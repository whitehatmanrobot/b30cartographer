ToPalSurf;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS16D8: Src palette not valid\n");

    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555 != NULL)
    {
        ULONG  ulPalSrcFlags = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).flPal();

        if (ulPalSrcFlags & PAL_RGB16_555)
        {
            pfnXlate = XLATEOBJ_RGB16_555ToPalSurf;
        }
        else if (ulPalSrcFlags & PAL_RGB16_565)
        {
            pfnXlate = XLATEOBJ_RGB16_565ToPalSurf;
        }

        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pusSrcTemp  = pusSrc;

           for (i = cStartPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp++);
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               *((ULONG*) (pjDstTemp)) = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+1))) << 8)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+2)))<< 16)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pusSrcTemp+3)))<< 24);
               pjDstTemp += 4;
               pusSrcTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pusSrcTemp++);
           }

           if (--cy == 0)
               break;

            pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }

    }
}

/**************************************************************************\
* vSrcCopyS24D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but 600 times faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS24D8(PBLTINFO psb)
{
    //
    // We assume we are doing left to right top to bottom blting
    //

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D8 - direction not up to down");

    ULONG cx         = psb->cx;
    ULONG cy         = psb->cy;
    PBYTE pjSrc      = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst      = psb->pjDst + psb->xDstStart;
    PBYTE pjDstEndY  = pjDst + cy * psb->lDeltaDst;
    PBYTE pjDstEnd;
    XLATE *pxlo      = psb->pxlo;
    PBYTE pxlate555  = NULL;
    PBYTE pjSrcTemp;
    PBYTE pjDstTemp;
    BYTE  r, g, b;
    BYTE  PaletteIndex1,PaletteIndex2,PaletteIndex3,PaletteIndex4;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    INT   i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS24D8: Src palette not valid\n");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555)
    {
        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pjSrcTemp  = pjSrc;

           for (i = cStartPixels; i != 0; i--)
           {
                b = *(pjSrcTemp  );
                g = *(pjSrcTemp+1);
                r = *(pjSrcTemp+2);

                *pjDstTemp = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

                pjDstTemp ++;
                pjSrcTemp += 3;
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex1 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex2 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex3 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               b = *(pjSrcTemp  );
               g = *(pjSrcTemp+1);
               r = *(pjSrcTemp+2);

               PaletteIndex4 = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

               pjSrcTemp += 3;

               *((ULONG*) (pjDstTemp)) = PaletteIndex1
                                   | (PaletteIndex2 << 8)
                                   | (PaletteIndex3 << 16)
                                   | (PaletteIndex4 << 24);
               pjDstTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
                b = *(pjSrcTemp  );
                g = *(pjSrcTemp+1);
                r = *(pjSrcTemp+2);

                *pjDstTemp = XLATEOBJ_RGB32ToPalSurf(pxlo,pxlate555,(b << 16) | (g << 8) | r);

                pjDstTemp ++;
                pjSrcTemp += 3;
           }

           if (--cy == 0)
               break;

           pjSrc += psb->lDeltaSrc;
           pjDst += psb->lDeltaDst;

        }

     }
}

/**************************************************************************\
* vSrcCopyS32D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but 600 times faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS32D8(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D8 - direction not up to down");

    PULONG pulSrcTemp;
    PBYTE  pjDstTemp;
    PULONG pulSrc = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PBYTE  pjDst  = psb->pjDst + psb->xDstStart;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    XLATE  *pxlo  = psb->pxlo;
    PBYTE  pxlate555 = NULL;
    ULONG  cStartPixels;
    ULONG  cMiddlePixels;
    ULONG  cEndPixels;
    INT    i;

    PFN_XLATE_RGB_TO_PALETTE pfnXlate = XLATEOBJ_ulIndexToPalSurf;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    //
    // match to the destination palette
    //

    ASSERTGDI(((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).bValid(),"vSrcCopyS32D8: Src palette not valid\n");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    //
    // determine source palette type, use specialized code for RGB and BGR formats
    //

    ULONG  ulPalSrcFlags = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).flPal();

    if (ulPalSrcFlags & PAL_RGB)
    {
        pfnXlate = XLATEOBJ_RGB32ToPalSurf;
    }
    else if (ulPalSrcFlags & PAL_BGR)
    {
        pfnXlate = XLATEOBJ_BGR32ToPalSurf;
    }

    //
    // get 555 to palete translate table
    //
    pxlate555 = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate555 != NULL)
    {
        //
        // translate bitmap
        //
        while(1)
        {
           // Write pixels a byte at a time until we're 'dword' aligned on
           // the destination:
           pjDstTemp = pjDst;
           pulSrcTemp  = pulSrc;

           for (i = cStartPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp++);
           }

           // Now write pixels a dword at a time.  This is almost a 4x win
           // over doing byte writes if we're writing to frame buffer memory
           // over the PCI bus on Pentium class systems, because the PCI
           // write throughput is so slow:

           for (i = cMiddlePixels; i != 0; i--)
           {
               *((ULONG*) (pjDstTemp)) = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+1))) << 8)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+2)))<< 16)
                                   | (((*pfnXlate)(pxlo,pxlate555,*(pulSrcTemp+3)))<< 24);
               pjDstTemp += 4;
               pulSrcTemp += 4;
           }

           // Take care of the end alignment:

           for (i = cEndPixels; i != 0; i--)
           {
               *pjDstTemp++ = (*pfnXlate)(pxlo,pxlate555,*pulSrcTemp++);
           }

           if (--cy == 0)
               break;

            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\strchblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: strchblt.cxx
*
* This contains the API and DDI entry points to the graphics engine
* for StretchBlt and EngStretchBlt.
*
* Created: 04-Apr-1991 10:57:37
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"

//the limit of our coordinate systems (2^27)
#define MAX_STRETCH_COOR 128000000L

ULONG gaulMonoExpand[] = {
    0x00000000,     //
    0x00000001,     // BMF_1BPP
    0x0000000F,     // BMF_4BPP
    0x000000FF,     // BMF_8BPP
    0x0000FFFF,     // BMF_16BPP
    0x00FFFFFF,     // BMF_24BPP
    0xFFFFFFFF      // BMF_32BPP
 };

/******************************Public*Routine******************************\
* GreStretchBlt
*
* Stretches the source image to the destination.
*
* Returns: TRUE if successful, FALSE for failure.
*
* History:
*  Thu Mar-05-1998 -by- Samer Arafeh [samera]
* Support LAYOUT_BITMAPORIENTATIONPRESERVED. Make sure
* to exit thru one of the RETURN_XXX labels if you are writing
* code past the layout code (see comments below).
*
*  Tue 02-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Fix clipping bugs
*
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  15-Jan-1992 -by- Patrick Haluptzok patrickh
* add mask support
*
*  Thu 19-Sep-1991 -by- Patrick Haluptzok [patrickh]
* add support for rops
*
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreStretchBlt(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor
)
{
    GDITraceHandle2(GreStretchBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %d, %d, %X, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc);
    return (GreStretchBltInternal(
                hdcTrg, x, y, cx, cy,
                hdcSrc, xSrc, ySrc, cxSrc, cySrc,
                rop4, crBackColor, 0));
}

BOOL GreStretchBltInternal(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor,
FLONG   ulFlags
)
{
    BLTRECORD   blt;
    BOOL bRet;
    POINTL ptOrgDst;
    DWORD  OrgRop4 = rop4, dwOldLayout;

    rop4 = rop4 & ~NOMIRRORBITMAP;

// [Bug #278291] - CAPTUREBLT
// The CAPTUREBLT rop flag is used for screen capture. When it's set, we bypass
// the sprite code which normally hides the sprites, so that the caller gets
// an exact copy of what's on the screen (except for the cursor).

    BOOL bCaptureBlt = 0;
    if (rop4 & CAPTUREBLT)
    {
        bCaptureBlt = 1;
        rop4 = rop4 & ~CAPTUREBLT;
    }

// Initialize the blt record

    blt.rop((rop4 | (rop4 & 0x00ff0000) << 8) >> 16);

// Convert the rop into something useful.

    ULONG ulAvec  = ((ULONG) gajRop3[blt.ropFore()]) |
                    ((ULONG) gajRop3[blt.ropBack()]);

// See if we can special case this operation

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
    // We can't require a mask, since one can't be passed.

        if (blt.ropFore() == blt.ropBack())
            return(NtGdiPatBlt(hdcTrg, x, y, cx, cy, rop4));
    }

// Lock the DC's, no optimization is made for same surface

    DCOBJ   dcoTrg(hdcTrg);
    DCOBJ   dcoSrc(hdcSrc);

    if (dcoTrg.bValid() && !dcoTrg.bStockBitmap())
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoTrg.pdc, dcoTrg.pdc->hbrush());
        }
    }

    if (!dcoTrg.bValid() ||
         dcoTrg.bStockBitmap() ||
        (!dcoSrc.bValid() && (ulAvec & AVEC_NEED_SOURCE)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(!(ulAvec & AVEC_NEED_SOURCE) || dcoSrc.bValid());
    }

// Lock the relevant surfaces

    DEVLOCKBLTOBJ dlo;

    if (ulAvec & AVEC_NEED_SOURCE)
        dlo.bLock(dcoTrg, dcoSrc);
    else
        dlo.bLock(dcoTrg);

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen());
    }

    if (!dcoTrg.bValidSurf() || !dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
    {
        if ((dcoTrg.dctp() == DCTYPE_INFO) || !dcoSrc.bValidSurf())
        {
            if (dcoTrg.fjAccum())
            {
                EXFORMOBJ   exo(dcoTrg, WORLD_TO_DEVICE);
                ERECTL      ercl(x, y, x + cx, y + cy);

                if (exo.bXform(ercl))
                {
                    ercl.vOrder();
                    dcoTrg.vAccumulate(ercl);
                }
            }

            // if we need a source and the source isn't valid, return failure

            return(TRUE);
        }

    // Do the security test on SCREEN to MEMORY blits.

        if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
        {
            if (!UserScreenAccessCheck())
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                return(FALSE);
            }
        }

    // If the source isn't a DISPLAY we should exit

        if (!dcoSrc.bDisplay())
            return(FALSE);
    }

    if(dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

// We can't require a mask, since one can't be passed.

    if (blt.ropFore() != blt.ropBack())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // ATTENTION: Please pay attention here
    //
    // Any code you are going to write past the following
    // section of code (mirroring code below that changes the
    // windows origin of the DC) should exit (return) -if it needs-
    // through either RETURN_FAIL, RETURN_FAIL_ONLY or RETURN_STATUS
    // labels by doing a goto statement to them. The reason for this
    // is to restore the DC's window origin by executing
    // the code located at the RETURN_STATUS label (see end of fn). [samera]

    //
    // Let's preserve the bitmap shape if the target DC
    // is a mirrored one. [samera]
    //
    if ( (((OrgRop4 & NOMIRRORBITMAP) && MIRRORED_DC(dcoTrg.pdc) ) ||
           MIRRORED_DC_NO_BITMAP_FLIP(dcoTrg.pdc)) &&
          (hdcSrc != hdcTrg) ) {
        dcoTrg.pdc->vGet_ptlWindowOrg( &ptOrgDst );
        dwOldLayout = dcoTrg.pdc->dwSetLayout(-1, 0);
        x = ptOrgDst.x - x - cx;

        // Restore the DC if the flag is in the DC and not part
        // of the Rops. [samera]
        //
        OrgRop4 = NOMIRRORBITMAP;
    } else {
        OrgRop4 = 0;
    }

    HANDLE hcmXform = NULL;

    // Don't put any goto's before here.
    //
    // [Bug #278291] - CAPTUREBLT
    // If we're doing a screen capture, hide the cursor, and set a
    // flag in the destination surface, to notify the sprite code.

    SURFACE *pSurfTrg = dcoTrg.pSurfaceEff();
    SURFACE *pSurfSrc = dcoSrc.pSurfaceEff();
    PDEVOBJ pdoSrc(pSurfSrc->hdev());
    POINTL pointerPos;

    if (bCaptureBlt)
    {
        if (dcoSrc.bDisplay()  &&
            !dcoSrc.bPrinter() &&
            (dcoSrc.hdev() == dcoTrg.hdev()))
        {
            ASSERTGDI(pSurfTrg, "Null destination surface");
            ASSERTGDI(pSurfSrc, "Null source surface");

            // Because the sprites are going to be visible, we must explicitly
            // hide the cursor (since it may be a sprite).

            // Grab the pointer semaphore to ensure that no-one else moves
            // the pointer until we restore it.

            GreAcquireSemaphoreEx(pdoSrc.hsemPointer(), SEMORDER_POINTER, dcoSrc.hsemDcDevLock());

            pointerPos = pdoSrc.ptlPointer();
            GreMovePointer(pSurfSrc->hdev(), -1, -1, MP_PROCEDURAL);

            // Set the 'IncludeSprites' flag in the destination surface. This tells
            // bSpBltFromScreen to include the sprites.

            pSurfTrg->vSetIncludeSprites();
        }
        else
        {
            // Clear bCaptureBlt, to bypass the cleanup code at the end.

            bCaptureBlt = 0;
        }
    }

// Fill the BLTRECORD

    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.pSurfTrg(dcoTrg.pSurfaceEff());
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);
    blt.pSurfSrc(dcoSrc.pSurfaceEff());
    blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
    blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());

    if (crBackColor == (COLORREF)-1)
        crBackColor = dcoSrc.pdc->ulBackClr();

// Initialize the color translation object.
//
// No ICM with StretchBlt() so pass NULL color transform to XLATEOBJ.

    if (ulFlags & STRETCHBLT_ENABLE_ICM)
    {
        hcmXform = dcoTrg.pdc->hcmXform();
    }

    if (!blt.pexlo()->bInitXlateObj(hcmXform,               // hColorTransform
                                    dcoTrg.pdc->lIcmMode(), // ICM mode
                                   *blt.ppoSrc(),
                                   *blt.ppoTrg(),
                                   *blt.ppoSrcDC(),
                                   *blt.ppoTrgDC(),
                                    dcoTrg.pdc->crTextClr(),
                                    dcoTrg.pdc->crBackClr(),
                                    crBackColor))
    {
        WARNING("bInitXlateObj failed in StretchBlt\n");
        goto RETURN_FAIL_ONLY;
    }

    blt.flSet(BLTREC_PXLO);

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        // Set up the brush if necesary.
        blt.pbo(dcoTrg.peboFill());

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg());
        }

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());
    }
    else
    {
        blt.pbo (NULL);
    }

// Initialize some stuff for DDI.

    blt.pSurfMsk((SURFACE  *) NULL);

// Set the source rectangle

    if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cxSrc, cySrc))
    {
        goto RETURN_FAIL;
    }

// Don't call the driver with an empty source rectangle.

    if((ulAvec & AVEC_NEED_SOURCE) &&
       (blt.perclSrc()->bEmpty()))
    {
        // We really should fail here, but return TRUE in order to maintain
        // backward compatibility.
        bRet = TRUE;
        goto RETURN_STATUS;
    }

// Now all the essential information has been collected.  We now
// need to check for promotion or demotion and call the appropriate
// method to finish the blt.  If we rotate we must send the call away.

    if (blt.pxoTrg()->bRotation())
    {
        blt.TrgPlg(x, y, cx, cy);
        bRet = blt.bRotate(dcoTrg, dcoSrc, ulAvec,  dcoTrg.pdc->jStretchBltMode());
        goto RETURN_STATUS;
    }

// We can now set the target rectangle

    if (!blt.Trg(x, y, cx, cy))
    {
        goto RETURN_FAIL;
    }

// If we are halftoning or the extents aren't equal, call bStretch

    if (( dcoTrg.pdc->jStretchBltMode() == HALFTONE) || !blt.bEqualExtents()) {
        bRet = blt.bStretch(dcoTrg, dcoSrc, ulAvec,  dcoTrg.pdc->jStretchBltMode() );
        goto RETURN_STATUS;
    }

// Since there can't be a mask, call bBitBlt.

    bRet = blt.bBitBlt(dcoTrg, dcoSrc, ulAvec);
    goto RETURN_STATUS;


RETURN_FAIL:

    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

RETURN_FAIL_ONLY:

    bRet = FALSE;

RETURN_STATUS:
    if (OrgRop4 & NOMIRRORBITMAP) {
        dcoTrg.pdc->dwSetLayout(-1, dwOldLayout);
    }

    // [Bug #278291] - CAPTUREBLT
    // Undo what was done above

    if (bCaptureBlt)
    {
        // Clear the flag

        pSurfTrg->vClearIncludeSprites();

        // Restore the cursor

        GreMovePointer(pSurfSrc->hdev(),
                       pointerPos.x,
                       pointerPos.y,
                       MP_PROCEDURAL);
            
        GreReleaseSemaphoreEx(pdoSrc.hsemPointer());

    }

    return bRet;
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dcoTrg, dcoSrc, ulAvec, jMode)
*
* Do a stretch blt from the blt record
*
* History:
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
DCOBJ&  dcoTrg,
DCOBJ&  dcoSrc,
ULONG   ulAvec,
BYTE    jMode)
{
// Make the target rectangle well ordered and remember flips.

    vOrderStupid(perclTrg());

// before we do a pattern only blt.  The mask will be replaced in the
// BLTRECORD and its offset correctly adjusted.

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        vOrderStupid(perclMask());

    // Before we call to the driver, validate that the mask will actually
    // cover the entire target.

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
                (aptlMask[1].y > pSurfMsk()->sizl().cy))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }

        SURFMEM   dimoMask;

        if ((ulAvec & AVEC_NEED_MASK) && !bStretch(dimoMask, (ULONG) jMode))
            return(FALSE);

    // Now, we need to fake out the source extents for the mask

        aptlSrc[1].x = aptlSrc[0].x + (aptlTrg[1].x - aptlTrg[0].x);
        aptlSrc[1].y = aptlSrc[0].y + (aptlTrg[1].y - aptlTrg[0].y);

        return(bBitBlt(dcoTrg, dcoTrg, ulAvec));
    }

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());

    // WINBUG #298689 4-4-2001 jasonha  Handle any device stretch to Meta
    BOOL bTrgMetaDriver = (dcoTrg.bSynchronizeAccess() && pdoTrg.bValid() && pdoTrg.bMetaDriver());

    // If the devices are on different PDEV's and we are not targeting a meta driver
    // we can only call driver if the Engine manages one or both of the surfaces.
    // Check for this.

    // WINBUG #256643 12-13-2000 bhouse Need to review handling of cross device operatons
    // We need to review this logic.  This check and others like it are spread
    // throughout GDI and are in some cases now outdated.  For example, there
    // is no reason not to call the multi-mon driver as a target.
    // We are fixing this case now but we should examine this check in light
    // of other possible cases.

    if (dcoTrg.hdev() != dcoSrc.hdev())
    {
        if (!bTrgMetaDriver)
        {
            if(((dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP)
             || (dcoTrg.pSurfaceEff()->dhsurf() != NULL)) &&
            ((dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
             || (dcoSrc.pSurfaceEff()->dhsurf() != NULL)))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }
        }
    }


// Before we get too involved, validate that the mask will actually
// cover the entire source.

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if ((aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
            (aptlMask[1].y > pSurfMsk()->sizl().cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

// Make the source rectangle well ordered and remember flips.

    vOrderStupid(perclSrc());
    vOrderAmnesia(perclMask());

// Win 3.1 has a lovely little 'feature' where they decide
// you called StretchBlt but you really didn't mean it.  This
// ludicrous behaviour needs to be supported forever because
// some pinhead applications have grown to rely on this act
// of insanity.  Flips cancel this, since EngBitBlt can't
// handle negative extents. Also note that we can't fail to
// call DanielC if HALFTONE has been requested. [donalds]

    if ((jMode != HALFTONE) &&
        (dcoTrg.pdc->iGraphicsMode() != GM_ADVANCED) &&
        (pSurfMskOut() == (SURFACE *) NULL) &&
        !(flState & (BLTREC_MIRROR_X | BLTREC_MIRROR_Y)))
    {
        LONG    lHStr = (perclTrg()->right - perclTrg()->left) -
                        (perclSrc()->right - perclSrc()->left);

        LONG    lVStr = (perclTrg()->bottom - perclTrg()->top) -
                        (perclSrc()->bottom - perclSrc()->top);

        if ((lHStr >= -1) && (lHStr <= 1) &&
            (lVStr >= -1) && (lVStr <= 1))
            return(bBitBlt(dcoTrg, dcoSrc, ulAvec, lHStr, lVStr));
    }


// Accumulate bounds.  We can do this before knowing if the operation is
// successful because bounds can be loose.

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*perclTrg());

// With a fixed DC origin we can change the rectangles to SCREEN coordinates.

    *perclTrg() += dcoTrg.eptlOrigin();
    *perclSrc() += dcoSrc.eptlOrigin();

// Compute the clipping complexity and maybe reduce the exclusion rectangle.

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), *perclTrg());

// Check the destination which is reduced by clipping.

    if (eco.erclExclude().bEmpty())
        return(TRUE);

// Compute the exclusion rectangle.

    ERECTL erclExclude = eco.erclExclude();

// If we are going to the same source, prevent bad overlap situations

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        if (perclSrc()->left   < erclExclude.left)
            erclExclude.left   = perclSrc()->left;

        if (perclSrc()->top    < erclExclude.top)
            erclExclude.top    = perclSrc()->top;

        if (perclSrc()->right  > erclExclude.right)
            erclExclude.right  = perclSrc()->right;

        if (perclSrc()->bottom > erclExclude.bottom)
            erclExclude.bottom = perclSrc()->bottom;
    }

// We might have to exclude the source or the target, get ready to do either.

    DEVEXCLUDEOBJ dxo;

    PDEVOBJ pdoSrc(pSurfSrc()->hdev());

// They can't both be display

    if (dcoSrc.bDisplay())
    {
        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);

        if (dcoSrc.pSurface() == dcoTrg.pSurface())
            ercl *= erclExclude;
        else
            ercl *= *perclSrc();

        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
    }
    else if (dcoTrg.bDisplay())
        dxo.vExclude(dcoTrg.hdev(),&erclExclude,&eco);

// Dispatch the call.

    PFN_DrvStretchBltROP pfn = PPFNGET(pdoTrg, StretchBltROP, pSurfTrg()->flags());

    if (!bTrgMetaDriver)
    {
        if (jMode == HALFTONE)
        {
            // Don't call the driver if it doesn't do halftone.
            if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }

        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        // Don't call the driver if the source rectangle exceeds the source
        // surface. Some drivers punt using a duplicate of the source
        // SURFOBJ, but without preserving its sizlBitmap member.

        BOOL bSrcExceeds = FALSE;

        if(pSurfSrc()->iType() == STYPE_DEVICE && pdoSrc.bValid() && pdoSrc.bMetaDriver())
        {
            if((perclSrc()->left < pdoSrc.pptlOrigin()->x ) ||
               (perclSrc()->top  < pdoSrc.pptlOrigin()->y ) ||
               (perclSrc()->right > pdoSrc.pptlOrigin()->x + pSurfSrc()->sizl().cx) ||
               (perclSrc()->bottom > pdoSrc.pptlOrigin()->y + pSurfSrc()->sizl().cy))
            {
                bSrcExceeds = TRUE;
            }

        }
        else
        {
            if((perclSrc()->left < 0) ||
               (perclSrc()->top  < 0) ||
               (perclSrc()->right  > pSurfSrc()->sizl().cx) ||
               (perclSrc()->bottom > pSurfSrc()->sizl().cy))
            {
                bSrcExceeds = TRUE;
            }
        }

        if( bSrcExceeds )
        {
            pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }

        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        // Don't call the driver if the source overlaps the destination.
        // Some drivers don't handle this case.
        
        if ((pSurfTrg() == pSurfSrc()) &&
            bIntersect(perclSrc(), perclTrg()))
        {
            pfn = (PFN_DrvStretchBltROP)EngStretchBltROP;
        }
    }

// Deal with target mirroring

    vMirror(perclTrg());

// Inc the target surface uniqueness

    INC_SURF_UNIQ(pSurfTrg());

    return((*pfn)(pSurfTrg()->pSurfobj(),
               pSurfSrc()->pSurfobj(),
               (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : pSurfMskOut()->pSurfobj(),
               &eco,
               pexlo()->pxlo(),
               (dcoTrg.pColorAdjustment()->caFlags & CA_DEFAULT) ?
                   (PCOLORADJUSTMENT)NULL : dcoTrg.pColorAdjustment(),
               &dcoTrg.pdc->ptlFillOrigin(),
               perclTrg(),
               perclSrc(),
               aptlMask,
               jMode,
               pbo(),
               rop4));
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dimo, iMode)
*
* Stretch just the mask.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
SURFMEM& dimo,
ULONG    iMode)
{
// Use the ordered target extents for the size

    DEVBITMAPINFO   dbmi;

    dbmi.iFormat  = BMF_1BPP;
    dbmi.cxBitmap = aptlTrg[1].x - aptlTrg[0].x;
    dbmi.cyBitmap = aptlTrg[1].y - aptlTrg[0].y;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.fl       = pSurfMskOut()->bUMPD() ? UMPD_SURFACE : 0;

// Build a shadow rectangle.

    ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

// Take care of mirroring.

    vMirror(&erclTrg);

    dimo.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimo.bValid())
        return(FALSE);

// Call EngStretchBlt to stretch the mask.

    EPOINTL ptl(0,0);

    if (!EngStretchBlt(dimo.pSurfobj(),
                        pSurfMskOut()->pSurfobj(),
                        (SURFOBJ *) NULL,
                        (CLIPOBJ *) NULL,
                        NULL,
                        NULL,
                        (POINTL *)&ptl,
                        &erclTrg,
                        perclMask(),
                        (POINTL *) NULL,
                        iMode))
        {
            return(FALSE);
        }

// Adjust the mask origin.

    aptlMask[0].x = 0;
    aptlMask[0].y = 0;

// Release the previous pSurfMask, tell ~BLTRECORD its gone and put the
// new DIB in its place.

    flState &= ~BLTREC_MASK_LOCKED;
    pSurfMsk()->vAltUnlockFast();
    pSurfMsk((SURFACE  *) dimo.ps);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bStretch(dcoSrc, dimoShadow, dimoMask, ulAvec)
*
* Stretch the shadow and mask.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bStretch(
DCOBJ&     dcoSrc,
SURFMEM&   dimoShadow,
SURFMEM&   dimoMask,
ULONG      ulAvec,
ULONG      iMode)
{
// If there is a mask, stretch it.

    if ((ulAvec & AVEC_NEED_MASK) && !bStretch(dimoMask, iMode))
        return(FALSE);

// Use the ordered target extents for the size

    DEVBITMAPINFO   dbmi;

    dbmi.cxBitmap = aptlTrg[1].x - aptlTrg[0].x;
    dbmi.cyBitmap = aptlTrg[1].y - aptlTrg[0].y;
    dbmi.hpal     = 0;
    dbmi.iFormat  = pSurfSrc()->iFormat();
    dbmi.fl       = pSurfSrc()->bUMPD() ? UMPD_SURFACE : 0;

// Build a shadow rectangle.

    ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

// Take care of mirroring.

    vMirror(&erclTrg);

    dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimoShadow.bValid())
        return(FALSE);

// Now comes the tricky part.  The source may be a display.  While it may
// be somewhat faster to assume it isn't, code would be much more complex.

    {
    // Adjust the source rectangle.

        *perclSrc() += dcoSrc.eptlOrigin();

    // Exclude the pointer.

        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);
        ercl *= *perclSrc();

        DEVEXCLUDEOBJ dxo(dcoSrc, &ercl);

        EPOINTL ptl(0,0);

    // Stretch the bits to the DIB.

        if (!EngStretchBlt(dimoShadow.pSurfobj(),
                           pSurfSrc()->pSurfobj(),
                           (SURFOBJ *) NULL,
                           (CLIPOBJ *) NULL,
                           NULL,
                           NULL,
                           (POINTL *)&ptl,
                           &erclTrg,
                           perclSrc(),
                           (POINTL *) NULL,
                           iMode))
        {
            return(FALSE);
        }

    // Update the source surface and origin.

        pSurfSrc((SURFACE  *) dimoShadow.ps);

        perclSrc()->left   = -dcoSrc.eptlOrigin().x;
        perclSrc()->top    = -dcoSrc.eptlOrigin().y;
        perclSrc()->right  = dbmi.cxBitmap - dcoSrc.eptlOrigin().x;
        perclSrc()->bottom = dbmi.cyBitmap - dcoSrc.eptlOrigin().y;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrder(percl)
*
* Make the rectangle well ordered, remembering how we flipped.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrder(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        flState ^= BLTREC_MIRROR_X;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        flState ^= BLTREC_MIRROR_Y;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrderStupid(percl)
*
* Make the rectangle well ordered, remembering how we flipped.  Uses the
* Win3.1 compatible swap method.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrderStupid(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        percl->left++;
        percl->right++;

        flState ^= BLTREC_MIRROR_X;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        percl->top++;
        percl->bottom++;

        flState ^= BLTREC_MIRROR_Y;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vOrderAmnesia(percl)
*
* Make the rectangle well ordered.  Uses the Win 3.1 compatible swap
* method.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vOrderAmnesia(ERECTL *percl)
{
    LONG    l;

    if (percl->left > percl->right)
    {
        l = percl->left, percl->left = percl->right, percl->right = l;

        percl->left++;
        percl->right++;
    }

    if (percl->top > percl->bottom)
    {
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;

        percl->top++;
        percl->bottom++;
    }
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vMirror(percl)
*
* Flip the rectangle according to the mirroring flags
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vMirror(ERECTL *percl)
{
    LONG    l;

    if (flState & BLTREC_MIRROR_X)
        l = percl->left, percl->left = percl->right, percl->right = l;

    if (flState & BLTREC_MIRROR_Y)
        l = percl->top, percl->top = percl->bottom, percl->bottom = l;
}


/******************************Public*Routine******************************\
* VOID BLTRECORD::bBitBlt(dcoTrg, dcoSrc, ul, lH, lV)
*
* Do a near-miss ???BitBlt instead of ???StretchBlt.
*
* History:
*  12-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#define PUT_RECTS  erclTrg = *perclTrg(); erclSrc = *perclSrc()
#define GET_RECTS  *perclSrc() = erclSrc; *perclTrg() = erclTrg

BOOL BLTRECORD::bBitBlt(
DCOBJ& dcoTrg,
DCOBJ& dcoSrc,
ULONG  ulAvec,
LONG   lHStr,
LONG   lVStr)
{
    ERECTL  erclTrg;
    ERECTL  erclSrc;
    BOOL    bHack;

    switch (lHStr)
    {
    case -1:
        perclSrc()->right--;

        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            return(bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    case 0:
        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            return(bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    case 1:
        perclTrg()->right--;

        if (lVStr == 1)
        {
            perclTrg()->bottom--;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            bHack &= bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;

            bHack &= bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->top = perclTrg()->bottom;
            perclTrg()->bottom++;
            perclSrc()->top = perclSrc()->bottom - 1;
            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        else
        {
            perclSrc()->bottom += lVStr;

            PUT_RECTS;
            bHack = bBitBlt(dcoTrg, dcoSrc, ulAvec);
            GET_RECTS;

            perclTrg()->left = perclTrg()->right;
            perclTrg()->right++;
            perclSrc()->left = perclSrc()->right - 1;

            return(bHack & bBitBlt(dcoTrg, dcoSrc, ulAvec));
        }
        break;

    default:
        break;
    }
    return FALSE;
}

#ifdef  DBG_STRBLT
LONG gflStrBlt = 0;

VOID vShowRect(
CHAR  *psz,
RECTL *prcl)
{
    if (gflStrBlt & STRBLT_RECTS)
        DbgPrint("%s [(%ld,%ld) (%ld,%ld)]\n",
                  psz, prcl->left, prcl->top, prcl->right, prcl->bottom);
}
#endif

/******************************Public*Routine******************************\
* EngStretchBlt
*
* This does stretched bltting.  The source rectangle is stretched to fit
* the target rectangle.
*
* NOTE! The source rectangle MUST BE WELL ORDERED IN DEVICE SPACE.
*
* This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote.
\**************************************************************************/

BOOL EngStretchBlt(
SURFOBJ         *psoTrg,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclTrg,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode)
{
    //
    // Prevent bad driver call backs
    //

    if ((iMode == 0) || (iMode > MAXSTRETCHBLTMODE))
    {
        WARNING1("EngStretchBlt: Unsupported iMode\n");
        return(FALSE);
    }

    PSURFACE pSurfTrg  = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMask = SURFOBJ_TO_SURFACE(psoMask);

    //
    // Can't StretchBlt to an RLE
    // Can't StretchBlt to/from a JPEG or PNG
    //

    if ((pSurfTrg->iFormat() == BMF_4RLE) ||
        (pSurfTrg->iFormat() == BMF_8RLE) ||
        (pSurfTrg->iFormat() == BMF_JPEG) ||
        (pSurfSrc->iFormat() == BMF_JPEG) ||
        (pSurfTrg->iFormat() == BMF_PNG ) ||
        (pSurfSrc->iFormat() == BMF_PNG ))
    {
        WARNING1("EngStretchBlt: Unsupported source/target\n");
        return(FALSE);
    }

    //
    // If the source or target rectangles are empty, don't bother.
    //

    if ((prclSrc->left == prclSrc->right) || (prclSrc->top == prclSrc->bottom) ||
        (prclTrg->left == prclTrg->right) || (prclTrg->top == prclTrg->bottom))
        return(TRUE);

    //
    // Get the LDEV for the target and source surfaces
    //

    PDEVOBJ   pdoTrg( pSurfTrg->hdev());
    PDEVOBJ   pdoSrc( pSurfSrc->hdev());

    //
    // We should have gone to the Mul layer if the destination
    // is a meta.
    //

    ASSERTGDI( !( psoTrg->iType != STYPE_BITMAP && pdoTrg.bValid()
        && pdoTrg.bMetaDriver()),
        "EngStretchBlt called with a destination meta device" );

    //
    // We cannot handle cases where the source is a meta,
    // so make a copy in this case.
    //

    SURFMEM  srcCopy;
    RECTL    rclCopy = *prclSrc;

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() &&
       pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE;

        if(srcCopy.ps == NULL )
        {
            // We didn't get to the point of creating the surface
            // becasue the rect was out of bounds.
            return TRUE;
        }

        prclSrc = &rclCopy;
        psoSrc   = srcCopy.pSurfobj();
        pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    //
    // CMYK based source bitmap support.
    //
    // limilation:
    //  - Source surface must be STYPE_BITMAP, since we can't read CMYK surface from device.
    //  - Target surface must be STYPE_DEVICE, since other Eng function can't handle.
    //  - Source surface must not be same as target surface.
    //  - No mask surface.
    //  - No halftone mode, since EngHTBlt can't handle.
    //

    BOOL bSrcCMYKColor = (pxlo && (pxlo->flXlate & XO_FROM_CMYK)) ? TRUE : FALSE;

    if (bSrcCMYKColor)
    {
        WARNING("EngStretchBlt called with XO_FROM_CMYK - limited support");

        // source surface must be STYPE_BITMAP.
        // target surface must be STYPE_DEVICE.
        // Must be no mask

        if ((psoSrc->iType != STYPE_BITMAP) ||
            (psoTrg->iType != STYPE_DEVICE) ||
            (psoMask != NULL))
        {
            return (FALSE);
        }
    }

    //
    // Send Halftoning to DanielC.
    //

    if (iMode == HALFTONE)
    {
        //
        // If source bitmap is CMYK, EngHTBlt can't handle.
        //

        if (bSrcCMYKColor)
        {
            return (FALSE);
        }

        int iRet = EngHTBlt(psoTrg,
                           psoSrc,
                           psoMask,
                           pco,
                           pxlo,
                           pca,
                           pptlBrushOrg,
                           prclTrg,
                           prclSrc,
                           pptlMask,
                           0,
                           NULL);

        switch (iRet)
        {
        case HTBLT_ERROR:
            return(FALSE);

        case HTBLT_SUCCESS:
            return(TRUE);

        case HTBLT_NOTSUPPORTED:
            iMode = COLORONCOLOR;
            break;
        };
    }

#ifdef  DBG_STRBLT
    if (!(gflStrBlt & STRBLT_ENABLE))
    {
        POINTFIX    aptfx[3];

        aptfx[0].x = FIX_FROM_LONG(prclTrg->left);
        aptfx[0].y = FIX_FROM_LONG(prclTrg->top);
        aptfx[1].x = FIX_FROM_LONG(prclTrg->right);
        aptfx[1].y = FIX_FROM_LONG(prclTrg->top);
        aptfx[2].x = FIX_FROM_LONG(prclTrg->left);
        aptfx[2].y = FIX_FROM_LONG(prclTrg->bottom);

        return(EngPlgBlt(psoTrg,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     aptfx,
                     prclSrc,
                     pptlMask,
                     iMode));
    }

    if (gflStrBlt & STRBLT_FORMAT)
    {
        LONG foo[] = { 0, 1, 4, 8, 16, 24, 32 };

        DbgPrint("Target = %2ldBPP, Source = %2ldBPP\n",
                  foo[pSurfTrg->iFormat()],
                  foo[pSurfSrc->iFormat()]);

    }
#endif

    //
    // We may have to 'mirror'.
    //

    FLONG   flMirror = 0;

    if (prclTrg->bottom < prclTrg->top)
    {
        LONG lTemp = prclTrg->top;
        prclTrg->top = prclTrg->bottom;
        prclTrg->bottom = lTemp;

        flMirror |= STRBLT_MIRROR_Y;
    }

    if (prclTrg->right < prclTrg->left)
    {
        LONG lTemp = prclTrg->left;
        prclTrg->left = prclTrg->right;
        prclTrg->right = lTemp;

        flMirror |= STRBLT_MIRROR_X;
    }

    //
    // We may need to do a WHITEONBLACK or BLACKONWHITE from a monochrome source.
    // Find out and set the bogusity flag.
    //

    BOOL bBogus = ((iMode < COLORONCOLOR) &&
                   (pSurfMask == (SURFACE *) NULL));

    //
    // Bogusity mode only applies on shrinking blts.  Test the dx/dy for source
    // and targets and see if it still applies.
    //

    if (bBogus)
    {
        if (((prclTrg->right - prclTrg->left) >= (prclSrc->right - prclSrc->left)) &&
            ((prclTrg->bottom - prclTrg->top) >= (prclSrc->bottom - prclSrc->top)))
            bBogus = FALSE;
    }

    //
    // If we don't need bogusity, eliminate it.
    //

    if ((!bBogus) && (iMode < COLORONCOLOR))
        iMode = COLORONCOLOR;

    //
    // Many display drivers have fast-paths for stretches that handle only
    // source formats that are the same as the destination format, and only
    // with identity translates.  They also typically handle only STYPE_BITMAP
    // formats.
    //
    // So we will consider making a copy of the source bitmap up-front to
    // remove any translations and also to convert non-STYPE_BITMAP formats.
    //
    // Note that this isn't terribly efficient when clipping is involved,
    // but that will be a later optimization...
    //

    if (!pSurfTrg->bUMPD() &&
        (((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL)) ||
         (psoSrc->iType != STYPE_BITMAP)))
    {
        //
        // To go any further, the driver must of course hook StretchBlt.
        //
        // In addition, we'll add some further restrictions here to make
        // our life easier.  The driver's fast paths typically handle only
        // stretches that are non-inverting, don't involve a mask, and don't
        // have source clipping, and we'll do the same (otherwise we'd have
        // to add more code):
        //
        // Note that some drivers (specifically the Weitek driver) have a
        // bug where they set "psoDst = ppdev->psoPunt" and then call
        // EngStretchBlt on that.  This would work fine, except that they
        // had also called EngAssociateSurface on the surface and said they
        // hooked STRETCHBLT for that punt surface -- which is a lie because
        // they fall over if we call DrvStretchBlt on that punt surface!
        // (They don't really expect their DrvStretchBlt routine to be called
        // for an engine-managed surface, even though that's what they're
        // saying they support via the EngAssociateSurface call.)  So
        // we add a (pSurfTrg->iType() != STYPE_BITMAP) check and don't
        // execute this fast-path at all for engine-managed surfaces, and
        // thus we avoid driver bugs like the Weitek's.
        //

        //
        // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
        //
        // Actually, we must NEVER call the driver if there is source
        // clipping. Some drivers punt using a duplicate of the source
        // SURFOBJ, but without preserving its sizlBitmap member.
        //

        if ((pSurfTrg->iType() != STYPE_BITMAP)         &&
            (pSurfTrg->flags() & HOOK_STRETCHBLT)       &&
            (flMirror == 0)                             &&
            (psoMask == NULL)                           &&
            (prclSrc->left >= 0)                        &&
            (prclSrc->top >= 0)                         &&
            (prclSrc->right <= psoSrc->sizlBitmap.cx)   &&
            (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
        {
            SIZEL      sizlNewSrc;
            HSURF       hsurfNewSrc;
            SURFOBJ    *psoNewSrc;
            RECTL       rclNew;
            BOOL        bRet;

            sizlNewSrc.cx = prclSrc->right - prclSrc->left;
            sizlNewSrc.cy = prclSrc->bottom - prclSrc->top;

            if ((sizlNewSrc.cx <= (prclTrg->right - prclTrg->left)) &&
                (sizlNewSrc.cy <= (prclTrg->bottom - prclTrg->top)))
            {
                hsurfNewSrc = (HSURF) EngCreateBitmap(sizlNewSrc,
                                                      0,
                                                      psoTrg->iBitmapFormat,
                                                      0,
                                                      NULL);

                psoNewSrc = EngLockSurface(hsurfNewSrc);

                if (psoNewSrc)
                {
                    //
                    // Bug #69739
                    //
                    // Set uniqueness to zero so that the driver does not bother
                    // trying to cache the temporary bitmap.
                    //
                    psoNewSrc->iUniq = 0;

                    rclNew.left   = 0;
                    rclNew.top    = 0;
                    rclNew.right  = sizlNewSrc.cx;
                    rclNew.bottom = sizlNewSrc.cy;

                    bRet = (PPFNGET(pdoSrc, CopyBits, pSurfSrc->flags())
                                                       (psoNewSrc,
                                                        psoSrc,
                                                        NULL,
                                                        pxlo,
                                                        &rclNew,
                                                        (POINTL*) prclSrc))
                        && (PPFNDRV(pdoTrg, StretchBlt)(psoTrg,
                                                        psoNewSrc,
                                                        psoMask,
                                                        pco,
                                                        NULL,
                                                        pca,
                                                        pptlBrushOrg,
                                                        prclTrg,
                                                        &rclNew,
                                                        pptlMask,
                                                        iMode));

                    EngUnlockSurface(psoNewSrc);
                    EngDeleteSurface(hsurfNewSrc);

                    return(bRet);
                }
            }
        }
    }

    //
    // Set up frame variables for possible switch to temporary output surface
    //

    SURFMEM     dimoOut;
    SURFACE    *pSurfOut;
    RECTL       rclOut;
    RECTL      *prclOut;
    ECLIPOBJ    ecoOut;
    CLIPOBJ    *pcoOut;
    ERECTL      erclDev;
    EPOINTL     eptlDev;
    ERECTL      erclTrim(0, 0, pSurfSrc->sizl().cx, pSurfSrc->sizl().cy);
    RECTL       rclTrim;
    RGNMEMOBJTMP rmoOut;

    //
    // If the target is not a DIB, or the target and source are on the same
    // surface and the extents overlap, create a target DIB of the needed
    // size and format.
    //

    if ((pSurfTrg->iType() == STYPE_BITMAP) &&
        (pSurfTrg->hsurf() !=  pSurfSrc->hsurf()))
    {
        pSurfOut   = pSurfTrg;
        prclOut  = prclTrg;
        pcoOut   = pco;
    }
    else
    {
        rclOut = *prclTrg;

        erclDev.left   = rclOut.left - 1;
        erclDev.top    = rclOut.top - 1;
        erclDev.right  = rclOut.right + 1;
        erclDev.bottom = rclOut.bottom + 1;

        //
        // Trim to the target surface.
        //

        ERECTL  erclTrg(0, 0, pSurfTrg->sizl().cx, pSurfTrg->sizl().cy);

#ifdef DBG_STRBLT
        vShowRect("Trg Rect", (RECTL *) &erclDev);
        vShowRect("Trg Surf", (RECTL *) &erclTrg);
#endif

        erclDev *= erclTrg;

        //
        // If we have nothing left, we're done.
        //

        if (erclDev.bEmpty())
            return(TRUE);

#ifdef DBG_STRBLT
        vShowRect("Trg Surf & Rect", (RECTL *) &erclDev);
#endif

        //
        // If we are only here on possible overlap, test for misses
        //

        if (( pSurfTrg->iType() == STYPE_BITMAP) &&
            ((erclDev.left > prclSrc->right) || (erclDev.right < prclSrc->left) ||
             (erclDev.top > prclSrc->bottom) || (erclDev.bottom < prclSrc->top)))
        {
            pSurfOut   = pSurfTrg;
            prclOut  = prclTrg;
            pcoOut   = pco;
        }
        else
        {
            //
            // Compute the adjusted rectangle in the temporary surface.
            //

            rclOut.left   -= erclDev.left;
            rclOut.top    -= erclDev.top;
            rclOut.right  -= erclDev.left;
            rclOut.bottom -= erclDev.top;

            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclDev.right - erclDev.left + 1;
            dbmi.cyBitmap = erclDev.bottom - erclDev.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            if (bSrcCMYKColor)
            {
                //
                // On CMYK color mode, create temporary surface based on source surface.
                //
                dbmi.iFormat = pSurfSrc->iFormat();
            }
            else
            {
                dbmi.iFormat = pSurfTrg->iFormat();
            }
            dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

#ifdef DBG_STRBLT
            if (gflStrBlt & STRBLT_ALLOC)
            {
                DbgPrint("Allocating temporary target\n");
                DbgPrint("Size (%lx, %lx)\n", dbmi.cxBitmap, dbmi.cyBitmap);
                DbgPrint("Format = %lx\n", dbmi.iFormat);
            }
#endif

            dimoOut.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoOut.bValid())
                return(FALSE);

            //
            // What point in the target surface is 0,0 in temporary surface.
            //

            eptlDev = *((EPOINTL *) &erclDev);

            //
            // Build a CLIPOBJ for the new surface.
            //

            if (!rmoOut.bValid())
                return(FALSE);

            erclDev.left    = 0;
            erclDev.top     = 0;
            erclDev.right  -= eptlDev.x;
            erclDev.bottom -= eptlDev.y;

#ifdef DBG_STRBLT
            vShowRect("Trg Clip", (RECTL *) &erclDev);
#endif
            rmoOut.vSet((RECTL *) &erclDev);

            ecoOut.vSetup(rmoOut.prgnGet(), erclDev, CLIP_FORCE);

            //
            // Synchronize with the device driver before touching the device surface.
            //

            {
                PDEVOBJ po( pSurfTrg->hdev());
                po.vSync(pSurfTrg->pSurfobj(),NULL,0);
            }

            //
            // If there is a mask, copy the actual target to the temporary.
            //

            if (pSurfMask != (SURFACE *) NULL)
            {
                (*PPFNGET(pdoTrg,CopyBits,  pSurfTrg->flags()))(
                          dimoOut.pSurfobj(),
                          pSurfTrg->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &erclDev,
                          &eptlDev);
            }

            //
            // Point to the new target.
            //

            pSurfOut = dimoOut.ps;
            prclOut  = &rclOut;
            pcoOut   = &ecoOut;
        }
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ po( pSurfSrc->hdev());
        po.vSync(psoSrc,NULL,0);
    }

    //
    // Compute what area of the source surface will actually be used.  We do
    // this so we never read off the end of the surface and fault or worse,
    // write bad pixels onto the target. Trim the source rectangle to the
    // source surface.
    //

#ifdef DBG_STRBLT
    vShowRect("Src Surf", (RECTL *) &erclTrim);
    vShowRect("Src Rect", prclSrc);
#endif

    erclTrim *= *prclSrc;

#ifdef DBG_STRBLT
    vShowRect("Src Surf & Src Rect", (RECTL *) &erclTrim);
#endif

    //
    // If we have nothing left, we're done.
    //

    if (erclTrim.bEmpty())
        return(TRUE);

    //
    // Now we must worry about the source surface.  Its possible we are blitting
    // from an RLE to the VGA for instance.  We convert the surface to the same
    // bitmap format as the target for convience.
    //

    SURFMEM     dimoIn;
    SURFACE    *pSurfIn;
    RECTL       rclIn;
    RECTL      *prclIn;
    XLATEOBJ   *pxloIn;

    if ((flMirror == 0) &&
        ( pSurfSrc->iType() == STYPE_BITMAP)    &&
        ( pSurfSrc->iFormat() != BMF_4RLE)      &&
        ( pSurfSrc->iFormat() != BMF_8RLE))
    {
        pSurfIn  = pSurfSrc;
        if (bSrcCMYKColor)
        {
            //
            // The surface will be kept as compatible as source, so no translation at this point.
            //
            pxloIn = NULL;
        }
        else
        {
            pxloIn = pxlo;
        }
        prclIn = prclSrc;
    }
    else
    {
        DEVBITMAPINFO   dbmi;

        dbmi.cxBitmap = erclTrim.right - erclTrim.left;
        dbmi.cyBitmap = erclTrim.bottom - erclTrim.top;
        dbmi.hpal     = (HPALETTE) 0;
        if (bSrcCMYKColor)
        {
            //
            // On CMYK color mode, create temporary surface based on source surface.
            //
            dbmi.iFormat = pSurfSrc->iFormat();
        }
        else
        {
            dbmi.iFormat = pSurfOut->iFormat();
        }
        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

#ifdef DBG_STRBLT
            if (gflStrBlt & STRBLT_ALLOC)
            {
                DbgPrint("Allocating temporary source\n");
                DbgPrint("Size (%lx, %lx)\n", dbmi.cxBitmap, dbmi.cyBitmap);
                DbgPrint("Format = %lx\n", dbmi.iFormat);
            }
#endif

        dimoIn.bCreateDIB(&dbmi, (VOID *) NULL);

        if (!dimoIn.bValid())
            return(FALSE);

        //
        // The cursor should already be excluded at this point, so just copy
        // to the DIB.
        //

        rclIn.left   = 0;
        rclIn.top    = 0;
        rclIn.right  = erclTrim.right - erclTrim.left;
        rclIn.bottom = erclTrim.bottom - erclTrim.top;

        (*PPFNGET(pdoSrc,CopyBits,  pSurfSrc->flags()))(
                  dimoIn.pSurfobj(),
                  pSurfSrc->pSurfobj(),
                  (CLIPOBJ *) NULL,
                  (bSrcCMYKColor ? NULL : pxlo),
                  &rclIn,
                  (POINTL *) &erclTrim);

        //
        // Point at the new source
        //

        rclIn.left   = prclSrc->left   - erclTrim.left;
        rclIn.top    = prclSrc->top    - erclTrim.top;
        rclIn.right  = prclSrc->right  - erclTrim.left;
        rclIn.bottom = prclSrc->bottom - erclTrim.top;

        pSurfIn  = dimoIn.ps;
        prclIn   = &rclIn;
        pxloIn   = NULL;

        //
        // Adjust the trimmed source origin and extent
        //

        erclTrim.right  -= erclTrim.left;
        erclTrim.bottom -= erclTrim.top;
        erclTrim.left = 0;
        erclTrim.top  = 0;

        //
        // If we needed to, do mirroring. Y mirroring is easy.
        //

        if (flMirror & STRBLT_MIRROR_Y)
        {
            if (dimoIn.ps->lDelta() > 0)
                dimoIn.ps->pvScan0(((BYTE *) dimoIn.ps->pvBits()) + dimoIn.ps->lDelta() * (erclTrim.bottom - 1));
            else
                dimoIn.ps->pvScan0(dimoIn.ps->pvBits());

            dimoIn.ps->lDelta(-dimoIn.ps->lDelta());
        }

        //
        // X mirroring is not.
        //

        if (flMirror & STRBLT_MIRROR_X)
            (*apfnMirror[dimoIn.ps->iFormat()])(dimoIn.ps);
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ po( pSurfOut->hdev());
        po.vSync(pSurfOut->pSurfobj(),NULL, 0);
    }

    //
    // Compute the space needed for the DDA to see if we can do it on the frame.
    // Clip it to the limit of our coordinate systems (2^27) to avoid math
    // overflow in the subsequent calculations.
    //

    if (((prclIn->right - prclIn->left) >= MAX_STRETCH_COOR) ||
        ((prclIn->bottom - prclIn->top) >= MAX_STRETCH_COOR))
    {
        return(FALSE);
    }

    if (((prclOut->right - prclOut->left) >= MAX_STRETCH_COOR) ||
        ((prclOut->bottom - prclOut->top) >= MAX_STRETCH_COOR) ||
        ((prclOut->right - prclOut->left) <= -MAX_STRETCH_COOR) ||
        ((prclOut->bottom - prclOut->top) <= -MAX_STRETCH_COOR))
    {
        return(FALSE);
    }

    //
    //  Special acceleration case:
    //
    //      SrcFormat and Destination format are the same
    //      Color translation is NULL
    //      Src width and height and less than 2 ^ 30
    //

    if  (
         (iMode == COLORONCOLOR) &&
         (psoMask == (SURFOBJ *) NULL) &&
         ((pxloIn == (XLATEOBJ *)NULL) || ((XLATE *)pxloIn)->bIsIdentity()) &&
         (pSurfOut->iFormat() == pSurfIn->iFormat()) &&
         (
            (pSurfIn->iFormat()  == BMF_8BPP)  ||
            (pSurfIn->iFormat()  == BMF_16BPP) ||
            (pSurfIn->iFormat()  == BMF_32BPP)
         )
        )
    {
        if((pcoOut == (CLIPOBJ *)NULL) ||
           (pcoOut->iDComplexity != DC_COMPLEX))
        {
            //
            // Case for no clip region (DC_TRIVIAL) or single rectangle 
            // clipping (DC_RECT).      
            //

            //
            // set clipping for DC_RECT case only, otherwise
            // use dst rectangle
            //
    
            PRECTL   prclClipOut = prclOut;
    
            //
            // StretchDIBDirect has early out cases which leave erclTrim 
            // uninitialized. This line of code is left commented out because
            // nobody has found a bug caused by this.
            //
            // erclTrim.left = erclTrim.right = erclTrim.top = erclTrim.bottom = 0;
            //

            if ((pcoOut != (CLIPOBJ *)NULL) && 
                (pcoOut->iDComplexity == DC_RECT)) 
            {
                prclClipOut = &(pcoOut->rclBounds);
            }
    
            //
            // call stretch blt accelerator
            //
    
            StretchDIBDirect(
               pSurfOut->pvScan0(),
               pSurfOut->lDelta(),
               pSurfOut->sizl().cx,
               pSurfOut->sizl().cy,
               prclOut,
               pSurfIn->pvScan0(),
               pSurfIn->lDelta(),
               pSurfIn->sizl().cx,
               pSurfIn->sizl().cy,
               prclIn,
               &erclTrim,
               prclClipOut,
               pSurfOut->iFormat()
            );
        } 
        else 
        {
            //
            // Handle the complex CLIPOBJ case (DC_COMPLEX)
            //
            
            //
            // Temp storage for individual trim sub-rectangles
            //

            ERECTL erclTrimTmp(0,0,0,0);

            //
            // Initialize erclTrim for accumulation using the += operator below
            // Setting everything to zero ensures the first RECTL is copied.
            // Theoretically we could just set left=right for this to work.
            //

            erclTrim.left = erclTrim.right = erclTrim.top = erclTrim.bottom = 0;

            BOOL bMore;
            ENUMRECTS arclComplexEnum;
            
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
  
            //
            // Point this at the RECTL location and then the loop code below
            // will slide each successive RECTL under this pointer.
            //

            PRECTL prclClipOut=&arclComplexEnum.arcl[0];

            do {

                //
                // Enumerate each rectangle one-by-one in any order.
                //

                bMore = CLIPOBJ_bEnum(pco, sizeof(arclComplexEnum), (ULONG*) &arclComplexEnum);
  
                //
                // Call the stretch blt accelerator for this RECTL
                //

                if(arclComplexEnum.c > 0) 
                {
                    StretchDIBDirect(
                       pSurfOut->pvScan0(),
                       pSurfOut->lDelta(),
                       pSurfOut->sizl().cx,
                       pSurfOut->sizl().cy,
                       prclOut,
                       pSurfIn->pvScan0(),
                       pSurfIn->lDelta(),
                       pSurfIn->sizl().cx,
                       pSurfIn->sizl().cy,
                       prclIn,
                       &erclTrimTmp,
                       prclClipOut,
                       pSurfOut->iFormat()
                    );                 

                    //
                    // Accumulate the Trim rectangle
                    //
                    
                    erclTrim += erclTrimTmp;
                }
            } while (bMore);
        }
        
        //
        // save reduced target rectangle for use in CopyBits
        // to write a temp DIB to the target
        //

        rclTrim.left    = erclTrim.left;
        rclTrim.right   = erclTrim.right;
        rclTrim.top     = erclTrim.top;
        rclTrim.bottom  = erclTrim.bottom;
    }
    else
    {
        //
        // Initialize the DDA
        //

        STRDDA *pdda;

        LONG cjSpace = sizeof(STRDDA) +
                       (sizeof(LONG) * (prclIn->right - prclIn->left +
                                        prclIn->bottom - prclIn->top));

        pdda = (STRDDA *) PALLOCNOZ(cjSpace, 'htsG');
        if (pdda == (STRDDA *) NULL)
        {
            return(FALSE);
        }

    #ifdef DBG_STRBLT
        if (gflStrBlt & STRBLT_ALLOC)
        {
            DbgPrint("Need %ld bytes for DDA\n", cjSpace);
            DbgPrint("DDA @%08lx\n", (ULONG) pdda);
        }
    #endif

        vInitStrDDA(pdda, (RECTL *) &erclTrim, prclIn, prclOut);

        //
        // Save the reduced target rectangle.
        //

        rclTrim = pdda->rcl;

        //
        // See if we can accelerate anything.
        //

        if ((pxloIn != NULL) && (pxloIn->flXlate & XO_TRIVIAL))
        {
            pxloIn = NULL;
        }

        if ((pcoOut != (CLIPOBJ *) NULL) &&
            (pcoOut->iDComplexity == DC_TRIVIAL))
        {
            pcoOut = (CLIPOBJ *) NULL;
        }

        PFN_STRREAD   pfnRead;
        PFN_STRWRITE  pfnWrite = apfnWrite[pSurfOut->iFormat()];

        if (bBogus)
        {
            pdda->iColor = (iMode == BLACKONWHITE) ? ~0L : 0L;
        }

        pfnRead = apfnRead[pSurfIn->iFormat()][iMode - BLACKONWHITE];

        STRRUN *prun;

        //
        // Now compute the space needed for the stretch buffers
        //

        if ((prclIn->right - prclIn->left) > (prclOut->right - prclOut->left))
        {
            //
            // Shrink case -- even though shrinking the mask may cause
            // separate runs to merge together, the low-level stretch code
            // does not handle this.  Therefore, may have a run for every
            // single pixel.
            //

            cjSpace = sizeof(STRRUN) +
                      (sizeof(XRUNLEN) * (rclTrim.right - rclTrim.left)) +
                      sizeof(DWORD);
        }
        else
        {
            //
            // Stretch case -- worse case: every other pixel is masked, so
            // number of runs is 1/2 the number of pixels.
            //

            cjSpace = sizeof(STRRUN) + sizeof(XRUNLEN) *
                       ((rclTrim.right - rclTrim.left + 3) / 2) + sizeof(DWORD);
        }

        if ( ((rclTrim.right - rclTrim.left) > 100000000L) ||
             ((prun = (STRRUN *) AllocFreeTmpBuffer(cjSpace)) == NULL) )
        {
            VFREEMEM(pdda);
            return(FALSE);
        }

    #ifdef DBG_STRBLT
        if (gflStrBlt & STRBLT_ALLOC)
        {
            DbgPrint("Need %ld bytes for buffer\n", cjSpace);
            DbgPrint("Buffer @%08lx\n", (ULONG) prun);
        }
    #endif

        BYTE    *pjSrc = (BYTE *) pSurfIn->pvScan0() + pSurfIn->lDelta() * erclTrim.top;
        BYTE    *pjMask;
        POINTL   ptlMask;
        LONG     yRow;
        LONG     yCnt;

        if (psoMask == (SURFOBJ *) NULL)
        {
            pjMask = (BYTE *) NULL;
        }
        else
        {
            ptlMask.x = erclTrim.left - prclIn->left + pptlMask->x;
            ptlMask.y = erclTrim.top  - prclIn->top  + pptlMask->y;

            pjMask = (BYTE *) pSurfMask->pvScan0() + pSurfMask->lDelta() * ptlMask.y;
        }

        //
        // If we are in bogus mode, initialize the buffer
        //

        ULONG   iOver;

        if (bBogus)
        {
            iOver = (iMode == BLACKONWHITE) ? -1 : 0;

            vInitBuffer(prun, &rclTrim, iOver);
        }

        prun->yPos = pdda->rcl.top;

        for (yRow = erclTrim.top, yCnt = 0; yRow < erclTrim.bottom; yRow++, yCnt++)
        {
            prun->cRep = pdda->plYStep[yCnt];

            if (prun->cRep)
            {
                (*pfnWrite)(prun,
                            (*pfnRead)(pdda,
                                       prun,
                                       pjSrc,
                                       pjMask,
                                       pxloIn,
                                       erclTrim.left,
                                       erclTrim.right,
                                       ptlMask.x),
                            pSurfOut,
                            pcoOut);

                //
                // If we are in bogus mode, reinitialize the buffer
                //

                if (bBogus)
                    vInitBuffer(prun, &rclTrim, iOver);
            }
            else
            {
                //
                // If we are in BLACKONWHITE or WHITEONBLACK mode, we need to read
                // the scan and mix it with the current buffer.
                //

                if (bBogus)
                {
                    (*pfnRead)(pdda,
                               prun,
                               pjSrc,
                               (BYTE *) NULL,
                               pxloIn,
                               erclTrim.left,
                               erclTrim.right,
                               0);
                }
            }

            pjSrc += pSurfIn->lDelta();
            prun->yPos += prun->cRep;

            if (pjMask != (BYTE *) NULL)
            {
                pjMask += pSurfMask->lDelta();
            }
        }

        //
        // Free up the work buffers.
        //

        FreeTmpBuffer(prun);
        VFREEMEM(pdda);
    }

    //
    // See if we have drawn on the actual output surface.
    //

    if (pSurfOut == pSurfTrg)
#ifndef DBG_STRBLT
        return(TRUE);
#else
    {
        if (gflStrBlt & STRBLT_FORMAT)
            DbgBreakPoint();

        return(TRUE);
    }
#endif

    //
    // We need to build a clipping region equal to the trimmed target.
    //

    rclTrim.left   += eptlDev.x;
    rclTrim.top    += eptlDev.y;
    rclTrim.right  += eptlDev.x;
    rclTrim.bottom += eptlDev.y;

    RGNMEMOBJTMP rmo;

    if (!rmo.bValid())
        return(FALSE);

    if (pco == (CLIPOBJ *) NULL)
        rmo.vSet(&rclTrim);
    else
    {
        RGNMEMOBJTMP   rmoTmp;

        if (!rmoTmp.bValid())
            return(FALSE);

        rmoTmp.vSet(&rclTrim);

        if (!rmo.bMerge(rmoTmp, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
            return(FALSE);
    }

    ERECTL  ercl;

    rmo.vGet_rcl(&ercl);

    if (pco != NULL)
    {
        //
        // Make sure that the bounds are tight to the destination rectangle.
        //

        if (!bIntersect(&ercl, &pco->rclBounds, &ercl))
        {
            return(TRUE);
        }
    }

    ECLIPOBJ eco(rmo.prgnGet(), ercl, CLIP_FORCE);

    if (eco.erclExclude().bEmpty())
        return(TRUE);

    //
    // Copy from the temporary to the target surface.
    //

    erclDev.left   += eptlDev.x;
    erclDev.top    += eptlDev.y;
    erclDev.right  += eptlDev.x;
    erclDev.bottom += eptlDev.y;
    eptlDev.x       = 0;
    eptlDev.y       = 0;

#ifdef DBG_STRBLT
        vShowRect("Trg Out", (RECTL *) &erclDev);
#endif

    //
    // With CMYK color, temp surface is based on source, while non-CMYK
    // case it's target. So we need xlateobj for CMYK color case, but
    // don't need for non-CMYK case.
    //

    (*PPFNGET(pdoTrg,CopyBits,  pSurfTrg->flags())) (pSurfTrg->pSurfobj(),
                                                     dimoOut.pSurfobj(),
                                                     &eco,
                                                     (bSrcCMYKColor ? pxlo : NULL),
                                                     &erclDev,
                                                     &eptlDev);

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_FORMAT)
        DbgBreakPoint();
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* EngStretchBltROP
*
* This does stretched bltting with a rop.
*
* This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  24-Sept-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL EngStretchBltROP(
SURFOBJ         *psoTrg,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclTrg,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode,
BRUSHOBJ        *pbo,
ROP4            rop4)
{
    GDIFunctionID(EngStretchBltROP);

    ASSERTGDI(psoTrg != (SURFOBJ *) NULL, "psoTrg == NULL\n");
    ASSERTGDI(prclTrg != (PRECTL) NULL, "dst rectangle is NULL\n");

    PSURFACE pSurfTrg  = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);

    ASSERTGDI(rop4, "rop4 == NULL\n");
    ASSERTGDI(pSurfTrg->iFormat() != BMF_JPEG,
              "dst BMF_JPEG not supported\n");
    ASSERTGDI(pSurfTrg->iFormat() != BMF_PNG,
              "dst BMF_PNG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (psoSrc == (SURFOBJ *) NULL)),
              "psoSrc == NULL\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (prclSrc == (PRECTL) NULL)),
              "src rectangle is NULL\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_JPEG)),
              "src BMF_JPEG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_PNG)),
              "src BMF_PNG not supported\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) && (pbo == (BRUSHOBJ *) NULL)),
              "Pattern is NULL\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) &&
                (pbo->iSolidColor == 0xFFFFFFFF) &&
                (pptlBrushOrg == (PPOINTL) NULL)),
              "Pattern offset is NULL\n");

    if ((rop4 != 0x0000CCCC) && (rop4 != 0x0000AACC))
    {
        //
        // Dont halftone if we got a weird ROP.
        //

        if (iMode == HALFTONE)
            iMode = COLORONCOLOR;

        LONG    l;
        BOOL    bFlipX = FALSE;
        BOOL    bFlipY = FALSE;

        //
        // order the target extents
        //

        if (prclTrg->left > prclTrg->right)
        {
           l = prclTrg->left, prclTrg->left = prclTrg->right, prclTrg->right = l;

           bFlipX = TRUE;
        }

        if (prclTrg->top > prclTrg->bottom)
        {
           l = prclTrg->top, prclTrg->top = prclTrg->bottom, prclTrg->bottom = l;

           bFlipY = TRUE;
        }

        DEVBITMAPINFO   dbmi;
        SURFMEM   dimoShadow;
        SURFMEM   dimoMask;

        ULONG ulAvec  = ((ULONG) gajRop3[rop4 & 0x00ff]) |
                        ((ULONG) gajRop3[(rop4 >> 8) & 0x00ff]);

        // The check above does not tell if we need a mask.
        // Check explicitly.

        if ((rop4 >> 8) != (rop4 & 0xff))
        {
            ulAvec |= AVEC_NEED_MASK;
        }

        EPOINTL ptl(0,0);

        //
        // Stretch the Mask
        //

        if (ulAvec & AVEC_NEED_MASK)
        {

            ASSERTGDI (psoMask, "psoMask == NULL\n");

            PSURFACE pSurfMask  = SURFOBJ_TO_SURFACE(psoMask);

            //
            // use ordered target extents for the size
            //

            dbmi.iFormat  = BMF_1BPP;
            dbmi.cxBitmap = prclTrg->right - prclTrg->left;
            dbmi.cyBitmap = prclTrg->bottom - prclTrg->top;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.fl       = pSurfMask->bUMPD() ? UMPD_SURFACE : 0;

            ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

            if (bFlipX)
                l = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = l;

            if (bFlipY)
                l = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = l;

            dimoMask.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoMask.bValid())
                return(FALSE);

            ULONG cx = prclSrc->right - prclSrc->left;
            ULONG cy = prclSrc->bottom - prclSrc->top;

            ERECTL  erclMask(pptlMask->x, pptlMask->y, pptlMask->x+cx, pptlMask->y+cy);

            //
            // Call EngStretchBlt to stretch the mask.
            //

            if (!EngStretchBlt(dimoMask.pSurfobj(),
                        psoMask,
                        (SURFOBJ *) NULL,
                        (CLIPOBJ *) NULL,
                        NULL,
                        NULL,
                        (POINTL *)&ptl,
                        &erclTrg,
                        &erclMask,
                        (POINTL *) NULL,
                        iMode))
            {
                return(FALSE);
            }

        }

        //
        // Stretch the Src
        //

        if (ulAvec & AVEC_NEED_SOURCE)
        {
            //
            // use ordered target extents for the size
            //

            dbmi.iFormat  = pSurfSrc->iFormat();
            dbmi.cxBitmap = prclTrg->right - prclTrg->left;
            dbmi.cyBitmap = prclTrg->bottom - prclTrg->top;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

            // Build a shadow rectangle.
            ERECTL  erclTrg(0, 0, dbmi.cxBitmap, dbmi.cyBitmap);

            if (bFlipX)
                l = erclTrg.left, erclTrg.left = erclTrg.right, erclTrg.right = l;

            if (bFlipY)
                l = erclTrg.top, erclTrg.top = erclTrg.bottom, erclTrg.bottom = l;

            dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoShadow.bValid())
            {
                WARNING("dimoShadow invalid\n");
                return(FALSE);
            }

            //
            // Call EngStretchBlt to stretch the source.
            //

            if (!EngStretchBlt(dimoShadow.pSurfobj(),
                                psoSrc,
                                (SURFOBJ *) NULL,
                                (CLIPOBJ *) NULL,
                                NULL,
                                NULL,
                                (POINTL *)&ptl,
                                &erclTrg,
                                prclSrc,
                                (POINTL *) NULL,
                                iMode))
             {
                 return(FALSE);
             }

        }

        //
        // Call BitBlt
        //

        return((*(pSurfTrg->pfnBitBlt()))
                  ( psoTrg,
                    dimoShadow.pSurfobj(),
                    dimoMask.pSurfobj(),
                    pco,
                    pxlo,
                    prclTrg,
                    (POINTL *)&ptl,
                    (POINTL *)&ptl,
                    pbo,
                    pptlBrushOrg,
                    rop4));
     }
     else
     {
        //
        // Just pass it off to EngStretchBlt since it doesn't have a complex ROP
        //

        PDEVOBJ pdoTrg(pSurfTrg->hdev());
        PDEVOBJ pdoSrc(pSurfSrc->hdev());

        // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurfTrg);

        PFN_DrvStretchBlt pfn = PPFNGET(pdoTrg, StretchBlt, pSurfTrg->flags());

        //
        // There are a bunch of conditions that we don't want to
        // call the driver, so we make pfn point to the Eng
        // function. But if the destination is a meta, we want it
        // to actually call the Mul layer.
        //
        // WINBUG #357937 4-3-2001 jasonha Meta DEVBITMAPs must go thru Mul layer
        //  Don't check iType:
        //    DEVICE/DEVBITMAP -> MulStretchBlt
        //    BITMAP (not hooked) -> EngStretchBlt

        if ((pSurfTrg->flags() & HOOK_StretchBlt) && !pdoTrg.bMetaDriver())
        {
            // Don't call the driver if it doesn't do halftone.

            if (iMode == HALFTONE)
            {
                if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

            // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
            // Don't call the driver if the source rectangle exceeds the source
            // surface. Some drivers punt using a duplicate of the source
            // SURFOBJ, but without preserving its sizlBitmap member.

            BOOL bSrcExceeds = FALSE;

            if(pSurfSrc->iType() == STYPE_DEVICE && pdoSrc.bValid() && pdoSrc.bMetaDriver())
            {
                if((prclSrc->left < pdoSrc.pptlOrigin()->x ) ||
                   (prclSrc->top  < pdoSrc.pptlOrigin()->y ) ||
                   (prclSrc->right > pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx) ||
                   (prclSrc->bottom > pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy))
                {
                    bSrcExceeds = TRUE;
                }

            }
            else
            {
                if((prclSrc->left < 0) ||
                   (prclSrc->top  < 0) ||
                   (prclSrc->right  > pSurfSrc->sizl().cx) ||
                   (prclSrc->bottom > pSurfSrc->sizl().cy))
                {
                    bSrcExceeds = TRUE;
                }
            }

            if( bSrcExceeds )
            {
                pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

            // WINBUG #95246 3-17-2000 jasonha GDI: StretchBlt optimizations: Let drivers handle more cases
            // Don't call the driver if the source overlaps the destination.
            // Some drivers don't handle this case.

            ASSERTGDI((prclSrc->left <= prclSrc->right) &&
                      (prclSrc->top  <= prclSrc->bottom),
                      "Source rectangle not well-ordered\n");

            // Use a well-ordered copy of the destination rectangle to do the
            // intersection test.

            ERECTL rclTrg(*prclTrg);
            rclTrg.vOrder();

            if ((psoSrc == psoTrg)            &&
                bIntersect(prclSrc, &rclTrg))
            {
                pfn = (PFN_DrvStretchBlt)EngStretchBlt;
            }

        }

        return ((*pfn)(psoTrg,
                       psoSrc,
                       (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : psoMask,
                       pco,
                       pxlo,
                       pca,
                       pptlBrushOrg,
                       prclTrg,
                       prclSrc,
                       pptlMask,
                       iMode));
     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\stockfnt.cxx ===
/******************************Module*Header*******************************\
* Module Name: stockfnt.cxx
*
* Initializes the stock font objects.
*
* Note:
*
*   This module requires the presence of the following section in the
*   WIN.INI file:
*
*       [GRE_Initialize]
*           fonts.fon=[System font filename]
*           oemfont.fon=[OEM (terminal) font filename]
*           fixedfon.fon=[System fixed-pitch font filename]
*
*   Also, an undocumented feature of WIN 3.0/3.1 is supported: the ability
*   to override the fonts.fon definition of the system font.  This is
*   done by defining SystemFont and SystemFontSize in the [windows]
*   section of WIN.INI.
*
*
* Rewritten 13-Nov-1994 Andre Vachon [andreva]
* Created: 06-May-1991 11:22:23
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Function prototypes.

extern "C" BOOL bInitStockFonts(VOID);
extern "C" BOOL bInitStockFontsInternal(PWSZ pwszFontDir);
extern "C" BOOL bInitOneStockFont(PWSZ pwszValue, LFTYPE type, int iFont, HANDLE RegistryKey,
                                   PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
                                   ULONG ValueLength, PWCHAR ValueName, PWCHAR ValueKeyName);
extern "C" BOOL bInitOneStockFontInternal(PWCHAR pwszFont, LFTYPE type, int iFont);
extern "C" BOOL bInitSystemFont(PWCHAR pfontFile, ULONG  fontSize);
extern "C" VOID vInitEmergencyStockFont(PWCHAR pfontFile);
#if(WINVER >= 0x0400)
extern "C" HFONT hfontInitDefaultGuiFont();
#endif

extern BOOL         G_fConsole;

#pragma alloc_text(INIT, bInitStockFonts)
#pragma alloc_text(INIT, bInitStockFontsInternal)
#pragma alloc_text(INIT, bInitOneStockFont)
#pragma alloc_text(INIT, bInitOneStockFontInternal)
#pragma alloc_text(INIT, bInitSystemFont)
#pragma alloc_text(INIT, vInitEmergencyStockFont)
#if(WINVER >= 0x0400)
#pragma alloc_text(INIT, hfontInitDefaultGuiFont)
#endif

// "Last resort" default HPFE for use by the mapper.

extern PFE *gppfeMapperDefault;

#if(WINVER >= 0x0400)
BOOL gbFinishDefGUIFontInit;
#endif

//
// This was the USER mode version of font initialization.
// This code relied on the ability of transforming a file name found in the
// registry to a full path name so the file could be loaded.
//
// In the kernel mode version, we will assume that all font files (except
// winsrv.dll) will be in the system directory
//
// If we, for some reason, need to get system font files loaded later on
// from another directory, the graphics engine should be "fixed" to allow
// for dynamic changing of the system font - especially when the USER logs
// on to a different desktop.
//

//
// Kernel mode version of font initialization.
//

/******************************Public*Routine******************************\
* BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey)
*
* History:
*  06-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey)
{
    UNICODE_STRING    UnicodeRoot;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeRoot, pwszKey);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    return NT_SUCCESS(ZwOpenKey(pRegistryKey,
                             (ACCESS_MASK) 0,
                             &ObjectAttributes));
}

/******************************Public*Routine******************************\
* BOOL bQueryValueKey
*
* History:
*  06-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bQueryValueKey
(
    PWSZ                           pwszValue,
    HANDLE                         RegistryKey,
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
    ULONG                          ValueLength
)
{
    UNICODE_STRING UnicodeValue;
    ULONG          ValueReturnedLength;

    RtlInitUnicodeString(&UnicodeValue,pwszValue);

    return NT_SUCCESS(ZwQueryValueKey(RegistryKey,
                                   &UnicodeValue,
                                   KeyValuePartialInformation,
                                   ValueKeyInfo,
                                   ValueLength,
                                   &ValueReturnedLength));
}


/******************************Public*Routine******************************\
* BOOL bInitStockFonts ()
*
* Part of the GRE initialization.
*
* Creates LFONTs representing each of the different STOCK OBJECT fonts.
*
\**************************************************************************/

#define KEY_SOFTWARE_FONTS  L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts"
#define KEY_GRE_INITIALIZE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Gre_Initialize"
#define FONTDIR_FONTS  L"\\SystemRoot\\Fonts\\"

extern "C" BOOL bInitStockFontsInternal(PWSZ pwszFontDir)
{
    ENUMLOGFONTEXDVW  elfw;
    HANDLE   RegistryKey;
    BOOL     bOk;

    PULONG ValueBuffer;

    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo;
    PWCHAR                         ValueName;
    PWCHAR                         ValueKeyName;
    ULONG ValueLength = MAX_PATH * 2 - sizeof(LARGE_INTEGER);
    ULONG FontSize;
    ULONG cjFontDir = (wcslen(pwszFontDir) + 1) * sizeof(WCHAR);

    ValueBuffer = (PULONG)PALLOCMEM((MAX_PATH + cjFontDir) * 2,'gdii');

    if (!ValueBuffer)
        return FALSE;

    RtlMoveMemory(ValueBuffer,
                  pwszFontDir,
                  cjFontDir);

    ValueName = (PWCHAR) ValueBuffer;

    ValueKeyName = (PWCHAR)
        (((PUCHAR)ValueBuffer) + cjFontDir -
            sizeof(UNICODE_NULL));

// Offset the regsitry query buffer into the ValueBuffer, but make sure
// it is quad-word aligned.

    ValueKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) (
        (((ULONG_PTR)ValueBuffer) + cjFontDir +
            sizeof(LARGE_INTEGER)) & (~(ULONG_PTR)(sizeof(LARGE_INTEGER) - 1)) );

// Lets try to use the USER defined system font

    if (bOpenKey(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
                 &RegistryKey))
    {

        if (bQueryValueKey(L"SystemFontSize", RegistryKey,
                                       ValueKeyInfo,
                                       ValueLength))
        {
            FontSize = *((PULONG)(&ValueKeyInfo->Data[0]));

            if (bQueryValueKey(L"SystemFont", RegistryKey,
                                           ValueKeyInfo,
                                           ValueLength))

            {
                RtlMoveMemory(ValueKeyName,
                              &ValueKeyInfo->Data[0],
                              ValueKeyInfo->DataLength);

                bInitSystemFont(ValueName, FontSize);
            }
        }

        ZwCloseKey(RegistryKey);
    }

    bOk = bOpenKey(KEY_SOFTWARE_FONTS, &RegistryKey);

    if (!bOk)
    {
        bOk = bOpenKey(KEY_GRE_INITIALIZE, &RegistryKey);
    }

    if (bOk)
    {
    // If the user did not specify a font, or it failed to load, then use the
    // font in the fonts section. This functionality is here to allow
    // a sophisticated user to specify a system font other than the
    // default system font which is defined by font.fon
    // entry in gre_initialize. for instance, lucida unicode was
    // one attempted by LoryH for international setup's but it was
    // not deemed acceptable because of the shell hardcoded issues

        if (STOCKOBJ_SYSFONT == NULL)
        {
            bInitOneStockFont(
                L"FONTS.FON", LF_TYPE_SYSTEM, SYSTEM_FONT,
                RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);
        }

    // init oem stock font

        bInitOneStockFont(
            L"OEMFONT.FON", LF_TYPE_OEM, OEM_FIXED_FONT,
            RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);

    // Initialize the fixed system font - use the default system font
    // if the fixed font could not be loaded

        bInitOneStockFont(
            L"FIXEDFON.FON", LF_TYPE_SYSTEM_FIXED, SYSTEM_FIXED_FONT,
            RegistryKey, ValueKeyInfo,ValueLength,ValueName,ValueKeyName);

        ZwCloseKey(RegistryKey);
    }

// Load the emergency fonts for the system and OEM font in case one
// of the previous two failed. The vInitEmergencyStockFont routine itself
// does appropriate checks to determine if one or the other of these fonts
// has been loaded.

    vInitEmergencyStockFont(L"\\SystemRoot\\System32\\winsrv.dll");

// if system fixed font was not initialized above, make it equal to "ordinary"
// system font. (This is warrisome, because system in not fixed pitch).

    if (STOCKOBJ_SYSFIXEDFONT == NULL)
    {
        bSetStockObject(STOCKOBJ_SYSFONT,SYSTEM_FIXED_FONT);
    }

    DcAttrDefault.hlfntNew = STOCKOBJ_SYSFONT;

// Create the DeviceDefault Font
    
    bOk = TRUE;

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = FIXED_PITCH;

    if (!bSetStockObject(
            hfontCreate(&elfw,
                        LF_TYPE_DEVICE_DEFAULT,
                        LF_FLAG_STOCK | LF_FLAG_ALIASED,
                        NULL),DEVICE_DEFAULT_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_DEFAULTDEVFONT\n");
    }

// Create the ANSI variable Font

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = VARIABLE_PITCH;

    if (!bSetStockObject(
               hfontCreate(&elfw,
                           LF_TYPE_ANSI_VARIABLE,
                           LF_FLAG_STOCK | LF_FLAG_ALIASED,
                           NULL),ANSI_VAR_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_ANSIVARFONT\n");
    }

// Create the ANSI Fixed Font

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));
    elfw.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = FIXED_PITCH;

    if (!bSetStockObject( hfontCreate(&elfw,
                                      LF_TYPE_ANSI_FIXED,
                                      LF_FLAG_STOCK | LF_FLAG_ALIASED,
                                      NULL),ANSI_FIXED_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_ANSIFIXEDFONT\n");
    }

#if(WINVER >= 0x0400)
// Create the default GUI font.

    if (!bSetStockObject(hfontInitDefaultGuiFont(), DEFAULT_GUI_FONT))
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not create STOCKOBJ_DEFAULTGUIFONT\n");
    }
#endif

// Set all stock fonts public.

    if (   (!GreSetLFONTOwner(STOCKOBJ_SYSFONT,        OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_SYSFIXEDFONT,   OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_OEMFIXEDFONT,   OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_DEFAULTDEVFONT, OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_ANSIFIXEDFONT,  OBJECT_OWNER_PUBLIC))
        || (!GreSetLFONTOwner(STOCKOBJ_ANSIVARFONT,    OBJECT_OWNER_PUBLIC))
#if(WINVER >= 0x0400)
        || (!GreSetLFONTOwner(STOCKOBJ_DEFAULTGUIFONT, OBJECT_OWNER_PUBLIC))
#endif
       )
    {
        if (!G_fConsole)
        {
            bOk = FALSE;
            goto error;
        }
        else
            RIP("bInitStockFonts(): could not set owner\n");
    }

error:
    VFREEMEM(ValueBuffer);

    return bOk;
}

/******************************Public*Routine******************************\
*
* BOOL bInitStockFonts(VOID)
*
* first check for stock fonts in the %windir%\fonts directory
* and if they are not there, check in the %windir%\system directory
* Later we should even remove the second attepmt when fonts directory
* becomes established, but for now we want to check both places.
*
* History:
*  05-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitStockFonts(VOID)
{
    return bInitStockFontsInternal(FONTDIR_FONTS);
}

/******************************Public*Routine******************************\
* BOOL bInitSystemFont ()
*
* Initialize the system font from either the SystemFont and SystemFontSize
* or the FONTS.FON definitions in the [windows] and [GRE_Initialize]
* sections of the WIN.INI file, respectively.
*
\**************************************************************************/

BOOL bInitSystemFont(
    PWCHAR pfontFile,
    ULONG fontSize)
{
    ENUMLOGFONTEXDVW elfw;
    COUNT   cFonts;
    BOOL    bRet = FALSE;


    if ( (pfontFile) &&
         (*pfontFile != L'\0') &&
         (fontSize != 0) )
    {
        //
        // Load font file.
        //

        PPFF pPFF_Font;
        PUBLIC_PFTOBJ  pfto;

        // The engine does not handle FOT files anymore, we shouldn't get here with a FOT file 

        if ( (pfto.bLoadAFont(pfontFile,
                              &cFonts,
                              PFF_STATE_PERMANENT_FONT,
                              &pPFF_Font)) &&
             (cFonts != 0) &&
             (pPFF_Font != NULL) )
        {
            //
            // Create and validate public PFF user object.
            //

            PFFOBJ  pffo(pPFF_Font);

            if (pffo.bValid())
            {
                //
                // Find the best size match from the faces (PFEs) in the PFF.
                //

                LONG    lDist;                      // diff. in size of candidate
                LONG    lBestDist = 0x7FFFFFFF;     // arbitrarily high number
                PFE    *ppfeBest = (PFE *) NULL;    // handle of best candidate

                for (COUNT c = 0; c < cFonts; c++)
                {
                    PFEOBJ  pfeoTmp(pffo.ppfe(c));  // candidate face

                    if (pfeoTmp.bValid())
                    {
                        //
                        // Compute the magnitude of the difference in size.
                        // simulations are not relevant
                        //

                        IFIOBJ ifio(pfeoTmp.pifi());

                        if (ifio.bContinuousScaling())
                        {
                            //don't care about best dist.
                            //lBestDist = 0;
                            ppfeBest = pfeoTmp.ppfeGet();
                            break;
                        }
                        else
                        {
                            lDist = (LONG) fontSize - ifio.lfHeight();

                            if ((lDist >= 0) && (lDist < lBestDist))
                            {
                                lBestDist = lDist;
                                ppfeBest = pfeoTmp.ppfeGet();

                                if (lDist == 0)
                                    break;
                            }
                        }
                    }
                }

                //
                // Fill a LOGFONT based on the IFIMETRICS from the best PFE.
                //

                PFEOBJ  pfeo(ppfeBest);

                if (pfeo.bValid())
                {
                    vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                    IFIOBJ ifio(pfeo.pifi());

                    // If this is a scalable font, force the height to be the same
                    // as that specified by [SystemFontSize].

                    if (ifio.bContinuousScaling())
                    {
                        elfw.elfEnumLogfontEx.elfLogFont.lfHeight = fontSize;
                        elfw.elfEnumLogfontEx.elfLogFont.lfWidth  = 0;
                    }

                    //
                    // Save the HPFE handle.  This is the mapper's default HPFE
                    // (its last resort).
                    //

                    gppfeMapperDefault = pfeo.ppfeGet();

                    //
                    // Win 3.1 compatibility stuff
                    //

                    elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                    bRet = bSetStockObject(hfontCreate(&elfw,
                                                LF_TYPE_SYSTEM,
                                                LF_FLAG_STOCK,
                                                NULL),SYSTEM_FONT);
                }
            }
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
* VOID bInitOneStockFont()
*
* Routine to initialize a stock font object
*
\**************************************************************************/

BOOL bInitOneStockFontInternal(
    PWCHAR   pwszFont,
    LFTYPE  type,
    int     iFont)
{
    COUNT         cFonts;
    PPFF          pPFF_Font;
    PUBLIC_PFTOBJ pfto;
    ENUMLOGFONTEXDVW    elfw;
    BOOL          bRet = FALSE;

    if ( (pfto.bLoadAFont(pwszFont,
                          &cFonts,
                          PFF_STATE_PERMANENT_FONT,
                          &pPFF_Font)) &&
         (cFonts != 0) &&
         (pPFF_Font != NULL) )
    {
        PFFOBJ  pffo(pPFF_Font);

        if (pffo.bValid())
        {
            PFEOBJ  pfeo(pffo.ppfe(0));

            if (pfeo.bValid())
            {
                vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                if (iFont == SYSTEM_FONT)
                {
                    //
                    // Save the HPFE handle.  This is the mapper's default
                    // HPFE (its last resort).
                    //

                    gppfeMapperDefault = pfeo.ppfeGet();
                }

                //
                // Win 3.1 compatibility stuff
                //

                elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                bRet = bSetStockObject(hfontCreate(&elfw,type,LF_FLAG_STOCK,NULL),iFont);
            }
        }
    }

    if (STOCKFONT(iFont) == NULL)
    {
        KdPrint(("bInitOneStockFontInternal: Failed to initialize the %ws stock fonts\n",
                 pwszFont));
    }
    return bRet;
}

BOOL bInitOneStockFont
(
    PWSZ                           pwszValue,
    LFTYPE                         type,
    int                            iFont,
    HANDLE                         RegistryKey,
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo,
    ULONG                          ValueLength,
    PWCHAR                         ValueName,
    PWCHAR                         ValueKeyName
)
{
    BOOL bRet = FALSE;
    if (bQueryValueKey(pwszValue, RegistryKey,
                                  ValueKeyInfo,
                                  ValueLength))
    {
        RtlMoveMemory(ValueKeyName,
                      &ValueKeyInfo->Data[0],
                      ValueKeyInfo->DataLength);

        bRet = bInitOneStockFontInternal(ValueName, type, iFont);
    }
    return bRet;
}

/******************************Public*Routine******************************\
* VOID vInitEmergencyStockFont()
*
* Initializes the system and oem fixed font stock objects in case the
* something failed during initialization of the fonts in WIN.INI.
*
\**************************************************************************/

VOID vInitEmergencyStockFont(
    PWSTR pfontFile)
{
    PPFF pPFF_Font;
    PUBLIC_PFTOBJ  pfto;
    COUNT cFonts;

    ENUMLOGFONTEXDVW  elfw;

    if ( ((STOCKOBJ_OEMFIXEDFONT == NULL) || (STOCKOBJ_SYSFONT == NULL)) &&
         (pfontFile) &&
         (pfto.bLoadAFont(pfontFile,
                          &cFonts,
                          PFF_STATE_PERMANENT_FONT,
                          &pPFF_Font)) &&
         (cFonts != 0) &&
         (pPFF_Font != NULL) )
    {
    // Create and validate PFF user object.

        PFFOBJ  pffo(pPFF_Font); // most recent PFF

        if (pffo.bValid())
        {
        // Create and validate PFE user object.

            for (COUNT i = 0;
                 (i < cFonts) && ((STOCKOBJ_OEMFIXEDFONT == NULL) ||
                                  (STOCKOBJ_SYSFONT      == NULL));
                 i++)
            {
                PFEOBJ pfeo(pffo.ppfe(i));

                if (pfeo.bValid())
                {
                // For the system font use the first face with the name
                // "system."  For the OEM font use the first face with
                // then name "terminal."

                    IFIOBJ ifiobj( pfeo.pifi() );

                    if ( (STOCKOBJ_SYSFONT == NULL) &&
                         (!_wcsicmp(ifiobj.pwszFaceName(), L"SYSTEM")) )
                    {
                        WARNING("vInitEmergencyStockFont(): trying to set STOCKOBJ_SYSFONT\n");

                        vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());
                        gppfeMapperDefault = pfeo.ppfeGet();

                    // Win 3.1 compatibility stuff

                        elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                        bSetStockObject(
                            hfontCreate(&elfw,LF_TYPE_SYSTEM,LF_FLAG_STOCK,NULL),
                            SYSTEM_FONT);
                    }

                    if ( (STOCKOBJ_OEMFIXEDFONT == NULL) &&
                         (!_wcsicmp(ifiobj.pwszFaceName(), L"TERMINAL")) )
                    {
                        WARNING("vInitEmergencyStockFont(): trying to set STOCKOBJ_OEMFIXEDFONT\n");

                        vIFIMetricsToEnumLogFontExDvW(&elfw, pfeo.pifi());

                    // Win 3.1 compatibility stuff

                        elfw.elfEnumLogfontEx.elfLogFont.lfQuality = PROOF_QUALITY;

                        bSetStockObject(
                            hfontCreate(&elfw,LF_TYPE_OEM,LF_FLAG_STOCK,NULL),
                            OEM_FIXED_FONT);
                    }
                }
            }
        }

        WARNING("vInitEmergencyStockFont(): Done\n");
    }
}

#if(WINVER >= 0x0400)
/******************************Public*Routine******************************\
* hfontInitDefaultGuiFont
*
* Initialize the DEFAULT_GUI_FONT stock font.
*
* The code Win95 uses to initialize this stock font can be found in
* win\core\gdi\gdiinit.asm in the function InitGuiFonts.  Basically,
* a description of several key parameters (height, weight, italics,
* charset, and facename) are specified as string resources of GDI.DLL.
* After scaling, to compensate for the DPI of the display, these parameters
* are used to create the logfont.
*
* We will emulate this behavior by loading these properties from the
* registry.  Also, so as to not have to recreate the hives initially, if
* the appropriate registry entries do not exist, we will supply defaults
* that match the values currently used by the initial Win95 US release.
*
* The registry entries are:
*
*   [GRE_Initialize]
*       ...
*
*       GUIFont.Height = (height in POINTS, default 8pt.)
*       GUIFont.Weight = (font weight, default FW_NORMAL (400))
*       GUIFont.Italic = (1 if italicized, default 0)
*       GUIFont.CharSet = (charset, default ANSI_CHARSET (0))
*       GUIFont.Facename = (facename, default "MS Sans Serif")
*
* Note: On Win95, the facename is NULL.  This defaults to "MS Sans Serif"
*       on Win95.  Unfortunately, the WinNT mapper is different and will
*       map to "Arial".  To keep ensure that GetObject returns a LOGFONT
*       equivalent to Win95, we could create this font as LF_FLAG_ALIASED
*       so that externally the facename would be NULL but internally we
*       use one with the appropriate facename.  On the other hand, an app
*       might query to find out the facename of the DEFAULT_GUI_FONT and
*       create a new font.  On Win95, this would also map to "MS Sans Serif",
*       but we would map to "Arial".  For now, I propose that we go with
*       the simpler method (do not set LF_FLAG_ALIASED).  I just wanted
*       to note this in case a bug arises later.
*
* History:
*  11-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HFONT hfontInitDefaultGuiFont()
{
    HANDLE hkey;
    PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo;
    BYTE aj[sizeof(PKEY_VALUE_PARTIAL_INFORMATION) + (LF_FACESIZE * sizeof(WCHAR))];

    ENUMLOGFONTEXDVW  elfw;

    RtlZeroMemory(&elfw,sizeof(ENUMLOGFONTEXDVW));

// Initialize to defaults.

    wcscpy(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"MS Shell Dlg");
    elfw.elfEnumLogfontEx.elfLogFont.lfHeight  = 8;
    elfw.elfEnumLogfontEx.elfLogFont.lfWeight  = FW_NORMAL;
    elfw.elfEnumLogfontEx.elfLogFont.lfItalic  = 0;
    elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = gjCurCharset;

// Now let's attempt to initialize from registry.

    ValueKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) aj;

    if (bOpenKey(KEY_GRE_INITIALIZE, &hkey))
    {
        if (bQueryValueKey(L"GUIFont.Facename", hkey, ValueKeyInfo, sizeof(aj)))
        {
            wcsncpy(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, (WCHAR *) ValueKeyInfo->Data,
                    LF_FACESIZE);
        }

        if (bQueryValueKey(L"GUIFont.Height", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfHeight = *((PLONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.Weight", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfWeight = *((PLONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.Italic", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfItalic = (BYTE)*((PULONG)(&ValueKeyInfo->Data[0]));
        }

        if (bQueryValueKey(L"GUIFont.CharSet", hkey, ValueKeyInfo, sizeof(aj)))
        {
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE)*((PULONG)(&ValueKeyInfo->Data[0]));
        }

        ZwCloseKey(hkey);

    }

// Compute height using vertical DPI of display.
//
// Unfortunately, we do not have a display driver loaded so we do not
// know what the vertical DPI is.  So, set a flag indicating that this
// needs to be done and we will finish intitialization after the (first)
// display driver is loaded.

    //elfw.elfEnumLogfontEx.elfLogFont.lfHeight = -((elfw.elfEnumLogfontEx.elfLogFont.lfHeight * ydpi + 36) / 72);
    gbFinishDefGUIFontInit = TRUE;

// Create the LOGFONT and return.

    return hfontCreate(&elfw, LF_TYPE_DEFAULT_GUI, LF_FLAG_STOCK, NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt4.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt4.cxx
*
* This contains the bitmap simulation functions that blt to a 4 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D4
*
* There are three main loops in this function.
*
* The first loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the starting pixels
* We use a dword mask here.
*
* The third loop deals with the Ending pixels
* We use a dword mask here.
*
* We use a 4 entry dword table to expand the
* Src bits.  We walk thru Src one byte at a time
* and expand the byte to 1 dword
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/


VOID vSrcCopyS1D4(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    BYTE  jDst;    // holds a dest byte
    INT   iSrc;    // bit position in the first Src byte
    INT   iDst;    // bit position in the first 8 Dst nibbles
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BYTE  jB = (BYTE) (psb->pxlo->pulXlate[0]);
    BYTE  jF = (BYTE) (psb->pxlo->pulXlate[1]);
    BYTE  ajExpTable[4];
    INT   count;
    INT   i;
    BYTE  ajSrc[4];
    static ULONG aulStartMask[8] = {0XFFFFFFFF, 0XFFFFFF0F, 0XFFFFFF00,
                                 0XFFFF0F00, 0XFFFF0000, 0XFF0F0000,
                                 0XFF000000, 0X0F000000};
    static ULONG aulEndMask[8] = {0X00000000, 0X000000F0, 0X000000FF,
                               0X0000F0FF, 0X0000FFFF, 0X00F0FFFF,
                               0X00FFFFFF, 0XF0FFFFFF};
    ULONG ulMask;
    BOOL  bNextSrc=TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D4 - direction not up to down");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d4\n");

    // Build table
    ajExpTable[0] = jB | (jB << 4);           // 0 0
    ajExpTable[1] = jF | (jB << 4);           // 0 1
    ajExpTable[2] = jB | (jF << 4);           // 1 0
    ajExpTable[3] = jF | (jF << 4);            //1 1

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment
    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    else
    // If Dst starting point is ahead of Src
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // check if there is a next 8 nibbles
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;  //pointer to the Last full Src byte

        // Get first Dst full 8 nibbles (1 dword expanding from
        // 1 Src byte)
        pjDst = psb->pjDst + (((psb->xDstStart+7)&~0x07)>>1);

        // Get the Src byte that matches the first Dst
        // full 8 nibbles
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*4;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *pjDst = ajExpTable[(jSrc&0xC0)>>6];
                    *(pjDst+1) = ajExpTable[(jSrc&0x30)>>4];
                    *(pjDst+2) = ajExpTable[(jSrc&0x0C)>>2];
                    *(pjDst+3) = ajExpTable[jSrc&0x03];

                    pjDst +=4;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)


        else  // if not aligned
        {
            BYTE jRem;     //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    *pjDst = ajExpTable[(jSrc&0xC0)>>6];
                    *(pjDst+1) = ajExpTable[(jSrc&0x30)>>4];
                    *(pjDst+2) = ajExpTable[(jSrc&0x0C)>>2];
                    *(pjDst+3) = ajExpTable[jSrc&0x03];

                    pjDst +=4;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (iDst | !bNextByte)
    {
        //build our masks
        ulMask = aulStartMask[iDst];

        // if there are only one partial left byte,
        // the mask is special
        // for example, when we have 00111000 for
        // Dst
        if (!bNextByte)
        {
             ulMask &= aulEndMask[xDstEnd&0x0007];
        }

        bNextSrc = ((iSrc+cx)>8);

        pjDst = psb->pjDst + ((psb->xDstStart&~0x07)>>1);

        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            if (bNextSrc)
            {
                 while (cy--)
                 {
                     jSrc = *pjSrc << jAlignL;
                     jSrc |= *(pjSrc+1) >> jAlignR;

                     ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                     ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                     ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                     ajSrc[3] = ajExpTable[jSrc&0x03];

                     *(PULONG) ajSrc &= ulMask;

                     *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                     pjDst += lDeltaDst;
                     pjSrc += lDeltaSrc;
                 }
             }
             else
             {
                 while (cy--)
                 {
                     jSrc = *pjSrc << jAlignL;

                     ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                     ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                     ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                     ajSrc[3] = ajExpTable[jSrc&0x03];

                     *(PULONG) ajSrc &= ulMask;

                     *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                     pjDst += lDeltaDst;
                     pjSrc += lDeltaSrc;
                 }
             }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc >> jAlignR;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG)pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
    }

    // Dealing with Ending pixels

    if ((xDstEnd & 0x0007)
        && bNextByte)
    {
        ulMask = aulEndMask[xDstEnd & 0x0007];

        pjDst = psb->pjDst + ((xDstEnd&~0x07)>>1);
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        iSrc = (xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG) pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *(pjSrc-1) << jAlignL;

                jSrc |= *pjSrc >> jAlignR;

                ajSrc[0] = ajExpTable[(jSrc&0xC0)>>6];
                ajSrc[1] = ajExpTable[(jSrc&0x30)>>4];
                ajSrc[2] = ajExpTable[(jSrc&0x0C)>>2];
                ajSrc[3] = ajExpTable[jSrc&0x03];

                *(PULONG) ajSrc &= ulMask;

                *(PULONG) pjDst = (*(PULONG) pjDst & ~ulMask) | *(PULONG) ajSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
    }

}

/******************************Public*Routine******************************\
* vSrcCopyS4D4
*
* History:
*  09-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting
// Otherwise we would be in vSrcCopyS4D4Identity.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D4 - direction not up to down");

    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize all the variables

        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iSrc = psb->xSrcStart;
        iDst = psb->xDstStart;

        {
            // If source and dest are not aligned we have to do
            // this the hard way
            //
            if ((iSrc ^ iDst) & 1)
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (BYTE)pulXlate[((*pjSrc >> 4) & 0x0f)];
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    *pjDst++ = ((BYTE)pulXlate[*pjSrc & 0x0f] << 4) |
                                (BYTE)pulXlate[(pjSrc[1] >> 4) & 0x0f];
                    pjSrc++;
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | ((BYTE)pulXlate[*pjSrc & 0x0f] << 4);
            }
            // Source and Dest are aligned
            //
            else
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (BYTE)pulXlate[*pjSrc++ & 0x0f];
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    *pjDst++ = (BYTE)pulXlate[*pjSrc & 0x0f] |
                            ((BYTE)pulXlate[(*pjSrc & 0xf0) >> 4] << 4);
                    pjSrc++;
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | ((BYTE)pulXlate[(*pjSrc >> 4) & 0x0f] << 4);
            }
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS4D4Identity
*
* History:
*  09-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D4Identity(PBLTINFO psb)
{
    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder = psb->pjDst + ((psb->xDstStart) >> 1);
    PBYTE pjSrcHolder = psb->pjSrc + ((psb->xSrcStart) >> 1);
    ULONG cy = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS4D4Identity\n");
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu \n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd);
#endif

    if (psb->xDir > 0)
    {
    // We're going left to right.

        while(1)
        {
        // Initialize all the variables

            pjDst  = pjDstHolder;
            pjSrc  = pjSrcHolder;

            iSrc = psb->xSrcStart;
            iDst = psb->xDstStart;
            // If source and dest are not aligned we have to do
            // this the hard way
            //
            if ((iSrc ^ iDst) & 1)
            {
                LONG iCnt;
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | ((*pjSrc >> 4) & 0x0f);
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                iCnt = iSrc >> 1;
                while (--iCnt >= 0)
                {
                    BYTE jSrc = *pjSrc++ << 4;
                    *pjDst++ = jSrc | ((*pjSrc >> 4) & 0x0f);
                }
                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                    *pjDst = (*pjDst & 0x0f) | (*pjSrc << 4);
            }
            // Source and Dest are aligned
            //
            else
            {
                iSrc = psb->xSrcEnd - iSrc;

                // if blt starts on odd nibble we need to update it
                //
                if ((iDst & 1) && iSrc)
                {
                    *pjDst = (*pjDst & 0xf0) | (*pjSrc++ & 0x0f);
                    pjDst++;
                    iSrc--;
                }
                // loop once per output byte (2 pixels)
                //
                RtlMoveMemory(pjDst,pjSrc,iSrc >> 1);

                // test if blt ends on odd nibble
                //
                if (iSrc & 1)
                {
                    iSrc >>= 1;
                    pjDst[iSrc] = (pjDst[iSrc] & 0x0f) | (pjSrc[iSrc] & 0xf0);
                }
            }
        // Check if we have anymore scanlines to do

            if (--cy)
            {
                pjSrcHolder += psb->lDeltaSrc;
                pjDstHolder += psb->lDeltaDst;
            }
            else
                break;
        }
    }
    else
    {
    // We're going right to left.  It must be on the same hsurf,
    // therefore must be an identity translation.

        ASSERTGDI(psb->pxlo->bIsIdentity(), "Error: S4D4 -xDir, non-ident xlate");

        while(1)
        {
        // Initialize all the variables

            pjDst  = pjDstHolder;
            pjSrc  = pjSrcHolder;

            iSrc = psb->xSrcStart;
            iDst = psb->xDstStart;

            if (!(iSrc & 0x00000001))
            {
                jSrc = *pjSrc;
                pjSrc--;
            }

            if (iDst & 0x00000001)
            {
                jDst = 0;
            }
            else
            {
            // We're gonna need the low nibble from the first byte

                jDst = *pjDst;
		        jDst = (BYTE) (jDst & 0x0F);
            }

        // Do the inner loop on a scanline

            while(iSrc != psb->xSrcEnd)
            {
                if (iSrc & 0x00000001)
                {
                // We need a new source byte

                    jSrc = *pjSrc;
                    pjSrc--;

                    if (iDst & 0x00000001)
                    {
                    // jDst must be 0 right now.

                        ASSERTGDI(jDst == (BYTE) 0, "ERROR in vSrcCopyS4D4 srcblt logic");

                        jDst |= (BYTE) (jSrc & 0x0F);
                    }
                    else
                    {
                        jDst |= (BYTE) (((ULONG) (jSrc & 0x0F)) << 4);
                        *pjDst = jDst;
                        pjDst--;
                        jDst = 0;
                    }
                }
                else
                {
                    if (iDst & 0x00000001)
                    {
                    // jDst must be 0 right now.

                        ASSERTGDI(jDst == (BYTE) 0, "ERROR in vSrcCopyS4D4 srcblt logic");

                        jDst |= (BYTE) ((jSrc & 0xF0) >> 4);
                    }
                    else
                    {
                        jDst |= (BYTE) (jSrc & 0xF0);
                        *pjDst = jDst;
                        pjDst--;
                        jDst = 0;
                    }
                }

                iSrc--;
                iDst--;
            }

        // Clean up after the inner loop.  We are going right to left.

            if (!(iDst & 0x00000001))
            {
            // The last pel was the low nibble, we need to get the high
            // nibble out of the bitmap and write then write the byte in.

		*pjDst = (BYTE) (jDst | (*pjDst & 0xF0));
            }

        // Check if we have anymore scanlines to do

            if (--cy)
            {
                pjSrcHolder += psb->lDeltaSrc;
                pjDstHolder += psb->lDeltaDst;
            }
            else
                break;
        }
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D4 - direction not up to down");

    LONG  iDst;
    PBYTE pjSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + psb->xSrcStart;
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | ((BYTE) pulXlate[*(pjSrc++)]);
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

		*(pjDst++) = (BYTE) (pulXlate[*(pjSrc + 1)] |
				    (pulXlate[*pjSrc] << 4));

                pjSrc += 2;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    *pjDst = (BYTE) (((*pjDst) & 0x0F) |
			     ((BYTE) (pulXlate[*pjSrc] << 4)));
                }

                break;
            }
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D4
*
*
* History:
*  Sun 10-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D4 - direction not up to down");

    LONG  iDst;
    PUSHORT pusSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PUSHORT pusSrcHolder  = (PUSHORT) (psb->pjSrc + (psb->xSrcStart << 1));
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pjDst  = pjDstHolder;
        pusSrc  = pusSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | ((BYTE) pxlo->ulTranslate(*(pusSrc++)));
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

                *(pjDst++) = (BYTE) (pxlo->ulTranslate(*(pusSrc + 1)) |
                                    (pxlo->ulTranslate(*pusSrc) << 4));

                pusSrc += 2;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
                             ((BYTE) (pxlo->ulTranslate(*pusSrc) << 4));
                }

                break;
            }
        }

        if (--cy)
        {
	    pusSrcHolder = (PUSHORT) (((PBYTE) pusSrcHolder) + psb->lDeltaSrc);
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define Translate32to4(ulPelTemp) ((ulPelLast == ulPelTemp) ? jPelLast : (jPelLast = (BYTE) pxlo->ulTranslate(ulPelLast = ulPelTemp)))

VOID vSrcCopyS24D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D4 - direction not up to down");

    LONG  iDst;
    ULONG ulPelTemp;   // variable to build src RGB's in.
    PBYTE pjSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart * 3);
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG ulPelLast;  // This is the last pel in the src.
    BYTE  jPelLast;   // This is the last pel in the dst.
    BYTE  jDstTmp;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Initialize the cache

    ulPelLast = *(pjSrcHolder + 2);
    ulPelLast = ulPelLast << 8;
    ulPelLast |= (ULONG) *(pjSrcHolder + 1);
    ulPelLast = ulPelLast << 8;
    ulPelLast |= (ULONG) *pjSrcHolder;
    jPelLast = (BYTE) (pxlo->ulTranslate(ulPelLast));

// Just do it

    while(1)
    {
        pjDst  = pjDstHolder;
        pjSrc  = pjSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
        // Do the first byte if it's misaligned.

	    ulPelTemp = *(pjSrc + 2);
	    ulPelTemp = ulPelTemp << 8;
	    ulPelTemp |= (ULONG) *(pjSrc + 1);
	    ulPelTemp = ulPelTemp << 8;
	    ulPelTemp |= (ULONG) *pjSrc;

	    Translate32to4(ulPelTemp);
	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | jPelLast;
            pjDst++;
	    iDst++;
            pjSrc += 3;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
            // Do a whole byte.

		ulPelTemp = (ULONG) *(pjSrc + 2);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *(pjSrc + 1);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *pjSrc;
		jDstTmp = Translate32to4(ulPelTemp);
		pjSrc += 3;

		ulPelTemp = (ULONG) *(pjSrc + 2);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *(pjSrc + 1);
		ulPelTemp = ulPelTemp << 8;
		ulPelTemp |= (ULONG) *pjSrc;
		Translate32to4(ulPelTemp);

		*(pjDst++) = (BYTE) (jPelLast |
				    (jDstTmp << 4));

		pjSrc += 3;
                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    ulPelTemp = (ULONG) *(pjSrc + 2);
		    ulPelTemp = ulPelTemp << 8;
		    ulPelTemp |= (ULONG) *(pjSrc + 1);
		    ulPelTemp = ulPelTemp << 8;
		    ulPelTemp |= (ULONG) *pjSrc;

		    Translate32to4(ulPelTemp);

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
				     ((BYTE) (jPelLast << 4));
                }

            // We are done with this scan

                break;
            }
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}


/******************************Public*Routine******************************\
* vSrcCopyS32D4
*
*
* History:
*  Wed 23-Oct-1991 -by- Patrick Haluptzok [patrickh]
* optimize color translation
*
*  Sun 10-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D4(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D4 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D4 - direction not up to down");

    LONG  iDst;
    PULONG pulSrc;
    PBYTE pjDst;
    LONG  iDstEnd = psb->xDstStart + psb->cx;
    PBYTE pjDstHolder  = psb->pjDst + (psb->xDstStart >> 1);
    PULONG pulSrcHolder  = (PULONG) (psb->pjSrc + (psb->xSrcStart << 2));
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG ulPelTemp;
    ULONG ulPelLast;  // This is the last pel in the src.
    BYTE  jPelLast;   // This is the last pel in the dst.
    BYTE  jDstTmp;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Initialize the cache

    ulPelLast = *pulSrcHolder;
    jPelLast = (BYTE) (pxlo->ulTranslate(ulPelLast));

// Just do it

    while(1)
    {
        pjDst  = pjDstHolder;
        pulSrc  = pulSrcHolder;

        iDst = psb->xDstStart;

        if (iDst & 0x00000001)
        {
	// Do the first byte if it's misaligned.

	    ulPelTemp = *(pulSrc++);
	    Translate32to4(ulPelTemp);
	    *pjDst = (BYTE) ((*pjDst) & 0xF0) | jPelLast;
            pjDst++;
            iDst++;
        }

        while(1)
        {
            if ((iDst + 1) < iDstEnd)
            {
	    // Do a whole byte.

		ulPelTemp = *(pulSrc++);
		jDstTmp = Translate32to4(ulPelTemp);
		ulPelTemp = *(pulSrc++);
		Translate32to4(ulPelTemp);

		*(pjDst++) = (BYTE) (jPelLast |
				    (jDstTmp << 4));

                iDst += 2;
            }
            else
            {
            // Check and see if we have a byte left to do.

                if (iDst < iDstEnd)
                {
                // This is our last byte.  Save low nibble from Dst.

		    ulPelTemp = *pulSrc;
		    Translate32to4(ulPelTemp);

		    *pjDst = (BYTE) ((*pjDst) & 0x0F) |
				     ((BYTE) (jPelLast << 4));
                }

                break;
            }
        }

        if (--cy)
        {
	    pulSrcHolder = (PULONG) (((PBYTE) pulSrcHolder) + psb->lDeltaSrc);
            pjDstHolder += psb->lDeltaDst;
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt32.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt32.cxx
*
* This contains the bitmap simulation functions that blt to a 32 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D32(psb)
    #define VERIFYS24D32(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D32(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D32 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D32 - direction not up to down");

    // These are our holding variables

        PUSHORT pusSrcTemp;
        PULONG pulDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pulDstTemp  = pulDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                if (*(pulDstTemp++) != pxlo->ulTranslate((ULONG) *(pusSrcTemp++)))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS24D32(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D32 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D32 - direction not up to down");

    // These are our holding variables

        ULONG ulDink;          // variable to dink around with the bytes in
        PBYTE pjSrcTemp;
        PULONG pulDstTemp;
        ULONG  cxTemp;
        PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
        PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pjSrcTemp  = pjSrc;
            pulDstTemp  = pulDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDink = *(pjSrcTemp + 2);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *(pjSrcTemp + 1);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *pjSrcTemp;

                if (*pulDstTemp != pxlo->ulTranslate(ulDink))
                    RIP("RGB mis-match");
                pulDstTemp++;
                pjSrcTemp += 3;
            }

            if (--cy)
            {
                pjSrc += psb->lDeltaSrc;
                pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }


#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D32
*
* This function loops through all the lines copying
* each one in three phases according to source
* alignment. The outer loop in x loops through
* the bits in the incomplete bytes (which might
* happen in the begining or the end of the sequence).
* When it comes to the first full byte, it
* goes into an internal x loop that copies 8
* bytes at a time, avoiding some branches, and
* allowing the processor to paraleliza these
* instructions, since there are no dependencies.
*
*
* History:
* 17-Nov-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************/

VOID vSrcCopyS1D32(PBLTINFO psb)
{
    PBYTE  pjSrc;
    PBYTE  pjDst;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    PBYTE  pjSrcTemp;
    PULONG pjDstTemp;
    ULONG  cxTemp;
    BYTE   jSrc;
    ULONG  aulTable[2];
    BYTE   iPosSrc;

    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D32 - direction not up to down");

    // We shouldn't be called with an empty rectangle

    ASSERTGDI( cx != 0 && cy != 0, "vSrcCopyS1D32 - called with an empty rectangle");

    // Generate aulTable. 2 entries.

    aulTable[0] = (ULONG)(psb->pxlo->pulXlate[0]);
    aulTable[1] = (ULONG)(psb->pxlo->pulXlate[1]);

    pjSrc = psb->pjSrc + (psb->xSrcStart >> 3);
    pjDst = psb->pjDst + 4*psb->xDstStart;

    while(cy--)
    {
        pjSrcTemp  = pjSrc;
        pjDstTemp  = (PULONG)pjDst;
        cxTemp     = cx;

        iPosSrc    = (BYTE)(psb->xSrcStart & 0x07);

        if( !iPosSrc )
        {
            // Decrement this since it will be
            // incremented up front ahead
            pjSrcTemp--;
        }
        else
        {
            jSrc = *pjSrcTemp << iPosSrc;
        }

        while (cxTemp)
        {
            if (!iPosSrc)
            {
                pjSrcTemp++;
                if (cxTemp>=8)
                {
                    while(cxTemp>= 8)
                    {
                        jSrc = *pjSrcTemp;

                        pjDstTemp[0] = aulTable[jSrc >> 7];
                        pjDstTemp[1] = aulTable[(jSrc >> 6) & 1];
                        pjDstTemp[2] = aulTable[(jSrc >> 5) & 1];
                        pjDstTemp[3] = aulTable[(jSrc >> 4) & 1];
                        pjDstTemp[4] = aulTable[(jSrc >> 3) & 1];
                        pjDstTemp[5] = aulTable[(jSrc >> 2) & 1];
                        pjDstTemp[6] = aulTable[(jSrc >> 1) & 1];
                        pjDstTemp[7] = aulTable[(jSrc & 1)];

                        pjSrcTemp++;
                        pjDstTemp += 8;
                        cxTemp -= 8;
                    }
                    pjSrcTemp--;
                    continue;
                }
                else
                {
                    jSrc = *pjSrcTemp;
                }
            }


            *pjDstTemp = aulTable[(jSrc >> 7) & 1];

            jSrc <<= 1;
            iPosSrc++;
            iPosSrc &= 7;
            pjDstTemp++;
            cxTemp--;
        }

        pjSrc = pjSrc + psb->lDeltaSrc;
        pjDst = pjDst + psb->lDeltaDst;

    }

}

/******************************Public*Routine******************************\
* vSrcCopyS4D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D32 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PULONG pulDst;
    PBYTE pjSrc;
    PULONG pulDstHolder  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pulDst  = pulDstHolder;
        pjSrc  = pjSrcHolder;

        i = psb->xSrcStart;

        if (i & 0x00000001)
            jSrc = *(pjSrc++);

        while(i != psb->xSrcEnd)
        {
            if (i & 0x00000001)
                *(pulDst++) = pulXlate[jSrc & 0x0F];
            else
            {
            // We need a new byte

                jSrc = *(pjSrc++);
                *(pulDst++) = pulXlate[(((ULONG) (jSrc & 0xF0)) >> 4)];
            }

            ++i;
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pulDstHolder = (PULONG) (((PBYTE) pulDstHolder) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrcTemp;
    PULONG pulDstTemp;
    ULONG  cxTemp;
    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {

        pjSrcTemp  = pjSrc;
        pulDstTemp  = pulDst;
        cxTemp     = cx;

        while(cxTemp--)
        {
            *(pulDstTemp++) = pulXlate[((ULONG) *(pjSrcTemp++))];
        }

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D32
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst = psb->pjDst + (4 * psb->xDstStart);
    ULONG cx    = psb->cx;
    ULONG cy    = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 4);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0,
        "ERROR: Src Move cy == 0");
    ASSERTGDI(palSrc.bIsBitfields(),
        "ERROR: destination not bitfields");

// First, try to optimize 5-6-5 to BGR:

    if ((palSrc.flBlu() == 0x001f) &&
        (palSrc.flGre() == 0x07e0) &&
        (palSrc.flRed() == 0xf800) &&
        (palDst.bIsBGR()))
    {
        while (1)
        {
            i = cx;
            do {
                ul = *((USHORT*) pjSrc);

                *((ULONG*) pjDst) = ((ul << 8) & 0xf80000)
                                  | ((ul << 3) & 0x070000)
                                  | ((ul << 5) & 0x00fc00)
                                  | ((ul >> 1) & 0x000300)
                                  | ((ul << 3) & 0x0000f8)
                                  | ((ul >> 2) & 0x000007);

                pjSrc += 2;
                pjDst += 4;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D32(psb);
        return;
    }

// Next, try to optimize 5-5-5 to BGR:

    if ((palSrc.flBlu() == 0x001f) &&
        (palSrc.flGre() == 0x03e0) &&
        (palSrc.flRed() == 0x7c00) &&
        (palDst.bIsBGR()))
    {
        while (1)
        {
            i = cx;
            do {
                ul = *((USHORT*) pjSrc);

                *((ULONG*) pjDst) = ((ul << 9) & 0xf80000)
                                  | ((ul << 4) & 0x070000)
                                  | ((ul << 6) & 0x00f800)
                                  | ((ul << 1) & 0x000700)
                                  | ((ul << 3) & 0x0000f8)
                                  | ((ul >> 2) & 0x000007);
                pjSrc += 2;
                pjDst += 4;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D32(psb);
        return;
    }

// Finally, fall back to the generic case:

    while (1)
    {
        i = cx;
        do {
            *((ULONG*) pjDst) = pxlo->ulTranslate(*((USHORT*) pjSrc));
            pjSrc += 2;
            pjDst += 4;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D32(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS24D32
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D32 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (4 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 3);
    LONG lDstSkip = psb->lDeltaDst - (cx * 4);
    PFN_pfnXlate pfnXlate;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    ULONG ul;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Try to optimize BGR to BGR:

    if (palSrc.bIsBGR() && palDst.bIsBGR())
    {
        while (1)
        {
            i = cx;
            do {
                *((ULONG*) pjDst) = (*(pjSrc))
                                  | (*(pjSrc + 1) << 8)
                                  | (*(pjSrc + 2) << 16);
                pjDst += 4;
                pjSrc += 3;

            } while (--i != 0);

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS24D32(psb);
        return;
    }

// Fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            ul = ((ULONG) *(pjSrc))
               | ((ULONG) *(pjSrc + 1) << 8)
               | ((ULONG) *(pjSrc + 2) << 16);

            *((ULONG*) pjDst) = pfnXlate(pxlo, ul);
            pjDst += 4;
            pjSrc += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS24D32(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS32D32
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS32D32(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D32 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D32 - direction not up to down");

// These are our holding variables

    PULONG pulSrcTemp;
    PULONG pulDstTemp;
    ULONG  cxTemp;
    PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {

        pulSrcTemp  = pulSrc;
        pulDstTemp  = pulDst;
        cxTemp     = cx;

        while(cxTemp--)
        {
            *(pulDstTemp++) = pxlo->ulTranslate(*(pulSrcTemp++));
        }

        if (--cy)
        {
            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D32Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D32Identity(PBLTINFO psb)
{
// These are our holding variables

    PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
    PULONG pulDst  = (PULONG) (psb->pjDst + (4 * psb->xDstStart));
    ULONG  cx      = psb->cx;
    ULONG  cy      = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (psb->xDir < 0)
    {
        pulSrc -= (cx - 1);
        pulDst -= (cx - 1);
    }

    cx = cx << 2;

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory((PBYTE)pulDst, (PBYTE)pulSrc, cx);
        else
            RtlMoveMemory((PVOID)pulDst, (PVOID)pulSrc, cx);

        if (--cy)
        {
            pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pulDst = (PULONG) (((PBYTE) pulDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\strdir.cxx ===
/*++

Copyright (c) 1994-1999 Microsoft Corporation

Module Name:

    str.c

Abstract:

    stretch blt routines

Author:

   Mark Enstrom  (marke)

Environment:

    C

Revision History:

   08-26-92     Initial version

--*/


#include "precomp.hxx"
#include "stretch.hxx"

#define STRETCH_MAX_WIDTH 32767

#ifdef DBG_STRDIR

ULONG   DbgStrBlt=0;

#endif

PFN_DIRSTRETCH
pfnStrArray[] = {
                    vDirectStretchError,        // 0
                    vDirectStretchError,        // 1
                    vDirectStretchError,        // 4
                    vDirectStretch8,            // 8
                    vDirectStretch16,           // 16
                    vDirectStretchError,        // 24
                    vDirectStretch32,           // 32
                    vDirectStretchError,        // 0  Narrow
                    vDirectStretchError,        // 0  Narrow
                    vDirectStretchError,        // 1  Narrow
                    vDirectStretchError,        // 4  Narrow
                    vDirectStretch8Narrow,      // 8  Narrow
                    vDirectStretch16,           // 16 Narrow
                    vDirectStretchError,        // 24 Narrow
                    vDirectStretch32,           // 32 Narrow
                    vDirectStretchError         // 0  Narrow
                };



/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format. Currently only 8,16 and 32 bit per pixel
*   are supported
*
* Arguments:
*
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclTrim        -   Return dst extents trimmed by clipping in this rect
*   prclSClip       -   Clip Dest to this rect
*   iBitmapFormat   -   Format of Src and Dst bitmaps
*
* Return Value:
*
*   Status
*
* Revision History:
*
*   10-07-94      Initial code
*
\**************************************************************************/


BOOL
StretchDIBDirect(
    PVOID   pvDst,
    LONG    lDeltaDst,
    ULONG   DstCx,
    ULONG   DstCy,
    PRECTL  prclDst,
    PVOID   pvSrc,
    LONG    lDeltaSrc,
    ULONG   SrcCx,
    ULONG   SrcCy,
    PRECTL  prclSrc,
    PRECTL  prclTrim,
    PRECTL  prclClip,
    ULONG   iBitmapFormat
    )
{

    //
    // validate parameters, then determine src to dst mapping
    //

    ASSERTGDI(pvDst != (PVOID)NULL,"Bad destination bitmap pointer");
    ASSERTGDI(pvSrc != (PVOID)NULL,"Bad source bitmap pointer");
    ASSERTGDI(prclDst != (PRECTL)NULL,"Bad destination rectangle");
    ASSERTGDI(prclSrc != (PRECTL)NULL,"Bad source rectangle");

    STR_BLT StrBlt;


#ifdef DBG_STRDIR
    if (DbgStrBlt >= 3) {
        DbgPrint("\n-----------------------------------------------------------");
        DbgPrint("StretchBlt\n");
        DbgPrint("rclDst = [0x%8lx,0x%8lx] to [0x%8lx,0x%8lx]\n",prclDst->left,prclDst->top,prclDst->right,prclDst->bottom);
        DbgPrint("rclSrc = [0x%8lx,0x%8lx] to [0x%8lx,0x%8lx]\n",prclSrc->left,prclSrc->top,prclSrc->right,prclSrc->bottom);
    }
#endif

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;

    //
    // calculate EXCLUSIVE start and end points
    //

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;

    BOOL    bXSrcClipped = FALSE;
    BOOL    bYSrcClipped = FALSE;
    RECTL   rclDefClip;
    PRECTL  prclBounds = prclClip;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;

    PFN_DIRSTRETCH pfnStr;

    //
    // check for quick-out NULL RECTs. SrcWidth and SrcHeight must be
    // positive here. Mirroring is taken care of earlier.
    //

    if (
        (WidthDst <= 0)  ||
        (HeightDst <= 0) ||
        (WidthSrc <= 0)  ||
        (HeightSrc <= 0)
       )
    {
        return(TRUE);
    }

    //
    // make sure extents fit with the limits of 32 bit integer
    // arithmatic
    //

    if (
        (WidthDst  > STRETCH_MAX_WIDTH) ||
        (HeightDst > STRETCH_MAX_WIDTH) ||
        (WidthSrc  > STRETCH_MAX_WIDTH) ||
        (HeightSrc > STRETCH_MAX_WIDTH)
       )
    {
        return(FALSE);
    }

    //
    // if prclClip is null, then make bounds point to a
    // default clip region of the entire dst rect
    //

    if (prclClip == (PRECTL)NULL) {
        prclBounds = &rclDefClip;
        rclDefClip.left   = 0;
        rclDefClip.right  = DstCx;
        rclDefClip.top    = 0;
        rclDefClip.bottom = DstCy;
    }

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {

        LARGE_INTEGER   liWidthSrc;
        LARGE_INTEGER   liQuo;
        ULONG           ulTemp;

        liWidthSrc.LowPart  = (ULONG)-1;
        liWidthSrc.HighPart = WidthSrc-1;

        liQuo = RtlExtendedLargeIntegerDivide(liWidthSrc,(ULONG)WidthDst,(PULONG)NULL);

        ulXDstToSrcIntCeil  = liQuo.HighPart;
        ulXDstToSrcFracCeil = liQuo.LowPart;

        //
        // now add 1, use fake carry
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;

    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {

        LARGE_INTEGER  liHeightSrc;
        LARGE_INTEGER  liQuo;
        ULONG          ulTemp;

        liHeightSrc.LowPart  = (ULONG) -1;
        liHeightSrc.HighPart = HeightSrc-1;

        liQuo = RtlExtendedLargeIntegerDivide(liHeightSrc,HeightDst,NULL);

        ulYDstToSrcIntCeil  = (ULONG)liQuo.HighPart;
        ulYDstToSrcFracCeil = liQuo.LowPart;

        //
        // now add 1, use fake carry
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;

    }

    //
    // Check for a x clipped src
    //

    if ((XSrcStart < 0)  || (XSrcEnd > (LONG)SrcCx)) {

        bXSrcClipped = TRUE;

        //
        // src is x clipped.
        // calculate Src to Dst mapping, then calculate
        // new XDstStart and/or XDstEnd based on clipped src
        //
        // Calculate X Src to Dst mapping
        //
        // Src->Dst =  ( FLOOR( (2k*WidthDst)/WidthSrc) ) / 2k
        //
        // where 2k = 2 ^ 32
        //

        LARGE_INTEGER   liHalfk = {0x7fffffff,0x00000000};
        LARGE_INTEGER   liWidthDst;
        LARGE_INTEGER   liQuo;
        ULONG           ulTemp;

        bXSrcClipped        = TRUE;

        liWidthDst.HighPart = WidthDst;;
        liWidthDst.LowPart  = 0;

        liQuo = RtlExtendedLargeIntegerDivide(liWidthDst,(ULONG)WidthSrc,(PULONG)NULL);

        XSrcToDstIntFloor  = (ULONG)liQuo.HighPart;
        XSrcToDstFracFloor = liQuo.LowPart;

        //
        // is src left clipped
        //

        if (XSrcStart < 0)
        {

            //
            // clip left Ad = FLOOR[ N * As + (2^(k-1) -1)]/2^k
            //

            LONG            SrcClipped   = -(LONG)XSrcStart;
            ULONG           DeltaDstInt;
            LARGE_INTEGER   liDeltaDstFrac;
            LONG            NewWidthSrc = WidthSrc;

            NewWidthSrc        -= SrcClipped;

            if (NewWidthSrc <= 0)
            {
                return(TRUE);
            }

            //
            // calc fraction N * As
            //

            DeltaDstInt    = (ULONG)SrcClipped * XSrcToDstIntFloor;
            liDeltaDstFrac = RtlEnlargedUnsignedMultiply((ULONG)SrcClipped,XSrcToDstFracFloor);

            liDeltaDstFrac.HighPart += (LONG)DeltaDstInt;

            //
            //   add in 2^(k-1) - 1  = 0x00000000 0x7fffffff
            //

            liDeltaDstFrac = RtlLargeIntegerAdd(liDeltaDstFrac,liHalfk);

            XSrcStart = 0;
            XDstStart += liDeltaDstFrac.HighPart;

        }

        if (XSrcEnd > (LONG)SrcCx)
        {

            //
            // clip right edge, calc src offset from XSrcStart (SrcClipped)
            //
            // clip left Bd = FLOOR[ N * Bs + (2^(k-1) -1)]/2^k
            //
            // Note: use original value of WidthSrc, not value reduced by
            // left clipping.
            //

            LONG             SrcClipped  = XSrcEnd - SrcCx;
            ULONG            DeltaDstInt;
            LARGE_INTEGER   liDstWidth;

            WidthSrc    = WidthSrc - SrcClipped;

            //
            // check for totally src clipped
            //

            if (WidthSrc <= 0)
            {
                return(TRUE);
            }

            //
            // calc N * Bs
            //

            DeltaDstInt = (ULONG)WidthSrc * (ULONG)XSrcToDstIntFloor;
            liDstWidth = RtlEnlargedUnsignedMultiply((ULONG)WidthSrc,XSrcToDstFracFloor);

            liDstWidth.HighPart += (LONG)DeltaDstInt;

            //
            // add in (2^(k-1) -1)
            //

            liDstWidth = RtlLargeIntegerAdd(liDstWidth,liHalfk);

            XSrcEnd = SrcCx;
            XDstEnd = prclDst->left + liDstWidth.HighPart;

        }
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclBounds->left)
    {
        XDstStart = prclBounds->left;
    }

    if (XDstEnd > prclBounds->right)
    {
        XDstEnd = prclBounds->right;
    }

    //
    // check for totally clipped out dst
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    if (!bXSrcClipped && (LeftClipDistance == 0))
    {

        ULONG   ulTempInt,ulTempFrac;

        //
        // calc displacement for .5 in dst and add
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = ulXDstToSrcIntCeil >> 1;

        XSrcStart  += (LONG)ulTempInt;
        ulXFracAccumulator = ulTempFrac;

    } else {

        //
        // calc new src start
        //

        LARGE_INTEGER  liMulResult;
        LARGE_INTEGER  liHalfDest;
        ULONG          ulIntResult;

        //
        // calculate starting XSrc based on LeftClipDistance.
        //

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)LeftClipDistance,ulXDstToSrcIntCeil);
        ulIntResult = liMulResult.LowPart;

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)LeftClipDistance,ulXDstToSrcFracCeil);
        liMulResult.HighPart += ulIntResult;

        //
        // calculate change in Src for .5 change in dst. This is just 1/2 INT:FRAC
        //

        liHalfDest.LowPart  = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        liHalfDest.HighPart = ulXDstToSrcIntCeil >> 1;

        //
        // add changed together for final XSrcStart
        //

        liMulResult = RtlLargeIntegerAdd(liMulResult,liHalfDest);

        //
        // separate int portion and fractional portion
        //

        XSrcStart          = prclSrc->left + liMulResult.HighPart;
        ulXFracAccumulator = liMulResult.LowPart;
    }


    //
    // now check for src and dst clipping in Y
    //
    // Check for a Y clipped src
    //

    if ((YSrcStart < 0)  || (YSrcEnd > (LONG)SrcCy))
    {

        bYSrcClipped = TRUE;

        //
        // src is y clipped.
        // calculate Src to Dst mapping, then calculate
        // new YDstStart and/or YDstEnd based on clipped src
        //
        // Calculate Y Src to Dst mapping
        //
        // Src->Dst =  ( FLOOR( (2k*HeightDst)/HeightSrc) ) / 2k
        //
        // where 2k = 2 ^ 32
        //

        LARGE_INTEGER  liHalfk = {0x7fffffff,0x00000000};
        LARGE_INTEGER  liHeightDst;
        LARGE_INTEGER  liQuo;
        ULONG          ulTemp;

        bYSrcClipped        = TRUE;

        liHeightDst.HighPart = HeightDst;
        liHeightDst.LowPart  = 0;

        liQuo = RtlExtendedLargeIntegerDivide(liHeightDst,(LONG)HeightSrc,(PULONG)NULL);

        YSrcToDstIntFloor  = (ULONG)liQuo.HighPart;
        YSrcToDstFracFloor = liQuo.LowPart;

        //
        // is src top clipped
        //

        if (YSrcStart < 0)
        {

            //
            // clip top
            // clip left Ad = FLOOR[ d/s * As - liHalfK] + 1
            //

            LONG            SrcClipped   = -(LONG)YSrcStart;
            LONG            DeltaDstInt;
            LARGE_INTEGER   liDeltaDst;
            LONG            NewHeightSrc = HeightSrc;

            NewHeightSrc -= SrcClipped;

            if (NewHeightSrc <= 0)
            {
                return(TRUE);
            }

            DeltaDstInt  = SrcClipped * (LONG)YSrcToDstIntFloor;
            liDeltaDst   = RtlEnlargedUnsignedMultiply((ULONG)SrcClipped,YSrcToDstFracFloor);

            liDeltaDst.HighPart += DeltaDstInt;

            //
            // add in (2^(k-1) -1)   "liHalfk"
            //

            liDeltaDst = RtlLargeIntegerAdd(liDeltaDst,liHalfk);

            YSrcStart = 0;
            YDstStart += liDeltaDst.HighPart;

        }

        if (YSrcEnd > (LONG)SrcCy)
        {

            //
            // clip bottom edge, calc src offset from YSrcStart (SrcClipped)
            // clip left Bd = FLOOR[ d/s * Bs + liHalfK]
            //
            // Note: use original value of HeightSrc, not value reduced
            // by top clipping
            //

            LONG            SrcClipped = YSrcEnd - SrcCy;
            ULONG           DeltaDstInt;
            LARGE_INTEGER   liDeltaDstFrac;

            HeightSrc   = HeightSrc - SrcClipped;

            //
            // check for totally src clipped
            //

            if (HeightSrc <= 0)
            {
                return(TRUE);
            }

            DeltaDstInt = (ULONG)HeightSrc * YSrcToDstIntFloor;
            liDeltaDstFrac = RtlEnlargedUnsignedMultiply(HeightSrc,YSrcToDstFracFloor);

            liDeltaDstFrac.HighPart += DeltaDstInt;

            //
            // add in (2^(k-1) -1)   "liHalfk"
            //

            liDeltaDstFrac = RtlLargeIntegerAdd(liDeltaDstFrac,liHalfk);

            YSrcEnd = SrcCy;
            YDstEnd = prclDst->top + liDeltaDstFrac.HighPart;


        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclBounds->top)
    {
        YDstStart = prclBounds->top;
    }

    if (YDstEnd > prclBounds->bottom)
    {
        YDstEnd = prclBounds->bottom;
    }

    //
    // check for totally clipped out dst
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    if (!bYSrcClipped && (TopClipDistance == 0))
    {

        ULONG   ulTempInt,ulTempFrac;

        //
        // calc displacement for .5 in dst and add
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart  += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

    } else {

        //
        // calc new src start
        //

        LARGE_INTEGER  liMulResult;
        LARGE_INTEGER  liHalfDest;
        ULONG          ulIntResult;

        //
        // calculate Src offset for clipping offset in Dst
        //

        liMulResult = RtlEnlargedUnsignedMultiply((ULONG)TopClipDistance,ulYDstToSrcIntCeil);
        ulIntResult = liMulResult.LowPart;

        liMulResult = RtlEnlargedUnsignedMultiply(TopClipDistance,ulYDstToSrcFracCeil);
        liMulResult.HighPart += ulIntResult;

        //
        // calculate change in Src for .5 change in dst. This is just 1/2 INT:FRAC
        //

        liHalfDest.LowPart  = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        liHalfDest.HighPart = ulYDstToSrcIntCeil >> 1;

        //
        // add changed together for final YSrcStart
        //

        liMulResult = RtlLargeIntegerAdd(liMulResult,liHalfDest);

        //
        // separate int and frac portions
        //

        YSrcStart          = prclSrc->top + liMulResult.HighPart;
        ulYFracAccumulator = liMulResult.LowPart;
    }

    //
    // fill out blt structure, then call format specific stretch code
    //


#ifdef DBG_STRDIR

    if (DbgStrBlt >= 2) {

        DbgPrint("StretchBlt:\n");
        DbgPrint("XSrcStart = %li\n",XSrcStart);
        DbgPrint("YSrcStart = %li\n",YSrcStart);
        DbgPrint("XDstStart,XDstEnd  = %li to %li\n",XDstStart,XDstEnd);
        DbgPrint("YDstStart,YDstEnd  = %li to %li\n",YDstStart,YDstEnd);
    }
#endif

    //
    // caclulate starting scan line address, since the inner loop
    // routines are format dependent, they must add XDstStart/XSrcStart
    // to pjDstScan/pjSrcScan to get the actual starting pixel address
    //

    StrBlt.pjSrcScan            = (PBYTE)pvSrc + (YSrcStart * lDeltaSrc);
    StrBlt.pjDstScan            = (PBYTE)pvDst + (YDstStart * lDeltaDst);

    StrBlt.lDeltaSrc            = lDeltaSrc;
    StrBlt.XSrcStart            = XSrcStart;
    StrBlt.XDstStart            = XDstStart;
    StrBlt.lDeltaDst            = lDeltaDst;
    StrBlt.XDstEnd              = XDstEnd;
    StrBlt.YDstCount            = YDstEnd - YDstStart;
    StrBlt.ulXDstToSrcIntCeil   = ulXDstToSrcIntCeil;
    StrBlt.ulXDstToSrcFracCeil  = ulXDstToSrcFracCeil;
    StrBlt.ulYDstToSrcIntCeil   = ulYDstToSrcIntCeil;
    StrBlt.ulYDstToSrcFracCeil  = ulYDstToSrcFracCeil;
    StrBlt.ulXFracAccumulator   = ulXFracAccumulator;
    StrBlt.ulYFracAccumulator   = ulYFracAccumulator;

    pfnStr = pfnStrArray[ (((XDstEnd - XDstStart) < 7) << 3)  | iBitmapFormat];

    (*pfnStr)(&StrBlt);

    //
    // save clipped dst in prclTrim
    //

    prclTrim->left   = XDstStart;
    prclTrim->right  = XDstEnd;
    prclTrim->top    = YDstStart;
    prclTrim->bottom = YDstEnd;

    return(TRUE);
}



#if !defined (_MIPS_)
#if !defined (_X86_)

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch8(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PBYTE   pjSrcScan = pStrBlt->pjSrcScan + xSrc;
    PBYTE   pjSrc;
    PBYTE   pjDst     = pStrBlt->pjDstScan + xDst;
    PBYTE   pjDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    ULONG   StartAln  = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;
    LONG    WidthXAln;
    ULONG   EndAln    = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - WidthX;

    WidthXAln = WidthX - EndAln - ((4-StartAln) & 0x03);

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {

        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp     = yAccum + yFrac;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {

            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;

        pjDst     += lDstStride;

    } while (--yCount);
}

#endif
#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch8Narrow(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PBYTE   pjSrcScan = pStrBlt->pjSrcScan + xSrc;
    PBYTE   pjSrc;
    PBYTE   pjDst     = pStrBlt->pjDstScan + xDst;
    PBYTE   pjDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;

    ULONG   ulDst;

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - WidthX;

    if (yCount <= 0)
    {
        return;
    }

    yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        PBYTE  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst     += lDstStride;

    } while (--yCount);

}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch16(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PUSHORT pusSrcScan = (PUSHORT)(pStrBlt->pjSrcScan) + xSrc;
    PUSHORT pusSrc;
    PUSHORT pusDst     = (PUSHORT)(pStrBlt->pjDstScan) + xDst;
    PUSHORT pusDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    ULONG   StartAln  = ((ULONG)(ULONG_PTR)pusDst & 0x02) >> 1;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;
    LONG    WidthXAln;
    ULONG   EndAln    = ((ULONG)(ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1;

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - 2*WidthX;

    WidthXAln = WidthX - EndAln - StartAln;

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // Loop stretching each scan line
    //

    do {

        USHORT  usSrc0,usSrc1;
        ULONG   yTmp = yAccum + yFrac;

        pusSrc  = pusSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(PULONG)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pusSrcScan = (PUSHORT)((PBYTE)pusSrcScan + yInt);

        if (yTmp < yAccum)
        {
            pusSrcScan = (PUSHORT)((PBYTE)pusSrcScan + pStrBlt->lDeltaSrc);
        }

        yAccum = yTmp;

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);

    } while (--yCount);
}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch32
*
* Routine Description:
*
*   Stretch blt 32->32
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vDirectStretch32(
    PSTR_BLT pStrBlt
    )
{

    LONG    xDst      = pStrBlt->XDstStart;
    LONG    xSrc      = pStrBlt->XSrcStart;

    PULONG  pulSrcScan = (PULONG)(pStrBlt->pjSrcScan) + xSrc;
    PULONG  pulSrc;
    PULONG  pulDst     = (PULONG)(pStrBlt->pjDstScan) + xDst;
    PULONG  pulDstEnd;

    LONG    yCount    = pStrBlt->YDstCount;
    LONG    WidthX    = pStrBlt->XDstEnd - xDst;

    ULONG   ulDst;
    BOOL    bExpand   = (pStrBlt->ulYDstToSrcIntCeil == 0);

    ULONG   xAccum;
    ULONG   xInt   = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac  = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   xTmp;

    ULONG   yAccum = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac  = pStrBlt->ulYDstToSrcFracCeil;
    LONG    yInt   = 0;
    ULONG   yTmp;
    LONG    lDstStride = pStrBlt->lDeltaDst - 4*WidthX;

    if (yCount <= 0)
    {
        return;
    }

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (!bExpand)
    {
        yInt = pStrBlt->lDeltaSrc * (LONG)pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // general
    //

    do {

        ULONG   ulSrc;
        ULONG   yTmp     = yAccum + yFrac;

        pulSrc  = pulSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {

            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt + (xTmp < xAccum);
            *(PULONG)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        pulSrcScan = (PULONG)((PBYTE)pulSrcScan + yInt);

        if (yTmp < yAccum)
        {
            pulSrcScan = (PULONG)((PBYTE)pulSrcScan + pStrBlt->lDeltaSrc);
        }

        yAccum = yTmp;

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);

    } while (--yCount);
}

VOID vDirectStretchError(
    PSTR_BLT pstr
    )
{
#ifdef DBG_STRDIR
    DbgPrint("Illegal stretch blt acceleration called\n");
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\stretch.cxx ===
/******************************Module*Header*******************************\
* Module Name: stretch.cxx
*
* Internal DDAs for EngStretchBlt
*
* Created: 16-Feb-1993 15:35:02
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"

#ifdef DBG_STRBLT
extern BOOL gflStrBlt;
#endif

static VOID STR_DIV(
DIV_T *pdt,
LONG   lNum,
LONG   lDen)
{
    if (lNum < 0)
    {
        lNum = - (lNum + 1);
        pdt->lQuo = lNum / lDen;
        pdt->lRem = lNum % lDen;
        pdt->lQuo = - (pdt->lQuo + 1);
        pdt->lRem = lDen - pdt->lRem - 1;
    }
    else
    {
        pdt->lQuo = lNum / lDen;
        pdt->lRem = lNum % lDen;
    }

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
    DbgPrint("%ld / %ld = %ld R %ld\n", lNum, lDen, pdt->lQuo, pdt->lRem);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitStrDDA(pdda, prclScan, prclSrc, prclTrg)
*
* Initialize the DDA
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vInitStrDDA(
STRDDA *pdda,
RECTL  *prclScan,
RECTL  *prclSrc,
RECTL  *prclTrg)
{
    RECTL   rclScan;
    RECTL   rclSrc;

// If the source surface does not have a 0,0 origin, deal with it here.

    if ((prclSrc->left != 0) || (prclSrc->top != 0))
    {
        rclScan.left   = prclScan->left   - prclSrc->left;
        rclScan.top    = prclScan->top    - prclSrc->top;
        rclScan.right  = prclScan->right  - prclSrc->left;
        rclScan.bottom = prclScan->bottom - prclSrc->top;
    prclScan = &rclScan;

        rclSrc.left   = 0;
        rclSrc.top    = 0;
        rclSrc.right  = prclSrc->right - prclSrc->left;
        rclSrc.bottom = prclSrc->bottom - prclSrc->top;
        prclSrc = &rclSrc;
    }

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
    {
    DbgPrint("prclScan = [(%ld,%ld) (%ld,%ld)]\n",
          prclScan->left, prclScan->top, prclScan->right, prclScan->bottom);

        DbgPrint("prclSrc = [(%ld,%ld) (%ld,%ld)]\n",
                  prclSrc->left, prclSrc->top, prclSrc->right, prclSrc->bottom);

        DbgPrint("prclTrg = [(%ld,%ld) (%ld,%ld)]\n",
                  prclTrg->left, prclTrg->top, prclTrg->right, prclTrg->bottom);
    }
#endif

    pdda->plYStep = &pdda->al[prclSrc->right];

    DDA_STEP dQnext;    // increment on position of next pixel image
    DIV_T    Qnext;     // starting position of next pixel image
    LONG     lQ;        // current positon
    LONG     iLoop;
    LONG     j;


//
// x-coordinates
//

    STR_DIV(&dQnext.dt, prclTrg->right - prclTrg->left, prclSrc->right);
    dQnext.lDen = prclSrc->right;

    Qnext.lQuo = dQnext.dt.lQuo;
    Qnext.lRem = dQnext.dt.lRem + ((dQnext.lDen - 1)>>1);
    if (Qnext.lRem >= dQnext.lDen)
    {
        Qnext.lQuo += 1;
        Qnext.lRem -= dQnext.lDen;
    }

    for (lQ = 0, iLoop = 0; iLoop < prclScan->left; iLoop++)
    {
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }

    pdda->rcl.left = lQ + prclTrg->left;
    for (j = 0; iLoop < prclScan->right; iLoop++, j++)
    {
        pdda->al[j] = Qnext.lQuo - lQ;
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }
    pdda->rcl.right = lQ + prclTrg->left;

//
// y-coordinates
//
    STR_DIV(&dQnext.dt, prclTrg->bottom - prclTrg->top, prclSrc->bottom);
    dQnext.lDen = prclSrc->bottom;

    Qnext.lQuo = dQnext.dt.lQuo;
    Qnext.lRem = dQnext.dt.lRem + ((dQnext.lDen - 1)>>1);
    if (Qnext.lRem >= dQnext.lDen)
    {
        Qnext.lQuo += 1;
        Qnext.lRem -= dQnext.lDen;
    }

    for (lQ = 0, iLoop = 0; iLoop < prclScan->top; iLoop++)
    {
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }

    pdda->rcl.top = lQ + prclTrg->top;
    for (j = 0; iLoop < prclScan->bottom; iLoop++, j++)
    {
        pdda->plYStep[j] = Qnext.lQuo - lQ;
        lQ = Qnext.lQuo;
        DDA(&Qnext, &dQnext);
    }
    pdda->rcl.bottom = lQ + prclTrg->top;

#ifdef DBG_STRBLT
    if (gflStrBlt & STRBLT_SHOW_INIT)
        DbgPrint("XStep @%08lx, YStep @%08lx\n", (ULONG) pdda->al, (ULONG) pdda->plYStep);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitBuffer(prun, ercl, iMode)
*
* Initialize the run buffer for overwrite modes
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vInitBuffer(
STRRUN *prun,
RECTL  *prcl,
ULONG   iOver)
{
    prun->xrl.xPos = prcl->left;
    prun->xrl.cRun = prcl->right - prcl->left;

    RtlFillMemoryUlong((VOID *) &prun->xrl.aul[0], prun->xrl.cRun << 2, iOver);
}

static ULONG gaulMaskEdge[] =
{
    0xFFFFFFFF, 0xFFFFFF7F, 0xFFFFFF3F, 0xFFFFFF1F,
    0xFFFFFF0F, 0xFFFFFF07, 0xFFFFFF03, 0xFFFFFF01,
    0xFFFFFF00, 0xFFFF7F00, 0xFFFF3F00, 0xFFFF1F00,
    0xFFFF0F00, 0xFFFF0700, 0xFFFF0300, 0xFFFF0100,
    0xFFFF0000, 0xFF7F0000, 0xFF3F0000, 0xFF1F0000,
    0xFF0F0000, 0xFF070000, 0xFF030000, 0xFF010000,
    0xFF000000, 0x7F000000, 0x3F000000, 0x1F000000,
    0x0F000000, 0x07000000, 0x03000000, 0x01000000
};

static ULONG gaulMaskMono[] =
{
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000
};

static ULONG gaulShftMono[] =
{
    0x00000007, 0x00000006, 0x00000005, 0x00000004,
    0x00000003, 0x00000002, 0x00000001, 0x00000000,
    0x0000000F, 0x0000000E, 0x0000000D, 0x0000000C,
    0x0000000B, 0x0000000A, 0x00000009, 0x00000008,
    0x00000017, 0x00000016, 0x00000015, 0x00000014,
    0x00000013, 0x00000012, 0x00000011, 0x00000010,
    0x0000001F, 0x0000001E, 0x0000001D, 0x0000001C,
    0x0000001B, 0x0000001A, 0x00000019, 0x00000018
};

static ULONG gaulMaskQuad[] =
{
    0x000000F0, 0x0000000F, 0x0000F000, 0x00000F00,
    0x00F00000, 0x000F0000, 0xF0000000, 0x0F000000
};

static ULONG gaulShftQuad[] =
{
    0x00000004, 0x00000000, 0x0000000C, 0x00000008,
    0x00000014, 0x00000010, 0x0000001C, 0x00000018
};

/******************************Public*Routine******************************\
* VOID vStrMirror01(pSurf)
*
* Mirror the 1BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror01(SURFACE *pSurf)
{
    ULONG  *pulBase;
    ULONG  *pulSrc;
    ULONG  *pulTrg;
    ULONG   ulSrc;
    ULONG   ulTrg;
    ULONG   ulSwp;
    ULONG   ulTmp;
    LONG    cFlip;
    LONG    cLeft;
    LONG    cRght;
    LONG    iLeft;
    LONG    iRght;
    LONG    x;
    LONG    y;

    pulBase = (ULONG *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        iLeft  = 0;
        cLeft  = 0;
        iRght  = pSurf->sizl().cx - 1;
        cRght  = iRght >> 5;
        iRght &= 31;

        pulSrc = pulBase;
        pulTrg = pulSrc + cRght;

        ulSrc  = *pulSrc;
        ulTrg  = *pulTrg;

        for (x = 0; x < cFlip; x++)
        {
            if (cLeft == cRght)
            {
                ulSwp = (ulSrc & gaulMaskMono[iLeft]) >> gaulShftMono[iLeft];
                ulTmp = (ulSrc & gaulMaskMono[iRght]) >> gaulShftMono[iRght];
                ulSrc = (ulSrc & ~gaulMaskMono[iLeft]) | (ulTmp << gaulShftMono[iLeft]);
                ulSrc = (ulSrc & ~gaulMaskMono[iRght]) | (ulSwp << gaulShftMono[iRght]);
            }
            else
            {
                ulSwp = (ulSrc & gaulMaskMono[iLeft]) >> gaulShftMono[iLeft];
                ulTmp = (ulTrg & gaulMaskMono[iRght]) >> gaulShftMono[iRght];
                ulSrc = (ulSrc & ~gaulMaskMono[iLeft]) | (ulTmp << gaulShftMono[iLeft]);
                ulTrg = (ulTrg & ~gaulMaskMono[iRght]) | (ulSwp << gaulShftMono[iRght]);
            }

            iLeft++;
            iRght--;

            if (iLeft & 32)
            {
               *pulSrc = ulSrc;
                pulSrc++;
                cLeft++;

                if (cLeft == cRght)
                   *pulTrg = ulTrg;

                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iRght < 0)
            {
               *pulTrg = ulTrg;
                pulTrg--;
                cRght--;

                if (cRght == cLeft)
                   *pulSrc = ulSrc;
                else
                    ulTrg = *pulTrg;

                iRght = 31;
            }
    }

       *pulSrc = ulSrc;

    if (cLeft != cRght)
       *pulTrg = ulTrg;

        pulBase = (ULONG *) (((BYTE *) pulBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror04(pSurf)
*
* Mirror the 4BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror04(SURFACE *pSurf)
{
    ULONG  *pulBase;
    ULONG  *pulSrc;
    ULONG  *pulTrg;
    ULONG   ulSrc;
    ULONG   ulTrg;
    ULONG   ulSwp;
    ULONG   ulTmp;
    LONG    cFlip;
    LONG    cLeft;
    LONG    cRght;
    LONG    iLeft;
    LONG    iRght;
    LONG    x;
    LONG    y;

    pulBase = (ULONG *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        iLeft  = 0;
        cLeft  = 0;
        iRght  = pSurf->sizl().cx - 1;
        cRght  = iRght >> 3;
        iRght &= 7;

        pulSrc = pulBase;
        pulTrg = pulSrc + cRght;

        ulSrc  = *pulSrc;
        ulTrg  = *pulTrg;

        for (x = 0; x < cFlip; x++)
        {
            if (cLeft == cRght)
            {
                ulSwp = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                ulTmp = (ulSrc & gaulMaskQuad[iRght]) >> gaulShftQuad[iRght];
                ulSrc = (ulSrc & ~gaulMaskQuad[iLeft]) | (ulTmp << gaulShftQuad[iLeft]);
                ulSrc = (ulSrc & ~gaulMaskQuad[iRght]) | (ulSwp << gaulShftQuad[iRght]);
            }
            else
            {
                ulSwp = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                ulTmp = (ulTrg & gaulMaskQuad[iRght]) >> gaulShftQuad[iRght];
                ulSrc = (ulSrc & ~gaulMaskQuad[iLeft]) | (ulTmp << gaulShftQuad[iLeft]);
                ulTrg = (ulTrg & ~gaulMaskQuad[iRght]) | (ulSwp << gaulShftQuad[iRght]);
            }

            iLeft++;
            iRght--;

            if (iLeft & 8)
            {
               *pulSrc = ulSrc;
                pulSrc++;
                cLeft++;

                if (cLeft == cRght)
                   *pulTrg = ulTrg;

                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iRght < 0)
            {
               *pulTrg = ulTrg;
                pulTrg--;
                cRght--;

                if (cRght == cLeft)
                   *pulSrc = ulSrc;
                else
                    ulTrg = *pulTrg;

                iRght = 7;
        }

       *pulSrc = ulSrc;

    if (cLeft != cRght)
       *pulTrg = ulTrg;

    }

        pulBase = (ULONG *) (((BYTE *) pulBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror08(pSurf)
*
* Mirror the 8BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror08(SURFACE *pSurf)
{
    BYTE   *pjSrc;
    BYTE   *pjTrg;
    BYTE   *pjBase;
    BYTE    jTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pjBase = (BYTE *) pSurf->pvScan0();
    cFlip  = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pjSrc = pjBase;
        pjTrg = pjSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            jTemp = *pjSrc;
           *pjSrc = *pjTrg;
           *pjTrg =  jTemp;
            pjSrc++;
            pjTrg--;
        }

        pjBase += pSurf->lDelta();
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror16(pSurf)
*
* Mirror the 16BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror16(SURFACE *pSurf)
{
    WORD   *pwSrc;
    WORD   *pwTrg;
    WORD   *pwBase;
    WORD    wTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pwBase = (WORD *) pSurf->pvScan0();
    cFlip  = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pwSrc = pwBase;
        pwTrg = pwSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            wTemp = *pwSrc;
           *pwSrc = *pwTrg;
           *pwTrg =  wTemp;
            pwSrc++;
            pwTrg--;
        }

        pwBase = (WORD *) (((BYTE *) pwBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror24(pSurf)
*
* Mirror the 24BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror24(SURFACE *pSurf)
{
    RGBTRIPLE  *prgbSrc;
    RGBTRIPLE  *prgbTrg;
    RGBTRIPLE  *prgbBase;
    RGBTRIPLE   rgbTemp;
    LONG        cFlip;
    LONG        x;
    LONG        y;

    prgbBase = (RGBTRIPLE *) pSurf->pvScan0();
    cFlip    = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        prgbSrc = prgbBase;
        prgbTrg = prgbSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            rgbTemp = *prgbSrc;
           *prgbSrc = *prgbTrg;
           *prgbTrg =  rgbTemp;
            prgbSrc++;
            prgbTrg--;
        }

        prgbBase = (RGBTRIPLE *) (((BYTE *) prgbBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* VOID vStrMirror32(pSurf)
*
* Mirror the 32BPP surface in X.
*
* History:
*  08-Mar-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrMirror32(SURFACE *pSurf)
{
    DWORD  *pdwSrc;
    DWORD  *pdwTrg;
    DWORD  *pdwBase;
    DWORD   dwTemp;
    LONG    cFlip;
    LONG    x;
    LONG    y;

    pdwBase = (DWORD *) pSurf->pvScan0();
    cFlip   = pSurf->sizl().cx / 2;

    for (y = 0; y < pSurf->sizl().cy; y++)
    {
        pdwSrc = pdwBase;
        pdwTrg = pdwSrc + pSurf->sizl().cx - 1;

        for (x = 0; x < cFlip; x++)
        {
            dwTemp = *pdwSrc;
           *pdwSrc = *pdwTrg;
           *pdwTrg =  dwTemp;
            pdwSrc++;
            pdwTrg--;
        }

        pdwBase = (DWORD *) (((BYTE *) pdwBase) + pSurf->lDelta());
    }
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 1BPP surface.
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft = xLeft >> 5;             // Index of leftmost DWORD
    iLeft = xLeft & 31;             // Bits used in leftmost DWORD
    pulSrc = ((DWORD *) pjSrc) + cLeft;     // Adjust base address

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;
    ulSrc = *pulSrc;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (!(ulSrc & gaulMaskMono[iLeft]))
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iBlack;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iBlack;
            }
            else
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iWhite;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iWhite;
            }

            xLeft++;
            iLeft++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 4BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;

    if (pxlo == NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }
    else
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] &= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] &= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
        }
    }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 8BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pjSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pjSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pjSrc;

            pjSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
    {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= pxlo->pulXlate[*pjSrc];
        else
        while (cnt--)
            pxrl->aul[j++] &= pxlo->pulXlate[*pjSrc];

            pjSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 16BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pwSrc;

        pwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt   = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;


            pwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 24BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG      ulTmp = 0;
    LONG       cnt;
    LONG       i;
    LONG       j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    prgbSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
            *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

            prgbSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
            ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

        prgbSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32AND(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, AND the pels and produce a run
* list for a row of a 32BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32AND(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pdwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] &= *pdwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] &= *pdwSrc;

            pdwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
            cnt = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

        if (!cnt)
        pxrl->aul[j] &= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] &= ulTmp;

        pdwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 1BPP surface.
*
* History:
*  27-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft = xLeft >> 5;             // Index of leftmost DWORD
    iLeft = xLeft & 31;             // Bits used in leftmost DWORD
    pulSrc = ((DWORD *) pjSrc) + cLeft;     // Adjust base address

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo ==  NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;
    ulSrc = *pulSrc;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (!(ulSrc & gaulMaskMono[iLeft]))
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iBlack;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iBlack;
            }
            else
            {
                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iWhite;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iWhite;
            }

            xLeft++;
            iLeft++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 4BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulSrc;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    i = 0;
    j = 0;
    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pxrl->xPos;

    if (pxlo == NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }
    else
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];

                cnt = pdda->al[i++];

                if (!cnt)
                    pxrl->aul[j] |= iColor;
                else
                    while (cnt--)
                        pxrl->aul[j++] |= iColor;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }
    }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 8BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pjSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pjSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pjSrc;

            pjSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
    {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= pxlo->pulXlate[*pjSrc];
        else
        while (cnt--)
            pxrl->aul[j++] |= pxlo->pulXlate[*pjSrc];

            pjSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 16BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pwSrc;

        pwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt   = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;


            pwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 24BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG      ulTmp = 0;
    LONG       cnt;
    LONG       i;
    LONG       j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    prgbSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo ==  NULL)
        while (xLeft != xRght)
        {
            *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

            prgbSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
            ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

        prgbSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32OR(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, xlate colors, OR the pels and produce a run
* list for a row of a 32BPP surface.
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32OR(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG    ulTmp;
    LONG     cnt;
    LONG     i;
    LONG     j;

    DONTUSE(pjMask);
    DONTUSE(xMask);

    pdwSrc += xLeft;

    pxrl->xPos = pdda->rcl.left;
    pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
    i = 0;
    j = 0;

    if (pxlo == NULL)
        while (xLeft != xRght)
        {
        cnt = pdda->al[i++];

        if (!cnt)
        pxrl->aul[j] |= *pdwSrc;
        else
        while (cnt--)
            pxrl->aul[j++] |= *pdwSrc;

            pdwSrc++;
            xLeft++;
        }
    else
        while (xLeft != xRght)
        {
            cnt = pdda->al[i++];
            ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

        if (!cnt)
        pxrl->aul[j] |= ulTmp;
        else
        while (cnt--)
            pxrl->aul[j++] |= ulTmp;

        pdwSrc++;
            xLeft++;
        }

    return((XRUNLEN *) &pxrl->aul[j]);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead01(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 1BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead01(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     xPos;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    cLeft  =  xLeft >> 5;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 31;                   // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
    iBlack = 0;
    iWhite = 1;
    }
    else
    {
    iBlack = pxlo->pulXlate[0];
    iWhite = pxlo->pulXlate[1];
    }

    if (pjMask == (BYTE *) NULL)
    {
    i = 0;
    j = 0;
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pxrl->xPos;

        if (xLeft < xRght)
        {
            while (TRUE)
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        prun->xrl.aul[j++] = iWhite;
                else
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        prun->xrl.aul[j++] = iBlack;

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 32)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
        }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    for (cnt = pdda->al[i]; cnt; cnt--)
                        pxrl->aul[j++] = iWhite;
                else
                    for (cnt = pdda->al[i]; cnt; cnt--)
                        pxrl->aul[j++] = iBlack;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }

                xPos += pdda->al[i];
            }

            xLeft++;
            iLeft++;
            iMask++;
            i++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead04(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 4BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead04(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     xPos;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Nybbles used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    if (pjMask == (BYTE *) NULL)
    {
    i = 0;
    j = 0;
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pxrl->xPos;

        if (pxlo == NULL)
    {
            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        pxrl->aul[j++] = iColor;

                    xLeft++;
                    iLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iLeft & 8)
                    {
                        pulSrc++;
                        ulSrc = *pulSrc;
                        iLeft = 0;
                    }
                }
            }
    }
    else
    {
            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    iColor = pxlo->pulXlate[(ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft]];
                    for (cnt = pdda->al[i++]; cnt; cnt--)
                        pxrl->aul[j++] = iColor;

                    xLeft++;
                    iLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iLeft & 8)
                    {
                        pulSrc++;
                        ulSrc = *pulSrc;
                        iLeft = 0;
                    }
                }
        }
    }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];
            if (pxlo != NULL)
                iColor = pxlo->pulXlate[iColor];

            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }

                xPos += pdda->al[i];
            }

            xLeft++;
            iLeft++;
            iMask++;
            i++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 8)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead08(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 8BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead08(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pjSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pjSrc;

                pjSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = pxlo->pulXlate[*pjSrc];
                pjSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;


    if (xLeft < xRght)
    {
        while(TRUE) 
        {
            iColor = (DWORD) *pjSrc++;
            if (pxlo != NULL)
                iColor = pxlo->pulXlate[iColor];
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
            
            if(xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead16(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 16BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead16(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    ulTmp;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pwSrc;

                pwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                pwSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while(TRUE)
        {
            iColor = (DWORD) *pwSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead24(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 24BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead24(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG     *pulMsk;
    ULONG      ulTmp = 0;
    ULONG      ulMsk;
    ULONG      iColor = 0;
    LONG       iMask;
    LONG       xPos;
    LONG       cnt;
    LONG       i;
    LONG       j;

    prgbSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &ulTmp) = *prgbSrc;

                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = ulTmp;

                prgbSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    *((RGBTRIPLE *) &ulTmp) = *prgbSrc;
                    ulTmp = ((XLATE *) pxlo)->ulTranslate(ulTmp);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                prgbSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE) 
        {
            *((RGBTRIPLE *) &iColor) = *prgbSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* XRUNLEN *pxrlStrRead32(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 32BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

XRUNLEN *pxrlStrRead32(
STRDDA   *pdda,
STRRUN   *prun,
BYTE     *pjSrc,
BYTE     *pjMask,
XLATEOBJ *pxlo,
LONG      xLeft,
LONG      xRght,
LONG      xMask)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulTmp;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     xPos;
    LONG     iMask;
    LONG     cnt;
    LONG     i;
    LONG     j;

    pdwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        pxrl->xPos = pdda->rcl.left;
        pxrl->cRun = pdda->rcl.right - pdda->rcl.left;
        i = 0;
        j = 0;

        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                for (cnt = pdda->al[i++]; cnt; cnt--)
                    pxrl->aul[j++] = *pdwSrc;

                pdwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                cnt = pdda->al[i++];

                if (cnt)
                {
                    ulTmp = ((XLATE *) pxlo)->ulTranslate((ULONG) *pdwSrc);

                    while (cnt--)
                        pxrl->aul[j++] = ulTmp;
                }

                pdwSrc++;
                xLeft++;
            }

        return((XRUNLEN *) &pxrl->aul[j]);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    xPos   =  pdda->rcl.left;
    ulMsk  = *pulMsk;
    i = 0;
    j = 0;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            iColor = *pdwSrc++;
            if (pxlo != NULL)
                iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
    
            if (ulMsk & gaulMaskMono[iMask])
            {
                for (cnt = pdda->al[i]; cnt; cnt--)
                    pxrl->aul[j++] = iColor;
            }
            else
            {
                if (j > 0)
                {
                    pxrl->xPos = xPos;
                    pxrl->cRun = j;
                    pxrl = (XRUNLEN *) &pxrl->aul[j];
                    xPos += j;
                    j = 0;
                }
    
                xPos += pdda->al[i];
            }
    
            xLeft++;
            iMask++;
            i++;
    
            if (xLeft >= xRght) 
              break;
    
            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    if (j > 0)
    {
        pxrl->xPos = xPos;
        pxrl->cRun = j;
        pxrl = (XRUNLEN *) &pxrl->aul[j];
    }

    return(pxrl);
}

/******************************Public*Routine******************************\
* VOID vStrWrite01(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 1BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite01(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    ULONG    ulTemp;
    ULONG    ulMask;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     cLeft;
    LONG     cRght;
    LONG     cByte;
    LONG     iMask;
    LONG     iLeft;
    LONG     iRght;
    LONG     iRep;
    LONG     jDraw;
    BOOL     bValid;

// There maybe no clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);
        jDraw = 0;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            pjDraw = pjCurr = pjBase + (xLeft >> 5);
         iMask = xLeft & 31;
            ulTemp = *pjDraw;

            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    if (pxrl->aul[jDraw++])
                        ulTemp |=  gaulMaskMono[iMask];
                    else
                        ulTemp &= ~gaulMaskMono[iMask];

                    iMask++;
                    xLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iMask & 32)
                    {
                       *pjDraw = ulTemp;
                        pjDraw++;
                        ulTemp = *pjDraw;
                        iMask  = 0;
                    }
                }
            }

           *pjDraw = ulTemp;

            if (prun->cRep > 1)
            {
                iLeft = pxrl->xPos;
                iRght = pxrl->cRun + iLeft;
                cLeft = iLeft >> 5;
                cRght = iRght >> 5;
        iLeft &= 31;
                iRght &= 31;

                if (cLeft == cRght)
                {
                    ulMask = gaulMaskEdge[iLeft] & ~gaulMaskEdge[iRght];

                    for (iRep = 1; iRep < prun->cRep; iRep++)
                    {
                        pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                       *pjDraw = (*pjCurr & ulMask) | (*pjDraw & ~ulMask);
                        pjCurr = pjDraw;
                    }
                }
                else
                {
                    if (iLeft)
                    {
                        ulMask = ~gaulMaskEdge[iLeft];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }

                        cLeft++;
                    }

                    if (cLeft != cRght)
                    {
                        pjCurr = pjBase + cLeft;
                        cByte = (cRght - cLeft) << 2;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                            RtlCopyMemory(pjDraw, pjCurr, cByte);
                            pjCurr = pjDraw;
                        }
                    }

                    if (iRght)
                    {
                        pjCurr = pjBase + cRght;
            ulMask = gaulMaskEdge[iRght];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }
                    }
                }
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
            jDraw = 0;
        }

        return;
    }

// Setup the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL   rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjBase + (xLeft >> 5);
         iMask = xLeft & 31;

                bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                ulTemp  = bValid ? *pjDraw : (ULONG) 0;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                    {
                        if (pxrl->aul[jDraw])
                            ulTemp |=  gaulMaskMono[iMask];
                        else
                            ulTemp &= ~gaulMaskMono[iMask];
                    }

            iMask++;
                    xLeft++;
                    jDraw++;

            if (iMask & 32)
            {
            if (bValid)
                           *pjDraw = ulTemp;

            pjDraw++;
            iMask = 0;

                        bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                        ulTemp = bValid ? *pjDraw : (ULONG) 0;
            }
                }

                if (bValid)
                   *pjDraw = ulTemp;

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite04(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 4BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite04(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    ULONG    ulTemp;
    ULONG    ulMask;
    ULONG    ulShft;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     cLeft;
    LONG     cRght;
    LONG     cByte;
    LONG     iMask;
    LONG     iLeft;
    LONG     iRght;
    LONG     iRep;
    LONG     jDraw;
    BOOL     bValid;

// There maybe no clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);
        jDraw = 0;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

        pjDraw = pjCurr = pjBase + (xLeft >> 3);
            ulTemp = *pjDraw;
         iMask = xLeft & 7;

            if (xLeft < xRght)
            {
                while (TRUE)
                {
                    ulShft = gaulShftQuad[iMask];
                    ulMask = gaulMaskQuad[iMask];

                    ulTemp = (ULONG) ((ulTemp & ~ulMask) |
                                      ((pxrl->aul[jDraw++] << ulShft) & ulMask));

                    iMask++;
                    xLeft++;

                    if (xLeft >= xRght)
                        break;

                    if (iMask & 8)
                    {
                       *pjDraw = ulTemp;
                        pjDraw++;
                        ulTemp = *pjDraw;
                        iMask  = 0;
                    }
                }
            }

           *pjDraw = ulTemp;

            if (prun->cRep > 1)
            {
                iLeft = pxrl->xPos;
                iRght = pxrl->cRun + iLeft;
                cLeft = iLeft >> 3;
                cRght = iRght >> 3;
        iLeft = (iLeft & 7) << 2;
                iRght = (iRght & 7) << 2;

                if (cLeft == cRght)
                {
                    ulMask = gaulMaskEdge[iLeft] & ~gaulMaskEdge[iRght];

                    for (iRep = 1; iRep < prun->cRep; iRep++)
                    {
                        pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                       *pjDraw = (*pjCurr & ulMask) | (*pjDraw & ~ulMask);
                        pjCurr = pjDraw;
                    }
                }
                else
                {
                    if (iLeft)
                    {
                        ulMask = ~gaulMaskEdge[iLeft];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }

                        cLeft++;
                    }

                    if (cLeft != cRght)
                    {
                        pjCurr = pjBase + cLeft;
                        cByte = (cRght - cLeft) << 2;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                            RtlCopyMemory(pjDraw, pjCurr, cByte);
                            pjCurr = pjDraw;
                        }
                    }

                    if (iRght)
                    {
                        pjCurr = pjBase + cRght;
            ulMask = gaulMaskEdge[iRght];
                        ulTemp = *pjCurr & ~ulMask;

                        for (iRep = 1; iRep < prun->cRep; iRep++)
                        {
                            pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                           *pjDraw = ulTemp | (*pjDraw & ulMask);
                            pjCurr = pjDraw;
                        }
                    }
                }
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
            jDraw = 0;
        }

        return;
    }

// Setup the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL   rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjBase + (xLeft >> 3);
         iMask = xLeft & 7;

                bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                ulTemp  = bValid ? *pjDraw : (ULONG) 0;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                    {
                        ulMask = gaulMaskQuad[iMask];
                        ulShft = gaulShftQuad[iMask];

                        ulTemp = (ULONG) ((ulTemp & ~ulMask) |
                                          ((pxrl->aul[jDraw] << ulShft) & ulMask));
                    }

            iMask++;
                    xLeft++;
                    jDraw++;

            if (iMask & 8)
            {
            if (bValid)
               *pjDraw = ulTemp;

            pjDraw++;
            iMask = 0;

                        bValid = ((xLeft >= 0) && (xLeft < pSurf->sizl().cx));
                        ulTemp = bValid ? *pjDraw : (ULONG) 0;
            }
                }

                if (bValid)
                   *pjDraw = ulTemp;

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite08(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 8BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite08(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    BYTE    *pjBase;
    BYTE    *pjCurr;
    BYTE    *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (BYTE) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                RtlCopyMemory(pjCurr + pSurf->lDelta(), pjCurr, pxrl->cRun);
                pjCurr += pSurf->lDelta();
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop;

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (BYTE) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                RtlCopyMemory(pjCurr + pSurf->lDelta(), pjCurr, jByte);
                pjCurr += pSurf->lDelta();
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (BYTE) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase += pSurf->lDelta();
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite16(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 16BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite16(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    WORD    *pjBase;
    WORD    *pjCurr;
    WORD    *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (WORD) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (WORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 2);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (WORD) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (WORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 2);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (WORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (WORD) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (WORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite24(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 24BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite24(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN   *pxrl = &prun->xrl;
    RGBTRIPLE *pjBase;
    RGBTRIPLE *pjCurr;
    RGBTRIPLE *pjDraw;
    LONG       xLeft;
    LONG       xRght;
    LONG       yCurr;
    LONG       iTop;
    LONG       iBot;
    LONG       iRep;
    LONG       jLeft;
    LONG       jRght;
    LONG       jDraw;
    LONG       jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = *((RGBTRIPLE *) &pxrl->aul[jDraw++]);
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (RGBTRIPLE *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 3);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = *((RGBTRIPLE *) &pxrl->aul[jDraw++]);
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (RGBTRIPLE *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 3);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (RGBTRIPLE *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = *((RGBTRIPLE *) &pxrl->aul[jDraw]);

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (RGBTRIPLE *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}

/******************************Public*Routine******************************\
* VOID vStrWrite32(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 32BPP surface.
*
* History:
*  16-Feb-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vStrWrite32(
STRRUN  *prun,
XRUNLEN *pxrlEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    XRUNLEN *pxrl = &prun->xrl;
    DWORD   *pjBase;
    DWORD   *pjCurr;
    DWORD   *pjDraw;
    LONG     xLeft;
    LONG     xRght;
    LONG     yCurr;
    LONG     iTop;
    LONG     iBot;
    LONG     iRep;
    LONG     jLeft;
    LONG     jRght;
    LONG     jDraw;
    LONG     jByte;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * prun->yPos);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;
            jDraw = 0;

            pjDraw = pjCurr = pjBase + xLeft;

            while (xLeft < xRght)
            {
               *pjDraw++ = (DWORD) pxrl->aul[jDraw++];
                xLeft++;
            }

            for (jDraw = 1; jDraw < prun->cRep; jDraw++)
            {
                pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, pxrl->cRun * 4);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }
        return;
    }

    RECTL   rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
        rclClip = pco->rclBounds;

        iTop = prun->yPos;
        iBot = prun->yPos + prun->cRep;

        if ((iTop >= rclClip.bottom) || (iBot <= rclClip.top))
            return;

        iTop = iTop >= rclClip.top ? iTop : rclClip.top;
        iBot = iBot < rclClip.bottom ? iBot : rclClip.bottom;
        iRep = iBot - iTop;

        pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * iTop);

        while (pxrl != pxrlEnd)
        {
            xLeft = pxrl->xPos;
            xRght = pxrl->cRun + xLeft;

            if (xRght < rclClip.left)
            {
                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                continue;
            }

            if (xLeft >= rclClip.right)
                return;

            jLeft = xLeft >= rclClip.left ? xLeft : rclClip.left;
            jRght = xRght < rclClip.right ? xRght : rclClip.right;
            jByte = jRght - jLeft;

            pjDraw = pjCurr = pjBase + jLeft;
            jDraw  = jLeft - xLeft;

            while (jLeft < jRght)
            {
               *pjDraw++ = (DWORD) pxrl->aul[jDraw++];
                jLeft++;
            }

            for (jDraw = 1; jDraw < iRep; jDraw++)
            {
                pjDraw = (DWORD *) ((BYTE *) pjCurr + pSurf->lDelta());
                RtlCopyMemory(pjDraw, pjCurr, jByte * 4);
                pjCurr = pjDraw;
            }

            pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
        }

        return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    yCurr = prun->yPos;
    iRep  = prun->cRep;
    ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    pjBase = (DWORD *) ((BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr);

    while (iRep--)
    {
        if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
        {
            jDraw = 0;

            while (pxrl != pxrlEnd)
            {
                xLeft = pxrl->xPos;
                xRght = pxrl->cRun + xLeft;

                pjDraw = pjCurr = pjBase + xLeft;

                while (xLeft < xRght)
                {
                    if ((xLeft < rclClip.left) || (xLeft >= rclClip.right))
                        ((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xLeft, yCurr);

                    if ((xLeft >= rclClip.left) && (xLeft < rclClip.right))
                       *pjDraw = (DWORD) pxrl->aul[jDraw];

                    pjDraw++;
                    jDraw++;
                    xLeft++;
                }

                pxrl = (XRUNLEN *) &pxrl->aul[pxrl->cRun];
                jDraw = 0;
            }

            pxrl = &prun->xrl;
        }

        pjBase = (DWORD *) ((BYTE *) pjBase + pSurf->lDelta());
        yCurr++;

        if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
            ((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\surfeng.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfeng.cxx
*
* Internal surface routines
*
* Created: 13-May-1991 12:53:31
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitBMOBJ();

#define MAX_STOCKBITMAPS 4*1024 
LONG gStockBitmapFree = MAX_STOCKBITMAPS;

#pragma alloc_text(INIT, bInitBMOBJ)

#if DBG_STOCKBITMAPS
#define STOCKWARNING DbgPrint
#define STOCKINFO    DbgPrint
#else
#define STOCKWARNING
#define STOCKINFO   
#endif

/******************************Public*Routine******************************\
* GreSetBitmapOwner
*
* Sets the bitmap owner.
*
\**************************************************************************/

BOOL
GreSetBitmapOwner(
    HBITMAP hbm,
    W32PID  lPid
    )
{
    BOOL bRet = FALSE;
    SURFREF so((HSURF)hbm);

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection() && (lPid == OBJECT_OWNER_PUBLIC)))
        {
            if(HmgStockObj(hbm)) {
                WARNING("GreSetBitmapOwner: Cannot set owner for the stock bitmap\n");
            } 
            else
            { 
#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                BOOL            bOwned;
                TRACED_SURFACE *pts = (TRACED_SURFACE *)so.ps;

                if (pts->bEnabled())
                {
                    PENTRY  pentTmp = &gpentHmgr[(UINT) HmgIfromH(hbm)];

                    bOwned = ((OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_PUBLIC) &&
                              (OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_NONE));

                    if (bOwned && ((lPid == OBJECT_OWNER_PUBLIC) || (lPid == OBJECT_OWNER_NONE)))
                    {
                        pts->vProcessStackFromUM(TRUE);
                        ASSERTGDI(pentTmp->pUser == NULL, "Object becoming unowned, but user mem is still allocated.\n");
                    }
                }
                else
                {
                    bOwned = TRUE;
                }
#endif
#endif

                bRet = HmgSetOwner((HOBJ)hbm,lPid,SURF_TYPE);

#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                if (!bRet && !bOwned)
                {
                    pts->vProcessStackFromUM(TRUE);
                }
#endif
#endif
            }
        }
        else
        {
            WARNING ("GreSetBitmapOnwer - Setting a DIBSECTION to PUBLIC\n");
        }    
    }
    else
    {
        WARNING1("GreSetBitmapOnwer - invalid surfobj\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreMakeBitmapStock
*
* Makes the bitmap a stock object.
*
* Requirements:
*    Bitmap is already not a stock Object.
*    Bitmap is not a dibsection.
*    Bitmap should not be selected into any DCs.
*    Not more than MAX_STOCKBITMAPS gStockBitmaps. 
*
\**************************************************************************/

HBITMAP
GreMakeBitmapStock(HBITMAP hbm)
{
    HANDLE bRet = 0;
    SURFREFAPI so((HSURF)hbm);

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection()))
        {
            if (HmgStockObj(hbm) || so.ps->cRef())
            {
                STOCKWARNING("GreMakeBitmapStock: cannot make bitmap (%p) stock\nReason:",hbm);
                if (HmgStockObj(hbm))
                    STOCKWARNING(" it is already a stock bitmap\n");
                else 
                    STOCKWARNING(" it is selected into some DC\n");
            } 
            else
            {
                bRet = (HANDLE)((ULONG_PTR)hbm | GDISTOCKOBJ);
                if (InterlockedDecrement(&gStockBitmapFree) >= 0 &&
                    HmgLockAndModifyHandleType((HOBJ)bRet))
                {
                    so.ps->vSetStockSurface(); 
                    so.ps->hsurf(bRet);
                    so.vSetPID(OBJECT_OWNER_PUBLIC);
                 }
                 else
                 {
                     InterlockedIncrement(&gStockBitmapFree);
                     STOCKWARNING ("GreMakeBitmapStock - HmgLockAndModifyHandleType failed\n");
                     bRet = 0;
                 }
            }
        }
        else
        {
            WARNING ("GreMakeBitmapStock - Setting a DIBSECTION to Stock \n");
        }    
    }
    else
    {
        WARNING1("GreMakeBitmapStock - invalid surfobj\n");
    }

    return((HBITMAP)bRet);
}


/******************************Public*Routine******************************\
* GreMakeBitmapNonStock
*
* Makes the bitmap a non stock object.
*
* Requirements:
*    Bitmap is not default stock bitmap
*    Bitmap is a stock bitmap
*    Bitmap is not a dibsection
*    Bitmap is not selected into any DC
*    Some stock bitmaps should exist
*    Bitmap must be public
*
\**************************************************************************/

HBITMAP
GreMakeBitmapNonStock(HBITMAP hbm)
{
    HANDLE bRet = 0;
    SURFREFAPI so((HSURF)hbm);

    ASSERTGDI(GreGetObjectOwner((HOBJ)hbm,SURF_TYPE) == OBJECT_OWNER_PUBLIC,"GreMakeBitmapNonStock() bitmap is not public\n");
    ASSERTGDI(gStockBitmapFree != MAX_STOCKBITMAPS,"GreMakeBitmapNonStock() no stock bitmaps\n");

    if (so.bValid())
    {
        if (!(so.ps->bDIBSection()))
        {
            if (hbm==STOCKOBJ_BITMAP || !HmgStockObj(hbm))
            {
                STOCKWARNING("GreMakeBitmapNonStock: Cannot make stock bitmap (%p) non Stock\nReason:",hbm);
                if (hbm==STOCKOBJ_BITMAP)
                    STOCKWARNING(" it is the default stock bitmap\n");
                else 
                    STOCKWARNING(" it is not a stock bitmap\n");
            } 
            else
            {
                bRet = (HANDLE)((ULONG_PTR)hbm & ~GDISTOCKOBJ);

                if (so.ps->cRef())
                {
                    so.ps->vSetUndoStockSurfaceDelayed();
                    STOCKWARNING("GreMakeBitmapNonStock: Delaying make stock bitmap (%p) non Stock\n",hbm);
                }
                else if(HmgLockAndModifyHandleType((HOBJ)bRet))
                {
                    InterlockedIncrement(&gStockBitmapFree);

                    so.ps->vClearStockSurface(); 
                    so.ps->hsurf(bRet);
                    so.vSetPID(OBJECT_OWNER_CURRENT);

                 }
                 else
                 {
                     STOCKWARNING ("GreMakeBitmapNonStock - HmgLockAndModifyHandleType failed\n");
                     bRet = 0;
                 }
            }
        }
        else
        {
            WARNING ("GreMakeBitmapNonStock - DIBSECTION to set as non stock\n");
        }    
    }
    else
    {
        WARNING1("GreMakeBitmapNonStock - invalid surfobj\n");
    }

    return((HBITMAP)bRet);
}
/******************************Public*Routine******************************\
* bInitBMOBJ
*
* Initializes the default bitmap.
*
* History:
*  14-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitBMOBJ()
{
    HBITMAP hbmTemp = GreCreateBitmap(1, 1, 1, 1, (LPBYTE) NULL);

    if (hbmTemp == (HBITMAP) 0)
    {
        WARNING("Failed to create default bitmap\n");
        return(FALSE);
    }


    SURFREF so((HSURF)hbmTemp);

    ASSERTGDI(so.bValid(), "ERROR it created but isn't lockable STOCKOBJ_BITMAP");
    ASSERTGDI(so.ps->ppal() == ppalMono, "ERROR the default bitmap has no ppalMono");

    so.vSetPID(OBJECT_OWNER_PUBLIC);

    bSetStockObject(hbmTemp,PRIV_STOCK_BITMAP);
    so.ps->hsurf((HANDLE)((ULONG_PTR)hbmTemp | GDISTOCKOBJ));

    SURFACE::pdibDefault = so.ps;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bDeleteSurface(HSURF)
*
* Delete the surface object
*
* History:
*  Sun 14-Apr-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL bDeleteSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    return(so.bDeleteSurface());        // bDeleteSurface() checks bValid()
}

/******************************Public*Routine******************************\
* hbmSelectBitmap
*
* Select the bitmap into a DC.  Provides option to override the
* DirectDraw surface check.
*
* History:
*  Wed 28-Aug-1991 -by- Patrick Haluptzok [patrickh]
* update it, make palette aware.
*
*  Mon 13-May-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP hbmSelectBitmap(HDC hdc, HBITMAP hsurf, BOOL bDirectDrawOverride)
{
    HSURF hsurfReturn = (HSURF) 0;
    BOOL  bDelete = FALSE;

    //
    // Grab multi-lock so noone can select or delete it.
    //

    MLOCKOBJ mlo;

    //
    // Lock bitmap
    //

    SURFREF  SurfBoNew;
    SurfBoNew.vMultiLock((HSURF) hsurf);

    MDCOBJ   dco(hdc);

    if (dco.bValid() && SurfBoNew.bValid())
    {
        PSURFACE pSurfNew = SurfBoNew.ps;

        ASSERTGDI(DIFFHANDLE(hsurf,STOCKOBJ_BITMAP) ||
                  (pSurfNew->cRef() == 0) , "ERROR STOCKOBJ_BITMAP cRef != 0");

        PDEVOBJ po(dco.hdev());
        PPALETTE ppalSrc;

        PROCESS_UM_TRACE(pSurfNew, FALSE);

        if ((dco.dctp() == DCTYPE_MEMORY) &&
            ((pSurfNew->cRef() == 0 || pSurfNew->bStockSurface()) || SAMEHANDLE(pSurfNew->hdc(),dco.hdc())) &&
            (bIsCompatible(&ppalSrc, pSurfNew->ppal(), pSurfNew, dco.hdev())))
        {
            //
            // Note: pSurfOld not safe outside of the MLOCKOBJ.
            //

            SURFACE *pSurfOld = dco.pSurfaceEff();

            //
            // Only DirectDraw itself may select DirectDraw surfaces
            // into, or out of, DCs.  This is because DirectDraw has
            // to track the DCs to be able to mark them as 'bInFullScreen'
            // when the corresponding DirectDraw surface is 'lost'.
            //

            if ((pSurfOld->bApiBitmap() && pSurfNew->bApiBitmap()) ||
                (bDirectDrawOverride))
            {
                //
                // If this DC is mirrored then turn the mirroring off
                // And turn it on after selecting the bitmap to set the correct
                // Window Org.
                //
                DWORD dwLayout = dco.pdc->dwLayout();
                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    dco.pdc->dwSetLayout(-1 , 0);
                }
                if (pSurfNew->ppal() != ppalSrc)
                {
                    pSurfNew->flags(pSurfNew->flags() | PALETTE_SELECT_SET);
                    pSurfNew->ppal(ppalSrc);
                }
                HSURF hsurfDelete = (HSURF)
                    (pSurfOld->bLazyDelete() ? pSurfOld->hGet() : NULL);
                hsurfReturn = pSurfOld->hsurf();

                if (DIFFHANDLE((HSURF) hsurf, hsurfReturn))
                {
                    if (pSurfNew->bIsDefault())
                    {
                        dco.pdc->pSurface((SURFACE *) NULL);
                    }
                    else
                    {
                        dco.pdc->pSurface((SURFACE *) pSurfNew);

                        if (pSurfNew->bStockSurface())
                            dco.pdc->bStockBitmap(TRUE);
                        else
                            dco.pdc->bStockBitmap(FALSE);
                    }

                    dco.pdc->sizl(pSurfNew->sizl());
                    dco.pdc->ulDirtyAdd(DIRTY_BRUSHES);

                    //
                    // Lower the reference count on the old handle
                    //

                    if (!pSurfOld->bIsDefault())
                    {
                        pSurfOld->vDec_cRef();
                        if (pSurfOld->cRef() == 0)
                        {
                            //
                            // Remove reference to device palette if it has one.
                            //

                            if (pSurfOld->flags() & PALETTE_SELECT_SET)
                                pSurfOld->ppal(NULL);

                            pSurfOld->flags(pSurfOld->flags() & ~PALETTE_SELECT_SET);
                        }
                    }

                    //
                    // Device Format Bitmaps hooked by the driver must always
                    // have devlock synchronization.
                    //
                    // Other device-dependent bitmaps must have devlock
                    // synchronization if they can be affected by dynamic mode
                    // changes, because they may have to be converted on-the-fly
                    // to DIBs.
                    //

                    dco.bSynchronizeAccess(
                        (pSurfNew->bUseDevlock()) ||
                        (pSurfNew->bDeviceDependentBitmap() && po.bDisplayPDEV()));

                    dco.bShareAccess(dco.bSynchronizeAccess() && pSurfNew->bShareAccess());

                    //
                    // Put the relevant DC information into the surface as long as it's not
                    // the default surface.
                    //

                    if (!pSurfNew->bIsDefault())
                    {
                        pSurfNew->vInc_cRef();
                        if (!pSurfNew->bStockSurface())
                        {
                            pSurfNew->hdc(dco.hdc());
                            pSurfNew->hdev(dco.hdev());
                        }
                    }

                    //
                    // set DIBSection flag in DC
                    //

                    dco.pdc->vDIBSection(pSurfNew->bDIBSection());

                    //
                    // set DIBColorSpace indentifier.
                    //

                    if (pSurfNew->bDIBSection())
                    {
                        dco.pdc->dwDIBColorSpace(pSurfNew->dwDIBColorSpace());
                    }
                    else
                    {
                        dco.pdc->dwDIBColorSpace(0);
                    }

                    mlo.vDisable();

                    dco.pdc->bSetDefaultRegion();

                    dco.pdc->vUpdate_VisRect(dco.pdc->prgnVis());

                    if (hsurfDelete)
                    {
                        //
                        // We need one shared lock for bDeleteSurface to succeed:
                        //

                        SURFREF so(hsurfDelete);
                        so.bDeleteSurface();

                        hsurfReturn = (HSURF)STOCKOBJ_BITMAP;
                    }
                }
                //
                // If it was mirrored then turn back the mirroring on.
                //
                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    dco.pdc->dwSetLayout(-1 , dwLayout);
                }
            }
            else
            {
                WARNING("hbmSelectBitmap failed, unselectable surface\n");
            }
        }
        else
        {
            WARNING1("hbmSelectBitmap failed selection, bitmap doesn't fit into DC\n");
        }
    }
    else
    {
#if DBG
        if (dco.bValid())
        {
            WARNING1("hbmSelectBitmap given invalid bitmap\n");
        }
        else
        {
            WARNING1("hbmSelectBitmap given invalid DC\n");
        }
#endif
    }

    return((HBITMAP) hsurfReturn);
}

/******************************Public*Routine******************************\
* GreSelectBitmap
*
* Select the bitmap into a DC.  User and the like will call this function.
*
\**************************************************************************/

HBITMAP GreSelectBitmap(HDC hdc, HBITMAP hsurf)
{
    return(hbmSelectBitmap(hdc, hsurf, FALSE));
}

/******************************Public*Routine******************************\
* hbmCreateClone
*
* Creates an engine managed clone of a bitmap.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* Synchronize the call if it's a DFB that needs synching.
*
*  19-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateClone(SURFACE *pSurfSrc, ULONG cx, ULONG cy)
{

    ASSERTGDI(pSurfSrc != NULL, "ERROR hbmCreateClone invalid src");

    ASSERTGDI((pSurfSrc->iType() == STYPE_BITMAP) ||
              (pSurfSrc->iType() == STYPE_DEVBITMAP), "ERROR hbmCreateClone src type");

    DEVBITMAPINFO dbmi;

    dbmi.iFormat = pSurfSrc->iFormat();

    if ((cx == 0) || (cy == 0))
    {
        dbmi.cxBitmap = pSurfSrc->sizl().cx;
        dbmi.cyBitmap = pSurfSrc->sizl().cy;
    }
    else
    {
        ASSERTGDI(cx <= LONG_MAX, "hbmCreateClone: cx too large\n");
        dbmi.cxBitmap = min(pSurfSrc->sizl().cx,(LONG)cx);

        ASSERTGDI(cy <= LONG_MAX, "hbmCreateClone: cy too large\n");
        dbmi.cyBitmap = min(pSurfSrc->sizl().cy,(LONG)cy);
    }

    dbmi.hpal = (HPALETTE) 0;

    if (pSurfSrc->ppal() != NULL)
    {
        dbmi.hpal = (HPALETTE) pSurfSrc->ppal()->hGet();
    }

    dbmi.fl = BMF_TOPDOWN;

    HBITMAP hbmReturn = (HBITMAP) 0;

    SURFMEM SurfDimo;

    if (SurfDimo.bCreateDIB(&dbmi, NULL))
    {
        POINTL ptlSrc;
        ptlSrc.x = 0;
        ptlSrc.y = 0;

        RECTL rclDst;
        rclDst.left  = 0;
        rclDst.right  = dbmi.cxBitmap;
        rclDst.top    = 0;
        rclDst.bottom = dbmi.cyBitmap;

        HSEMAPHORE hsemDevLock = NULL;
        PPDEV ppdev            = NULL;

        if (pSurfSrc->bUseDevlock())
        {
            PDEVOBJ po(pSurfSrc->hdev());
            ASSERTGDI(po.bValid(), "PDEV invalid");
            hsemDevLock = po.hsemDevLock();
            ppdev       = po.ppdev;
            GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
        }

        if (EngCopyBits( SurfDimo.pSurfobj(),        // Destination surfobj
                         pSurfSrc->pSurfobj(),       // Source surfobj.
                         (CLIPOBJ *) NULL,           // Clip object.
                         &xloIdent,                  // Palette translation object.
                         &rclDst,                    // Destination rectangle.
                         &ptlSrc ))
        {
            SurfDimo.vKeepIt();
            hbmReturn = (HBITMAP) SurfDimo.ps->hsurf();
        }
        else
        {
            WARNING("ERROR hbmCreateClone failed EngBitBlt\n");
        }

        if (hsemDevLock)
        {
            GreExitMonitoredSection(ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(hsemDevLock);
        }
    }
    else
    {
        WARNING("ERROR hbmCreateClone failed DIB allocation\n");
    }

    return(hbmReturn);
}



/******************************Public*Routine******************************\
* NtGdiGetDCforBitmap
*
* Get the DC that the bitmap is selected into
*
* History:
* 12-12-94 -by- Lingyun Wang[lingyunw]
* Wrote it.
\**************************************************************************/

HDC NtGdiGetDCforBitmap(HBITMAP hsurf)
{
    HDC      hdcReturn = 0;
    SURFREF   so((HSURF) hsurf);

    if (so.bValid())
    {
        hdcReturn = so.ps->hdc();
    }

    return(hdcReturn);
}

/******************************Public*Routine******************************\
* NtGdiColorSpaceforBitmap
*
* Get the color space data for this bitmap
*
* History:
* 06-06-97 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

ULONG_PTR NtGdiGetColorSpaceforBitmap(HBITMAP hsurf)
{
    ULONG_PTR  dwReturn = 0;
    SURFREF   so((HSURF) hsurf);

    if (so.bValid() && so.ps->bDIBSection())
    {
        dwReturn = so.ps->dwDIBColorSpace();
    }

    return(dwReturn);
}

/******************************Public*Routine******************************\
* GreMakeInfoDC()
*
*   This routine is used to take a printer DC and temporarily make it a
*   Metafile DC for spooled printing.  This way it can be associated with
*   an enhanced metafile.  During this period, it should look and act just
*   like an info DC.
*
*   bSet determines if it should be set into the INFO DC state or restored
*   to the Direct state.
*
* History:
*  04-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiMakeInfoDC(
    HDC  hdc,
    BOOL bSet)
{
    ASSERTGDI(LO_TYPE(hdc) == LO_ALTDC_TYPE,"GreMakeInfoDC - not alt type\n");

    BOOL bRet = FALSE;

    XDCOBJ dco( hdc );

    if (dco.bValid())
    {
        bRet = dco.pdc->bMakeInfoDC(bSet);
        dco.vUnlockFast();
    }

    return(bRet);
}

/******************************Private*Routine*****************************\
* BOOL pConvertDfbSurfaceToDib
*
* Converts a compatible bitmap into an engine managed bitmap.  Note that
* if the bitmap is currently selected into a DC, bConvertDfbDcToDib should
* be called.
*
* The devlock must be already be held.
*
* History:
*  Wed 5-May-1994 -by- Tom Zakrajsek [tomzak]
* Wrote it (with lots of help from PatrickH and EricK).
\*************************************************************************/

SURFACE* pConvertDfbSurfaceToDib
(
    HDEV     hdev,
    SURFACE *pSurfOld,
    LONG     ExpectedShareCount
)
{
    BOOL     b;
    SURFACE *pSurfNew;
    SURFACE *pSurfRet;

#if TEXTURE_DEMO
    if (ghdevTextureParent)
    {
        return(NULL);
    }
#endif

    pSurfRet = NULL;

    ASSERTGDI((pSurfOld != NULL),
        "pConvertDfbSurfaceToDib: pSurf attached to the DC is NULL\n");

    ASSERTGDI((pSurfOld->bRedirection() == FALSE),
        "pConvertDfbSurfaceToDib: pSurf is a redirection surface");

    //
    // GDI surfaces wrapped around DirectDraw surfaces cannot be
    // converted (DirectDraw wouldn't know about its new state).
    //
    // Similarly, we can't convert surfaces that are the primary
    // screen!
    //

    if (pSurfOld->bDirectDraw() || pSurfOld->bPDEVSurface())
    {
        return(NULL);
    }

    //
    // Create a DIB (dimoCvt) with the same height,width,
    // and BPP as the DEVBITMAP attached to the DC and
    // then replace the DEVBITMAP with the DIB
    //

    SURFMEM         dimoCvt;
    DEVBITMAPINFO   dbmi;
    ERECTL          ercl(0, 0, pSurfOld->sizl().cx, pSurfOld->sizl().cy);
    PDEVOBJ         po(hdev);

    //
    // Figure out what format the engine should use by looking at the
    // size of palette.  This is a clone from CreateCompatibleBitmap().
    //

    dbmi.iFormat    = pSurfOld->iFormat(); 
    dbmi.cxBitmap   = pSurfOld->sizl().cx;
    dbmi.cyBitmap   = pSurfOld->sizl().cy;
    dbmi.hpal       = 0;
    dbmi.fl         = BMF_TOPDOWN;

    if (dimoCvt.bCreateDIB(&dbmi, NULL))
    {
        pSurfNew = dimoCvt.ps;

        //
        // Fill in other necessary fields
        //

        ASSERTGDI(pSurfOld->hdev() == hdev, "hdev's don't match");

        pSurfNew->hdev(hdev);

        //
        // Copy the area as big as the bitmap
        //

        if ((*PPFNGET(po, CopyBits, pSurfOld->flags()))
                (
                dimoCvt.pSurfobj(),           // destination surface
                pSurfOld->pSurfobj(),         // source surface
                (CLIPOBJ *)NULL,              // clip object
                &xloIdent,                    // palette translation object
                (RECTL *) &ercl,              // destination rectangle
                (POINTL *) &ercl              // source origin
                ))
        {
            MLOCKOBJ mlo;
            LONG SurfTargShareCount;

            SurfTargShareCount = HmgQueryAltLock((HOBJ)pSurfOld->hsurf());

            if (SurfTargShareCount == ExpectedShareCount)
            {
                BOOL bStockSurface =  pSurfOld->bStockSurface();
                BOOL bUndoStockSurfaceDelayed = pSurfOld->bUndoStockSurfaceDelayed();

                if (HmgSwapLockedHandleContents((HOBJ)pSurfOld->hsurf(),
                                          SurfTargShareCount,
                                          (HOBJ)pSurfNew->hsurf(),
                                          HmgQueryAltLock((HOBJ)pSurfNew->hsurf()),
                                          SURF_TYPE))
                {
                    //
                    // Swap necessary fields between the bitmaps
                    // hsurf, hdc, cRef, hpalHint, sizlDim, ppal, SurfFlags
                    //

                    HSURF hsurfTemp = pSurfOld->hsurf();
                    pSurfOld->hsurf(pSurfNew->hsurf());
                    pSurfNew->hsurf(hsurfTemp);

                    HDC hdcTemp = pSurfOld->hdc();
                    pSurfOld->hdc(pSurfNew->hdc());
                    pSurfNew->hdc(hdcTemp);

                    ULONG cRefTemp = pSurfOld->cRef();
                    pSurfOld->cRef(pSurfNew->cRef());
                    pSurfNew->cRef(cRefTemp);

                    HPALETTE hpalTemp = pSurfOld->hpalHint();
                    pSurfOld->hpalHint(pSurfNew->hpalHint());
                    pSurfNew->hpalHint(hpalTemp);

                    SIZEL sizlTemp = pSurfOld->sizlDim();
                    pSurfOld->sizlDim(pSurfNew->sizlDim());
                    pSurfNew->sizlDim(sizlTemp);

                    PPALETTE ppalTemp = pSurfOld->ppal();
                    pSurfOld->ppal(pSurfNew->ppal());
                    pSurfNew->ppal(ppalTemp);

                    FLONG flagsTemp = pSurfOld->flags();
                    pSurfOld->flags((pSurfOld->flags() & ~SURF_FLAGS) | (pSurfNew->flags() & SURF_FLAGS));
                    pSurfNew->flags((pSurfNew->flags() & ~SURF_FLAGS) | (flagsTemp & SURF_FLAGS));

                    //
                    // Some flags have to stay with the original surface,
                    // so swap them yet again to go back to the original:
                    //

                    #define KEEP_FLAGS ENG_CREATE_DEVICE_SURFACE

                    flagsTemp = pSurfOld->flags();
                    pSurfOld->flags((pSurfOld->flags() & ~KEEP_FLAGS) | (pSurfNew->flags() & KEEP_FLAGS));
                    pSurfNew->flags((pSurfNew->flags() & ~KEEP_FLAGS) | (flagsTemp & KEEP_FLAGS));

#if TRACE_SURFACE_ALLOCS
                    // We don't care about copying the current allocation trace
                    // to the old object.
                    if (TRACED_SURFACE::bEnabled())
                    {
                        TRACED_SURFACE *ptsOld = (TRACED_SURFACE *)pSurfOld;
                        TRACED_SURFACE *ptsNew = (TRACED_SURFACE *)pSurfNew;

                        ptsNew->Trace = ptsOld->Trace;

#if TRACE_SURFACE_USER_CHAIN_IN_UM
                        // pUser values were swapped in HmgSwapLockedHandleContents.
                        // Swap them back since object owners weren't swapped.
                        // It doesn't matter if TRACED_SURFACE::bUserChainInUM
                        //  is enable, since pUser is unused if not enabled.
                        PENTRY  pEntryOld = &gpentHmgr[HmgIfromH(pSurfOld->hGet())];
                        PENTRY  pEntryNew = &gpentHmgr[HmgIfromH(pSurfNew->hGet())];
                        PVOID   pUserTemp = pEntryOld->pUser;
                        pEntryOld->pUser = pEntryNew->pUser;
                        pEntryNew->pUser = pUserTemp;
#endif
                    }
#endif

                    if (bStockSurface)
                    {
                        DC* pdc;
                        HOBJ hObj = 0;

                        pSurfOld->vClearStockSurface();
                        pSurfNew->vSetStockSurface();

                        STOCKINFO("Transfer Stock Bitmap State from %p to %p\n", pSurfOld, pSurfNew);

                        if (bUndoStockSurfaceDelayed)
                        {
                            STOCKINFO("Transfer Delayed Undo Stock Bitmap State from %p to %p\n", pSurfOld, pSurfNew);
                            pSurfNew->vSetUndoStockSurfaceDelayed();
                        }

                        // As its a Stock surface it may be selected into many DCs. Run thru all of them
                        // and replace with new .

                        while (pdc = (DC*) HmgSafeNextObjt(hObj, DC_TYPE))
                        {
                            hObj = (HOBJ)pdc->hGet();

                            if ((pdc->pSurface() == pSurfOld))
                            {
                                STOCKINFO("Updating DC (%p) which refs old stockbmp %p with new stockbmp %p\n", pdc, pSurfOld, pSurfNew);
                                pdc->flbrushAdd(DIRTY_BRUSHES);
                                pdc->pSurface(pSurfNew);

                                MDCOBJA dco((HDC)hObj);
                                LONG lNumLeft = dco.lSaveDepth();
                                HDC hdcSave = dco.hdcSave();

                                while (lNumLeft > 1)
                                {
                                    MDCOBJA dcoTmp(hdcSave);
                                    if (dcoTmp.pSurface() == pSurfOld)
                                    {
                                        dcoTmp.pdc->pSurface(pSurfNew);
                                    }
                                    lNumLeft = dcoTmp.lSaveDepth();
                                    hdcSave = dcoTmp.hdcSave();
                                }
                            }
                        }
		    }
                    //
                    // Destroy the DFB
                    //
                    // If the deletion fails, we're toast, since a bad,
                    // stale surface will have been left in the handle
                    // table.  So on the next mode-change, when we walk
                    // the table looking at all surfaces belonging to
                    // this HDEV, we'd crash.
                    //

                    mlo.vDisable();
                    b = pSurfOld->bDeleteSurface();
                    ASSERTGDI(b, "A bad surface is left in handle table");

                    //
                    // Keep a reference to the new surface.
                    //

                    dimoCvt.vKeepIt();
                    dimoCvt.ps = NULL;

                    pSurfRet = pSurfNew;
                }
                else
                {
                    WARNING("pConvertDfbSurfaceToDib failed to swap bitmap handles\n");
                }
            }
            else
            {
                WARNING("pConvertDfbSurfaceToDib someone else is holding a lock\n");
            }
        }
        else
        {
            WARNING("pConvertDfbSurfaceToDib failed copying DFB to DIB\n");
        }
    }

    return(pSurfRet);
}

/******************************Private*Routine*****************************\
* BOOL bConvertDfbDcToDib
*
* Converts a compatible bitmap that is currently selected into a DC
* into an engine managed bitmap.
*
* The Devlock must already be held.  Some sort of lock must also be held
* to prevent SaveDC/RestoreDC operations from occuring -- either via an
* exclusive DC lock or some other lock.
*
* History:
*  Wed 5-May-1994 -by- Tom Zakrajsek [tomzak]
* Wrote it (with lot's of help from PatrickH and EricK).
\*************************************************************************/

BOOL bConvertDfbDcToDib
(
    XDCOBJ * pdco
)
{
    SURFACE *pSurfOld;
    SURFACE *pSurfNew;

    ASSERTDEVLOCK(pdco->pdc);

    pSurfOld = pdco->pSurface();
    pSurfNew = pConvertDfbSurfaceToDib(pdco->hdev(),
                                       pSurfOld,
                                       pSurfOld->cRef());

    if (pSurfNew)
    {
        //
        // Make sure that the surface pointers in any EBRUSHOBJ's get
        // updated, by ensuring that vInitBrush() gets called the next
        // time any brush is used in this DC.
        //

        pdco->pdc->flbrushAdd(DIRTY_BRUSHES);

        //
        // Replace the pSurf reference in the DCLEVEL
        //

        pdco->pdc->pSurface(pSurfNew);

        //
        // Walk the saved DC chain
        //

        LONG lNumLeft = pdco->lSaveDepth();
        HDC  hdcSave = pdco->hdcSave();

        while (lNumLeft > 1)
        {
            MDCOBJA dcoTmp(hdcSave);

            //
            // Replace all references to pSurfOld with references to pSurfNew
            //

            if (dcoTmp.pSurface() == pSurfOld)
            {
                dcoTmp.pdc->pSurface(pSurfNew);
            }

            lNumLeft = dcoTmp.lSaveDepth();
            hdcSave = dcoTmp.hdcSave();
        }
    }

    return(pSurfNew != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\surfddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfddi.cxx
*
* Surface DDI callback routines
*
* Created: 23-Aug-1990
* Author: Greg Veres [w-gregv]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngMarkBandingSurface
*
* DDI entry point to mark a surface as a banding surface meaning we should
* capture all output to it in a metafile.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngMarkBandingSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    ASSERTGDI(so.bValid(), "ERROR EngMarkBandingSurfae invalid HSURF passed in\n");

    so.ps->vSetBanding();

    return(TRUE);
}

/******************************Public*Routine******************************\
* hbmCreateDriverSurface
*
* Common entry point for creating DDI surfaces.
*
* History:
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateDriverSurface(ULONG iType, DHSURF dhsurf, SIZEL sizl, LONG lWidth,
                               ULONG iFormat, FLONG fl, PVOID pvBits)
{
    DEVBITMAPINFO dbmi;
    ULONG cjWidth = (ULONG) lWidth;

    dbmi.iFormat = iFormat & ~UMPD_FLAG;
    dbmi.cxBitmap = sizl.cx;
    dbmi.cyBitmap = sizl.cy;
    dbmi.hpal = (HPALETTE) 0;
    dbmi.fl = fl;

    //
    // convert from bytes to pels if given a buffer and cjWidth.  If either
    // of these are set to 0 use what DIBMEMOBJ computes.
    //

    if ((pvBits) && (cjWidth))
    {
        switch (dbmi.iFormat)
        {
        case BMF_1BPP:
            dbmi.cxBitmap = cjWidth * 8;
            break;

        case BMF_4BPP:
            dbmi.cxBitmap = cjWidth * 2;
            break;

        case BMF_8BPP:
            dbmi.cxBitmap = cjWidth;
            break;

        case BMF_16BPP:
            dbmi.cxBitmap = cjWidth / 2;
            break;

        case BMF_24BPP:
            dbmi.cxBitmap = cjWidth / 3;
            break;

        case BMF_32BPP:
            dbmi.cxBitmap = cjWidth / 4;
            break;
        }
    }

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, pvBits);

    if (!SurfDimo.bValid())
    {
        //
        // Constructor logs error code.
        //

        return((HBITMAP) 0);
    }

    //
    // We have to mark the surface with a special flag indicating it was
    // created via EngCreateDeviceBitmap, instead of just looking for
    // STYPE_DEVBITMAP, because EngModifySurface can change the type to
    // STYPE_BITMAP yet we still want to cleanup the surface by calling
    // DrvDeleteDeviceBitmap.
    //

    if (iType == STYPE_DEVBITMAP)
    {
        SurfDimo.ps->vSetEngCreateDeviceBitmap();
    }

    if (iType != STYPE_BITMAP)
    {
        SurfDimo.ps->lDelta(0);
        SurfDimo.ps->pvScan0(NULL);
        SurfDimo.ps->pvBits(NULL);
    }

    SurfDimo.ps->vSetDriverCreated();
    SurfDimo.ps->sizl(sizl);
    SurfDimo.ps->dhsurf(dhsurf);
    SurfDimo.ps->iType(iType);
    SurfDimo.vKeepIt();

    //
    // charge the surface from umpd driver against the process
    // so we can clean it up afterwards
    //

    if (!(iFormat & UMPD_FLAG))
        SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);
    else
        SurfDimo.ps->vSetUMPD();

    return((HBITMAP) SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* EngCreateBitmap
*
* DDI entry point to create a engine bitmap surface.
*
* History:
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP EngCreateBitmap(SIZEL sizl, LONG lWidth, ULONG iFormat, FLONG fl, PVOID pvBits)
{
    return(hbmCreateDriverSurface(STYPE_BITMAP, NULL, sizl, lWidth, iFormat,
                                  fl, pvBits));
}

/******************************Public*Routine******************************\
* EngCreateDeviceBitmap
*
* DDI entry point to create device managed bitmap.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP EngCreateDeviceBitmap(DHSURF dhsurf, SIZEL sizl, ULONG iFormat)
{
    return(hbmCreateDriverSurface(STYPE_DEVBITMAP, dhsurf, sizl, 0, iFormat,
                                  0, (PVOID)UIntToPtr( 0xdeadbeef )));
}

/******************************Public*Routine******************************\
* EngCreateDeviceSurface
*
* DDI entry point to create device managed bitmap.
*
* History:
*  10-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HSURF EngCreateDeviceSurface(DHSURF dhsurf, SIZEL sizl, ULONG iFormat)
{
    //
    // [NT 4.0 compatible]
    //
    //  EngCreateDeviceSurface in NT4, does not fail with invalid iFormat
    // (especially 0, Adobe Acrobat 3.01 - PDFKD.DLL calls with 0 at least).
    // So we replace the wrong data with something valid, here.
    //
    switch (iFormat & ~UMPD_FLAG)
    {
        case BMF_1BPP:
        case BMF_4BPP:
        case BMF_8BPP:
        case BMF_16BPP:
        case BMF_24BPP:
        case BMF_32BPP:
            break;

        default:
            //
            // UMPD_FLAG should be preserved.
            //
            iFormat = (iFormat & UMPD_FLAG) | BMF_1BPP;
    }

    return((HSURF) hbmCreateDriverSurface(STYPE_DEVICE, dhsurf, sizl, 0,
                                          iFormat, 0, (PVOID)UIntToPtr( 0xdeadbeef )));
}

/******************************Public*Routine******************************\
* EngDeleteSurface
*
* DDI entry point to delete a surface.
*
* History:
*  Thu 12-Mar-1992 -by- Patrick Haluptzok [patrickh]
* change to bool return.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngDeleteSurface(HSURF hsurf)
{
    BOOL bReturn = TRUE;

    if (hsurf != 0)
    {
        bReturn = bDeleteSurface(hsurf);
    }

    ASSERTGDI(bReturn, "ERROR EngDeleteSurface failed");

    return(bReturn);
}

/******************************Public*Routine******************************\
* EngLockSurface
*
* DDI entry point to lock down a surface handle.
*
* History:
*  Thu 27-Aug-1992 -by- Patrick Haluptzok [patrickh]
* Remove SURFOBJ accelerator allocation.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

SURFOBJ *EngLockSurface(HSURF hsurf)
{
    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    if (so.bValid())
    {
        so.vKeepIt();
        return(so.pSurfobj());
    }
    else
    {
        WARNING("EngLockSurface failed to lock handle\n");
        return((SURFOBJ *) NULL);
    }
}

/******************************Public*Routine******************************\
* EngUnlockSurface
*
* DDI entry point to unlock a surface that has been locked
* with EngLockSurface.
*
* History:
*  Thu 27-Aug-1992 -by- Patrick Haluptzok [patrickh]
* Remove SURFOBJ accelerator allocation.
*
*  11-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID EngUnlockSurface(SURFOBJ *pso)
{
    if (pso != (SURFOBJ *) NULL)
    {

        SURFACE *ps = SURFOBJ_TO_SURFACE_NOT_NULL(pso);

        if (ps == HmgReferenceCheckLock((HOBJ)pso->hsurf,SURF_TYPE,FALSE))
        {
            SURFREF su(pso);

            su.vUnreference();
        }
    }
}


#if DBG
BOOL PanCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);

VOID vAssertValidHookFlags(PDEVOBJ *pdo, SURFREF *pso) 
{
    FLONG flHooks;
    flHooks = pso->ps->flags();


    //
    // Check to make sure we haven't disabled h/w accelerations and are now
    // using the panning driver (unaccelerated driver).
    //

    if(PPFNDRV(*pdo, CopyBits)!=PanCopyBits) {
        //
        // Assert that the driver provides a routine entry point to match each
        // Hooked flag. 
        //
        // PPFNGET returns the driver routine if the appropriate flag is set.
        // if the flag is set and the routine is NULL, we ASSERT.
        //
        // if the flag is not set, then PPFNGET returns the Eng routine, which
        // better not be NULL, so we ASSERT if it is.
        //
    
        ASSERTGDI( (PPFNGET(*pdo, BitBlt, flHooks)), 
                   "HOOK_BITBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StretchBlt, flHooks)), 
                   "HOOK_STRETCHBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, PlgBlt, flHooks)), 
                   "HOOK_PLGBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, TextOut, flHooks)), 
                   "HOOK_TEXTOUT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, Paint, flHooks)), 
                   "HOOK_PAINT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StrokePath, flHooks)), 
                   "HOOK_STROKEPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, FillPath, flHooks)), 
                   "HOOK_FILLPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StrokeAndFillPath, flHooks)), 
                   "HOOK_STROKEANDFILLPATH specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, LineTo, flHooks)), 
                   "HOOK_LINETO specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, CopyBits, flHooks)), 
                   "HOOK_COPYBITS specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, StretchBltROP, flHooks)), 
                   "HOOK_STRETCHBLTROP specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, TransparentBlt, flHooks)), 
                   "HOOK_TRANSPARENTBLT specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, AlphaBlend, flHooks)), 
                   "HOOK_ALPHABLEND specified, but entry is NULL");
        ASSERTGDI( (PPFNGET(*pdo, GradientFill, flHooks)), 
                   "HOOK_GRADIENTFILL specified, but entry is NULL");
    
        ASSERTGDI( ((flHooks & HOOK_SYNCHRONIZE) == 0 || 
                   pdo->ppfn(INDEX_DrvSynchronize) != NULL ||
                   pdo->ppfn(INDEX_DrvSynchronizeSurface != NULL)),
                   "HOOK_SYNCHRONIZE specified, but appropriate driver function"
                   " (DrvSynchronize or DrvSynchronizeSurface) not available");
    }

}
#endif


/******************************Public*Routine******************************\
* EngAssociateSurface                                                      *
*                                                                          *
* DDI entry point for assigning a surface a palette, associating it with   *
* a device.                                                                *
*                                                                          *
* History:                                                                 *
*  Mon 27-Apr-1992 16:36:38 -by- Charles Whitmer [chuckwh]                 *
* Changed HPDEV to HDEV.                                                   *
*                                                                          *
*  Thu 12-Mar-1992 -by- Patrick Haluptzok [patrickh]                       *
* change to bool return                                                    *
*                                                                          *
*  Mon 01-Apr-1991 -by- Patrick Haluptzok [patrickh]                       *
* add pdev, dhpdev init, palette stuff                                     *
*                                                                          *
*  13-Feb-1991 -by- Patrick Haluptzok patrickh                             *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EngAssociateSurface(HSURF hsurf, HDEV hdev, FLONG flHooks)
{
    //
    // Remove any obsolete HOOK_ flags, so that we can overload them for
    // internal GDI purposes.
    //

    flHooks &= ~(HOOK_SYNCHRONIZEACCESS | HOOK_MOVEPANNING);

    ASSERTGDI((flHooks & (~HOOK_FLAGS)) == 0, "ERROR driver set high flags");

    //
    // This call needs to associate this surface with the the HDEV given.
    // We can't stick the palette in here because for palette managed devices
    // the compatible bitmaps have a NULL palette.  If we ever try and init
    // the palettes here we need to be careful not to do it for compatible
    // bitmaps on palette managed devices.
    //

    PDEVOBJ po(hdev);
    if (!po.bValid())
    {
        WARNING("EngAssociateSurface: invalid PDEV passed in\n");
        return FALSE;
    }

    SURFREF so;

    so.vAltCheckLockIgnoreStockBit(hsurf);

    if (!so.bValid())
    {
        WARNING("EngAssociateSurface: invalid SURF passed in\n");
        return FALSE;
    }

    //
    // EA Recovery support: If we are hooking the driver entry points for
    // EA recovery, we need to store away the surface and associated
    // LDEV so that when the DrvDeleteDeviceBitmap comes down, we can hook
    // up the "real" driver entry point.
    //
    // NOTE: We only create this node if EA recovery is currently enabled, and
    // DrvCreateDeviceBitmap (which will do the cleanup of the node) is present.
    //

    if (WatchdogIsFunctionHooked(po.pldev(), INDEX_DrvCreateDeviceBitmap)) {

        if (so.ps->bEngCreateDeviceBitmap()) {

	    PASSOCIATION_NODE Node = AssociationCreateNode();

	    if (Node) {

		Node->key = (ULONG_PTR)so.ps->dhsurf();
		Node->data = AssociationRetrieveData((ULONG_PTR)po.dhpdev());
		Node->hsurf = (ULONG_PTR)hsurf;

		if (AssociationIsNodeInList(Node) == FALSE) {

		    AssociationInsertNodeAtTail(Node);

		} else {

		    AssociationDeleteNode(Node);
		}

	    } else {

		WARNING("EngAssociateSurface: failed to create association node\n");
		return FALSE;
	    }
	}
    }

    so.ps->pwo((EWNDOBJ *)NULL);
    so.ps->hdev(hdev);
    so.ps->dhpdev(po.dhpdevNotDynamic());   // Since we're being called from
                                            // the driver, we are implicitly
                                            // holding a dynamic mode change
                                            // lock, and so don't need to
                                            // check it -- hence 'NotDynamic'
    
    so.ps->flags(so.ps->flags() | flHooks);
    
    #if DBG
    vAssertValidHookFlags(&po, &so);
    #endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* EngModifySurface
*
* DDI entry point for changing surface internals such as the type,
* bits pointers, and the hooked flags.

*  27-Apr-1998 -by- J. Andrew Goossen patrickh
* Wrote it.
\**************************************************************************/

BOOL EngModifySurface(
HSURF   hsurf,
HDEV    hdev,
FLONG   flHooks,
FLONG   flSurface,
DHSURF  dhsurf,
VOID*   pvScan0,
LONG    lDelta,
VOID*   pvReserved)
{
    BOOL    bRet = TRUE;            // Assume success;
    SURFREF so;

    PDEVOBJ po(hdev);
    if (!po.bValid())
    {
        WARNING("EngModifySurface: invalid PDEV passed in");
        return(FALSE);
    }

    so.vAltLockIgnoreStockBit(hsurf);

    if (!so.bValid())
    {
        WARNING("EngModifySurface: invalid surface handle passed in");
        return(FALSE);
    }

    if (pvReserved != NULL)
    {
        WARNING("EngModifySurface: pvReserved not NULL");
        bRet = FALSE;
    }

    if (flSurface & ~(MS_NOTSYSTEMMEMORY | MS_SHAREDACCESS))
    {
        WARNING("EngModifySurface: invalid flSurface flag");
        return(FALSE);
    }

    //
    // Only surfaces that were created via EngCreateDeviceBitmap or
    // EngCreateDeviceSurface are allowed to be modified.  We do this
    // primarily for two reasons:
    //
    //   1. This prevents the driver from modifying willy-nilly
    //      SURFOBJs that it sees;
    //   2. If solves some problems with bDeleteSurface calling
    //      DrvDeleteDeviceBitmap (it was impossible to allow
    //      an STYPE_BITMAP surface to have DrvDeleteDeviceBitmap
    //      called, and still handle the DrvEnableSurface case
    //      where a driver created its primary surface using
    //      EngCreateSurface and modified the 'dhsurf' field --
    //      in this case DrvDeleteDeviceBitmap should not be called!
    //
    // Note that as a side effect of how we check for STYPE_DEVICE,
    // primary surfaces should only ever be called with EngModifySurface
    // once.  Bitmap surfaces, however, can intentionally be modified by
    // EngModifySurface any number times.
    //

    if (!(so.ps->bEngCreateDeviceBitmap()) && (so.ps->iType() != STYPE_DEVICE))
    {
        WARNING("EngModifySurface: surface not driver created");
        bRet = FALSE;
    }

    if ((so.ps->hdev() != NULL) && (so.ps->hdev() != hdev))
    {
        WARNING("EngModifySurface: surface associated with different hdev");
        bRet = FALSE;
    }

    //
    // Remove any obsolete HOOK_ flags, so that we can overload them for
    // internal GDI purposes.
    //

    flHooks &= ~(HOOK_SYNCHRONIZEACCESS | HOOK_MOVEPANNING);

    ASSERTGDI((flHooks & (~HOOK_FLAGS)) == 0, "ERROR driver set high flags");


    //
    // WINBUG #254444 bhouse 12-14-2000 Allow drivers to change primary using EngModifySurface
    // TODO: Additional code review of this change
    // Allow drivers to change primary surface attributes so long as they
    // are not changing the hooking flags and the PDEV is disabled.
    //


    if (so.ps->bPDEVSurface() && ((po.pSpriteState()->flOriginalSurfFlags & HOOK_FLAGS) != flHooks || !po.bDisabled()))
    {
        WARNING("EngModifySurface: can't modify PDEV surface once created");
        bRet = FALSE;
    }

    //
    // EA Recovery support: If we are hooking the driver entry points for
    // EA recovery, we need to store away the surface and associated
    // LDEV so that when the DrvDeleteDeviceBitmap comes down, we can hook
    // up the "real" driver entry point.
    //
    //
    // NOTE: We only create this node if EA recovery is currently enabled, and
    // DrvCreateDeviceBitmap (which will do the cleanup of the node) is present.
    //

    if (WatchdogIsFunctionHooked(po.pldev(), INDEX_DrvCreateDeviceBitmap)) {

        if (so.ps->bEngCreateDeviceBitmap()) {

	    PASSOCIATION_NODE Node = AssociationCreateNode();

	    if (Node) {

		Node->key = (ULONG_PTR)dhsurf;
		Node->data = AssociationRetrieveData((ULONG_PTR)po.dhpdev());
		Node->hsurf = (ULONG_PTR)hsurf;

		if (AssociationIsNodeInList(Node) == FALSE) {

		    AssociationInsertNodeAtTail(Node);

		} else {

		    AssociationDeleteNode(Node);
		}

	    } else {

		WARNING("EngAssociateSurface: failed to create association node\n");
		bRet = FALSE;
	    }
	}
    }

    //
    // First, try changing the surface's type as appropriate:
    //

    if ((pvScan0 == NULL) || (lDelta == 0))
    {
        //
        // Make the surface opaque, assuming they've hooked the minimum
        // number of calls to allow an opaque surface.
        //

        if ((flHooks & (HOOK_TEXTOUT | HOOK_BITBLT | HOOK_STROKEPATH))
                    != (HOOK_TEXTOUT | HOOK_BITBLT | HOOK_STROKEPATH))
        {
            WARNING("EngModifySurface: opaque surfaces must hook textout, bitblt, strokepath");
            bRet = FALSE;
        }

        if (!(flSurface & MS_NOTSYSTEMMEMORY))
        {
            WARNING("EngModifySurface: why have opaque surface if system memory?");
            bRet = FALSE;
        }

        if (dhsurf == NULL)
        {
            WARNING("EngModifySurface: opaque types must have a dhsurf");
            bRet = FALSE;
        }

        //
        // If all systems are go, convert to an opaque surface:
        //

        if (bRet)
        {
            so.ps->pvScan0(NULL);
            so.ps->pvBits(NULL);
            so.ps->lDelta(0);

            //
            // We're making the surface opaque, and STYPE_DEVICE surfaces should
            // remain STYPE_DEVICE to denote the primary surface, and not become
            // STYPE_DEVBITMAP.
            //

            if (so.ps->iType() != STYPE_DEVICE)
            {
                so.ps->iType(STYPE_DEVBITMAP);
            }
        }
    }
    else
    {
        if ((flSurface & MS_NOTSYSTEMMEMORY) && !(flHooks & HOOK_SYNCHRONIZE))
        {
            WARNING("EngModifySurface: VRAM non-opaque surfaces must hook synchronize");
            bRet = FALSE;
        }

        //
        // If all systems are go, convert to a GDI-managed surface:
        //

        if (bRet)
        {
            so.ps->pvScan0(pvScan0);
            so.ps->lDelta(lDelta);
            so.ps->iType(STYPE_BITMAP);

            if (lDelta > 0)
            {
                so.ps->pvBits(pvScan0);
                so.ps->fjBitmap(so.ps->fjBitmap() | BMF_TOPDOWN);
            }
            else
            {
                so.ps->pvBits((VOID*) ((BYTE*) pvScan0
                            + (so.ps->sizl().cy - 1) * lDelta));
                so.ps->fjBitmap(so.ps->fjBitmap() & ~BMF_TOPDOWN);
            }
        }
    }

    //
    // If we were successful in changing the type, update some common fields:
    //

    if (bRet)
    {
        if (flSurface & MS_NOTSYSTEMMEMORY)
        {
            so.ps->fjBitmap(so.ps->fjBitmap() | BMF_NOTSYSMEM);
        }
        else
        {
            so.ps->fjBitmap(so.ps->fjBitmap() & ~BMF_NOTSYSMEM);
        }

        if (flSurface & MS_SHAREDACCESS)
        {
            so.ps->vSetShareAccess();
        }
        else
        {
            so.ps->vClearShareAccess();
        }

        so.ps->dhsurf(dhsurf);
        so.ps->pwo((EWNDOBJ *)NULL);
        so.ps->hdev(hdev);
        so.ps->dhpdev(po.dhpdev());
        
        so.ps->flags((so.ps->flags() & ~HOOK_FLAGS) | flHooks);
                                                // Replace the old hooked flags
                                                // with the new ones

        #if DBG
        vAssertValidHookFlags(&po, &so);
        #endif
    }
    else
    {
        WARNING("EngModifySurface: failed");
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\surfobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfobj.cxx
*
* Surface user objects.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

extern BOOL G_fConsole;

// Global surface uniqueness -- incremented every time a surface is created.

ULONG _ulGlobalSurfaceUnique;

// The following declarations are required by the native c8 compiler.

PSURFACE SURFACE::pdibDefault;   // The default bitmap pointer

SIZE_T SURFACE::tSize = sizeof(SURFACE);

#if TRACE_SURFACE_ALLOCS
TRACED_SURFACE::SurfaceTraceStatus TRACED_SURFACE::eTraceStatus = SURFACE_TRACING_UNINITIALIZED;
#if TRACE_SURFACE_USER_CHAIN_IN_UM
TRACED_SURFACE::SurfaceTraceStatus TRACED_SURFACE::eUMTraceStatus = SURFACE_TRACING_UNINITIALIZED;
#endif
#endif

// By default, EngCreateBitmap allocations larger than 260k will be
// allocated as a section:

#define KM_SIZE_MAX   0x40000


/******************************Public*Routine******************************\
* GreMarkUndeletableBitmap -- a USER callable API to mark a surface as
*     undeletable.  Currently this is used to make sure applications
*     cannot delete redirection bitmaps.
*
* Arguments:
*
*   hbm -- handle to bitmap to be marked undeletable
*
* Return Value:
*   
*   TRUE upon success, FALSE otherwise.
*
* History:
*
*    2-Nov-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

BOOL
GreMarkUndeletableBitmap(
    HBITMAP hbm
    )
{
    return (HmgMarkUndeletable((HOBJ) hbm, SURF_TYPE));
}

/******************************Public*Routine******************************\
* GreMarkDeletableBitmap -- a USER callable API to mark a surface as
*     deletable.  Currently this is used by USER just before deleting
*     a redirection bitmap.
*
* Arguments:
*
*   hbm -- handle to bitmap to be marked deletable
*
* Return Value:
*   
*   TRUE upon success, FALSE otherwise.
*
* History:
*
*    2-Nov-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

BOOL
GreMarkDeletableBitmap(
    HBITMAP hbm
    )
{
    return (HmgMarkDeletable((HOBJ) hbm, SURF_TYPE));
}


/******************************Public*Routine******************************\
*   pvAllocateKernelSection - Allocate kernel mode section
*
* Arguments:
*
*   AllocationSize - size in bytes of requested memory
*
* Return Value:
*
*   Pointer to memory or NULL
*
* History:
*
*    22-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PVOID
pvAllocateKernelSection(
    ULONGSIZE_T   AllocationSize,
    ULONG         Tag
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LARGE_INTEGER MaximumSize;
    PVOID  pvAlloc = NULL;
    PVOID  pvRet   = NULL;

    //
    // Create km section
    //


    ACCESS_MASK DesiredAccess =  SECTION_MAP_READ |
                                 SECTION_MAP_WRITE;

    ULONG SectionPageProtection = PAGE_READWRITE;

    ULONG AllocationAttributes = SEC_COMMIT |
                                 SEC_NO_CHANGE;

    MaximumSize.HighPart = 0;
    MaximumSize.LowPart  = AllocationSize + sizeof(KMSECTIONHEADER);



    PVOID pHandleSection;

    //
    // map a copy of this section into kernel address space
    // Lets use the Section tagging code.
    //
    Status = Win32CreateSection(&pHandleSection,
                                DesiredAccess,
                                NULL,
                                &MaximumSize,
                                SectionPageProtection,
                                AllocationAttributes,
                                NULL,
                                NULL,
                                TAG_SECTION_DIB);

    if (!NT_SUCCESS(Status))
    {
        WARNING1("pvAllocateKernelSection: ObReferenceObjectByHandle failed\n");
    }
    else
    {
        SIZE_T ViewSize = 0;

#ifdef _HYDRA_
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.
        Status = Win32MapViewInSessionSpace(
                        pHandleSection,
                        (PVOID*)&pvAlloc,
                        &ViewSize);
#else
        Status = MmMapViewInSystemSpace(
                        pHandleSection,
                        (PVOID*)&pvAlloc,
                        &ViewSize);
#endif

        if (!NT_SUCCESS(Status))
        {
            //
            // free section
            //

            WARNING1("pvAllocateKernelSection: MmMapViewInSystemSpace failed\n");
            Win32DestroySection(pHandleSection);
        }
        else
        {
#ifdef _HYDRA_
#if DBG
            if (!G_fConsole)
            {
                DebugGreTrackAddMapView(pvAlloc);
            }
#endif
#endif
            ((PKMSECTIONHEADER)pvAlloc)->Tag      = Tag;
            ((PKMSECTIONHEADER)pvAlloc)->pSection = pHandleSection;

            pvRet = (PVOID)(((PUCHAR)pvAlloc)+sizeof(KMSECTIONHEADER));
        }
    }

    return(pvRet);
}

/******************************Public*Routine******************************\
*   vFreeKernelSection: Free kernel mode section
*
* Arguments:
*
*   pvMem - Kernel mode section pointer
*
* Return Value:
*
*   None
*
* History:
*
*    22-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFreeKernelSection(
    PVOID pvMem
    )
{
    NTSTATUS Status;
    PVOID    pHandleSection;

    if (pvMem != NULL)
    {
        PKMSECTIONHEADER pvHeader = (PKMSECTIONHEADER)((PUCHAR)pvMem - sizeof(KMSECTIONHEADER));

        pHandleSection = pvHeader->pSection;

        //
        // Temporary code to catch stress failure (bug #263678)
        // We want to fail before the page is unmapped, instead of
        // afterwards
        //

        if (!pHandleSection) 
        {
            KeBugCheckEx(PAGE_FAULT_IN_NONPAGED_AREA,
                         (LONG_PTR) pHandleSection,
                         (LONG_PTR) pvHeader->pSection,
                         (LONG) pvHeader->Tag,
                         0);
        }

        //
        // unmap kernel mode view
        //

#ifdef _HYDRA_
        // MmUnmapViewInSessionSpace is internally promoted to
        // MmUnmapViewInSystemSpace on non-Hydra systems.

        Status = Win32UnmapViewInSessionSpace((PVOID)pvHeader);
#else
        Status = MmUnmapViewInSystemSpace((PVOID)pvHeader);
#endif

        if (!NT_SUCCESS(Status))
        {
            WARNING1("vFreeKernelSection: MmUnmapViewInSystemSpace failed\n");
        }
        else
        {
#ifdef _HYDRA_
#if DBG
            if (!G_fConsole)
            {
                DebugGreTrackRemoveMapView(pvHeader);
            }
#endif
#endif
            //
            // delete reference to section
            //

            Win32DestroySection(pHandleSection);
        }
    }
    else
    {
        WARNING("vFreeKernelSection called with NULL pvMem\n");
    }
}

/******************************Public*Routine******************************\
* SURFACE::bDeleteSurface()
*
* Delete the surface.  Make sure it is not selected into a DC if it is
* a bitmap.  We do under cover of multi-lock to ensure no one will select
* the bitmap into a DC after we checked cRef.
*
* History:
*  Mon 17-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Add support for closing journal file.
*
*  Fri 22-Feb-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL
SURFACE::bDeleteSurface(CLEANUPTYPE cutype)
{
    GDIFunctionID(SURFACE::bDeleteSurface);

    BOOL bRet = TRUE;

    if (!bIsDefault() && bValid())
    {
        HANDLE hSecure       = NULL;
        HANDLE hDibSection   = NULL;
        PVOID  pvBitsBaseOld = NULL;

        if (iType() == STYPE_BITMAP)
        {
            hSecure       = DIB.hSecure;
            hDibSection   = DIB.hDIBSection;
            pvBitsBaseOld = pvBitsBase();
        }

        PDEVOBJ      pdo(hdev());
        ULONG        iTypeOld  = iType();
        DHSURF       dhsurfOld = dhsurf();
        PPALETTE     ppalOld   = ppal();
        EWNDOBJ     *pwoDelete = pwo();
        PVOID        pvBitsOld = pvBits();
        FLONG        fl        = fjBitmap();

        //
        // If the surface is a bitmap, ensure it is not selected into a DC.
        // Also make sure we are the only one with it locked down. These are
        // both tested at once with HmgRemoveObject, because we increment
        // and decrement the alt lock count at the same time we increment
        // and decrement the cRef count on selection and deselection into
        // DCs. Note that surfaces can also be locked for GetDIBits with no
        // DC involvement, so the alt lock count may be higher than the
        // reference count.
        //

        ASSERTGDI(HmgQueryLock((HOBJ) hGet()) == 0,
                  "ERROR cLock != 0");

        //
        // If it's a device bitmap, acquire the devlock to protect against
        // dynamic mode and driver changes.
        //

        DEVLOCKOBJ dlo;

        if (bEngCreateDeviceBitmap() && pdo.bValid())
        {
            dlo.vLock(pdo);
        }
        else
        {
            dlo.vInit();
        }

#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
        PVOID   pvUserMem = NULL;

        if (TRACED_SURFACE::bEnabled())
        {
            TRACED_SURFACE *pts = (TRACED_SURFACE *)this;
            UINT            uiIndex = (UINT) HmgIfromH(hGet());

            if (pts->Trace.UserChainAllocated &&
                uiIndex < gcMaxHmgr)
            {
                pvUserMem = gpentHmgr[uiIndex].pUser;
                ASSERTGDI(pvUserMem == NULL ||
                          OBJECTOWNER_PID(gpentHmgr[uiIndex].ObjectOwner) == W32GetCurrentPID(),
                          "Unowned SURFACE still has User Memory.");
            }
        }
#endif
#endif
        //
        // Remove undeletable surfaces only during session cleanup.
        //

        if (HmgRemoveObject((HOBJ) hGet(), 0, 1, (cutype == CLEANUP_SESSION), 
            SURF_TYPE))
        {
#if TRACE_SURFACE_ALLOCS
#if TRACE_SURFACE_USER_CHAIN_IN_UM
            EngFreeUserMem(pvUserMem);
#endif
#endif
            //
            // If this bitmap was created by EngCreateDeviceBitmap, we have
            // to call DrvDeleteDeviceBitmap to clean it up.  Note that we
            // can't simply check for STYPE_DEVBITMAP, since EngModifySurface
            // may have changed the type to STYPE_BITMAP.
            //

            if (bEngCreateDeviceBitmap() && (dhsurfOld != NULL))
            {
                //
                // In UMPD, a bad driver/app(ntcrash) can create a dev bitmap by
                // EngCreateDeviceBitmap.  But hdev could be null if 
                // EngAssociateSurface is not called.
                //

                if (pdo.bValid() && PPFNVALID(pdo, DeleteDeviceBitmap))
                {
                    #if defined(_GDIPLUS_)

                    (*PPFNDRV(pdo,DeleteDeviceBitmap))(dhsurfOld);

                    #else // !_GDIPLUS_

                    if (bUMPD())
                    {
                        //
                        // Do not callout to user-mode driver if the
                        // user-mode process is gone (i.e., during
                        // session or process cleanup).
                        //

                        if (cutype == CLEANUP_NONE)
                        {
                            UMPDDrvDeleteDeviceBitmap(pdo.dhpdev(), dhsurfOld);
                        }
                    }
                    else
                    {
                        (*PPFNDRV(pdo,DeleteDeviceBitmap))(dhsurfOld);
                    }

                    #endif // !_GDIPLUS_
                }
            }

            FREEOBJ(this, SURF_TYPE);

            //
            // Note, 'this' not set to NULL
            //

            //
            // For kernel mode, we must unlock the section memory,
            // then free the memory. If the section handle is NULL
            // then we just use NtVirtualFree, otherwise we must
            // use NtUnmapViewOfSection
            //

            if (hSecure != NULL)
            {
                MmUnsecureVirtualMemory(hSecure);

                if (pvBitsOld == NULL)
                {
                    WARNING("deleting DIB but hSecure or pvBitsOld == NULL");
                }
                else
                {
                    if (hDibSection != NULL)
                    {
                        ZwUnmapViewOfSection(NtCurrentProcess(), pvBitsBaseOld);
                    }
                    else
                    {

                        SIZE_T ViewSize = 0;

                        ZwFreeVirtualMemory(
                                        NtCurrentProcess(),
                                        &pvBitsOld,
                                        &ViewSize,
                                        MEM_RELEASE);
                    }
                }
            }
            else if (fl & BMF_USERMEM)
            {
#if defined(_WIN64)
                if (fl & BMF_UMPDMEM)
                    UMPDEngFreeUserMem(pvBitsOld);
                else
#endif
                    EngFreeUserMem(pvBitsOld);
            }
            else if (fl & BMF_KMSECTION)
            {
                vFreeKernelSection(pvBitsOld);
            }

            //
            // This DC is going away, the associated WNDOBJ should be deleted.
            // The WNDOBJs for memory bitmap and printer surface are deleted here.
            // The WNDOBJs for display DCs are deleted in DestroyWindow.
            //

            if (pwoDelete)
            {
                GreDeleteWnd((PVOID) pwoDelete);
            }

            if (ppalOld != NULL)
            {
                XEPALOBJ pal(ppalOld);
                pal.vUnrefPalette();
            }
        }
        else
        {
            //
            // if we can't remove it because it's an application's bitmap
            // and is currently selected, mark it for lazy deletion
            //

            if (HmgQueryAltLock((HOBJ)hGet()) != 1)
            {
                if (hdc() != NULL || bStockSurface())
                {
                    //
                    // The surface is currently selected into a DC, so we can't
                    // simply delete it.  Instead, mark it to be deleted when
                    // the DC is destroyed, or a new surface is selected into
                    // the DC.
                    //

                    vLazyDelete();
                    bRet = TRUE;

                    //
                    // Because we're returning TRUE, the caller will expect
                    // that the deletion succeeded and so will not unlock the
                    // object.  But since it wasn't truly deleted, we have
                    // to keep the lock count consistent with the number of DC
                    // references.  We account for the fact that the caller
                    // won't do the unlock by doing it here:
                    //

                    DEC_SHARE_REF_CNT(this);
                }
                else
                {
                    WARNING("LIKELY MEMORY LEAK IN DRIVER OR GDI!");
                    RIP("active locks prevented surface deletion");
                    bRet = FALSE;
                }
            }
            else
            {
                RIP("failed, handle busy\n");
                SAVE_ERROR_CODE(ERROR_BUSY);
                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SURFMEM::bCreateDIB
*
* Constructor for device independent bitmap memory object
*
* History:
*  Mon 18-May-1992 -by- Patrick Haluptzok [patrickh]
* return BOOL
*
*  28-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
SURFMEM::bCreateDIB(
    PDEVBITMAPINFO pdbmi,
    PVOID pvBitsIn,
    HANDLE hDIBSection,
    DWORD  dsOffset,
    HANDLE hSecure,
    ULONG_PTR  dwColorSpace
    )
{
    GDIFunctionID(SURFMEM::bCreateDIB);

    BOOL bRet = TRUE;

    AllocationFlags = SURFACE_DIB;
    ps = (PSURFACE) NULL;
    FLONG flAllocateSection = 0;
    BOOL bCompressed = FALSE;

    //
    // Figure out the length of a scanline
    //

    ULONG cjScanTemp;

    switch(pdbmi->iFormat)
    {
    case BMF_1BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 31) & ~31) >> 3;
        break;

    case BMF_4BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 7) & ~7) >> 1;
        break;

    case BMF_8BPP:
        cjScanTemp = (pdbmi->cxBitmap + 3) & ~3;
        break;

    case BMF_16BPP:
        cjScanTemp = ((pdbmi->cxBitmap + 1) & ~1) << 1;
        break;

    case BMF_24BPP:
        cjScanTemp = ((pdbmi->cxBitmap * 3) + 3) & ~3;
        break;

    case BMF_32BPP:
        cjScanTemp = pdbmi->cxBitmap << 2;
        break;

    case BMF_8RLE:
    case BMF_4RLE:
    case BMF_JPEG:
    case BMF_PNG:
        bCompressed = TRUE;
        break;

    default:
        WARNING("ERROR: failed INVALID BITMAP FORMAT \n");
        return(FALSE);
    }

    //
    // If we are given a pointer to bits, then only allocate a DIB header.
    // Otherwise allocate space for the header and the required bits.
    //

    ULONGSIZE_T size = (ULONGSIZE_T) SURFACE::tSizeOf();

    FSHORT fsAlloc = HMGR_ALLOC_ALT_LOCK|HMGR_NO_ZERO_INIT;

    if (pvBitsIn == (PVOID) NULL)
    {
        LONGLONG eq;

        if (bCompressed)
            eq = (LONGLONG)(ULONGLONG) pdbmi->cjBits;
        else
            eq = Int32x32To64(pdbmi->cyBitmap, cjScanTemp);

        eq += (LONGLONG)(ULONGLONG) size;

        if (eq > LONG_MAX)
        {
            WARNING("Attempting to allocate > 4Gb\n");
            return(FALSE);
        }

        //
        // if it is UMPD and size > PAGE_SIZE, we always allocate in user memory
        //
        //
        // make sure no one will change KM_SIZE_MAX later and mess things up
        //
        ASSERTGDI(PAGE_SIZE < KM_SIZE_MAX, "bad KM_SIZE_MAX\n");

        if ((pdbmi->fl & UMPD_SURFACE) && (eq > PAGE_SIZE))
            pdbmi->fl |= BMF_USERMEM;

        // see if we need to allocate the bits out of USER memory

        if (pdbmi->fl & BMF_USERMEM)
        {
            pvBitsIn = EngAllocUserMem((LONG) eq,'mbuG'); //Gubm

            if (pvBitsIn == NULL)
                return(FALSE);
        }
        else if ((pdbmi->fl & BMF_KMSECTION) || (eq > KM_SIZE_MAX))
        {
            //
            // Kernel-mode pool is limited in size and prone to fragmentation.
            // For this reason, we will automatically allocate 'large' bitmaps
            // as sections, which will not be charged against kernel-mode
            // pool.
            //
            // We also allow the driver to specify BMF_KMSECTION -- this is
            // specifically for the ModeX driver to allow it to map its shadow
            // buffer into user-mode.
            //

            //
            //Sundown, change from SIZE_T to LONG, we return false earlier if > 4GB
            //
            pvBitsIn = pvAllocateKernelSection((LONG)eq,'mbkG');

            if (pvBitsIn != NULL)
            {
                //
                // mark surface as KM SECTION
                //

                flAllocateSection = BMF_KMSECTION;
            }
        }

        //
        // combine size and allocate from pool
        //

        if (pvBitsIn == NULL)
        {
            size = (ULONGSIZE_T) eq;

            if ((pdbmi->fl & BMF_NOZEROINIT) == 0)
            {
                fsAlloc = HMGR_ALLOC_ALT_LOCK;
            }
        }
    }
    else
    {
        ASSERTGDI(!(pdbmi->fl & BMF_USERMEM),"flags error\n");
    }

    ps = (PSURFACE)ALLOCOBJ(size,SURF_TYPE,!(fsAlloc & HMGR_NO_ZERO_INIT));

    if (ps == NULL)
    {
        WARNING("failed memory alloc\n");
        bRet = FALSE;
    }
    else
    {
        //
        // Initialize the surf fields
        //

        SIZEL sizlTemp;
        sizlTemp.cx = pdbmi->cxBitmap;
        sizlTemp.cy = pdbmi->cyBitmap;
        ps->sizl(sizlTemp);
        ps->iType(STYPE_BITMAP);
        ps->hSecureUMPD = 0;

        if (pdbmi->hpal != (HPALETTE) 0)
        {
            EPALOBJ palSurf(pdbmi->hpal);
            ASSERTGDI(palSurf.bValid(), "ERROR invalid palette");

            //
            // Set palette into surface.
            //

            ps->ppal(palSurf.ppalGet());

            //
            // Reference count it by making sure it is not unlocked.
            //

            palSurf.ppalSet((PPALETTE) NULL);  // It won't be unlocked
        }
        else
        {
            ps->ppal((PPALETTE) NULL);
        }

        //
        // Initialize the BITMAP fields
        //

        ps->iFormat(pdbmi->iFormat);

        ps->fjBitmap(((pdbmi->fl) & (BMF_TOPDOWN | BMF_USERMEM)) |
                     (flAllocateSection));

        ps->DIB.hDIBSection = hDIBSection;
        ps->DIB.dwOffset = dsOffset;
        ps->DIB.hSecure = hSecure;
        ps->DIB.dwDIBColorSpace = dwColorSpace;

        ps->dhsurf((DHSURF) 0);
        ps->dhpdev((DHPDEV) 0);
        ps->flags(pdbmi->fl & UMPD_SURFACE);
        ps->pwo((EWNDOBJ *) NULL);
        sizlTemp.cx = 0;
        sizlTemp.cy = 0;
        ps->sizlDim(sizlTemp);
        ps->hdev((HDEV) 0);
        ps->EBitmap.hdc = (HDC) 0;
        ps->EBitmap.cRef = 0;
        ps->EBitmap.hpalHint = 0;
        ps->pdcoAA = NULL;

        if (hSecure != (HANDLE) NULL)
        {
            //
            // Set flag for DIBSECTION so driver doesn't cache it.
            // because we don't know to increment the uniqueness
            // when the app writes on it.
            //

            ps->so.fjBitmap |= BMF_DONTCACHE;
        }

        //
        // Initialize the DIB fields
        //

        if (pvBitsIn == (PVOID) NULL)
        {
            ps->pvBits((PVOID) (((ULONG_PTR) ps) + SURFACE::tSizeOf()));
        }
        else
        {
            ps->pvBits(pvBitsIn);
        }

        if ((pdbmi->iFormat != BMF_8RLE) &&
            (pdbmi->iFormat != BMF_4RLE) &&
            (pdbmi->iFormat != BMF_JPEG) &&
            (pdbmi->iFormat != BMF_PNG ))
        {
            ps->cjBits(pdbmi->cyBitmap * cjScanTemp);

            if (pdbmi->fl & BMF_TOPDOWN)
            {
                ps->lDelta(cjScanTemp);
                ps->pvScan0(ps->pvBits());
            }
            else
            {
                ps->lDelta(-(LONG)cjScanTemp);
                ps->pvScan0((PVOID) (((PBYTE) ps->pvBits()) +
                                   (ps->cjBits() - cjScanTemp)));
            }
        }
        else
        {
            //
            // lDelta is 0 because RLE's don't have scanlines.
            //

            ps->lDelta(0);
            ps->cjBits(pdbmi->cjBits);

            //
            // pvScan0 is ignored for JPEG's and PNG's
            //

            if ((pdbmi->iFormat != BMF_JPEG) && (pdbmi->iFormat != BMF_PNG))
                ps->pvScan0(ps->pvBits());
            else
                ps->pvScan0(NULL);
        }

        //
        // Set initial uniqueness.  Not 0 because that means don't cache it.
        //
        // We used to always set the uniqueness to 1 on creation, but the
        // NetMeeting folks ran into tool-bar scenarios where the buttons
        // were being created and deleted on every repaint and eventually we
        // would run out of uniqueness bits in the handles.  So the end
        // result would be that the NetMeeting driver would see a surface
        // with a handle the same as the one they cached, and with an iUniq
        // the same as the one they cached (specifically, a value of '1') --
        // but the cached bitmap would not match the actual bitmap bits!
        //
        // We fix this by always creating the surface with a unique uniqueness.
        // Note that it's still possible to get different surfaces with the
        // same uniqueness because drawing calls simply increment the surface
        // uniqueness, not the global uniqueness.  However, this change will
        // make the possibility of the driver mis-caching a bitmap extremely
        // unlikely.
        //

        ps->iUniq(ulGetNewUniqueness(_ulGlobalSurfaceUnique));

        //
        // Now that the surface is set up, give it a handle
        //

        if (HmgInsertObject(ps, fsAlloc, SURF_TYPE) == 0)
        {
            WARNING("failed HmgInsertObject\n");

            //
            // Don't forget to decrement reference count on the palette before
            // freeing the surface
            //

            if (ps->ppal())
            {
                XEPALOBJ pal(ps->ppal());
                pal.vUnrefPalette();
                ps->ppal((PPALETTE) NULL); // Not necessary, but makes the code cleaner
            }

            FREEOBJ(ps, SURF_TYPE);
            ps = NULL;
            bRet = FALSE;
        }
        else
        {
            ps->hsurf(ps->hGet());

#if TRACE_SURFACE_ALLOCS
            if (TRACED_SURFACE::bEnabled())
            {
                TRACED_SURFACE *pts = (TRACED_SURFACE *)ps;

                RtlZeroMemory(&pts->Trace, sizeof(pts->Trace));
                pts->Trace.pProcess = PsGetCurrentProcess();
                pts->Trace.pThread = PsGetCurrentThread();
                pts->Trace.KernelLength = RtlWalkFrameChain((PVOID *)pts->Trace.Chain,
                                                           lengthof(pts->Trace.Chain),
                                                           0);
                ULONG   MaxUserLength;
                PVOID  *UserChain;
                PVOID   TmpUserChain[TRACE_SURFACE_MIN_USER_CHAIN];

                MaxUserLength = lengthof(pts->Trace.Chain) - pts->Trace.KernelLength;
                if (MaxUserLength < TRACE_SURFACE_MIN_USER_CHAIN)
                {
                    MaxUserLength = TRACE_SURFACE_MIN_USER_CHAIN;
                    UserChain = TmpUserChain;
                }
                else
                {
                    UserChain = (PVOID *)&pts->Trace.Chain[pts->Trace.KernelLength];
                }

                pts->Trace.UserLength = RtlWalkFrameChain(UserChain,
                                                          MaxUserLength,
                                                          1);

                if (UserChain == TmpUserChain && pts->Trace.UserLength != 0)
                {
                    pts->Trace.KernelLength = min(pts->Trace.KernelLength, (ULONG) lengthof(pts->Trace.Chain) - pts->Trace.UserLength);
                    RtlCopyMemory(&pts->Trace.Chain[pts->Trace.KernelLength],
                                  UserChain,
                                  pts->Trace.UserLength);
                }

#if TRACE_SURFACE_USER_CHAIN_IN_UM
                if (pts->bUMEnabled())
                {
                    SurfaceUserTrace   *pSurfUserTrace;
                    PENTRY              pentTmp;
                    UINT                uiIndex = (UINT) HmgIfromH(pts->hGet());

                    pentTmp = &gpentHmgr[uiIndex];

                    ASSERTGDI(pentTmp->pUser == NULL,
                              "SURFACE's pUser is already being used.\n");

                    pSurfUserTrace = (SurfaceUserTrace *)EngAllocUserMem(sizeof(SurfaceUserTrace), 'rTSG');

                    if (pSurfUserTrace != NULL)
                    {
                        pts->Trace.UserChainAllocated = 1;
                        pts->Trace.UserChainNotRead = 1;

                        pSurfUserTrace->MaxLength = lengthof(pSurfUserTrace->Chain);
                        pSurfUserTrace->UserLength = 0;
                        pentTmp->pUser = pSurfUserTrace;
                    }
                }
#endif
            }
#endif
        }
    }

    //
    // cleanup in failure case
    //

    if (!bRet && pvBitsIn)
    {
        if (pdbmi->fl & BMF_USERMEM)
        {
            EngFreeUserMem(pvBitsIn);
        }
        else if (flAllocateSection & BMF_KMSECTION)
        {
            vFreeKernelSection(pvBitsIn);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* SURFMEM::~SURFMEM
*
*   Description:
*
*       SURFACE Destructor, takes appropriate action based
*       on allocation flags
*
\**************************************************************************/
SURFMEM::~SURFMEM()
{

    if (ps != (SURFACE*) NULL)
    {
        //
        // what type of surface
        //

        if (AllocationFlags & SURFACE_KEEP)
        {

            DEC_SHARE_REF_CNT(ps);

        } else {

            if (AllocationFlags & SURFACE_DIB)
            {
                //
                // free selected palette
                //

                if (ps->ppal() != NULL)
                {
                    XEPALOBJ pal(ps->ppal());
                    pal.vUnrefPalette();
                }
            }

            //
            // remove object from hmgr and free
            //

            if (!HmgRemoveObject((HOBJ) ps->hGet(), 0, 1, TRUE, SURF_TYPE))
            {
                ASSERTGDI(TRUE, "Failed to remove object in ~DIBMEMOBJ");
            }

            PVOID        pvBitsOld = ps->pvBits();
            FLONG        fl        = ps->fjBitmap();
            BOOL         bUMPD = ps->bUMPD();

            FREEOBJ(ps, SURF_TYPE);

            if (fl & BMF_USERMEM)
            {
                if (bUMPD && pvBitsOld)
                {
                    EngFreeUserMem(pvBitsOld);
                }
                else if (!bUMPD)
                {
                   RIP("SURFMEM destructor has BMF_USERMEM set\n");
                }
            }
            else if (fl & BMF_KMSECTION)
            {
                vFreeKernelSection(pvBitsOld);
            }
        }
    }
}

#if DBG
void SURFACE::vDump()
{
    DbgPrint("SURFACE @ %-#x\n", this);
    DbgPrint("    so.dhsurf        = %-#x\n"  ,   so.dhsurf);
    DbgPrint("    so.hsurf         = %-#x\n"  ,   so.hsurf);
    DbgPrint("    so.dhpdev        = %-#x\n"  ,   so.dhpdev);
    DbgPrint("    so.hdev          = %-#x\n"  ,   so.hdev);
    DbgPrint("    so.sizlBitmap    = %u %u\n" ,   so.sizlBitmap.cx , so.sizlBitmap.cy);
    DbgPrint("    so.cjBits        = %u\n"    ,   so.cjBits);
    DbgPrint("    so.pvBits        = %-#x\n"  ,   so.pvBits);
    DbgPrint("    so.pvScan0       = %-#x\n"  ,   so.pvScan0);
    DbgPrint("    so.lDelta        = %d\n"    ,   so.lDelta);
    DbgPrint("    so.iUniq         = %u\n"    ,   so.iUniq);
    DbgPrint("    so.iBitmapFormat = %u\n"    ,   so.iBitmapFormat);
    DbgPrint("    so.iType         = %u\n"    ,   so.iType);
    DbgPrint("    so.fjBitmap      = %-#x\n"  ,   so.fjBitmap);


    DbgPrint("    SurfFlags        = %-#x\n"  ,   SurfFlags);
    DbgPrint("    pPal             = %-#x\n"  ,   pPal);
    DbgPrint("    pWo              = %-#x\n"  ,   pWo);
    DbgPrint("    EBitmap.sizlDim  = %u %u\n" ,   EBitmap.sizlDim.cx, EBitmap.sizlDim.cy);
    DbgPrint("    EBitmap.hdc      = %-#x\n"  ,   EBitmap.hdc);
    DbgPrint("    EBitmap.cRef     = %-#x\n"  ,   EBitmap.cRef);
    DbgPrint("    DIB.hDIBSection  = %-#x\n"  ,   DIB.hDIBSection);
    DbgPrint("    DIB.hSecure      = %-#x\n"  ,   DIB.hSecure);

}
#endif

#if TRACE_SURFACE_ALLOCS

#define TRACE_SURFACE_KM_ENABLE_MASK    0x00000001
#define TRACE_SURFACE_UM_ENABLE_MASK    0x00000002

VOID TRACED_SURFACE::vInit()
{
    NTSTATUS    Status;
    DWORD       dwDefaultValue = 0;
    DWORD       dwEnableStack;

    // Check registry key to determine whether to enable stack traces
    // or not for SURFACE allocations
 
    RTL_QUERY_REGISTRY_TABLE QueryTable[] =
        {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EnableSurfaceTrace",
             &dwEnableStack, REG_DWORD, &dwDefaultValue, sizeof(dwDefaultValue)},
            {NULL, 0, NULL}
        };

    if (eTraceStatus == SURFACE_TRACING_UNINITIALIZED)
    {
        Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                        L"GRE_Initialize",
                                        &QueryTable[0],
                                        NULL,
                                        NULL);
        if (NT_SUCCESS(Status))
        {
            if (dwEnableStack & TRACE_SURFACE_KM_ENABLE_MASK)
            {
                eTraceStatus = SURFACE_TRACING_ENABLED;
                SURFACE::tSize = sizeof(TRACED_SURFACE);

                if (dwEnableStack & TRACE_SURFACE_UM_ENABLE_MASK)
                {
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                    eUMTraceStatus = SURFACE_TRACING_ENABLED;
#else
                    WARNING("GDI: UM Surface Trace requested, but not available.\n");
#endif
                }
                else
                {
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                    eUMTraceStatus = SURFACE_TRACING_DISABLED;
#endif
                }
            }
            else
            {
                eTraceStatus = SURFACE_TRACING_DISABLED;
#if TRACE_SURFACE_USER_CHAIN_IN_UM
                eUMTraceStatus = SURFACE_TRACING_DISABLED;
#endif
            }
        }
    }
    else
    {
        RIP("TRACED_SURFACE::vInit: Tracing already initialized.\n");
    }
}


#if TRACE_SURFACE_USER_CHAIN_IN_UM
VOID TRACED_SURFACE::vProcessStackFromUM(
    BOOL bFreeUserMem
    )
{
    GDIFunctionID(TRACED_SURFACE::vProcessStackFromUM);

    if (Trace.UserChainAllocated)
    {
        if (Trace.UserChainNotRead || bFreeUserMem)
        {
            PENTRY  pentTmp;
            UINT    uiIndex = (UINT) HmgIfromH(hHmgr);
            ULONG   ulNewKernelLength;
            ULONG   ulMaxUserLength;
            ULONG   ulMaxLength = lengthof(Trace.Chain);

            if (uiIndex < gcMaxHmgr)
            {
                pentTmp = &gpentHmgr[uiIndex];

                if (pentTmp->pUser != NULL)
                {
                    if (Trace.UserChainNotRead)
                    {
                        SurfaceUserTrace *pUserTrace = (SurfaceUserTrace *)pentTmp->pUser;
                        __try {
                            if (pUserTrace->UserLength > 0)
                            {
                                ulMaxUserLength = min(pUserTrace->UserLength, ulMaxLength);
                                ulNewKernelLength = ulMaxLength - ulMaxUserLength;
                                if (ulNewKernelLength > Trace.KernelLength)
                                {
                                    ulNewKernelLength = Trace.KernelLength;
                                }
                                RtlCopyMemory(&Trace.Chain[ulNewKernelLength],
                                              pUserTrace->Chain,
                                              ulMaxUserLength);

                                Trace.UserLength = ulMaxUserLength;
                                Trace.UserChainNotRead = 0;
                                Trace.KernelLength = ulNewKernelLength;
                            }
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            WARNING("Couldn't read UM stored stack trace.");
                        }
                    }

                    if (bFreeUserMem)
                    {
                        Trace.UserChainAllocated = 0;
                        EngFreeUserMem(pentTmp->pUser);
                        pentTmp->pUser = NULL;
                    }
                }
                else
                {
                    RIP("Lost track of UserMem trace allocation.\n");
                    Trace.UserChainAllocated = 0;
                }
            }
        }
    }
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\textddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: textddi.cxx
*
*   EngTextOut text drawing to DIBs
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


VOID vRectBlt(PBYTE, ULONG, LONG, LONG, LONG, LONG);
VOID vRectBlt4(BYTE*,ULONG, LONG, LONG, LONG, LONG);
VOID vRectBlt8(BYTE*,ULONG, LONG, LONG, LONG, LONG);

class FRINGERECT
{
private:
    SURFACE  *pSurf;
    PVOID    pvBits; // see comment [1] below
    CLIPOBJ  *pco;
    BRUSHOBJ *pboOpaque;
    int      crcl;              // Count of fringe rectangles to do.
    RECTL    arcl[4];

public:
    FRINGERECT(SURFACE *pSurf1,CLIPOBJ *pco1,BRUSHOBJ *pboOpaque1)
    {
        pSurf     = pSurf1;

        if (pSurf1->iType() == STYPE_BITMAP)
             pvBits = pSurf1->pvBits();
        else
             pvBits = NULL;

        pco       = pco1;
        pboOpaque = pboOpaque1;
        crcl      = 0;
    }

   ~FRINGERECT()
    {
        //
        // We just assume the Rop is P according to the DDI.
        //

        if (pvBits)
        {
            while (--crcl >= 0)
            {
                vDIBSolidBlt(
                    pSurf                 ,
                    &arcl[crcl]           ,
                    pco                   ,
                    pboOpaque->iSolidColor,
                    FALSE
                    );
            }
        }
        else
        {
            // this section was put in to support AntiAliased
            // text. It is possible that for the case of
            // antialiased text EngTextOut could be asked to
            // render to a device managed surface. In that
            // case, we use the device's BitBlt function to
            // render the rectangles

            POINTL  ptlBrush = {0,0}; // it does not matter, it is solid color always
            RECTL   *prcl;
            SURFOBJ *pso            = pSurf->pSurfobj();
            PFN_DrvBitBlt pFnBitBlt = pSurf->pfnBitBlt();


            for (prcl = arcl; prcl < arcl + crcl; prcl++)
            {
                (*(pFnBitBlt))(
                    pso              , // psoTrg
                    0                , // psoSrc
                    0                , // psoMask
                    pco              , // pco
                    0                , // pxlo
                    prcl             , // prclTrg
                    0                , // pptlSrc
                    0                , // pptlMask
                    pboOpaque        , // pbo
                    &ptlBrush        , // pptlBrush
                    0x0000f0f0         // rop4
                    );
            }
        }
    }

    VOID vAddRect(LONG left, LONG top, LONG right, LONG bottom)
    {
        arcl[crcl].left   = left;
        arcl[crcl].top    = top;
        arcl[crcl].right  = right;
        arcl[crcl].bottom = bottom;
        crcl++;
    }
};

/***********************************************************************
*    [1]                                                               *
*                                                                      *
*    Before GDI provided support for antialiased text it would         *
*    not have been possible to have a surface without a pointer        *
*    to the DIB bits. However, in the case of antialiased text         *
*    it is possible that we reached here by way of GreExtTextOutW()    *
*    ( this case is signaled by pSurf->pdcoAA != 0  ). In this         *
*    case, the original surface of the device may not be accessible    *
*    by GDI. This case would be indicated by a zero value for          *
*    pvBits. You might worry that this means that we cannot take       *
*    care of the background rectangles. But this is not the case!      *
*    The background rectangle will be taken care of by GreExtTextOutW. *
*                                                                      *
***********************************************************************/

#define SO_MASK                     \
(                                   \
    SO_FLAG_DEFAULT_PLACEMENT |     \
    SO_ZERO_BEARINGS          |     \
    SO_CHAR_INC_EQUAL_BM_BASE |     \
    SO_MAXEXT_EQUAL_BM_SIDE         \
)


#define     TEXT_BUFFER_SIZE    1024
#define     KERNEL_ALLOC_SIZE   65536

//
// accelerator masks for four canonical directions of
// writing (multiples of 90 degrees)
//

#define SO_LTOR          (SO_MASK | SO_HORIZONTAL)
#define SO_RTOL          (SO_LTOR | SO_REVERSED)
#define SO_TTOB          (SO_MASK | SO_VERTICAL)
#define SO_BTOT          (SO_TTOB | SO_REVERSED)

//
// Glyph copy Declarations
//

typedef VOID (*PFN_MASTERTEXTTYPE)(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

//
// Temp buffer expansion Declarations
//

typedef VOID (*PFN_TEXTSRCCPY)(
    BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vExpandAndCopyText(
    SURFACE *,
    FONTOBJ * ,
    GLYPHPOS *,
    ULONG    ,
    PBYTE,
    ULONG,
    ULONG,
    SURFACE *,
    SURFACE *,
    RECTL *,
    RECTL *,
    INT,
    INT,
    ULONG,
    RECTL *,
    RECTL *,
    ULONG,
    BRUSHOBJ *,
    POINTL *
    );

extern "C" {

VOID vFastText(
    GLYPHPOS *,
    ULONG    ,
    PBYTE,
    ULONG,
    ULONG,
    SURFOBJ *,
    RECTL *,
    RECTL *,
    INT,
    INT,
    ULONG,
    RECTL *,
    RECTL *
    );

VOID vSrcTranCopyError(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS1D1(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D4(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D8(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS1D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS1D1(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D4(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D8(   BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D8_64(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS1D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS4D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS4D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS4D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS4D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS4D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS4D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcOpaqCopyS8D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS8D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcOpaqCopyS8D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

VOID vSrcTranCopyS8D16(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS8D24(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
VOID vSrcTranCopyS8D32(  BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);





VOID draw_f_tb_no_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_nf_tb_no_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

// grayscale routines

VOID draw_gray_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_gray_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

// cleartype routines

VOID draw_clrt_nf_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);
VOID draw_clrt_f_ntb_o_to_temp_start(PGLYPHPOS,ULONG,PUCHAR,ULONG,ULONG,ULONG,ULONG);

ULONG TextExpStartMask[]  = {0xFFFFFFFF,
                             0xFFFFFF00,
                             0xFFFF0000,
                             0xFF000000
                            };

ULONG TextExpEndMask[]    = {0xFFFFFFFF,
                             0x000000FF,
                             0x0000FFFF,
                             0x00FFFFFF
                            };

LONG  TextExpStartByteCount[] = {0,3,2,1};

}




#define NO_TARGET 0
#define     FIFTEEN_BITS        ((1 << 15)-1)

#if DBG
void vDump8bppDIB(SURFMEM& surfmem);
#endif

/******************************Public*Routine******************************\
* Routine Name:
*
*   EngTextOut
*
* Routine Description:
*
*   This routine blts glyphs to a DIB.
*
* Arguments:
*
*   pso         - Surface object for destination surface
*   pstro       - String object for enumerating glyphs
*   pfo         - Font object of glyphs
*   pco         - Clip object
*   prclExtra   - Extra rectangles to draw with text
*   prclOpaque  - Opaque rectangle
*   pboFore     - Foreground brush
*   pboOpaque   - Background brush
*   pptlOrg     - Brush starting origin
*   mix         - Equal to SRCCOPY for now
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/
#define ETO_GRAY                       8
#define ETO_DEVICE_SURFACE            16
#define ETO_CLEARTYPE_X               32
#define ETO_CLEARTYPE_Y               64

VOID EngTextOutBitBlt(
    SURFACE     *pSurf,
    FONTOBJ     *pfo,
    ULONG       fDrawFlags,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMsk,
    CLIPOBJ     *pco,
    XLATEOBJ    *plxo,
    RECTL       *prclTrg,
    POINTL      *pptlSrc,
    POINTL      *pptlMsk,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrush,
    ROP4        rop4
)
{

    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

        TextOutBitBlt(pSurf, rfo, psoSrc, psoMsk, pco, plxo,
                      prclTrg, pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }
    else
    {
        EngBitBlt(pSurf->pSurfobj(), psoSrc, psoMsk, pco, plxo,
                  prclTrg, pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }
}

BOOL EngTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    PRECTL    prclExtra,
    PRECTL    prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    PPOINTL   pptlOrg,
    MIX       mix
    )
{
    ULONG           iClip;                  // Clip object's complexity
    BOOL            bMore;                  // Flag for clip enumeration
    CLIPENUMRECT    txen;                   // Clip enumeration object
    GLYPHPOS       *pgp;                    // pointer to the 1st glyph
    BOOL            bMoreGlyphs;            // Glyph enumeration flag
    ULONG           cGlyph;                 // number of glyphs in one batch
    ULONG           iSolidForeColor;        // Solid foreground color
    ULONG           iSolidBkColor;          // Solid background color
    FLONG           flStr = 0;              // Accelator flag for DrvTextOut()
    FLONG           flOption = 0;           // Accelator flag for pfnBlt
    RECTL           arclTmp[4];             // Temp storage for portions of
                                            //  opaquing rect
    RECTL          *prclClip;               // ptr to list of clip rectangles
    ULONG           ulBufferWidthInBytes = 0;
    ULONG           ulBufferHeight;
    ULONG           ulBufferBytes;
    BOOL            bTextPerfectFit;
    ULONG           fDrawFlags = 0;
    BYTE           *pjTempBuffer;
    BOOL            bTempAlloc;
    BOOL            bKernelAlloc;
    BYTE            szTextBuffer[TEXT_BUFFER_SIZE];
    ULONG           Native64BitAccess = TRUE;
    ULONG           iTrgType = 0;
    SURFACE        *pSurfDraw;
    RECTL           rcScreen;               // intersection of Screen & DIB
                                            // in screen coordinates
    RECTL           rcDIB;                  // intersection of Screen & DIB
                                            // in DIB coordinates

    XDCOBJ         *pdco = 0;               // equal to pSurf->pdcoAA
                                            // this is non-zero in the case
                                            // where the text in anti-aliased
                                            // and the device does not support
                                            // antialiased text directly. In such
                                            // a case we must be able to pass
                                            // information about the original
                                            // deivce surface
    SURFACE        *pSurfDevice = 0;        // pointer to original device surface
                                            // this is obtained via pdco

// This hack, due to filtering needs to be put in textgdi.cxx
// filtering leeks color one pixel to the left and one pixel to the right

    ASSERTGDI(pso   != (SURFOBJ *) NULL, "ERROR: EngTextOut Surface\n");
    ASSERTGDI(pstro != (STROBJ  *) NULL, "ERROR: EngTextOut String\n" );
    ASSERTGDI(pfo   != (FONTOBJ *) NULL, "ERROR: EngTextOut Font\n"   );

    // In order to support antialiasing text on devices that don't
    // support antialiasing GDI will first render the text to
    // a DIB then later copy the DIB to the original device surface.
    // In such a case pso represents the DIB surface and mix
    // contains a pointer to the original XDCOBJ which will
    // be needed in order to interpret the colors corectly. The
    // way that we recognize this situation is that
    // pSurf->pdcoAA is non-zero

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);
    pSurfDraw = pSurf;

    if (pfo->flFontType & FO_GRAY16)
    {
        if ( pdco = pSurf->pdcoAA )
        {
            ASSERTGDI(pdco->dctp() != DCTYPE_INFO, "dctp == DCTYPE_INFO\n");

            pSurfDevice = pdco->pdc->ppdev()->pSurface;

        }
        else
        {
            pSurfDevice = pSurf;
        }

        if (pSurf->iType() != STYPE_BITMAP)
        {
            fDrawFlags |= ETO_DEVICE_SURFACE;
        }
    }

    if ((pfo->flFontType & DEVICE_FONTTYPE) != 0)
    {
        WARNING("Attempting EngTextOut with Device Font\n");
        return(FALSE);
    }

    //
    // Note that we don't synchronize with the device here (we do that in
    // vExpandAndCopyText after doing a bunch of work not involving the
    // frame buffer), but we do let the driver know we're going to be
    // calling Synchronize soon via FLUSH, to get it to empty its DMA
    // buffer.
    //

//    {
//        PDEVOBJ po(pSurf->hdev());
//        if (po.flGraphicsCaps2() & GCAPS2_SYNCFLUSH)
//        {
//            po.vSync(pso, NULL, DSS_FLUSH_EVENT);
//        }
//    }

    iClip = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

    iSolidForeColor = pboFore->iSolidColor;

    //
    // assume no opaque rectangle
    //

    iSolidBkColor = 0xFFFFFFFF;

    //
    // See if the temp buffer is big enough for the text; if not,
    // try to allocate enough memory.
    // Round up to the nearest dword multiple so that the alignment
    // will stay constant when blt to the destination surface.
    //

    if(pfo->flFontType & FO_GRAY16)
    {
        if (pSurf->iFormat() == BMF_8BPP)
        {
            if (pboOpaque->iSolidColor == -1L)
            {
                RIP("EngTextOut Error attempting anti-aliased text\n"
                    "at 8bpp with a transparent background.\n");
                return(FALSE);
            }
        }

        fDrawFlags |= ETO_GRAY;

        if (pfo->flFontType & FO_CLEARTYPE_X)
        {
        //
        // This is the case 8-bpp antialiased text
        //
        // The strategy is to create a 8-bpp buffer representing
        // the entire string.
        //
        // The buffer shall be aligned with the destination. That
        // is, 32-bit boundaries in the buffer correspond to 32
        // bit boundaries in the destination surface and the text
        // in the buffer has the same relative alignment as the
        // destination. To do this, we bump boundaries of the buffer
        // such that the left and right boundaries of the buffer
        // land on 32-bit aligned postions. This is done in the
        // following way. We note that a DWORD is 32 bits, this
        // is enough information to specify 4 (8bpp) pixels. The
        // number aligned DWORD's needed to surround the nibbles
        // defining the text is calculated by finding the nearest
        // multiple of 4 above and below the x-boundaries of the
        // text. The difference between these two numbers is a
        // count of DWORD's. Then since each DWORD is made up
        // of 4 bytes, we multiply by 4 at the end to get a count
        // of bytes.
        //
        // buffer width in bytes = 4 * (ceiling((right+1)/4) - floor(left/4))
        //

            fDrawFlags |= ETO_CLEARTYPE_X;

            ulBufferWidthInBytes  =
             ( ((pstro->rclBkGround.right + 4) >> 2)
             - ((pstro->rclBkGround.left     ) >> 2) ) << 2;

        }
        else if (pfo->flFontType & FO_CLEARTYPE_Y)
        {
            RIP("FO_CLEARTYPE_Y, not supported yet\n");
        }
        else
        {
        //
        // This is the case 4-bpp antialiased text
        //
        // The strategy is to create a 4-bpp buffer representing
        // the entire string.
        //
        // The buffer shall be aligned with the destination. That
        // is, 32-bit boundaries in the buffer correspond to 32
        // bit boundaries in the destination surface and the text
        // in the buffer has the same relative alignment as the
        // destination. To do this, we bump boundaries of the buffer
        // such that the left and right boundaries of the buffer
        // land on 32-bit aligned postions. This is done in the
        // following way. We note that a DWORD is 32 bits, this
        // is enough information to specify 8 (4bpp) pixels. The
        // number aligned DWORD's needed to surround the nibbles
        // defining the text is calculated by finding the nearest
        // multiple of 8 above and below the x-boundaries of the
        // text. The difference between these two numbers is a
        // count of DWORD's. Then since each DWORD is made up
        // of 4 bytes, we multiply by 4 at the end to get a count
        // of bytes.
        //
        // buffer width in bytes = 4 * (ceiling((right+1)/8) - floor(left/8))
        //

            ulBufferWidthInBytes  =
                ( ((pstro->rclBkGround.right + 8) >> 3)
                - ((pstro->rclBkGround.left     ) >> 3) ) << 2;

        }
    }
    else
    {
        ulBufferWidthInBytes =
            ((((pstro->rclBkGround.right + 32) & ~31) -
            (pstro->rclBkGround.left & ~31)) >> 3);
    }
    ulBufferHeight = (ULONG)(pstro->rclBkGround.bottom - pstro->rclBkGround.top);

    if ((ulBufferWidthInBytes > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        //
        // the math will have overflowed
        //

        return(FALSE);
    }
    ulBufferBytes = ulBufferWidthInBytes * ulBufferHeight;

    if (ulBufferBytes <= TEXT_BUFFER_SIZE)
    {
        //
        // The temp buffer on the stack is big enough, so we'll use it
        //

        pjTempBuffer = szTextBuffer;
        bTempAlloc = FALSE;
    }
    else
    {
        //
        // The temp buffer isn't big enough, so we'll try to allocate
        // enough memory
        //

        #if DBG

            if (ulBufferBytes >= (PAGE_SIZE * 10000))
            {
                WARNING("EngTextOut: temp buffer >= 10000 pages");
                return(FALSE);
            }

        #endif
        
        bKernelAlloc = (ulBufferBytes < KERNEL_ALLOC_SIZE);
        if (bKernelAlloc)
        {
            pjTempBuffer = (BYTE*) PALLOCNOZ(ulBufferBytes, 'oteG');
        }
        else
        {
            pjTempBuffer = (BYTE*) EngAllocUserMem(ulBufferBytes,'oteG');
        }

        if (pjTempBuffer == NULL)
        {
            return(FALSE);
        }

        //
        // Mark that we have to free the buffer when we're done
        //

        bTempAlloc = TRUE;
    }

    //
    // One way or another, we've found a buffer that's big enough; set up
    // for accelerated text drawing
    //
    // Set fixed pitch, overlap, and top & bottom Y alignment flags
    //

    if ((!(pstro->flAccel & SO_HORIZONTAL)) || (pstro->flAccel & SO_REVERSED))
    {
        ;
    }
    else
    {
        fDrawFlags |= ((pstro->ulCharInc != 0) |


                     (
                       (
                        (pstro->flAccel & (SO_ZERO_BEARINGS |
                         SO_FLAG_DEFAULT_PLACEMENT)) !=
                        (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT)
                        ) << 1
                     ) |

                     (
                      ((pstro->flAccel & (SO_ZERO_BEARINGS |
                        SO_FLAG_DEFAULT_PLACEMENT |
                        SO_MAXEXT_EQUAL_BM_SIDE)) ==
                       (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                        SO_MAXEXT_EQUAL_BM_SIDE)
                       ) << 2
                      )
                     );
    }

    //
    // Handle the opaque rectangle if given.
    //
    // If the background brush is a pattern brush or the foreground brush is
    // a pattern brush (foreground pattern brush is not supported), we
    // will output the whole rectangle now.
    //
    // Otherwise, we will compute the fringe opaque area outside the text
    // rectangle and include the remaining rectangle in the text output.
    // The fringe rectangles will be output last to reduce flickering when
    // a string is "moved" continuously across the screen.
    //

    FRINGERECT fr(pSurf, pco, pboOpaque);

    if (prclOpaque != (PRECTL) NULL)
    {
        //
        // If we have a device managed surface then the pattern should be
        // laid down with the device's BitBlt function
        //

        iSolidBkColor = pboOpaque->iSolidColor;
        if ((iSolidBkColor   == 0xFFFFFFFF)  ||   // Background brush is pattern.
            (iSolidForeColor == 0xFFFFFFFF))      // Foreground brush is pattern.
        {

            //
            // Output the whole rectangle.
            //

            EngTextOutBitBlt(
                    pSurf,
                    pfo,
                    fDrawFlags,
                    (SURFOBJ *)  NULL,    // Source surface.
                    (SURFOBJ *)  NULL,    // Mask surface.
                    pco,                  // Clip object.
                    NULL,                 // Palette translation object.
                    prclOpaque,           // Destination rectangle.
                    (POINTL *)  NULL,     // Source origin.
                    (POINTL *)  NULL,     // Mask origin.
                    pboOpaque,            // Realized opaque brush.
                    pptlOrg,              // brush origin
                    0x0000f0f0            // PATCOPY
            );
        }
        else
        {
            //
            // Compute the four fringe rectangles.
            //
            // According to the DDI, the opaque rectangle,
            // if given, always bounds the text to be drawn.
            //
            // (iClip == DC_RECT) added because display driver changes prclOpq 
            // after intersecting the original prclOpq, rclBkGrnd and rclClip
            // iClip == DC_RECT if there is a clipping rectangle.
            //

            ASSERTGDI((iClip != DC_TRIVIAL) || ((ERECTL *) prclOpaque)->bContain(pstro->rclBkGround),
                        "EngTextOut: opaque rectangle does not bound text background!");

            if (pstro->rclBkGround.top > prclOpaque->top) 
            {
                fr.vAddRect(prclOpaque->left, prclOpaque->top,
                            prclOpaque->right, pstro->rclBkGround.top);
            }

            if (pstro->rclBkGround.left > prclOpaque->left)
            {
                fr.vAddRect(prclOpaque->left, pstro->rclBkGround.top,
                            pstro->rclBkGround.left, pstro->rclBkGround.bottom);
            }

            if (pstro->rclBkGround.right < prclOpaque->right)
            {
                fr.vAddRect(pstro->rclBkGround.right, pstro->rclBkGround.top,
                            prclOpaque->right, pstro->rclBkGround.bottom);
            }

            if (pstro->rclBkGround.bottom < prclOpaque->bottom) 
            {
                fr.vAddRect(prclOpaque->left, pstro->rclBkGround.bottom,
                            prclOpaque->right, prclOpaque->bottom);
            }
        }
    }


    //
    // Draw the text into the temp buffer, and thence to the screen
    //

    //
    // IF (a device surface) THEN BEGIN
    //   create a DIB;
    //   IF (allocation was not successful) THEN return(FAILURE);
    //   IF (transparent text) THEN
    //     copy the surface bits to the DIB;
    // END
    //
    SURFMEM surfmem;
    DEVBITMAPINFO dbmi;
    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        ASSERTGDI(fDrawFlags & ETO_GRAY, 
            "Device surface but not antialiased text\n");

        //  Rectangles of interest (in screen coordinates)
        //
        //  1. screen
        //
        //                  left_s   = 0
        //                  top_s    = 0
        //                  right_s  = pso->sizlBitmap.cx
        //                  bottom_s = pso->sizlBitmap.cy
        //
        //  2. text
        //
        //                  left_t   = prcl->left
        //                  top_t    = prcl->top
        //                  right_t  = prcl->right
        //                  bottom_t = prcl->bottom
        //
        //  3. buffer
        //
        //                  left_b   = left_t & ~7
        //                  top_b    = top_t
        //                  right_b  = (right_t + 7) & ~7
        //                  bottom_b = bottom_t
        //
        //  4. dib
        //
        //                  left_d   = left_b
        //                  top_d    = top_b
        //                  right_d  = right_t
        //                  bottom_d = bottom_t
        //
        //  The intersection of the screen and dib rectangles
        //  have screen coordinates
        //
        //  5. interesection of the screen and text rectangles
        //     (screen coordinates)
        //
        //      left_st   = max(left_t,   left_s  )
        //      top_st    = max(top_t,    top_s   )
        //      right_st  = min(right_t,  right_s )
        //      bottom_st = min(bottom_t, bottom_s)
        //
        //  6. intersection of the screen and text coordinates
        //     (DIB coordinates)
        //
        //      left_st'   = left_st   - left_d
        //      top_st'    = top_st    - top_d
        //      right_st'  = right_st  - left_d
        //      bottom_st' = bottom_st - top_d
        //
        // Make the DIB aligned with the buffer on the left
        // and aligned with the text on the right
        //
        // Actually, I could have been less aggressive in allocating
        // memory. There is actually no reason to allocate memory
        // that is larger than the screen. However, if I did that
        // I would have to watch for the end of the dib while I
        // processed the glyphs which would slow things down.
        //

        long left = pstro->rclBkGround.left & ~7;   // left of DIB (screen coordinates)

        if (fDrawFlags & ETO_CLEARTYPE_X)
            left = pstro->rclBkGround.left & ~3;

        long top  = pstro->rclBkGround.top;         // top  of DIB (screen coordinates)

        dbmi.iFormat  = pSurf->iFormat();
        dbmi.cxBitmap = pstro->rclBkGround.right  - left;
        dbmi.cyBitmap = pstro->rclBkGround.bottom - top;
        dbmi.hpal     = 0;
        dbmi.fl       = BMF_TOPDOWN;

        if (pSurf->bUMPD())
            dbmi.fl |= UMPD_SURFACE;

        if (!surfmem.bCreateDIB(&dbmi,0))
        {
            WARNING("EngTextOut: surfmem.bCreateDIB failed\n");
            if (bTempAlloc)
            {
                if (bKernelAlloc)
                    VFREEMEM(pjTempBuffer);
                else
                    EngFreeUserMem(pjTempBuffer);
            }
            return(FALSE);
        }
        pSurfDraw = surfmem.ps;

        //
        // Compute the source surface origin, taking into account multi-mon
        // and negative offsets:
        //

        LONG xOrigin = 0;
        LONG yOrigin = 0;

        PDEVOBJ pdoSrc(pSurf->hdev());
        ASSERTGDI(pdoSrc.bValid(),"Invalid pdoSrc I\n");

        if (pdoSrc.bPrimary(pSurf) && pdoSrc.bMetaDriver())
        {
            xOrigin = pdoSrc.pptlOrigin()->x;
            yOrigin = pdoSrc.pptlOrigin()->y;
        }

        //
        // rcScreen = screen & text intersection (screen coordinates)
        //

        rcDIB = pstro->rclBkGround;

        rcScreen.left   = max(xOrigin, pstro->rclBkGround.left);
        rcScreen.top    = max(yOrigin, pstro->rclBkGround.top );
        rcScreen.right  = min(xOrigin + pso->sizlBitmap.cx, pstro->rclBkGround.right );
        rcScreen.bottom = min(yOrigin + pso->sizlBitmap.cy, pstro->rclBkGround.bottom);

        //
        // The DDI guarantees the driver that 'pco->rclBounds' is guaranteed
        // to intersect with 'prclDst' on a DrvCopyBits call.  Later on, we
        // will use 'pco' and 'rcScreen' in a DrvCopyBits call, so check for
        // no drawing here:
        //

        if ((iClip != DC_TRIVIAL) && !bIntersect(&rcScreen, &pco->rclBounds))
        {
            if (bTempAlloc)
            {
                if (bKernelAlloc)
                    VFREEMEM(pjTempBuffer);
                else
                    EngFreeUserMem(pjTempBuffer);
            }
            return(TRUE);
        }

        //
        // rcDIB = screen & text intersection (DIB coordinates)
        //

        rcDIB = rcScreen;
        rcDIB.left   -= left;
        rcDIB.top    -= top;
        rcDIB.right  -= left;
        rcDIB.bottom -= top;

        if (iSolidBkColor == (ULONG) -1)
        {
            //
            // background is transparent copy bits from surface to DIB
            //

            if (rcScreen.left < rcScreen.right && rcScreen.top < rcScreen.bottom)
            {
                (*PPFNGET(pdoSrc,CopyBits,pSurf->flags())) (
                         surfmem.pSurfobj(),
                         pSurf->pSurfobj(),
                         0,
                         &xloIdent,
                         &rcDIB,
                         (POINTL*) &rcScreen);
            }
        }
    }

    //
    // Some drivers do banking meaning they will call EngTextOut multiple times
    // per TextOut call.  Most of the time all the GLYPH positions in the STROBJ will
    // be valid meaning it doesn't matter that you call STROBJ_vEnumStart.  But if
    // they aren't, it does matter.  This is always true in the case of linked text out
    // calls.
    //

    STROBJ_vEnumStart(pstro);

    //
    // clear buffer for opaque mode
    //
    if (iSolidBkColor != -1L)
        RtlFillMemoryUlong((ULONG*) pjTempBuffer, ulBufferBytes, 0);

    do
    {
        //
        // Get the next batch of glyphs
        //

        //
        // clear buffer, transparent mode, we need to clean the buffer in the while loop to get the font linking 
        //               with antialiazing work right 
        //
        if (iSolidBkColor == -1L)
            RtlFillMemoryUlong((ULONG*) pjTempBuffer, ulBufferBytes, 0);

        if (pstro->pgp != NULL)
        {
            //
            // There's only the one batch of glyphs, so save ourselves a call
            //

            pgp = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);
        }

        //
        //  No glyph, no work!
        //

        if (cGlyph)
        {
            arclTmp[0].left   = LONG_MIN;
            arclTmp[0].top    = LONG_MIN;
            arclTmp[0].right  = LONG_MAX;
            arclTmp[0].bottom = LONG_MAX;
            arclTmp[1].bottom = 0;
            prclClip = &arclTmp[0];

            {
                switch (iClip)
                {
                case DC_RECT:
                    arclTmp[0] = pco->rclBounds;    // copy clip rect to arclTmp[0]
                    arclTmp[1].bottom = 0;          // make arclTmp[1] a null rect

                    //
                    // falling through !
                    //

                case DC_TRIVIAL:
                    vExpandAndCopyText(pSurf,
                                       pfo,
                                       pgp,
                                       cGlyph,
                                       (PBYTE)pjTempBuffer,
                                       ulBufferWidthInBytes,
                                       pstro->ulCharInc,
                                       pSurfDraw,
                                       pSurfDevice,
                                       &pstro->rclBkGround,
                                       prclOpaque,
                                       iSolidForeColor,
                                       iSolidBkColor,
                                       fDrawFlags,
                                       prclClip,
                                       prclExtra,
                                       Native64BitAccess,
                                       pboFore,
                                       pptlOrg);
                    break;

                case DC_COMPLEX:
                    prclClip = &txen.arcl[0];


                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco,
                                (ULONG) (sizeof(txen) - sizeof(RECT)),
                                (PULONG) &txen);

                        txen.arcl[txen.c].bottom = 0;   // terminate txen.arcl[]
                                                        // with a null rect
                        vExpandAndCopyText(pSurf,
                                           pfo,
                                           pgp,
                                           cGlyph,
                                           (PBYTE)pjTempBuffer,
                                           ulBufferWidthInBytes,
                                           pstro->ulCharInc,
                                           pSurfDraw,
                                           pSurfDevice,
                                           &pstro->rclBkGround,
                                           prclOpaque,
                                           iSolidForeColor,
                                           iSolidBkColor,
                                           fDrawFlags,
                                           prclClip,
                                           prclExtra,
                                           Native64BitAccess,
                                           pboFore,
                                           pptlOrg);
                    } while (bMore);
                    break;
                }
            }
        }
    } while (bMoreGlyphs);

    if (fDrawFlags & ETO_DEVICE_SURFACE)
    {
        PDEVOBJ pdoSrc(pSurf->hdev());
        ASSERTGDI(pdoSrc.bValid(), "Invalid pdoSrc II\n");

        (*PPFNGET(pdoSrc,CopyBits,pSurf->flags())) (
                 pSurf->pSurfobj(),
                 surfmem.pSurfobj(),
                 pco,
                 0,
                 &rcScreen,
                 (POINTL*) &rcDIB);
    }

    //
    // Free up any memory we allocated for the temp buffer
    //

    if (bTempAlloc) 
    {

        if (bKernelAlloc)
            VFREEMEM(pjTempBuffer);
        else
            EngFreeUserMem(pjTempBuffer);
    }

    return(TRUE);
}



//
// lookup tables for character drawing and temp buffer expansion
//


#if !defined (_X86_)
PVOID   MastertextTypeTabel[] = {
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,
            draw_nf_tb_no_to_temp_start,
            draw_f_tb_no_to_temp_start,
            draw_nf_ntb_o_to_temp_start,
            draw_f_ntb_o_to_temp_start,

            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start,
            draw_gray_nf_ntb_o_to_temp_start,
            draw_gray_f_ntb_o_to_temp_start
        };
#endif




//
// MIPS has separate code for 8bpp destination depending
// on whether the driver supports the GCAPS_64BITMEMACCESS flag.
// This is because on some MIPS systems, 64 bit memory accesses
// the video space are truncated to 32. These systems must use the
// 32 bit version of 8 bpp output.
//


// SrcCopyTextFunctionTable is an array of 32 pointers to functions
// takeing BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*
// as arguments and returning a VOID.

#if !defined (_MIPS_)

VOID (*(SrcCopyTextFunctionTable[48]))
(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*) = {

                vSrcTranCopyError,         // 0 opaque
                vSrcOpaqCopyS1D1,          // 1
                vSrcOpaqCopyS1D4,          // 2
                vSrcOpaqCopyS1D8,          // 3
                vSrcOpaqCopyS1D16,         // 4
                vSrcOpaqCopyS1D24,         // 5
                vSrcOpaqCopyS1D32,         // 6
                vSrcTranCopyError,         // 7

                vSrcTranCopyError,         // 8 transparent
                vSrcTranCopyS1D1,          // 9
                vSrcTranCopyS1D4,          // a
                vSrcTranCopyS1D8,          // b
                vSrcTranCopyS1D16,         // c
                vSrcTranCopyS1D24,         // d
                vSrcTranCopyS1D32,         // e
                vSrcTranCopyError,         // f

                                           // gray pixels
                vSrcTranCopyError,         // 10 opaque
                vSrcTranCopyError,         // 11
                vSrcTranCopyError,         // 12
                vSrcTranCopyError,         // 13
                vSrcOpaqCopyS4D16,         // 14
                vSrcOpaqCopyS4D24,         // 15
                vSrcOpaqCopyS4D32,         // 16
                vSrcTranCopyError,         // 17

                vSrcTranCopyError,         // 18 transparent
                vSrcTranCopyError,         // 19
                vSrcTranCopyError,         // 1a
                vSrcTranCopyError,         // 1b
                vSrcTranCopyS4D16,         // 1c
                vSrcTranCopyS4D24,         // 1d
                vSrcTranCopyS4D32,         // 1e
                vSrcTranCopyError,         // 1f

                // CLEARTYPE_X

                vSrcTranCopyError,         // 20 opaque
                vSrcTranCopyError,         // 21
                vSrcTranCopyError,         // 22
                vSrcTranCopyError,         // 23
                vSrcOpaqCopyS8D16,         // 24
                vSrcOpaqCopyS8D24,         // 25
                vSrcOpaqCopyS8D32,         // 26
                vSrcTranCopyError,         // 27

                vSrcTranCopyError,         // 28 transparent
                vSrcTranCopyError,         // 29
                vSrcTranCopyError,         // 2a
                vSrcTranCopyError,         // 2b
                vSrcTranCopyS8D16,         // 24
                vSrcTranCopyS8D24,         // 25
                vSrcTranCopyS8D32,         // 26
                vSrcTranCopyError,         // 2f
            };

#else

VOID (*(SrcCopyTextFunctionTable[48]))
(BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*) = {

                vSrcOpaqCopyS1D8,          // 0 opaque
                vSrcOpaqCopyS1D1,          // 1
                vSrcOpaqCopyS1D4,          // 2
                vSrcOpaqCopyS1D8_64,       // 3
                vSrcOpaqCopyS1D16,         // 4
                vSrcOpaqCopyS1D24,         // 5
                vSrcOpaqCopyS1D32,         // 6
                vSrcTranCopyError,         // 7

                vSrcTranCopyError,         // 8 transparent
                vSrcTranCopyS1D1,          // 9
                vSrcTranCopyS1D4,          // a
                vSrcTranCopyS1D8,          // b
                vSrcTranCopyS1D16,         // c
                vSrcTranCopyS1D24,         // d
                vSrcTranCopyS1D32,         // e
                vSrcTranCopyError,         // f

                                           // gray pixels
                vSrcTranCopyError,         // 10 opaque
                vSrcTranCopyError,         // 11
                vSrcTranCopyError,         // 12
                vSrcTranCopyError,         // 13
                vSrcOpaqCopyS4D16,         // 14
                vSrcOpaqCopyS4D24,         // 15
                vSrcOpaqCopyS4D32,         // 16
                vSrcTranCopyError,         // 17

                vSrcTranCopyError,         // 18 transparent
                vSrcTranCopyError,         // 19
                vSrcTranCopyError,         // 1a
                vSrcTranCopyError,         // 1b
                vSrcTranCopyS4D16,         // 1c
                vSrcTranCopyS4D24,         // 1d
                vSrcTranCopyS4D32,         // 1e
                vSrcTranCopyError,         // 1f

                // CLEARTYPE_X

                vSrcTranCopyError,         // 20 opaque
                vSrcTranCopyError,         // 21
                vSrcTranCopyError,         // 22
                vSrcTranCopyError,         // 23
                vSrcOpaqCopyS8D16,         // 24
                vSrcOpaqCopyS8D24,         // 25
                vSrcOpaqCopyS8D32,         // 26
                vSrcTranCopyError,         // 27

                vSrcTranCopyError,         // 28 transparent
                vSrcTranCopyError,         // 29
                vSrcTranCopyError,         // 2a
                vSrcTranCopyError,         // 2b
                vSrcTranCopyS8D16,         // 2c
                vSrcTranCopyS8D24,         // 2d
                vSrcTranCopyS8D32,         // 2e
                vSrcTranCopyError,         // 2f
            };
#endif




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vExpandAndCopyText
*
* Routine Description:
*
*   Break down glyph drawing into several classes, based on
*   pitch, alignment and overlap, and in this loop dispatch to
*   highly specialized glyph drawing routines based on width
*   and bit rotation.
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - temp 1BPP [4BPP] buffer to draw into
*   ulBufferWidthInBytes    - Delta for temp buffer
*   ulCharInc               - pstro->ulCharInc, increment for fixed pitch
*   pSurf                   - surface obj, for drawing on actual surface
*   pSurfDevice             - surface object for original device
*                             (for antialiased text on devices that
*                              don't support antialiased text natively).
*   prclText                - bounding rectangle on dest surface
*   prclOpaque              - boundary of opaque rect
*   iSolidForeColor         - foreground color when drawing on dest surface
*   iSolidBkColor           - background color when drawing on dest surface
*   fDrawFlags              - special flags to allow for table lookup of routines
*   prclClip                - clipping rect
*   prclExtra               - extra rects to draw
*   Native64BitAccess       - can use 64 bit accesses
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID vExpandAndCopyText(
    SURFACE* pSurface,
    FONTOBJ* pfo,
    GLYPHPOS *pGlyphPos,
    ULONG     cGlyph,
    BYTE     *pjTempBuffer,
    ULONG     ulBufferWidthInBytes,
    ULONG     ulCharInc,
    SURFACE   *pSurf,
    SURFACE   *pSurfDevice,
    RECTL     *prclText,
    RECTL     *prclOpaque,
    INT       iSolidForeColor,
    INT       iSolidBkColor,
    ULONG     fDrawFlags,
    RECTL     *prclClip,
    RECTL     *prclExtra,
    ULONG     Native64BitAccess,
    BRUSHOBJ  *pboFore,
    POINTL    *pptlOrg
    )
{

    PFN_MASTERTEXTTYPE pfnMasterType;
    BLTINFO            SrcCopyBltInfo;
    PFN_TEXTSRCCPY     pfnTextSrcCopy;
    EXLATEOBJ          exlo;
    XLATE              *pxlo = NULL;
    RECTL              *pCurrentRect;
    ULONG              BufferAlign;
    ULONG              BufferOffset;
    ULONG              ulSrcCopyFlag;
    ULONG              ulTempTop;

#if DBG
/**/void vDumpGrayBuffer(BYTE *, ULONG, RECTL*);
#endif

	GLYPHPOS *pGPosTmp = pGlyphPos;

	//
	//	pGlyphPos->pgdf->pgb must not be NULL.
	//	But if there is printer a driver bug and GetGlyphMode() returns FO_HGLYPHS
	//	instead of FO_GLYPHBITS, then it can be NULL and crash system.
	//	To protect from this situation, vExpandAndCopyText() just return without copying
	//	in this case.
	//
	
	for(ULONG i=0; i<cGlyph; i++, pGPosTmp++){
		if(pGPosTmp->pgdf->pgb == NULL){
        	WARNING("pGlyphPos->pgdf->pgb is NULL. Possibly GetGlyphMode() bug of Printer Driver\n");
        	return;
		}
	}

    // UMPD NtGdiEngTextOut holding RFONT cache semaphore.
    // vExpandAndCopyText might call back into user mode.

    BOOL bSem = FALSE;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    PDEVOBJ po(pSurface->hdev());
    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

    if (po.bValid() && po.bPrinter() && po.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    //
    // save global params
    //

    ulTempTop = prclText->top;

    //
    // DWORD Align temp buffer to DST.
    //
    // For 1Bpp addresses, left[31:05] = DWORD Address
    //                     left[04:03] = Byte in DWORD
    //                     left[02:00] = Pixel in Byte
    //
    // To optimize 1bpp drawing, both buffers must be DWORD aligned,
    // this makes the temp buffer starting point is left[04:00].
    //
    // This means that the glyph offset in the temporary buffer is xPos - left[31:05]
    //

    //
    // BufferOffset = x-position of nearest pixel to the left of the text rectangle
    //                whose address is on a 32-bit boundary in the glyph source
    //                which is either monchrome (1bpp) or gray (4bpp). This
    //                is also the position of the first pixel position on
    //                a temporary DIB buffer provided for anti-aliased text
    //                simulation.
    //
    // BufferAlign  = number of pixels the left portion of the text is
    //                offset to the right from BufferOffset
    //
    // prclText = BufferOffset + BufferAlign
    //
    //      monochrome text
    //
    //              BufferOffset = prclText->left & ~31
    //              BufferAlign  = prclText->left &  31
    //
    //      gray (4bpp) text
    //
    //              BufferOffset = prclText->left & ~7
    //              BufferAlign  = prclText->left &  7
    //
    //      clear type 8bpp text
    //
    //              BufferOffset = prclText->left & ~3
    //              BufferAlign  = prclText->left &  3
    //

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        if (fDrawFlags & ETO_GRAY)
        {
            GLYPHPOS *pgp, *pgpBad;
            DbgPrint(
                "vExpandAndCopyText(\n"
                "   GLYPHPOS *pGlyphPos            =    %-#x\n"
                "   ULONG     cGlyph               =    %u\n"
                "   BYTE     *pjTempBuffer         =    %-#x\n"
                "   ULONG     ulBufferWidthInBytes =    %u\n"
                "   ULONG     ulCharInc            =    %u\n"
                "   SURFACE   *pSurf               =    %-#x\n"
                "   SURFACE   *pSurfDevice         =    %-#x\n"
                , pGlyphPos
                , cGlyph
                , pjTempBuffer
                , ulBufferWidthInBytes
                , ulCharInc
                , pSurf
                , pSurfDevice
                );
            DbgPrint(
                "   RECTL     *prclText            =    %-#x\n"
                "   RECTL     *prclOpaque          =    %-#x\n"
                "   INT       iSolidForeColor      =    %-#x\n"
                "   INT       iSolidBkColor        =    %-#x\n"
                , prclText
                , prclOpaque
                , iSolidForeColor
                , iSolidBkColor
            );
            DbgPrint(
                "   RECTL     *prclClip            =    %-#x\n"
                "   RECTL     *prclExtra           =    %-#x\n"
                "   ULONG     Native64BitAccess    =    %-#x\n"
                , prclClip
                , prclExtra
                , Native64BitAccess
            );
            DbgPrint(
                "   ULONG     fDrawFlags           =    %-#x\n"
                , fDrawFlags
            );
            if (fDrawFlags & 1)
            {
                DbgPrint("\t\t\t\t\tETO_FIXED_PITCH\n");
            }
            if (fDrawFlags & 2)
            {
                DbgPrint(
                "\t\t\t\t\tETO_NOT_DEFAULT\n"
                );
            }
            if (fDrawFlags & ETO_GRAY)
            {
                DbgPrint("\t\t\t\t\tETO_GRAY\n");
            }
            if (fDrawFlags & ETO_DEVICE_SURFACE)
            {
                DbgPrint("\t\t\t\t\tETO_DEVICE_SURFACE\n");
            }
            DbgPrint(")\n");
            DbgPrint("---\n");
            pSurf->vDump();
            if (pSurfDevice)
                pSurfDevice->vDump();
            DbgBreakPoint();
        }
    }
#endif
    //
    // pSurfDevice is an argument given to the SrcTextCopy function
    // It must be non-zero in order to get information about the
    // device palette
    //
    if (!pSurfDevice)
    {
        pSurfDevice = pSurf;
    }

    // This is a wasted calculation for the case of a device surface
    // but what the heck, a branch costs too

    BufferAlign  = prclText->left & ((fDrawFlags & ETO_GRAY) ? ((fDrawFlags & ETO_CLEARTYPE_X) ? 3 : 7) : 31);
    BufferOffset = prclText->left - BufferAlign;


    if(!(fDrawFlags & ETO_CLEARTYPE_X))
    {

#if !defined (_X86_)

    //
    // select and jump to appropriate glyph dispatch
    // routine
    //

    pfnMasterType =
    (PFN_MASTERTEXTTYPE)MastertextTypeTabel[
        fDrawFlags & ~(ETO_DEVICE_SURFACE | ETO_CLEARTYPE_X)
    ];
    pfnMasterType(
        pGlyphPos
      , cGlyph
      , pjTempBuffer
      , BufferOffset
      , ulBufferWidthInBytes
      , ulCharInc
      , ulTempTop
      );

#else

    //
    // call x86 version for glyph copy
    //

    vFastText(
        pGlyphPos,
        cGlyph,
        pjTempBuffer + ((prclText->left >> 3) & 3),
        ulBufferWidthInBytes,
        ulCharInc,
        pSurf->pSurfobj(),
        prclText,
        prclOpaque,
        iSolidForeColor,
        iSolidBkColor,
        fDrawFlags & ~(ETO_DEVICE_SURFACE | ETO_CLEARTYPE_X),
        prclClip,
        prclExtra
    );
#endif

    }
    else // cleartype
    {
        PVOID   MastertextClearTypeTable[] = {
            draw_clrt_nf_ntb_o_to_temp_start,
            draw_clrt_f_ntb_o_to_temp_start,
        };

        pfnMasterType =
        (PFN_MASTERTEXTTYPE)MastertextClearTypeTable[fDrawFlags & 1];

        pfnMasterType(
            pGlyphPos
          , cGlyph
          , pjTempBuffer
          , BufferOffset
          , ulBufferWidthInBytes
          , ulCharInc
          , ulTempTop
          );
    }

    //
    //  draw extra rects (if any)
    //

    if (prclExtra != (PRECTL) NULL)
    {
        //
        // intersect extra rects with temp buffer, draw any
        // that intersect
        //

        VOID (*pfn)(PBYTE, ULONG, LONG, LONG, LONG, LONG);

        pfn = (fDrawFlags & ETO_GRAY) ? ((fDrawFlags & ETO_CLEARTYPE_X) ? vRectBlt8 : vRectBlt4) : vRectBlt;

        while (prclExtra->left != prclExtra->right) {

            LONG xleft, xright, ytop, ybottom;

            xleft   = max(prclExtra->left,   prclText->left)   - BufferOffset;
            xright  = min(prclExtra->right,  prclText->right)  - BufferOffset;
            ytop    = max(prclExtra->top,    prclText->top)    - prclText->top;
            ybottom = min(prclExtra->bottom, prclText->bottom) - prclText->top;

            //
            // Render the clipped 'extra' rectangle into the mono dib.
            //

            if (xleft < xright && ytop < ybottom) {
                (*pfn)(pjTempBuffer,ulBufferWidthInBytes, xleft, ytop, xright, ybottom);
            }

            prclExtra++;
        }
    }

    //
    // draw/expand 1bpp temp buffer onto target surface
    //

    ASSERTGDI(pSurf->iFormat() > 0,"Error in DIB format");
    ASSERTGDI(pSurf->iFormat() <= BMF_32BPP,"Error in DIB format");

    ULONG   iFormat = pSurf->iFormat();

#if defined (_MIPS_)

    //
    // special check for MIPS 64 bit opaque,
    // set format to 0 (use 32 bit opaque routine)
    //

    if
    (
        (iFormat == BMF_8BPP) &&
        (!Native64BitAccess)  &&
        (iSolidBkColor != 0xFFFFFFFF)
    )
    {
        iFormat = 0;
    }

#endif

    //
    // Get a pointer to the appropriate function
    //

    {
        int i = iFormat;
        ASSERTGDI(i < 8, "bad index");
        if (iSolidBkColor == -1L)
        {
            i += 8;                     // transparent background
        }

        if (ETO_GRAY & fDrawFlags)
        {
            i += 16;                    // anti-aliased text

            if (ETO_CLEARTYPE_X & fDrawFlags)
                i += 16;
        }
        pfnTextSrcCopy = SrcCopyTextFunctionTable[i];
    }

    //
    // blt each clip rectangle
    //

    for (pCurrentRect=prclClip; pCurrentRect->bottom; pCurrentRect++)
    {
        LONG Left   = max(prclText->left  , pCurrentRect->left  );
        LONG Right  = min(prclText->right , pCurrentRect->right );
        LONG Top    = max(prclText->top   , pCurrentRect->top   );
        LONG Bottom = min(prclText->bottom, pCurrentRect->bottom);
        ULONG dX    = (ULONG) (Left - prclText->left);
        ULONG dY    = (ULONG) (Top  - prclText->top );

        if (fDrawFlags & ETO_DEVICE_SURFACE)
        {
            // Left = position of first pixel relative to the left
            //        hand edge of the temporary 4bpp buffer

            Left   -= BufferOffset;
            Right  -= BufferOffset;
            Top    -= prclText->top;
            Bottom -= prclText->top;

#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "*pCurrentRect = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    "*prclText     = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    " intersection = 0x%lx 0x%lx 0x%lx 0x%lx\n"
                    " BuffOffset BuffAlign = 0x%lx 0x%lx    \n"
                    " dX dY        = 0x%lx 0x%lx            \n"
                ,   pCurrentRect->left
                ,   pCurrentRect->top
                ,   pCurrentRect->right
                ,   pCurrentRect->bottom
                ,   prclText->left
                ,   prclText->top
                ,   prclText->right
                ,   prclText->bottom
                ,   Left
                ,   Top
                ,   Right
                ,   Bottom
                ,   BufferOffset, BufferAlign
                ,   dX,dY
                );
            }
#endif

        }
        else
        {
            //
            // Synchronize with the driver
            //

            PDEVOBJ po(pSurf->hdev());
            po.vSync(pSurf->pSurfobj(), NULL, 0);
        }

        if ((Left < Right) && (Top < Bottom))
        {
            if (iSolidForeColor == 0xffffffff)
            {
                //
                // Our (*pfnTextSrcCopy) routines can only expand solid
                // colors, so if the foreground color is a dither we fall
                // back to our slower MaskBlt support.  We set the mask
                // to the monochrome text bitmap and do a masked PatBlt
                // using the dithered brush.
                //
                // Note that we've already laid down the opaquing rectangle,
                // so this is now effectively a "transparent" textout
                // operation.
                //

                ASSERTGDI(!(fDrawFlags & ETO_GRAY),
                    "Can't do dithered anti-aliased text");

                RECTL   rclDst;
                SURFACE surfMask;
                POINTL  ptlMask;

                rclDst.left   = Left;
                rclDst.top    = Top;
                rclDst.right  = Right;
                rclDst.bottom = Bottom;

                surfMask.iFormat(BMF_1BPP);
                surfMask.iType(STYPE_BITMAP);
                surfMask.pvScan0(pjTempBuffer);
                surfMask.lDelta(ulBufferWidthInBytes);
                surfMask.sizl().cx = 8 * ulBufferWidthInBytes;
                surfMask.sizl().cy = prclText->bottom - prclText->top;

                ptlMask.x = dX + BufferAlign;
                ptlMask.y = dY;

                BltLnk(pSurf,
                       NULL,
                       &surfMask,
                       NULL,
                       NULL,
                       &rclDst,
                       NULL,
                       &ptlMask,
                       pboFore,
                       pptlOrg,
                       0xaaf0);
            }
            else
            {
                // The brush is a solid color, so use our optimized monochrome
                // solid color expansion routines.

                ASSERTGDI(pSurf->pvScan0(), "EngTextOut: pvScan0 == NULL\n");

                (*pfnTextSrcCopy)(
                    (PBYTE)pjTempBuffer + dY * ulBufferWidthInBytes,
                    BufferAlign + dX,
                    ulBufferWidthInBytes,
                    (PBYTE)pSurf->pvScan0() + Top * pSurf->lDelta(),
                    Left,
                    Right,
                    pSurf->lDelta(),
                    Bottom - Top,
                    iSolidForeColor,
                    iSolidBkColor,
                    pSurfDevice
                );
            }
        }
    }

    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D1
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*    pSurf      - not used
*
* Return Value:
*
*   None
*
\**************************************************************************/



#if !defined (_X86_)


VOID
vSrcTranCopyS1D1(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{

    //
    // DWORD version
    //
    // if uF == 1 then  Dst |= Src
    //
    // if uF == 0 then  Dst &= ~Src
    //
    //

    LONG    cx = DstRight - DstLeft;

    LONG    lStartCase = SrcLeft;
    LONG    lEndCase   = SrcLeft + cx;
    ULONG   uStartMask = (ULONG)~0;
    ULONG   uEndMask   = (ULONG)~0;
    LONG    lEndOffset;
    LONG    lSrcStride = DeltaSrcIn;
    LONG    lDstStride = DeltaDstIn;

    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjSrcEnd;
    PBYTE   pjSrcEndY;

    lStartCase  = lStartCase & 0x1F;
    lEndCase    = lEndCase   & 0x1F;

    //
    // big endian masks
    //

    if (lStartCase) {
        uStartMask  >>= lStartCase;

        //
        // convert to little
        //                                      // 0 1 2 3

        ULONG u0 = uStartMask << 24;             // 3 - - -
        ULONG u1 = uStartMask >> 24;             // - - - 0
        ULONG u2 = (uStartMask >> 8) & 0xFF00;   // - - 1 -
        uStartMask = (uStartMask & 0xFF00) << 8;  // - 2 - -

        uStartMask |= u0 | u1 | u2;

    }

    if (lEndCase) {

        uEndMask    <<= (32 - lEndCase);

        //
        // convert to little
        //                                      // 0 1 2 3

        ULONG u0 = uEndMask << 24;               // 3 - - -
        ULONG u1 = uEndMask >> 24;               // - - - 0
        ULONG u2 = (uEndMask >> 8) & 0xFF00;     // - - 1 -
        uEndMask = (uEndMask & 0xFF00) << 8;      // - 2 - -

        uEndMask |= u0 | u1 | u2;
    }

    //
    // calc starting and ending addresses (DWORD aligned)
    //

    pjDst     = pjDstIn + ((DstLeft >> 5) << 2);
    pjSrc     = pjSrcIn + ((SrcLeft >> 5) << 2);
    pjSrcEnd  = pjSrcIn + (((SrcLeft+cx) >> 5) << 2);

    // Sundown safe truncation
    lEndOffset = (ULONG)((ULONG_PTR)pjSrcEnd - (ULONG_PTR)pjSrc);

    pjSrcEndY = pjSrc + cy * lSrcStride;

    if (uF) {

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst |= *(PULONG)pjSrc & uStartMask;
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst |= *(PULONG)pjSrc;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst |= *(PULONG)pjSrc & uEndMask;
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst |= *(PULONG)pjSrc & uStartMask;

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    } else {

        //
        // uF == 0,   Dst &= ~Src
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc);
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst &= ~(*(PULONG)pjSrc & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }
    }
}

#endif




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D4
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID vSrcTranCopyS1D4(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    //
    // Warning, noot optimized. It is not expected that 4 bit text
    // will be handled by the negine
    //

    LONG    cx = DstRight - DstLeft;
    BYTE    jF = (BYTE)uF;
    BYTE    jB = (BYTE)uB;
    BYTE    TextExpMask[4] = {0x00,0x0f,0xf0,0xff};

    //
    // build byte of replicate foreground
    //

    BYTE    Accum      = jF | (jF << 4);
    LONG    SrcRight   = SrcLeft + cx;
    LONG    lStartCase = SrcLeft  & 0x07;
    LONG    lEndCase   = SrcRight & 0x07;
    PBYTE   pjSrc      = pjSrcIn + ((SrcLeft + 7) >> 3);
    PBYTE   pjSrcEndY  = pjSrc + cy * DeltaSrcIn;
    PBYTE   pjSrcEnd;
    LONG    lSrcStartOffset = (8 - lStartCase);
    LONG    lSrcStride;


    PBYTE   pjDst;
    LONG    lDstStride;

    BYTE    jSrc;
    BYTE    Mask;


    if (lStartCase == 0) {
        lSrcStartOffset = 0;
    }

    cx = cx - lSrcStartOffset - (SrcRight & 0x07);

    if (cx > 0) {

        lDstStride = DeltaDstIn - (cx >> 1);
        lSrcStride = DeltaSrcIn - (cx >> 3);

        pjDst = pjDstIn + ((DstLeft + lSrcStartOffset) >> 1);

        do {

            pjSrcEnd = pjSrc + (cx >> 3);

            //
            // aligned middle
            //

            do {

                jSrc = *pjSrc;

                Mask = TextExpMask[(jSrc & 0xC0) >> 6];

                *pjDst = (*pjDst & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x30) >> 4];

                *(pjDst+1) = (*(pjDst+1) & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x0C) >> 2];

                *(pjDst+2) = (*(pjDst+2) & ~Mask ) | (Accum & Mask);

                Mask = TextExpMask[(jSrc & 0x03)     ];

                *(pjDst+3) = (*(pjDst+3) & ~Mask ) | (Accum & Mask);

                pjDst += 4;
                pjSrc ++;

            } while (pjSrc != pjSrcEnd);

            pjDst += lDstStride;
            pjSrc += lSrcStride;

        } while (pjSrc != pjSrcEndY);

    }


    //
    // start case
    //

    if (lStartCase) {

        //
        // check for start and stop in same src byte
        //

        BOOL  bSameByte = ((SrcLeft) & ~0x07) ==  ((SrcRight) & ~0x07);

        if (bSameByte) {

            //
            // start and stop in same src byte
            //

            PBYTE pjDstEnd2;
            PBYTE pjDstScan  = pjDstIn + ((DstLeft >> 1));
            LONG  lTextWidth = lEndCase - lStartCase;

            //
            // check for bad width
            //

            if (lTextWidth <= 0) {
                return;
            }

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;

            do {

                pjDst   = pjDstScan;
                jSrc    = *pjSrc << lStartCase;
                LONG    ix = lTextWidth;

                //
                // partial nibble on left edge
                //

                if (lStartCase & 0x01) {

                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0xF0) | (Accum & 0x0F);
                    }

                    jSrc <<= 1;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix >= 2) {

                    Mask     = TextExpMask[(jSrc & 0xc0) >> 6];
                    *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);
                    jSrc<<=2;
                    ix -= 2;
                    pjDst++;

                }

                //
                // last nibble on right edge
                //

                if (ix & 0x01) {
                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0x0F) | (Accum & 0xF0);
                    }
                }

                pjSrc     += DeltaSrcIn;
                pjDstScan += DeltaDstIn;

            } while (pjSrc != pjSrcEndY);

            //
            // make sure end case doesn't run
            //

            lEndCase = 0;

        } else {

            //
            // start case
            //

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjDst           = pjDstIn + ((DstLeft >> 1));
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
            LONG lDstStride = DeltaDstIn - ((9 - lStartCase) >> 1);

            do {

                jSrc    = *pjSrc << lStartCase;
                LONG ix = 8 - lStartCase;

                //
                // partial
                //

                if (ix & 0x01) {

                    if (jSrc & 0x80) {
                        *pjDst = (*pjDst & 0xF0) | (Accum & 0x0F);
                    }

                    jSrc <<= 1;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix != 0) {

                    Mask     = TextExpMask[(jSrc & 0xc0) >> 6];
                    *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);
                    jSrc<<=2;
                    ix-=2;
                    pjDst++;

                }

                pjSrc += DeltaSrcIn;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    }

    //
    // end case
    //

    if (lEndCase) {

        pjSrc           = pjSrcIn + (SrcRight >> 3);
        pjDst           = pjDstIn + ((DstRight - lEndCase) >> 1);
        pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
        LONG lDstStride = DeltaDstIn - ((lEndCase + 1) >> 1);

        do {

            jSrc = *pjSrc;

            LONG ix = lEndCase;

            //
            // bytes
            //

            while (ix >= 2) {

                Mask = TextExpMask[(jSrc & 0xC0) >> 6];

                *(pjDst) = (*(pjDst) & ~Mask ) | (Accum & Mask);

                jSrc <<= 2;
                ix   -=  2;
                pjDst ++;

            }

            //
            // last partial
            //

            if (ix) {

                if (jSrc & 0x80) {
                    *pjDst = (*pjDst & 0x0F) | (Accum & 0xF0);
                }

                pjDst++;

            }

            pjSrc += DeltaSrcIn;
            pjDst += lDstStride;

        } while (pjSrc != pjSrcEndY);
    }
}

#if !defined(_MIPS_)


const ULONG TranTable [] =
                         {
                           0x00000000,
                           0xff000000,
                           0x00ff0000,
                           0xffff0000,
                           0x0000ff00,
                           0xff00ff00,
                           0x00ffff00,
                           0xffffff00,
                           0x000000ff,
                           0xff0000ff,
                           0x00ff00ff,
                           0xffff00ff,
                           0x0000ffff,
                           0xff00ffff,
                           0x00ffffff,
                           0xffffffff
                         };


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D8
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
vSrcTranCopyS1D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    //
    // start at 8-byte aligned left edge
    //


    ULONG   uExpand      = uF | (uF << 8);
    ULONG   LeftAln      = (DstLeft   & ~0x07);
    ULONG   LeftEdgeMask = 0xFF >> (DstLeft & 0x07);
    ULONG   RightAln     = (DstRight  & ~0x07);
    ULONG   EndOffset    = RightAln - LeftAln;
    LONG    DeltaDst;
    LONG    DeltaSrc;
    PBYTE   pjDstEndY;
    PBYTE   pjSrc;
    PBYTE   pjDst;

    uExpand = uExpand | (uExpand << 16);

    //
    // calc addresses and strides
    //

    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + (SrcLeft >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    //
    // make sure at least 1 QWORD needs copied
    //

    if (RightAln != LeftAln) {

        do {

            PBYTE pjDstEnd   = pjDst + EndOffset;

            //
            // and first src byte to cover left edge
            //

            BYTE c0 = *pjSrc & (BYTE)LeftEdgeMask;

            if (c0 != 0) {

                ULONG MaskLow = TranTable[c0 >> 4];
                ULONG MaskHi  = TranTable[c0 & 0x0F];
                ULONG d0      = *(PULONG)pjDst;
                ULONG d1      = *(PULONG)(pjDst + 4);

                d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                *(PULONG)pjDst       = d0;
                *(PULONG)(pjDst + 4) = d1;
            }

            pjSrc ++;
            pjDst += 8;

            while (pjDst != pjDstEnd) {

                c0 = *pjSrc;

                if (c0 != 0) {

                    ULONG MaskLow = TranTable[c0 >> 4];
                    ULONG MaskHi  = TranTable[c0 & 0x0F];
                    ULONG d0      = *(PULONG)pjDst;
                    ULONG d1      = *(PULONG)(pjDst + 4);

                    d0 = (d0 & ~MaskLow) | (uExpand & MaskLow);
                    d1 = (d1 & ~MaskHi)  | (uExpand & MaskHi);

                    *(PULONG)pjDst       = d0;
                    *(PULONG)(pjDst + 4) = d1;
                }

                pjSrc ++;
                pjDst += 8;

            };

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;

        } while (pjDst != pjDstEndY);
    }

    RightAln = DstRight & 0x07;

    if (RightAln) {

        BYTE  jSrc;
        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight) & ~0x07);

        //
        // if left and right edges are in same qword handle with masked
        // read-modify-write
        //

        if (bSameQWord) {

            LeftAln = DstLeft & 0x07;

            LONG  xCount = RightAln - LeftAln;

            //
            // assert ic xCount < 0
            //

            if (xCount <= 0) {
                return;
            }

            LONG  lDeltaDst = DeltaDstIn - xCount;

            PBYTE pjDstEnd;

            pjDst     = pjDstIn + DstLeft;
            pjDstEndY = pjDst + cy * DeltaDstIn;
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            //
            // expand, one src byte is all that's required
            //

            do {

                //
                // load src and shift into place
                //

                jSrc = *pjSrc;
                jSrc <<= LeftAln;

                pjDstEnd  = pjDst + xCount;

                do {

                    if (jSrc & 0x80) {
                        *pjDst = (BYTE)uF;
                    }

                    jSrc <<=1;
                    pjDst++;

                } while (pjDst != pjDstEnd);

                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;

        } else {

            ULONG ul0,ul1;
            BYTE  jSrc;
            LONG  lDeltaDst = DeltaDstIn - RightAln;
            PBYTE pjDstEnd;

            pjDst               = pjDstIn + (DstRight & ~0x07);
            pjDstEndY           = pjDst + cy * DeltaDstIn;
            pjSrc               = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

            do {

                //
                // read src
                //

                jSrc = *pjSrc;

                if (jSrc != 0) {

                    pjDstEnd = pjDst + RightAln;

                    do {
                        if (jSrc & 0x80) {
                            *pjDst = (BYTE)uF;
                        }
                        jSrc <<=1;
                        pjDst++;
                    } while (pjDst != pjDstEnd);

                } else {

                    //
                    // short cut for zero
                    //

                    pjDst += RightAln;

                }


                pjDst += lDeltaDst;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

        }
    }
}

#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D16
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
vSrcTranCopyS1D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PUSHORT pusEnd;
    PUSHORT pusEnd8;
    PUSHORT pusDst     = (PUSHORT)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 1);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PUSHORT pusEndY    = (PUSHORT)((PBYTE)pusDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    do {

        pusEnd = pusDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PUSHORT pusEndSt = pusDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pusDst = (USHORT)uF;
                }

                pusDst++;
                jSrc <<=1;

            } while (pusDst != pusEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pusEnd8 = (PUSHORT)((PBYTE)pusDst + (((ULONG_PTR)pusEnd - (ULONG_PTR)pusDst) & ~0x0F));

        //
        // expand full bytes
        //

        while (pusDst != pusEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pusDst+0) = (USHORT)uF;
            }
            if (jSrc & 0x40) {
                *(pusDst+1) = (USHORT)uF;
            }
            if (jSrc & 0x20) {
                *(pusDst+2) = (USHORT)uF;
            }
            if (jSrc & 0x10) {
                *(pusDst+3) = (USHORT)uF;
            }
            if (jSrc & 0x08) {
                *(pusDst+4) = (USHORT)uF;
            }
            if (jSrc & 0x04) {
                *(pusDst+5) = (USHORT)uF;
            }
            if (jSrc & 0x02) {
                *(pusDst+6) = (USHORT)uF;
            }
            if (jSrc & 0x01) {
                *(pusDst+7) = (USHORT)uF;
            }


            pjSrc++;
            pusDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pusDst != pusEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *pusDst = (USHORT)uF;
                }
                jSrc<<=1;
                pusDst++;
            } while (pusDst != pusEnd);

        }

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pusDst != pusEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D24
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcTranCopyS1D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    BYTE    jF0         = (BYTE)uF;
    BYTE    jF1         = (BYTE)(uF >> 8);
    BYTE    jF2         = (BYTE)(uF >> 16);
    LONG    ixStart     = SrcLeft & 0x07;
    PBYTE   pjEnd;
    PBYTE   pjEnd8;
    PBYTE   pjDst       = (PBYTE)pjDstIn + 3 * DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn -  3* cx;
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PBYTE   pjEndY      = (PBYTE)((PBYTE)pjDst + DeltaDstIn * cy);
    LONG    StartOffset = 3 * min(cx, (8 - ixStart));

    do {

        pjEnd = pjDst + 3 * cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PBYTE pjEndSt = pjDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pjDst     = jF0;
                    *(pjDst+1) = jF1;
                    *(pjDst+2) = jF2;
                }

                pjDst += 3;
                jSrc <<=1;

            } while (pjDst != pjEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pjEnd8 = (PBYTE)((PBYTE)pjDst + ( 24 * (((ULONG_PTR)(pjEnd - pjDst))/24)));

        //
        // expand full bytes
        //

        while (pjDst != pjEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pjDst+0) = jF0;
                *(pjDst+1) = jF1;
                *(pjDst+2) = jF2;
            }
            if (jSrc & 0x40) {
                *(pjDst+3) = jF0;
                *(pjDst+4) = jF1;
                *(pjDst+5) = jF2;
            }
            if (jSrc & 0x20) {
                *(pjDst+6) = jF0;
                *(pjDst+7) = jF1;
                *(pjDst+8) = jF2;
            }
            if (jSrc & 0x10) {
                *(pjDst+9) = jF0;
                *(pjDst+10) = jF1;
                *(pjDst+11) = jF2;
            }
            if (jSrc & 0x08) {
                *(pjDst+12) = jF0;
                *(pjDst+13) = jF1;
                *(pjDst+14) = jF2;
            }
            if (jSrc & 0x04) {
                *(pjDst+15) = jF0;
                *(pjDst+16) = jF1;
                *(pjDst+17) = jF2;
            }
            if (jSrc & 0x02) {
                *(pjDst+18) = jF0;
                *(pjDst+19) = jF1;
                *(pjDst+20) = jF2;
            }
            if (jSrc & 0x01) {
                *(pjDst+21) = jF0;
                *(pjDst+22) = jF1;
                *(pjDst+23) = jF2;
            }


            pjSrc++;
            pjDst += 3*8;

        }

        //
        // finish off scan line if needed
        //

        if (pjDst != pjEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *(pjDst+0) = jF0;
                    *(pjDst+1) = jF1;
                    *(pjDst+2) = jF2;
                }
                jSrc <<= 1;
                pjDst += 3;
            } while (pjDst != pjEnd);

        }

        pjDst = (PBYTE)((PBYTE)pjDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pjDst != pjEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcTranCopyS1D32
*
* Routine Description:
*
*   Transparent blt of 1BPP src to all destination format
*   src bits that are "1" are copied to the dest as foreground color,
*   src bits that are "0" are not copied
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcTranCopyS1D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PULONG  pulEnd;
    PULONG  pulEnd8;
    PULONG  pulDst     = (PULONG)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 2);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    PULONG  pulEndY    = (PULONG)((PBYTE)pulDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    do {

        pulEnd = pulDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PULONG pulEndSt = pulDst + StartOffset;

            do {

                if (jSrc & 0x80) {
                    *pulDst = uF;
                }

                pulDst++;
                jSrc <<=1;

            } while (pulDst != pulEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pulEnd8 = (PULONG)((PBYTE)pulDst + (((ULONG_PTR)pulEnd - (ULONG_PTR)pulDst) & ~0x1F));

        //
        // expand full bytes
        //

        while (pulDst != pulEnd8) {

            jSrc = *pjSrc;

            if (jSrc & 0x80) {
                *(pulDst+0) = uF;
            }
            if (jSrc & 0x40) {
                *(pulDst+1) = uF;
            }
            if (jSrc & 0x20) {
                *(pulDst+2) = uF;
            }
            if (jSrc & 0x10) {
                *(pulDst+3) = uF;
            }
            if (jSrc & 0x08) {
                *(pulDst+4) = uF;
            }
            if (jSrc & 0x04) {
                *(pulDst+5) = uF;
            }
            if (jSrc & 0x02) {
                *(pulDst+6) = uF;
            }
            if (jSrc & 0x01) {
                *(pulDst+7) = uF;
            }


            pjSrc++;
            pulDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pulDst != pulEnd) {

            jSrc = *pjSrc++;

            do {
                if (jSrc & 0x80) {
                    *pulDst = uF;
                }
                jSrc<<=1;
                pulDst++;
            } while (pulDst != pulEnd);

        }

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pulDst != pulEndY);

}




/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D1
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/



#if !defined (_X86_)

VOID
vSrcOpaqCopyS1D1(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{

    //
    // DWORD version
    //
    //
    //  build and and xor mask
    //
    //  and mask is set to 0x00 if uF == uB, so that
    //  this routine acts like a solid fill. (although src is not needed!)
    //
    //  The xor mask is set to 0xFF if inversion is needed:
    //      either uF == uB == 1, for solid fill 1s or
    //      uF = 0, uB = 1 for inverted text
    //

    uF      &= 1;
    uB      &= 1;

    LONG    cx = DstRight - DstLeft;

    LONG    lStartCase = SrcLeft;
    LONG    lEndCase   = SrcLeft + cx;
    ULONG   uStartMask = (ULONG)~0;
    ULONG   uEndMask   = (ULONG)~0;
    LONG    lEndOffset;
    LONG    lSrcStride = DeltaSrcIn;
    LONG    lDstStride = DeltaDstIn;

    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjSrcEnd;
    PBYTE   pjSrcEndY;

    lStartCase  = lStartCase & 0x1F;
    lEndCase    = lEndCase   & 0x1F;

    //
    // big endian masks
    //

    if (lStartCase) {
        uStartMask  >>= lStartCase;

        //
        // convert to little
        //                                       // 0 1 2 3

        ULONG u0 = uStartMask << 24;             // 3 - - -
        ULONG u1 = uStartMask >> 24;             // - - - 0
        ULONG u2 = (uStartMask >> 8) & 0xFF00;   // - - 1 -
        uStartMask = (uStartMask & 0xFF00) << 8; // - 2 - -

        uStartMask |= u0 | u1 | u2;

    }

    if (lEndCase) {

        uEndMask    <<= (32 - lEndCase);

        //
        // convert to little
        //                                       // 0 1 2 3

        ULONG u0 = uEndMask << 24;               // 3 - - -
        ULONG u1 = uEndMask >> 24;               // - - - 0
        ULONG u2 = (uEndMask >> 8) & 0xFF00;     // - - 1 -
        uEndMask = (uEndMask & 0xFF00) << 8;     // - 2 - -

        uEndMask |= u0 | u1 | u2;
    }

    //
    // calc starting and ending full dword addresses (DWORD aligned)
    //

    pjDst     = pjDstIn + (((DstLeft) >> 3) & ~0x03);
    pjSrc     = pjSrcIn + (((SrcLeft) >> 3) & ~0x03);
    pjSrcEnd  = pjSrcIn + (((SrcLeft+cx) >> 3) & ~0x03);

    //Sundown safe truncation
    lEndOffset = (ULONG)((ULONG_PTR)pjSrcEnd - (ULONG_PTR)pjSrc);

    pjSrcEndY = pjSrc + cy * lSrcStride;

    //
    // special case uF = 1 and uB = 0
    //

    if (uF && !uB) {

        //
        // special case direct copy
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (*(PULONG)pjSrc & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = *(PULONG)pjSrc;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (*(PULONG)pjSrc & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (*(PULONG)pjSrc & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    //
    //  special case uF = 0 and uB = 1  (invert)
    //

    } else if (!uF && uB) {

        //
        // dst = ~Src
        //

        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (~(*(PULONG)pjSrc) & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = ~(*(PULONG)pjSrc);
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (~(*(PULONG)pjSrc) & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (~(*(PULONG)pjSrc) & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }


    } else {

        ULONG   AndMask = (uF == uB) ? 0x00 : 0xFF;
                AndMask |= AndMask << 8;
                AndMask |= AndMask << 16;

        ULONG   XorMask = (uB == 1)  ? 0xFF : 0x00;
                XorMask |= XorMask << 8;
                XorMask |= XorMask << 16;



        if (pjSrc != pjSrcEnd) {

            //
            // start and stop are not in same byte
            //

            lDstStride -= lEndOffset;
            lSrcStride -= lEndOffset;

            do {

                pjSrcEnd = pjSrc + lEndOffset;

                if (lStartCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uStartMask);
                    pjDst+=4;
                    pjSrc+=4;
                }

                while (pjSrc != pjSrcEnd) {

                    *(PULONG)pjDst = *(PULONG)pjSrc & AndMask ^ XorMask;
                    pjSrc +=4;
                    pjDst +=4;

                }

                if (lEndCase) {
                    *(PULONG)pjDst = (*(PULONG)pjDst & ~uEndMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uEndMask);
                }

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);

        } else {

            //
            // start and stop are in same byte
            //

            uStartMask &= uEndMask;

            do {

                *(PULONG)pjDst = (*(PULONG)pjDst & ~uStartMask) | (((*(PULONG)pjSrc & AndMask) ^ XorMask) & uStartMask);

                pjSrc += lSrcStride;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }

    }
}

#endif



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D4
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID vSrcOpaqCopyS1D4(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{

    //
    // Warning, this 4bit code is not optimized, it is not expected that
    // we will draw many 4bpp engine bitmaps.
    //

    //
    // check for quick out?
    //

    BYTE    jF = (BYTE)uF;
    BYTE    jB = (BYTE)uB;
    BYTE    TextExpTable[4];
    LONG    cx = DstRight - DstLeft;

    //
    // build small table
    //

    BYTE    Accum = jB | (jB << 4);

    TextExpTable[0] = Accum;                // 0 0
    Accum <<= 4;
    Accum |= jF;
    TextExpTable[1] = Accum;                // 0 1
    Accum <<= 4;
    Accum |= jF;
    TextExpTable[3] = Accum;                // 1 1
    Accum <<= 4;
    Accum |= jB;
    TextExpTable[2] = Accum;                // 1 0

    LONG    lStartCase    = SrcLeft & 0x07;
    LONG    SrcRight      = SrcLeft+cx;
    LONG    lEndCase      = SrcRight & 0x07;
    PBYTE   pjSrc         = pjSrcIn + ((SrcLeft + 7) >> 3);
    PBYTE   pjSrcEndY     = pjSrc + cy * DeltaSrcIn;
    PBYTE   pjSrcEnd;
    LONG    lSrcStartOffset = (8 - lStartCase);
    LONG    lSrcStride;
    PBYTE   pjDst;
    LONG    lDstStride;
    BYTE    jSrc;

    if (lStartCase == 0) {
        lSrcStartOffset = 0;
    }

    cx = cx - lSrcStartOffset - lEndCase;

    if (cx > 0) {

        lDstStride = DeltaDstIn - (cx >> 1);
        lSrcStride = DeltaSrcIn - (cx >> 3);

        pjDst = pjDstIn + ((DstLeft + lSrcStartOffset) >> 1);

        do {

            pjSrcEnd = pjSrc + (cx >> 3);

            //
            // aligned middle
            //

            do {

                jSrc = *pjSrc;

                *pjDst     = TextExpTable[(jSrc & 0xC0) >> 6];
                *(pjDst+1) = TextExpTable[(jSrc & 0x30) >> 4];
                *(pjDst+2) = TextExpTable[(jSrc & 0x0C) >> 2];
                *(pjDst+3) = TextExpTable[ jSrc & 0x03 ];

                pjDst += 4;
                pjSrc ++;

            } while (pjSrc != pjSrcEnd);

            pjDst += lDstStride;
            pjSrc += lSrcStride;

        } while (pjSrc != pjSrcEndY);

    }

    //
    // start case
    //

    if (lStartCase) {

        //
        // are start and stop in same src byte
        //

        BOOL  bSameByte = ((SrcLeft) & ~0x07) ==  ((SrcRight) & ~0x07);

        if (bSameByte) {

            //
            // start and stop in same byte
            //

            PBYTE pjDstScan = pjDstIn + ((DstLeft >> 1));
            PBYTE pjDstEnd2;
            LONG  lTextWidth = lEndCase - lStartCase;

            //
            // check for bad width
            //

            if (lTextWidth <= 0) {
                return;
            }

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;

            do {

                pjDst   = pjDstScan;
                jSrc    = *pjSrc << (lStartCase & ~0x01);
                LONG ix = lTextWidth;

                //
                // starting odd nibble
                //

                if (lStartCase & 0x01) {
                    *pjDst     = (*pjDst & 0xF0) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0x0F);
                    jSrc <<= 2;
                    pjDst++;
                    ix--;
                }

                //
                // full byte nibble pairs
                //

                while (ix >= 2) {
                    *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];
                    jSrc<<=2;
                    pjDst++;
                    ix -= 2;
                }

                //
                // last nibble
                //

                if (ix) {
                    *(pjDst) = (*(pjDst) & 0x0F) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0xF0);
                }

                pjSrc     += DeltaSrcIn;
                pjDstScan += DeltaDstIn;

            } while (pjSrc != pjSrcEndY);

            //
            // make sure end case doesn't run
            //

            lEndCase = 0;

        } else {

            pjSrc           = pjSrcIn + (SrcLeft >> 3);
            pjDst           = pjDstIn + ((DstLeft >> 1));
            pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
            LONG lDstStride = DeltaDstIn - ((9 - lStartCase) >> 1); // ((8 - lStartCase) + 1) / 2

            do {

                jSrc    = *pjSrc << (lStartCase & ~0x01);
                LONG ix = 8 - lStartCase;

                //
                // partial
                //

                if (ix & 0x01) {

                    *pjDst     = (*pjDst & 0xF0) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0x0F);

                    jSrc <<= 2;
                    pjDst++;
                    ix--;
                }

                //
                // bytes
                //

                while (ix != 0) {

                    *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];
                    jSrc<<=2;
                    ix-=2;
                    pjDst++;
                }

                pjSrc += DeltaSrcIn;
                pjDst += lDstStride;

            } while (pjSrc != pjSrcEndY);
        }
    }

    //
    // end case
    //

    if (lEndCase) {

        pjSrc           = pjSrcIn + (SrcRight >> 3);
        pjDst           = pjDstIn + ((DstRight - lEndCase) >> 1);
        pjSrcEndY       = pjSrc + cy * DeltaSrcIn;
        LONG lDstStride = DeltaDstIn - ((lEndCase + 1) >> 1);

        do {

            jSrc = *pjSrc;

            LONG ix = lEndCase;

            //
            // bytes
            //

            while (ix >= 2) {

                *(pjDst) = TextExpTable[(jSrc & 0xC0) >> 6];

                jSrc <<= 2;
                ix   -=  2;
                pjDst ++;

            }

            //
            // last partial
            //

            if (ix) {


                *(pjDst) = (*(pjDst) & 0x0F) | (TextExpTable[(jSrc & 0xc0) >> 6] & 0xF0);
                pjDst++;

            }

            pjSrc += DeltaSrcIn;
            pjDst += lDstStride;

        } while (pjSrc != pjSrcEndY);
    }
}

//
// edge mask for 8 bit expansion
//

extern "C" {

ULONG gTextLeftMask[8][2] = {
		     {0xffffffff,0xffffffff},
                     {0xffffff00,0xffffffff},
                     {0xffff0000,0xffffffff},
                     {0xff000000,0xffffffff},
                     {0x00000000,0xffffffff},
                     {0x00000000,0xffffff00},
                     {0x00000000,0xffff0000},
                     {0x00000000,0xff000000}
                 };
ULONG gTextRightMask[8][2] = {
		     {0xffffffff,0xffffffff},
                     {0x000000ff,0x00000000},
                     {0x0000ffff,0x00000000},
                     {0x00ffffff,0x00000000},
                     {0xffffffff,0x00000000},
                     {0xffffffff,0x000000ff},
                     {0xffffffff,0x0000ffff},
                     {0xffffffff,0x00ffffff}
                 };
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D8
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
    //
    // Aligned portion
    //

    ULONG   LeftAln    = ((DstLeft + 7) & ~0x07);
    ULONG   RightAln   = ((DstRight)    & ~0x07);
    ULONG   EndOffset  = RightAln - LeftAln;
    ULONG   EndOffset4 = EndOffset & ~0x0F;
    ULONG   EndOffset8 = EndOffset & ~0x1F;
    LONG    DeltaDst;
    LONG    DeltaSrc;
    PBYTE   pjDstEndY;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   TextExpTable[16];

    //
    // Generate text expasion table
    //

    ULONG  Accum = uB;

    Accum = Accum | (Accum << 8);
    Accum = Accum | (Accum << 16);
    TextExpTable[0] = Accum;            // 0 0 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[8] = Accum;            // 0 0 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[4] = Accum;            // 0 0 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[10] = Accum;            // 0 1 0 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[5] = Accum;           // 1 0 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 2] = Accum;           // 0 1 0 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[ 9] = Accum;           // 1 0 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[12] = Accum;           // 0 0 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[14] = Accum;           // 0 1 1 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[15] = Accum;           // 1 1 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 7] = Accum;           // 1 1 1 0
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[11] = Accum;           // 1 1 0 1
    Accum <<= 8;
    Accum |=  uF;
    TextExpTable[13] = Accum;           // 1 0 1 1
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[06] = Accum;           // 0 1 1 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 3] = Accum;           // 1 1 0 0
    Accum <<= 8;
    Accum |=  uB;
    TextExpTable[ 1] = Accum;           // 1 0 0 0

    //
    // calc addresses and strides
    //

    pjDst     = pjDstIn + LeftAln;
    pjDstEndY = pjDst + cy * DeltaDstIn;
    pjSrc     = pjSrcIn + ((SrcLeft+7) >> 3);

    DeltaSrc  = DeltaSrcIn - (EndOffset >> 3);
    DeltaDst  = DeltaDstIn - EndOffset;

    //
    // make sure at least 1 QWORD needs copied
    //

    if (RightAln > LeftAln) {

        //
        // expand buffer
        //

        do {

            PBYTE pjDstEnd  = pjDst + EndOffset;
            PBYTE pjDstEnd4 = pjDst + EndOffset4;
            PBYTE pjDstEnd8 = pjDst + EndOffset8;

            //
            // 4 times unrolled
            //

            while (pjDst != pjDstEnd8) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);
                BYTE c2 = *(pjSrc + 2);
                BYTE c3 = *(pjSrc + 3);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                *(PULONG)(pjDst +16) = TextExpTable[c2  >>  4];
                *(PULONG)(pjDst +20) = TextExpTable[c2 & 0x0F];

                *(PULONG)(pjDst +24) = TextExpTable[c3  >>  4];
                *(PULONG)(pjDst +28) = TextExpTable[c3 & 0x0F];

                pjSrc += 4;
                pjDst += 32;
            }

            //
            // 2 times unrolled
            //

            while (pjDst != pjDstEnd4) {
                BYTE c0 = *(pjSrc + 0);
                BYTE c1 = *(pjSrc + 1);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                *(PULONG)(pjDst + 8) = TextExpTable[c1  >>  4];
                *(PULONG)(pjDst +12) = TextExpTable[c1 & 0x0F];

                pjSrc += 2;
                pjDst += 16;
            }

            //
            // 1 byte expansion loop
            //

            while (pjDst != pjDstEnd) {
                BYTE c0 = *(pjSrc + 0);

                *(PULONG)(pjDst + 0) = TextExpTable[c0  >>  4];
                *(PULONG)(pjDst + 4) = TextExpTable[c0 & 0x0F];

                pjSrc++;
                pjDst += 8;
            }

            pjDst += DeltaDst;
            pjSrc += DeltaSrc;


        } while (pjDst != pjDstEndY);
    }

    //
    // Starting alignment case: at most 1 src byte is required.
    // Start and end may occur in same Quadword.
    //
    //
    // Left                  Right
    //    0 1 2 34 5 6 7       0 1 2 34 5 6 7
    //   Ŀ     ĺĿ
    // 1  xxxxxxx   1 x       
    //   ĺĴ     ĺĴ
    // 2   xxxxxx   2 xx      
    //   ĺĴ     ĺĴ
    // 3    xxxxx   3 xxx     
    //   ĺĴ     ĺĴ
    // 4     xxxx   4 xxxx    
    //   ĺĴ     ĺĴ
    // 5      xxx   5 xxxxx   
    //   ĺĴ     ĺĴ
    // 6       xx   6 xxxxxx  
    //   ĺĴ     ĺĴ
    // 7        x   7 xxxxxxx 
    //        ĺ
    //

    LeftAln  = DstLeft & 0x07;
    RightAln = DstRight & 0x07;

    if (LeftAln) {

        BYTE  jSrc;
        BOOL  bSameDWord     = ((DstLeft) & ~0x03) ==  ((DstRight-1) & ~0x03);
        BOOL  bSameQWord     = ((DstLeft) & ~0x07) ==  ((DstRight-1) & ~0x07);
        ULONG ul0,ul1;

	ASSERTGDI (DstLeft < DstRight, "vSrcOpaqCopyS1D8: null rectangle passed in.");

        // if left and right edges are in the same dword or the same qword,
        // handle with masked read-modify-write

        if (bSameDWord) {

            ULONG Mask0;

	    Mask0     = gTextLeftMask[LeftAln & 3][0] &
			gTextRightMask[RightAln & 3][0];

            pjDst     = pjDstIn + (DstLeft & ~0x03);
	    pjDstEndY = pjDst + cy * DeltaDstIn;

            // (SrcLeft >> 3) is the number of bytes to offset by
	    // (1 BPP in the src buffer).

            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            // expand

            do {

                jSrc = *pjSrc;

		if (LeftAln < 4)
		    ul0 = TextExpTable[jSrc  >>	4];
		else
		    ul0 = TextExpTable[jSrc  & 0xf];

		*(PULONG)pjDst = (*(PULONG)pjDst & ~Mask0) | (ul0 & Mask0);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;

        } else if (bSameQWord) {

            ULONG Mask0,Mask1;

            Mask0     = gTextLeftMask[LeftAln][0] & gTextRightMask[RightAln][0];
            Mask1     = gTextLeftMask[LeftAln][1] & gTextRightMask[RightAln][1];

            pjDst     = pjDstIn + (DstLeft & ~0x07);
            pjDstEndY = pjDst + cy * DeltaDstIn;
            // (SrcLeft >> 3) is the number of bytes to offset by
            // (1 BPP in the src buffer).
            pjSrc     = pjSrcIn + (SrcLeft >> 3);

            //
            // expand
            //

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)   = (*(PULONG)(pjDst)   & ~Mask0) | (ul0 & Mask0);
                *(PULONG)(pjDst+4) = (*(PULONG)(pjDst+4) & ~Mask1) | (ul1 & Mask1);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            return;
        }

        //
        // Left edge only, handle with special write-only loops
        //

        pjDst     = pjDstIn + (DstLeft & ~0x07);
        pjDstEndY = pjDst + cy * DeltaDstIn;
        pjSrc     = pjSrcIn + (SrcLeft >> 3);

        switch (LeftAln) {

        case 1:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+1)            = (BYTE)(ul0 >> 8);
                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 2:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PUSHORT)(pjDst+2)) = (USHORT)(ul0 >> 16);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 3:

            do {

                jSrc = *pjSrc;
                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+3)            = (BYTE)(ul0 >> 24);
                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 4:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PULONG)(pjDst+4))  = ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 5:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+5)            = (BYTE)(ul1 >> 8);
                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 6:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *((PUSHORT)(pjDst+6)) = (USHORT)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;

        case 7:

            do {

                jSrc = *pjSrc;
                ul1 = TextExpTable[jSrc & 0x0F];

                *(pjDst+7) = (BYTE)(ul1 >> 24);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);

            break;
        }
    }

    //
    // handle right edge only, use special write-only loops for each case
    //

    if (RightAln) {

        ULONG ul0,ul1;
        BYTE  jSrc;

        pjDst               = pjDstIn + (DstRight & ~0x07);
        pjDstEndY           = pjDst + cy * DeltaDstIn;
        pjSrc               = pjSrcIn + ((SrcLeft + (DstRight - DstLeft)) >> 3);

        //
        // select right case
        //

        switch (RightAln) {
        case 1:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(pjDst) = (BYTE)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 2:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PUSHORT)(pjDst) = (USHORT)ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 3:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PUSHORT)(pjDst) = (USHORT)ul0;
                *(pjDst+2)        = (BYTE)(ul0 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 4:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];

                *(PULONG)(pjDst) = ul0;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 5:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst) = ul0;
                *(pjDst+4)       = (BYTE)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 6:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;

        case 7:

            do {

                jSrc = *pjSrc;

                ul0 = TextExpTable[jSrc  >>  4];
                ul1 = TextExpTable[jSrc & 0x0F];

                *(PULONG)(pjDst)    = ul0;
                *(PUSHORT)(pjDst+4) = (USHORT)ul1;
                *(pjDst+6)          = (BYTE)(ul1 >> 16);

                pjDst += DeltaDstIn;
                pjSrc += DeltaSrcIn;

            } while (pjDst != pjDstEndY);
            break;
        }
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D16
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    LONG    ixStart     = SrcLeft & 0x07;
    PUSHORT pusEnd;
    PUSHORT pusEnd8;
    PUSHORT pusDst      = (PUSHORT)pjDstIn + DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn - (cx << 1);
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[4];
    PUSHORT pusEndY     = (PUSHORT)((PBYTE)pusDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    //
    // build exp table
    //

    *(PUSHORT)ExpTable     = (USHORT)uB;
    *(PUSHORT)(ExpTable+2) = (USHORT)uF;

    do {

        pusEnd = pusDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PUSHORT pusEndSt = pusDst + StartOffset;

            do {
                *pusDst = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
                pusDst++;
                jSrc <<=1;

            } while (pusDst != pusEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pusEnd8 = (PUSHORT)((PBYTE)pusDst + (((ULONG_PTR)pusEnd - (ULONG_PTR)pusDst) & ~0x0F));

        //
        // expand full bytes
        //

        while (pusDst != pusEnd8) {

            jSrc = *pjSrc;

            *(pusDst + 0) = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
            *(pusDst + 1) = *(PUSHORT)(ExpTable + ((jSrc & 0x40) >> (6-1)));
            *(pusDst + 2) = *(PUSHORT)(ExpTable + ((jSrc & 0x20) >> (5-1)));
            *(pusDst + 3) = *(PUSHORT)(ExpTable + ((jSrc & 0x10) >> (4-1)));
            *(pusDst + 4) = *(PUSHORT)(ExpTable + ((jSrc & 0x08) >> (3-1)));
            *(pusDst + 5) = *(PUSHORT)(ExpTable + ((jSrc & 0x04) >> (2-1)));
            *(pusDst + 6) = *(PUSHORT)(ExpTable + ((jSrc & 0x02) >> (1-1)));
            *(pusDst + 7) = *(PUSHORT)(ExpTable + ((jSrc & 0x01) << 1));

            pjSrc++;
            pusDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pusDst != pusEnd) {

            jSrc = *pjSrc++;

            do {
                *pusDst = *(PUSHORT)(ExpTable + ((jSrc & 0x80) >> (7-1)));
                jSrc<<=1;
                pusDst++;
            } while (pusDst != pusEnd);

        }

        pusDst = (PUSHORT)((PBYTE)pusDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pusDst != pusEndY);

}



/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D24
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    BYTE    F0,F1,F2;
    BYTE    B0,B1,B2;
    LONG    ixStart     = SrcLeft & 0x07;
    PBYTE   pjEnd;
    PBYTE   pjEnd8;
    PBYTE   pjDst       = pjDstIn + 3 * DstLeft;
    PBYTE   pjSrc       = pjSrcIn + (SrcLeft >> 3);
    LONG    cx          = DstRight - DstLeft;
    LONG    lDstStride  = DeltaDstIn - (cx * 3);
    LONG    lSrcStride  = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[8];
    PBYTE   pjEndY      = pjDst + DeltaDstIn * cy;
    LONG    StartOffset = 3 * (min(cx, (8 - ixStart)));
    PBYTE   pTable;

    //
    // build exp table
    //

    *(PULONG)ExpTable     = uB;
    *(PULONG)(ExpTable+4) = uF;

    do {

        pjEnd = pjDst + 3 * cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PBYTE pjEndSt = pjDst + StartOffset;

            do {

                pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

                *pjDst   = *pTable;
                *(pjDst+1) = *(pTable+1);
                *(pjDst+2) = *(pTable+2);

                pjDst += 3;

                jSrc <<=1;

            } while (pjDst != pjEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pjEnd8 = pjDst + (24 * (((ULONG_PTR)pjEnd - (ULONG_PTR)pjDst)/24));

        //
        // expand full bytes
        //

        while (pjDst != pjEnd8) {

            jSrc = *pjSrc;

            pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

            *(pjDst + 0) = *pTable;
            *(pjDst + 1) = *(pTable+1);
            *(pjDst + 2) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x40) >> (6-2));

            *(pjDst + 3) = *pTable;
            *(pjDst + 4) = *(pTable+1);
            *(pjDst + 5) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x20) >> (5-2));

            *(pjDst + 6) = *pTable;
            *(pjDst + 7) = *(pTable+1);
            *(pjDst + 8) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x10) >> (4-2));

            *(pjDst + 9) = *pTable;
            *(pjDst + 10) = *(pTable+1);
            *(pjDst + 11) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x08) >> (3-2));

            *(pjDst + 12) = *pTable;
            *(pjDst + 13) = *(pTable+1);
            *(pjDst + 14) = *(pTable+2);

            pTable = ExpTable + (jSrc & 0x04);

            *(pjDst + 15) = *pTable;
            *(pjDst + 16) = *(pTable+1);
            *(pjDst + 17) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x02) << 1);

            *(pjDst + 18) = *pTable;
            *(pjDst + 19) = *(pTable+1);
            *(pjDst + 20) = *(pTable+2);

            pTable = ExpTable + ((jSrc & 0x01) << 2);

            *(pjDst + 21) = *pTable;
            *(pjDst + 22) = *(pTable+1);
            *(pjDst + 23) = *(pTable+2);

            pjSrc++;
            pjDst += (3*8);

        }

        //
        // finish off scan line if needed
        //

        if (pjDst != pjEnd) {

            jSrc = *pjSrc++;

            do {

                pTable = ExpTable + ((jSrc & 0x80) >> (7-2));

                *(pjDst +  0) = *pTable;
                *(pjDst +  1) = *(pTable+1);
                *(pjDst +  2) = *(pTable+2);

                jSrc<<=1;
                pjDst+= 3;
            } while (pjDst != pjEnd);

        }

        pjDst = (PBYTE)((PBYTE)pjDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pjDst != pjEndY);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSrcOpaqCopyS1D32
*
* Routine Description:
*
*   Opaque blt of 1BPP src to destination format
*
* Arguments:
*
*    pjSrcIn    - pointer to beginning of current scan line of src buffer
*    SrcLeft    - left (starting) pixel in src rectangle
*    DeltaSrcIn - bytes from one src scan line to next
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer
*    DstLeft    - left(first) dst pixel
*    DstRight   - right(last) dst pixel
*    DeltaDstIn - bytes from one Dst scan line to next
*    cy         - number of scan lines
*    uF         - Foreground color
*    uB         - Background color
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
vSrcOpaqCopyS1D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )

{
    BYTE    jSrc;
    LONG    ixStart    = SrcLeft & 0x07;
    PULONG  pulEnd;
    PULONG  pulEnd8;
    PULONG  pulDst     = (PULONG)pjDstIn + DstLeft;
    PBYTE   pjSrc      = pjSrcIn + (SrcLeft >> 3);
    LONG    cx         = DstRight - DstLeft;
    LONG    lDstStride = DeltaDstIn - (cx << 2);
    LONG    lSrcStride = DeltaSrcIn - ((cx + ixStart + 7) >> 3);
    UCHAR   ExpTable[8];
    PULONG  pulEndY    = (PULONG)((PBYTE)pulDst + DeltaDstIn * cy);
    LONG    StartOffset = min(cx, (8 - ixStart));

    //
    // build exp table
    //

    *(PULONG)ExpTable     = uB;
    *(PULONG)(ExpTable+4) = uF;

    do {

        pulEnd = pulDst + cx;

        //
        // do starting pixels
        //

        if (ixStart) {

            jSrc = *pjSrc << ixStart;

            pjSrc++;

            PULONG pulEndSt = pulDst + StartOffset;

            do {
                *pulDst = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
                pulDst++;
                jSrc <<=1;

            } while (pulDst != pulEndSt);
        }


        //
        // number of full bytes that can be expanded
        //

        pulEnd8 = (PULONG)((PBYTE)pulDst + (((ULONG_PTR)pulEnd - (ULONG_PTR)pulDst) & ~0x1F));

        //
        // expand full bytes
        //

        while (pulDst != pulEnd8) {

            jSrc = *pjSrc;

            *(pulDst + 0) = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
            *(pulDst + 1) = *(PULONG)(ExpTable + ((jSrc & 0x40) >> (6-2)));
            *(pulDst + 2) = *(PULONG)(ExpTable + ((jSrc & 0x20) >> (5-2)));
            *(pulDst + 3) = *(PULONG)(ExpTable + ((jSrc & 0x10) >> (4-2)));
            *(pulDst + 4) = *(PULONG)(ExpTable + ((jSrc & 0x08) >> (3-2)));
            *(pulDst + 5) = *(PULONG)(ExpTable + ((jSrc & 0x04) >> (2-2)));
            *(pulDst + 6) = *(PULONG)(ExpTable + ((jSrc & 0x02) << 1));
            *(pulDst + 7) = *(PULONG)(ExpTable + ((jSrc & 0x01) << 2));

            pjSrc++;
            pulDst += 8;

        }

        //
        // finish off scan line if needed
        //

        if (pulDst != pulEnd) {

            jSrc = *pjSrc++;

            do {
                *pulDst = *(PULONG)(ExpTable + ((jSrc & 0x80) >> (7-2)));
                jSrc<<=1;
                pulDst++;
            } while (pulDst != pulEnd);

        }

        pulDst = (PULONG)((PBYTE)pulDst + lDstStride);
        pjSrc  += lSrcStride;

    } while(pulDst != pulEndY);

}



VOID vSrcTranCopyError(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pSurf
    )
{
/**/WARNING("!!vSrcTranCopyError!!\n");
}

/******************************Public*Routine******************************\
* vRectBlt
*
* 'Extra' rectangle on a monochrome dib.
*
* History:
*  Thu Dec 03 11:22:21 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vRectBlt
(
    PBYTE pjMonoDib,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    PWORD pwDst;
    ULONG cy = (ULONG) (ybottom - ytop);

    //
    // Left mask
    //

    static WORD awMaskL[16] = {
        0x0000, 0x0080, 0x00C0, 0x00E0, 0x00F0, 0x00F8, 0x00FC, 0x00FE,
        0x00FF, 0x80FF, 0xC0FF, 0xE0FF, 0xF0FF, 0xF8FF, 0xFCFF, 0xFEFF};

    //
    // Right mask
    //

    static WORD awMaskR[16] = {
        0xFFFF, 0xFF7F, 0xFF3F, 0xFF1F, 0xFF0F, 0xFF07, 0xFF03, 0xFF01,
        0xFF00, 0x7F00, 0x3F00, 0x1F00, 0x0F00, 0x0700, 0x0300, 0x0100};

    ASSERTGDI(xleft < xright && ytop < ybottom, "vRectBlt: bad rectangle");

    pjMonoDib += (ytop * cjScanMono);
    pjMonoDib += (xleft >> 4 << 1);

    //
    // Since the mono dib is word-aligned, we will set one word at a time
    // in the main loop.
    //

    LONG cWords = (xright >> 4) - ((xleft + 0xF) >> 4);

    do {

        pwDst = (PWORD) pjMonoDib;
        pjMonoDib += cjScanMono;

        //
        // Handle the special case where both xleft and xright are in
        // the same word and ((xleft & 0xF) != 0) and ((xright & 0xF) != 0).
        //

        if (cWords < 0)
        {
            WORD wMask = awMaskR[xleft & 0xF] & awMaskL[xright & 0xF];
            *pwDst = *pwDst | wMask;
            continue;
        }

        //
        // Handle the first partial source word.
        //

        if (xleft & 0xF)
        {
            *pwDst = *pwDst | awMaskR[xleft & 0xF];
            pwDst++;
        }

        //
        // Handle the main loop for each source word.
        //

        for (LONG i = cWords; i > 0; i--) {
            *pwDst++ = (WORD) ~0;
        }

        //
        // Handle the last partial source word.
        //

        if (xright & 0xF) {
            *pwDst = *pwDst | awMaskL[xright & 0xF];
        }
    } while (--cy);
}


VOID vRectBlt4
(
    PBYTE pj4bpp,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    // Put in a rectangle by hand. This is a matter of setting each
    // of the appropriate nibbles to 0xf
}


VOID vRectBlt8
(
    PBYTE pj8bpp,
    ULONG cjScanMono,
    LONG  xleft,
    LONG  ytop,
    LONG  xright,
    LONG  ybottom
)
{
    // Put in a rectangle by hand. This is a matter of setting each
    // of the appropriate pixels  to ????

    RIP("cleartype vRectBlt8 \n");

}



/******************************Public*Routine******************************\
* STROBJ_dwGetCodePage
*
* Code page corresponding to the current TextOut
*
* History:
*  Wed Jan 24 11:09:21 1996     -by-    Tessie Wu    [tessiew]
* Wrote it.
\**************************************************************************/

extern "C" DWORD STROBJ_dwGetCodePage( STROBJ* pstro)
{
   return ( ((ESTROBJ*)pstro)->dwCodePage );
}


/******************************Public*Routine******************************\
*
* more accelerators for ps driver:
*
* FIX APIENTRY STROBJ_fxCharacterExtra(STROBJ  *pstro)
* FIX APIENTRY STROBJ_fxBreakExtra(STROBJ  *pstro)
* Effects:
*
* History:
*  25-Oct-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



extern "C" FIX APIENTRY STROBJ_fxCharacterExtra(STROBJ  *pstro)
{
    if (((ESTROBJ*)pstro)->flAccel & SO_CHARACTER_EXTRA)
        return ((ESTROBJ*)pstro)->xExtra;
    else
        return 0;
}

extern "C" FIX APIENTRY STROBJ_fxBreakExtra(STROBJ  *pstro)
{
    if (((ESTROBJ*)pstro)->flAccel & SO_BREAK_EXTRA)
        return ((ESTROBJ*)pstro)->xBreakExtra;
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\textgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: textgdi.cxx
*
* Text APIs for NT graphics engine
*
* Created: 18-Dec-1990 10:09:19
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


EFLOAT efCos(EFLOAT x);
EFLOAT efSin(EFLOAT x);

extern PBRUSH gpbrText;
extern PBRUSH gpbrBackground;

#define XFORMNULL (EXFORMOBJ *) NULL

// This is a tiny class just to make sure we don't forget to free up any
// objects before leaving ExtTextOut.

class TXTCLEANUP
{
    XDCOBJ *pdco;
public:
    TXTCLEANUP()                   {pdco=(DCOBJ *) NULL;}
   ~TXTCLEANUP()                   {if (pdco != (DCOBJ *) NULL) vMopUp();}
    VOID vSet(XDCOBJ& dco)         {pdco = &dco;}
    VOID vMopUp();
};

VOID TXTCLEANUP::vMopUp()
{
    RGNOBJ ro(pdco->pdc->prgnAPI());
    ro.bDeleteRGNOBJ();
    pdco->pdc->prgnAPI(NULL);
}

// Helper routine to draw a device coordinate RECTL into a path.

BOOL bAddRectToPath(EPATHOBJ& po,RECTL *prcl)
{
    POINTFIX aptfx[4];

    aptfx[3].x = aptfx[0].x = LTOFX(prcl->left);
    aptfx[1].y = aptfx[0].y = LTOFX(prcl->top);
    aptfx[2].x = aptfx[1].x = LTOFX(prcl->right);
    aptfx[3].y = aptfx[2].y = LTOFX(prcl->bottom);

    return(po.bAddPolygon(XFORMNULL,(POINTL *) aptfx,4));
}


/******************************Public*Routine******************************\
* GreExtTextOutRect: Wrapper for common GreExtTextOutW code. This routine just
* acquires locks then calls GreExtTextOutWLocked
*
* Arguments:
*
*    Same as ExtTextOutRect
*
* Return Value:
*
*    BOOL States
*
* History:
*
*    30-Oct-1995 - Initial version of wrapper
*
\**************************************************************************/


BOOL
GreExtTextOutRect(
    HDC     hdc,
    LPRECT  prcl
    )
{
    BOOL bRet = FALSE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            if ((!dcoDst.bDisplay() || dcoDst.bRedirection()) || UserScreenAccessCheck())
            {
                bRet = ExtTextOutRect(
                               dcoDst,
                               prcl);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
            }
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* ExtTextOutRect
*
* Called when just a Rectangle is passed.  Over-used by Winbench4.0 the
* perf app we aim to please.
*
* History:
*  02-Nov-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
ExtTextOutRect(
    XDCOBJ    &dcoDst,
    LPRECT prcl
    )
{
// Assume failure.

    BOOL bReturn;

// Validate the destination DC.

    if (dcoDst.bValid())
    {
        ASSERTGDI(prcl != NULL, "This API must be past a valid rect");

        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

        if (!xoDst.bRotation())
        {
            ERECTL erclDst(prcl->left, prcl->top, prcl->right, prcl->bottom);
            xoDst.bXform(erclDst);
            erclDst.vOrder();

            if (!erclDst.bEmpty())
            {
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.

                if (dcoDst.fjAccum())
                    dcoDst.vAccumulate(erclDst);

            // Check surface is included in DC.

                SURFACE *pSurfDst = dcoDst.pSurface();

                if (pSurfDst != NULL)
                {
                // With a fixed DC origin we can change the destination to SCREEN coordinates.

                    erclDst += dcoDst.eptlOrigin();

                    ECLIPOBJ *pco = NULL;

                // This is a pretty knarly expression to save a return in here.
                // Basically pco can be NULL if the rect is completely in the
                // cached rect in the DC or if we set up a clip object that isn't empty.

                    if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                         (erclDst.right  <= dcoDst.prclClip()->right) &&
                         (erclDst.top    >= dcoDst.prclClip()->top) &&
                         (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                        (pco = dcoDst.pco(),
                         pco->vSetup(dcoDst.prgnEffRao(), erclDst,CLIP_NOFORCETRIV),
                         erclDst = pco->erclExclude(),
                         (!erclDst.bEmpty())))
                    {
                    // Set up the brush if necessary.

                        EBRUSHOBJ *pbo = dcoDst.peboBackground();

                        if (dcoDst.bDirtyBrush(DIRTY_BACKGROUND))
                        {
                            dcoDst.vCleanBrush(DIRTY_BACKGROUND);

                            XEPALOBJ palDst(pSurfDst->ppal());
                            XEPALOBJ palDstDC(dcoDst.ppal());

                            pbo->vInitBrush(dcoDst.pdc,
                                            gpbrBackground,
                                            palDstDC,
                                            palDst,
                                            pSurfDst,
                                            (dcoDst.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) ? TRUE : FALSE);
                        }

                        DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,pco);

                    // Inc the target surface uniqueness

                        INC_SURF_UNIQ(pSurfDst);

                    // Dispatch the call.

                        bReturn = (*(pSurfDst->pfnBitBlt()))

                                      (pSurfDst->pSurfobj(),
                                       (SURFOBJ *) NULL,
                                       (SURFOBJ *) NULL,
                                       pco,
                                       NULL,
                                       &erclDst,
                                       (POINTL *)  NULL,
                                       (POINTL *)  NULL,
                                       pbo,
                                       &dcoDst.pdc->ptlFillOrigin(),
                                       0x0000f0f0);

                    }
                    else
                    {
                        bReturn = TRUE;
                    }
                }
                else
                {
                    bReturn = TRUE;
                }
            }
            else
            {
                bReturn = TRUE;
            }
        }
        else
        {
        // There is rotation involved - send it off to ExtTextOutW to handle it.

            bReturn = GreExtTextOutWLocked(dcoDst, 0, 0, ETO_OPAQUE,
                prcl, (LPWSTR) NULL, 0, NULL, dcoDst.pdc->jBkMode(), NULL, 0);
        }
    }
    else
    {
        WARNING1("ERROR TextOutRect called on invalid DC\n");
        bReturn = FALSE;
    }

    return(bReturn);
}
/******************************Public*Routine******************************\
* BOOL GrePolyTextOut
*
* Write text with lots of random spacing and alignment options.
*
* Arguments:
*
*   hdc      -  handle to DC
*   lpto     -  Ptr to array of polytext structures
*   nStrings -  number of polytext structures
*
* Return Value:
*
* History:
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* For code size we'll call ExtTextOutW.  After the RFONT and brushes are
* realized, the RaoRegion is setup etc, future calls to ExtTextOutW
* will be very cheap.  Plus ExtTextOut will be in the working set where a
* huge GrePolyTextOut won't be.  It is still a savings by avoiding kernel
* transitions
*
\**************************************************************************/

BOOL GrePolyTextOutW(
    HDC        hdc,
    POLYTEXTW *lpto,
    UINT       nStrings,
    DWORD      dwCodePage
)
{
    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    BOOL bRet = TRUE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            for (POLYTEXTW *ppt = lpto; ppt < lpto+nStrings; ppt += 1)
            {
                //
                // Try to use stack buffer
                //

                PVOID pStrObjBuffer = NULL;
                ULONG cjStrObj = SIZEOF_STROBJ_BUFFER(ppt->n);

                if (TEXT_CAPTURE_BUFFER_SIZE >= cjStrObj)
                {
                    pStrObjBuffer = CaptureBuffer;
                }

                if (!GreExtTextOutWLocked(
                                    dcoDst,
                                    ppt->x,
                                    ppt->y,
                                    ppt->uiFlags,
                                    &(ppt->rcl),
                                    (LPWSTR) ppt->lpstr,
                                    ppt->n,
                                    ppt->pdx,
                                    dcoDst.pdc->jBkMode(),
                                    pStrObjBuffer,
                                    dwCodePage))
                {
                    WARNING1("GrePolyTextOutW failed a call to GreExtTextOutW\n");
                    bRet = FALSE;
                    break;
                }
            }
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("GrePolyTextOutW: can not lock dc \n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        bRet = FALSE;
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* GreExtTextOutW: Wrapper for common GreExtTextOutW code. This routine just
* acquires locks then calls GreExtTextOutWLocked
*
* Arguments:
*
*    Same as GreExtTextOutW
*
* Return Value:
*
*    BOOL States
*
* History:
*
*    30-Oct-1995 - Initial version of wrapper
*
\**************************************************************************/

// for user/kernel consumption only

BOOL GreExtTextOutW(
    HDC     hdc,
    int     x,
    int     y,
    UINT    flOpts,
    CONST RECT *prcl,
    LPCWSTR    pwsz,
    UINT       cwc,
    CONST INT *pdx
    )
{
    return GreExtTextOutWInternal(
            hdc,
            x,
            y,
            flOpts,
            (LPRECT)prcl,
            (LPWSTR)pwsz,
            (int) cwc,
            (LPINT)pdx,
            NULL,
            0
            );
}



BOOL GreExtTextOutWInternal(
    HDC     hdc,
    int     x,
    int     y,
    UINT    flOpts,
    LPRECT  prcl,
    LPWSTR  pwsz,
    int     cwc,
    LPINT   pdx,
    PVOID   pvBuffer,
    DWORD   dwCodePage
    )
{

    BOOL bRet = FALSE;

    //
    // call GreExtTextOutW
    //

    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            bRet = GreExtTextOutWLocked(
                                 dcoDst,
                                 x,
                                 y,
                                 flOpts,
                                 prcl,
                                 pwsz,
                                 cwc,
                                 pdx,
                                 dcoDst.pdc->jBkMode(),
                                 pvBuffer,
                                 dwCodePage);
        }
        else
        {
            bRet = dcoDst.bFullScreen();
        }

        dcoDst.vUnlock();
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* GreBatchTextOut: Set propper DC flags and attributes, then call textout
* pr textoutrect.
*
* Arguments:
*
*   dcoDst Locked DCOBJ
*   xoDst  XFORMOBJ
*   pbText Batched textout entry
*
* Return Value:
*
*   Status
*
*    14-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


#define ETO_NULL_PRCL 0x80000000

BOOL
GreBatchTextOut(
    XDCOBJ          &dcoDst,
    PBATCHTEXTOUT   pbText,
    ULONG           cjBatchLength   // cannot trust the Length field in pbText
                                    // because it is accessible to user-mode
    )
{
    //
    // set foreground and background color in DC
    // and restore after call (if needed)
    //

    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    COLORREF crSaveText = (COLORREF)-1;
    COLORREF crSaveBack = (COLORREF)-1;
    HANDLE   hlfntNewSave = NULL;
    UINT     flTextAlignSave = -1;
    POINTL   ptlViewportOrgSave;
    PVOID    pStrObjBuffer = NULL;
    ULONG    ulSaveText, ulSaveBack;

    if (pbText->Type == BatchTypeTextOutRect)
    {
        ASSERTGDI(((PBATCHTEXTOUTRECT)pbText)->fl & ETO_OPAQUE, "GreBatchTextOut, flags\n");

        crSaveBack = dcoDst.pdc->crBackClr();
        ulSaveBack = dcoDst.pdc->ulBackClr();

        if (crSaveBack != ((PBATCHTEXTOUTRECT)pbText)->BackColor)
        {
            dcoDst.pdc->crBackClr(((PBATCHTEXTOUTRECT)pbText)->BackColor);
            dcoDst.pdc->ulBackClr(((PBATCHTEXTOUTRECT)pbText)->ulBackColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

        if ((ptlViewportOrgSave.x != ((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.x) ||
            (ptlViewportOrgSave.y != ((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.y))
        {
            dcoDst.pdc->lViewportOrgX(((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.x);
            dcoDst.pdc->lViewportOrgY(((PBATCHTEXTOUTRECT)pbText)->ptlViewportOrg.y);

            dcoDst.pdc->flSet_flXform(
                               PAGE_XLATE_CHANGED     |
                               DEVICE_TO_WORLD_INVALID);
        }

        ExtTextOutRect(dcoDst,(LPRECT)&((PBATCHTEXTOUTRECT)pbText)->rcl);

        if (dcoDst.pdc->crBackClr() != crSaveBack)
        {
            dcoDst.pdc->crBackClr(crSaveBack);
            dcoDst.pdc->ulBackClr(ulSaveBack);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }


        if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
             (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
        {
            dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
            dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

            dcoDst.pdc->flSet_flXform(
                               PAGE_XLATE_CHANGED     |
                               DEVICE_TO_WORLD_INVALID);

        }

    }
    else
    {
        RECT newRect;
        LPRECT prcl;
        LPINT  pdx = NULL;

        //
        // Capture the buffer length parameters from the TEB batch.
        // They can be overwritten by user-mode, so are not to be
        // trusted.
        //

        ULONG fl        = pbText->fl;
        ULONG cChar     = pbText->cChar;
        ULONG PdxOffset = pbText->PdxOffset;

        //
        // Check that char data will not overflow the data buffer.
        //

        ULONG cjBuf = cjBatchLength - offsetof(BATCHTEXTOUT, ulBuffer);

        if (cChar > (cjBuf / sizeof(WCHAR)))
        {
            WARNING("GreBatchTextOut: batch overflow char\n");
            return FALSE;
        }

        //
        // Check that optional pdx data will not overflow the data buffer.
        //

        if (PdxOffset != 0)
        {
            ULONG cjPdxPerChar;

            //
            // The pdx array must have cChar number of horizontal
            // deltas and, if the optional ETO_PDY flag is set, cChar
            // number of vertical deltas.
            //

            cjPdxPerChar = sizeof(INT);
            if (fl & ETO_PDY)
                cjPdxPerChar *= 2;

            //
            // Is the start and end of the pdx array in range?
            //

            if ((PdxOffset > cjBuf) ||
                 (cChar > ((cjBuf - PdxOffset) / cjPdxPerChar)))
            {
                WARNING("GreBatchTextOut: batch overflow pdx\n");
                return FALSE;
            }

            //
            // Since we know that the pdx array is in range, go ahead
            // and set pdx.
            //

            pdx = (LPINT)((PUCHAR)&pbText->ulBuffer[0] + PdxOffset);
        }

        //
        // Set foreground and background text colors.
        //

        crSaveText = dcoDst.pdc->crTextClr();
        ulSaveText = dcoDst.pdc->ulTextClr();

        if (crSaveText != pbText->TextColor)
        {
            dcoDst.pdc->crTextClr(pbText->TextColor);
            dcoDst.pdc->ulTextClr(pbText->ulTextColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }

        crSaveBack = dcoDst.pdc->crBackClr();
        ulSaveBack = dcoDst.pdc->ulBackClr();

        if (crSaveBack != pbText->BackColor)
        {
            dcoDst.pdc->crBackClr(pbText->BackColor);
            dcoDst.pdc->ulBackClr(pbText->ulBackColor);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        if (dcoDst.pdc->hlfntNew() != pbText->hlfntNew)
        {
            hlfntNewSave = dcoDst.pdc->hlfntNew();
            dcoDst.pdc->hlfntNew((HLFONT)pbText->hlfntNew);
            dcoDst.ulDirtyAdd(DIRTY_CHARSET);
            dcoDst.ulDirtySub(SLOW_WIDTHS);

        }

        if (dcoDst.pdc->flTextAlign() != pbText->flTextAlign)
        {
            flTextAlignSave = dcoDst.pdc->flTextAlign();
            dcoDst.pdc->flTextAlign(pbText->flTextAlign);
        }

        ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

        if ((ptlViewportOrgSave.x != pbText->ptlViewportOrg.x) ||
            (ptlViewportOrgSave.y != pbText->ptlViewportOrg.y))
        {
            dcoDst.pdc->lViewportOrgX(pbText->ptlViewportOrg.x);
            dcoDst.pdc->lViewportOrgY(pbText->ptlViewportOrg.y);

            dcoDst.pdc->flSet_flXform(
                                        PAGE_XLATE_CHANGED     |
                                        DEVICE_TO_WORLD_INVALID);
        }

        if (fl & ETO_NULL_PRCL)
        {
            prcl = NULL;
            fl &= ~ETO_NULL_PRCL;
        }
        else
        {
            __try
            {
                newRect = ProbeAndReadStructure((LPRECT)&pbText->rcl,RECT);
                prcl = &newRect;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(119);

                return FALSE;
            }
        }

        //
        // try to use stack based temp buffer
        //

        ULONG cjStrObj = SIZEOF_STROBJ_BUFFER(cChar);

        if (TEXT_CAPTURE_BUFFER_SIZE >= cjStrObj)
        {
            pStrObjBuffer = &CaptureBuffer[0];
        }

        GreExtTextOutWLocked(
                             dcoDst,
                             pbText->x,
                             pbText->y,
                             fl,
                             prcl,
                             (LPWSTR)&pbText->ulBuffer[0],
                             cChar,
                             pdx,
                             pbText->BackMode,
                             pStrObjBuffer,
                             pbText->dwCodePage);

        //
        // Restore the foreground and background text colors.
        //

        if (dcoDst.pdc->crTextClr() != crSaveText)
        {
            dcoDst.pdc->crTextClr(crSaveText);
            dcoDst.pdc->ulTextClr(ulSaveText);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }

        if (dcoDst.pdc->crBackClr() != crSaveBack)
        {
            dcoDst.pdc->crBackClr(crSaveBack);
            dcoDst.pdc->ulBackClr(ulSaveBack);
            dcoDst.ulDirtyAdd(DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }

        if (hlfntNewSave != NULL)
        {
           dcoDst.pdc->hlfntNew(((HLFONT)hlfntNewSave));
           dcoDst.ulDirtyAdd(DIRTY_CHARSET);
           dcoDst.ulDirtySub(SLOW_WIDTHS);
        }

        if (flTextAlignSave != -1)
        {
            dcoDst.pdc->flTextAlign(flTextAlignSave);
        }

        if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
             (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
        {
            dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
            dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

            dcoDst.pdc->flSet_flXform(
                            PAGE_XLATE_CHANGED     |
                            DEVICE_TO_WORLD_INVALID);

        }

    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GreExtTextOutW (hdc,x,y,flOpts,prcl,pwsz,cwc,pdx,pvBuffer)
*
* Write text with lots of random spacing and alignment options.
*
* Below are the string length distributions from running the Winstone 95
* scenarios for Excel and Winword, courtesy of KirkO:
*
*   [Excel]
*                  ------ OPAQUE ------- ----- TRANSPARENT ---
*    string length   pdx == 0   pdx != 0   pdx == 0   pdx != 0
*    ------------- ---------- ---------- ---------- ----------
*         0--9           3799          0      15323       9143
*        10--19           695          0       1651        983
*        20--29           527          0        196         22
*        30--39           200          0        289         53
*        40--49            12          0          3          0
*        50--59            96          0         12          0
*        60--69            10          0          4          0
*        70--79             3          0          0          0
*        80--89             0          0          0          0
*        90--99             0          0         49         16
*       100--109           11          0          0          0
*
*   [Winword]
*
*                 ------ OPAQUE ------- ----- TRANSPARENT ---
*   string length   pdx == 0   pdx != 0   pdx == 0   pdx != 0
*   ------------- ---------- ---------- ---------- ----------
*        0--9           1875          9       3350          0
*       10--19           878         17        324          0
*       20--29           254         17         25          0
*       30--39            93          6         28          2
*       40--49           146         30         18         12
*       50--59            34         16          3         14
*       60--69            20         13          8          7
*       70--79           128         73         13         18
*       80--89            53        139          6         23
*       90--99            41        903          9        127
*      100--109           92       1878          3        217
*      110--119            5         23          0          0
*
* History:
*  Fri 05-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Make smaller and faster.
*
*  Sat 14-Mar-1992 06:08:26 -by- Charles Whitmer [chuckwh]
* Rewrote it.
*
*  Thu 03-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define TS_DRAW_TEXT                0x0001
#define TS_DRAW_OPAQUE_PGM          0x0002
#define TS_DRAW_COMPLEX_UNDERLINES  0x0004
#define TS_DRAW_OPAQUE_RECT         0x0008
#define TS_DRAW_BACKGROUND_PGM      0x0010
#define TS_DRAW_VECTOR_FONT         0x0020
#define TS_DRAW_OUTLINE_FONT        0x0040
#define TS_START_WITH_SUCCESS       0x0080

// Due to the massiveness of this function we will use 2 space tabs.

#if DBG // statistics
    typedef struct _TSTATENTRY {
        int c;         // number observed
    } TSTATENTRY;
    typedef struct _TSTAT {
        TSTATENTRY NO; // pdx == 0, opaque
        TSTATENTRY DO; // pdx != 0, opaque
        TSTATENTRY NT; // pdx == 0, transparent
        TSTATENTRY DT; // pdx != 0, transparent
    } TSTAT;
    #define MAX_CHAR_COUNT 200  // observe for 0,1,..200,201 and above
    typedef struct _TEXTSTATS {
        int cchMax;             // = MAX_CHAR_COUNT
        TSTAT ats[MAX_CHAR_COUNT+2];
    } TEXTSTATS;
    TEXTSTATS gTS = {MAX_CHAR_COUNT};
    #define TS_START    1
    #define TS_CONTINUE 2
    #define TS_VERBOSE  4
    #define TS_STOP     8
    FLONG   gflTS = 0;          // flags that control text statistics
#endif  // statistics


BOOL GreExtTextOutWLocked(
    XDCOBJ    &dco,             // Locked DC
    int       x,                // Initial x position
    int       y,                // Initial y position
    UINT      flOpts,           // Options
    LPRECT    prcl,             // Clipping rectangle
    LPWSTR    pwsz,             // Unicode character array
    int       cwc,              // Count of characters
    LPINT     pdx,              // Character spacing
    ULONG     ulBkMode,         // Current background mode
    PVOID     pvBuffer,         // If non-NULL, contains a buffer for storing
                                //   the STROBJ, so that we don't need to
                                //   allocate one on the fly.  Must be at
                                //   least SIZEOF_STROBJ_BUFFER(cwc) bytes in
                                //   size.
                                // If NULL, we will try to use the global
                                //   STROBJ buffer, otherwise we will allocate
                                //   on the fly.
    DWORD     dwCodePage        // Code page for current textout
)
{
  // flState gets set with BITS for things we need to draw.
  // We also use this for the return value, setting it to 0 if an error occurs.

  BOOL bIsVectorFont = FALSE;
  BOOL bPathFont = FALSE;


  FLONG flState = TS_START_WITH_SUCCESS;
  BOOL  flType = ((flOpts & ETO_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);

  // Win95 comaptibility: If in path bracket and ETO_CLIPPED is set, then fail call

  if ( dco.pdc->bActive() && ( flOpts & ETO_CLIPPED ) )
  {
    EngSetLastError( ERROR_INVALID_PARAMETER );
    return( FALSE );
  }

  if (dco.bDisplay() && !dco.bRedirection() && !UserScreenAccessCheck())
  {
      SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
      return( FALSE );
  }

// ignore RTOLREADING flag,
// only does something if lpk dlls are loaded under win95

  BOOL bPdy = flOpts & ETO_PDY;

  flOpts &= ~(ETO_PDY | ETO_GLYPH_INDEX | ETO_RTLREADING | ETO_IGNORELANGUAGE | ETO_NUMERICSLOCAL | ETO_NUMERICSLATIN);
  if (!prcl)
  {
      flOpts &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
  }
  else if ((prcl->left == prcl->right) || (prcl->top == prcl->bottom))
  {
      prcl->left = prcl->right = x;
      prcl->top = prcl->bottom = y;

      // now prcl is guaranteed to be within text rect

      if ((flOpts & (ETO_OPAQUE|ETO_CLIPPED)) == ETO_OPAQUE)
      {
    prcl = NULL; // since it is empty, we may as well ignore it
    flOpts &= ~ETO_OPAQUE; // ignore flag if no rect
      }
  }

  PFN_DrvTextOut pfnTextOut;
  MIX mix = R2_COPYPEN + 256*R2_COPYPEN;    // default mix sent to TextOut routines

  // Lock the DC and set the new attributes.

  if (dco.bValid())
  {
    #if DBG // statistics
    if (gflTS & TS_START) {
        KdPrint((
            "\n"
            "***************************************\n"
            "*** BEGIN GreExtTextOutW statistics ***\n"
            "***************************************\n"
            "\n"
        ));
        RtlZeroMemory(gTS.ats, sizeof(TSTAT)*(gTS.cchMax+2));
        gflTS ^= TS_START;
        gflTS |= TS_CONTINUE;
    }
    if (gflTS & TS_CONTINUE) {
        TSTATENTRY *ptse;
        char       *psz;
        TSTAT      *pts;

        pts = gTS.ats + min(cwc,gTS.cchMax+1);
        ptse = 0;
        switch (ulBkMode)
        {
        case OPAQUE:
            ptse = (pdx) ? &(pts->DO) : &(pts->NO);
            psz =  "OPAQUE";
            break;
        case TRANSPARENT:
            ptse = (pdx) ? &(pts->DT) : &(pts->NT);
            psz  = "TRANSP";
            break;
        default:
            KdPrint(("jBkMode = UNKNOWN\n"));
            break;
        }
        if (ptse) {
            ptse->c += 1;
            if (gflTS & TS_VERBOSE)
                KdPrint((
                    "%10d %10d %s %s"
                ,   min(cwc,gTS.cchMax+1)
                ,   ptse->c
                ,   psz
                ,   (pdx) ? "(pdx)" : ""
                ));
        }
    }
    if (gflTS & TS_STOP) {
        KdPrint((
            "\n"
            "*************************************\n"
            "*** END GreExtTextOutW statistics ***\n"
            "*************************************\n"
            "\n"
        ));
        gflTS = 0;
    }
    #endif  // statistics

    // Check the validity of the flags.

    if
    (
      ((flOpts == 0) || ((prcl != (RECT *) NULL) && ((flOpts & ~(ETO_CLIPPED | ETO_OPAQUE)) == 0)))
      &&
      !(dco.pdc->bActive() && (flOpts & ETO_CLIPPED)) // no clipping in a path
    )
    {
      FLONG flControl = 0;        // Set to 0 in case cwc is 0
      ERECTL rclExclude(0,0,0,0);

      // Lock the Rao region if we are drawing on a display surface.  The Rao region
      // might otherwise change asynchronously.  The DEVLOCKOBJ also makes sure that
      // the VisRgn is up to date, calling the window manager if necessary to
      // recompute it.  This is needed if want to compute positions in screen coords.
      // No DEVLOCK is needed if we are in path accumulation mode.

      POINTL   ptlOrigin;             // The window origin.
      POINTFIX ptfxOrigin;            // Same thing in FIX.

        if (dco.pdc->bActive())
        {
          ptlOrigin.x = 0;
          ptlOrigin.y = 0;
        }
        else
        {
          ptlOrigin = dco.eptlOrigin();
        }

        ptfxOrigin.x = LTOFX(ptlOrigin.x);
        ptfxOrigin.y = LTOFX(ptlOrigin.y);

        // Get the transform from the DC.

        EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

        // Transform the input rectangle.  In the simple case the result is in
        // rclInput.  In the general case a parallelogram is in ptfxInput[4], and
        // bounds for the parallelogram are in rclInput.

        ERECTL    rclInput;
        POINTFIX  ptfxInput[4];

        // this must go after the DCOBJ, so that the DCOBJ still exists at cleanup

        TXTCLEANUP clean;              // Mops up before exit.

        if (prcl != (RECT *) NULL)
        {
          if (flOpts & ETO_OPAQUE)
          {
            flState |= TS_DRAW_OPAQUE_RECT;
          }

          // The intent of the following bTranslationsOnly and bScale cases is to provide
          // faster inline versions of the same code that would be executed by xo.bXform(prcl).
          // We must be completely compatible with the normal xform code because apps expect
          // to opaque and clip to the same rectangles as a PatBlt would cover.  So, if you
          // intend to modify the behavior of this code, make sure you change PatBlt and
          // BitBlt as well!  (I.e. just don't do it.)  [chuckwh]

          if (xo.bTranslationsOnly())
          {
            rclInput.left   = prcl->left   + ptlOrigin.x + FXTOL(xo.fxDx() + 8);
            rclInput.right  = prcl->right  + ptlOrigin.x + FXTOL(xo.fxDx() + 8);
            rclInput.top    = prcl->top    + ptlOrigin.y + FXTOL(xo.fxDy() + 8);
            rclInput.bottom = prcl->bottom + ptlOrigin.y + FXTOL(xo.fxDy() + 8);
          }
          else if (xo.bScale())        // Simple scaling.
          {
            rclInput.left   = FXTOL(xo.fxFastX(prcl->left)   + 8) + ptlOrigin.x;
            rclInput.right  = FXTOL(xo.fxFastX(prcl->right)  + 8) + ptlOrigin.x;
            rclInput.top    = FXTOL(xo.fxFastY(prcl->top)    + 8) + ptlOrigin.y;
            rclInput.bottom = FXTOL(xo.fxFastY(prcl->bottom) + 8) + ptlOrigin.y;
          }
          else                        // General case.
          {
            //
            // Construct three vertices of the input rectangle, in drawing order.
            //

            ptfxInput[0].x = prcl->left;
            ptfxInput[0].y = prcl->bottom;
            ptfxInput[1].x = prcl->left;
            ptfxInput[1].y = prcl->top;
            ptfxInput[2].x = prcl->right;
            ptfxInput[2].y = prcl->top;

            // Transform the vertices.

            xo.bXform((POINTL *) ptfxInput,ptfxInput,3);

            // We construct the fourth vertex ourselves to avoid excess transform
            // work and roundoff errors.

            ptfxInput[3].x = ptfxInput[0].x + ptfxInput[2].x - ptfxInput[1].x;
            ptfxInput[3].y = ptfxInput[0].y + ptfxInput[2].y - ptfxInput[1].y;

            // Bound the parallelogram.  (Using Black Magic.)

            // DChinn: At this point, we know that EITHER points 0 and 2 OR
            // points 1 and 3 are the extreme x coordinates (left and right).
            // Similarly, EITHER points 0 and 2 OR points 1 and 3 are the extreme y
            // coordinates.
            //
            // ASSERT: it is possible that at this point, prcl is inverted
            // (i.e., left > right or top > bottom).  If this is true, then
            // ptfxInput[] will have its points ordered counterclockwise rather
            // than clockwise.

            int ii;

            ii = (ptfxInput[1].x > ptfxInput[0].x)
                 == (ptfxInput[1].x > ptfxInput[2].x);

            // Rounding direction depends on whether the parallelogram is inverted or not.
            if (ptfxInput[ii].x <= ptfxInput[ii+2].x)
            {
                rclInput.left   = ptlOrigin.x + FXTOL(ptfxInput[ii].x);
                rclInput.right  = ptlOrigin.x + FXTOLCEILING(ptfxInput[ii+2].x);
            }
            else
            {
                rclInput.left   = ptlOrigin.x + FXTOLCEILING(ptfxInput[ii].x);
                rclInput.right  = ptlOrigin.x + FXTOL(ptfxInput[ii+2].x);
            }

            ii = (ptfxInput[1].y > ptfxInput[0].y)
                 == (ptfxInput[1].y > ptfxInput[2].y);

            // Rounding direction depends on whether the parallelogram is inverted or not.
            if (ptfxInput[ii].y <= ptfxInput[ii+2].y)
            {
                rclInput.top    = ptlOrigin.y + FXTOL(ptfxInput[ii].y);
                rclInput.bottom = ptlOrigin.y + FXTOLCEILING(ptfxInput[ii+2].y);
            }
            else
            {
                rclInput.top    = ptlOrigin.y + FXTOLCEILING(ptfxInput[ii].y);
                rclInput.bottom = ptlOrigin.y + FXTOL(ptfxInput[ii+2].y);
            }

            // Take care of a complex clipping request now.  We'll set things up
            // so that the clipping will just happen automatically, and then clear
            // the clipping flag.  This simplifies the rest of the code.

            if (flOpts & ETO_CLIPPED)
            {
              // Allocate a path.  We know we're not already in a path bracket
              // since clipping requests in path brackets were rejected above.
              // Draw the parallelogram into it.

              PATHMEMOBJ po;

              if (po.bValid() && po.bAddPolygon(XFORMNULL,(POINTL *)&ptfxInput[0],4))
              {
                //
                // Construct a region from the path.
                //

                RECTL Bounds, *pBounds;

                // Only the top and bottom are used for clipping and
                // they have to be initialized as FIX.
                Bounds.top    = LTOFX(dco.erclClip().top - ptlOrigin.y);
                Bounds.bottom = LTOFX(dco.erclClip().bottom - ptlOrigin.y);
                pBounds = &Bounds;

                RGNMEMOBJ rmo(po, ALTERNATE, pBounds);


                if (rmo.bValid())
                {
                  // Stuff the region handle into the DC.  This is a nifty trick
                  // (courtesy of DonaldS) that uses this region in the next
                  // calculation of the clipping pipeline.  We'll clear the prgnAPI
                  // after we're through.

                  dco.pdc->prgnAPI(rmo.prgnGet());

                  // Clipping is now transparent, so forget about it.

                  clean.vSet(dco);        // This frees the region on exit.

                  if (dco.pdc->prgnRao() != (REGION *)NULL)
                  {
                    dco.pdc->vReleaseRao();
                  }

                  if (dco.pdc->bCompute())
                  {
                    flOpts &= ~ETO_CLIPPED;
                  }

                  // Now that we have a complex clip area, we can opaque with a
                  // simple BitBlt.  So we don't need to set TS_DRAW_OPAQUE_PGM.
                }
              }

              //
              // Well if we have succeeded we will have erased the ETO_CLIPPED flag.
              // Otherwise we failed and need to return FALSE.  We can't return here
              // without generating tons of destructors so we set flState and a few
              // other fields to 0 so we bop down and return FALSE.
              //

              if (flOpts & ETO_CLIPPED)
              {
                flOpts  = 0;
                flState = 0;
                cwc     = 0;
              }
            }
            else if (flOpts & ETO_OPAQUE)
            {
              flState &= ~TS_DRAW_OPAQUE_RECT;
              flState |= TS_DRAW_OPAQUE_PGM;

              // Since we're actually going to use it, offset the parallelogram
              // to screen coordinates. use unrolled loop

              EPOINTFIX *pptfx = (EPOINTFIX *) &ptfxInput[0];

              *pptfx++ += ptfxOrigin;
              *pptfx++ += ptfxOrigin;
              *pptfx++ += ptfxOrigin;
              *pptfx   += ptfxOrigin;
            }
          }

          // If it a mirrored DC then shift the rect one pixel to the right
          // This will give the effect of including the right edge of the rect and exclude the left edge.
          if (MIRRORED_DC(dco.pdc)) {
             ++rclInput.left;
             ++rclInput.right;
          }
          // Force the rectangle to be well ordered.

          rclInput.vOrder();

          // Add any opaquing into the exclusion area.

          if (flState &
              (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM))
          {
            rclExclude += rclInput;
          }
        }

        POINTFIX aptfxBackground[4];    // The TextBox.
        BOOL     bComplexBackground;    // TRUE if the TextBox is a parallelogram.
        RECTL   *prclBackground = NULL; // Bkgnd rectangle passed to DrvTextOut.
        RECTL   *prclExtraRects = NULL; // Extra rectangles passed to DrvTextOut.
        RFONTOBJ rfo;
        ESTROBJ to;

        if (cwc)
        {
          //
          // Locate the font cache.  Demand PATHOBJ's if we are in a path bracket.
          //

          rfo.vInit(dco, dco.pdc->bActive() ? TRUE  : FALSE, flType);
          if (rfo.bValid())
          {
            bPathFont = rfo.bPathFont();
            bIsVectorFont = rfo.bPathFont() && !rfo.bReturnsOutlines();

            // The recording of the simulation flags and escapement must come AFTER
            // the rfont constructor since they're cached values that are copied from
            // the LFONT only when the font is realized.

            flControl = (dco.pdc->flTextAlign() & TA_MASK)
                         | dco.pdc->flSimulationFlags();

            // Get the reference point.

            EPOINTFIX ptfx;

            if (flControl & TA_UPDATECP)
            {
              if (dco.pdc->bValidPtfxCurrent())
              {
                // Mark that we'll be updating the DC's CP in device coords only:

                dco.pdc->vInvalidatePtlCurrent();
                ptfx.x = dco.ptfxCurrent().x + ptfxOrigin.x;
                ptfx.y = dco.ptfxCurrent().y + ptfxOrigin.y;
              }
              else
              {
                // DC's CP is in logical coords; we have to transform it to device
                // space and mark that we'll be updating the CP in device space:

                dco.pdc->vValidatePtfxCurrent();
                dco.pdc->vInvalidatePtlCurrent();

                if (xo.bTranslationsOnly())
                {
                    ptfx.x = LTOFX(dco.ptlCurrent().x) + xo.fxDx();
                    ptfx.y = LTOFX(dco.ptlCurrent().y) + xo.fxDy();
                }
                else if (xo.bScale())
                {
                    ptfx.x = xo.fxFastX(dco.ptlCurrent().x);
                    ptfx.y = xo.fxFastY(dco.ptlCurrent().y);
                }
                else
                {
                    xo.bXform((POINTL *) &dco.ptlCurrent(), &ptfx, 1);
                }

                dco.ptfxCurrent() = ptfx;
                ptfx += ptfxOrigin;
              }
            }
            else
            {
              //
              // The reference point is passed in.  Transform it to device coords.
              //

              if (xo.bTranslationsOnly())
              {
                ptfx.x = LTOFX(x) + xo.fxDx() + ptfxOrigin.x;
                ptfx.y = LTOFX(y) + xo.fxDy() + ptfxOrigin.y;
              }
              else if (xo.bScale())
              {
                ptfx.x = xo.fxFastX(x) + ptfxOrigin.x;
                ptfx.y = xo.fxFastY(y) + ptfxOrigin.y;
              }
              else
              {
                ptfx.x = x;
                ptfx.y = y;
                xo.bXform((POINTL *) &ptfx,&ptfx,1);
                ptfx += ptfxOrigin;
              }
            }

            // The STROBJ will now compute the text alignment, character positions,
            // and TextBox.

            to.vInit
            (
                pwsz,
                cwc,
                dco,
                rfo,
                xo,
                (LONG *) pdx,
                bPdy,
                dco.pdc->lEscapement(),   // Only read this after RFONTOBJ!
                dco.pdc->lTextExtra(),
                dco.pdc->lBreakExtra(),
                dco.pdc->cBreak(),
                ptfx.x,ptfx.y,
                flControl,
                (LONG *) NULL,
                pvBuffer,
                dwCodePage
            );

            if (to.bValid())
            {
              // Compute the bounding box and the background opaquing area.  The
              // parallelogram aptfxBackground is only computed when it's complex.

              bComplexBackground = to.bOpaqueArea(aptfxBackground,
                                                  &to.rclBkGround);

// This hack, due to filtering needs to be put in textgdi.cxx
// filtering leeks color one pixel to the left and one pixel to the right
// The trouble with it is that is it going to add a pixel on each side
// to the text background when text is painted in the OPAQUE mode.


              if (rfo.pfo()->flFontType & FO_CLEARTYPE_X)
              {
                   to.rclBkGround.left--;
                   to.rclBkGround.right++;
              }

              if (to.bLinkedGlyphs())
              {
                to.vEudcOpaqueArea(aptfxBackground, bComplexBackground);
              }

              // Accumulate the touched area to the exclusion rect.

              rclExclude += to.rclBkGround;

              // Make notes of exactly what drawing needs to be done.

              if (ulBkMode == OPAQUE)
              {
                if (bComplexBackground)
                {
                  flState |= TS_DRAW_BACKGROUND_PGM;
                }
                else
                {
                  prclBackground = &to.rclBkGround; // No TS_ bit since this gets
                }                                   // passed directly to DrvTextOut.
              }

              // In a few bizarre cases the STROBJ can have an empty text rectangle
              // we don't want to call DrvTextOut in those case but still need
              // to worry about the opaque rectangle.

              BOOL bEmptyTextRectangle = ((ERECTL *)&(to.rclBkGround))->bEmpty();

              // Attempt to combine the rectangles.  Even in transparent mode we should
              // attempt to send an opaquing rectangle to DrvTextOut in prclBackground.

              if ((flState & TS_DRAW_OPAQUE_RECT)     &&
                  (rclInput.bContain(to.rclBkGround)) &&
                  (!bEmptyTextRectangle) )
              {
                  prclBackground = &rclInput;
                  flState &= ~TS_DRAW_OPAQUE_RECT;
              }

              if ( ((prclBackground != NULL ) && !((ERECTL *)prclBackground)->bEmpty() ) ||
                   ((prclBackground == NULL) && !bEmptyTextRectangle) )
              {
                  flState |= TS_DRAW_TEXT;
              }

              if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
              {
                  if ((prclExtraRects = to.prclExtraRects()) == NULL)
                  {
                      flState |= TS_DRAW_COMPLEX_UNDERLINES;
                  }
                  else // include extra rectangles into the touched area:
                  {
                      ERECTL *eprcl = (ERECTL *) prclExtraRects;

                      for (; !eprcl->bEmpty(); eprcl++)
                      {
                            rclExclude += *eprcl;
                      }
                  }
              }

              // Accelerate the clipping case when it's irrelevant.  (I'm concerned
              // that a spreadsheet might tell us to clip to a cell, even though the
              // string lies completely within.)

              if (flOpts & ETO_CLIPPED)
              {
                if (rclInput.bContain(rclExclude))
                {
                  flOpts &= ~ETO_CLIPPED;
                }
                else
                {
                  rclExclude *= rclInput;
                }
              }
            }
            else // if (to.bValid())
            {
              flState = 0;
            }
          }
          else // if (rfo.bValid())
          {
            flState = 0;
          }
        } // if (cwc)

        if (flControl & TA_UPDATECP)
        {
          dco.ptfxCurrent().x += to.ptfxAdvance().x;
          dco.ptfxCurrent().y += to.ptfxAdvance().y;
        }

        //
        // Draw the text into a path if we're in a path bracket.
        //

        if (dco.pdc->bActive())
        {
          //
          // We fail this call if we are asked to CLIP while in a path bracket.
          //

          if (flOpts & ETO_CLIPPED)
          {
            flState = 0;
          }

          XEPATHOBJ po(dco);

          if (po.bValid())
          {
            // Draw the various background shapes.

            if (flState & TS_DRAW_OPAQUE_RECT)
            {
              if (!bAddRectToPath(po,&rclInput))
              {
                flState = 0;
              }
            }

            if (flState & TS_DRAW_OPAQUE_PGM)
            {
              if (!po.bAddPolygon(XFORMNULL,(POINTL *) &ptfxInput[0],4))
              {
                flState = 0;
              }
            }

            if (flState & TS_DRAW_BACKGROUND_PGM)
            {
              if (!po.bAddPolygon(XFORMNULL,(POINTL *) aptfxBackground,4))
              {
                flState = 0;
              }
            }

            BOOL bNeedUnflattend = FALSE;

            //
            // Draw the background rect, text, and extra rectangles.
            //

            if (flState & TS_DRAW_TEXT)
            {
              //
              // Draw a background rectangle.
              //

              if ((prclBackground == (RECTL *) NULL) ||
                  bAddRectToPath(po,prclBackground))
              {
                //
                // Draw the text.
                //

                bNeedUnflattend =
                    ( dco.flGraphicsCaps() & GCAPS_BEZIERS ) ? FALSE : TRUE;

                if (!to.bTextToPath(po, dco, bNeedUnflattend))
                {
                  flState = 0;
                }
                else
                {
                  //
                  // Draw extra rectangles.
                  //

                  if (prclExtraRects != (ERECTL *) NULL)
                  {
                    ERECTL *eprcl = (ERECTL *) prclExtraRects;

                    for (; !eprcl->bEmpty(); eprcl++)
                    {
                      if (!bAddRectToPath(po,eprcl))
                      {
                        flState = 0;
                        break;
                      }
                    }
                  }
                }
              } // if ((prclBackground==0)||bAddRectToPath(po,prclBackground))
            } // if (flState & TS_DRAW_TEXT)

            //
            // Handle complex cases of strikeout and underlines.
            //

            if (flState & TS_DRAW_COMPLEX_UNDERLINES)
            {
              if (!to.bExtraRectsToPath(po, bNeedUnflattend))
              {
                flState = 0;
              }
            }
          } // if (po.bValid())
        }
        else // if (dco.pdc->bActive())
        {
          //
          // If there's nothing to do, get out now.
          //

          if (!rclExclude.bEmpty())
          {
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.

            if (dco.fjAccum())
            {
              // Use a temporary exclusion rect in device coordinates.

              ERECTL rclExcludeDev;
              rclExcludeDev.left   = rclExclude.left   - ptlOrigin.x;
              rclExcludeDev.right  = rclExclude.right  - ptlOrigin.x;
              rclExcludeDev.top    = rclExclude.top    - ptlOrigin.y;
              rclExcludeDev.bottom = rclExclude.bottom - ptlOrigin.y;
              dco.vAccumulate(*((ERECTL *) &rclExcludeDev));
            }

            // Compute the clipping complexity and maybe reduce the exclusion rectangle.
            // It appears that a 10pt script font (on a screen DC) can be outside of
            // the bounds of the background rectangle.  We have a situation where
            // an app creates a memory DC exactly the size of the bouding rectangle
            // and then draws a vector font to it.  We compute the cliping to be
            // trivial since we think the vector string fits completely inside
            // the bounds of the DC and blow up later in the code. Rather than tweak
            // the vector font driver at this point in the game I am going to force
            // cliping to be set for vector fonts.  Later on we should figure out
            // why this is happening and fix the vector font driver. [gerritv]

            // Under some xform, the text might be "stretched" to some extent length
            // and it will go to the bSimpleFill path code. Force clipping for this
            // case, otherwise we might hit the AV since recl's generated from the
            // pathobj might be a pixel off than the clip rclBounds <seen in stress>.

            ECLIPOBJ co(dco.prgnEffRao(),rclExclude,
                        bPathFont || (flOpts & ETO_CLIPPED) ? CLIP_FORCE :
                                                                  CLIP_NOFORCE);
            rclExclude = co.erclExclude();

            // Check the destination which is reduced by clipping.

            if (!co.erclExclude().bEmpty())
            {
              SURFACE *pSurf = dco.pSurface();

              if (pSurf != NULL)
              {
                PDEVOBJ pdo(pSurf->hdev());
                XEPALOBJ palDest(pSurf->ppal());
                XEPALOBJ palDestDC(dco.ppal());

                // Get the foreground and opaque brushes

                FLONG flCaps = dco.flGraphicsCaps();
                EBRUSHOBJ *peboText = dco.peboText();
                EBRUSHOBJ *peboBackground = dco.peboBackground();

                BOOL bDitherText = FALSE;
                if ( flCaps & GCAPS_ARBRUSHTEXT )
                {
                  // Even if a printer driver sets GCAPS_ARBRUSHTEXT, we
                  // can't allow vector fonts to be dithered.

                  bDitherText = !bIsVectorFont;

                  // We always dirty the text brush if ARBRUSHTEXT is set to
                  // catch the cases where we transition between vector and
                  // non-vector fonts but keep the same brush -- if we didn't
                  // do this, we might try to use a cached, dithered brush
                  // after switching from a TrueType font to a vector font.

                  dco.ulDirtyAdd(DIRTY_TEXT);

                  // Get through the are-you-really-dirty check in vInitBrush:

                  peboText->vInvalidateUniqueness();
                }

                if ( dco.bDirtyBrush(DIRTY_TEXT|DIRTY_BACKGROUND) )
                {
                  if ( dco.bDirtyBrush(DIRTY_TEXT) )
                  {
                    peboText->vInitBrush(dco.pdc,
                                         gpbrText,
                                         palDestDC,
                                         palDest,
                                         pSurf,
                                         bDitherText);
                  }

                  if ( dco.bDirtyBrush(DIRTY_BACKGROUND) )
                  {
                    peboBackground->vInitBrush(dco.pdc,
                                     gpbrBackground,
                                     palDestDC, palDest, pSurf,
                                     (flCaps & GCAPS_ARBRUSHOPAQUE) ? TRUE : FALSE);
                  }
                  dco.vCleanBrush(DIRTY_TEXT|DIRTY_BACKGROUND);
                }

                // exclude the pointer

                DEVEXCLUDEOBJ dxo(dco,&co.erclExclude(),&co);

                //
                // Draw background shapes that are too complex for DrvTextOut.
                //

                POINTL *pptlBO = &dco.pdc->ptlFillOrigin();

                // There's an extra layer of conditional here so that simple text can just
                // jump over it all.

                if (flState &
                    (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                {
                  if ((flState & TS_DRAW_OPAQUE_RECT) && !rclInput.bEmpty())
                  {
                    // intersect the dest rect with the clip rect and set it in co

                    // we can only get away with touching co.rclBounds after
                    // the ECLIPOBJ constructor because of two reasons:
                    // a) the target rectangle passed to bitblt is contained in the
                    //    original bounds set by ECLIPOBJ, being the intersection
                    //    of the origianal bounds with THE intended target rectangle.
                    // b) clipping complexity may have changed when we changed
                    //    co.erclExclude, but it only could have gotten simpler,
                    //    so at worst in those rare situations we would not go
                    //    through the optimal code path.
                    // By changing clipping bounds we accomplish that no intersection
                    // of the target rectangle with clipping region rectangle is emtpy
                    // relieving the driver of extra work [bodind]

                    co.erclExclude().left   = max(rclExclude.left,rclInput.left);
                    co.erclExclude().right  = min(rclExclude.right,rclInput.right);

                    co.erclExclude().top    = max(rclExclude.top,rclInput.top);
                    co.erclExclude().bottom = min(rclExclude.bottom,rclInput.bottom);

                    // if not clipped, Just paint the rectangle.

                    if ((co.erclExclude().left < co.erclExclude().right) &&
                        (co.erclExclude().top < co.erclExclude().bottom))
                    {
                      // Inc target surface uniqueness

                        INC_SURF_UNIQ(pSurf);

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboBackground,
                                      pptlBO,
                                      0x0000f0f0);
                    }

                    co.erclExclude() = rclExclude;
                  }

                  if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                  {
                    PATHMEMOBJ po;

                    if (po.bValid())
                    {
                      if (flState & TS_DRAW_OPAQUE_PGM)
                      {
                        if (!po.bAddPolygon(XFORMNULL,(POINTL *) &ptfxInput[0],4))
                        {
                          flState = 0;
                        }
                      }

                      if (flState & TS_DRAW_BACKGROUND_PGM)
                      {
                        if (!po.bAddPolygon(XFORMNULL,(POINTL *) aptfxBackground,4))
                        {
                          flState = 0;
                        }
                      }

                      if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                      {
                        if (!po.bTextOutSimpleFill(dco,
                                                   rfo,
                                                   &pdo,
                                                   pSurf,
                                                   &co,
                                                   (BRUSHOBJ *)peboBackground,
                                                   pptlBO,
                                                   (R2_COPYPEN << 8) | R2_COPYPEN,
                                                   WINDING))
                        {
                          flState = 0;
                        }
                      } // if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                    } // if (po.bValid())
                  } // if (flState & (TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))
                } // if (flState & (TS_DRAW_OPAQUE_RECT | TS_DRAW_OPAQUE_PGM | TS_DRAW_BACKGROUND_PGM))

                //
                // Draw the background rect, text, and extra rectangles.
                //

                if (flState & TS_DRAW_TEXT)
                {
                    ERECTL *prclSimExtra = NULL;

                    // Prepare for a vector font simulation.  Note that we'll also need to
                    // simulate the background and extra rectangles.

                    if (bPathFont)
                    {
                        flCaps &= ~(GCAPS_OPAQUERECT);
                        flState |= (rfo.bReturnsOutlines()) ? TS_DRAW_OUTLINE_FONT:TS_DRAW_VECTOR_FONT;
                    }

                    // Simulate a background rectangle.

                    if ((prclBackground != (RECTL *) NULL) &&
                        !(flCaps & GCAPS_OPAQUERECT))
                    {
                      // intersect the dest rect with the clip rect and set it in co

                      // we can only get away with touching co.rclBounds after
                      // the ECLIPOBJ constructor because of two reasons:
                      // a) the target rectangle passed to bitblt is contained in the
                      //    original bounds set by ECLIPOBJ, being the intersection
                      //    of the origianal bounds with THE intended target rectangle.
                      // b) clipping complexity may have changed when we changed
                      //    co.erclExclude, but it only could have gotten simpler,
                      //    so at worst in those rare situations we would not go
                      //    through the optimal code path.
                      // By changing clipping bounds we accomplish that no intersection
                      // of the target rectangle with clipping region rectangle is emtpy
                      // relieving the driver of extra work [bodind]

                      co.erclExclude().left   = max(rclExclude.left,prclBackground->left);
                      co.erclExclude().right  = min(rclExclude.right,prclBackground->right);

                      co.erclExclude().top    = max(rclExclude.top,prclBackground->top);
                      co.erclExclude().bottom = min(rclExclude.bottom,prclBackground->bottom);

                      // if not clipped, Just paint the rectangle.

                      if ((co.erclExclude().left < co.erclExclude().right) &&
                          (co.erclExclude().top < co.erclExclude().bottom))
                      {
                      // Inc target surface uniqueness

                        INC_SURF_UNIQ(pSurf);

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboBackground,
                                      pptlBO,
                                      0x0000f0f0);
                      }

                      co.erclExclude() = rclExclude;
                      prclBackground = NULL;
                    }

                    // Prepare for the extra rectangle simulation.
                    // For TTY drivers, we need to pass prclExtraRects
                    // to the DrvTextOut call.

                    if ((prclExtraRects != (ERECTL *) NULL) &&
                        (pdo.ulTechnology() != DT_CHARSTREAM))
                    {
                      prclSimExtra = (ERECTL *) prclExtraRects;
                      prclExtraRects = NULL;
                    }

                    // Draw the text.

                    if (flState & TS_DRAW_VECTOR_FONT)
                    {

#ifdef FE_SB
                        if( to.bLinkedGlyphs() )
                        {
                            if( ! bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    (RECTL*) NULL,
                                    (RECTL*) NULL,
                                    (BRUSHOBJ*) peboText,
                                    (BRUSHOBJ*) peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    dco.flGraphicsCaps(),
                                    &rclExclude
                                   ))
                            {
                                flState = 0;
                            }
                        }
                        else
                        {
#endif

                        PATHMEMOBJ po;
                        if ((!po.bValid())        ||
                            (!to.bTextToPath(po, dco)) ||
                            (!po.bTextOutSimpleStroke1(dco,
                                                       rfo,
                                                       &pdo,
                                                       pSurf,
                                                       &co,
                                                       (BRUSHOBJ *)peboText,
                                                       pptlBO,
                                                       (R2_COPYPEN | (R2_COPYPEN << 8)))))
                        {
                          flState = 0;
                        }
                      }
                    }
                    else // if (flState & TS_DRAW_VECTOR_FONT)
                    {
                      if (pSurf->pdcoAA)
                      {
                          RIP("pdcoAA != 0\n");
                          pSurf->pdcoAA = 0;    // let the free build run
                      }

                      pfnTextOut = pSurf->pfnTextOut();

                      // If the pointer to the TextOut function points to SpTextOut then
                      // we know that AntiAliased text can be handled and we can skip
                      // the funny business in the else clause

		      if (pfnTextOut == SpTextOut)
                      {
			if (rfo.prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X))
                        {
                            pSurf->pdcoAA = &dco;
                        }
                      }
                      else
                      {

                        if
                        (
                            (rfo.prfnt->fobj.flFontType & FO_GRAY16) &&
                            (!(dco.flGraphicsCaps() & GCAPS_GRAY16) ||
                              (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X))
                        )
                        {

                          // Inform SpTextOut that this call came from GreExtTextOutW
                          // for the purpose of rendering anti aliased text on a device
                          // that does not support it. Remember to set this to zero
                          // before releasing the surface to other users.

			  if (pfnTextOut != EngTextOut)
			      pSurf->pdcoAA = &dco;

                          pfnTextOut = SpTextOut;
                        }
                      } // if (pfnTextOut == SpTextOut) else

                      if (flState & TS_DRAW_OUTLINE_FONT)
                      {

#ifdef FE_SB
                        if( to.bLinkedGlyphs() )
                        {
                            if( ! bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    (RECTL*) NULL,
                                    (RECTL*) NULL,
                                    (BRUSHOBJ*) peboText,
                                    (BRUSHOBJ*) peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    dco.flGraphicsCaps(),
                                    &rclExclude
                                   ))
                            {
                                flState = 0;
                            }
                        }
                        else
                        {
#endif

                        PATHMEMOBJ po;
                        if ((!po.bValid())        ||
                            (!to.bTextToPath(po, dco)) ||
                            (  ( po.cCurves > 1 ) &&
                               !po.bTextOutSimpleFill(dco,
                                                      rfo,
                                                      &pdo,
                                                      pSurf,
                                                      &co,
                                                      (BRUSHOBJ *)peboText,
                                                      pptlBO,
                                                      (R2_COPYPEN | (R2_COPYPEN << 8)),
                                                      WINDING)))
                        {
                          flState = 0;
                        }
                        }
                      }
                      else // if (flState & TS_DRAW_OUTLINE_FONT)
                      {
                        if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                        {
                          INC_SURF_UNIQ(pSurf);

                          // Unfortunately, many drivers destroy the coordinates in our
                          // GLYPHPOS array.  This means that any complex underlining has
                          // to be calculated now.

                          PATHMEMOBJ po;

                          if ((!po.bValid())               ||
                              (!to.bExtraRectsToPath(po))  ||
#ifdef FE_SB
                                    ((to.bLinkedGlyphs() ) ?
                                      (!bProxyDrvTextOut
                                        (
                                            dco,
                                            pSurf,
                                            to,
                                            co,
                                            prclExtraRects,
                                            prclBackground,
                                            peboText,
                                            peboBackground,
                                            pptlBO,
                                            rfo,
                                            (PDEVOBJ *) NULL,
                                            (FLONG) 0L,
                                            &rclExclude
                                        )) :
#endif

                              (!((*pfnTextOut)
                                      (pSurf->pSurfobj(),
                                       (STROBJ *) &to,
                                       rfo.pfo(),
                                       &co,
                                       prclExtraRects,
                                       prclBackground,
                                       (BRUSHOBJ *)peboText,
                                       (BRUSHOBJ *)peboBackground,
                                       pptlBO,
                                       mix)))

                              ) ||
                              (!po.bTextOutSimpleFill(dco,
                                                      rfo,
                                                      &pdo,
                                                      pSurf,
                                                      &co,
                                                      (BRUSHOBJ *)peboText,
                                                      pptlBO,
                                                      (R2_COPYPEN | (R2_COPYPEN << 8)),
                                                      WINDING)))
                          {
                              flState = 0;
                          }

                          flState &= ~TS_DRAW_COMPLEX_UNDERLINES;
                        } // if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                        else
                        {
                          // Inc target surface uniqueness

                          INC_SURF_UNIQ(pSurf);

#ifdef FE_SB
                            if( to.bLinkedGlyphs() )
                            {
                                if( !bProxyDrvTextOut
                                  (
                                    dco,
                                    pSurf,
                                    to,
                                    co,
                                    prclExtraRects,
                                    prclBackground,
                                    peboText,
                                    peboBackground,
                                    pptlBO,
                                    rfo,
                                    &pdo,
                                    (FLONG) 0,
                                    &rclExclude
                                  ))
                                {
                                    flState = 0;
                                }
                            }
                            else
                            {
#endif
                                rfo.PreTextOut(dco);
                                if (!(*pfnTextOut)(pSurf->pSurfobj(),
                                                              (STROBJ *) &to,
                                                              rfo.pfo(),
                                                              &co,
                                                              prclExtraRects,
                                                              prclBackground,
                                                              (BRUSHOBJ *)peboText,
                                                              (BRUSHOBJ *)peboBackground,
                                                              pptlBO,
                                                              mix))
                                {
                                  flState = 0;
                                }
                                rfo.PostTextOut(dco);
                            }
                        } // if (flState & TS_DRAW_COMPLEX_UNDERLINES) else
                      } // if (flState & TS_DRAW_OUTLINE_FONT) else

                      ASSERTGDI(pSurf != NULL, "pSurf null after EngTextOut");
                      /* we have seen pSurf being null with privates binaries */
                      if (pSurf != NULL)
                          pSurf->pdcoAA = 0;    // clear AA state;

                    } // if (flState & TS_DRAW_VECTOR_FONT) else

                    // Simulate extra rectangles.

                    if (prclSimExtra != (ERECTL *) NULL)
                    {
                      ERECTL erclOrg;
                      erclOrg = co.erclExclude();

                      // Inc target surface uniqueness

                      INC_SURF_UNIQ(pSurf);

                      for (; !prclSimExtra->bEmpty(); prclSimExtra++)
                      {
                        // intersect the dest rect with the clip rect and set it in co

                        co.erclExclude().left   = max(erclOrg.left,prclSimExtra->left);
                        co.erclExclude().right  = min(erclOrg.right,prclSimExtra->right);

                        if (co.erclExclude().left >= co.erclExclude().right)
                            continue;

                        co.erclExclude().top    = max(erclOrg.top,prclSimExtra->top);
                        co.erclExclude().bottom = min(erclOrg.bottom,prclSimExtra->bottom);

                        if (co.erclExclude().top >= co.erclExclude().bottom)
                        {
                            continue;
                        }

                        //
                        // not completely clipped, do the bitblt
                        //

                        TextOutBitBlt(pSurf,
                                      rfo,
                                      (SURFOBJ *)  NULL,
                                      (SURFOBJ *)  NULL,
                                      &co,
                                      NULL,
                                      &co.rclBounds,
                                      (POINTL *)  NULL,
                                      (POINTL *)  NULL,
                                      (BRUSHOBJ *)peboText,
                                      pptlBO,
                                      0x0000f0f0);
                      }

                      co.erclExclude() = erclOrg;
                    } // if (prclSimExtra != (ERECTL *) NULL)
                } // if (flState & TS_DRAW_TEXT)

                //
                // Handle complex cases of strikeout and underlines.
                //

                if (flState & TS_DRAW_COMPLEX_UNDERLINES)
                {

                  PATHMEMOBJ po;

                  if (po.bValid())
                  {
                    if (!to.bExtraRectsToPath(po) ||
                        !po.bTextOutSimpleFill(dco,
                                               rfo,
                                               &pdo,
                                               pSurf,
                                               &co,
                                               (BRUSHOBJ *)peboText,
                                               pptlBO,
                                               (R2_COPYPEN | (R2_COPYPEN << 8)),
                                               WINDING))
                    {
                      flState = 0;
                    }
                  }
                  else // if (po.bValid())
                  {
                    flState = 0;
                  }

                } // if (flState & TS_DRAW_COMPLEX_UNDERLINES)

              } // if (pSurf != NULL)

            } // if (!co.erclExclude().bEmpty())

          } // if (!rclExclude.bEmpty())
        } // else if (dco.pdc->bActive())
    }
    else // if (((flOpts == 0) ||
         // ((prcl != (RECT *) NULL) &&
         // ((flOpts & ~(ETO_CLIPPED | ETO_OPAQUE)) == 0)))
         // && !(dco.pdc->bActive() && (flOpts & ETO_CLIPPED)))
    {
      WARNING1("Invalid flags for ExtTextOut.\n");
      flState = 0;
    }

  }
  else
  {
    flState = 0;
  }

  //
  // flState is filled with all the stuff we need to do.
  // If it is 0 we failed.
  //

  // return(flState /* != 0 */);
  return(flState != 0);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextExtentW
*
* Computes the size of the text box in logical coordinates.  The text box
* has sides which are parallel to the baseline of the text and its ascent
* direction.  The height is measured in the ascent direction.  The width
* is measured in the baseline direction.  This definition does not change
* for transformed text.
*
* History:
*  Sat 14-Mar-1992 05:39:04 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define PDXNULL (LONG *) NULL

BOOL GreGetTextExtentW(
    HDC    hdc,    // device context
    LPWSTR pwsz,   // pointer to a UNICODE text string
    int    cwc,    // Count of chars.
    PSIZE  pSize,  // address to return the dimensions of the string to
    UINT   fl      // internal flags
)
{
    BOOL bRet = FALSE;

    if (cwc == 0)
    {
        //
        // Nothing to do, but we do not fail.
        //

        pSize->cx = 0;
        pSize->cy = 0;
        bRet = TRUE;
    }
    else
    {
        //
        // Lock the DC and set the new attributes.
        //

        DCOBJ dco(hdc);

        if (dco.bValid())
        {
            RFONTOBJ rfo(dco,FALSE, (fl & GGTE_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);

            if (rfo.bValid())
            {
            // fix up glyph indices for bitmap fonts

                if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
                    rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);

                // If we have (escapement != orientation) we return the extents of the
                // bounding parallelogram.  This is not Windows compatible, but then
                // Windows can't draw it either.

                LONG lEsc = dco.pdc->lEscapement(); // Only read this after RFONTOBJ!

                if ((lEsc != (LONG)rfo.ulOrientation()) &&
                    ((rfo.iGraphicsMode() != GM_COMPATIBLE) ||
                        (rfo.prfnt->flInfo & FM_INFO_TECH_STROKE)))
                {
                    //
                    // Get the transform from the DC.
                    //

                    EXFORMOBJ xo(dco,WORLD_TO_DEVICE);

                    //
                    // The STROBJ will now compute the text alignment, character positions,
                    // and TextBox.
                    //


                    ESTROBJ to(pwsz,
                               cwc,
                               dco,
                               rfo,
                               xo,
                               PDXNULL,FALSE,
                               lEsc,
                               dco.pdc->lTextExtra(),
                               dco.pdc->lBreakExtra(),
                               dco.pdc->cBreak(),
                               0,
                               0,
                               0,
                               PDXNULL);

                    if (to.bValid())
                    {
                        //
                        // Transform the TextBox to logical coordinates.
                        //

                        bRet = to.bTextExtent(rfo,lEsc,pSize);

                    }
                }
                else
                {
                    //
                    // At this point we have (escapement == orientation) so we can just run
                    // some pretty trivial code.
                    //

                    bRet = rfo.bTextExtent(dco,
                                           pwsz,
                                           cwc,
                                           lEsc,
                                           dco.pdc->lTextExtra(),
                                           dco.pdc->lBreakExtra(),
                                           dco.pdc->cBreak(),
                                           fl,
                                           pSize);

                    //
                    // finally if this is compatible mode and a vector font, do win31
                    // crazyness about text extent: "rotate" cx and cy by esc vector.
                    // This is totally crazy, and is different from what win31 is doing
                    // for tt, but it turns out that quatro pro for windows has figured
                    // this out and that they use this "feature" [bodind]
                    //

                    if (bRet                                        &&
                        lEsc                                        &&
                        (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                        !dco.pdc->bUseMetaPtoD()                    &&
                        (rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
                    {
                        EVECTORFL evfl((LONG)pSize->cx, (LONG)pSize->cy);
                        EFLOATEXT efAngle = lEsc;
                        efAngle /= (LONG)10;

                        MATRIX mx;

                        mx.efM11 = efCos(efAngle);
                        mx.efM11.vAbs();
                        mx.efM22 = mx.efM11;

                        mx.efM12 = efSin(efAngle);
                        mx.efM12.vAbs();
                        mx.efM21 = mx.efM12;
                        mx.efDx.vSetToZero();
                        mx.efDy.vSetToZero();

                        EXFORMOBJ xoExt(&mx,COMPUTE_FLAGS | XFORM_FORMAT_LTOL);

                        if ((bRet = xoExt.bXform(evfl)) != FALSE)
                        {
                            evfl.x.vAbs();
                            evfl.y.vAbs();
                            bRet = evfl.bToPOINTL(*(POINTL *)pSize);
                        }
                    }
                }
            }
            else
            {
                WARNING("gdisrv!GreGetTextExtentW(): could not lock HRFONT\n");
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bTextExtent (pwsz,lExtra,lBreakExtra,cBreak,cc,fl,psizl)       *
*                                                                          *
* A quick function to compute text extents on the server side.  Only       *
* handles the case where (escapement==orientation).  Call the ESTROBJ      *
* version for the other very hard case.                                    *
*                                                                          *
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  OK, so it's a blatant ripoff of my bComputeTextExtent from    *
* the client side.  Fine.                                                  *
\**************************************************************************/

#define CTE_BATCH 82

BOOL RFONTOBJ::bTextExtent(
    XDCOBJ     &dco,
    LPWSTR    pwsz,
    int       cc,
    LONG      lEsc,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    UINT      fl,
    SIZE     *psizl
)
{
    LONG      fxBasicExtent;
    int       ii, cNoBackup;
    FIX       fxCharExtra = 0;
    FIX       fxBreakExtra;
    FIX       fxExtra = 0;
    GLYPHPOS  agpos[CTE_BATCH];  // Default set of GLYPHPOS structures.

// Compute the basic extent.  Batch the glyphs through our array.

    if (lExtra)
    {
       fxCharExtra = lCvt(efWtoDBase(),lExtra);
       cNoBackup = 0;
    }

#ifndef FE_SB
    if(lCharInc() == 0)
#endif
    {
        fxBasicExtent = 0;

    // NOTE PERF: This is the loop that PaulB would like to optimize with a
    // special cache access function.  Why create the GLYPHPOS
    // array? [chuckwh]

        int    cBatch;
        int    cLeft = cc;
        WCHAR *pwc = pwsz;

        while (cLeft)
        {
            cBatch = cLeft;
            if (cBatch > CTE_BATCH)
                cBatch = CTE_BATCH;

        // Get the glyph data.

            if (!bGetGlyphMetrics(cBatch,agpos,pwc,&dco))
                return(FALSE);

        // Sum the advance widths.

            for (ii=0; ii<cBatch; ii++)
            {
                fxBasicExtent += ((EGLYPHPOS *) &agpos[ii])->pgd()->fxD;

            // the layout code won't allow lExtra to backup a character behind
            // its origin so keep track of the number of times this happens

                if( ( fxCharExtra < 0 ) &&
                    ( ((EGLYPHPOS *) &agpos[ii])->pgd()->fxD + fxCharExtra <= 0 ) )
                {
                    cNoBackup += 1;
                }
            }

            cLeft -= cBatch;
            pwc   += cBatch;

        }
    }

// Adjust for CharExtra.

    if (lExtra)
    {
        PDEVOBJ pdo(prfnt->hdevConsumer);
        ASSERTGDI(pdo.bValid(), "bTextExtentRFONTOBJ(): PDEVOBJ constructor failed\n");

        if ( (fl & GGTE_WIN3_EXTENT) && pdo.bDisplayPDEV()
             && (!(prfnt->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lExtra > 0) ? cc : (cc - 1));
        else
            fxExtra = fxCharExtra * ( cc - cNoBackup );
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
    // Track down the break character.

        PFEOBJ pfeo(ppfe());
        IFIOBJ ifio(pfeo.pifi());

    // Compute the extra space in device units.

        fxBreakExtra = lCvt(efWtoDBase(),lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + fxBreak() + fxCharExtra < 0)
            fxBreakExtra = -(fxBreak() + fxCharExtra);

    // Add it up for all breaks.

        WCHAR wcBreak = (fl & GGTE_GLYPH_INDEX)?
                        (WCHAR)hgBreak():ifio.wcBreakChar();

        WCHAR *pwc = pwsz;
        for (ii=0; ii<cc; ii++)
        {
            if (*pwc++ == wcBreak)
                fxExtra += fxBreakExtra;
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += lOverhang() << 4;

// Transform the result to logical coordinates.

    if (efDtoWBase_31().bIs1Over16())
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(efDtoWBase_31(),fxBasicExtent);

    if (efDtoWAscent_31().bIs1Over16())
        psizl->cy = lMaxHeight();
    else
        psizl->cy = lCvt(efDtoWAscent_31(),lMaxHeight() << 4);


#ifdef FE_SB
    if( gbDBCSCodePage &&                   // Only in DBCS system locale
        (iGraphicsMode() == GM_COMPATIBLE)  && // We are in COMPAPIBLE mode
        !(flInfo() & FM_INFO_ARB_XFORMS) && // The driver couldnt do arbitrary rotations
        !(flInfo() & FM_INFO_TECH_STROKE) && // The driver is not vector driver
         (flInfo() & FM_INFO_90DEGREE_ROTATIONS) && // Driver does 90 degree rotations
         (lEsc == 900L || lEsc == 2700L)  // Current font Escapemant is 900 or 2700
      )
    {
        LONG lSwap = psizl->cx;
        psizl->cx  = psizl->cy;
        psizl->cy  = lSwap;
    }
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* GreSetTextJustification (hdc,lBreakExtra,cBreak)                         *
*                                                                          *
* Sets the amount of extra spacing we'd like to add for each break (space) *
* character to (lBreakExtra/cBreak) in logical coordinates.                *
*                                                                          *
* History:                                                                 *
*  Fri 13-Mar-1992 02:25:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL APIENTRY
NtGdiSetTextJustification(
    HDC hdc,
    int lBreakExtra, // Space in logical units to be added to the line.
    int cBreak       // Number of break chars in the line.
)
{
    BOOL bRet;

    DCOBJ dco(hdc);

    if ((bRet = dco.bValid()) != FALSE)
    {
        dco.pdc->lBreakExtra(lBreakExtra);
        dco.pdc->cBreak(cBreak);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextExtentExW                                                 *
*                                                                          *
* Determines the number of characters in the input string that fit into    *
* the given max width (with the widths computed along the escapement       *
* vector).  The partial widths (the distance from the string origin to     *
* a given character with the width of that character included) for each of *
* character.                                                               *
*                                                                          *
* Returns:                                                                 *
*   TRUE if successful, FALSE otherwise.                                   *
*                                                                          *
* History:                                                                 *
*  Sat 14-Mar-1992 06:03:32 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new ESTROBJ technology.                                     *
*                                                                          *
*  06-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GreGetTextExtentExW(
    HDC     hdc,            // device context
    LPWSTR  pwsz,           // pointer to a UNICODE text string
    COUNT   cwc,            // count of WCHARs in the string
    ULONG   dxMax,          // maximum width to return
    COUNT  *pcChars,        // number of chars that fit in dxMax
    PULONG  pdxOut,         // offset of each character from string origin
    LPSIZE  pSize,          // return height and width of string
    FLONG   fl
)
{
    BOOL bRet = FALSE;
    PVOID pv;

#ifdef DUMPCALL
    DbgPrint("\nGreGetTextExtentExW("                       );
    DbgPrint("\n    HDC         hdc     = %-#8lx\n", hdc    );
    DbgPrint("\n    LPWSTR      pwsz    = %-#8lx -> \"%ws\"\n", pwsz ,pwsz  );
    DbgPrint("\n    COUNT       cwc     = %d\n",     cwc    );
    DbgPrint("\n    ULONG       dxMax   = %-#8lx\n", dxMax  );
    DbgPrint("\n    COUNT      *pcChars = %-#8lx\n", pcChars);
    DbgPrint("\n    PULONG      pdxOut  = %-#8lx\n", pdxOut );
    DbgPrint("\n    LPSIZE      pSize   = %-#8lx\n", pSize  );
    DbgPrint("\n    )\n"                                    );
#endif

// Parameter validation.

    if ( ((pwsz == (LPWSTR) NULL) && (cwc != 0))
         || (pSize == (LPSIZE) NULL) )
    {
        WARNING("gdisrv!GreGetTextExtentExW(): invalid parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Early out.

    if (cwc == 0L)              // Nothing to do, but we do not fail.
    {
        if ( pcChars != (COUNT *) NULL )
        {
            *pcChars = 0;
        }

        return(TRUE);
    }

// Lock the DC and set the new attributes.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("gdisrv!GreGetTextExtentExW(): invalid HDC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }
    else
    {
    // Get the transform.

        EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

    // Realize font and get the simulation flags and escapement.

        RFONTOBJ rfo(dco, FALSE, (fl & GTEEX_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
        if (!rfo.bValid())
        {
            WARNING("gdisrv!GreGetTextExtentExW(): could not lock HRFONT\n");
        }
        else
        {
            if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
                rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);

        // If there is no pdxOut buffer provided, but we still need one to compute the
        // number of characters that fit (pcChars not NULL), then we will have to
        // allocate one of our own.

        #define DXOUTLEN 40

            ULONG dxOut[DXOUTLEN];
            PULONG pdxAlloc = NULL;

            if ((pdxOut == (PULONG) NULL) && (pcChars != (COUNT *) NULL))
            {
                if (cwc <= DXOUTLEN)
                {
                    pdxOut = &dxOut[0];
                }
                else
                {
                    if ((pdxAlloc = (PULONG) PALLOCMEM(cwc * sizeof(ULONG), 'txtG')) == (PULONG) NULL)
                    {
                        WARNING("gdisrv!GreGetTextExtentExW(): could not alloc temp buffer\n");
                        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    pdxOut = pdxAlloc;
                }
            }

        // The STROBJ will now compute the text alignment, character positions,
        // and TextBox.

            ESTROBJ to(
                       pwsz,cwc,
                       dco,
                       rfo,
                       xo,PDXNULL,FALSE,      // xo, PDXNULL, bPdy = FALSE
                       dco.pdc->lEscapement(),
                       dco.pdc->lTextExtra(),
                       dco.pdc->lBreakExtra(),
                       dco.pdc->cBreak(),
                       0,0,0,(LONG *) pdxOut
                      );

            if (to.bValid())
            {

            // Transform the TextExtent to logical coordinates.  Because this is a
            // new NT function, we need not worry about the extent compatibility hack.

                if (to.bTextExtent(rfo,0L,pSize))
                {

                // Count number of characters that fit in the max. width.
                // If pcChars is NULL, we skip this and ignore the dxMax limit.

                    if (pcChars && pdxOut)
                    {
                        ULONG c;

                        for (c=0; c<cwc && *pdxOut<=dxMax; c++,pdxOut++)
                        {}

                        *pcChars = c;
                    }

                    bRet = TRUE;
                }
            }

        // Free temp buffer.

            if (pdxAlloc)
                VFREEMEM(pdxAlloc);
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL GreConsoleTextOut
*
* Write text with no spacing and alignment options, thereby saving a ton
* of time.
*
* History:
*  Fri 12-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Smaller and Faster
*
*  Wed 16-Sep-1992 17:36:17 -by- Charles Whitmer [chuckwh]
* Duplicated GrePolyTextOut, and then deleted the unneeded code.
\**************************************************************************/

extern "C" BOOL GreConsoleTextOut(
    HDC        hdc,
    POLYTEXTW *lpto,            // Ptr to array of polytext structures
    UINT       nStrings,        // number of polytext structures
    RECTL     *prclBounds
)
{
    // make sure CSR is calling us

    if (PsGetCurrentProcess() != gpepCSRSS)
        return(FALSE);

    //
    // Assume we will succeed, set Failure if we don't
    //

    BOOL bRet = TRUE;

    //
    // Lock the DC.
    //

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // Accumulate bounds.  We can do this before knowing if
        // the operation is successful because bounds can be loose.
        //

        if (dco.bAccum())
            dco.erclBounds() |= *prclBounds;

        //
        // Lock the Rao region.
        //

        DEVLOCKOBJ dlo;

        if (dlo.bLock(dco))
        {
            //
            // Locate the font realization.
            //

            RFONTOBJ rfo;

            rfo.vInit(dco,FALSE);

            if (rfo.bValid() && !rfo.bPathFont())
            {
                POINTL   ptlOrigin;
                ptlOrigin = dco.eptlOrigin();
                SURFACE *pSurf = dco.pSurface();
                XEPALOBJ palDest(pSurf->ppal());
                XEPALOBJ palDestDC(dco.ppal());
                POINTL   *pptlBO = &dco.pdc->ptlFillOrigin();
                EBRUSHOBJ *peboText = dco.peboText();
                EBRUSHOBJ *peboBackground = dco.peboBackground();

                BOOL bDitherText = FALSE;
                if ( dco.flGraphicsCaps() & GCAPS_ARBRUSHTEXT )
                {
                  // Even if a printer driver sets GCAPS_ARBRUSHTEXT, we
                  // can't allow vector fonts to be dithered.

                  bDitherText = (!rfo.bPathFont() || rfo.bReturnsOutlines());

                  // We always dirty the text brush if ARBRUSHTEXT is set to
                  // catch the cases where we transition between vector and
                  // non-vector fonts but keep the same brush -- if we didn't
                  // do this, we might try to use a cached, dithered brush
                  // after switching from a TrueType font to a vector font.

                  dco.ulDirtyAdd(DIRTY_TEXT);

                  // Get through the are-you-really-dirty check in vInitBrush:

                  peboText->vInvalidateUniqueness();
                }

                if ( dco.bDirtyBrush(DIRTY_TEXT|DIRTY_BACKGROUND) )
                {
                  if ( dco.bDirtyBrush(DIRTY_TEXT) )
                  {
                    peboText->vInitBrush(dco.pdc,
                                         gpbrText,
                                         palDestDC, palDest,
                                         pSurf,
                                         bDitherText);
                  }

                  if ( dco.bDirtyBrush(DIRTY_BACKGROUND) )
                  {
                    peboBackground->vInitBrush(
                                     dco.pdc,
                                     gpbrBackground,
                                     palDestDC, palDest, pSurf,
                                     (dco.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) ?
                                     TRUE : FALSE);
                  }
                  dco.vCleanBrush(DIRTY_TEXT|DIRTY_BACKGROUND);
                }

                //
                // Compute the clipping complexity and maybe reduce the exclusion
                // rectangle. The bounding rectangle must be converted to Screen
                // coordinates.
                //

                ERECTL rclExclude;

                rclExclude.left   = prclBounds->left   + ptlOrigin.x;
                rclExclude.right  = prclBounds->right  + ptlOrigin.x;
                rclExclude.top    = prclBounds->top    + ptlOrigin.y;
                rclExclude.bottom = prclBounds->bottom + ptlOrigin.y;

                ECLIPOBJ co(
                     dco.prgnEffRao(),
                     rclExclude,
                     (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X) ? CLIP_FORCE : CLIP_NOFORCE
                     );

                rclExclude = co.erclExclude();

                //
                // Check the destination which is reduced by clipping.
                //

                if (!rclExclude.bEmpty())
                {
                    DEVEXCLUDEOBJ dxo(dco,&rclExclude,&co);

                    //
                    // We now begin the 'Big Loop'.  We will pass thru this loop once for
                    // each entry in the array of PolyText structures.  Increment the
                    // pSurface once before we enter.  We assume success from here on out
                    // unless we hit a failure.
                    //

                    INC_SURF_UNIQ(pSurf);
                    PFN_DrvBitBlt  pfnBitBlt  = pSurf->pfnBitBlt();

                    PFN_DrvTextOut pfnTextOut;

                    if
                    (
                        ((rfo.prfnt->fobj.flFontType & FO_GRAY16) && !(dco.flGraphicsCaps() & GCAPS_GRAY16)) ||
                        (rfo.prfnt->fobj.flFontType & FO_CLEARTYPE_X)
                    )
                    {
                        pfnTextOut = SpTextOut;
                        pSurf->pdcoAA = &dco; // make sure this is needed
                    }
                    else
                    {
                        pfnTextOut = pSurf->pfnTextOut();
                    }

                    ERECTL  rclInput;

                    for (POLYTEXTW *ppt = lpto; ppt < lpto + nStrings; ppt += 1)
                    {
                        //
                        // Process the rectangle in prcl.
                        //

                        rclInput.left   = ppt->rcl.left   + ptlOrigin.x;
                        rclInput.right  = ppt->rcl.right  + ptlOrigin.x;
                        rclInput.top    = ppt->rcl.top    + ptlOrigin.y;
                        rclInput.bottom = ppt->rcl.bottom + ptlOrigin.y;

                        //
                        // Process the string.
                        //

                        if (ppt->n)
                        {
                            //
                            // The STROBJ will now compute the text alignment,
                            // character positions, and TextBox.
                            //

                            ESTROBJ to;

                            to.vInitSimple(
                                           (PWSZ) ppt->lpstr,
                                           ppt->n,
                                           dco,
                                           rfo,ppt->x+ptlOrigin.x,
                                           ppt->y+ptlOrigin.y,NULL);

                            if (to.bValid())
                            {
                            // Draw the text.
#ifdef FE_SB
                                if( to.bLinkedGlyphs() )
                                {
                                    // If there are linked glyphs, then the bounds of the
                                    // glyphs (to.rclBkGround) might exceed the bounds of the
                                    // clipping object (co.rclBounds).  If so, then we need
                                    // to increase the complexity of the clipping object from
                                    // DC_TRIVIAL to DC_RECT.
                                    if ((co.iDComplexity == DC_TRIVIAL) &&
                                        ((to.rclBkGround.left   < co.rclBounds.left)  ||
                                         (to.rclBkGround.right  > co.rclBounds.right) ||
                                         (to.rclBkGround.top    < co.rclBounds.top)   ||
                                         (to.rclBkGround.bottom > co.rclBounds.bottom)))
                                    {
                                        co.iDComplexity = DC_RECT;
                                    }

                                    bProxyDrvTextOut
                                    (
                                        dco,
                                        pSurf,
                                        to,
                                        co,
                                        (RECTL *) NULL,
                                        &rclInput,
                                        peboText,
                                        peboBackground,
                                        pptlBO,
                                        rfo,
                                        (PDEVOBJ*)NULL,
                                        (FLONG) 0L,
                                        &rclExclude
                                    );
                                }
                                else
                                {
#endif

                                (*pfnTextOut)(pSurf->pSurfobj(),
                                              (STROBJ *) &to,
                                              rfo.pfo(),
                                              &co,
                                              (RECTL *) NULL,
                                              &rclInput,
                                              peboText,
                                              peboBackground,
                                              pptlBO,
                                              (R2_COPYPEN | (R2_COPYPEN << 8)));
                                }
                            }
                            else
                            {
                                bRet = FALSE;
                                break;
                            }
                        }
                        else
                        {
                        // intersect the dest rect with the clip rect and set it in co

                        // we can only get away with touching co.rclBounds after
                        // the ECLIPOBJ constructor because of two reasons:
                        // a) the target rectangle passed to bitblt is contained in the
                        //    original bounds set by ECLIPOBJ, being the intersection
                        //    of the origianal bounds with THE intended target rectangle.
                        // b) clipping complexity may have changed when we changed
                        //    co.erclExclude, but it only could have gotten simpler,
                        //    so at worst in those rare situations we would not go
                        //    through the optimal code path.
                        // By changing clipping bounds we accomplish that no intersection
                        // of the target rectangle with clipping region rectangle is emtpy
                        // relieving the driver of extra work [bodind]

                            co.erclExclude().left   = max(rclExclude.left,rclInput.left);
                            co.erclExclude().right  = min(rclExclude.right,rclInput.right);

                            co.erclExclude().top    = max(rclExclude.top,rclInput.top);
                            co.erclExclude().bottom = min(rclExclude.bottom,rclInput.bottom);

                            // if not clipped, Just paint the rectangle.

                            if ((co.erclExclude().left < co.erclExclude().right) &&
                                (co.erclExclude().top < co.erclExclude().bottom))
                            {

                                (*pfnBitBlt)(pSurf->pSurfobj(),
                                            (SURFOBJ *)  NULL,
                                            (SURFOBJ *)  NULL,
                                            &co,
                                            NULL,
                                            &co.rclBounds,
                                            (POINTL *)   NULL,
                                            (POINTL *)   NULL,
                                            (BRUSHOBJ *)peboBackground,
                                            pptlBO,
                                            0x0000f0f0);
                            }
                            co.erclExclude() = rclExclude;
                        }

                    }
                    pSurf->pdcoAA = NULL;
                }

            }
            else
            {
                WARNING("gdisrv!GreExtTextOutW(): could not lock HRFONT\n");
                bRet = FALSE;
            }
        }
        else
        {
            bRet = dco.bFullScreen();
        }
    }
    else
    {
        bRet = FALSE;
        WARNING("Invalid DC passed to GreConsoleTextOut\n");
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* DWORD GreSetTextAlign (hdc,flOpts)                                       *
*                                                                          *
* Set the text alignment flags in the DC.                                  *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  Tue 28-Dec-1993 -by- Patrick Haluptzok [patrickh]                       *
* smaller and faster                                                       *
*                                                                          *
*  18-Dec-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

UINT APIENTRY GreSetTextAlign(HDC hdc,UINT flOpts)
{
    ULONG    ulReturn = 0;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreSetTextAlign\n");
    }
    else
    {
        ulReturn = (UINT)dco.pdc->lTextAlign();
        dco.pdc->lTextAlign(flOpts);

        if (MIRRORED_DC(dco.pdc) && ((flOpts & TA_CENTER) != TA_CENTER)) {
            flOpts = flOpts ^ TA_RIGHT;
        }

        dco.pdc->flTextAlign(flOpts & (TA_UPDATECP | TA_CENTER | TA_BASELINE));
        dco.vUnlockFast();
    }

    return((UINT)ulReturn);
}


/******************************Public*Routine******************************\
* int GreSetTextCharacterExtra (hdc,lExtra)                                *
*                                                                          *
* Sets the amount of intercharcter spacing for TextOut.                    *
*                                                                          *
* History:                                                                 *
*  Tue 28-Dec-1993 -by- Patrick Haluptzok [patrickh]                       *
* smaller and faster                                                       *
*                                                                          *
*  Tue 08-Jan-1991 -by- Bodin Dresevic [BodinD]                            *
* Update: bug, used to return lExtra instead of lOld, transform stuff      *
* deleted since it will be done at the TextOut time.                       *
*                                                                          *
*  18-Dec-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreSetTextCharacterExtra(HDC hdc,int lExtra)
{
    ULONG ulOld = 0x80000000;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreSetTextCharacterExtra\n");
    }
    else
    {
        ulOld = dco.pdc->lTextExtra();
        dco.pdc->lTextExtra(lExtra);
        dco.vUnlockFast();
    }

    return(ulOld);
}


/******************************Public*Routine******************************\
* int GreGetTextCharacterExtra (hdc)                                       *
*                                                                          *
* Gets the amount of intercharcter spacing for TextOut.                    *
*                                                                          *
*  29-Jun-1995 -by- Fritz Sands [fritzs]                                   *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreGetTextCharacterExtra(HDC hdc)
{
    ULONG    ulOld = 0;

    XDCOBJ dco( hdc );

    if(!dco.bValid())
    {
        WARNING("Invalid DC or offset passed to GreGetTextCharacterExtra\n");
    }
    else
    {
        ulOld = dco.pdc->lTextExtra();
        dco.vUnlockFast();
    }

    return(ulOld);
}



/******************************Public*Routine******************************\
*
* CalcJustInArray
*
* Effects: mimics win95 asm code, except that their code does not have
* if (b_lpDx) clause, for all of their arrays are 16 bit.
*
* if GCP_JUSTIFYIN flag is set, the lpDx array on input contains
* justifying priorities.
* For latin this means the lpDx array will contain
* 0's or 1's where 0 means that the glyph at this position can not be
* used for spacing while 1 means that the glyph at this position should
* be used for spacing. If GCP_JUSTIFYIN is NOT set, than space chars ' ',
* in the input string are used to do justification.
*
* History:
*  21-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD nCalcJustInArray(
    UINT **ppJustIn,      // place to store the pointer to array
    WCHAR  Glyph,         // glyph to find
    VOID  *pvIn,          // input array
    BOOL   b_lpDx,        // input array is lpDx or pwc
    UINT   cGlyphs        // length of the input array
    )
{
    WCHAR *pwc, *pwcEnd;
    int   *pDx, *pDxEnd;
    int    iGlyph;
    COUNT  nJustIn = 0;
    UINT  *piInit;

// look for Glyph in the string

    if (b_lpDx)
    {
        iGlyph = (int)Glyph;
        pDxEnd = (int*)pvIn + cGlyphs;
        for (pDx = (int*)pvIn; pDx < pDxEnd; pDx++)
        {
            if (*pDx == iGlyph)
                nJustIn++;
        }
    }
    else
    {
        pwcEnd = (WCHAR*)pvIn + cGlyphs;
        for (pwc = (WCHAR*)pvIn; pwc < pwcEnd; pwc++)
        {
            if (*pwc == Glyph)
                nJustIn++;
        }
    }

    if ((nJustIn == 0) || // did not find any Glyphs in the string
       !(piInit = (UINT *)PALLOCMEM(nJustIn * sizeof(UINT), 'ylgG')))
    {
        *ppJustIn = NULL;
        return 0;
    }

// store locations where Glyph's are found in the input array

    UINT *pi = piInit;

    if (b_lpDx)
    {
        for (pDx = (int*)pvIn; pDx < pDxEnd; pDx++)
        {
            if (*pDx == iGlyph)
            {
                //Sundown: safe to truncate since pDxEnd = pvIn + cGlyphs
                *pi++ = (UINT)(pDx - (int*)pvIn);
            }
        }
    }
    else
    {
        for (pwc = (WCHAR*)pvIn; pwc < pwcEnd; pwc++)
        {
            if (*pwc == Glyph)
            {
                //Sundown: same as above
                *pi++ = (UINT)(pwc - (WCHAR*)pvIn);
            }
        }
    }

// return the pointer with array of locations of uiGlyphs

    *ppJustIn = piInit;
    return nJustIn;
}

/******************************Public*Routine******************************\
*
* VOID RFONTOBJ::vFixUpGlyphIndices(USHORT *pgi, UINT cgi)
*
* Effects: Windows 95 returns glyph indices for bitmap fonts that are the
*          same as ansi values. On NT glyph handles are zero based, so
*          we need to add chFirstChar to NT handles to get win95 indices
*          which is what we do in GetGlyphIndicesA/W and GetCharacterPlacement.
*          Conversely, when those indices are passed to us through
*          text routines we have to subtract chFirstChar from indices to
*          produce NT handles. This is what this routine does:
*
* History:
*  04-Mar-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vFixUpGlyphIndices(USHORT *pgi, UINT cgi)
{
    USHORT usFirst = prfnt->ppfe->pifi->chFirstChar;

    ASSERTGDI(prfnt->flType & RFONT_TYPE_HGLYPH, "vFixUpGlyphIndices\n");

    ASSERTGDI(prfnt->ppfe->pfdg, "RFONTOBJ::vFixUpGlyphIndices invalid ppfe->pfdg \n");

    if ((prfnt->ppfe->pfdg->flAccel & GS_8BIT_HANDLES) && usFirst)
    {
    // win95 does not return true glyph indicies but ansi
    // values for raster, vector, ps fonts

        for (USHORT *pgiEnd = pgi + cgi; pgi < pgiEnd; pgi++)
           *pgi -= usFirst;
    }
}

/******************************Public*Routine******************************\
*
* GreGetGlyphIndicesW (
*
* Effects: designed to emulate win95 behavior
*
* Warnings:
*
* History:
*  25-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD GreGetGlyphIndicesW (
    HDC     hdc,
    WCHAR  *pwc,
    DWORD   cwc,
    USHORT *pgi,
    DWORD   iMode,
    BOOL    bSubset
    )
{
    DWORD         dwRet = GDI_ERROR;
    HGLYPH *phg, *phgInit;
    USHORT *pgiEnd = pgi + cwc;

    XDCOBJ dco(hdc);           // Lock the DC.
    if (dco.bValid())          // Check if it's good.
    {
    // Locate the RFONT.
    // It might be better to set the type to RFONT_TYPE_HGLYPH
    // in anticipation of ETO_GLYPH_INDEX ExtTextOut calls

        RFONTOBJ rfo(dco, FALSE, RFONT_TYPE_UNICODE);

        if (rfo.bValid())
        {
            USHORT usFirst = rfo.prfnt->ppfe->pifi->chFirstChar;

        // if cwc == 0 all we are care for is the # of distinct glyph indices

            if (cwc==0)
            {
                ASSERTGDI(iMode == 0, "GreGetGlyphIndicesW parameters bogus\n");

                if (rfo.prfnt->ppfe->pifi->cjIfiExtra > offsetof(IFIEXTRA,cig))
                {
                    dwRet = ((IFIEXTRA *)(rfo.prfnt->ppfe->pifi + 1))->cig;
                }
                else
                {
                    dwRet = 0;
                }
            }
            else
            {
            // if we ever switch to 16 bit HGLYPHS in ddi, this alloc will no
            // longer be necessary [bodind]

                if (phgInit = (phg = (HGLYPH *)PALLOCMEM(cwc * sizeof(HGLYPH), 'ylgG')))
                {
                    rfo.vXlatGlyphArray(pwc, cwc, phg, iMode, bSubset);

                // separate loops for faster processing:

                    ASSERTGDI(rfo.prfnt->ppfe->pfdg, "GreGetGlyphIndicesW invalid ppfe->pfdg \n");

                    if (rfo.prfnt->ppfe->pfdg->flAccel & (GS_8BIT_HANDLES|GS_16BIT_HANDLES))
                    {
                        if ((rfo.prfnt->ppfe->pfdg->flAccel & GS_8BIT_HANDLES) && usFirst)
                        {
                        // win95 does not return true glyph indicies but ansi
                        // values for raster, vector, ps fonts

                            for ( ; pgi < pgiEnd; pgi++, pwc++, phg++)
                               *pgi = (USHORT)*phg + usFirst;
                        }
                        else
                        {
                            for ( ; pgi < pgiEnd; pgi++, pwc++, phg++)
                               *pgi = (USHORT)*phg;
                        }

                        dwRet = cwc; // can not fail any more
                    }
                    else
                    {
                        dwRet = GDI_ERROR;
                    }

                    VFREEMEM(phgInit);
                }
            }
        }

        dco.vUnlockFast();
    }
    return dwRet;
}



/******************************Public*Routine******************************\
*
* DWORD GreGetCharacterPlacementW
*
*
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


DWORD GreGetCharacterPlacementW(
    HDC     hdc,
    LPWSTR  pwsz,
    DWORD   nCountIn,
    DWORD   nMaxExtent,
    LPGCP_RESULTSW   pResults,
    DWORD   dwFlags
)
{
    SIZE   size;
    GCP_RESULTSW gcpw;

    DWORD nCount = nCountIn;
    DWORD dwWidthType = 0;
    int   *pDx = NULL;
    UINT  *pJustIn = NULL;
    DWORD dwJustInOff = 0; // used by calc routine for spacing
    DWORD nJustIn = 0;
    ULONG nKern = 0;
    KERNINGPAIR *pKern = NULL;
    KERNINGPAIR *pKernSave = NULL; // esential initialization
    int   nExtentLeft = 0;
    int   nExtentRem = 0;
    WORD *pwc,*pwcEnd;
    DWORD i, j;

// init size

    size.cx = size.cy = 0;

// we will only be implementing the simple version of this api,
// that is for now we will not be calling LPK dlls

    if (!pResults)
    {
        if (!GreGetTextExtentW(hdc, (LPWSTR)pwsz, (int)nCount, &size, GGTE_WIN3_EXTENT))
        {
            WARNING("GreGetCharacterPlacementW, GreGetTextExtentW failed\n");
            return 0;
        }

    // now do unthinkable win95 stuff, chop off 32 bit values to 16 bits

        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// main code starts here. We are following win95 code as closely as possible.
// Copy pResults to the stack, for faster access I presume.

    gcpw = *pResults;

// take nCount to be the smaller of the nCounts and nGlyphs

    if (nCount > gcpw.nGlyphs)
        nCount = gcpw.nGlyphs;

// Calc pJustIn array if any

    if (dwFlags & GCP_JUSTIFY)     // if have this
        dwFlags |= GCP_MAXEXTENT;  // then must also have this

    if ((dwFlags & GCP_JUSTIFYIN) && gcpw.lpDx)
    {
    // if this flag is set, the lpDx array on input contains
    // justifying priorities so we can not continue if lpDx is not present.
    // For latin this means the lpDx array will contain
    // 0's or 1's where 0 means that the glyph at this position can not be
    // used for spacing while 1 means that the glyph at this position should
    // be used for spacing. If GCP_JUSTIFYIN is NOT set, than space chars ' ',
    // in the string are used to do justification.
    // Now that we have everything in place we can call CalcJustInArray
    // to compute the array in pJustIn

        nJustIn = nCalcJustInArray(&pJustIn, 1,
                                   (VOID *)gcpw.lpDx, TRUE ,gcpw.nGlyphs);
        if (!nJustIn)
        {
        // if this computation fails must pretend that this flag is not set

            dwFlags &= ~GCP_JUSTIFYIN;
        }
    }
    else
    {
    // either GCP_JUSTIFYIN not set or lpDx is NULL input,
    // in either case can kill the bit

            dwFlags &= ~GCP_JUSTIFYIN;
    }

// we could have either the lpDx, lpCaretPos or neither or both.  Take this
// into account and call GetTextExtentEx

// we could or could not be asking for a maximum.  If we are, put it in the
// local version of the results structure.

    if (gcpw.lpDx)
        dwWidthType += 1; // bogus way of doing it, i.e. win95 way
    if (gcpw.lpCaretPos)
        dwWidthType += 2; // bogus way of doing it, i.e. win95 way

// dwWidthType can be 0,1,2,3

    pDx = gcpw.lpDx;
    if (dwWidthType == 2) // CaretPos only
        pDx = gcpw.lpCaretPos; // reset the array pointer

// Check if the count should be reduced even further

    COUNT *pnCount = NULL;
    if (dwFlags & GCP_MAXEXTENT)
    {
        pnCount = (COUNT*)&nCount;
    }

// now call GetTextExtentEx

    if (!GreGetTextExtentExW(
                hdc,                // device context
                (LPWSTR)pwsz,       // pointer to a UNICODE text string
                nCount,             // count of WCHARs in the string
                (ULONG)nMaxExtent,  // maximum width to return
                pnCount,            // number of chars that fit in dxMax
                (PULONG)pDx,        // offset of each character from string origin
                &size,0))
    {
        if (pJustIn)
            VFREEMEM(pJustIn);
        return 0;
    }

// these few lines of code do not exist in Win95, presumably because
// their internal version of GetTextExtentExW does not return positions
// of glyphs (relative to the first glyph) but character increments along
// baseline.

    if (pDx && (nCount > 0))
    {
        for (int * pDxEnd = &pDx[nCount - 1]; pDxEnd > pDx; pDxEnd--)
        {
            *pDxEnd -= pDxEnd[-1];
        }
    }

    if ((dwFlags & GCP_MAXEXTENT) && (nCount == 0))
    {
        if (pJustIn)
            VFREEMEM(pJustIn);
        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// Kerning:
// It only makes sense to do kerning if there are more than 2 glyphs

    if ((dwFlags & GCP_USEKERNING) && (dwWidthType != 0) && (nCount >= 2))
    {
    // Get the number of kerning pairs, if zero done

        if (nKern = GreGetKerningPairs(hdc,0,NULL))
        {
            if (pKernSave = (KERNINGPAIR*)PALLOCMEM(nKern * sizeof(KERNINGPAIR), 'txtG'))
            {
            // consistency check for GetKerningPairs:

                if (GreGetKerningPairs(hdc,nKern,pKernSave) != nKern)
                {
                // something is gone wrong, out of here

                    if (pJustIn)
                        VFREEMEM(pJustIn);
                    if (pKernSave)
                        VFREEMEM(pKernSave);

                    return 0;
                }

                KERNINGPAIR *pKernEnd = pKernSave + nKern;
                register WCHAR wcFirst;
                for (pKern = pKernSave; pKern < pKernEnd; pKern++)
                {
                // now go over the sting and find all the instances of
                // THIS kerning pair in the string:

                    register WORD wcFirst = pKern->wFirst;

                // note that this is the loop for trying the wcFirst
                // so that the end condition is &pwsz[nCount - 2],
                // wcSecond could go up to &pwsz[nCount - 1],
                // Either I do not understand Win95 code or they have
                // a bug in that they could fault on trying to access the
                // the second glyph in a pair in the input string

                    pwcEnd = (WORD*)pwsz + (nCount - 1);

                    for (pwc = (WORD *)pwsz; pwc < pwcEnd; pwc++)
                    {
                        if ((wcFirst == pwc[0]) && (pwc[1] == pKern->wSecond))
                        {
                        // found a kerning pair in the string,
                        // we need to modify the pDx vector for the second
                        // glyph in the kerning pair

                            pDx[pwc - (WORD *)pwsz] += pKern->iKernAmount;

                        // also adjust the return value accordingly:

                            size.cx += pKern->iKernAmount;
                        }
                    }
                } // on to the next pair

            // done with kerning pairs can free the memory

                VFREEMEM(pKernSave);

            // if we have kerned positive amounts, then the string could well
            // have gone over the preset limit. If so, reduce the number of
            // characters we found [win95 comment]

                if (dwFlags & GCP_MAXEXTENT)
                {
                    while (((DWORD)size.cx > nMaxExtent) && (nCount > 0))
                    {
                    // point to the last glyph in the string

                        size.cx -= pDx[nCount - 1];

                        nCount -= 1;
                    }

                // see if there are any glyphs left to process

                    if (nCount == 0)
                    {
                        if (pJustIn)
                            VFREEMEM(pJustIn);

                        pResults->nGlyphs = nCount;
                        pResults->nMaxFit = (int)nCount;
                        return 0;
                    }
                }
            } // no memory
        } // no kern pairs
    }

// Justification, check flags and the presence of array

    if ((dwFlags & GCP_JUSTIFY) && dwWidthType && (nCount > 0))
    {
        int *pDxEnd = &pDx[nCount - 1]; // must have nCount > 0 for this

    // check trailing spaces, adjust nCount further to remove trailing spaces

        for
        (
            pwcEnd = (WORD*)&pwsz[nCount-1];
            (pwcEnd >= (WORD*)pwsz) && (*pwcEnd == L' ');
            nCount--, pwcEnd--, pDxEnd--
        )
        {
            size.cx -= *pDxEnd;
        }

        if (nCount == 0)
        {
            if (pJustIn)
                VFREEMEM(pJustIn);

            pResults->nGlyphs = nCount;
            pResults->nMaxFit = (int)nCount;
            return 0;
        }

    // See if we need to justify.
    // Can not justify one character, need at least two...

        nExtentLeft = (int)nMaxExtent - (int)size.cx;

        if ((nExtentLeft >= 0) && (nCount >= 2))
        {
        // ... yes, we do need to justify

        // if GCP_JUSTIFYIN was set, pJustIn and nJustIn have
        // already been set.

            if (!nJustIn) // try to use ' ' as a "spacer glyph"
            {
                nJustIn = nCalcJustInArray(&pJustIn,L' ',
                                           (VOID *)pwsz, FALSE, nCount);
            }


            if (nJustIn)
            {
            // Make sure that the array doesn't say to
            // space a character beyond the new nCount.

                j = nCount - 1; // convert count to index of the last glyph

                int ii;

                for (ii = (int)(nJustIn - 1); ii >= 0; ii--)
                {
                    if ((UINT)j >= pJustIn[ii])
                        break;
                }

            // pJustIn array is zero based, to get the effective number
            // of "spacers" in the array must add 1 to the index of the last "spacer" in the array

                i = (DWORD)ii + 1;

            // run a sort of primitive DDA a'la DavidMS

                nExtentRem = (int) (((DWORD)nExtentLeft) % i);
                nExtentLeft /= i;

                for (j = 0; j < i; j++, nExtentRem--)
                {
                    int  dxCor = nExtentLeft;
                    if (nExtentRem > 0)
                        dxCor += 1;
                    pDx[pJustIn[j]] += dxCor;
                }
            }
            else
            {
            // no spaces. justify by expanding every character evenly.

                while (nExtentLeft > 0)
                {
                // Note the end condition: nCount - 1, rather
                // than usual nCount; This is because there is no point
                // in adding spaces to the last glyph in the string

                    j = nCount - 1;
                    for (i = 0; i < j; i++)
                    {
                        pDx[i] += 1;
                        if (!(--nExtentLeft))
                            break;
                    }
                }
            }
        }
        #if DBG
        else
        {
            if (nCount < 2)
                RIP("GetCharacterPlacement, justification wrong\n");
        }
        #endif

    // we now have exactly this:

        size.cx = (LONG)nMaxExtent;
    }

// fill other width array, that is CaretPos

    if (dwWidthType == 3) // both lpDx and lpCaretPos are non NULL
        RtlCopyMemory(gcpw.lpCaretPos, gcpw.lpDx, nCount * sizeof(int));

// caret positioning is from the start of the string,
// not the previous character.

    if (gcpw.lpCaretPos)
    {
        int iCaretPos = 0,  iDx = 0;

        for (i = 0; i < nCount; i++)
        {
            iDx = gcpw.lpCaretPos[i];
            gcpw.lpCaretPos[i] = iCaretPos;
            iCaretPos += iDx;
        }
    }

// Fix Output String

    if (gcpw.lpOutString)
        RtlCopyMemory(gcpw.lpOutString, pwsz, nCount * sizeof(WCHAR));

// Classification

    if (gcpw.lpClass)
        RtlFillMemory(gcpw.lpClass, nCount, GCPCLASS_LATIN);

// Ordering

    if (gcpw.lpOrder)
    {
        for (i = 0; i < nCount; i++)
        {
            gcpw.lpOrder[i] = i;
        }
    }

// Get lpGlyphs

    if (gcpw.lpGlyphs)
    {
        if (GreGetGlyphIndicesW(
                hdc,(WCHAR*)pwsz,nCount,
                (USHORT*)gcpw.lpGlyphs,0, FALSE) == GDI_ERROR)
        {
            nCount = 0;
            size.cx = size.cy = 0;
        }
    }

// Finally fix counters in the returned structure

    if (pJustIn)
        VFREEMEM(pJustIn);
    pResults->nGlyphs = nCount;
    pResults->nMaxFit = nCount;
    return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
}


/**************************************************************************\
* NtGdiGetWidthTable
*
* Gets a table of character advance widths for a font.  Returns SHORTs
* over the C/S interface to save space.  (Note that 99+% of all requests
* will be happy with this limitation.)
*
* We will try real hard to get widths for the "special" characters at the
* start of the array.  Other widths are returned only when they are not
* expensive.  (Expensive is True Type rasterizing a glyph, for example.)
* The value NO_WIDTH is returned for those expensive glyphs.
*
* We return GDI_ERROR (0xFFFFFFFF) in case of an error.  TRUE indicates
* that all widths were easy.
*
* History:
*  Tue 13-Jun-1995 22:24:49 by Gerrit van Wingerden [gerritv]
*  Moved to kernel mode
*
*  Mon 11-Jan-1993 22:24:39 -by- Charles Whitmer [chuckwh]
* Wrote it.  Sorry about the wierd structure, I'm trying to get good tail
* merging.
\**************************************************************************/

BOOL APIENTRY NtGdiGetWidthTable
(
    HDC        hdc,         // Device context
    ULONG      cSpecial,
    WCHAR     *pwc,         // Pointer to a UNICODE text codepoints.
    ULONG      cwc,         // Count of chars.
    USHORT    *psWidth,     // Width table (returned).
    WIDTHDATA *pwd,         // Useful font data (returned).
    FLONG     *pflInfo      // Font info flags.
)
{
    ULONG ii;
    BOOL  bRet = (BOOL) GDI_ERROR;

    XDCOBJ dco(hdc);             // Lock the DC.

    if (dco.bValid())          // Check if it's good.
    {
        WIDTHDATA wd;

        FLONG flInfo;
        USHORT *psWidthTmp = NULL;
        WCHAR *pwcTmp;

        if (!BALLOC_OVERFLOW2(cwc, USHORT, WCHAR))
        {
            psWidthTmp = (USHORT*) AllocFreeTmpBuffer(cwc*(sizeof(USHORT)+sizeof(WCHAR)));
        }

        if( psWidthTmp )
        {
            pwcTmp = (WCHAR*) (psWidthTmp + cwc);
            __try
            {
                ProbeForRead(pwc,sizeof(WCHAR)*cwc,sizeof(WORD));
                RtlCopyMemory(pwcTmp,pwc,cwc*sizeof(WCHAR));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                cwc = 0;
            }
        }
        else
        {
            WARNING("NtGdiGetWidthTable unable to allocate memory\n");
            cwc = 0;
        }

        if (cwc)
        {
        // Locate the RFONT.

            RFONTOBJ rfo(dco,FALSE);

            if (rfo.bValid())
            {
            // Grab the flInfo flags.

                flInfo = rfo.flInfo();

                if (rfo.cxMax() < 0xFFF)
                {
                // Check for a simple case.  We still have to fill the table
                // because some one may want it.

                    if (rfo.lCharInc())
                    {
                        USHORT *psWidth1 = psWidthTmp;

                        LONG fxInc = rfo.lCharInc() << 4;

                        for (ii=0; ii<cwc; ii++)
                            *psWidth1++ = (USHORT) fxInc;
                        bRet = TRUE;
                    }
                    else
                    {
                        bRet = rfo.bGetWidthTable(dco,cSpecial,pwcTmp,cwc,psWidthTmp);
                    }

                // If things are going well, get the WIDTHDATA.

                    if (bRet != GDI_ERROR)
                    {
                        if (!rfo.bGetWidthData(&wd,dco))
                            bRet = (BOOL) GDI_ERROR;
                    }
                }
            }
            else
            {
                WARNING("gdisrv!GreGetWidthTable(): could not lock HRFONT\n");
            }
        }

        if( bRet != GDI_ERROR )
        {
            __try
            {
                ProbeForWrite(psWidth,sizeof(USHORT)*cwc,sizeof(USHORT));
                RtlCopyMemory(psWidth,psWidthTmp,cwc*sizeof(USHORT));
                if( pwd )
                {
                    ProbeForWrite(pwd,sizeof(WIDTHDATA),sizeof(DWORD));
                    RtlCopyMemory(pwd,&wd,sizeof(WIDTHDATA));
                }
                ProbeForWrite(pflInfo,sizeof(FLONG),sizeof(DWORD));
                RtlCopyMemory(pflInfo,&flInfo,sizeof(FLONG));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bRet = GDI_ERROR;
            }
        }

        if (psWidthTmp)
        {
            FreeTmpBuffer( psWidthTmp );
        }

        dco.vUnlockFast();

    }
    return(bRet);
}

/******************************Public*Routine******************************\
* iGetPublicWidthTable()
*
*
* History:
*  28-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

EFLOAT_S ef_16   = EFLOAT_16;
EFLOAT_S ef_1_16 = EFLOAT_1Over16;

int iGetPublicWidthTable(
    HDC   hdc)
{
    ULONG ii   = MAX_PUBLIC_CFONT; // this means failure
    BOOL  bRet = FALSE;
    HLFONT hf;

    XDCOBJ dco(hdc);             // Lock the DC.

    if (dco.bValid())            // Check if it's good.
    {
        // only want to support no transforms

        if ((dco.pdc->ulMapMode() == MM_TEXT) && (dco.ulDirty() & DISPLAY_DC))
        {
            // Get the hfont and check if it is public

            hf = dco.pdc->hlfntNew();

            if ((hf != NULL) &&
                GreGetObjectOwner((HOBJ)hf,LFONT_TYPE) == OBJECT_OWNER_PUBLIC)
            {
                RFONTOBJ rfo(dco,FALSE);

                if (rfo.bValid() && (rfo.cxMax() < 0xFFF))
                {
                    // lets see if we can find an available cpf

                    for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
                    {
                        if (gpGdiSharedMemory->acfPublic[ii].hf == 0)
                            break;

                        if (gpGdiSharedMemory->acfPublic[ii].hf == (HFONT)hf)
                        {
                            WARNING("iGetPublicWidthTable - font already in public list\n");
                            ii = MAX_PUBLIC_CFONT;
                        }
                    }

                    if (ii < MAX_PUBLIC_CFONT)
                    {
                        PCFONT pcf = &gpGdiSharedMemory->acfPublic[ii];

                        pcf->timeStamp = gpGdiSharedMemory->timeStamp;

                        // Grab the flInfo flags.

                        pcf->flInfo = rfo.flInfo();

                        // Check for a simple case.  We still have to fill the table
                        // because some one may want it.

                        if (rfo.lCharInc())
                        {
                            USHORT usInc = (USHORT)(rfo.lCharInc() << 4);

                            for (ii=0; ii<256; ii++)
                                pcf->sWidth[ii] = usInc;

                            bRet = TRUE;
                        }
                        else
                        {
                            WCHAR wch[256];
                            LFONTOBJ lfo(hf);

                            if (lfo.bValid())
                            {

                                if (IS_ANY_DBCS_CHARSET(lfo.plfw()->lfCharSet))
                                {
                                    ULONG  uiCodePage = ulCharsetToCodePage((UINT)lfo.plfw()->lfCharSet);

                                    for (ii = 0; ii < 256; ++ii)
                                    {
                                        UCHAR j = (UCHAR) ii;

                                        EngMultiByteToWideChar(uiCodePage,
                                                               &wch[ii],
                                                               sizeof(WCHAR),
                                                               (LPSTR)&j,
                                                               1);
                                    }
                                }
                                else
                                {
                                    UCHAR ach[256];
                                    ULONG BytesReturned;

                                    for (ii = 0; ii < 256; ++ii)
                                      ach[ii] = (UCHAR)ii;

                                    RtlMultiByteToUnicodeN(wch,
                                                           sizeof(wch),
                                                           &BytesReturned,
                                                           (PCHAR)ach,
                                                           sizeof(ach));
                                }

                                bRet = rfo.bGetWidthTable(dco,256,wch,256,pcf->sWidth);

                                if (bRet == GDI_ERROR)
                                    bRet = FALSE;
                            }
                        }

                        // If things are going well, get the WIDTHDATA , metrics and
                        // RealizationInfo
                        DCOBJ dcof(hdc);

                        if (bRet &&
                            rfo.bGetWidthData(&pcf->wd,dco) &&
#ifdef LANGPACK
                            rfo.GetRealizationInfo(&pcf->ri) &&
#endif
                            bGetTextMetrics(rfo, dcof, &pcf->tmw)
                           )
                        {
                            pcf->fl   = CFONT_COMPLETE       |
                                        CFONT_CACHED_METRICS |
                                        CFONT_CACHED_WIDTHS  |
#ifdef LANGPACK
                                        CFONT_CACHED_RI      |
#endif
                                        CFONT_PUBLIC;

                            // since we are always MM_TEXT, the xform is identity

                            pcf->efM11          = ef_16;
                            pcf->efM22          = ef_16;
                            pcf->efDtoWBaseline = ef_1_16;
                            pcf->efDtoWAscent   = ef_1_16;

                            pcf->hf             = (HFONT)hf;
                            pcf->hdc            = 0;
                            pcf->cRef           = 0;
                            pcf->lHeight        = FXTOL((LONG) pcf->wd.sHeight);
                        }
                        else
                        {
                        // if got error... we should retuen MAX_PUBLIC_CFONT..
                        // At this point "ii" is not equal to MAX_PUBLIC_CFONT, it
                        // points first free entry of cache table...
                        // Just force set it to error..

                            ii = MAX_PUBLIC_CFONT;
                        }
                    }
                }
                else
                {
                    WARNING("gdisrv!GreGetWidthTable(): could not lock HRFONT\n");
                }
            }
        }
        dco.vUnlockFast();
    }

    return(ii);
}

/******************************Public*Routine******************************\
* NtGdiSetupPublicCFONT()
*
*  Modify the cached public cfont.
*
*  if HDC is non-null, textmetrics must be set
*  if HF  is non-null, cached ave width must be set
*
*  returns index of cfont modified
*
* History:
*  23-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int APIENTRY NtGdiSetupPublicCFONT(
    HDC     hdc,
    HFONT   hf,
    ULONG   ulAve)
{
    int ii = MAX_PUBLIC_CFONT;

    // get metrics and widths if necesary

    if (hdc)
    {
        ii = iGetPublicWidthTable(hdc);
    }

    // now see if we need to fill in the ave width

    if (hf)
    {
        // if we havn't found it yet, find it

        if (ii == MAX_PUBLIC_CFONT)
        {
            for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
            {
                if (gpGdiSharedMemory->acfPublic[ii].hf == hf)
                    break;
            }
        }

        if (ii < MAX_PUBLIC_CFONT)
        {
            gpGdiSharedMemory->acfPublic[ii].ulAveWidth = ulAve;
            gpGdiSharedMemory->acfPublic[ii].fl        |= CFONT_CACHED_AVE;
        }
    }

    return(ii);
}


UINT APIENTRY GreGetTextAlign(HDC hdc)
{
    XDCOBJ dco( hdc );

    if(dco.bValid())
    {
        dco.vUnlockFast();
        return(dco.pdc->lTextAlign());
    }
    else
    {
        WARNING("GreGetTextAlign: invalid DC\n");
        return(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\surfgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: surfgdi.cxx
*
* This file contains the bitmap creation functions
*
* Created: 14-Jun-1991 17:05:47
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

BOOL bDoGetSetBitmapBits(SURFOBJ *, SURFOBJ *, BOOL);

/******************************Public*Routine******************************\
* HBITMAP GreCreateBitmap
*
* API Entry point to create a bitmap.
*
* Returns: Handle to bitmap for success
*
* History:
*  Wed 23-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY GreCreateBitmap(
    int cx,
    int cy,
    UINT cPlanes,
    UINT cBits,
    LPBYTE pvBits
    )
{
    //
    // Try to guess what format the user wanted.  We will always guarantee
    // enough space in the bitmap for the info.  Note that if either cPlanes
    // or cBits is zero, a monochrome bitmap will be created.
    //

    ULONG iFormat = cPlanes * cBits;
    
    //
    // Validate the width, height, planes, and bits
    //

    if ((cx <= 0) ||
        (cx > MAX_SURF_WIDTH) ||
        (cy <= 0) ||
        (cPlanes > 32) ||
        (cBits   > 32) ||
        (iFormat > 32))
    {
        WARNING("GreCreateBitmap failed - parameter too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    ULONG       cjScanBytes = (((((ULONG) cx * iFormat) + 15) >> 4) << 1);
    ULONGLONG   cjTotal =  (ULONGLONG) cjScanBytes * (ULONGLONG) cy;

    // BUGFIX #172774 12-12-2000 bhouse
    //
    // NOTE: Is there a better way to detect overflow then to use ULONGLONG?
    //       I vaguely recall that if for unsigned values r = a * b
    //       then an overflow occured if either r < a || r < b

    if(cjTotal  > ULONG_MAX)
    {
        WARNING("GreCreateBitmap failed - size too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }


    //
    // This if-else loop can be simplified and made smaller but until we get
    // this right let's leave it like this so it's easy to change.
    //

    DEVBITMAPINFO dbmi;
    dbmi.cxBitmap   = cx;
    dbmi.cyBitmap   = cy;
    dbmi.hpal       = (HPALETTE) 0;
    dbmi.fl         = BMF_TOPDOWN;

    if (iFormat <= 1)
    {
        //
        // A monochrome bitmap has a fixed palette.  The 0 (black) is always
        // mapped to foreground, the 1 is always mapped to background (white).
        //

        iFormat = BMF_1BPP;
        dbmi.hpal = hpalMono;
    }
    else if (iFormat <= 4)
    {
        iFormat = BMF_4BPP;
    }
    else if (iFormat <= 8)
    {
        iFormat = BMF_8BPP;
    }
    else if (iFormat <= 16)
    {
        iFormat = BMF_16BPP;
    }
    else if (iFormat <= 24)
    {
        iFormat = BMF_24BPP;
    }
    else if (iFormat <= 32)
    {
        iFormat = BMF_32BPP;
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    dbmi.iFormat = iFormat;

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, NULL);

    if (!SurfDimo.bValid())
    {
        WARNING("Failed surface memory alloc in GreCreateBitmap\n");
        return((HBITMAP) 0);
    }

    SurfDimo.ps->vSetApiBitmap();

    if (pvBits != (LPBYTE) NULL)
    {
        //
        // Initialize the bitmap.
        //

        ULONG   cColors;
        cColors = 0;
        GreSetBitmapBits((HBITMAP)SurfDimo.ps->hsurf(), (ULONG) cjTotal,
                         (PBYTE) pvBits, (LONG *) &cColors);
    }

    //
    // Monochrome bitmaps are not considered to be DDBs:
    //

    if (iFormat != BMF_1BPP)
    {
        SurfDimo.ps->vSetDeviceDependentBitmap();
    }

    SurfDimo.vKeepIt();
    GreSetBitmapOwner((HBITMAP) SurfDimo.ps->hsurf(), OBJECT_OWNER_CURRENT);
    return((HBITMAP) SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* HSURF hsurfCreateCompatibleSurface(hdev,cx,cy,bDriver)
*
* Low-level GDI interface for creating a compatible surface, possibly
* hooked by the driver.
*
\**************************************************************************/

HSURF hsurfCreateCompatibleSurface(
    HDEV hdev,
    ULONG iFormat,
    HPALETTE hpal,
    int cx,
    int cy,
    BOOL bDriverCreatible
    )
{
    PDEVOBJ po(hdev);

    po.vAssertDevLock();

    //
    // Fill in the desired bitmap properties
    //

    DEVBITMAPINFO   dbmi;
    dbmi.cxBitmap   = cx;
    dbmi.cyBitmap   = cy;
    dbmi.hpal       = hpal;
    dbmi.iFormat    = iFormat;
    dbmi.fl         = BMF_TOPDOWN;

    if (po.bUMPD())
    {
        dbmi.fl |= UMPD_SURFACE;
    }

    //
    // See if the device driver will manage the bitmap.
    //

    if ((bDriverCreatible) &&
        (PPFNVALID(po,CreateDeviceBitmap)))
    {
        //
        // Ok the device exports the entry point.  Let's call him up.
        //

        HSURF   hsurf;

        SIZEL sizlTemp;
        sizlTemp.cx = cx;
        sizlTemp.cy = cy;

        hsurf = (HSURF) (*PPFNDRV(po,CreateDeviceBitmap))(po.dhpdev(),
                                                          sizlTemp,
                                                          dbmi.iFormat);

        if (hsurf && (LongToHandle(HandleToLong(hsurf)) != (HANDLE)-1))
        {
            SURFREF so(hsurf);
            ASSERTGDI(so.bValid(), "ERROR device gave back invalid handle");

            //
            // Device Format Bitmaps (DFBs) are a subset of Device
            // Depdendent Bitmaps (DDBs):
            //

            so.ps->vSetDeviceDependentBitmap();
            so.ps->vSetApiBitmap();

            //
            // DFBs must always be accessed under the devlock, in part
            // because they have to be deleted and recreated when a
            // dynamic mode change occurs.
            //

            so.ps->vSetUseDevlock();

            if (dbmi.hpal != (HPALETTE) 0)
            {
                EPALOBJ palSurf(dbmi.hpal);
                ASSERTGDI(palSurf.bValid(), "ERROR invalid palette CreateCompatibleBitmap");

                //
                // Set palette into surface.
                //

                so.ps->ppal(palSurf.ppalGet());

                //
                // Reference count it by making sure it is not unlocked.
                //

                palSurf.ppalSet((PPALETTE) NULL);  // It won't be unlocked
            }

            //
            // Zero memory by sending a bitblt command to device
            //

            RECTL rclDst;

            rclDst.left   = 0;
            rclDst.top    = 0;
            rclDst.right  = cx;
            rclDst.bottom = cy;

            (*(so.ps->pfnBitBlt()))(
                            so.pSurfobj(),
                            (SURFOBJ *)NULL,
                            (SURFOBJ *)NULL,
                            (CLIPOBJ *)NULL,
                            NULL,
                            &rclDst,
                            (POINTL *)NULL,
                            (POINTL *)NULL,
                            (EBRUSHOBJ *)NULL,
                            (POINTL *)NULL,
                            0x0);

            return(hsurf);
        }
    }

    SURFMEM SurfDimo;

    SurfDimo.bCreateDIB(&dbmi, (PVOID) NULL);

    if (!SurfDimo.bValid())
    {
        return(0);
    }

    //
    // Mark the bitmap a keeper.
    //

    SurfDimo.vKeepIt();
    SurfDimo.ps->vSetDeviceDependentBitmap();
    SurfDimo.ps->vSetApiBitmap();
    SurfDimo.ps->hdev(po.hdev());
    return(SurfDimo.ps->hsurf());
}

/******************************Public*Routine******************************\
* HBITMAP GreCreateCompatibleBitmap(hdc,cx,cy)
*
* GDI Interface routine to create a bitmap.
*
* History:
*  Mon 06-Nov-1995 -by- Tom Zakrajsek [tomzak]
* Add overflow checking for cx*cy.
*
*  Mon 01-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Add IC support.
*
*  Fri 25-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY GreCreateCompatibleBitmap(HDC hdc, int cx, int cy)
{
    BOOL bDriver;
    HSURF hsurf;
    HPALETTE hpal;
    ULONG iFormat;

    bDriver = TRUE;
    if (cy & CCB_NOVIDEOMEMORY)
    {
        cy &= ~CCB_NOVIDEOMEMORY;
        bDriver = FALSE;
    }

    //
    // Validate the width and height
    //

    if ((cx <= 0) || (cy <= 0))
    {
        WARNING("GreCreateCompatibleBitmap failed - cx or cy was <= 0\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    
    ULONGLONG   cjTotal =  (ULONGLONG) cx * (ULONGLONG) cy;

    //
    // Assume worse case (32bpp pixels) and calculate possible overflow condition
    //
    // BUGFIX #172447 12-12-2000 bhouse
    //
    // NOTE: Tom Zakrajsek added a fairly restrictive checking of cx/cy in 1995
    //       and we have modified this check to be less restrictive.  It appears the
    //       check was to avoid potential numeric overflow when cx and cy are multiplied
    //       together with bytes per pixel.  It is kinda goofy to have this check
    //       here though as the possible overflow does not even occur in this
    //       routine but farther down in the call stack.  We will leave the modified
    //       check here to avoid introducing a possible regression.
    //

    if(cjTotal  > (ULONG_MAX >> 2))
    {
        WARNING("GreCreateCompatibleBitmap failed - size too big");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBITMAP) 0);
    }

    //
    // Without an hdc we create a monochrome bitmap.
    //

    if (hdc == (HDC) NULL)
        return(GreCreateBitmap(cx, cy, 1, 1, (LPBYTE) NULL));

    //
    // Ok lock down the hdc and the surface.
    //

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("CreateCompatibleBitmap failed - invalid hdc\n");
        return((HBITMAP) 0);
    }

    //
    // NOTE:  Even though we touch the SURFOBJ, we actually aren't going to read
    // or write it.  We just need some of its information.
    //

    PDEVOBJ po(dco.hdev());

    //
    // We must hold a lock to protect against the dynamic mode change
    // code and to synchronize access to the drivers.
    //

    {
        DEVLOCKOBJ dlo(po);

        PSURFACE pSurf = dco.pSurfaceEff();

        hpal = 0;

        if (dco.dctp() == DCTYPE_MEMORY)
        {
            iFormat = pSurf->iFormat();

            if (pSurf->ppal() != NULL)
            {
                hpal = (HPALETTE) pSurf->ppal()->hGet();
            }
        }
        else
        {
            iFormat = po.iDitherFormat();

            if (!po.bIsPalManaged())
            {
                hpal = (HPALETTE) po.ppalSurf()->hGet();
            }
        }

        hsurf = hsurfCreateCompatibleSurface(dco.hdev(),
                                             iFormat,
                                             hpal,
                                             cx,
                                             cy,
                                             bDriver);
    }

    GreSetBitmapOwner((HBITMAP) hsurf, OBJECT_OWNER_CURRENT);

    return((HBITMAP) hsurf);
}

/******************************Public*Routine******************************\
* GreSetBitmapBits
*
* Does the work for SetBitmapBits.
*
* History:
*  19-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LONG
GreSetBitmapBits(
    HBITMAP hbm,
    ULONG cjTotal,
    PBYTE pjBuffer,
    PLONG pOffset
    )
{

    if (cjTotal == 0)
    {
        return(0);
    }

    LONG lReturn = 0;

    SURFREF  SurfBmo((HSURF) hbm);
    SURFMEM  SurfDimo;
    PSURFACE pSurf;

    pSurf = SurfBmo.ps;

    if (SurfBmo.bValid() && SurfBmo.ps->bApiBitmap())
    {
        LONG lInitOffset = *pOffset;
        SURFOBJ soTemp;
        ERECTL erclDst;
        POINTL ptlSrc;

        soTemp.dhsurf        = 0;
        soTemp.hsurf         = 0;
        soTemp.dhpdev        = SurfBmo.ps->dhpdev();
        soTemp.hdev          = SurfBmo.ps->hdev();
        soTemp.sizlBitmap.cx = SurfBmo.ps->sizl().cx;
        soTemp.sizlBitmap.cy = SurfBmo.ps->sizl().cy;
        soTemp.cjBits        = cjTotal;
        soTemp.pvBits        = pjBuffer;
        soTemp.pvScan0       = 0;
        soTemp.lDelta        = lInitOffset;
        soTemp.iUniq         = 0;
        soTemp.iType         = (USHORT) STYPE_BITMAP;
        soTemp.fjBitmap      = 0;

        ptlSrc.x = 0;
        ptlSrc.y = 0;
        erclDst.left = 0;
        erclDst.top  = 0;
        erclDst.right  = SurfBmo.ps->sizl().cx;
        erclDst.bottom = SurfBmo.ps->sizl().cy;

        HSEMAPHORE hsemDevLock = NULL;
        PPDEV ppdev            = NULL;

        if (SurfBmo.ps->bUseDevlock())
        {
            PDEVOBJ po(SurfBmo.ps->hdev());
            ASSERTGDI(po.bValid(), "PDEV invalid");
            hsemDevLock = po.hsemDevLock();
            ppdev       = po.ppdev;
            GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
        }

        if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
        {
            DEVBITMAPINFO   dbmi;

            dbmi.iFormat    = SurfBmo.ps->iFormat();
            dbmi.cxBitmap   = SurfBmo.ps->sizl().cx;
            dbmi.cyBitmap   = SurfBmo.ps->sizl().cy;
            dbmi.hpal       = 0;
            dbmi.fl         = SurfBmo.ps->bUMPD() ? UMPD_SURFACE : 0;

            //
            // Create a DIB (SurfDimo) with the same height,width,
            // and BPP as the DEVBITMAP passed in
            //

            if (!SurfDimo.bCreateDIB(&dbmi,NULL))
            {
                WARNING("GreSetBitmapBits failed bCreateDIB\n");
                lInitOffset = -1;  // This is to make us fail the call below.
            }
            else
            {
                pSurf = SurfDimo.ps;

                //
                // We don't need to copy if the offset is 0 because either
                // it's a 1 shot set that inits the whole thing, or else
                // it's the first of a batch.  In either case anything
                // that's there before doesn't need to be saved because
                // it will all be over-written when we are done.
                //

                if (lInitOffset != 0)
                {
                    BOOL bCopyRet = EngCopyBits
                                    (
                                        pSurf->pSurfobj(),
                                        SurfBmo.pSurfobj(),
                                        NULL,
                                        NULL,
                                        &erclDst,
                                        &ptlSrc
                                    );

                    ASSERTGDI(bCopyRet, "ERROR how can this fail ?");
                }
            }
        }

        //
        // Check for invalid initial offset.
        //

        if (lInitOffset >= 0)
        {
            PDEVOBJ po(SurfBmo.ps->hdev());

            //
            // Inc the target surface uniqueness
            //

            INC_SURF_UNIQ(SurfBmo.ps);

            //
            // Copy the buffer to the DIB
            //

            BOOL bReturn = bDoGetSetBitmapBits(pSurf->pSurfobj(),&soTemp,FALSE);

            ASSERTGDI(bReturn, "GreSetBitmapBits failed bDoGetSetBitmapBits\n");

            lReturn = soTemp.cjBits;
            *pOffset = lInitOffset + lReturn;

            if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
            {
                //
                // Have the driver copy the temp DIB to the DEVBITMAP
                //

                if (!((*PPFNGET(po,CopyBits,SurfBmo.ps->flags())) (
                        SurfBmo.pSurfobj(),
                        pSurf->pSurfobj(),
                        NULL,
                        NULL,
                        &erclDst,
                        &ptlSrc)))
                {
                    WARNING("GreSetBitmapBits failed copying temp DIB to DFB\n");
                    lReturn = 0;
                }
            }
        }

        if (hsemDevLock)
        {
            GreExitMonitoredSection(ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(hsemDevLock);
        }
    }
    else
    {
       WARNING("GreSetBitmapBits failed - invalid bitmap handle\n");
       SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(lReturn);
}

/******************************Public*Routine******************************\
* GreGetBitmapBits
*
* Does the work for GetBitmapBits
*
* Returns: Number of bytes copied, or if pjBuffer is NULL the total size of
*          the bitmap.
*
* History:
*  Mon 01-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Return bitmap scanlines in BMF_TOPDOWN organization.
*
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LONG GreGetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset)
{

    LONG lReturn = 0;

    SURFREF SurfBmo((HSURF) hbm);

    if (SurfBmo.bValid() && SurfBmo.ps->bApiBitmap())
    {
        SURFMEM SurfDimo;
        SURFACE *pSurf;
        PDEVOBJ pdo(SurfBmo.ps->hdev());

        pSurf = SurfBmo.ps;

        lReturn = ((((gaulConvert[SurfBmo.ps->iFormat()] * SurfBmo.ps->sizl().cx) + 15) >> 4) << 1) * SurfBmo.ps->sizl().cy;

        if (pjBuffer != (PBYTE) NULL)
        {
            SURFOBJ soTemp;
            ERECTL erclDst;
            POINTL ptlSrc;

            soTemp.dhsurf        = 0;
            soTemp.hsurf         = 0;
            soTemp.dhpdev        = SurfBmo.ps->dhpdev();
            soTemp.hdev          = SurfBmo.ps->hdev();
            soTemp.sizlBitmap.cx = SurfBmo.ps->sizl().cx;
            soTemp.sizlBitmap.cy = SurfBmo.ps->sizl().cy;
            soTemp.cjBits        = 0;
            soTemp.pvBits        = 0;
            soTemp.pvScan0       = 0;
            soTemp.lDelta        = 0;
            soTemp.iUniq         = 0;
            soTemp.iType         = (USHORT) STYPE_BITMAP;
            soTemp.fjBitmap      = 0;

            ptlSrc.x = 0;
            ptlSrc.y = 0;
            erclDst.left = 0;
            erclDst.top  = 0;
            erclDst.right  = SurfBmo.ps->sizl().cx;
            erclDst.bottom = SurfBmo.ps->sizl().cy;

            HSEMAPHORE hsemDevLock = NULL;
            PPDEV ppdev            = NULL;
            
            if (SurfBmo.ps->bUseDevlock())
            {
                PDEVOBJ po(SurfBmo.ps->hdev());
                ASSERTGDI(po.bValid(), "PDEV invalid");
                hsemDevLock = po.hsemDevLock();
                ppdev       = po.ppdev;
                GreAcquireSemaphoreEx(hsemDevLock, SEMORDER_DEVLOCK, NULL);
                GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
            }

            if (SurfBmo.ps->iType() == STYPE_DEVBITMAP)
            {
                //
                // Create a DIB (SurfDimo) with the same height,width,
                // and BPP as the DEVBITMAP passed in
                //

                DEVBITMAPINFO   dbmi;

                dbmi.iFormat    = SurfBmo.ps->iFormat();
                dbmi.cxBitmap   = SurfBmo.ps->sizl().cx;
                dbmi.cyBitmap   = SurfBmo.ps->sizl().cy;
                dbmi.hpal     = 0;
                dbmi.fl       = SurfBmo.ps->bUMPD() ? UMPD_SURFACE : 0;

                if (!SurfDimo.bCreateDIB(&dbmi,NULL))
                {
                    WARNING("GreGetBitmapBits failed bCreateDIB\n");
                    lReturn = 0;
                }
                else
                {
                    pSurf = SurfDimo.ps;

                    EngCopyBits(pSurf->pSurfobj(),
                                SurfBmo.pSurfobj(),
                                NULL,
                                NULL,
                                &erclDst,
                                &ptlSrc);
                }
            }

            if (lReturn)
            {
                //
                // We know how big the buffer needs to be.  Set up the
                // soTemp so the driver knows how much to fill in.
                //

                ULONG cjMaxLength = lReturn;
                LONG lInitOffset = *pOffset;

                //
                // Check for invalid initial offset.
                //

                if ((lInitOffset >= 0) && ((ULONG)lInitOffset < cjMaxLength))
                {
                    //
                    // Make cjTotal valid range.
                    //

                    if ((lInitOffset + cjTotal) > cjMaxLength)
                    {
                        cjTotal = cjMaxLength - lInitOffset;
                    }

                    if (cjTotal > 0)
                    {

                        //
                        // Fill in our return values, we know them already.
                        //

                        soTemp.cjBits = cjTotal;
                        soTemp.lDelta = lInitOffset;
                        soTemp.pvBits = pjBuffer;

                        BOOL bReturn = bDoGetSetBitmapBits(&soTemp,pSurf->pSurfobj(),TRUE);

                        ASSERTGDI(bReturn, "GreGetBitmapBits failed bDoGetSetBitmapBits\n");

                        lReturn = soTemp.cjBits;
                        *pOffset = lInitOffset + lReturn;
                    }
                    else
                    {
                        WARNING("GreGetBitmapBits failed cjTotal 0\n");
                        lReturn = 0;
                    }
                }
                else
                {
                    WARNING("GreGetBitmapBits failed lInitOffset invalid\n");
                    lReturn = 0;
                }
            }

            if (hsemDevLock)
            {
                GreExitMonitoredSection(ppdev, WD_DEVLOCK);
                GreReleaseSemaphoreEx(hsemDevLock);
            }
        }
    }
    else
    {
        WARNING("GreGetBitmapBits failed - invalid bitmap handle\n");

        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(lReturn);
}

/******************************Public*Routine******************************\
* bDoGetSetBitmapBits
*
* Does the get or set of bitmap bits for EngCopyBits.
*
* History:
*  16-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bDoGetSetBitmapBits(SURFOBJ *psoDst, SURFOBJ *psoSrc, BOOL bGetBits)
{

    ASSERTGDI(psoDst->iType == STYPE_BITMAP, "ERROR no DIB dst");
    ASSERTGDI(psoSrc->iType == STYPE_BITMAP, "ERROR no DIB src");

    //
    // Synchronize with the device driver before touching the device surface.
    //

    if (bGetBits)
    {
        //
        // Doing a GetBitmapBits.
        //

        PSURFACE pSurfSrc =  SURFOBJ_TO_SURFACE(psoSrc);

        {
            PDEVOBJ po(psoSrc->hdev);
            po.vSync(psoSrc,NULL,0);
        }

        if (psoDst->pvBits == NULL)
        {
            psoDst->cjBits = ((((gaulConvert[psoSrc->iBitmapFormat] * psoSrc->sizlBitmap.cx) + 15) >> 4) << 1) * psoSrc->sizlBitmap.cy;
        }
        else
        {
            //
            // Initialize temporaries.
            //

            PBYTE pjBuffer = (PBYTE) psoDst->pvBits;
            PBYTE pjBitmap = (PBYTE) psoSrc->pvScan0;
            LONG lDeltaBitmap  = psoSrc->lDelta;
            ULONG cjScanBitmap = pSurfSrc->cjScan();

            ASSERTGDI(pjBuffer != NULL, "ERROR pjBuffer is NULL");
            ASSERTGDI(pjBitmap != NULL, "ERROR pjBitmap is NULL");

            //
            // Get the WORD aligned width of the input scanlines.
            //

            ULONG cjScanInput = ((((gaulConvert[psoSrc->iBitmapFormat] * psoSrc->sizlBitmap.cx) + 15) >> 4) << 1);
            ULONG cjMaxLength = cjScanInput * psoSrc->sizlBitmap.cy;
            LONG lInitOffset = psoDst->lDelta;
            ULONG cjTotal = psoDst->cjBits;

            //
            // Check for invalid initial offset.
            //

            if ((lInitOffset < 0) || ((ULONG)lInitOffset >= cjMaxLength))
            {
                psoDst->cjBits = 0;
                return(FALSE);
            }

            //
            // Make cjTotal valid range.
            //

            if (lInitOffset + cjTotal > cjMaxLength)
            {
                cjTotal = cjMaxLength - lInitOffset;
            }

            //
            // Fill in our return values.
            //

            psoDst->cjBits = cjTotal;

            //
            // Move pointer to current scanline in bitmap.
            //

            pjBitmap += ((lInitOffset / cjScanInput) * lDeltaBitmap);

            ULONG ulTemp,ulCopy;

            //
            // Move partial scan if necesary.
            //

            ulTemp = (lInitOffset % cjScanInput);

            if (ulTemp)
            {
                ulCopy = MIN((cjScanInput - ulTemp), cjTotal);

                RtlCopyMemory((PVOID) pjBuffer, (PVOID) (pjBitmap + ulTemp), (unsigned int) ulCopy);

                pjBuffer += ulCopy;
                pjBitmap += lDeltaBitmap;
                cjTotal  -= ulCopy;
            }

            //
            // Move as many scans that fit.
            //

            ulTemp = cjTotal / cjScanInput;
            cjTotal -= (ulTemp * cjScanInput);

            while (ulTemp--)
            {
                RtlCopyMemory((PVOID) pjBuffer, (PVOID) pjBitmap, (unsigned int) cjScanInput);

                pjBuffer += cjScanInput;
                pjBitmap += lDeltaBitmap;
            }

            //
            // Move as much of partial scan as possible.
            //

            if (cjTotal)
            {
                RtlCopyMemory((PVOID) pjBuffer, (PVOID) pjBitmap, (unsigned int) cjTotal);
            }
        }
    }
    else
    {

        //
        // Doing a SetBitmapBits call.
        //

        PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

        {
            PDEVOBJ po(psoDst->hdev);
            po.vSync(psoDst,NULL,0);
        }

        //
        // Initialize temporaries.
        //

        PBYTE pjBuffer = (PBYTE) psoSrc->pvBits;
        PBYTE pjBitmap = (PBYTE) psoDst->pvScan0;
        LONG lDeltaBitmap = psoDst->lDelta;
        ULONG cjScanBitmap = pSurfDst->cjScan();

        //
        // Get the WORD aligned width of the input scanlines.
        //

        ULONG cjScanInput = ((((gaulConvert[psoDst->iBitmapFormat] * psoDst->sizlBitmap.cx) + 15) >> 4) << 1);
        ULONG cjMaxLength = cjScanInput * psoDst->sizlBitmap.cy;
        LONG lInitOffset = psoSrc->lDelta;
        ULONG cjTotal = psoSrc->cjBits;

        //
        // Check for invalid initial offset.
        //

        if ((lInitOffset < 0) || ((ULONG)lInitOffset >= cjMaxLength))
        {
            psoSrc->cjBits = 0;
            return(TRUE);
        }

        //
        // Make cjTotal valid range.
        //

        if (lInitOffset + cjTotal > cjMaxLength)
        {
            cjTotal = cjMaxLength - lInitOffset;
        }

        //
        // Fill in our return values, we know them already.
        //

        psoSrc->cjBits = cjTotal;

        //
        // Move pointer to current scanline in bitmap.
        //

        pjBitmap += ((lInitOffset / cjScanInput) * lDeltaBitmap);

        ULONG ulTemp,ulCopy;

        //
        // Move partial scan if necesary.
        //

        ulTemp = (lInitOffset % cjScanInput);

        if (ulTemp)
        {
            ulCopy = MIN((cjScanInput - ulTemp), cjTotal);

            RtlCopyMemory((PVOID) (pjBitmap + ulTemp), (PVOID) pjBuffer, (unsigned int) ulCopy);

            pjBuffer += ulCopy;
            pjBitmap += lDeltaBitmap;
            cjTotal  -= ulCopy;
        }

        //
        // Move as many scans that fit.
        //

        ulTemp = cjTotal / cjScanInput;
        cjTotal -= (ulTemp * cjScanInput);

        while (ulTemp--)
        {
            RtlCopyMemory((PVOID) pjBitmap, (PVOID) pjBuffer, (unsigned int) cjScanInput);

            pjBuffer += cjScanInput;
            pjBitmap += lDeltaBitmap;
        }

        //
        // Move as much of partial scan as possible.
        //

        if (cjTotal)
        {
            RtlCopyMemory((PVOID) pjBitmap, (PVOID) pjBuffer, (unsigned int) cjTotal);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\textobj.cxx ===
/******************************module*header*******************************\
* Module Name: textobj.cxx
*
* Supporting routines for text output calls, ExtTextOut etc.
*
* Created: 08-Feb-1991 09:25:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1999 Microsoft Corporation
\**************************************************************************/


#include "precomp.hxx"

#define XFORMNULL (EXFORMOBJ *) NULL

VOID vGenWidths
(
    FIX    *pfxD1,
    FIX    *pfxD2,
    EFLOAT& efRA,
    EFLOAT& efRB,
    FIX     fxWidth,
    FIX     fxTop,
    FIX     fxBottom,
    FIX     fxMaxAscent
);

#define SO_ACCEL_FLAGS (SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE \
                        | SO_CHAR_INC_EQUAL_BM_BASE | SO_ZERO_BEARINGS)

BOOL bAdjusBaseLine(RFONTOBJ &rfoBase, RFONTOBJ &rfoLink, POINTL *pptlAdjustBaseLine);

/******************************Member*Function*****************************\
* ESTROBJ::vInit
*
* Constructor for ESTROBJ.  Performs the following operations:
*
*  1) Initialize the STROBJ fields for the driver.
*  2) Compute all character positions.
*  3) Compute the TextBox.
*  4) In the simplest cases, computes rectangles for underline and
*     strikeout.
*
* The TextBox is a parallelogram in device coordinates, whose sides are
* parallel to the transformed sides of a character cell, and which bounds
* all the character cells.  A and C spacings are taken into account to
* assure that it is a proper bound.
*
* We record the TextBox in an unusual notation.  If a line is constructed
* through the character origin of the first character in the string and in
* the direction of the ascent, then what we record as the "left" and
* "right" of the TextBox are really the distances from this line to each
* of those edges of the parallelogram, in device coordinates.  Likewise,
* the "top" and "bottom" are the distances from the baseline of the first
* character.  This completely determines the parallelogram, and is
* surprisingly easy to compute.  ExtTextOut later turns this data into the
* actual parallelogram, whereas the TextExtent functions turn this data
* into scalar extents.
*
* History:
*  Fri 13-Mar-1992 00:47:05 -by- Charles Whitmer [chuckwh]
* Rewrote from the ground up.
*
*  21-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vInit
(
    PWSZ        pwsz,
    LONG        cwc,
    XDCOBJ&  dco,
    RFONTOBJ&   rfo,
    EXFORMOBJ&  xo,
    LONG       *pdx,
    BOOL        bPdy,
    LONG        lEsc,
    LONG        lExtra,
    LONG        lBreakExtra,
    LONG        cBreak,
    FIX        xRef,
    FIX         yRef ,
    FLONG       flControl,
    LONG       *pdxOut,
    PVOID       pvBuffer,
    DWORD       CodePage
)
{
    EGLYPHPOS  *pg;
    GLYPHDATA  *pgd;
    UINT    ii;
    EFLOAT  efScaleX = xo.efM11();

    cGlyphs     = cwc;
    prfo        = &rfo;
    flTO        = 0L;

    flAccel     = bPdy ? SO_DXDY : 0L;

    // we don't want to substitute the symbol font
    // if its glyph set has been extended

    {
        PFE         *ppfe = rfo.ppfe();

        ASSERTGDI(ppfe->pfdg, "ESTROBJ::vInit invalid ppfe->pfdg \n");
        
        if (ppfe->pfdg->flAccel & GS_EXTENDED)
        {
            ASSERTGDI(ppfe->pifi->jWinCharSet == SYMBOL_CHARSET,
                      "ESTROBJ::vInit(): GS_EXTENDED set for on SYMBOL_CHARSET fonts\n");

            flAccel |= SO_DO_NOT_SUBSTITUTE_DEVICE_FONT;
        }
    }

    ulCharInc   = 0L;
    cgposCopied = 0;
    cgposPositionsEnumerated = 0;
    cExtraRects = 0;
    pgp         = NULL;
    pgpos       = NULL;
    pwszOrg     = pwsz;
    dwCodePage  = CodePage;
    xExtra      = 0; // will be computed later if needed
    xBreakExtra = 0; // will be computed later if needed

// fix the string if in GLYPH_INDEX mode, waste of time to be win95 compatible

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        flAccel |= SO_GLYPHINDEX_TEXTOUT;
        rfo.vFixUpGlyphIndices((USHORT *)pwsz, cwc);
    }

// Remember if the printer driver wants 28.4 char positions.

    PDEVOBJ po(rfo.hdevConsumer());

    if (po.bCapsHighResText())
        flTO |= TO_HIGHRESTEXT;

// Locate the GLYPHPOS array.  Use the buffer given, if there is one.  We
// need one more GLYPHPOS structure than there are glyphs.  The concatenation
// point is computed in the last one.

    if (pvBuffer)
    {
        pg = (EGLYPHPOS *) pvBuffer;
    }
    else
    {
        pg = (EGLYPHPOS *) PVALLOCTEMPBUFFER(SIZEOF_STROBJ_BUFFER(cwc));
        if (pg == (PGLYPHPOS) NULL)
            return;

        // Note that the memory has been allocated.

        flTO |= TO_MEM_ALLOCATED;
    }

    pgpos = pg;     // Make sure our cached value is in the structure.

// In Win 3.1 compatibility mode, we always assume that escapement is
// the same as orientation, except for vector fonts.  Make it explicitly so.

    if (rfo.iGraphicsMode() == GM_COMPATIBLE)
    {
        if (!(rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
           lEsc = rfo.ulOrientation();
    }

// Offset the reference point for TA_TOP and TA_BOTTOM.  Our GLYPHPOS
// structures always contain positions along the baseline.  The TA_BASELINE
// case is therefore already correct.

    switch (flControl & (TA_TOP | TA_BASELINE | TA_BOTTOM))
    {
    case TA_TOP:
        xRef -= rfo.ptfxMaxAscent().x;
        yRef -= rfo.ptfxMaxAscent().y;
        break;

    case TA_BOTTOM:
        xRef -= rfo.ptfxMaxDescent().x;
        yRef -= rfo.ptfxMaxDescent().y;
        break;
    }

/**************************************************************************\
* [Win 3.1 compatibility issue]
*
* Adjust pdx array if there is a non-zero lExtra.
*
* This is only done under compatibility mode and only when using non-vector
* fonts on a non-display device.
\**************************************************************************/

    if ( lExtra
         && (pdx != (LONG *) NULL)
         && (rfo.iGraphicsMode() == GM_COMPATIBLE)
         && (!(rfo.prfnt->flInfo & FM_INFO_TECH_STROKE))
         && po.bDisplayPDEV() )
    {
        LONG *pdxAdj = pdx;
        LONG *pdxEnd;

        if (!bPdy)
        {
            pdxEnd = pdx + cwc;

            for (;pdxAdj < pdxEnd; pdxAdj += 1)
                *pdxAdj += lExtra;
        }
        else
        {
            pdxEnd = pdx + 2*cwc;

            for (;pdxAdj < pdxEnd; pdxAdj += 2)
                *pdxAdj += lExtra;
        }
    }

/**************************************************************************\
* Handle all horizontal special cases.
\**************************************************************************/

    if (
        ((lEsc | rfo.ulOrientation()) == 0)
        && xo.bScale()
        && !xo.efM22().bIsNegative()  // Otherwise the ascent goes down.
        && !efScaleX.bIsNegative()    // Otherwise A and C spaces get confused.
       )
    {
        /**********************************************************************\
        * We provide several special routines to calculate the character
        * positions and TextBox.  Each routine is responsible for calculating:
        *
        *  1) Each position
        *  2) Bounding coordinates.
        *  3) The ptfxUpdate vector.
        *  4) The flAccel flags.
        \**********************************************************************/

        if (pdx != NULL)
        {
        // Case H1: A PDX array is provided.

            if (!bPdy)
            {
                vCharPos_H1(
                        dco,
                        rfo,xRef,yRef,pdx,efScaleX);
            }
            else
            {
                if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
                {
                // In H4 case we want to force individual character underlining
                // as we do for esc!=orientation case,

                    if (!rfo.bCalcEscapement(xo,lEsc))
                        return;
                    flTO |= TO_ESC_NOT_ORIENT;
                }

                vCharPos_H4(
                        dco,
                        rfo,xRef,yRef,pdx, efScaleX,xo.efM22());
            }

        }

        else if (rfo.lCharInc() && ((lExtra | lBreakExtra) == 0))
        {
        // Case H2: Characters have constant integer width.

            vCharPos_H2(dco,rfo,xRef,yRef,efScaleX);
        }

        else
        {
        // Case H3: The general case.

            vCharPos_H3(dco,rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,efScaleX);
        }

        /**********************************************************************\
        * Horizontal special cases done!
        *
        * It remains only to finish the alignment.
        \**********************************************************************/

        // Offset all the relevant points if our alignment is RIGHT or CENTER.
        // Also correct the CP update vector.

        ptfxEscapement.x = ptfxUpdate.x;        // Remember this for underlining.
        ptfxEscapement.y = ptfxUpdate.y;

        if (flControl & (TA_RIGHT | TA_CENTER))
        {
            FIX dx = ptfxUpdate.x;

            if ((flControl & TA_CENTER) == TA_CENTER)
            {
                dx /= 2;
                ptfxUpdate.x = 0;       // Don't update CP.
            }
            else
            {
                ptfxUpdate.x = -ptfxUpdate.x; // Reverse the CP update.
            }

            pg = pgpos;
            dx = FXTOL(dx + 8);             // Convert to LONG for pgp adjusts
            xRef = ((pg++)->ptl.x -= dx);   // Always adjust the first one.
            xRef = LTOFX(xRef);             // Convert back to FIX for later

            if (ulCharInc == 0)
            {
                for (ii=0; ii<(ULONG) cwc-1; ii++)
                    (pg++)->ptl.x -= dx;
            }
        }

        // Fill in a pdxOut array.

        if (pdxOut != (LONG *) NULL)
        {
            EFLOAT efDtoW = rfo.efDtoWBase();

        if (ulCharInc && !bLinkedGlyphs())
            {
                FIX dx, xSum;

                dx = lCvt(efDtoW,LTOFX(ulCharInc));
                xSum = 0;
                for (ii=0; ii<(ULONG) cwc; ii++)
                {
                    xSum += dx;
                    *pdxOut++ = xSum;
                }
            }
            else
            {
                pg = pgpos + 1; // skip the first element
                for (ii=0; ii<(ULONG) cwc-1; ii++,pg++)
                    *pdxOut++ = lCvt(efDtoW,LTOFX(pg->ptl.x) - xRef);

            // Unfortunately, to be consistent with the rounding we've done
            // in the above cases, we can't simply compute this last one
            // as: *pdxOut = lCvt(efDtoW,ptfxUpdate.x):

                *pdxOut = lCvt(efDtoW, ((ptfxUpdate.x + xRef) & ~0xf) - xRef);
            }
        }

        ptfxRef.x = LTOFX(pgpos->ptl.x);
        ptfxRef.y = LTOFX(pgpos->ptl.y);
    }

/**************************************************************************\
* Handle the harder cases, i.e general orientations and transforms are
* allowed.
\**************************************************************************/

    else
    {
        if (!bPdy)
        {
            if (lEsc == (LONG)rfo.ulOrientation())
            {
                if (pdx != NULL)
                {
                // Case G1: A PDX array is provided.  Escapement == Orientation.

                    vCharPos_G1(dco,rfo,xRef,yRef,pdx,pdxOut);
                }
                else // (pdx == NULL)
                {
                // Case G2: No PDX array.  Escapement == Orientation.

                    vCharPos_G2(dco,rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,pdxOut);
                }
            }
            else // lEsc!=rfo.ulOrientation()
            {
            // Case G3: Escapement != Orientation.

                // Make sure escapement vectors and data are up to date.

                if (!rfo.bCalcEscapement(xo,lEsc))
                    return;
                flTO |= TO_ESC_NOT_ORIENT;
                flAccel |= SO_ESC_NOT_ORIENT;

                vCharPos_G3
                (
                dco,
                rfo,
                xRef,yRef,
                lExtra,lBreakExtra,cBreak,
                pdx,
                pdxOut
                );
            }
        }
        else // pdy case
        {
        // Make sure escapement vectors and data are up to date.

            if (!rfo.bCalcEscapement(xo,lEsc))
                return;
            flTO |= TO_ESC_NOT_ORIENT;

            vCharPos_G4
            (
                dco,
                rfo,
                xRef,
                yRef,
                pdx
            );
        }


        /**********************************************************************\
        * General special cases done!
        *
        * It remains only to finish the alignment.
        \**********************************************************************/

        // Offset all the relevant points if our alignment is RIGHT or CENTER.
        // Also correct the CP update vector.

        ptfxEscapement = ptfxUpdate;        // Remember this for underlining.

        if (flControl & (TA_RIGHT | TA_CENTER))
        {
            FIX dx = ptfxUpdate.x;
            FIX dy = ptfxUpdate.y;

            if ((flControl & TA_CENTER) == TA_CENTER)
            {
                dx /= 2;
                dy /= 2;
                ptfxUpdate.x = 0;         // No CP update.
                ptfxUpdate.y = 0;
            }
            else
            {
                ptfxUpdate.x = -ptfxUpdate.x; // Reverse the CP update.
                ptfxUpdate.y = -ptfxUpdate.y;
            }

            pg = pgpos;
            for (ii=0; ii<(ULONG)cwc; ii++)
            {
                pg->ptl.x -= dx;
                pg->ptl.y -= dy;
                pg++;
            }
            xRef -= dx;
            yRef -= dy;
        }

        // Convert the FIX coordinates to LONG for low res devices.

        pg = pgpos;

        ptfxRef.x = xRef;
        ptfxRef.y = yRef;

        for (ii=0; ii<(ULONG)cwc; ii++,pg++)
        {
            pg->ptl.x = FXTOL(pg->ptl.x + 8);
            pg->ptl.y = FXTOL(pg->ptl.y + 8);
        }
    }

// Fill in the underline and strikeout rectangles.  The horizontal cases
// are the only ones that can use the extra rectangles of DrvTextOut to
// draw the lines quickly.  We'll use a PATHOBJ (in a separate optional
// method) for the complex cases.

    if (flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT))
    {
        flTO |= flControl & (TSIM_UNDERLINE1 | TSIM_STRIKEOUT);

        if (((lEsc | rfo.ulOrientation() | bPdy) == 0) && xo.bScale())
        {
            ERECTL *prcl = (ERECTL *) &arclExtra[cExtraRects];

        // Round off the starting point and update width to pels.

            LONG x  = FXTOL(xRef+8);
            LONG y  = FXTOL(yRef+8);
            LONG dx = FXTOL(ptfxEscapement.x+8);

            if (flControl & TSIM_UNDERLINE1)
            {
                prcl->right  = (prcl->left = x + rfo.ptlUnderline1().x) + dx;
                prcl->bottom = (prcl->top  = y + rfo.ptlUnderline1().y)
                           + rfo.ptlULThickness().y;
                prcl->vOrder();

                cExtraRects++;
                prcl++;
            }

            if (flControl & TSIM_STRIKEOUT)
            {
                prcl->right  = (prcl->left = x + rfo.ptlStrikeOut().x) + dx;
                prcl->bottom = (prcl->top  = y + rfo.ptlStrikeOut().y)
                           + rfo.ptlSOThickness().y;
                prcl->vOrder();

                cExtraRects++;
                prcl++;
            }

        // Put a NULL rectangle at the end of the list.

            prcl->left   = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
            prcl->top    = 0;
        }
    }

    if ( rfo.prfnt->fobj.flFontType & RASTER_FONTTYPE )
    {
        flTO |= TO_BITMAPS;
    }
    else
    {
        flTO &= ~TO_BITMAPS;
    }
}

/******************************Member*Function*****************************\
* ESTROBJ::vInitSimple
*
* Constructor for ESTROBJ.  Performs the following operations:
*
*  1) Initialize the STROBJ fields for the driver.
*  2) Compute all character positions.
*  3) Compute the TextBox.
*  4) Stores the TextBox in the ESTROBJ. <--- Note!
*
* The is the special case code for the console, so we ignore transforms
* and other fancy options.
*
* Note that you don't need to call bOpaqueArea to get rclBkGround
* initialized.  This is a difference from the normal vInit.
*
* History:
*  Thu 17-Sep-1992 17:32:10 -by- Charles Whitmer [chuckwh]
* Took the vInit code and simplified it for the special console case.
\**************************************************************************/


VOID ESTROBJ::vInitSimple
(
    PWSZ    pwsz,
    LONG    cwc,
    XDCOBJ&  dco,
    RFONTOBJ&   rfo,
    LONG    xRef,
    LONG    yRef,
    PVOID   pvBuffer
)
{
// Characters have constant integer width.  We will also ignore the A and C spaces.

    EGLYPHPOS  *pg;
    cGlyphs = cwc;
    prfo    = &rfo;
    cgposCopied = 0;
    pgp     = NULL;
    pwszOrg = pwsz;

    ASSERTGDI(cwc > 0, "Count of glyphs must be greater than zero");

// Locate the GLYPHPOS array.  Try to use the default one on the stack.  We
// need one more GLYPHPOS structure than there are glyphs.  The concatenation
// point is computed in the last one.

    if (pvBuffer)
    {
        pg = (EGLYPHPOS *) pvBuffer;
    }
    else
    {
        pg = (EGLYPHPOS *) PVALLOCTEMPBUFFER(SIZEOF_STROBJ_BUFFER(cwc));
        if (pg == (PGLYPHPOS) NULL)
            return;

    // Note that the memory has been allocated.

        flTO |= TO_MEM_ALLOCATED;
    }
    pgpos = pg;     // Make sure our cached value is in the structure.

// Compute device driver accelerator flags.

    flAccel = SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cwc, pg, pwsz, &bAccel, &dco, this))
        return;

    if ( bAccel )
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// We leave these variables uninitialized in this simple case.
// BE CAREFUL!

    // cExtraRects = 0;
    // ptfxUpdate.x = dx;
    // ptfxUpdate.y = 0;
    // ptfxEscapement = ptfxUpdate;
    // ptfxRef.x = xRef;
    // ptfxRef.y = yRef;

// Offset the reference point for TA_TOP.  Our GLYPHPOS structures always contain
// positions along the baseline.

// We assume that displays never set the GCAPS_HIGHRESTEXT bit.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef + rfo.lMaxAscent();

// Set the width accelerator.  When the device driver sees ulCharInc
// non-zero, it must not expect any more x coordinates.

    ulCharInc = rfo.lCharInc();


#ifdef FE_SB
// If this is a SBCS linked to a DBCS font the font is really "binary pitch" and we
// should ignore ulCharInc. In the case of a DBCS TT font, the font is also really
// "binary pitch" and the TT driver will set ulCharInc to 0.  In either case use
// the individual glyph metrics to lay out glyphs.  This is slightly slower than
// the fixed pitch optimization but not enough to be significant.

    if( bLinkedGlyphs() || (ulCharInc == 0) )
    {
        FIX  xA , xLeft , xRight;
        UINT ii;

        ulCharInc = 0;

    // Calculate the left bound using only the first glyph.

        xLeft = pg->pgd()->fxA;

    // Handle the remaining glyphs in this batch.

        xA = 0; // Distance along the escapement (x) in device coords.
        for (ii=1; ii<(unsigned) cwc; ii++)
        {

        // Compute the next position.

            xA += pg->pgd()->fxD;
            pg++;
            pg->ptl.x = xRef + FXTOL(8 + xA);
            pg->ptl.y = yRef + rfo.lMaxAscent();
        }

    // Calculate the right bound.  This is easier than the general case since
    // there's no extra spacing.

        xRight = xA + pg->pgd()->fxAB;

    // Compute the bounding rectangle.

        rclBkGround.left   = xRef + FXTOL(xLeft);
        rclBkGround.right  = xRef + FXTOLCEILING(xRight);
        rclBkGround.top    = yRef;
        rclBkGround.bottom = yRef + rfo.lMaxHeight();
    }
    else
    {

#endif

// Compute the bounding rectangle.

    rclBkGround.left   = xRef;
    rclBkGround.right  = xRef + cwc * ulCharInc;
    rclBkGround.top    = yRef;
    rclBkGround.bottom = yRef + rfo.lMaxHeight();

    }

// color filtering causes spill on each side for cleartype

    if (rfo.pfo()->flFontType & FO_CLEARTYPE_X)
    {
        rclBkGround.left -= 1;
        rclBkGround.right += 1;
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
*
* Routine Name: "ESTROBJ::vCorrectBackGround"
*
* Routine Description:
*
*     If a glyph lies outside the background rectangle
*     the background rectangle is expanded to contain
*     the errant glyph. This is a hack routine to fix
*     some anomalies found when rendering texts at
*     arbitrary angles.
*
* Arguments:
*
*   pfo             a pointer to the associated FONTOBJ
*                   This is used to inform us if the
*                   font contains bitmaps
*
* Return Value: TRUE if string is consistent FALSE if not.
*
\**************************************************************************/

#if DBG
void ESTROBJ::vCorrectBackGroundError(GLYPHPOS *pgp)
{
    GLYPHBITS *pgb = pgp->pgdf->pgb;
    char *psz = "vCorrectBackGround: Glyph found outside background rectangle";

    DbgPrint("\n");
    DbgPrint("\n");
    DbgPrint("%s\n", psz);
    DbgPrint("STROJB* = %-#x\n", this);

    DbgPrint(
        "rclBkGround = %d %d %d %d\n",
        rclBkGround.left,
        rclBkGround.top,
        rclBkGround.right,
        rclBkGround.bottom
    );
    DbgPrint("pgp = %-#x\n", pgp);
    DbgPrint("    hg  = %-#x\n",  pgp->hg);
    DbgPrint("    ptl = %d %d\n", pgp->ptl.x, pgp->ptl.y);
    DbgPrint("    pgb = %-#x\n",  pgb);
    DbgPrint("        ptlOrigin = %d %d\n", pgb->ptlOrigin.x, pgb->ptlOrigin.y);
    DbgPrint("        sizlBitmap = %d %d\n", pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
    DbgPrint("\n");
    RIP("Stopping for debugging\n");
}

void ESTROBJ::vCorrectBackGround()
{
    LONG l;                     // place holder for glyph bitmap coord
    GLYPHPOS *pgp, *pgp_;
    GLYPHBITS *pgb;

    if (
        ((flAccel & SO_FLAG_DEFAULT_PLACEMENT) == 0 ) &&
        ( flTO & TO_BITMAPS                         ) &&
        ( pgpos                                     )
    )
    {
        pgp_ = pgpos + cGlyphs;
        for ( pgp = pgpos ; pgp < pgp_ ; pgp++ ) {
            if ( pgb = pgp->pgdf->pgb )
            {
                l = pgp->ptl.x + pgb->ptlOrigin.x;
                if ( l < rclBkGround.left )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.left = l;
                }
                l += pgb->sizlBitmap.cx;
                if ( l > rclBkGround.right )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.right = l;
                }
                l = pgp->ptl.y + pgb->ptlOrigin.y;
                if ( l < rclBkGround.top )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.top = l;
                }
                l += pgb->sizlBitmap.cy;
                if ( l > rclBkGround.bottom )
                {
                    vCorrectBackGroundError( pgp );
                    rclBkGround.bottom = l;
                }
            }
        }
    }
}

#endif


/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G3 (rfo,x,y,lExtra,lBreakExtra,cBreak,pdx,pdxOut)
*
* Computes character positions in the case where escapement does not equal
* orientation.  This is pretty tricky.  We have to make up vertical
* spacings.  Also, the character positions we record in the GLYPHPOS
* structure all have to be adjusted because for general escapements the
* concatenation point is not the same as the character origin.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*
* History:
*  Sun 22-Mar-1992 23:31:55 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vCharPos_G3
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    LONG     *pdx,
    LONG     *pdxOut
)
{
// In this case, we keep track of how far we have traveled along the
// escapement vector in device coordinates.  We need scales to project
// this distance onto the base and ascent, as well as a unit escapement
// vector to find the position.

    POINTFL pteEsc  = rfo.pteUnitEsc();     // Unit escapement vector.
    EFLOAT efScaleX = rfo.efEscToBase();    // Project escapement to baseline.
    EFLOAT efScaleY = rfo.efEscToAscent();  // Project escapement to ascent.

// Compute logical to device transforms.

    EFLOAT efWtoDEsc = rfo.efWtoDEsc(); // Forward transform for pdx.
    EFLOAT efDtoWEsc = rfo.efDtoWEsc(); // Back transform for pdxOut.

// Compute extra spacing for the non-pdx case.

    FIX    fxD1,fxD2;       // Pre- and Post-center character widths.
    FIX    fxAscent  = rfo.fxMaxAscent();  // Cache locally.
    HGLYPH hgBreak;

    if (pdx == (LONG *) NULL)
    {
        // Calculate the lExtra and lBreakExtra spacing.

        xExtra      = 0;
        xBreakExtra = 0;
        hgBreak     = 0;

        if (lExtra)
        {
            xExtra = lCvt(rfo.efWtoDEsc(),lExtra);
        }
        if (lBreakExtra && cBreak)
        {
            xBreakExtra = lCvt(rfo.efWtoDEsc(),lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

            vGenWidths
            (
            &fxD1,          // Pre-center spacing
            &fxD2,          // Post-center spacing
            efScaleY,       // Ascent projection
            efScaleX,       // Baseline projection
            rfo.fxBreak(),      // Character width
            fxAscent,       // Ink box top
            0,          // Ink box bottom
            fxAscent        // Maximum Ascent
            );
            if (fxD1 + fxD2 + xBreakExtra + xExtra < 0)
                xBreakExtra = -(fxD1 + fxD2 + xExtra);
            hgBreak = rfo.hgBreak();
        }
    }

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    LONG   xSum;        // Keep pdx sum here.
    FIX    xA,xB;       // Baseline coordinates.
    FIX    yA,yB;       // Ascent coordinates.
    FIX    sA;          // Position on the escapement vector.
    RECTFX rcfxBounds;      // Accumulate bounds here.
    UINT   ii;
    FIX    fxDescent = rfo.fxMaxDescent(); // Cache locally.

    rcfxBounds.xLeft   = LONG_MAX; // Start with an empty TextBox.
    rcfxBounds.xRight  = LONG_MIN;
    rcfxBounds.yTop    = LONG_MIN;
    rcfxBounds.yBottom = LONG_MAX;

    ASSERTGDI(cGlyphs > 0, "G3, cGlyphs == 0\n");

// We keep the current concatenation point in sA.  Note that this is NOT
// where the character origin will be placed.

    sA   = 0;
    xSum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    BOOL bZeroBearing = ( rfo.flRealizedType() & SO_ZERO_BEARINGS ) && !bLinkedGlyphs();

    for (ii=0; ii<cGlyphs; ii++)
    {
        pgd = pg->pgd();

    // Using the GenWidths function, determine where the
    // character center should be placed.

        vGenWidths
        (
            &fxD1,              // Pre-center spacing
            &fxD2,              // Post-center spacing
            efScaleY,           // Ascent projection
            efScaleX,           // Baseline projection
            pgd->fxD,           // Character width
            pgd->fxInkTop,      // Ink box top
            pgd->fxInkBottom,   // Ink box bottom
            fxAscent            // Maximum Ascent
        );

        sA += fxD1;         // Advance to the character center.

    // Update ascent bounds.

        yA = lCvt(efScaleY,sA); // Project onto ascent.
        yB = yA + fxDescent;
        if (yB < rcfxBounds.yBottom)
            rcfxBounds.yBottom = yB;
        yB = yA + fxAscent;
        if (yB > rcfxBounds.yTop)
            rcfxBounds.yTop = yB;

        ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G3: Small Metrics in cache\n");

    // Project the center position onto the baseline and
    // move back to the character origin.

        xA = lCvt(efScaleX,sA) - pgd->fxD / 2;

    // Update the width bounds.  Fudge a quarter pel on each side for
    // roundoff.

        if( bZeroBearing )
        {
            xB = xA - 4;
            if (xB < rcfxBounds.xLeft)
                rcfxBounds.xLeft = xB;
            xB = xA + pgd->fxD + 4;
            if (xB > rcfxBounds.xRight)
                rcfxBounds.xRight = xB;
        }
        else
        {
            xB = xA + pgd->fxA - 4;
            if (xB < rcfxBounds.xLeft)
                rcfxBounds.xLeft = xB;
            xB = xA + pgd->fxAB + 4;
            if (xB > rcfxBounds.xRight)
                rcfxBounds.xRight = xB;
        }

    // Save the adjusted character origin.

        pg->ptl.x
         = xRef + lCvt(pteEsc.x,sA) - pgd->ptqD.x.u.HighPart / 2;

        pg->ptl.y
         = yRef + lCvt(pteEsc.y,sA) - pgd->ptqD.y.u.HighPart / 2;

    // Advance to the next concatenation point.

        if (pdx != (LONG *) NULL)
        {
            xSum += *pdx++;
            sA = lCvt(efWtoDEsc,xSum);

            if (pdxOut != (LONG *) NULL)
                *pdxOut++ = xSum;
        }
        else
        {
            sA += fxD2 + xExtra;

            if (xBreakExtra && (pg->hg == hgBreak))
            {
                sA += xBreakExtra;
            }

        // Record the concatenation point for GetTextExtentEx.  This
        // would be very difficult to reconstruct at a later time.

            if (pdxOut != (LONG *) NULL)
                *pdxOut++ = lCvt(efDtoWEsc,sA);
        }
        pg++;
    }
    ptfxUpdate.x = lCvt(pteEsc.x,sA);
    ptfxUpdate.y = lCvt(pteEsc.y,sA);

    rcfx = rcfxBounds;
    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G2 (rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,pdxOut)
*
* Computes character positions in the case where no pdx array is provided
* and escapement equals orientation.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 23:31:55 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G2
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    LONG     *pdxOut
)
{
// Calculate the lExtra and lBreakExtra spacing.

    HGLYPH   hgBreak     = 0;
    EPOINTQF ptqExtra;      // Accurate spacing along the escapement.
    EPOINTQF ptqBreakExtra;

    if (lExtra)
    {
        xExtra    = lCvt(rfo.efWtoDBase(),lExtra);
        ptqExtra  = rfo.pteUnitBase();
        ptqExtra *= (LONG) xExtra;
    }
    if (lBreakExtra && cBreak)
    {
        xBreakExtra    = lCvt(rfo.efWtoDBase(),lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

        if (rfo.fxBreak() + xBreakExtra + xExtra < 0)
            xBreakExtra = -(rfo.fxBreak() + xExtra);
        ptqBreakExtra  = rfo.pteUnitBase();
        ptqBreakExtra *= (LONG) xBreakExtra;
        hgBreak        = rfo.hgBreak();
    }

// Prepare for a pdxOut.

    EFLOAT efDtoW = rfo.efDtoWBase();

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX      xA,xB;
    FIX      xLeft,xRight;      // Accumulate bounds here.
    UINT     ii;
    EPOINTQF ptq;           // Record the current position here.

    ptq.y = ptq.x = (LONGLONG) LONG_MAX + 1;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs,pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G2: Small Metrics in cache\n");

    BOOL bZeroBearing = ( rfo.flRealizedType() & SO_ZERO_BEARINGS ) && !bLinkedGlyphs();

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        if( bZeroBearing )
        {
            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;
        }
        else
        {
            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;
        }

    // Move to the next position.

        xA  += pgd->fxD;
        ptq += pgd->ptqD;

        if ( (xExtra) && (xExtra + pgd->fxD > 0) )
        {
            xA  += xExtra;
            ptq += ptqExtra;
        }

        if (xBreakExtra && (pg->hg == hgBreak))
        {
            xA  += xBreakExtra;
            ptq += ptqBreakExtra;
        }

    // Handle a pdxOut.

        if (pdxOut != (LONG *) NULL)
            *pdxOut++ = lCvt(efDtoW,xA);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = xRef + (LONG) (ptq.x >> 32);
        pg->ptl.y = yRef + (LONG) (ptq.y >> 32);

    }
    fxExtent     = xA;
    ptfxUpdate.x = (LONG) (ptq.x >> 32);
    ptfxUpdate.y = (LONG) (ptq.y >> 32);

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;
    else if (xA < xLeft)
        xLeft = xA;         // possible if lExtra < 0

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;
    rcfx.yTop    = rfo.fxMaxAscent();
    rcfx.yBottom = rfo.fxMaxDescent();
    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_G1 (rfo,xRef,yRef,pdx,pdxOut)
*
* Computes character positions in the case where a pdx array is provided
* and escapement equals orientation.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G1
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdx,
    LONG     *pdxOut
)
{
    ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G1: Small Metrics in cache\n");

// Our X scale is measured along the escapement direction.  We cache a
// local copy of the unit escapement vector.

    EFLOAT  efScaleX = rfo.efWtoDBase();
    POINTFL pteEsc   = rfo.pteUnitBase();

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX   xA,xB;
    LONG  xSum;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    BOOL bZeroBearing = (rfo.flRealizedType() & SO_ZERO_BEARINGS) && !bLinkedGlyphs();

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        if( bZeroBearing )
        {
            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;
        }
        else
        {
            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;
        }

    // Add the next offset.

        xSum += *pdx++;
        if (pdxOut != (LONG *) NULL)
            *pdxOut++ = xSum;

    // Scale the new offset.

        xA = lCvt(efScaleX,xSum);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = xRef + lCvt(pteEsc.x,xA);
        pg->ptl.y = yRef + lCvt(pteEsc.y,xA);
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = lCvt(pteEsc.x,xA);
    ptfxUpdate.y = lCvt(pteEsc.y,xA);

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;
    rcfx.yTop    = rfo.fxMaxAscent();
    rcfx.yBottom = rfo.fxMaxDescent();
    flTO |= TO_VALID;
}



/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H1 (rfo,xRef,yRef,pdx,efScale)
*
* Computes character positions in the simple horizontal case when a pdx
* array is provided.  We use the ABC spacing info for the TextBox.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H1
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdx,
    EFLOAT    efScale
)
{
// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Compute device driver accelerator flags.

    flAccel |= SO_HORIZONTAL
            | (rfo.flRealizedType() & SO_MAXEXT_EQUAL_BM_SIDE);

// The transform is pretty simple, we're going to handle it ourselves.
// Accelerate on a really simple transform.

    BOOL bUnity = efScale.bIs16();

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// Set up for character loop.

    FIX   xA,xB;
    LONG  xSum;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;     // Distance along the escapement in logical coords.
    xA   = 0;     // Distance along the escapement (x) in device coords.

// Set the first character position:

    yRef = FXTOL(yRef + 8);         // Convert y to LONG coordinate
    xRef += 8;                      // Add in rounding offset for later
                                    //   converting x to LONG coordinate
    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = yRef;

    if((rfo.flRealizedType() & SO_ZERO_BEARINGS) && !bLinkedGlyphs())
    {
        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            if (xA < xLeft)
                xLeft = xA;
            xB = xA + pgd->fxD;
            if (xB > xRight)
                xRight = xB;

        // Add the next offset.

            xSum += *pdx++;

        // Scale the new offset.

            xA = bUnity ? LTOFX(xSum) : lCvt(efScale,xSum);

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.y = yRef;
            pg->ptl.x = FXTOL(xA + xRef);
        }
    }
    else
    {
        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;

        // Add the next offset.

            xSum += *pdx++;

        // Scale the new offset.

            xA = bUnity ? LTOFX(xSum) : lCvt(efScale,xSum);

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.y = yRef;
            pg->ptl.x = FXTOL(xA + xRef);
        }
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = xA;
    ptfxUpdate.y = 0;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H2()
*
* Computes character positions in the simple horizontal case when
* characters have constant integer width.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*  5) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H2
(
    XDCOBJ&   dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef
   ,EFLOAT    efScale
)
{
// In this case we will also assume that the A and C spaces are
// constants.
//
// NOTE: this is actually wrong assumption for tt fixed pitch fonts
// however, we will set ZERO_BEARINGS flag when we want to lie
// about this to the engine. [bodind]

    LONG  dx;

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

    // Set the first character position.  This is the only y position
    // we'll fill in.

        pg->ptl.x = FXTOL(xRef + 8);
        pg->ptl.y = FXTOL(yRef + 8);

    // Compute device driver accelerator flags.

        flAccel |= SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);

    // Set the width accelerator.  When the device driver sees ulCharInc
    // non-zero, it must not expect any more x coordinates.

        ulCharInc = rfo.lCharInc();
        dx = LTOFX(cGlyphs * ulCharInc);
        fxExtent = dx;

        BOOL bAccel;

        if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
            return;

#ifdef FE_SB
    // if there are linked glyphs we can't count on this optimization

        if(bLinkedGlyphs())
        {
            ASSERTGDI((dco.pdc->lTextExtra()|dco.pdc->lBreakExtra()) == 0,
                      "vCharPos_H3 lTextExtra or lBreakExtra non zero\n");

            vCharPos_H3(dco,rfo,xRef,yRef,0,0,dco.pdc->cBreak(),efScale,&bAccel);
            return;
        }
#endif
        if (bAccel)
        {
            flTO |= TO_ALL_PTRS_VALID;
            pgp = pgpos;
        }

        pgd = pg->pgd();

        if (flAccel & SO_ZERO_BEARINGS)
        {
            rcfx.xLeft  = 0;
            rcfx.xRight = dx;
        }
        else
        {
        //
        // Old Comment from bodind might point out possible work item:
        //      these lines of code rely on the const a,c spaces
        //      assumption which is only true for simulated italic
        //      fonts [bodind]

            rcfx.xLeft  = pgd->fxA;
            rcfx.xRight = dx - LTOFX(ulCharInc) + pgd->fxAB;
        }

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

        ptfxUpdate.x = dx;
        ptfxUpdate.y = 0;

        flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::vCharPos_H3 (rfo,xRef,yRef,lExtra,lBreakExtra,cBreak,efScale)
*
* Computes character positions in the simple horizontal case when no pdx
* array is provided and the character widths are not constant.
*
* The following fields of the ESTROBJ are filled in:
*
*  1) Each x,y position.
*  2) Bounding coordinates in rcfx.
*  3) The ptfxUpdate vector.
*  4) The flAccel flags.
*  5) The fxExtent.
*
* History:
*  Sun 22-Mar-1992 18:48:19 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_H3
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG      lExtra,
    LONG      lBreakExtra,
    LONG      cBreak,
    EFLOAT    efScale,
    PBOOL     pbAccel
)
{
// Calculate the lExtra and lBreakExtra spacing.

    HGLYPH hgBreak  = 0;

    if ((lExtra | lBreakExtra) == 0)
    {
    // Will use only character increments given to us with the font

        flAccel |= SO_HORIZONTAL | (rfo.flRealizedType() & SO_ACCEL_FLAGS);
    }
    else
    {
        flAccel |= SO_HORIZONTAL
                | (rfo.flRealizedType() & SO_MAXEXT_EQUAL_BM_SIDE);

        if (lExtra)
        {
            xExtra = lCvt(efScale,lExtra);
            if (xExtra > 0)
                flAccel |= SO_CHARACTER_EXTRA;
        }

        if (lBreakExtra && cBreak)
        {
            xBreakExtra = lCvt(efScale,lBreakExtra) / cBreak;

        // Windows won't let us back up over a break.

            if (rfo.fxBreak() + xBreakExtra + xExtra < 0)
                xBreakExtra = -(rfo.fxBreak() + xExtra);
            hgBreak  = rfo.hgBreak();
            flAccel |= SO_BREAK_EXTRA;
        }
    }

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set up for FIX to LONG conversion.

    xRef += 8;
    yRef = FXTOL(yRef + 8);

// Set the first character position.

    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = yRef;

// Set up for character loop.

    FIX   xA,xB;
    FIX   xLeft,xRight;         // Accumulate bounds here.
    UINT  ii;

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    xA     = 0;     // Distance along the escapement (x) in device coords.

    BOOL bAccel;


//  If pbAccel is NULL it means we have encountered the case where we were
//  going to do a fixed pitch optimization of the base font but encountered
//  linked characters which weren't fixed pitch.  In this case we have
//  already called bGetGlyphMetricsPlus and will signal this by passing
//  in a pointer to bAccel

    if( pbAccel == (BOOL*) NULL )
    {
        if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
            return;
    }
    else
    {
        bAccel = *pbAccel;
    }

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// if there are linked glyphs then SO_ZERO_BEARINGS and SO_CHAR_INC_EQUAL_BM_BASE
// will be turned off in the ESTROBJ::bPartitionInit

    if (((flAccel & (SO_ZERO_BEARINGS | SO_CHAR_INC_EQUAL_BM_BASE))
                 == (SO_ZERO_BEARINGS | SO_CHAR_INC_EQUAL_BM_BASE)) &&
        (xExtra >= 0) &&
        (xBreakExtra == 0))
    {
    // This handles the case when the glyphs won't overlap, thus simplifying

    // the computation of the bounding box.

        ii = cGlyphs;
        while (TRUE)
        {
            pgd = pg->pgd();

        // Move to the next position.

            xA += pgd->fxD + xExtra;

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.x = FXTOL(xA + xRef);
            pg->ptl.y = yRef;
        }

    // Expand the text box out to the concatenation point.  This allows us to
    // continue on with another opaqued string with no visible gap in the
    // opaquing.

        xLeft  = 0;
        xRight = xA;
    }
    else
    {
    // This handles the general case.

        ii = cGlyphs;
        while (TRUE)
        {
        // Update the bounds.

            pgd = pg->pgd();
            xB = xA + pgd->fxA;
            if (xB < xLeft)
                xLeft = xB;
            xB = xA + pgd->fxAB;
            if (xB > xRight)
                xRight = xB;

        // Move to the next position.

            xA += pgd->fxD;

        // don't let xExtra backup past the origin of the previous glyph

            if( ( xExtra ) && (pgd->fxD + xExtra  > 0) )
            {
                xA += xExtra;
            }

            if (pg->hg == hgBreak)
                xA += xBreakExtra;

            if (--ii == 0)
                break;

        // Save the next position.

            pg++;
            pg->ptl.x = FXTOL(xA + xRef);
            pg->ptl.y = yRef;
        }

    // Expand the text box out to the concatenation point.  This allows us to
    // continue on with another opaqued string with no visible gap in the
    // opaquing.

        if (xA > xRight)
            xRight = xA;
    }

    fxExtent     = xA;
    ptfxUpdate.x = xA;
    ptfxUpdate.y = 0;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -rfo.fxMaxDescent();
        rcfx.yBottom = -rfo.fxMaxAscent();
    }
    else
    {
        rcfx.yTop    = rfo.fxMaxAscent();
        rcfx.yBottom = rfo.fxMaxDescent();
    }

    flTO |= TO_VALID;
}

/******************************Public*Routine******************************\
* ESTROBJ::bOpaqueArea (pptfx,prcl)
*
* Computes the opaquing area for the text.
*
* In the complex case, i.e. non-horizontal case, the TextBox is written as
* a parallelogram into pptfx.  A bounding rectangle is computed in prcl.
* TRUE is returned.
*
* In the simple case, the opaque area is also the bounds and is returned
* only in prcl.  FALSE is returned.
*
* History:
*  Fri 13-Mar-1992 19:52:00 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/


BOOL ESTROBJ::bOpaqueArea(POINTFIX *pptfx,RECTL *prcl)
{
// Handle the simplest case.

    if (flAccel & SO_HORIZONTAL)
    {
    // The opaque area is a simple rectangle.  We do the rounding in a
    // particular order so that if the whole string is displaced by a
    // fraction of a pel in any direction, the TextBox will not change size,
    // and will move exactly with the characters.

        LONG x      = FXTOL(ptfxRef.x + 8);
        prcl->left  = x + FXTOL(rcfx.xLeft);
        prcl->right = x + FXTOLCEILING(rcfx.xRight);

        // Making the background rectangle compatible with WFW
        //
        // The problem surfaced with Dbase for Windows where one found
        // that a console window would not be repainted correctly.  The
        // problem was that the Borland coders relied on the fact that WFW
        // vga drivers make the background rectangle for text equal to the
        // rectangle returned in GetTextExtent().  Using this they would
        // erase blank lines by printing lines with a lot of blanks.  Of
        // course this is an extremely bad thing to do but it got the
        // job done, all be it slowly.  Now the interesting part: Under
        // WFW the background rectangle for emboldend (via simulation)
        // text has a horizontal extend equal to one greater than the sum
        // of character widths.  NT is compatible with this.  However,
        // under NT 3.5 Gdi calculated the horizontal extent of the
        // background rectangle equal to the sum of the character widths
        // (at least for simple fonts e.g.  MS Sans Serif) because this
        // was guaranteed to cover all of the bits of the glyphy.  Thus,
        // for the case of emboldened text, NT had BackGround.x =
        // GetTextExtent.x - 1 where WFW had BackGround.x =
        // GetTextExtent.x.  So if the text is simulated bold we bump the
        // horizontal extent of the background rectangle by 1.

        if (
            (prfo->prfnt->fobj.flFontType & FO_SIM_BOLD) &&
            (prfo->prfnt->flInfo & (FM_INFO_TECH_BITMAP | FM_INFO_TECH_STROKE))
        )
        {
            prcl->right++;

            // The line of code that follows this comment is a
            // hack to compensate for a bug in many of the video
            // drivers shipped with 3.5.  This started with the
            // S3 driver which is the prototype of all of the NT
            // video driver shipped from Microsoft.  The S3
            // driver has the following line of code in textout.c:
            //
            // bTextPerfectFit = (pstro->flAccel &
            // (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
            // SO_MAXEXT_EQUAL_BM_SIDE |
            // SO_CHAR_INC_EQUAL_BM_BASE)) == (SO_ZERO_BEARINGS |
            // SO_FLAG_DEFAULT_PLACEMENT |
            // SO_MAXEXT_EQUAL_BM_SIDE |
            // SO_CHAR_INC_EQUAL_BM_BASE);
            //
            // it says that if flAccel sets all of the following
            // bits {SO_ZERO_BEARINGS, SO_FLAG_DEFAULT_PLACEMENT,
            // SO_MAXEXT_EQUAL_BM_SIDE, SO_CHAR_INC_EQUAL_BM_BASE}
            // then the S3 driver will assume that the text
            // passed down from the driver is "perfect".  The S3
            // driver assumes that if a STROBJ is perfect, then
            // it just has to lay down the text.  This conclusion
            // applys to the background rectangle as well.  That
            // is, the S3 driver assume that if this magic set of
            // bits is set, then it can safely ignore the
            // background rectangle safe in the knowlege that it
            // will be taken care of in the process of laying
            // down the glyphs. Unfortunately, this assumption of
            // perfection is not correct now that I have bumped
            // up the background rectangle by one. What is a
            // coder to do? Well I have decided to make the text
            // not so perfect by erasing one of the bits. This
            // will have a couple of result. First it correct the
            // bug as demonstrated by Dbase for Windows. Second
            // it will slow down the case of emboldened text.
            // How important is this? I don't know. We usually
            // base our performance decisions on WinBench tests.
            // If this hack has a noticeable impact then we may
            // have to rethink this strategy.
            //
            // Ref. Bug No. 25102 "T1 DBaseWin X86 Command ..."
            //
            // Wed 07-Dec-1994 08:25:21 by Kirk Olynyk [kirko]

            flAccel &= ~SO_ZERO_BEARINGS;
        }

        LONG y       = FXTOL(ptfxRef.y + 8);

        prcl->top    = y - FXTOLCEILING(rcfx.yTop);
        prcl->bottom = y - FXTOL(rcfx.yBottom);

        return(FALSE);
    }

// An inverting transform or an escapement could get us here.

    EPOINTFL *ppteBase   = &prfo->pteUnitBase();
    EPOINTFL *ppteAscent = &prfo->pteUnitAscent();

    if (ppteBase->y.bIsZero() && ppteAscent->x.bIsZero())
    {
        LONG x = FXTOL(ptfxRef.x + 8);

        if (ppteBase->x.bIsNegative())
        {
            prcl->left  = x - FXTOLCEILING(rcfx.xRight);
            prcl->right = x - FXTOL(rcfx.xLeft);
        }
        else
        {
            prcl->left  = x + FXTOL(rcfx.xLeft);
            prcl->right = x + FXTOLCEILING(rcfx.xRight);
        }

        LONG y = FXTOL(ptfxRef.y + 8);

        if (ppteAscent->y.bIsNegative())
        {
            prcl->top    = y - FXTOLCEILING(rcfx.yTop);
            prcl->bottom = y - FXTOL(rcfx.yBottom);
        }
        else
        {
            prcl->top    = y + FXTOL(rcfx.yBottom);
            prcl->bottom = y + FXTOLCEILING(rcfx.yTop);
        }

    // fudge an extra pixel, do not have a better solution for a space
    // character at the beginning or at the end of string written horizontally
    // It should not be necessary to do any of
    //
    //     prcl->top--;
    //     prcl->bottom++;
    //
    // because space character is positioned at the baseline, so it should not
    // stick out at the top or at the bottom
    //
    // Also it should not be neccessary to do
    //
    //     prcl->left--;
    //
    // because we always ADD a cx = 1 for the space character to the
    // origin of the space character

        prcl->right++;

        return(FALSE);
    }

// A 90 degree rotation could get us here.

    if (ppteBase->x.bIsZero() && ppteAscent->y.bIsZero())
    {
        LONG x    = FXTOL(ptfxRef.x + 8);

        if (ppteAscent->x.bIsNegative())
        {
            prcl->left   = x - FXTOLCEILING(rcfx.yTop);
            prcl->right  = x - FXTOL(rcfx.yBottom);
        }
        else
        {
            prcl->left   = x + FXTOL(rcfx.yBottom);
            prcl->right  = x + FXTOLCEILING(rcfx.yTop);
        }

        LONG y    = FXTOL(ptfxRef.y + 8);

        if (ppteBase->y.bIsNegative())
        {
            prcl->top    = y - FXTOLCEILING(rcfx.xRight);
            prcl->bottom = y - FXTOL(rcfx.xLeft);
        }
        else
        {
            prcl->top    = y + FXTOL(rcfx.xLeft);
            prcl->bottom = y + FXTOLCEILING(rcfx.xRight);
        }

    // fudge an extra pixel, do not have a better solution for a space
    // character at the beginning or at the end of string written vertically.
    // It should not be necessary to do any of
    //
    //     prcl->right++;
    //     prcl->left--;
    //
    // because space character is positioned at the baseline, so it should not
    // stick out left or right.
    //
    // Also it should not be neccessary to do
    //
    //     prcl->top--;
    //
    // because we always ADD a cy = 1 for the space character to the
    // origin of the space character

        prcl->bottom++;

        return(FALSE);
    }

// The opaque area is a parallelogram.  We multiply the orientation and
// ascent unit vectors by the computed bounding widths to get the
// displacements from the reference point.

    POINTFIX ptfxLeft,ptfxRight,ptfxTop,ptfxBottom;

    ptfxLeft.x   = lCvt(ppteBase->x,rcfx.xLeft);
    ptfxLeft.y   = lCvt(ppteBase->y,rcfx.xLeft);
    ptfxRight.x  = lCvt(ppteBase->x,rcfx.xRight);
    ptfxRight.y  = lCvt(ppteBase->y,rcfx.xRight);
    ptfxTop.x    = lCvt(ppteAscent->x,rcfx.yTop);
    ptfxTop.y    = lCvt(ppteAscent->y,rcfx.yTop);
    ptfxBottom.x = lCvt(ppteAscent->x,rcfx.yBottom);
    ptfxBottom.y = lCvt(ppteAscent->y,rcfx.yBottom);

    pptfx[0].x = ptfxRef.x + ptfxLeft.x  + ptfxTop.x;
    pptfx[1].x = ptfxRef.x + ptfxRight.x + ptfxTop.x;
    pptfx[2].x = ptfxRef.x + ptfxRight.x + ptfxBottom.x;
    pptfx[3].x = ptfxRef.x + ptfxLeft.x  + ptfxBottom.x;
    pptfx[0].y = ptfxRef.y + ptfxLeft.y  + ptfxTop.y;
    pptfx[1].y = ptfxRef.y + ptfxRight.y + ptfxTop.y;
    pptfx[2].y = ptfxRef.y + ptfxRight.y + ptfxBottom.y;
    pptfx[3].y = ptfxRef.y + ptfxLeft.y  + ptfxBottom.y;

// Bound the parallelogram.  (Using Black Magic.)

    int ii;

    ii = (pptfx[1].x > pptfx[0].x)
     == (pptfx[1].x > pptfx[2].x);

    prcl->left   = pptfx[ii].x;
    prcl->right  = pptfx[ii+2].x;

    ii = (pptfx[1].y > pptfx[0].y)
     == (pptfx[1].y > pptfx[2].y);

    prcl->top    = pptfx[ii].y;
    prcl->bottom = pptfx[ii+2].y;

    ((ERECTL *) prcl)->vOrder();

    prcl->left   = FXTOL(prcl->left) - 2;          // to be safe, 1 not enough [bodind]
    prcl->top    = FXTOL(prcl->top) - 2;           // to be safe, 1 not enough [bodind]
    prcl->right  = FXTOLCEILING(prcl->right) + 2;  // to be safe, 1 not enough [bodind]
    prcl->bottom = FXTOLCEILING(prcl->bottom) + 2; // to be safe, 1 not enough [bodind]

    #if 0
    vCorrectBackGround();
    #endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* ESTROBJ::bTextExtent (psize)
*
* Simply transforms the TextBox extents back to logical coordinates.
*
* History:
*  Wed 31-Mar-1993 03:15:04 -by- Charles Whitmer [chuckwh]
* Removed the overhang hack since the RFONTOBJ version of this function is
* the Windows compatible one.  Made it return an advance width based
* extent when (escapement==orientation).  Otherwise, the bounding box is
* the only sensible definition.
*
*  Thu 24-Sep-1992 18:36:14 -by- Charles Whitmer [chuckwh]
* Added the compatibility hack.
*
*  Sat 14-Mar-1992 22:08:21 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bTextExtent(RFONTOBJ& rfo,LONG lEsc,PSIZE pSize)
{
    if (flTO & TO_ESC_NOT_ORIENT)
    {
        pSize->cx = lCvt(prfo->efDtoWBase(),rcfx.xRight-rcfx.xLeft);
        pSize->cy = lCvt(prfo->efDtoWAscent(),rcfx.yTop-rcfx.yBottom);
    }
    else
    {
    // Computes a more Windows compatible extent.  This is only possible
    // when (escapement==orientation) and no pdx vector was provided.
    // The field fxExtent is only defined in these cases!  We neglect adding
    // in the overhang, since only GetTextExtentEx, a Win32 function, can
    // get here.

        pSize->cx = lCvt(prfo->efDtoWBase(),fxExtent);
        pSize->cy = lCvt(prfo->efDtoWAscent(),prfo->lMaxHeight() << 4);
    }

#ifdef FE_SB
    if( gbDBCSCodePage &&                   // Only in DBCS system locale
        (rfo.iGraphicsMode() == GM_COMPATIBLE) && // We are in COMPATIBLE mode
        !(rfo.flInfo() & FM_INFO_ARB_XFORMS) && // Driver can't do arbitrary rotations
        !(rfo.flInfo() & FM_INFO_TECH_STROKE) && // Not a vector driver
         (rfo.flInfo() & FM_INFO_90DEGREE_ROTATIONS) && // Driver does 90 deg. rotations
         (lEsc == 900L || lEsc == 2700L) // Current font Escapement is 900 or 2700
      )
    {
        LONG lSwap = pSize->cx;
        pSize->cx  = pSize->cy;
        pSize->cy  = lSwap;
    }
#endif FE_SB

    return(TRUE);
}

/******************************Public*Routine******************************\
* bTextToPath (po)
*
* Draws the outlines of all the glyphs in the string into the given path.
*
* History:
*  Wed 17-Jun-1992 15:43:22 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bTextToPath(EPATHOBJ& po, XDCOBJ& dco, BOOL bNeedUnflattened)
{
    BOOL ReturnValue;

    if (bLinkedGlyphs())
    {
        ReturnValue = bLinkedTextToPath(po, dco, bNeedUnflattened);
    }
    else
    {
        ReturnValue = bTextToPathWorkhorse(po, bNeedUnflattened);
    }
    return(ReturnValue);
}

BOOL ESTROBJ::bTextToPathWorkhorse(EPATHOBJ& po, BOOL bNeedUnflattened)
{
    ULONG     ii, iFound;
    ULONG     cLeft, cGot;
    POINTFIX  ptfxOffset;
    EGLYPHPOS *pg;
    FIX       dx;
    BOOL      bMore;

    cLeft = 0;
    vEnumStart();
    do
    {
        bMore =  STROBJ_bEnum(this, &iFound, (GLYPHPOS**)&pg);
        if (iFound == 0 || pg == 0)
        {
            break;
        }
        if (ulCharInc)
        {
            ASSERTGDI(flAccel & SO_HORIZONTAL, "bTextToPath,text not horizontal\n");

            ptfxOffset.x = pg->ptl.x;
            ptfxOffset.y = pg->ptl.y;

            if (!(flTO & TO_HIGHRESTEXT))
            {
                ptfxOffset.x <<=4;
                ptfxOffset.y <<=4;
            }

            dx = (FIX)(ulCharInc << 4);
            ptfxOffset.x -= dx;
        }
        else
        {
            dx = 0;
        }

        for (cGot = cLeft = iFound; cLeft; cLeft -= cGot)
        {
            //
            // If the paths in the cache have been flattened we will need to
            // call directly to the driver to get unflatttened paths [gerritv].
            //

            if ( bNeedUnflattened )
            {
                if (!prfo->bInsertPathLookaside(pg,FALSE))
                {
                    break;
                }
                cGot = 1;
            }
            else if (!(flTO & TO_ALL_PTRS_VALID))
            {
                if ((cGot = prfo->cGetGlyphData(cLeft,pg)) == 0)
                {
                    break;
                }
            }

            for (ii = 0; ii < cGot; ii++, pg++)
            {
                if (dx)
                {
                    ptfxOffset.x += dx;
                }
                else
                {
                    ptfxOffset.x = pg->ptl.x;
                    ptfxOffset.y = pg->ptl.y;

                    if (!(flTO & TO_HIGHRESTEXT))
                    {
                        ptfxOffset.x <<=4;
                        ptfxOffset.y <<=4;
                    }
                }
                if (!po.bAppend((EPATHOBJ *) pg->pgdf->ppo, &ptfxOffset))
                {
                    if (bNeedUnflattened)
                       pg->pgdf = NULL;
                        
                    break;
                }

                if (bNeedUnflattened)
                    pg->pgdf = NULL;
            }

            if (ii < cGot)
            {
                break;
            }
        }
        if (cLeft)
        {
            break;
        }
    } while (bMore);

    if (bNeedUnflattened)
    {
       flTO = (flTO & ~TO_ALL_PTRS_VALID);
    }   
       
    return(cLeft == 0);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ESTROBJ::bLinkedTextToPath
*
* Routine Description:
*
*   Renders a text in the form of a path for the case where font linking
*   is in place.
*
* Arguments:
*
*   po - a referece to an EPATHOBJ. This will receive the text path.
*
*   bNeedUnflattened - a variable that indicates that whether the path
*       should be unflattened. If it needs to be unflattened we must
*       go back to the font driver to get the glyph path in its original
*       form before being flattend.
*
* Called by:
*
*   ESTROBJ::bTextToPath
*
* Return Value:
*
\**************************************************************************/

BOOL ESTROBJ::bLinkedTextToPath(EPATHOBJ& po, XDCOBJ& dco, BOOL bNeedUnflattened)
{
    RFONTOBJ *prfoSave;
    WCHAR *pwszSave, *pwcTmp, *pwcSource;
    LONG  *plPart, *plPartLast, lFontLast, lFont, lInflatedMax = 0;
    ULONG count;

    prfoSave   = prfo;
    pgp        = 0;                              // forces enumeration
    flAccel    = 0;
    ulCharInc  = 0;
    pwszSave   = pwszOrg;
    plPartLast = plPartition + cGlyphs;         // useful

    lFontLast = EUDCTYPE_FACENAME + (LONG) prfo->uiNumFaceNameLinks();

    for (lFont = EUDCTYPE_BASEFONT; lFont < lFontLast ; lFont++)
    {
        RFONTTMPOBJ rfoLink;
        RFONTOBJ   *prfoLink;

        // (re)initialize prfo, because it could be pointing to an old 
        // or invalid rfoLink from a previous iteration.
        prfo = prfoSave;

        if (lFont == EUDCTYPE_BASEFONT)
        {
            prfoLink = prfo;
        }
        else
        {
            RFONT *prfnt;

            switch (lFont)
            {
            case EUDCTYPE_SYSTEM_TT_FONT:

                if(cTTSysGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntSystemTT();
                break;

            case EUDCTYPE_SYSTEM_WIDE:

                if(cSysGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntSysEUDC();
                break;

            case EUDCTYPE_DEFAULT:

                if(cDefGlyphs == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntDefEUDC();
                break;

            default:

                if(cFaceNameGlyphsGet(lFont - EUDCTYPE_FACENAME) == 0)
                {
                    continue;
                }
                prfnt = prfo->prfntFaceName(lFont - EUDCTYPE_FACENAME);
                break;
            }

            if (prfnt == 0)
            {
                RIP("prfnt == 0\n");
                return(FALSE);
            }

            rfoLink.vInit(prfnt);
            prfoLink = (RFONTOBJ*) &rfoLink;

        }

        plPart    = plPartition;
        pwcTmp    = pwcPartition;
        pwcSource = pwszSave;
        count     = 0;
        for ( ; plPart < plPartLast; plPart++, pwcSource++)
        {
            if (*plPart == lFont)
            {
                *pwcTmp++ = *pwcSource;
                count++;
            }
        }

        if (count)
        {
            cGlyphs = count;
            pwszOrg = pwcPartition;
            prfo    = prfoLink;
            vFontSet(lFont);

            if (lFont != EUDCTYPE_BASEFONT)
            {
                POINTL ptlAdjustBaseLine;
                if (bAdjusBaseLine(*prfo, rfoLink, &ptlAdjustBaseLine))
                {
                    ptlBaseLineAdjustSet(ptlAdjustBaseLine);
                }
            }

            if (!bTextToPathWorkhorse(po))
            {
                pwszOrg = pwszSave;
                prfo    = prfoSave;
                return(FALSE);
            }
        }
    }
    pwszOrg = pwszSave;
    prfo    = prfoSave;

    return(TRUE);
}

/******************************Public*Routine******************************\
* bAddPgmToPath (po,x,y,dx1,dy1,dx2,dy2)
*
* Performs the often repeated adding of a parallelogram to a path.
*
*  Tue 07-Apr-1992 00:17:57 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL bAddPgmToPath(EPATHOBJ& po,FIX x,FIX y,FIX dx1,FIX dy1,FIX dx2,FIX dy2)
{
    POINTFIX aptfx[4];

    aptfx[0].x = x;
    aptfx[0].y = y;
    aptfx[1].x = x + dx1;
    aptfx[1].y = y + dy1;
    aptfx[2].x = x + dx1 + dx2;
    aptfx[2].y = y + dy1 + dy2;
    aptfx[3].x = x + dx2;
    aptfx[3].y = y + dy2;
    return(po.bAddPolygon(XFORMNULL,(POINTL *) aptfx,4));
}

/******************************Public*Routine******************************\
* bExtraRectsToPath (po)
*
* Draws all the underlines and strikeouts into a path, suitable for
* filling.
*
* History:
*  Tue 07-Apr-1992 00:44:00 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bExtraRectsToPath(EPATHOBJ& po, BOOL bNeedUnflattend)
{
    FIX x;
    FIX y;

// Get local copies of the offsets and thicknesses.

    POINTFIX ptfxUL;
    POINTFIX ptfxULThick;

    ptfxUL.x      = LTOFX(prfo->ptlUnderline1().x);
    ptfxUL.y      = LTOFX(prfo->ptlUnderline1().y);
    ptfxULThick.x = LTOFX(prfo->ptlULThickness().x);
    ptfxULThick.y = LTOFX(prfo->ptlULThickness().y);

    POINTFIX ptfxSO;
    POINTFIX ptfxSOThick;

    ptfxSO.x      = LTOFX(prfo->ptlStrikeOut().x);
    ptfxSO.y      = LTOFX(prfo->ptlStrikeOut().y);
    ptfxSOThick.x = LTOFX(prfo->ptlSOThickness().x);
    ptfxSOThick.y = LTOFX(prfo->ptlSOThickness().y);

// Underlines and strikeouts are continuous and parallel the escapement
// vector, if escapement equals orientation.

    if (!(flTO & TO_ESC_NOT_ORIENT))
    {
        // Round off the starting point.

        x = (ptfxRef.x + 8) & -16;
        y = (ptfxRef.y + 8) & -16;

        if (flTO & TSIM_UNDERLINE1)
        {
            if (!bAddPgmToPath
             (
              po,
              x + ptfxUL.x,
              y + ptfxUL.y,
              ptfxEscapement.x,
              ptfxEscapement.y,
              ptfxULThick.x,
              ptfxULThick.y
             )
               )
            return(FALSE);
        }

        if (flTO & TSIM_STRIKEOUT)
        {
            if (!bAddPgmToPath
             (
              po,
              x + ptfxSO.x,
              y + ptfxSO.y,
              ptfxEscapement.x,
              ptfxEscapement.y,
              ptfxSOThick.x,
              ptfxSOThick.y
             )
               )
            return(FALSE);
        }
        return(TRUE);
    }

// Otherwise underlines and strikeouts apply to each character.

    UINT  ii;
    ULONG cLeft;
    ULONG cGot;

    EGLYPHPOS *pg = pgpos;
    WCHAR *pwsz = pwszOrg;

    for (cGot=cLeft=cGlyphs; cLeft; cLeft-=cGot)
    {
        if (bNeedUnflattend)
        {
            if ((cGot = prfo->cGetGlyphDataLookaside(cLeft, pg)) == 0)
                return (FALSE);
        }
        else if (!(flTO & TO_ALL_PTRS_VALID))
        {
            if ((cGot = prfo->cGetGlyphData(cLeft,pg)) == 0)
                return(FALSE);
        }

        pwsz += cGot;

        EPOINTFL *ppteBase   = &prfo->pteUnitBase();
        POINTFIX ptfxA;
        POINTFIX ptfxB;

        for (ii=0; ii<cGot; ii++,pg++)
        {
            x = pg->ptl.x;
            y = pg->ptl.y;

            // If pg->ptl contains LONG's, we must convert them to FIX's.

            if (!(flTO & TO_HIGHRESTEXT))
            {
                x <<=4;
                y <<=4;
            }

            ptfxA.x = lCvt(ppteBase->x,pg->pgd()->fxA);
            ptfxA.y = lCvt(ppteBase->y,pg->pgd()->fxA);
            ptfxB.x = lCvt(ppteBase->x,(pg->pgd()->fxAB - pg->pgd()->fxA));
            ptfxB.y = lCvt(ppteBase->y,(pg->pgd()->fxAB - pg->pgd()->fxA));

            if (flTO & TSIM_UNDERLINE1)
            {
                if (!bAddPgmToPath
                 (
                  po,
                  x + ptfxUL.x + ptfxA.x,
                  y + ptfxUL.y + ptfxA.y,
                  ptfxB.x,
                  ptfxB.y,
                  ptfxULThick.x,
                  ptfxULThick.y
                 )
               )
                return(FALSE);
            }

            if (flTO & TSIM_STRIKEOUT)
            {
                if (!bAddPgmToPath
                 (
                  po,
                  x + ptfxSO.x + ptfxA.x,
                  y + ptfxSO.y + ptfxA.y,
                  ptfxB.x,
                  ptfxB.y,
                  ptfxSOThick.x,
                  ptfxSOThick.y
                 )
               )
                return(FALSE);
            }
        }
    }
    return(TRUE);
}





/******************************Public*Routine******************************\
* VOID STROBJ_vEnumStart (pstro)
*
* Initialize the string enumerator.
*
* History
*  Tue 17-Mar-1992 10:33:09 -by- Charles Whitmer [chuckwh]
* Simplified it.
*
*  Fri 25-Jan-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" VOID STROBJ_vEnumStart(STROBJ *pso)
{
    ((ESTROBJ *)pso)->vEnumStart();
}

/******************************Public*Routine******************************\
* BOOL STROBJ_bEnum
*
* The glyph enumerator.
*
* History:
*  Tue 17-Mar-1992 10:35:05 -by- Charles Whitmer [chuckwh]
* Simplified it and gave it the quick exit.  Also let drivers call here
* direct.
*
*  02-Oct-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STROBJ_bEnumLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos);

extern "C" BOOL STROBJ_bEnum(STROBJ *pso, ULONG *pc, PGLYPHPOS *ppgpos)
{

    // Quick exit.

#ifdef FE_SB
    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return(STROBJ_bEnumLinked( (ESTROBJ*) pso, pc, ppgpos ));
    }
#endif

    if (((ESTROBJ*)pso)->flTO & TO_ALL_PTRS_VALID)
    {
        *pc = ((ESTROBJ*)pso)->cGlyphs;
        *ppgpos = ((ESTROBJ*)pso)->pgpos;
        return(FALSE);
    }

// compute the number of wc's in the string for which the GLYPHPOS strucs
// have not yet been written to the driver's buffer

    ULONG cgposYetToCopy = ((ESTROBJ*)pso)->cGlyphs - ((ESTROBJ*)pso)->cgposCopied;

    if (cgposYetToCopy == 0)
    {
        *pc = 0;
        return(FALSE);
    }

    GLYPHPOS *pgp = ((ESTROBJ*)pso)->pgpos + ((ESTROBJ*)pso)->cgposCopied;
    ULONG cgposActual; // # of chars enumerated during this call to strobj

    if ( ((ESTROBJ*)pso)->prfo == NULL)  // check for journaling
    {
        WARNING("ESTROBJ::bEnum(), bitmap font, prfo == NULL\n");
        *pc = 0;
        return(FALSE);
    }

    cgposActual =((ESTROBJ*)pso)->prfo->cGetGlyphData(cgposYetToCopy,pgp);

    if (cgposActual == 0)
    {
        *pc = 0;
        return(FALSE);
    }

// The first glyph in a batch should always have the position info.

    if (((ESTROBJ*)pso)->cgposCopied && ((ESTROBJ*)pso)->ulCharInc)
    {
        if (((ESTROBJ*)pso)->flTO & TO_HIGHRESTEXT)
        {
            pgp->ptl.x = ((ESTROBJ*)pso)->pgpos->ptl.x +
                ((((ESTROBJ*)pso)->cgposCopied * ((ESTROBJ*)pso)->ulCharInc) << 4);
        }
        else
        {
            pgp->ptl.x = ((ESTROBJ*)pso)->pgpos->ptl.x +
                ((ESTROBJ*)pso)->cgposCopied * ((ESTROBJ*)pso)->ulCharInc;
        }
        pgp->ptl.y = ((ESTROBJ*)pso)->pgpos->ptl.y;
    }

    ((ESTROBJ*)pso)->cgposCopied += cgposActual;     // update enumeration state

    *pc = cgposActual;
    *ppgpos = pgp;

    return(((ESTROBJ*)pso)->cgposCopied < ((ESTROBJ*)pso)->cGlyphs);  // TRUE => more to come.
}

/******************************Public*Routine******************************\
* vGenWidths
*
* Computes the advance widths for escapement not equal to orientation.
* The theory is pretty simple.  We construct an 'egg' whose upper and
* lower outlines are half ellipses with sizes determined by the top and
* bottom of the ink box.  The escapement vector always goes through the
* center of the character baseline.  We call that point (halfway between
* the normal concatenation points of the glyph) the 'center'.  We advance
* the current position from where the escapement vector first pierces the
* egg to the center, and then from the center to where the vector exits
* the egg.  These are the D1 and D2 returned widths from this routine.
*
*  Mon 07-Jun-1993 12:27:22 -by- Charles Whitmer [chuckwh]
* Wrote it long ago.  My apologies for the undocumented math.
\**************************************************************************/

VOID vGenWidths
(
    FIX    *pfxD1,      // First part of advance width. (Returned.)
    FIX    *pfxD2,      // Second part of advance width. (Returned.)
    EFLOAT& efRA,       // Projection ratio of escapement onto Ascent.
    EFLOAT& efRB,       // Projection ratio of escapement onto Baseline.
    FIX     fxWidth,    // Normal width.
    FIX     fxTop,      // Top of ink box.
    FIX     fxBottom,   // Bottom of ink box.
    FIX     fxMaxAscent
)
{
    EFLOAT efA,efB,efOne;
    FIX    fxTemp;

// Worry about the width being zero.  This can occur in a Unicode font.
// Never advance in this case, since the character is some kind of
// overpainting glyph.

    if (fxWidth == 0)
    {
        *pfxD2 = 0;
        *pfxD1 = 0;
        return;
    }

// For escapement along the baseline, we return the normal width, separated
// into two parts.

    if (efRA.bIsZero())
    {
        *pfxD1 = fxWidth / 2;
        *pfxD2 = fxWidth - *pfxD1;
        return;
    }

    if (fxBottom == fxTop)      // Probably a break character.
    {
        fxBottom = -(fxMaxAscent / 4);
        fxTop    = fxMaxAscent/2 + fxBottom;
    }
    if (fxBottom >= 0)
        fxBottom = 0;
    if (fxTop <= 0)
        fxTop = 0;
    if (efRA.bIsNegative())
    {
        fxTemp   = fxBottom;
        fxBottom = -fxTop;
        fxTop    = -fxTemp;
    }

// Provide a little extra spacing in addition to the ink box.

    fxTop    += fxMaxAscent / 16;
    if ( fxTop == 0 )
    {
        WARNING1("vGenWidths: fxTop == 0 .. setting to +1\n");
        fxTop = 1;
    }
    fxBottom -= fxMaxAscent / 16;
    if ( fxBottom == 0 )
    {
        WARNING1("vGenWidths: fxBottom == 0 .. setting to -1\n");
        fxBottom = -1;
    }

// For escapement in the ascent direction, we return a width that will
// traverse the ink box.  Note that the general code below would give the
// same result, only take longer!

    if (efRB.bIsZero())
    {
        *pfxD2 = fxTop;
        *pfxD1 = -fxBottom;
        return;
    }

// Compute the displacements.

    ASSERTGDI(fxWidth, "fxWidth == 0\n");
    efB = fxWidth;          // Converts to EFLOAT.
    efB.vDivBy2();
    efB.eqDiv(efRB,efB);
    efB.eqMul(efB,efB);

    efA = fxBottom;
    efA.eqDiv(efRA,efA);
    efA.eqMul(efA,efA);
    efA.eqAdd(efA,efB);
    efA.eqSqrt(efA);
    efOne.vSetToOne();
    efA.eqDiv(efOne,efA);
    efA.bEfToL(*pfxD1);

    efA = fxTop;
    efA.eqDiv(efRA,efA);
    efA.eqMul(efA,efA);
    efA.eqAdd(efA,efB);
    efA.eqSqrt(efA);
    efA.eqDiv(efOne,efA);
    efA.bEfToL(*pfxD2);
    return;
}



/******************************Public*Routine******************************\
*
* VOID ESTROBJ::vCharPos_H4, pdxdy case for zero esc and orientation
*
* History:
*  18-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID ESTROBJ::vCharPos_H4
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdxdy,
    EFLOAT    efXScale,
    EFLOAT    efYScale
)
{
// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;
    POINTL *pDxDy = (POINTL *)pdxdy;

// The transform is pretty simple, we're going to handle it ourselves.
// Accelerate on a really simple transforms.

    BOOL bUnityX = efXScale.bIs16();
    BOOL bUnityY = efYScale.bIs16();

    BOOL bAccel;


    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel,&dco,this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

// Set up for character loop.

    FIX   xA,xB;
    FIX   yT,yB;
    LONG  xSum, ySum;
    FIX   xLeft,xRight, yTop, yBottom;  // Accumulate bounds here.
    UINT  ii;
    FIX fxAscent, fxDescent;

    if (dco.pdc->bYisUp())
    {
        fxAscent  = -rfo.fxMaxDescent();
        fxDescent = -rfo.fxMaxAscent();
    }
    else
    {
        fxAscent  = rfo.fxMaxAscent();
        fxDescent = rfo.fxMaxDescent();
    }

    xLeft  = 0;             // Start with an empty TextBox.
    xRight = 0;
    yTop   = 0;
    yBottom = 0;

// To avoid roundoff errors, we accumulate the DX widths in logical
// coordinates and transform the sums.

    xSum = 0;     // Distance along the escapement in logical coords.
    ySum = 0;     // Distance along the ascender in logical coords.
    xA   = 0;     // Distance along the escapement (x) in device coords.
    yT   = 0;     // Distance along the ascender (y) in device coords

// Set the first character position:

    yRef += 8;  // Add in rounding offset for later
    xRef += 8;  // converting x and y to LONG coordinates

    pg->ptl.x = FXTOL(xRef);
    pg->ptl.y = FXTOL(yRef);

    ii = cGlyphs;
    while (TRUE)
    {
    // Update the bounds.

        pgd = pg->pgd();
        xB = xA + pgd->fxA;
        if (xB < xLeft)
            xLeft = xB;
        xB = xA + pgd->fxAB;
        if (xB > xRight)
            xRight = xB;

    // make top and bottom independent of glyphs, ie replace glyph in the
    // string by another one, want to get the same top and bottom, possibly
    // different left and right.
    // (this is similar to how all other H? cases work)

        yB = yT + fxAscent;
        if (yB > yTop)
            yTop = yB;
        yB = yT + fxDescent;
        if (yB < yBottom)
            yBottom = yB;

    // Add the next offset.

        xSum += pDxDy->x;
        ySum += pDxDy->y;
        pDxDy++;

    // Scale the new offset.

        xA = bUnityX ? LTOFX(xSum) : lCvt(efXScale,xSum);
        yT = bUnityY ? LTOFX(ySum) : lCvt(efYScale,ySum);

        if (--ii == 0)
            break;

    // Save the next position.

        pg++;
        pg->ptl.x = FXTOL(xA + xRef);
        pg->ptl.y = FXTOL(-yT + yRef); // y goes down, not opposite from ascender
    }

// Expand the text box out to the concatenation point.  This allows us to
// continue on with another opaqued string with no visible gap in the
// opaquing.

    if (xA > xRight)
        xRight = xA;

    ptfxUpdate.x = xA;
    ptfxUpdate.y = -yT;

    rcfx.xLeft   = xLeft;
    rcfx.xRight  = xRight;

    if (dco.pdc->bYisUp())
    {
        rcfx.yTop    = -yBottom;
        rcfx.yBottom = -yTop;
    }
    else
    {
        rcfx.yTop    = yTop;
        rcfx.yBottom = yBottom;
    }


    flTO |= TO_VALID;
}


/******************************Public*Routine******************************\
*
* VOID ESTROBJ::vCharPos_G4
*
* handles pdy case with esc != orientation
*
* History:
*  17-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::vCharPos_G4
(
    XDCOBJ&  dco,
    RFONTOBJ& rfo,
    FIX       xRef,
    FIX       yRef,
    LONG     *pdxdy
)
{
// In this case, we keep track of how far we have traveled along the
// escapement vector in device coordinates.  We need scales to project
// this distance onto the base and ascent, as well as a unit escapement
// vector to find the position.

    POINTFL pteEsc  = rfo.pteUnitEsc();     // Unit escapement vector.
    POINTFL pteAsc  = rfo.pteUnitAscent();  // Unit ascender vector.
    EFLOAT efScaleX = rfo.efEscToBase();    // Project escapement to baseline.
    EFLOAT efScaleY = rfo.efEscToAscent();  // Project escapement to ascent.

// Compute logical to device transforms.

    EFLOAT efWtoDEsc = rfo.efWtoDEsc();    // Forward transform for pdx.
    EFLOAT efWtoDAsc = rfo.efWtoDAscent(); // Forward transform for pdy
    BOOL   bUnityEsc = efWtoDEsc.bIs16();
    BOOL   bUnityAsc = efWtoDAsc.bIs16();

// Compute extra spacing for the non-pdx case.

    FIX    fxD1,fxD2;       // Pre- and Post-center character widths.
    FIX    fxAscent  = rfo.fxMaxAscent();  // Cache locally.
    FIX    fxDescent = rfo.fxMaxDescent(); // Cache locally.

    ASSERTGDI(pdxdy, "G4 text out case: pdxdy is null\n");
    ASSERTGDI(cGlyphs > 0, "G4, cGlyphs == 0\n");

// Make some local pointers.

    EGLYPHPOS *pg = pgpos;
    GLYPHDATA *pgd;
    WCHAR *pwsz = pwszOrg;

// Set the first character position.

    pg->ptl.x = xRef;
    pg->ptl.y = yRef;

// Set up for character loop.

    LONG   xSum;        // Keep pdx sum here.
    LONG   ySum;        // Keep pdy sum here.
    FIX    xA,xB;       // Baseline coordinates.
    FIX    yA,yB;       // Ascent coordinates.
    FIX    sA;          // Position on the escapement vector.
    FIX    sT;          // Position on the ascender vector.

    RECTFX rcfxBounds;  // Accumulate bounds here.
    UINT   ii;
    POINTL *pDxDy = (POINTL *)pdxdy;

    rcfxBounds.xLeft   = LONG_MAX; // Start with an empty TextBox.
    rcfxBounds.xRight  = LONG_MIN;
    rcfxBounds.yTop    = LONG_MIN;
    rcfxBounds.yBottom = LONG_MAX;

// We keep the current concatenation point in sA.  Note that this is NOT
// where the character origin will be placed.

    sA   = sT   = 0;
    xSum = ySum = 0;

    BOOL bAccel;

    if (!rfo.bGetGlyphMetricsPlus(cGlyphs, pg, pwsz, &bAccel, &dco, this))
        return;

    if (bAccel)
    {
        flTO |= TO_ALL_PTRS_VALID;
        pgp = pgpos;
    }

    for (ii=0; ii<cGlyphs; ii++, pg++, pDxDy++)
    {
        pgd = pg->pgd();

    // Using the GenWidths function, determine where the
    // character center should be placed.

        vGenWidths
        (
            &fxD1,              // Pre-center spacing
            &fxD2,              // Post-center spacing
            efScaleY,           // Ascent projection
            efScaleX,           // Baseline projection
            pgd->fxD,           // Character width
            pgd->fxInkTop,      // Ink box top
            pgd->fxInkBottom,   // Ink box bottom
            fxAscent            // Maximum Ascent
        );

        sA += fxD1;         // Advance to the character center.

    // Update ascent bounds.

        yA = lCvt(efScaleY,sA) + sT; // Project onto ascent.
        yB = yA + fxDescent;
        if (yB < rcfxBounds.yBottom)
            rcfxBounds.yBottom = yB;
        yB = yA + fxAscent;
        if (yB > rcfxBounds.yTop)
            rcfxBounds.yTop = yB;

        ASSERTGDI(!rfo.bSmallMetrics(),"ESTROBJ__vCharPos_G3: Small Metrics in cache\n");

    // Project the center position onto the baseline and
    // move back to the character origin.

        xA = lCvt(efScaleX,sA) - pgd->fxD / 2;

    // Update the width bounds.  Fudge a quarter pel on each side for
    // roundoff.

        xB = xA + pgd->fxA - 4;
        if (xB < rcfxBounds.xLeft)
            rcfxBounds.xLeft = xB;
        xB = xA + pgd->fxAB + 4;
        if (xB > rcfxBounds.xRight)
            rcfxBounds.xRight = xB;

    // Save the adjusted character origin.

        pg->ptl.x
         = xRef + lCvt(pteEsc.x,sA) + lCvt(pteAsc.x,sT) - pgd->ptqD.x.u.HighPart / 2;

        pg->ptl.y
         = yRef + lCvt(pteEsc.y,sA) + lCvt(pteAsc.y,sT) - pgd->ptqD.y.u.HighPart / 2;

    // Advance to the next concatenation point.

        xSum += pDxDy->x;
        ySum += pDxDy->y;

        sA = bUnityEsc ? LTOFX(xSum) : lCvt(efWtoDEsc,xSum);
        sT = bUnityAsc ? LTOFX(ySum) : lCvt(efWtoDAsc,ySum);
    }


// ptfxUpdate, continue where the last glyph is written:

    ptfxUpdate.x = lCvt(pteEsc.x,sA) + lCvt(pteAsc.x,sT);
    ptfxUpdate.y = lCvt(pteEsc.y,sA) + lCvt(pteAsc.y,sT);

    rcfx = rcfxBounds;
    flTO |= TO_VALID;
}


/******************************Public*Routine******************************\
* STROBJ_bGetAdvanceWidthsLinked(
*
* returns the widths for the batch of glyphs from the current font
*
* Warnings: assumes that the glyph has been partitioned properly
*
* History:
*  27-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL STROBJ_bGetAdvanceWidthsLinked(
    ESTROBJ * peso,
    ULONG     iFirst,
    ULONG     cBatch,
    POINTQF  *pptqD
)
{
// Quick exit.

    BOOL bRet = FALSE;
    ULONG iG, iLast;

    iG = 0;
    iLast = iFirst +  cBatch;


    if (iLast <= peso->cGlyphs)
    {
        bRet = TRUE;

        for(iG = 0, peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            iG < iLast;
            (peso->pgpNext)++, (peso->plNext)++)
        {

            if (*(peso->plNext) == peso->lCurrentFont)
            {
                if (iG >= iFirst)
                {
                    EGLYPHPOS *pg = (EGLYPHPOS *)peso->pgpNext;

                    if (peso->prfo->bSmallMetrics())
                    {
                        pptqD->x.u.HighPart = pg->pgd()->fxD;
                        pptqD->x.u.LowPart = 0;
                        pptqD->y.u.HighPart = 0;
                        pptqD->y.u.LowPart = 0;
                    }
                    else
                    {
                        *pptqD = pg->pgd()->ptqD;
                    }

                // get to the next adv. width

                    pptqD++;
                }

            // increment iG, count of glyphs from this font

                iG++;
            }
        }
    }
    return bRet;
}



/******************************Public*Routine******************************\
*
*
* Effects: accelerator for the printer drivers, they need to know how to
*          update current position, so they need advance vectors of glyphs
*          in this string.
*
* Warnings: I think this will not work for linked fonts
*           On the other hand printer driver never get called with STROBJ
*           for linked string, so this should be ok.
*
* History:
*  09-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" BOOL APIENTRY STROBJ_bGetAdvanceWidths(
    STROBJ   *pso, ULONG iFirst, ULONG cBatch,POINTQF  *pptqD
    )
{
// We know that all the widths are in the cache, computed already
// just need to copy them down

    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return STROBJ_bGetAdvanceWidthsLinked((ESTROBJ*)pso,iFirst,cBatch,pptqD);
    }

    BOOL bRet = FALSE;

    if ((iFirst +  cBatch) <= ((ESTROBJ*)pso)->cGlyphs)
    {
        EGLYPHPOS *pg    = &((ESTROBJ*)pso)->pgpos[iFirst];
        EGLYPHPOS *pgEnd = pg  + cBatch;
        bRet = TRUE;

        if (((ESTROBJ*)pso)->prfo->bSmallMetrics())
        {
            for ( ; pg < pgEnd; pg++, pptqD++)
            {
                pptqD->x.u.HighPart = pg->pgd()->fxD;
                pptqD->x.u.LowPart = 0;
                pptqD->y.u.HighPart = 0;
                pptqD->y.u.LowPart = 0;
            }
        }
        else
        {
            for ( ; pg < pgEnd; pg++)
            {
                *pptqD++ = pg->pgd()->ptqD;
            }
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
*
* BOOL STROBJ_bEnumPositionsOnlyLinked
*
* Enumerates positions only in paralel with STROBJ_bEnumLinked in misceudc.cxx
*
* History:
*  20-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL STROBJ_bEnumPositionsOnlyLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos)
{
// Quick exit.

    if( peso->cgposPositionsEnumerated == 0 )
    {
        for( peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            *(peso->plNext) != peso->lCurrentFont;
            (peso->pgpNext)++, (peso->plNext)++ );
        {
        }
    }
    else
    {
       if (peso->cgposPositionsEnumerated == peso->cGlyphs)
       {
        // no more glyphs so just return
            *pc = 0;
            return(FALSE);
       }
       else
       {
        // find next glyph

            for( (peso->plNext)++, (peso->pgpNext)++;
                 *(peso->plNext) != (peso->lCurrentFont);
                 (peso->pgpNext)++, (peso->plNext)++ );
            {
            }
       }
    }

    peso->cgposPositionsEnumerated += 1;     // update enumeration state
    *pc = 1;
    *ppgpos = peso->pgpNext;

    return(peso->cgposPositionsEnumerated < peso->cGlyphs);  // TRUE => more to come.
}


BOOL APIENTRY STROBJ_bEnumPositionsOnly(
    STROBJ    *pso,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
// Quick exit.

    if(((ESTROBJ*)pso)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
    {
        return STROBJ_bEnumPositionsOnlyLinked((ESTROBJ*)pso, pc, ppgpos);
    }

// if not linked all positions are guaranteed to be in the cache:

    *pc = ((ESTROBJ*)pso)->cGlyphs;
    *ppgpos = ((ESTROBJ*)pso)->pgpos;
    return(FALSE); // no more
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\textxl.c ===
/******************************Module*Header*******************************\
* Module Name: textxl.c
*
*   Draw glyphs to 1Bpp temporary buffer. This is the portable version
*   of the x86 code from the VGA driver.
*
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"

#if !defined (_X86_)


typedef VOID (*PFN_GLYPHLOOP)(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
typedef VOID (*PFN_GLYPHLOOPN)(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);

PFN_GLYPHLOOP   pfnGlyphLoop;

//
// debug routine
//

VOID
exit_fast_text(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    return;
}

//
// or_all_1_wide_rotated_need_last::
// or_all_1_wide_rotated_no_last::
// or_first_1_wide_rotated_need_last
// or_first_1_wide_rotated_no_last::
//

VOID
or_all_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    UCHAR  c;

    do {
        c = *pGlyph++;
        *pBuffer |= c >> RightRot;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}

//
// mov_first_1_wide_rotated_need_last::
// mov_first_1_wide_rotated_no_last::
//

VOID
mov_first_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    UCHAR  c;

    do {
        c = *pGlyph++;
        *pBuffer = c >> RightRot;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_1_wide_unrotated::
//

VOID
mov_first_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    do {
        *pBuffer = *pGlyph++;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}


//
//or_all_1_wide_unrotated::
//or_all_1_wide_unrotated_loop::
//

VOID
or_all_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    do {
        *pBuffer |= *pGlyph++;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_2_wide_rotated_need_last::
//

VOID
or_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        pGlyph+=2;
        *pBuffer |= c0 >> RightRot;
        *(pBuffer+1) = (c1 >> RightRot) | (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
//or_all_2_wide_rotated_need_last::
//

VOID
or_all_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  rl    = 8-RightRot;
    USHORT usTmp;
    UCHAR  c0,c1;



    do {
        usTmp = *(PUSHORT)pGlyph;
        pGlyph += 2;
        c0 = (UCHAR)usTmp;
        c1 = (UCHAR)(usTmp >> 8);
        *pBuffer |= (UCHAR)(c0 >> RightRot);
        *(pBuffer+1) |= (UCHAR)((c1 >> RightRot) | (c0 << rl));
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_2_wide_rotated_need_last::
//

VOID
mov_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG rl = 8-RightRot;
    USHORT us;
    UCHAR c0;
    UCHAR c1;

    do {
        us = *(PUSHORT)pGlyph;
        c0 = (us & 0xff);
        c1 = us >> 8;
        pGlyph += 2;
        *pBuffer     = c0 >> RightRot;
        *(pBuffer+1) = (c1 >> RightRot) | (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_2_wide_rotated_no_last
//

VOID
or_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0;

    do {
        c0 = *pGlyph++;
        *pBuffer     |= c0 >> RightRot;
        *(pBuffer+1)  = (c0 << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}


//
//or_all_2_wide_rotated_no_last::
//

VOID
or_all_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c;

    do {
        c = *pGlyph;
        pGlyph ++;
        *pBuffer     |= (UCHAR)(c >> RightRot);
        *(pBuffer+1) |= (UCHAR)(c << rl);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_all_2_wide_unrotated::
//

VOID
or_all_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;

    //
    // aligned?
    //

    if ((ULONG_PTR)pBuffer & 0x01) {

        //
        // not aligned
        //

        USHORT usTmp;
        UCHAR  c1,c0;

        do {
            usTmp = *(PUSHORT)pGlyph;
            pGlyph +=2;
            *pBuffer     |= (UCHAR)usTmp;
            *(pBuffer+1) |= (UCHAR)(usTmp >> 8);
            pBuffer += ulBufDelta;
        }  while (pGlyph != pjEnd);

    } else {

        //
        // aligned
        //

        USHORT usTmp;

        do {
            usTmp = *(PUSHORT)pGlyph;
            pGlyph +=2;
            *(PUSHORT)pBuffer |= usTmp;
            pBuffer += ulBufDelta;
        }  while (pGlyph != pjEnd);

    }

}

//
// mov_first_2_wide_unrotated::
//

VOID
mov_first_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    USHORT     us;

    do {
        us = *(PUSHORT)pGlyph;
        pGlyph +=2;
        *pBuffer      = us & 0xff;
        *(pBuffer+1)  = (UCHAR)(us >> 8);
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// mov_first_2_wide_rotated_no_last::
//

VOID
mov_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0;
    UCHAR c1;

    do {
        c0 = *pGlyph++;
        *pBuffer      = c0 >> RightRot;
        *(pBuffer+1)  = c0 << rl;
        pBuffer += ulBufDelta;
    }  while (pGlyph != pjEnd);
}

//
// or_first_3_wide_rotated_need_last::
//

VOID
or_first_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG ul;
    UCHAR c0,c1,c2;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian ulong and shift
        //

        ul = (c0 << 16) | (c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}


//
// or_all_3_wide_rotated_need_last::
//

VOID
or_all_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG ul;
    UCHAR c0,c1,c2;
    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian ulong and shift
        //

        ul = (c0 << 16) | (c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_all_3_wide_rotated_no_last::
//

VOID
or_all_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  ul;
    UCHAR  c0,c1;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = (c0 << 16) | (c1 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_first_3_wide_rotated_no_last::
//

VOID
or_first_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 2*cyGlyph;
    ULONG  ul;
    UCHAR  c0,c1;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = (c0 << 16) | (c1 << 8);
        ul >>= RightRot;

        //
        // store result, only or in first byte
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// mov_first_3_wide_unrotated::
//

VOID
mov_first_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1,c2;

    do {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer     = c0;
        *(pBuffer+1) = c1;
        *(pBuffer+2) = c2;

        pGlyph += 3;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}


//
//or_all_3_wide_unrotated::
//

VOID
or_all_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 3*cyGlyph;
    ULONG rl = 8-RightRot;
    UCHAR c0,c1,c2;

    do {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer |= c0;
        *(pBuffer+1) |= c1;
        *(pBuffer+2) |= c2;

        pBuffer += ulBufDelta;
        pGlyph += 3;

    } while (pGlyph != pjEnd);
}

//
// or_first_4_wide_rotated_need_last::
//

VOID
or_first_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;
    ULONG  ul;
    ULONG  t0,t1,t2;

    do {

        ul = *(PULONG)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & (0xff << 8);
        ul = (ul << 8) & (0xff << 16);

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1)  = (BYTE)(ul >> 16);

        *(pBuffer+2)  = (BYTE)(ul >> 8);

        *(pBuffer+3)  = (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;
    } while (pGlyph != pjEnd);
}

//
// or_all_4_wide_rotated_need_last::
//

VOID
or_all_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;
    ULONG  ul;
    ULONG  t0,t1,t2;

    do {

        ul = *(PULONG)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & (0xff << 8);
        ul = (ul << 8) & (0xff << 16);

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;

    } while (pGlyph != pjEnd);
}

//
// or_first_4_wide_rotated_no_last::
//

VOID
or_first_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PBYTE pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    ULONG ul;


    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian ULONG and shift
        //

        ul = (c0 << 24) | (c1 << 16) | (c2 << 8);
        ul >>= RightRot;

        //
        // store result, ony or in fisrt byte
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) = (BYTE)(ul >> 16);;

        *(pBuffer+2) = (BYTE)(ul >> 8);

        *(pBuffer+3) = (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
}

//
// or_all_4_wide_rotated_no_last::
//

VOID
or_all_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PBYTE pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    ULONG ul;


    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian ULONG and shift
        //

        ul = (c0 << 24) | (c1 << 16) | (c2 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);;

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
}

VOID
mov_first_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {
            *(PULONG)pBuffer = *(PULONG)pGlyph;
            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:
        while (pGlyph != pjEnd) {

            *pBuffer              = *pGlyph;
            *(pBuffer+1)          = *(pGlyph+1);
            *(pBuffer+2)          = *(pGlyph+2);
            *(pBuffer+3)          = *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    case 2:
        while (pGlyph != pjEnd) {

            *(PUSHORT)(pBuffer)   = *(PUSHORT)pGlyph;
            *(PUSHORT)(pBuffer+2) = *(PUSHORT)(pGlyph+2);

            pBuffer += ulBufDelta;
            pGlyph += 4;
        }
        break;
    }
}


//
// or_all_4_wide_unrotated::
//

VOID
or_all_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph
    )
{
    PUCHAR pjEnd = pGlyph + 4*cyGlyph;

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {

            *(PULONG)pBuffer |= *(PULONG)pGlyph;

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:

        while (pGlyph != pjEnd) {

            *pBuffer              |= *pGlyph;
            *(pBuffer+1)          |= *(pGlyph+1);
            *(pBuffer+2)          |= *(pGlyph+2);
            *(pBuffer+3)          |= *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 2:

        while (pGlyph != pjEnd) {

            *(PUSHORT)pBuffer     |= *(PUSHORT)pGlyph;
            *(PUSHORT)(pBuffer+2) |= *(PUSHORT)(pGlyph+2);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   or_first_N_wide_rotated_need_last
*
*
* Routine Description:
*
*   Draw arbitrarily wide glyphs to 1BPP temp buffer
*
*
* Arguments:
*
*   cyGlyph     -   glyph height
*   RightRot    -   alignment
*   ulBufDelta  -   scan line stride of temp buffer
*   pGlyph      -   pointer to glyph bitmap
*   pBuffer     -   pointer to temp buffer
*   cxGlyph     -   glyph width in pixels
*   cxDst       -   Dest width in bytes
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
or_first_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0 = *pGlyph++;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst;

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = c0 << rl;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst = (c0 >> RightRot) | c1;
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0 = *pGlyph++;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst;

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = c0 << rl;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_first_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst - 1;

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;
        c0 = *pGlyph;
        *pjDst |= ((c0 >> RightRot) | c1);
        pjDst++;
        pGlyph++;


        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst = ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst = c1;
        pjDst++;

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    do {

        UCHAR c0;
        UCHAR c1;
        pjDstEnd = pjDst + cxDst - 1;

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;

        //
        // know cxDst is at least 4, use do-while
        //

        do {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = c0 << rl;
            pjDst++;
            pGlyph++;

        } while (pjDst != pjDstEnd);

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst |= c1;
        pjDst++;

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

//
// The following routines can be significantly sped up by
// breaking them out into DWORD alignment cases.
//

VOID
mov_first_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    //
    // byte aligned copy
    //


    do {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        do {

            *pjDst++ = *pGlyph++;

        } while (pjDst != pjDstEnd );

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}

VOID
or_all_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PUCHAR  pGlyph,
    PUCHAR  pBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    PUCHAR pjDst      = (PUCHAR)pBuffer;
    PUCHAR pjDstEnd;
    PUCHAR pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    //
    // byte aligned copy
    //


    do {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        do {

            *pjDst++ |= *pGlyph++;

        } while (pjDst != pjDstEnd );

        pjDst += lStride;

    }  while (pjDst != pjDstEndy);
}



VOID exit_fast_text(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG);
VOID or_all_N_wide_rotated_need_last(LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_rotated_no_last  (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PUCHAR,PUCHAR,LONG,LONG);


PVOID OrAllTableNarrow[] = {
        exit_fast_text,
        exit_fast_text,
        exit_fast_text,
        exit_fast_text,
        or_all_1_wide_rotated_need_last,
        or_all_1_wide_unrotated,
        or_all_1_wide_rotated_need_last,
        or_all_1_wide_unrotated,
        or_all_2_wide_rotated_need_last,
        or_all_2_wide_unrotated,
        or_all_2_wide_rotated_no_last,
        or_all_2_wide_unrotated,
        or_all_3_wide_rotated_need_last,
        or_all_3_wide_unrotated,
        or_all_3_wide_rotated_no_last,
        or_all_3_wide_unrotated,
        or_all_4_wide_rotated_need_last,
        or_all_4_wide_unrotated,
        or_all_4_wide_rotated_no_last,
        or_all_4_wide_unrotated
    };


PVOID OrInitialTableNarrow[] = {
        exit_fast_text                     ,
        exit_fast_text                     ,
        exit_fast_text                     ,
        exit_fast_text                     ,

        or_all_1_wide_rotated_need_last    ,
        mov_first_1_wide_unrotated         ,
        or_all_1_wide_rotated_need_last    ,
        mov_first_1_wide_unrotated         ,

        or_first_2_wide_rotated_need_last  ,
        mov_first_2_wide_unrotated         ,
        or_first_2_wide_rotated_no_last    ,
        mov_first_2_wide_unrotated         ,

        or_first_3_wide_rotated_need_last  ,
        mov_first_3_wide_unrotated         ,
        or_first_3_wide_rotated_no_last    ,
        mov_first_3_wide_unrotated         ,
        or_first_4_wide_rotated_need_last  ,
        mov_first_4_wide_unrotated         ,
        or_first_4_wide_rotated_no_last    ,
        mov_first_4_wide_unrotated
    };

//
// Handles arbitrarily wide glyph drawing, for case where initial byte should be
// ORed if it's not aligned (intended for use in drawing all but the first glyph
// in a string). Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//

PVOID OrInitialTableWide[] = {
        or_first_N_wide_rotated_need_last,
        mov_first_N_wide_unrotated,
        or_first_N_wide_rotated_no_last,
        mov_first_N_wide_unrotated
    };

//
// Handles arbitrarily wide glyph drawing, for case where all bytes should
// be ORed (intended for use in drawing potentially overlapping glyphs).
// Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//
//

PVOID OrAllTableWide[] =  {
        or_all_N_wide_rotated_need_last,
        or_all_N_wide_unrotated,
        or_all_N_wide_rotated_no_last,
        or_all_N_wide_unrotated
    };


/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_nf_ntb_o_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    ULONG          iGlyph = 0;
    LONG           GlyphPosY;

    //
    // Draw non fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xffffffe0)
        //

        GlyphPosX = pGlyphPos[iGlyph].ptl.x + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphPosY = pGlyphPos[iGlyph].ptl.y + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.y - ulTempTop ;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        pTempOutput += (GlyphPosY * TempBufDelta);

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        iGlyph++;
    }


}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_f_ntb_o_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    ULONG          iGlyph = 0;
    LONG           GlyphPitchX;
    LONG           GlyphPitchY;
    LONG           GlyphPosY;

    //
    // Draw fixed pitch, tops and bottoms not aligned,overlap
    //

    GlyphPitchX = pGlyphPos->ptl.x - ulLeftEdge;
    GlyphPitchY = pGlyphPos->ptl.y - ulTempTop;

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = GlyphPitchX + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x;
        GlyphPosY = GlyphPitchY + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.y;

        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        //
        // calc glyph destination scan line
        //

        pTempOutput += (GlyphPosY * TempBufDelta);

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrAllTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        GlyphPitchX += ulCharInc;
        iGlyph++;
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_nf_tb_no_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom aligned glyphs that do not overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
draw_nf_tb_no_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    ULONG          iGlyph = 0;

    //
    // Draw non fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = pGlyphPos[iGlyph].ptl.x + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)              |
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }

        iGlyph++;
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_f_tb_no_to_temp_start
*
* Routine Description:
*
*   Specialized glyph dispatch routine for fixed pitch, top and
*   bottom aligned glyphs that do not overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjTempBuffer            - Pointer to temp 1Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xFFFFFFF80
*   TempBufDelta            - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
draw_f_tb_no_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjTempBuffer,
    ULONG           ulLeftEdge,
    ULONG           TempBufDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{

    LONG           NumScans;
    LONG           RightRot;
    PBYTE          pGlyphData;
    PBYTE          pTempOutput;
    GLYPHBITS      *pGlyphBits;
    LONG           GlyphPosX;
    LONG           GlyphPixels;
    LONG           GlyphAlignment;
    LONG           SrcBytes;
    LONG           DstBytes;
    ULONG          ulDrawFlag;
    PFN_GLYPHLOOPN pfnGlyphLoopN;
    PFN_GLYPHLOOP  pfnGlyphLoop;
    ULONG          iGlyph = 0;
    LONG           GlyphPitchX;

    GlyphPitchX = pGlyphPos->ptl.x;

    //
    // Draw fixed pitch, tops and bottoms not aligned,overlap
    //

    while (cGlyphs--) {

        pGlyphBits = pGlyphPos[iGlyph].pgdf->pgb;

        //
        // Glyph position in temp buffer = point.x + org.c - (TextRect.left & 0xfffffff8)
        //

        GlyphPosX = GlyphPitchX + pGlyphPos[iGlyph].pgdf->pgb->ptlOrigin.x - ulLeftEdge;
        GlyphAlignment = GlyphPosX & 0x07;

        //
        // calc byte offset
        //

        pTempOutput = pjTempBuffer + (GlyphPosX >> 3);

        //
        // glyph width
        //

        GlyphPixels = pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cx;

        //
        // source and dest bytes required
        //

        DstBytes = ((GlyphAlignment) + GlyphPixels + 7) >> 3;
        SrcBytes = (GlyphPixels + 7) >> 3;

        if (DstBytes <= 4) {

            //
            // use narrow initial table
            //

            ulDrawFlag = (
                            (DstBytes << 2)                       |
                            ((DstBytes > SrcBytes) << 1)          |
                            (GlyphAlignment == 0)
                         );


            pfnGlyphLoop = (PFN_GLYPHLOOP)OrInitialTableNarrow[ulDrawFlag];

            pfnGlyphLoop(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes
                        );

        } else {

            //
            // use wide glyph drawing
            //

            ulDrawFlag = (
                            ((DstBytes > SrcBytes) << 1) |
                            ((GlyphAlignment == 0))
                         );


            pfnGlyphLoopN = (PFN_GLYPHLOOPN)OrAllTableWide[ulDrawFlag];

            pfnGlyphLoopN(
                            pGlyphPos[iGlyph].pgdf->pgb->sizlBitmap.cy,
                            GlyphAlignment,
                            TempBufDelta,
                            pGlyphPos[iGlyph].pgdf->pgb->aj,
                            pTempOutput,
                            SrcBytes,
                            DstBytes
                        );


        }


        iGlyph++;
        GlyphPitchX += ulCharInc;

    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\textxlg.c ===
/******************************Module*Header*******************************\
* Module Name: textxlg.c
*
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#if 0

The following code assumes that the gray glyphs comming from the
font driver have DWORD aligned scans.....

/******************************Public*Routine******************************\
*
* Routine Name
*
*   draw_gray_nf_ntb_o_to_temp_start
*
* Routine Description:
*
*   The input glyphs are 4-bpp gray scale bitmaps that are DWORD aligned.
*   Specialized glyph dispatch routine for non-fixed pitch, top and
*   bottom not aligned glyphs that do overlap. This routine calculates
*   the glyph's position on the temp buffer, then determines the correct
*   highly specialized routine to be used to draw each glyph based on
*   the glyph width, alignment and rotation
*
* Arguments:
*
*   pGlyphPos               - Pointer to first in list of GLYPHPOS structs
*   cGlyph                  - Number of glyphs to draw
*   pjDst                   - Pointer to temp 4Bpp buffer to draw into
*   ulLeftEdge              - left edge of TextRect & 0xfffffff8
*                             This is equal to the position of the left
*                             edge rounded down to the nearest 32-bit
*                             aligned boundary (8 pixels / DWORD)
*   dpDst                   - Scan line Delta for TempBuffer (always pos)
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
draw_gray_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS *pgb; // pointer to current GLYPHBITS
    int x;          // pixel offset of the left edge of the glyph bitmap
                    // from the left edge of the output (4-bpp) bitmap
    int y;          // the pixel offset of the top edge of the glyph
                    // bitmap from the top edge of the output bitmap.
    GLYPHPOS *pgpOut;  // sentinel for loop
    void (*apfnGray[8])(ULONG*,ptrdiff_t,ULONG*,ULONG*,ptrdiff_t);

/**/DbgPrint(
/**/   "draw_gray_nf_ntb_o_to_temp_start(\n"
/**/   "    PGLYPHPOS       pGlyphPos  = %-#x\n"
/**/   "    ULONG           cGlyphs    = %u\n"
/**/   "    PUCHAR          pjDst      = %-#x\n"
/**/   "    ULONG           ulLeftEdge = %u\n"
/**/   "    ULONG           dpDst      = %-#x\n"
/**/   "    ULONG           ulCharInc  = %u\n"
/**/   "    ULONG           ulTempTop  = %u\n"
/**/   "     )\n"
/**/);
/**/DbgBreakPoint();

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; pGlyphPos++)
    {
        ULONG *pulSrcScan;
        ptrdiff_t dpulSrcScan;

        pgb         = pGlyphPos->pgdf->pgb;
        x           = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y           = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop ;
        pulSrcScan = (ULONG*) &(pgb->aj[0]);
        dpulSrcScan = (ptrdiff_t) (pgb->sizlBitmap.cx + 7)/8;
        //
        // dispatch to the appropriate function
        //
/**/    DbgPrint(
/**/        "pgb         = %-#x\n"
/**/        "x           = %d\n"
/**/        "y           = %d\n"
/**/        "pulSrcScan  = %-#x\n"
/**/        "dpulSrcScan = %u = %-#x\n"
/**/      , pgb
/**/      , x
/**/      , y
/**/      , pulSrcScan
/**/      , dpulSrcScan
/**/    );
/**/    DbgBreakPoint();
        (*apfnGray[x & 0x07]) (
            pulSrcScan                                                 ,
            dpulSrcScan                                                ,
            pulSrcScan + dpulSrcScan * (unsigned) pgb->sizlBitmap.cy   ,
            (ULONG*) (pjDst + y * dpDst) + ( x / 8)                    ,
            (ptrdiff_t) dpDst / sizeof(ULONG)
        );
    }
}

void
vOrShiftGrayGlyph0(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            *pulDst |= *pulSrc;
        }
    }
}


void
vOrShiftGrayGlyph2(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*2) + (b >> (32-4*2));
            b = a;
        }
    }
}


void
vOrShiftGrayGlyph4(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*4) + (b >> (32-4*4));
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph6(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG a = *pulSrc;

            *pulDst |= (a << 4*6) + (b >> (32-4*6));
            b = a;
        }
    }
}

#define MASK_0 0x0f0f0f0f
#define MASK_1 0xf0f0f0f0

void
vOrShiftGrayGlyph1(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 12;
            u |= (b & MASK_0) >> 20;
            u |= (a & MASK_1) >>  4;
            u |= (b & MASK_1) << 28;
            *pulDst = u;
            b = a;
        }
    }
}


void
vOrShiftGrayGlyph3(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 20;
            u |= (b & MASK_0) >> 12;
            u |= (a & 0x00f0f0f0) <<  4;
            u |= (b & MASK_1) >> 28;
            *pulDst = u;
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph5(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) << 28;
            u |= (b & MASK_0) >>  4;
            u |= (a & MASK_1) <<  4;
            u |= (b & MASK_1) >> 28;
            *pulDst = u;
            b = a;
        }
    }
}

void
vOrShiftGrayGlyph7(
    ULONG     *pulSrcScan
  , ptrdiff_t  dpulSrcScan
  , ULONG     *pulSrcScanOut
  , ULONG     *pulDstScan
  , ptrdiff_t  dpulDstScan
    )
{
    for (
        ; pulSrcScan < pulSrcScanOut
        ; pulDstScan += dpulDstScan,
          pulSrcScan += dpulSrcScan
    )
    {
        ULONG *pulSrc, *pulDst, *pulSrcOut;
        ULONG b = 0;
        for (
            pulDst    = pulDstScan,
            pulSrc    = pulSrcScan,
            pulSrcOut = pulSrcScan + dpulSrcScan
          ; pulSrc < pulSrcOut
          ; pulDst++,
            pulSrc++
        )
        {
            ULONG u;
            ULONG a = *pulSrc;

            u  = (a & MASK_0) >> 28;
            u |= (b & MASK_0) <<  4;
            u |= (a & MASK_1) << 20;
            u |= (b & MASK_1) >> 12;
            *pulDst = u;
            b = a;
        }
    }
}

void (*apfnGray[8])(ULONG*,ptrdiff_t,ULONG*,ULONG*,ptrdiff_t) =
{
    vOrShiftGrayGlyph0
   ,vOrShiftGrayGlyph1
   ,vOrShiftGrayGlyph2
   ,vOrShiftGrayGlyph3
   ,vOrShiftGrayGlyph4
   ,vOrShiftGrayGlyph5
   ,vOrShiftGrayGlyph6
   ,vOrShiftGrayGlyph7
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\tranblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: transblt.cxx
*
* Transparent BLT
*
* Created: 08-Nov-96
* Author: Lingyun Wang [lingyunw]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

VOID vTransparentCopy (PBLTINFO psb);

VOID vTransparentCopyS4D8 (PBLTINFO psb);
VOID vTransparentCopyS4D16 (PBLTINFO psb);
VOID vTransparentCopyS4D24 (PBLTINFO psb);
VOID vTransparentCopyS4D32 (PBLTINFO psb);

VOID vTransparentCopyS8D8Identity (PBLTINFO psb);
VOID vTransparentCopyS8D8 (PBLTINFO psb);
VOID vTransparentCopyS8D16 (PBLTINFO psb);
VOID vTransparentCopyS8D24 (PBLTINFO psb);
VOID vTransparentCopyS8D32 (PBLTINFO psb);

VOID vTransparentCopyS16D16Identity (PBLTINFO psb);
VOID vTransparentCopyS16D8 (PBLTINFO psb);
VOID vTransparentCopyS16D16 (PBLTINFO psb);
VOID vTransparentCopyS16D24 (PBLTINFO psb);
VOID vTransparentCopyS16D32 (PBLTINFO psb);

VOID vTransparentCopyS24D24Identity (PBLTINFO psb);
VOID vTransparentCopyS24D8 (PBLTINFO psb);
VOID vTransparentCopyS24D16 (PBLTINFO psb);
VOID vTransparentCopyS24D24 (PBLTINFO psb);
VOID vTransparentCopyS24D32 (PBLTINFO psb);

VOID vTransparentCopyS32D32Identity (PBLTINFO psb);
VOID vTransparentCopyS32D8 (PBLTINFO psb);
VOID vTransparentCopyS32D16 (PBLTINFO psb);
VOID vTransparentCopyS32D24 (PBLTINFO psb);
VOID vTransparentCopyS32D32 (PBLTINFO psb);


typedef VOID  (*PFN_TRANSPARENT)(PBLTINFO);

//
// Note:  if we ever want to reduce the amount of code we generate, we
//        can replace rarely used functions below with vTransparentCopy
//        (the general case function) and the linker should be smart
//        enough not to generate the unused code.  This will reduce
//        performance by roughly 5-15% (more in the no color translation
//        cases).
//
//        For now, we will not generate special code for 1BPP sources
//        and destinations
//

PFN_TRANSPARENT TransFunctionTable [6][7] = {
    vTransparentCopy, // 1BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopy, // 4BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS4D8,
    vTransparentCopyS4D16,
    vTransparentCopyS4D24,
    vTransparentCopyS4D32,
    vTransparentCopyS8D8Identity, // 8BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS8D8,
    vTransparentCopyS8D16,
    vTransparentCopyS8D24,
    vTransparentCopyS8D32,
    vTransparentCopyS16D16Identity, // 16BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS16D8,
    vTransparentCopyS16D16,
    vTransparentCopyS16D24,
    vTransparentCopyS16D32,
    vTransparentCopyS24D24Identity, // 24BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS24D8,
    vTransparentCopyS24D16,
    vTransparentCopyS24D24,
    vTransparentCopyS24D32,
    vTransparentCopyS32D32Identity, // 32BPP Source
    vTransparentCopy,
    vTransparentCopy,
    vTransparentCopyS32D8,
    vTransparentCopyS32D16,
    vTransparentCopyS32D24,
    vTransparentCopyS32D32
};



BOOL
GreTransparentBltPS(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor
);

/******************************Public*Routine******************************\
* StartPixel
*    Given a scanline pointer and position of a pixel, return the byte address
* of where the pixel is at depending on the format
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
PBYTE StartPixel (
    PBYTE pjBits,
    ULONG xStart,
    ULONG iBitmapFormat
)
{
   PBYTE pjStart = pjBits;
    //
    // getting the starting pixel
    //
    switch (iBitmapFormat)
    {
      case BMF_1BPP:
          pjStart = pjBits + (xStart >> 3);
          break;

       case BMF_4BPP:
          pjStart = pjBits + (xStart >> 1);
          break;

       case BMF_8BPP:
          pjStart = pjBits + xStart;
          break;

       case BMF_16BPP:
          pjStart = pjBits + 2*xStart;
          break;

       case BMF_24BPP:
          pjStart = pjBits + 3*xStart;
          break;

       case BMF_32BPP:
          pjStart = pjBits+4*xStart;
          break;

       default:
           WARNING ("Startpixel -- bad iFormatSrc\n");
    }

    return (pjStart);
}


/******************************Public*Routine******************************\
* vTransparentCopy
*     Does the gerneral transparent copy between 1,4,8,16,24,32 bit formats
*
*     Note:
*     performance can be improved by breaking this routine into many
*     dealing with different format so that we can save two comparsions
*     for each pixel operation.  Working set size will be large
*
*
* History:
*  15-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentCopy (PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting.
    // If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vTransparentCopy - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vTransparentCopy - direction not up to down");

    // These are our holding variables

    PBYTE  pjSrc;
    PBYTE  pjDst;
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;
    XLATE  *pxlo  = psb->pxlo;
    PBYTE  pjSrcTemp;
    PBYTE  pjDstTemp;
    ULONG  cxTemp;
    INT    iPosSrc, iPosDst;
    PULONG pulXlate = psb->pxlo->pulXlate;
    BYTE   jDst, jSrc;
    ULONG ulDst;
    ULONG ulSrc;
    BYTE jDstMask1[] = {0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};
    BYTE jDstMask4[] = {0x00, 0xf0};
    
    // We should never have got to this point with cx or 
    // cy zero, since there should be a check for empty rectangles 
    // before we get here 

    ASSERTGDI( cx != 0 && cy != 0,"vTransparentCopy - called with an empty rectangle"); 

    // used for 16bpp and 32bpp only
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); 
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | 
                     palSrc.flGre() | 
                     palSrc.flBlu()) : 0xFFFFFFFF;

    pjSrc = StartPixel (psb->pjSrc, psb->xSrcStart, psb->iFormatSrc);
    pjDst = StartPixel (psb->pjDst, psb->xDstStart, psb->iFormatDst);

    while(cy--)
    {
        pjSrcTemp  = pjSrc;
        pjDstTemp  = pjDst;
        cxTemp     = cx;

        iPosSrc = psb->xSrcStart;
        iPosDst = psb->xDstStart;

        if( psb->iFormatSrc == BMF_1BPP )
        {
            if (!(iPosSrc & 0x00000007))
            {
                // Decrement since we'll get incremented again 
                // right at the begining of this case in the 
                // switch statement.
                pjSrcTemp--;
            }
            else
            {
                jSrc = *pjSrcTemp << (iPosSrc & 0x7); 
            }
        }

        // jDst is used only by 1BPP and 4BPP destinations.  Need to get the correct
        // initial value for left boundary condition.
        if (psb->iFormatDst == BMF_1BPP)
        {
            jDst = *pjDstTemp & jDstMask1[iPosDst & 0x7];
        }
        else if (psb->iFormatDst == BMF_4BPP)
        {
            jDst = *pjDstTemp & jDstMask4[iPosDst & 0x1];
        }


        while (cxTemp--)
        {
            //
            // get a pixel from source and put it in ulSrc
            // move down one pixel
            //
            switch (psb->iFormatSrc)
            {
            case BMF_32BPP:
                ulSrc = *(PULONG)(pjSrcTemp) & flcolMask;
                pjSrcTemp +=4;
                break;

            case BMF_24BPP:
                ulSrc = *(pjSrcTemp + 2);
                ulSrc = ulSrc << 8;
                ulSrc |= (ULONG) *(pjSrcTemp + 1);
                ulSrc = ulSrc << 8;
                ulSrc |= (ULONG) *pjSrcTemp;
                pjSrcTemp += 3;
                break;

            case BMF_16BPP:
                ulSrc = (ULONG) *((PUSHORT)pjSrcTemp) & flcolMask;
                pjSrcTemp += 2;
                break;

            case BMF_8BPP:
                ulSrc = (ULONG) *pjSrcTemp;
                pjSrcTemp++;
                break;

            case BMF_4BPP:
                if (iPosSrc & 0x00000001)
                {
                    ulSrc = *pjSrcTemp & 0x0F;
                    pjSrcTemp++;
                }
                else
                {
                    ulSrc = (*pjSrcTemp & 0xF0)>>4;
                }

                iPosSrc++;
                break;

            case BMF_1BPP:
                if (!(iPosSrc & 0x00000007))
                {
                    pjSrcTemp++;
                    jSrc = *pjSrcTemp;
                }

                ulSrc = (ULONG)(jSrc & 0x80);
                ulSrc >>= 7;
                jSrc <<= 1;

                iPosSrc++;

                break;

            default:
                WARNING ("vTransparentCopy -- bad iFormatSrc\n");
                return ;

            } /*switch*/

            //
            // put one pixel in the dest
            //
            switch (psb->iFormatDst)
            {
            case BMF_32BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    *(PULONG)pjDstTemp = pxlo->ulTranslate(ulSrc);
                }
                pjDstTemp += 4;
                break;

            case BMF_24BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    ulDst = pxlo->ulTranslate(ulSrc);
                    *(pjDstTemp) = (BYTE) ulDst;
                    *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);
                    *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);
                }
                pjDstTemp += 3;
                break;

            case BMF_16BPP:
                if (ulSrc != psb->TransparentColor)
                    *(PUSHORT)pjDstTemp = (USHORT)pxlo->ulTranslate(ulSrc);

                pjDstTemp += 2;
                break;

            case BMF_8BPP:
                if (ulSrc != psb->TransparentColor)
                    *pjDstTemp = (BYTE)pxlo->ulTranslate(ulSrc);

                pjDstTemp++;
                break;

            case BMF_4BPP:
                if (iPosDst & 0x00000001)
                {
                    if (ulSrc != psb->TransparentColor)
                    {
                        jDst |= (BYTE)pxlo->ulTranslate(ulSrc);
                    }
                    else
                    {
                        jDst |= *pjDstTemp & 0x0F;
                    }

                    *pjDstTemp++ = jDst;
                }
                else
                {
                    if (ulSrc != psb->TransparentColor)
                    {
                        jDst = (BYTE)pxlo->ulTranslate(ulSrc) << 4;
                    }
                    else
                    {
                        jDst = *pjDstTemp & 0xF0;
                    }
                }

                iPosDst++;
                break;


            case BMF_1BPP:
                if (ulSrc != psb->TransparentColor)
                {
                    jDst |= pxlo->ulTranslate(ulSrc)<<7;
                }
                else
                {
                    jDst |= (*pjDstTemp << (iPosDst & 0x7)) & 0x80;
                }
                iPosDst++;

                if (!(iPosDst & 0x00000007) )
                {
                    *pjDstTemp++ = jDst;
                    jDst = 0;
                }
                else
                {
                    jDst >>= 1;
                }

                break;

            default:
                WARNING ("vTransparentCopy -- bad iFormatDst\n");
                return;
            }
        }

        // The boundary condition on the right
        if (psb->iFormatDst == BMF_1BPP)
        {
            if (iPosDst & 0x7)
            {
                BYTE mask = jDstMask1[iPosDst & 0x7];;
                *pjDstTemp = ((*pjDstTemp & (~mask)) | (jDst & mask));
            }
        }
        else if (psb->iFormatDst == BMF_4BPP)
        {
            if (iPosDst & 0x1)
            {
                BYTE mask = jDstMask4[iPosDst & 0x1];
                *pjDstTemp = ((*pjDstTemp & (~mask)) | (jDst & mask));
            }
        }

        pjSrc = pjSrc + psb->lDeltaSrc;
        pjDst = pjDst + psb->lDeltaDst;
    }
}

/**************************************************************************\
 *
 * Macro Generation Framework:
 *
 *   We use specialized functions to do the transparent blit from every
 *   source format to every target format.  In order to minimize typing
 *   errors, these are automatically generated using macros.  Here is
 *   the general structure of the vTransparentCopy Routines:
 *
 *   TC_START_TRANSPARENT_COPY(name)
 *   TC_INIT_PJSRC_[1,4,8,16,24,32]BPP
 *   TC_INIT_PJDST_[1,4,8,16,24,32]BPP
 *   TC_START_LOOP
 *   TC_GET_SRC_[1,4,8,16,24,32]BPP
 *   TC_PUT_DST_[1,4,8,16,24,32]BPP
 *   TC_FINISH
 *
 *   Note that in order to simplify boundary cases, we don't generate optimized
 *   code for 1BPP sources and destination, and 4BPP destinations.  This is OK
 *   because those cases are not very common.
 *
 * History:
 *  14-Aug-1997 -by- Ori Gershony [orig]
 * Wrote it.
 *
\**************************************************************************/

//
// Function declaration and variable declaration
//
#define TC_START_TRANSPARENT_COPY_PFNXLATE(name)                                \
VOID name (PBLTINFO psb)                                                        \
{                                                                               \
    ASSERTGDI(psb->xDir == 1,"vTransparentCopy - direction not left to right"); \
    ASSERTGDI(psb->yDir == 1,"vTransparentCopy - direction not up to down");    \
                                                                                \
    PBYTE  pjSrc;                                                               \
    PBYTE  pjDst;                                                               \
    ULONG  cx     = psb->cx;                                                    \
    ULONG  cy     = psb->cy;                                                    \
    XLATE  *pxlo  = psb->pxlo;                                                  \
    PBYTE  pjSrcTemp;                                                           \
    PBYTE  pjDstTemp;                                                           \
    ULONG  cxTemp;                                                              \
    INT    iPosSrc, iPosDst;                                                    \
    PULONG pulXlate = psb->pxlo->pulXlate;                                      \
    PFN_pfnXlate pfnXlate = pxlo->pfnXlateBetweenBitfields();                   \
    BYTE   jDst = 0, jSrc;                                                      \
    ULONG ulDst;                                                                \
    ULONG ulSrc;

#define TC_START_TRANSPARENT_COPY(name)                                   \
VOID name (PBLTINFO psb)                                                        \
{                                                                               \
    ASSERTGDI(psb->xDir == 1,"vTransparentCopy - direction not left to right"); \
    ASSERTGDI(psb->yDir == 1,"vTransparentCopy - direction not up to down");    \
                                                                                \
    PBYTE  pjSrc;                                                               \
    PBYTE  pjDst;                                                               \
    ULONG  cx     = psb->cx;                                                    \
    ULONG  cy     = psb->cy;                                                    \
    XLATE  *pxlo  = psb->pxlo;                                                  \
    PBYTE  pjSrcTemp;                                                           \
    PBYTE  pjDstTemp;                                                           \
    ULONG  cxTemp;                                                              \
    INT    iPosSrc, iPosDst;                                                    \
    PULONG pulXlate = psb->pxlo->pulXlate;                                      \
    BYTE   jDst = 0, jSrc;                                                      \
    ULONG ulDst;                                                                \
    ULONG ulSrc;

//
//  Initialize pjSrc based on source format
//
#define TC_INIT_PJSRC_4BPP \
    pjSrc = psb->pjSrc + (psb->xSrcStart >> 1);

#define TC_INIT_PJSRC_8BPP \
    pjSrc = psb->pjSrc + psb->xSrcStart;

#define TC_INIT_PJSRC_16BPP \
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); \
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | \
                                         palSrc.flGre() | \
                                         palSrc.flBlu()) : \
                                        0xFFFF; \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 2);

#define TC_INIT_PJSRC_24BPP \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 3);

#define TC_INIT_PJSRC_32BPP \
    XEPALOBJ palSrc(psb->pdioSrc->ppal()); \
    FLONG flcolMask = palSrc.bValid() ? (palSrc.flRed() | \
                                         palSrc.flGre() | \
                                         palSrc.flBlu()) : \
                                        0xFFFFFFFF; \
    pjSrc = psb->pjSrc + (psb->xSrcStart * 4);


//
//  Initialize pjDst based on destination format
//
#define TC_INIT_PJDST_8BPP \
    pjDst = psb->pjDst + psb->xDstStart;

#define TC_INIT_PJDST_16BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 2);

#define TC_INIT_PJDST_24BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 3);

#define TC_INIT_PJDST_32BPP \
    pjDst = psb->pjDst + (psb->xDstStart * 4);



//
// The loop upto the first switch statement
//
#define TC_START_LOOP              \
    while(cy--)                    \
    {                              \
        pjSrcTemp  = pjSrc;        \
        pjDstTemp  = pjDst;        \
        cxTemp     = cx;           \
                                   \
        iPosSrc = psb->xSrcStart;  \
        iPosDst = psb->xDstStart;  \
                                   \
        while (cxTemp--)           \
        {


//
// Get the source pixel
//
#define TC_GET_SRC_4BPP                    \
    if (iPosSrc & 0x00000001)              \
    {                                      \
        ulSrc = *pjSrcTemp & 0x0F;         \
        pjSrcTemp++;                       \
    }                                      \
    else                                   \
    {                                      \
        ulSrc = (*pjSrcTemp & 0xF0)>>4;    \
    }                                      \
    iPosSrc++;

#define TC_GET_SRC_8BPP                    \
    ulSrc = (ULONG) *pjSrcTemp;            \
    pjSrcTemp++;

#define TC_GET_SRC_16BPP                                \
    ulSrc = (ULONG) *((PUSHORT)pjSrcTemp) & flcolMask;  \
    pjSrcTemp += 2;

#define TC_GET_SRC_24BPP                   \
    ulSrc = *(pjSrcTemp + 2);              \
    ulSrc = ulSrc << 8;                    \
    ulSrc |= (ULONG) *(pjSrcTemp + 1);     \
    ulSrc = ulSrc << 8;                    \
    ulSrc |= (ULONG) *pjSrcTemp;           \
    pjSrcTemp += 3;

#define TC_GET_SRC_32BPP                                \
    ulSrc = *(PULONG)(pjSrcTemp) & flcolMask;          \
    pjSrcTemp +=4;


//
// Put the destination pixel (color translation version)
//

#define TC_PUT_DST_8BPP(A)                           \
    if (ulSrc != psb->TransparentColor)              \
        *pjDstTemp = (BYTE) A;                       \
    pjDstTemp++;

#define TC_PUT_DST_16BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
        *(PUSHORT)pjDstTemp = (USHORT) A;            \
    pjDstTemp += 2;

#define TC_PUT_DST_24BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        ulDst = A;                                   \
        *(pjDstTemp) = (BYTE) ulDst;                 \
        *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);      \
        *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);     \
    }                                                \
    pjDstTemp += 3;

#define TC_PUT_DST_32BPP(A)                          \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        *(PULONG)pjDstTemp = A;                      \
    }                                                \
    pjDstTemp += 4;



//
// Put the destination pixel (no color translation)
//

#define TC_PUT_DST_IDENT_8BPP                        \
    if (ulSrc != psb->TransparentColor)              \
        *pjDstTemp = (BYTE) ulSrc;                   \
    pjDstTemp++;

#define TC_PUT_DST_IDENT_16BPP                       \
    if (ulSrc != psb->TransparentColor)              \
        *(PUSHORT)pjDstTemp = (USHORT) ulSrc;        \
    pjDstTemp += 2;

#define TC_PUT_DST_IDENT_24BPP                       \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        ulDst = ulSrc;                               \
        *(pjDstTemp) = (BYTE) ulDst;               \
        *(pjDstTemp + 1) = (BYTE) (ulDst >> 8);        \
        *(pjDstTemp + 2) = (BYTE) (ulDst >> 16);       \
    }                                                \
    pjDstTemp += 3;

#define TC_PUT_DST_IDENT_32BPP                       \
    if (ulSrc != psb->TransparentColor)              \
    {                                                \
        *(PULONG)pjDstTemp = ulSrc;                  \
    }                                                \
    pjDstTemp += 4;




//
// The rest of the function:
//
#define TC_FINISH                                    \
         } pjSrc = pjSrc + psb->lDeltaSrc;           \
         pjDst = pjDst + psb->lDeltaDst;             \
    }                                                \
}





/******************************Public*Routine******************************\
* vTransparentS4Dxx
*
*     Does the transparent copy from a 4BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D8)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_8BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D16)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_16BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D24)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_24BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS4D32)
TC_INIT_PJSRC_4BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_4BPP
TC_PUT_DST_32BPP(pulXlate[ulSrc])
TC_FINISH







/******************************Public*Routine******************************\
* vTransparentS8Dxx
*
*     Does the transparent copy from a 8BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D8Identity)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_IDENT_8BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D8)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_8BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D16)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_16BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D24)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_24BPP(pulXlate[ulSrc])
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS8D32)
TC_INIT_PJSRC_8BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_8BPP
TC_PUT_DST_32BPP(pulXlate[ulSrc])
TC_FINISH






/******************************Public*Routine******************************\
* vTransparentS16Dxx
*
*     Does the transparent copy from a 16BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS16D16Identity)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_IDENT_16BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS16D8)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D16)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D24)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS16D32)
TC_INIT_PJSRC_16BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_16BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH





/******************************Public*Routine******************************\
* vTransparentS24Dxx
*
*     Does the transparent copy from a 24BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS24D24Identity)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_IDENT_24BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS24D8)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D16)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D24)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS24D32)
TC_INIT_PJSRC_24BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_24BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH





/******************************Public*Routine******************************\
* vTransparentS32Dxx
*
*     Does the transparent copy from a 32BPP source
*
* History:
*  14-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

TC_START_TRANSPARENT_COPY(vTransparentCopyS32D32Identity)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_IDENT_32BPP
TC_FINISH

TC_START_TRANSPARENT_COPY(vTransparentCopyS32D8)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_8BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_8BPP(pxlo->ulTranslate(ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D16)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_16BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_16BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D24)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_24BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_24BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH

TC_START_TRANSPARENT_COPY_PFNXLATE(vTransparentCopyS32D32)
TC_INIT_PJSRC_32BPP
TC_INIT_PJDST_32BPP
TC_START_LOOP
TC_GET_SRC_32BPP
TC_PUT_DST_32BPP(pfnXlate(pxlo, ulSrc))
TC_FINISH




/******************************Public*Routine******************************\
* EngTransparentBlt
*
*    Sets up for a transparent blt from <psoSrc> to <psoDst> with TransColor.
*    The actual copying of the bits is performed by a function call.
*
\**************************************************************************/

BOOL
EngTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor,
    ULONG      bCalledFromBitBlt    // Officially, this is 'ulReserved' and
                                    //   should always be set to zero.  But
                                    //   for the purposes of our 'ccaa' trick
                                    //   below, we use it for some private
                                    //   communication within GDI.  If this
                                    //   field needs to be used for something
                                    //   else in the future, GDI can communicate
                                    //   via some other mechanism.  (That is,
                                    //   feel free to use this field for something
                                    //   else in the future.)
)
{
    ASSERTGDI(psoDst != NULL, "ERROR EngTransparentBlt:  No Dst. Object");
    ASSERTGDI(psoSrc != NULL, "ERROR EngTransparentBlt:  No Src. Object");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR EngTransparentBlt:  No Target Rect.");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR EngTransparentBlt left < right");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR EngTransparentBlt top < bottom");

    if ((psoDst->iType != STYPE_BITMAP) || (psoSrc->iType != STYPE_BITMAP))
    {
        //
        // Performance is horrible and disgusting when the driver doesn't hook
        // DrvTransparentBlt and we can't directly access the bits.  As a work-
        // around for this problem, we piggy-back on DrvBitBlt: we know that when
        // the driver sees a weird ROP, it will turn around and call EngBitBlt,
        // with STYPE_BITMAP surfaces.  Then in EngBitBlt, we catch that case and
        // route it back here.  In this way we can cheaply get direct
        // access to the bits.
        //
        // Note that to avoid endlessly recursive calls (like with the VGA driver 
        // when the destination is a DIB and the source is a device bitmap), we
        // terminate the loop via 'bCalledFromBitBlt':

        if (!(bCalledFromBitBlt) &&
            ((prclDst->right - prclDst->left) == (prclSrc->right - prclSrc->left)) &&
            ((prclDst->bottom - prclDst->top) == (prclSrc->bottom - prclSrc->top)))
        {
            BRUSHOBJ bo;

            PDEVOBJ po(psoDst->hdev != NULL ? psoDst->hdev : psoSrc->hdev);

            bo.iSolidColor = TransColor;
            bo.flColorType = 0;
            bo.pvRbrush = NULL;

            return(PPFNDRV(po, BitBlt)(psoDst, psoSrc, NULL, pco, pxlo, prclDst, 
                                       (POINTL*) prclSrc, NULL, &bo, NULL, 0xccaa));
        }
    }

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    //
    // Make sure we psSetupTransparentSrcSurface doesn't modify caller's rectangles
    //

    RECTL rclDstWk = *prclDst;
    RECTL rclSrcWk = *prclSrc;
    prclDst = &rclDstWk;
    prclSrc = &rclSrcWk;

    //
    // Synchronize with the device driver before touching
    // the device surface.
    //

    {
         PDEVOBJ po(psoDst->hdev);
         po.vSync(psoDst,NULL,0);
    }

    {
         PDEVOBJ po(psoSrc->hdev);
         po.vSync(psoSrc,NULL,0);
    }

    SURFACE *pSurfaceOld = NULL;
    RECTL   rclDstOld;
    CLIPOBJ    *pcoOld = pco;

    //
    // Get a readable source surface that is stretched to the destination size.
    //

    SURFMEM SurfDimoSrc;
    POINTL  ptlSrc;

    pSurfSrc = psSetupTransparentSrcSurface(
                        pSurfSrc,
                        pSurfDst,
                        prclDst,
                        NULL,
                        prclSrc,
                        SurfDimoSrc,
                        SOURCE_TRAN,
                        TransColor);

    //
    // adjust psoSrc and prclSrc
    //
    if (!pSurfSrc)
    {
        WARNING ("EngTransparentBlt -- psSetupTransparentSrcSurface failed\n");
        return (FALSE);
    }

    if (prclDst->left == prclDst->right)
    {
        return (TRUE);
    }

    psoSrc   = pSurfSrc->pSurfobj();

    //
    // If Dst is a device surface, copy it into a temporary DIB.
    //

    SURFMEM SurfDimoDst;

    pSurfaceOld = pSurfDst;
    rclDstOld = *prclDst;

    PDEVOBJ po(psoDst->hdev);

    //
    // printer surface, one scanline at a time
    //
    if ((pSurfDst->iType() != STYPE_BITMAP) && po.bPrinter())
    {
         return (GreTransparentBltPS(
                                    psoDst,
                                    psoSrc,
                                    pco,
                                    pxlo,
                                    prclDst,
                                    prclSrc,
                                    TransColor
                                   ));

    }
    else
    {
        pSurfDst = psSetupDstSurface(
                        pSurfDst,
                        prclDst,
                        SurfDimoDst,
                        FALSE,
                        TRUE
                        );
    }

    if (pSurfDst && (pSurfDst != pSurfaceOld))
    {
          //
          // adjust psoDst and prclDst and remember the original ones
          //

          psoDst = pSurfDst->pSurfobj();
          pco = NULL;
    }
    else if (pSurfDst == NULL)
    {
          return (FALSE);
    }

    //
    // prepare to call vTransparentCopy between two bitmaps
    //
    BOOL     bMore;            // True while more clip regions exist
    ULONG    ircl;             // Clip region index
    BLTINFO  bltinfo;          // Data passed to our vSrcCopySnDn fxn

    bltinfo.TransparentColor = TransColor;
    bltinfo.lDeltaSrc  = psoSrc->lDelta;
    bltinfo.lDeltaDst  = psoDst->lDelta;
    bltinfo.pdioSrc    = pSurfSrc;
    
    //
    // Determine the clipping region complexity.
    //

    CLIPENUMRECT    clenr;           // buffer for storing clip rectangles

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngTransBlt bad clipping type");
        }
    }
    else
    {
        bMore = FALSE;                   //Default to TRIVIAL for no clip
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    }

    //
    // Set up the static blt information into the BLTINFO structure -
    // The colour translation, & the copy directions.
    //

    //
    // pxlo is NULL implies identity colour translation. */
    //
    if (pxlo == NULL)
        bltinfo.pxlo = &xloIdent;
    else
        bltinfo.pxlo = (XLATE *) pxlo;

    bltinfo.xDir = 1L;
    bltinfo.yDir = 1L;


    ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBits:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBits:  bad source format");
    ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngTransparentBits:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngTransparentBits:  bad source format");

     //
     // Compute the function table index and select the source copy
     // function.
     //

     bltinfo.iFormatDst = psoDst->iBitmapFormat;
     bltinfo.iFormatSrc = psoSrc->iBitmapFormat;

     PFN_TRANSPARENT pfnTransCopy;

     ASSERTGDI(BMF_1BPP == 1, "ERROR EngTransparentBlt:  BMF_1BPP not eq 1");
     ASSERTGDI(BMF_4BPP == 2, "ERROR EngTransparentBlt:  BMF_1BPP not eq 2");
     ASSERTGDI(BMF_8BPP == 3, "ERROR EngTransparentBlt:  BMF_1BPP not eq 3");
     ASSERTGDI(BMF_16BPP == 4, "ERROR EngTransparentBlt:  BMF_1BPP not eq 4");
     ASSERTGDI(BMF_24BPP == 5, "ERROR EngTransparentBlt:  BMF_1BPP not eq 5");
     ASSERTGDI(BMF_32BPP == 6, "ERROR EngTransparentBlt:  BMF_1BPP not eq 6");
     ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBlt:  bad destination format");
     ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngTransparentBlt:  bad source format");
     ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngTransparentBlt:  bad destination format");
     ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngTransparentBlt:  bad source format");


     do
     {
         if (bMore)
             bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                               (PVOID) &clenr);

         for (ircl = 0; ircl < clenr.c; ircl++)
         {
             PRECTL prcl = &clenr.arcl[ircl];

             //
             // Insersect the clip rectangle with the target rectangle to
             // determine our visible recangle
             //

             if (prcl->left < prclDst->left)
                 prcl->left = prclDst->left;
             if (prcl->right > prclDst->right)
                 prcl->right = prclDst->right;
             if (prcl->top < prclDst->top)
                 prcl->top = prclDst->top;
             if (prcl->bottom > prclDst->bottom)
                 prcl->bottom = prclDst->bottom;

             //
             // Process the result if it's a valid rectangle.
             //
             if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
             {
                 LONG   xSrc;
                 LONG   ySrc;
                 LONG   xDst;
                 LONG   yDst;

                 //
                 // Figure out the upper-left coordinates of rects to blt
                 //
                 xDst = prcl->left;
                 yDst = prcl->top;
                 xSrc = prclSrc->left + xDst - prclDst->left;
                 ySrc = prclSrc->top + yDst - prclDst->top;

                 //
                 // Figure out the width and height of this rectangle
                 //
                 bltinfo.cx = prcl->right  - xDst;
                 bltinfo.cy = prcl->bottom - yDst;

                 //
                 // # of pixels offset to first pixel for src and dst
                 // from start of scan
                 //
                 bltinfo.xSrcStart = xSrc;
                 bltinfo.xSrcEnd   = bltinfo.xSrcStart + bltinfo.cx;
                 bltinfo.xDstStart = xDst;
                 bltinfo.yDstStart = prcl->top;

                 //
                 // Src scanline begining
                 // Destination scanline begining
                 //
                 bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                     ySrc*(psoSrc->lDelta);
                 bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                     yDst * (psoDst->lDelta);


                 //
                 // Do the blt.  Assume that BMF_1BPP=1, BMF_32BPP=6 and the rest
                 // are in between.
                 //

                 ASSERTGDI(((bltinfo.iFormatSrc >= BMF_1BPP) && (bltinfo.iFormatSrc <= BMF_32BPP)),
                     "Source format is not one of 1BPP, 4BPP, 8BPP, 16BPP, 24BPP or 32BPP\n");

                 if ((((XLATE *)(bltinfo.pxlo))->bIsIdentity()) &&
                     (bltinfo.iFormatSrc == bltinfo.iFormatDst))
                 {
                     pfnTransCopy = TransFunctionTable[bltinfo.iFormatSrc-BMF_1BPP][0];
                 }
                 else
                 {
                     pfnTransCopy = TransFunctionTable[bltinfo.iFormatSrc-BMF_1BPP][bltinfo.iFormatDst];
                 }

                 (*pfnTransCopy)(&bltinfo);
             }
         }

    } while (bMore);

    //
    // if we have blt to a temp dest DIB, need to blt to the original dest
    //
    if (pSurfaceOld != pSurfDst)
    {
        PDEVOBJ pdoDstOld(pSurfaceOld->hdev());
        POINTL  ptl = {0,0};

        (*PPFNGET(pdoDstOld,CopyBits,pSurfaceOld->flags()))(
                  pSurfaceOld->pSurfobj(),
                  psoDst,
                  pcoOld,
                  &xloIdent,
                  &rclDstOld,
                  &ptl);

    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* ReadScanLine
*     read the scanline until it hits a transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG ReadScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  cx = xEnd-xStart;
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //
     iPos = xStart;

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos <= xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case BMF_1BPP:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if ((iPos & 0x00000007) == 0x7 )
                 pjSrc++;
             break;

         case BMF_4BPP:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case BMF_8BPP:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case BMF_16BPP:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case BMF_24BPP:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case BMF_32BPP:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return(0);

         } /*switch*/

         if (ulSrc == TransparentColor)
             bStop = TRUE;

         iPos++;
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* SkipScanLine
*     read the scanline until it hits a non-transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG SkipScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos = xStart;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos <= xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case BMF_1BPP:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if ((iPos & 0x00000007) == 0x7 )
                 pjSrc++;
             break;

         case BMF_4BPP:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case BMF_8BPP:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case BMF_16BPP:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case BMF_24BPP:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case BMF_32BPP:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return (0);

         } /*switch*/

         if (ulSrc != TransparentColor)
             bStop = TRUE;

         iPos++;   // move to the next pixel
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* VOID vTransparentScan
*
* Read a scanline at a time and send the non-transparent pixel scans over
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vTransparentScan (
    SURFOBJ   *psoDst,
    SURFOBJ   *psoSrc,
    ULONG     xSrc,
    ULONG     ySrc,
    XLATEOBJ  *pxlo,
    RECTL     *prcl,
    ULONG     TransparentColor)
{
    ULONG xStart = xSrc;
    ULONG cx =  prcl->right - prcl->left;
    ULONG xEnd = xSrc + cx;
    ULONG xStop, xReStart;
    RECTL erclTemp = *prcl;
    POINTL ptlSrc;

    PBYTE pjSrc = (PBYTE)psoSrc->pvScan0 + (LONG)ySrc * psoSrc->lDelta;

     // get the scanline

    ptlSrc.x = xSrc;
    ptlSrc.y = ySrc;

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);

    PDEVOBJ pdoDst(pSurfDst->hdev());

    while (xStart < xEnd)
    {
        xStop = ReadScanLine((PBYTE)pjSrc,
                              xStart,
                              xEnd,
                              psoSrc->iBitmapFormat,
                              TransparentColor);

        if (xStop-1 > xStart)
        {
            erclTemp.right = erclTemp.left + xStop - xStart;

            // send the partial scan line over

            (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags())) (psoDst,
                                                       psoSrc,
                                                       (CLIPOBJ *) NULL,
                                                       pxlo,
                                                       &erclTemp,
                                                       &ptlSrc);

        }

        //get to the next non transparent pixel
        xReStart = SkipScanLine((PBYTE)pjSrc,
                                 xStop,
                                 xEnd,
                                 psoSrc->iBitmapFormat,
                                 TransparentColor);

        erclTemp.left = erclTemp.left + xReStart-xStart;

        ptlSrc.x = xReStart;

        xStart = xReStart;
     }
}

/******************************Public*Routine******************************\
* GreTransparentBltPS
*
*    Special routine for Pscript when the destination is unreadable
*
\**************************************************************************/
BOOL
GreTransparentBltPS(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor
)
{
    ASSERTGDI(psoDst != NULL, "ERROR GreTransparentBltPS:  No Dst. Object");
    ASSERTGDI(psoSrc != NULL, "ERROR GreTransparentBltPS:  No Src. Object");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR GreTransparentBltPS:  No Target Rect.");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR GreTransparentBltPS left < right");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR GreTransparentBltPS top < bottom");

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    ULONG cx = prclDst->right-prclDst->left;
    ULONG cy = prclDst->bottom-prclDst->top;

    //
    // If same legnth/width but Src is a device surface,
    // need to copy it into atemporary DIB.
    //

    SURFMEM SurfDimoDst;

    ASSERTGDI (psoSrc->iType == STYPE_BITMAP, "ERROR GreTransparentBltPS:  source surface not STYPE_BITMAP");
    ASSERTGDI (psoDst->iType != STYPE_BITMAP, "ERROR GreTransparentBltPS:  destination surface is STYPE_BITMAP");

    //
    // prepare to call vTransparentCopy between two bitmaps
    //

    BOOL     bMore;            // True while more clip regions exist
    ULONG    ircl;             // Clip region index

    //
    // Determine the clipping region complexity.
    //

    CLIPENUMRECT    clenr;           // buffer for storing clip rectangles

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;    // Use the target for clipping
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngTransBlt bad clipping type");
        }
    }
    else
    {
        bMore = FALSE;                   //Default to TRIVIAL for no clip
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    }

    //
    // Set up the static blt information into the BLTINFO structure -
    // The colour translation, & the copy directions.
    //

    //
    // pxlo is NULL implies identity colour translation. */
    //
    if (pxlo == NULL)
        pxlo = &xloIdent;

    ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR GreTransparentBltPS:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR GreTransparentBltPS:  bad source format");
    ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR GreTransparentBltPS:  bad destination format");
    ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR GreTransparentBltPS:  bad source format");


    do
    {
        if (bMore)
            bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                              (PVOID) &clenr);

        for (ircl = 0; ircl < clenr.c; ircl++)
        {
            PRECTL prcl = &clenr.arcl[ircl];

            //
            // Insersect the clip rectangle with the target rectangle to
            // determine our visible recangle
            //

            if (prcl->left < prclDst->left)
                prcl->left = prclDst->left;
            if (prcl->right > prclDst->right)
                prcl->right = prclDst->right;
            if (prcl->top < prclDst->top)
                prcl->top = prclDst->top;
            if (prcl->bottom > prclDst->bottom)
                prcl->bottom = prclDst->bottom;

            //
            // Process the result if it's a valid rectangle.
            //
            if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
            {
                LONG   xSrc;
                LONG   ySrc;
                LONG   xDst;
                LONG   yDst;
                ERECTL ercl;
                POINTL ptlSrc;

                //
                // Figure out the upper-left coordinates of rects to blt
                //
                ercl.left = prcl->left;
                ercl.top  = prcl->top;
                ercl.right = prcl->right;
                ercl.bottom = ercl.top+1;

                xDst = prcl->left;
                yDst = prcl->top;

                xSrc = prclSrc->left + xDst - prclDst->left;
                ySrc = prclSrc->top + yDst - prclDst->top;

                //
                // Figure out the width and height of this rectangle
                //
                LONG cx = prcl->right  - prcl->left;
                LONG cy = prcl->bottom - prcl->top;

                while (cy--)
                {
                    //
                    // Send one scanline over
                    //

                    //
                    // draw one scan line and skip transparent color pixels
                    //
                    vTransparentScan (psoDst, psoSrc, xSrc, ySrc, pxlo, &ercl, TransColor);

                    ySrc++;
                    ercl.top++;
                    ercl.bottom++;
                }

            }

        }

    } while (bMore);

    return TRUE;
}


/******************************Public*Routine******************************\
* NtGdiTransparentBlt
*
*     Copy or stretch the source bits onto the destionation surface which
* preserving the specific Transparent color on the destination Surface
*
* 25-Jun-97 Added rotation support -by- Ori Gershony [orig]
*
*  8-Nov-96 by Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
NtGdiTransparentBlt(
    HDC      hdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    HDC      hdcSrc,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    COLORREF TransColor
    )
{
    GDITraceHandle2(NtGdiTransparentBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %d, %d, %X)\n", (va_list)&hdcDst, hdcDst, hdcSrc);

    BOOL bReturn = FALSE;

    //
    // no mirroring
    //
    
    if ((cxDst < 0) || (cyDst < 0) || (cxSrc < 0) || (cySrc < 0)) 
    {
        WARNING1("NtGdiTransparentBlt: mirroring not allowed\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    //
    // Lock down both the Src and Dest DCs
    //

    DCOBJ  dcoDst(hdcDst);
    DCOBJ  dcoSrc(hdcSrc);

    if ((dcoDst.bValid() && !dcoDst.bStockBitmap()) && dcoSrc.bValid())
    {
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

        //
        // no source rotation
        //
        if (!xoSrc.bRotationOrMirroring())
        {
            //
            // Return null operations.  Don't need to check source for
            // empty because the xforms are the same except translation.
            //

            ERECTL erclSrc(xSrc,ySrc,xSrc+cxSrc,ySrc+cySrc);
            xoSrc.bXform(erclSrc);
            erclSrc.vOrder();


            //
            // If destination has a rotation, compute a bounding box for the
            // resulting parallelogram
            //
            EPOINTFIX pptfxDst[4];
            ERECTL erclDst;
            BOOL bRotationDst;

            if ((bRotationDst = xoDst.bRotationOrMirroring()))
            {
                //
                // Compute the resulting parallelogram.  In order to make sure we don't lose
                // precision in the rotation, we will store the output of the transformation
                // in fixed point numbers (this is how PlgBlt does it and we want our output
                // to match).
                // 
                POINTL pptlDst[3];

                pptlDst[0].x = xDst;
                pptlDst[0].y = yDst;

                pptlDst[1].x = xDst+cxDst;
                pptlDst[1].y = yDst;

                pptlDst[2].x = xDst;
                pptlDst[2].y = yDst+cyDst;

                xoDst.bXform(pptlDst, pptfxDst, 3);

                if (!xoDst.bRotation()) 
                {
                    //
                    // Mirroring transforms hack:  back in windows 3.1, they used to shift
                    // by one for mirroring transforms.  We need to support this here to
                    // be compatible with NT's BitBlt/StretchBlt that also use this hack, and
                    // also to be compatible with AlphaBlend that calls BitBlt/StretchBlt
                    // code when constant alpha=255 and there's no per-pixel alpha.  Ick!
                    // See BLTRECORD::vOrderStupid for details.  Also see bug 319917.
                    //

                    if (pptfxDst[0].x > pptfxDst[1].x) 
                    {
                        //
                        // Mirroring in x
                        //
                        pptfxDst[0].x += LTOFX(1);
                        pptfxDst[1].x += LTOFX(1);
                        pptfxDst[2].x += LTOFX(1);
                    }

                    if (pptfxDst[0].y > pptfxDst[2].y) 
                    {
                        //
                        // Mirroring in y
                        //
                        pptfxDst[0].y += LTOFX(1);
                        pptfxDst[1].y += LTOFX(1);
                        pptfxDst[2].y += LTOFX(1);
                    }
                }

                //
                // Compute the fourth point using the first three points.
                //
                pptfxDst[3].x = pptfxDst[1].x + pptfxDst[2].x - pptfxDst[0].x;
                pptfxDst[3].y = pptfxDst[1].y + pptfxDst[2].y - pptfxDst[0].y;

                //
                // Compute the bounding box.  Algorithm borrowed from Donald Sidoroff's code
                // in EngPlgBlt.  Basically the first two statements decide whether the indices of
                // the extremas are odd or even, and the last two statements determine exactly what
                // they are.
                //
                int iLeft = (pptfxDst[1].x > pptfxDst[0].x) == (pptfxDst[1].x > pptfxDst[3].x);
                int iTop  = (pptfxDst[1].y > pptfxDst[0].y) == (pptfxDst[1].y > pptfxDst[3].y);
                 
                if (pptfxDst[iLeft].x > pptfxDst[iLeft ^ 3].x)
                {
                    iLeft ^= 3;
                }
                 
                if (pptfxDst[iTop].y > pptfxDst[iTop ^ 3].y)
                {
                    iTop ^= 3;
                }

                erclDst = ERECTL(LONG_CEIL_OF_FIX(pptfxDst[iLeft  ].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop   ].y),
                                 LONG_CEIL_OF_FIX(pptfxDst[iLeft^3].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop^3 ].y));

                //
                // The vertices should now be in vOrder, but it doesn't hurt to verify this...
                //
                ASSERTGDI((erclDst.right  >= erclDst.left), "NtGdiTransparentBlt:  erclDst not in vOrder");
                ASSERTGDI((erclDst.bottom >= erclDst.top),  "NtGdiTransparentBlt:  erclDst not in vOrder");
            }
            else
            {
                //
                // No rotation--just apply the transformation to the rectangle
                //

                erclDst = ERECTL(xDst,yDst,xDst+cxDst,yDst+cyDst);
                xoDst.bXform(erclDst);
                erclDst.vOrder();
            }

            if (!erclDst.bEmpty())
            {
                //
                // Accumulate bounds.  We can do this outside the DEVLOCK
                //

                if (dcoDst.fjAccum())
                    dcoDst.vAccumulate(erclDst);

                //
                // Lock the Rao region and the surface if we are drawing on a
                // display surface.  Bail out if we are in full screen mode.
                //

                DEVLOCKBLTOBJ dlo;
                BOOL bLocked;

                bLocked = dlo.bLock(dcoDst, dcoSrc);

                if (bLocked)
                {
                    //
                    // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
                    //

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        XEPALOBJ   palDst(pSurfDst->ppal());
                        XEPALOBJ   palDstDC(dcoDst.ppal());


                        SURFACE *pSurfSrc = dcoSrc.pSurface();

                        //
                        // Basically we check that pSurfSrc is not NULL which
                        // happens for memory bitmaps with the default bitmap
                        // and for info DC's.  Otherwise we continue if
                        // the source is readable or if it isn't we continue
                        // if we are blting display to display or if User says
                        // we have ScreenAccess on this display DC.  Note
                        // that if pSurfSrc is not readable the only way we
                        // can continue the blt is if the src is a display.
                        //

                        if (pSurfSrc != NULL)
                        {
                            if ((pSurfSrc->bReadable()) ||
                                ((dcoSrc.bDisplay())  &&
                                 ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                            {

                                
                                //
                                // With a fixed DC origin we can change the rectangles to SCREEN coordinates.                                
                                //

                                //
                                // This is useful later for rotations
                                //                                
                                ERECTL erclDstOrig = erclDst;

                                erclDst += dcoDst.eptlOrigin();
                                erclSrc += dcoSrc.eptlOrigin();

                                //
                                // Make sure the source rectangle lies completely within the source
                                // surface.
                                //

                                BOOL bBadRects; 

                                // If the source is a Meta device, we must check bounds taking its 
                                // origin into account. 

                                PDEVOBJ pdoSrc( pSurfSrc->hdev() ); 

                                if( pSurfSrc->iType() == STYPE_DEVICE && 
                                    pdoSrc.bValid() && pdoSrc.bMetaDriver())
                                {
                                    bBadRects = ((erclSrc.left < pdoSrc.pptlOrigin()->x) ||
                                                    (erclSrc.top  < pdoSrc.pptlOrigin()->y) ||
                                                    (erclSrc.right  > (pdoSrc.pptlOrigin()->x + 
                                                     pSurfSrc->sizl().cx)) ||
                                                    (erclSrc.bottom > (pdoSrc.pptlOrigin()->y + 
                                                     pSurfSrc->sizl().cy)));
                                }
                                else
                                {   
                                    bBadRects = ((erclSrc.left < 0) ||
                                                    (erclSrc.top  < 0) ||
                                                    (erclSrc.right  > pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pSurfSrc->sizl().cy));
                                }
 
                                if (bBadRects)
                                {
                                    WARNING("NtGdiTransparentBlt -- source rectangle out of surface bounds");
                                }

                                //
                                // Make sure that source and destination rectangles don't overlap if the
                                // source surface is the same as the destination surface.
                                //
                                if (pSurfSrc == pSurfDst)
                                {
                                    ERECTL erclIntersection = erclSrc;
                                    erclIntersection *= erclDst;
                                    if (!erclIntersection.bEmpty())
                                    {
                                        bBadRects = TRUE;
                                        WARNING ("NtGdiTransparentBlt -- source and destination rectangles are on the same surface and overlap");
                                    }
                                }

                                if (!bBadRects)
                                {

                                    XEPALOBJ   palSrc(pSurfSrc->ppal());
                                    XEPALOBJ   palSrcDC(dcoSrc.ppal());

                                    //
                                    // get representation of src color
                                    //

                                    ULONG ulColor = ulGetNearestIndexFromColorref(
                                        palSrc,
                                        palSrcDC,
                                        TransColor,
                                        SE_DO_SEARCH_EXACT_FIRST
                                        );

                                    //
                                    // we don't want to touch the src/dest rectangles when there is stretching
                                    //
                                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                                    ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);

                                    // Check the destination which is reduced by clipping.

                                    if (eco.erclExclude().bEmpty())
                                    {
                                        return (TRUE);
                                    }

                                    // Compute the exclusion rectangle.

                                    ERECTL erclExclude = eco.erclExclude();

                                    // If we are going to the same source, prevent bad overlap situations

                                    if (dcoSrc.pSurface() == dcoDst.pSurface())
                                    {
                                        if (erclSrc.left   < erclExclude.left)
                                            erclExclude.left   = erclSrc.left;

                                        if (erclSrc.top    < erclExclude.top)
                                            erclExclude.top    = erclSrc.top;

                                        if (erclSrc.right  > erclExclude.right)
                                            erclExclude.right  = erclSrc.right;

                                        if (erclSrc.bottom > erclExclude.bottom)
                                            erclExclude.bottom = erclSrc.bottom;
                                    }

                                    // We might have to exclude the source or the target, get ready to do either.

                                    DEVEXCLUDEOBJ dxo;

                                    // They can't both be display

                                    if (dcoSrc.bDisplay())
                                    {
                                        ERECTL ercl(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);

                                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                                            ercl *= erclExclude;
                                        else
                                            ercl *= erclSrc;

                                        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
                                    }
                                    else if (dcoDst.bDisplay())
                                        dxo.vExclude(dcoDst.hdev(),&erclExclude,&eco);


                                    //
                                    // If the destination requires rotation, we allocate a surface and rotate the
                                    // source surface into it.
                                    //

                                    SURFMEM surfMemTmpSrc;
                                    if (bRotationDst)
                                    {
                                        //
                                        // Allocate memory for the rotated source surface
                                        //
                                        DEVBITMAPINFO   dbmi;

                                        dbmi.cxBitmap = erclDst.right  - erclDst.left;
                                        dbmi.cyBitmap = erclDst.bottom - erclDst.top;
                                        dbmi.iFormat  = pSurfSrc->iFormat();
                                        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                                        dbmi.hpal     = (HPALETTE)NULL;

                                        BOOL bStatus = surfMemTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                                        //
                                        // init DIB to transparent
                                        // (so that portions of dst rect not covered by source rect are not drawn)
                                        //
                                        if (bStatus)
                                        {
                                            ULONG i;
                                            ULONG cjBits = surfMemTmpSrc.ps->cjBits();
                                            ULONG ulColor4BPP;

                                            switch (pSurfSrc->iFormat())
                                            {
                                            case BMF_1BPP:
                                                if (ulColor)
                                                {
                                                    memset(surfMemTmpSrc.ps->pvBits(),0xff,cjBits);
                                                }
                                                else
                                                {
                                                    memset(surfMemTmpSrc.ps->pvBits(),0,cjBits);
                                                }
                                                break;

                                            case BMF_4BPP:
                                                ulColor4BPP = ulColor | (ulColor << 4);
                                                memset(surfMemTmpSrc.ps->pvBits(),ulColor4BPP,cjBits);
                                                break;

                                            case BMF_8BPP:
                                                memset(surfMemTmpSrc.ps->pvBits(),ulColor,cjBits);
                                                break;

                                            case BMF_16BPP:
                                                {
                                                    PUSHORT pvBits = (PUSHORT) surfMemTmpSrc.ps->pvBits();

                                                    for (i=0; i<(cjBits/sizeof(USHORT)); i++)
                                                    {
                                                        *pvBits++ = (USHORT) ulColor;

                                                    }
                                                }
                                            break;

                                            case BMF_24BPP:
                                                {
                                                    BYTE bC1 = ((PBYTE)&ulColor)[0];
                                                    BYTE bC2 = ((PBYTE)&ulColor)[1];
                                                    BYTE bC3 = ((PBYTE)&ulColor)[2];


                                                    PULONG pulDstY     = (PULONG)surfMemTmpSrc.ps->pvScan0();
                                                    PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY +
                                                                                  (surfMemTmpSrc.ps->lDelta() * surfMemTmpSrc.ps->sizl().cy));
                                                    while (pulDstY != pulDstLastY)
                                                    {
                                                        PBYTE pulDstX     = (PBYTE) pulDstY;
                                                        PBYTE pulDstLastX = pulDstX + 3 * surfMemTmpSrc.ps->sizl().cx;

                                                        while (pulDstX < pulDstLastX-2)
                                                        {
                                                            *pulDstX++ = bC1;
                                                            *pulDstX++ = bC2;
                                                            *pulDstX++ = bC3;
                                                        }
                                                        pulDstY = (PULONG)((PBYTE)pulDstY + surfMemTmpSrc.ps->lDelta());
                                                    }
                                                }
                                            break;

                                            case BMF_32BPP:
                                                {
                                                    PULONG pvBits = (PULONG) surfMemTmpSrc.ps->pvBits();

                                                    for (i=0; i<(cjBits/sizeof(ULONG)); i++)
                                                    {
                                                        *pvBits++ = ulColor;
                                                    }
                                                }
                                            break;
                                            }
                                        }
                                        else
                                        {
                                            //
                                            // Fail the call
                                            //
                                            WARNING("NtGdiTransparentBlt:  failed to create temporary DIB\n");
                                            EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                            return FALSE;
                                        }


                                        //
                                        // Now define the parallelogram the source bitmap is mapped to in surfMemTmpSrc
                                        //

                                        EPOINTFIX eptlNewSrc[3];

                                        eptlNewSrc[0] = EPOINTFIX(
                                            pptfxDst[0].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[0].y - LTOFX(erclDstOrig.top)
                                            );

                                        eptlNewSrc[1] = EPOINTFIX(
                                            pptfxDst[1].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[1].y - LTOFX(erclDstOrig.top)
                                            );

                                        eptlNewSrc[2] = EPOINTFIX(
                                            pptfxDst[2].x - LTOFX(erclDstOrig.left), 
                                            pptfxDst[2].y - LTOFX(erclDstOrig.top)
                                            );

                                        EngPlgBlt(
                                            surfMemTmpSrc.ps->pSurfobj(),
                                            pSurfSrc->pSurfobj(),
                                            NULL,   // No mask
                                            NULL,   // No clipping object
                                            &xloIdent,
                                            NULL,   // No color adjustment
                                            NULL,
                                            eptlNewSrc,
                                            &erclSrc,
                                            NULL,
                                            COLORONCOLOR
                                            );

                                        //
                                        // Now adjust the local variables
                                        //

                                        pSurfSrc = surfMemTmpSrc.ps;
                                        erclSrc.left = 0;
                                        erclSrc.top = 0;
                                        erclSrc.right = erclDst.right - erclDst.left;
                                        erclSrc.bottom = erclDst.bottom - erclDst.top;

                                    }

                                    bReturn = TRUE;

                                    EXLATEOBJ xlo;
                                    XLATEOBJ *pxlo;

                                    pxlo = NULL;

                                    if (dcoSrc.pSurface() != dcoDst.pSurface())
                                    {
                                        //
                                        // Get a translate object.
                                        //

                                        bReturn = xlo.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palDst,
                                            palSrcDC,
                                            palDstDC,
                                            dcoDst.pdc->crTextClr(),
                                            dcoDst.pdc->crBackClr(),
                                            (COLORREF)-1
                                            );

                                        pxlo = xlo.pxlo();
                                    }

                                    if (bReturn)
                                    {

                                        //
                                        // Inc the target surface uniqueness
                                        //

                                        INC_SURF_UNIQ(pSurfDst);

                                        //
                                        // Check were on the same PDEV, we can't blt between
                                        // different PDEV's.  We could make blting between different
                                        // PDEV's work easily.  All we need to do force EngBitBlt to
                                        // be called if the PDEV's aren't equal in the dispatch.
                                        // EngBitBlt does the right thing.
                                        //
                                        if (dcoDst.hdev() == dcoSrc.hdev())
                                        {
                                            PDEVOBJ pdo(pSurfDst->hdev());

                                            //
                                            // Dispatch the call.
                                            //

                                            bReturn = (*PPFNGET(pdo, TransparentBlt, pSurfDst->flags())) (
                                                pSurfDst->pSurfobj(),
                                                pSurfSrc->pSurfobj(),
                                                &eco,
                                                pxlo,
                                                &erclDst,
                                                &erclSrc,
                                                ulColor,
                                                0);
                                        }
                                        else
                                        {
                                            WARNING1("NtGdiTransparentBlt failed: source and destination surfaces not on same PDEV");
                                            EngSetLastError(ERROR_INVALID_PARAMETER);
                                            bReturn = FALSE;
                                        }
                                    }
                                    else
                                    {
                                        WARNING("NtGdiTransparentBlt -- failed to initxlateobj\n");
                                        EngSetLastError(ERROR_INVALID_HANDLE);
                                        bReturn = FALSE;
                                    }
                                }
                                else
                                {
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    bReturn = FALSE;
                                }
                            }
                            else
                            {
                                WARNING1("TransparentBlt failed - trying to read from unreadable surface\n");
                                EngSetLastError(ERROR_INVALID_HANDLE);
                                bReturn = FALSE;
                            }
                        }
                        else  // null src suface
                        {
                            bReturn = TRUE;
                        }
                    }
                    else  // null dest surface
                    {
                        bReturn = TRUE;
                    }
                }
                else
                {
                    // Return True if we are in full screen mode.

                    bReturn = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
                }
            }
            else
            {
                bReturn = TRUE;
            }
        }
        else
        {
            WARNING ("Source rotation in TranparentBlt is not supported\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bReturn=FALSE;
        }

    }
    else
    {
        WARNING("NtGdiTransparentBlt failed invalid src or dest dc \n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        bReturn=FALSE;
    }

    return(bReturn);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\timer.cxx ===
/******************************Module*Header*******************************\
* Module Name: timer.cxx
*
* For profiling
*
* Warning!
*
*       In its present form, this profiler will work only for single
*       threads of execution.
*
* Created: 13-Oct-1994 10:01:42
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#if DBG

FLONG  TIMER::fl               = 0; // set 0'th bit to start timing
char  *TIMER::pszRecordingFile = 0; // set to "c:\timer.txt" or whatever
TIMER *TIMER::pCurrent         = 0; // don't change this

/******************************Member*Function*****************************\
* TIMER::TIMER                                                             *
*                                                                          *
* History:                                                                 *
*  Fri 14-Oct-1994 06:59:29 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

TIMER::TIMER(char *psz_)
{
    if (fl & TIMER_MEASURE) {
        psz      = psz_;
        pParent  = pCurrent;
        pCurrent = this;
        NtQuerySystemTime((LARGE_INTEGER*)&llTick);
    }
}

/******************************Member*Function*****************************\
* TIMER::~TIMER                                                            *
*                                                                          *
* History:                                                                 *
*  Fri 14-Oct-1994 06:59:08 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

TIMER::~TIMER()
{
    if (fl & TIMER_MEASURE)  {
        if (psz)  {
            TIMER *p;
            CHAR ach[200];
            LONGLONG ll;
            NtQuerySystemTime((LARGE_INTEGER*)&ll);

            // calculate the difference in 0.1 microsecond units

            ll -= llTick;

            // print the lowest 32 bits of ll -- this limits
            // function calls to less than 429 seconds
            // this time is placed on the far left of the screen

            DbgPrint("%7u\t", (unsigned) ll / 100);
            // CHAR *pch = ach + wsprintfA(ach, "%7u\t", (unsigned) ll / 100);

            // indent one space for each parent that you have

            for (p = pParent; p; p = p->pParent)
                DbgPrint(" ");
                //*pch++ = ' ';

            // write the string after the indentation

            DbgPrint(psz);
            //pch += wsprintf(pch, "%s\n", psz);


            // always write the result to the debugging screen

            // DbgPrint("%s", ach);

            // if a recording file has been specified then append
            // the same string at the end of that file

            if (pszRecordingFile) {
                HANDLE hf;

                ASSERTGDI(FALSE, "Timer Recording File broken for now\n");

            //    if  (
            //        hf =
            //            CreateFileA(
            //                pszRecordingFile
            //            ,   GENERIC_WRITE
            //            ,   0
            //            ,   0
            //            ,   OPEN_ALWAYS
            //            ,   FILE_ATTRIBUTE_NORMAL
            //            ,   0
            //            )
            //    )  {
            //        LONG l = 0;
            //        SetFilePointer(hf, 0, &l, FILE_END);
            //        WriteFile(hf, ach, pch - ach, (DWORD*) &l, 0);
            //        CloseHandle(hf);
            //    }
            }
            // before this TIMER dies, change the current pointer
            // back to the parent

            pCurrent = pParent;

            // Put the parent TIMER's to sleep during the time that
            // this TIMER was in scope.
            // unfortunately this does not compensate the parents
            // for the this last little bit of copying .. oh well

            NtQuerySystemTime((LARGE_INTEGER*)&ll);
            ll -= llTick;
            for (p = pParent; p; p = p->pParent)
                p->llTick += ll;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\trivblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: trivblt.cxx
*
* EngCopyBits does the bitmap simulations source copy blts.
* The Rop is 0xCCCC, no brush or mask required.  Dib src
* and Dib dest are required.
*
* Created: 05-Feb-1991 21:06:12
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// The following table is used to lookup the function to be used for a
// particular type of copy operation. The table is indexed by a loosely
// encoded index composed of the source format, the destination format,
// the direction of the move, and whether the function is an identify
// function.
//
// This table is used in lieu of a doubly nested switch structure that
// not only takes more room, but requires more execution time.
//
// The index is formed as:
//
//     Index = (iFormatDst << 5) | (iFormatSrc << 2);
//     if (xDir < 0) {
//         Index += 2;
//     }
//
//     if (pxlo->bIsIdentity()) {
//         Index += 1;
//     }
//
// N.B. The entire table is filled. Entries that are illegal are tested
//     for using assertions. In free systems, dummy entries are used.
//



VOID
vSrcCopyDummy (
    PBLTINFO BltInfo
    );

PFN_SRCCPY SrcCopyFunctionTable[] = {
        vSrcCopyDummy,              // 000-000-0-0 Dst = ?, Src = ?
        vSrcCopyDummy,              // 000-000-0-1
        vSrcCopyDummy,              // 000-000-1-0
        vSrcCopyDummy,              // 000-000-1-1

        vSrcCopyDummy,              // 000-001-0-0 Dst = ?, Src = BMF_1BPP
        vSrcCopyDummy,              // 000-001-0-1
        vSrcCopyDummy,              // 000-001-1-0
        vSrcCopyDummy,              // 000-001-1-1

        vSrcCopyDummy,              // 000-010-0-0 Dst = ?, Src = BMF_4BPP
        vSrcCopyDummy,              // 000-010-0-1
        vSrcCopyDummy,              // 000-010-1-0
        vSrcCopyDummy,              // 000-010-1-1

        vSrcCopyDummy,              // 000-011-0-0 Dst = ?, Src = BMF_8BPP
        vSrcCopyDummy,              // 000-011-0-1
        vSrcCopyDummy,              // 000-011-1-0
        vSrcCopyDummy,              // 000-011-1-1

        vSrcCopyDummy,              // 000-100-0-0 Dst = ?, Src = BMF_16BPP
        vSrcCopyDummy,              // 000-100-0-1
        vSrcCopyDummy,              // 000-100-1-0
        vSrcCopyDummy,              // 000-100-1-1

        vSrcCopyDummy,              // 000-101-0-0 Dst = ?, Src = BMF_24BPP
        vSrcCopyDummy,              // 000-101-0-1
        vSrcCopyDummy,              // 000-101-1-0
        vSrcCopyDummy,              // 000-101-1-1

        vSrcCopyDummy,              // 000-110-0-0 Dst = ?, Src = BMF_32BPP
        vSrcCopyDummy,              // 000-110-0-1
        vSrcCopyDummy,              // 000-110-1-0
        vSrcCopyDummy,              // 000-110-1-1

        vSrcCopyDummy,              // 000-111-0-0 Dst = ?, Src = ?
        vSrcCopyDummy,              // 000-111-0-1
        vSrcCopyDummy,              // 000-111-1-0
        vSrcCopyDummy,              // 000-111-1-1

        vSrcCopyDummy,              // 001-000-0-0 Dst = BMF_1BPP, Src = ?
        vSrcCopyDummy,              // 001-000-0-1
        vSrcCopyDummy,              // 001-000-1-0
        vSrcCopyDummy,              // 001-000-1-1

        vSrcCopyS1D1LtoR,           // 001-001-0-0 Dst = BMF_1BPP, Src = BMF_1BPP
        vSrcCopyS1D1LtoR,           // 001-001-0-1
        vSrcCopyS1D1RtoL,           // 001-001-1-0
        vSrcCopyS1D1RtoL,           // 001-001-1-1

        vSrcCopyS4D1,               // 001-010-0-0 Dst = BMF_1BPP, Src = BMF_4BPP
        vSrcCopyS4D1,               // 001-010-0-1
        vSrcCopyS4D1,               // 001-010-1-0
        vSrcCopyS4D1,               // 001-010-1-1

        vSrcCopyS8D1,               // 001-011-0-0 Dst = BMF_1BPP, Src = BMF_8BPP
        vSrcCopyS8D1,               // 001-011-0-1
        vSrcCopyS8D1,               // 001-011-1-0
        vSrcCopyS8D1,               // 001-011-1-1

        vSrcCopyS16D1,              // 001-100-0-0 Dst = BMF_1BPP, Src = BMF_16BPP
        vSrcCopyS16D1,              // 001-100-0-1
        vSrcCopyS16D1,              // 001-100-1-0
        vSrcCopyS16D1,              // 001-100-1-1

        vSrcCopyS24D1,              // 001-101-0-0 Dst = BMF_1BPP, Src = BMF_24BPP
        vSrcCopyS24D1,              // 001-101-0-1
        vSrcCopyS24D1,              // 001-101-1-0
        vSrcCopyS24D1,              // 001-101-1-1

        vSrcCopyS32D1,              // 001-110-0-0 Dst = BMF_1BPP, Src = BMF_32BPP
        vSrcCopyS32D1,              // 001-110-0-1
        vSrcCopyS32D1,              // 001-110-1-0
        vSrcCopyS32D1,              // 001-110-1-1

        vSrcCopyDummy,              // 001-111-0-0 Dst = BMF_1BPP, Src = ?
        vSrcCopyDummy,              // 001-111-0-1
        vSrcCopyDummy,              // 001-111-1-0
        vSrcCopyDummy,              // 001-111-1-1

        vSrcCopyDummy,              // 010-000-0-0 Dst = BMF_4BPP, Src = ?
        vSrcCopyDummy,              // 010-000-0-1
        vSrcCopyDummy,              // 010-000-1-0
        vSrcCopyDummy,              // 010-000-1-1

        vSrcCopyS1D4,               // 010-001-0-0 Dst = BMF_4BPP, Src = BMF_1BPP
        vSrcCopyS1D4,               // 010-001-0-1
        vSrcCopyS1D4,               // 010-001-1-0
        vSrcCopyS1D4,               // 010-001-1-1

        vSrcCopyS4D4,               // 010-010-0-0 Dst = BMF_4BPP, Src =BMF_4BPP
        vSrcCopyS4D4Identity,       // 010-010-0-1
        vSrcCopyS4D4,               // 010-010-1-0
        vSrcCopyS4D4Identity,       // 010-010-1-1

        vSrcCopyS8D4,               // 010-011-0-0 Dst = BMF_4BPP, Src = BMF_8BPP
        vSrcCopyS8D4,               // 010-011-0-1
        vSrcCopyS8D4,               // 010-011-1-0
        vSrcCopyS8D4,               // 010-011-1-1

        vSrcCopyS16D4,              // 010-100-0-0 Dst = BMF_4BPP, Src = BMF_16BPP
        vSrcCopyS16D4,              // 010-100-0-1
        vSrcCopyS16D4,              // 010-100-1-0
        vSrcCopyS16D4,              // 010-100-1-1

        vSrcCopyS24D4,              // 010-101-0-0 Dst = BMF_4BPP, Src = BMF_24BPP
        vSrcCopyS24D4,              // 010-101-0-1
        vSrcCopyS24D4,              // 010-101-1-0
        vSrcCopyS24D4,              // 010-101-1-1

        vSrcCopyS32D4,              // 010-110-0-0 Dst = BMF_4BPP, Src = BMF_32BPP
        vSrcCopyS32D4,              // 010-110-0-1
        vSrcCopyS32D4,              // 010-110-1-0
        vSrcCopyS32D4,              // 010-110-1-1

        vSrcCopyDummy,              // 010-111-0-0 Dst = BMF_4BPP, Src = ?
        vSrcCopyDummy,              // 010-111-0-1
        vSrcCopyDummy,              // 010-111-1-0
        vSrcCopyDummy,              // 010-111-1-1

        vSrcCopyDummy,              // 011-000-0-0 Dst = BMF_8BPP, Src = ?
        vSrcCopyDummy,              // 011-000-0-1
        vSrcCopyDummy,              // 011-000-1-0
        vSrcCopyDummy,              // 011-000-1-1

        vSrcCopyS1D8,               // 011-001-0-0 Dst = BMF_8BPP, Src = BMF_1BPP
        vSrcCopyS1D8,               // 011-001-0-1
        vSrcCopyS1D8,               // 011-001-1-0
        vSrcCopyS1D8,               // 011-001-1-1

        vSrcCopyS4D8,               // 011-010-0-0 Dst = BMF_8BPP, Src = BMF_4BPP
        vSrcCopyS4D8,               // 011-010-0-1
        vSrcCopyS4D8,               // 011-010-1-0
        vSrcCopyS4D8,               // 011-010-1-1

        vSrcCopyS8D8,               // 011-011-0-0 Dst = BMF_8BPP, Src = BMF_8BPP
        vSrcCopyS8D8IdentityLtoR,   // 011-011-0-1
        vSrcCopyS8D8,               // 011-011-1-0
        vSrcCopyS8D8IdentityRtoL,   // 011-011-1-1

        vSrcCopyS16D8,              // 011-100-0-0 Dst = BMF_8BPP, Src = BMF_16BPP
        vSrcCopyS16D8,              // 011-100-0-1
        vSrcCopyS16D8,              // 011-100-1-0
        vSrcCopyS16D8,              // 011-100-1-1

        vSrcCopyS24D8,              // 011-101-0-0 Dst = BMF_8BPP, Src = BMF_24BPP
        vSrcCopyS24D8,              // 011-101-0-1
        vSrcCopyS24D8,              // 011-101-1-0
        vSrcCopyS24D8,              // 011-101-1-1

        vSrcCopyS32D8,              // 011-110-0-0 Dst = BMF_8BPP, Src = BMF_32BPP
        vSrcCopyS32D8,              // 011-110-0-1
        vSrcCopyS32D8,              // 011-110-1-0
        vSrcCopyS32D8,              // 011-110-1-1

        vSrcCopyDummy,              // 011-111-0-0 Dst = BMF_8BPP, Src = ?
        vSrcCopyDummy,              // 011-111-0-1
        vSrcCopyDummy,              // 011-111-1-0
        vSrcCopyDummy,              // 011-111-1-1

        vSrcCopyDummy,              // 100-000-0-0 Dst = BMF_16BPP, Src = ?
        vSrcCopyDummy,              // 100-000-0-1
        vSrcCopyDummy,              // 100-000-1-0
        vSrcCopyDummy,              // 100-000-1-1

        vSrcCopyS1D16,              // 100-001-0-0 Dst = BMF_16BPP, Src = BMF_1BPP
        vSrcCopyS1D16,              // 100-001-0-1
        vSrcCopyS1D16,              // 100-001-1-0
        vSrcCopyS1D16,              // 100-001-1-1

        vSrcCopyS4D16,              // 100-010-0-0 Dst = BMF_16BPP, Src = BMF_4BPP
        vSrcCopyS4D16,              // 100-010-0-1
        vSrcCopyS4D16,              // 100-010-1-0
        vSrcCopyS4D16,              // 100-010-1-1

        vSrcCopyS8D16,              // 100-011-0-0 Dst = BMF_16BPP, Src = BMF_8BPP
        vSrcCopyS8D16,              // 100-011-0-1
        vSrcCopyS8D16,              // 100-011-1-0
        vSrcCopyS8D16,              // 100-011-1-1

        vSrcCopyS16D16,             // 100-100-0-0 Dst = BMF_16BPP, Src = BMF_16BPP
        vSrcCopyS16D16Identity,     // 100-100-0-1
        vSrcCopyS16D16,             // 100-100-1-0
        vSrcCopyS16D16Identity,     // 100-100-1-1

        vSrcCopyS24D16,             // 100-101-0-0 Dst = BMF_16BPP, Src = BMF_24BPP
        vSrcCopyS24D16,             // 100-101-0-1
        vSrcCopyS24D16,             // 100-101-1-0
        vSrcCopyS24D16,             // 100-101-1-1

        vSrcCopyS32D16,             // 100-110-0-0 Dst = BMF_16BPP, Src = BMF_32BPP
        vSrcCopyS32D16,             // 100-110-0-1
        vSrcCopyS32D16,             // 100-110-1-0
        vSrcCopyS32D16,             // 100-110-1-1

        vSrcCopyDummy,              // 100-111-0-0 Dst = BMF_16BPP, Src = ?
        vSrcCopyDummy,              // 100-111-0-1
        vSrcCopyDummy,              // 100-111-1-0
        vSrcCopyDummy,              // 100-111-1-1

        vSrcCopyDummy,              // 101-000-0-0 Dst = BMF_24BPP, Src = ?
        vSrcCopyDummy,              // 101-000-0-1
        vSrcCopyDummy,              // 101-000-1-0
        vSrcCopyDummy,              // 101-000-1-1

        vSrcCopyS1D24,              // 101-001-0-0 Dst = BMF_24BPP, Src = BMF_1BPP
        vSrcCopyS1D24,              // 101-001-0-1
        vSrcCopyS1D24,              // 101-001-1-0
        vSrcCopyS1D24,              // 101-001-1-1

        vSrcCopyS4D24,              // 101-010-0-0 Dst = BMF_24BPP, Src = BMF_4BPP
        vSrcCopyS4D24,              // 101-010-0-1
        vSrcCopyS4D24,              // 101-010-1-0
        vSrcCopyS4D24,              // 101-010-1-1

        vSrcCopyS8D24,              // 101-011-0-0 Dst = BMF_24BPP, Src = BMF_8BPP
        vSrcCopyS8D24,              // 101-011-0-1
        vSrcCopyS8D24,              // 101-011-1-0
        vSrcCopyS8D24,              // 101-011-1-1

        vSrcCopyS16D24,             // 101-100-0-0 Dst = BMF_24BPP, Src = BMF_16BPP
        vSrcCopyS16D24,             // 101-100-0-1
        vSrcCopyS16D24,             // 101-100-1-0
        vSrcCopyS16D24,             // 101-100-1-1

        vSrcCopyS24D24,             // 101-101-0-0 Dst = BMF_24BPP, Src = BMF_24BPP
        vSrcCopyS24D24Identity,     // 101-101-0-1
        vSrcCopyS24D24,             // 101-101-1-0
        vSrcCopyS24D24Identity,     // 101-101-1-1

        vSrcCopyS32D24,             // 101-110-0-0 Dst = BMF_24BPP, Src = BMF_32BPP
        vSrcCopyS32D24,             // 101-110-0-1
        vSrcCopyS32D24,             // 101-110-1-0
        vSrcCopyS32D24,             // 101-110-1-1

        vSrcCopyDummy,              // 101-111-0-0 Dst = BMF_24BPP, Src = ?
        vSrcCopyDummy,              // 101-111-0-1
        vSrcCopyDummy,              // 101-111-1-0
        vSrcCopyDummy,              // 101-111-1-1

        vSrcCopyDummy,              // 110-000-0-0 Dst = BMF_32BPP, Src = ?
        vSrcCopyDummy,              // 110-000-0-1
        vSrcCopyDummy,              // 110-000-1-0
        vSrcCopyDummy,              // 110-000-1-1

        vSrcCopyS1D32,              // 110-001-0-0 Dst = BMF_32BPP, Src = BMF_1BPP
        vSrcCopyS1D32,              // 110-001-0-1
        vSrcCopyS1D32,              // 110-001-1-0
        vSrcCopyS1D32,              // 110-001-1-1

        vSrcCopyS4D32,              // 110-010-0-0 Dst = BMF_32BPP, Src = BMF_4BPP
        vSrcCopyS4D32,              // 110-010-0-1
        vSrcCopyS4D32,              // 110-010-1-0
        vSrcCopyS4D32,              // 110-010-1-1

        vSrcCopyS8D32,              // 110-011-0-0 Dst = BMF_32BPP, Src = BMF_8BPP
        vSrcCopyS8D32,              // 110-011-0-1
        vSrcCopyS8D32,              // 110-011-1-0
        vSrcCopyS8D32,              // 110-011-1-1

        vSrcCopyS16D32,             // 110-100-0-0 Dst = BMF_32BPP, Src = BMF_16BPP
        vSrcCopyS16D32,             // 110-100-0-1
        vSrcCopyS16D32,             // 110-100-1-0
        vSrcCopyS16D32,             // 110-100-1-1

        vSrcCopyS24D32,             // 110-101-0-0 Dst = BMF_32BPP, Src = BMF_24BPP
        vSrcCopyS24D32,             // 110-101-0-1
        vSrcCopyS24D32,             // 110-101-1-0
        vSrcCopyS24D32,             // 110-101-1-1

        vSrcCopyS32D32,             // 110-110-0-0 Dst = BMF_32BPP, Src = BMF_32BPP
        vSrcCopyS32D32Identity,     // 110-110-0-1
        vSrcCopyS32D32,             // 110-110-1-0
        vSrcCopyS32D32Identity,     // 110-110-1-1

        vSrcCopyDummy,              // 110-111-0-0 Dst = BMF_32BPP, Src = ?
        vSrcCopyDummy,              // 110-111-0-1
        vSrcCopyDummy,              // 110-111-1-0
        vSrcCopyDummy               // 110-111-1-1
};

/******************************Public*Routine******************************\
* EngCopyBits
*
* Purpose:  Does all 0xCCCC blts.  This includes RLE blts.
*
* Description:
*
*    Sets up for a blt from <psoSrc> to <psoDst>.  The actual copying of
*    the bits is performed by a function call.  The function to be used
*    is determined by the formats of the source & destination - and is
*    is selected by making a call to <pfnSrcCpy>.
*
*    The blt setup consists of filling a BLTINFO structure with
*       - offsets into the source and destination bitmaps
*       - intial values of the source and destination pointers
*       - ending points in source and destination.
*
*    This function also controls clipping:  In the complex clipping case,
*    the BLTINFO structure is set up and the blt function is called for
*    EACH rectangle in the clipping object <pco>.
*
*    NB:  RLE Sources are treated as a special case, since we can't cheat
*         and start copying from inside the source bitmap.  We must play
*         the RLE from the beginning for each clipping region.
*         An optimization to get around this is coming.
*
* History:
*  22-Jan-1992 - Andrew Milton (w-andym):
*      Isolated the RLE source cases and provided some RLE play
*      optimizations.
*
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EngCopyBits(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc
)
{
    ASSERTGDI(psoDst != NULL, "ERROR EngCopyBits:  No Dst. Object\n");
    ASSERTGDI(psoSrc != NULL, "ERROR EngCopyBits:  No Src. Object\n");
    ASSERTGDI(prclDst != (PRECTL) NULL,  "ERROR EngCopyBits:  No Target Rect.\n");
    ASSERTGDI(pptlSrc != (PPOINTL) NULL, "ERROR EngCopyBits:  No Start Point.\n");
    ASSERTGDI(prclDst->left < prclDst->right, "ERROR EngCopyBits0\n");
    ASSERTGDI(prclDst->top < prclDst->bottom, "ERROR EngCopyBits1\n");

    ASSERTGDI(psoDst->iType == STYPE_BITMAP,
              "ERROR EngCopyBits:  Dst. Object is not a bitmap.\n");

    PSURFACE pSurfDst = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);

    ASSERTGDI(pSurfDst->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: dst BMF_JPEG\n");
    ASSERTGDI(pSurfDst->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: dst BMF_PNG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_JPEG,
              "ERROR EngCopyBits: src BMF_JPEG\n");
    ASSERTGDI(pSurfSrc->iFormat() != BMF_PNG,
              "ERROR EngCopyBits: src BMF_PNG\n");

// If this is a device surface pass it off to the driver.

    if (psoSrc->iType != STYPE_BITMAP)
    {
        PDEVOBJ pdoSrc(pSurfSrc->hdev());

        PFN_DrvCopyBits pfnCopyBits = PPFNDRV(pdoSrc,CopyBits);

    // If the source is a mirrored surface, pass the read request back 
    // through the DDML.  This allows a driver like NetMeeting to read
    // from the screen:

        EXLATEOBJ xloParent;

        if (pSurfSrc->bMirrorSurface() &&
            (pdoSrc.hdev() != pdoSrc.hdevParent()))
        {
            PDEVOBJ pdoSrc(pSurfSrc->hdev());
            PDEVOBJ pdoParent(pdoSrc.hdevParent());
            SURFREF srParent((HSURF)pSurfSrc->hMirrorParent);
            if (!srParent.bValid()) return (FALSE);
            if (xloParent.bInitXlateObj(
                          NULL,DC_ICM_OFF,
                          pdoParent.ppalSurf(), pdoSrc.ppalSurf(),
                          ppalDefault, ppalDefault, 
                          0L,0L,0L, XLATE_USE_SURFACE_PAL))
                pxlo = xloParent.pxlo();
            else
                return (FALSE);

            psoSrc      = srParent.ps->pSurfobj();
            pfnCopyBits = PPFNDRV(pdoParent, CopyBits);
        }

        return(pfnCopyBits(psoDst,
                           psoSrc,
                           pco,
                           pxlo,
                           prclDst,
                           pptlSrc));
    }

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(psoDst->hdev);
        po.vSync(psoDst,NULL,0);
    }

    {
        PDEVOBJ po(psoSrc->hdev);
        po.vSync(psoSrc,NULL,0);
    }

// Local Variables required for the blt

    BOOL     bMore;            // True while more clip regions exist
    BOOL     bRLE = FALSE;     // True if the source is an RLE bitmap
    ULONG    ircl;             // Clip region index
    BLTINFO  bltinfo;          // Data passed to our vSrcCopySnDn fxn

    /* Compute the directions for the copy and clipping enumeration.  There
     * are two cases:  RLE & not.
     *
     * RLE's are always copied Left-Right, Bottom-Top; which is also their
     * clipping enumeration.
     *
     * For non-RLE's, the copy direction is dependant on overlap.  The
     * X and Y directions must be chosen so ensure no portion of the source
     * is clobbered by the copy operation.  If there is no overlap, the
     * copy and clipping enumeration is Left-Right, Top-Bottom.
     */

    LONG xDir = 1L, yDir = 1L;  /* X, Y Directions.  Positive = Left, Down */
    LONG iDir;                  // Order to fetch clip region rectangles

    /*
     * Are we going to do reads from BMF_NOTSYSMEM ie Video memory ?
     * If so set up bltinfo so the blitting routine wil do source aligned reads.
     */

    if ((psoSrc->iBitmapFormat == BMF_8RLE) || (psoSrc->iBitmapFormat == BMF_4RLE))
    {
        /* RLE Case. */

        iDir = CD_RIGHTUP;
        xDir =  1L;
        yDir = -1L;

        bltinfo.lDeltaDst = -psoDst->lDelta;
        bltinfo.lDeltaSrc = 0;

        bRLE = TRUE;
    }
    else
    {
        /* Non-RLE Case.  
         *
     * Check whether source and destination are the same by comparing
     * the pvScan0 pointers.  We can't simply compare surface pointers or
     * handles because some drivers punt this call to GDI, but pass us
     * different SURFOBJs for the source and destination even when
     * they're really the same surface.
     */

        if (psoSrc->pvScan0 == psoDst->pvScan0) 
        {
            if (pptlSrc->x < prclDst->left)
            {
                xDir = -1L;                   /* Copy Right to Left          */
                if (pptlSrc->y < prclDst->top)
                {
                    yDir = -1L;               /* Copy Bottom to Top          */
                    iDir = CD_LEFTUP;         /* Clip Left-Right, Bottom-Top */
                }
                else
                {
                    iDir = CD_LEFTDOWN;       /* Clip Left-Right, Top-Bottom */
                }
            }
            else
            {
                if (pptlSrc->y < prclDst->top)
                {
                    yDir = -1L;               /* Copy Bottom to Top          */
                    iDir = CD_RIGHTUP;        /* Clip Right-Left, Bottom-Top */
                }
                else
                    iDir = CD_RIGHTDOWN;
            }
        }
        else
            iDir = CD_ANY;

        bltinfo.lDeltaSrc  = (yDir > 0) ?  psoSrc->lDelta :
                                          -psoSrc->lDelta;
        bltinfo.lDeltaDst  = (yDir > 0) ?  psoDst->lDelta :
                                          -psoDst->lDelta;
    }

    /* Determine the clipping region complexity. */

    CLIPENUMRECT    clenr;           /* buffer for storing clip rectangles */
    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;    // Use the target for clipping
            break;

        case DC_RECT:
            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, iDir,
                                           CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR EngCopyBits bad clipping type");

        } /* switch */
    }
    else
    {
        bMore = FALSE;                   /* Default to TRIVIAL for no clip */
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;        // Use the target for clipping
    } /* if */


    /* Set up the static blt information into the BLTINFO structure -
     * The colour translation, & the copy directions.
     */

    /* pxlo is NULL implies identity colour translation. */
    if (pxlo == NULL)
        bltinfo.pxlo = &xloIdent;
    else
        bltinfo.pxlo = (XLATE *) pxlo;

    bltinfo.xDir = xDir;
    bltinfo.yDir = yDir;

    /* Use a seperate loop for RLE bitmaps.  This way, we won't slow down
     * an iteration with an IF on each pass.  The trade-off is to duplicate
     * a portion of the code.
     */

    if (bRLE)
    {
        /* Fetch our blt function.  Die if NULL */

        PFN_RLECPY pfnRLECopy = pfnGetRLESrcCopy(psoSrc->iBitmapFormat,
                                                 psoDst->iBitmapFormat);
        if (pfnRLECopy == (PFN_RLECPY) NULL)
            return (FALSE);

        BOOL bBytesRemain = TRUE;

        /* Since an RLE bitmap must be played from its beginning,
         * we do not need to calculate offsets into the source bitmap.
         * This way, most of the information required for the BLTINFO
         * can be read off the Source & Destination objects.
         */

        bltinfo.ptlSrc    = *pptlSrc;
        bltinfo.pdioSrc   = pSurfSrc;
        bltinfo.yDstStart = (LONG)(prclDst->top + psoSrc->sizlBitmap.cy -
                                   pptlSrc->y - 1);

        bltinfo.xDstStart = (LONG)(prclDst->left - pptlSrc->x);
        bltinfo.ulOutCol  = bltinfo.xDstStart;

        bltinfo.pjSrc   = (PBYTE) psoSrc->pvScan0;
        bltinfo.pjDst   = (PBYTE) (((PBYTE) psoDst->pvScan0) +
                          bltinfo.yDstStart*psoDst->lDelta);
        bltinfo.ulConsumed = 0;
        bltinfo.rclDst.top = 0;

        do
        {
            PRECTL prcl;
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                                  (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {

                prcl = &clenr.arcl[ircl];

                /* Insersect the clip rectangle with the target rectangle to
                 * determine our visible rectangle
                 */

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;
                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;
                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;
                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

                /* Process the result if it's a valid rectangle.       */

                if ((prcl->top  < prcl->bottom) && (prcl->left < prcl->right))
                {
                    /* Adjust our starting position based on previous clips */

                    if (prcl->bottom <= bltinfo.rclDst.top)
                    {
                        if ((ULONG)prcl->top > bltinfo.ulEndRow)
                            continue;

                        if (!bBytesRemain)
                        {
                            bMore = FALSE; // Force us out of the outer loop
                            break;         // Force us out of the inner loop
                        }

                        bltinfo.pjSrc = bltinfo.pjSrcEnd;
                        bltinfo.pjDst = bltinfo.pjDstEnd;
                        bltinfo.yDstStart  = bltinfo.ulEndRow;
                        bltinfo.ulOutCol   = bltinfo.ulEndCol;
                        bltinfo.ulConsumed = bltinfo.ulEndConsumed;
                    }

                    bltinfo.rclDst = *prcl;
                    bBytesRemain = (*pfnRLECopy)(&bltinfo);

                }

            } /* for */

        } while(bMore);

    }
    else
    {
        /* Non-RLE Case */

        ULONG Index;
        PFN_SRCCPY pfnSrcCopy;

        ASSERTGDI(BMF_1BPP == 1, "ERROR EngCopyBits:  BMF_1BPP not eq 1");
        ASSERTGDI(BMF_4BPP == 2, "ERROR EngCopyBits:  BMF_1BPP not eq 2");
        ASSERTGDI(BMF_8BPP == 3, "ERROR EngCopyBits:  BMF_1BPP not eq 3");
        ASSERTGDI(BMF_16BPP == 4, "ERROR EngCopyBits:  BMF_1BPP not eq 4");
        ASSERTGDI(BMF_24BPP == 5, "ERROR EngCopyBits:  BMF_1BPP not eq 5");
        ASSERTGDI(BMF_32BPP == 6, "ERROR EngCopyBits:  BMF_1BPP not eq 6");
        ASSERTGDI(psoDst->iBitmapFormat <= BMF_32BPP, "ERROR EngCopyBits:  bad destination format");
        ASSERTGDI(psoSrc->iBitmapFormat <= BMF_32BPP, "ERROR EngCopyBits:  bad source format");
        ASSERTGDI(psoDst->iBitmapFormat != 0, "ERROR EngCopyBits:  bad destination format");
        ASSERTGDI(psoSrc->iBitmapFormat != 0, "ERROR EngCopyBits:  bad source format");

        //
        // Compute the function table index and select the source copy
        // function.
        //

        Index = (psoDst->iBitmapFormat << 5) | (psoSrc->iBitmapFormat << 2);
        if (xDir < 0) {
            Index += 2;
        }

        KFLOATING_SAVE fpState;
        BOOL bRestoreFP = FALSE;
        if (((XLATE *)(bltinfo.pxlo))->bIsIdentity())
        {
            Index += 1;
            if(psoSrc->fjBitmap & BMF_NOTSYSMEM)
            {
                bltinfo.fSrcAlignedRd = TRUE;
#if i386
                if(HasMMX)
                {
                    bRestoreFP = TRUE;
                    if(!NT_SUCCESS(KeSaveFloatingPointState(&fpState)))
                    {
                        bltinfo.fSrcAlignedRd = FALSE;
                        bRestoreFP = FALSE;
                    }
                }
#endif
            }
        }

        pfnSrcCopy = SrcCopyFunctionTable[Index];
        do {

            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr),
                                                  (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                /* Insersect the clip rectangle with the target rectangle to
                 * determine our visible recangle
                 */

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;
                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;
                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;
                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

                /* Process the result if it's a valid rectangle.       */

                if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
                {
                    /* These variables are used for computing where the
                     * scanlines start.
                     */
                    LONG   xSrc;
                    LONG   ySrc;
                    LONG   xDst;
                    LONG   yDst;

                    // Figure out the upper-left coordinates of rects to blt
                    xDst = prcl->left;
                    yDst = prcl->top;
                    xSrc = pptlSrc->x + xDst - prclDst->left;
                    ySrc = pptlSrc->y + yDst - prclDst->top;

                    // Figure out the width and height of this rectangle
                    bltinfo.cx = prcl->right  - xDst;
                    bltinfo.cy = prcl->bottom - yDst;

                    /* # of pixels offset to first pixel for src and dst
                     * from start of scan
                     */
                    bltinfo.xSrcStart = (xDir > 0) ? xSrc :
                                                     (xSrc + bltinfo.cx - 1);
                    bltinfo.xSrcEnd   = bltinfo.xSrcStart +
                                         (bltinfo.cx * xDir);
                    bltinfo.xDstStart = (xDir > 0) ? xDst :
                                                     (xDst + bltinfo.cx - 1);
                    bltinfo.yDstStart = prcl->top;

                    // Src scanline begining
                    // Destination scanline begining
                    if (yDir > 0)
                    {
                        bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                                                 ySrc*(psoSrc->lDelta);
                        bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                                                 yDst * (psoDst->lDelta);
                    }
                    else
                    {
                        bltinfo.pjSrc = ((PBYTE) psoSrc->pvScan0) +
                                 (ySrc + bltinfo.cy - 1) * (psoSrc->lDelta);
                        bltinfo.pjDst = ((PBYTE) psoDst->pvScan0) +
                                 (yDst + bltinfo.cy - 1) * (psoDst->lDelta);
                    } /* if */

                    /* Do the blt */

                    (*pfnSrcCopy)(&bltinfo);

                } /* if */

            } /* for */

        } while (bMore);
#if i386
        if(HasMMX)
        {
            if(bRestoreFP)
            {
                KeRestoreFloatingPointState(&fpState);
            }
        }
#endif

    } /* if */
    return(TRUE);

} /* EngCopyBits */

/******************************Private*Routine*****************************\
* vSrcCopyDummy
*
* This gets the correct function to dispatch to for Src Copy Bitblt.
*
* History:
*  02-Sep-1992 -by- David N. Cutler davec
* Wrote it.
\**************************************************************************/

VOID
vSrcCopyDummy (
    PBLTINFO BltInfo
    )

{

    ASSERTGDI(FALSE, "ERROR EngCopyBits: dummy function called");
    return;
}

/******************************Public*Routine******************************\
* pfnGetRLESrcCopy
*
* This gets the correct function to dispatch to for Src Copy Bitblt,
* assuming that the source is an RLE bitmap.
*
* History:
*
*  05 Mar 1992 - Andrew Milton (w-andym):
*     Creation.
*
\**************************************************************************/

PFN_RLECPY
pfnGetRLESrcCopy(
    ULONG iFormatSrc,
    ULONG iFormatDst)
{

    switch(iFormatDst) {

    case BMF_1BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D1);

        case BMF_4RLE:
            return(bSrcCopySRLE4D1);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_4BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D4);

        case BMF_4RLE:
            return(bSrcCopySRLE4D4);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_8BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D8);

        case BMF_4RLE:
            return(bSrcCopySRLE4D8);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_16BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D16);

        case BMF_4RLE:
            return(bSrcCopySRLE4D16);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_24BPP:

        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D24);

        case BMF_4RLE:
            return(bSrcCopySRLE4D24);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    case BMF_32BPP:
        switch(iFormatSrc)
        {
        case BMF_8RLE:
            return(bSrcCopySRLE8D32);

        case BMF_4RLE:
            return(bSrcCopySRLE4D32);

        default:
            RIP("ERROR: Invalid iFormatSrc in XlateList");
        }

    default:
        RIP("ERROR: Invalid iFormatDst in XlateList");
    } /* switch */

    return(NULL);
} /* pfnGetRLESrcCopy */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\trimesh.cxx ===
/******************************Module*Header*******************************\
* Module Name: trimesh.cxx
*
* Gradient fill inplementation
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

/**************************************************************************\
* pfnDetermineTriangleFillRoutine
*
*   determine scan line drawing routine for gradient fill
*
* Arguments:
*
*   pSurfDst          - dest surface
*   *ppal             - dest palette
*   *pnfTriangleFill  - return triangle fill routine
*   *pnfRectangleFill - return gradient fill routine
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineTriangleFillRoutine(
    PSURFACE     pSurfDst,
    XEPALOBJ     *ppal,
    PFN_GRADIENT *pnfTriangleFill,
    PFN_GRADRECT *pnfRectangleFill
    )
{

    switch (pSurfDst->iFormat())
    {
    case BMF_1BPP:
        *pnfTriangleFill  = vGradientFill1;
        *pnfRectangleFill = vFillGRectDIB1;
        break;
    case BMF_4BPP:
        *pnfTriangleFill  = vGradientFill4;
        *pnfRectangleFill = vFillGRectDIB4;
        break;

    case BMF_8BPP:
        *pnfTriangleFill  = vGradientFill8;
        *pnfRectangleFill = vFillGRectDIB8;
        break;

    case BMF_16BPP:
    {
        ULONG flR = ppal->flRed();
        ULONG flG = ppal->flGre();
        ULONG flB = ppal->flBlu();

        if (
            (flR == 0xf800) &&
            (flG == 0x07e0) &&
            (flB == 0x001f)
           )
        {
            *pnfTriangleFill  = vGradientFill16_565;
            *pnfRectangleFill = vFillGRectDIB16_565;
        }
        else if (
            (flR == 0x7c00) &&
            (flG == 0x03e0) &&
            (flB == 0x001f)
           )
        {
            *pnfTriangleFill  = vGradientFill16_555;
            *pnfRectangleFill = vFillGRectDIB16_555;
        }
        else
        {
            *pnfTriangleFill  = vGradientFill16Bitfields;
            *pnfRectangleFill = vFillGRectDIB16Bitfields;
        }
    }
    break;

    case BMF_24BPP:
        if(ppal->bIsRGB())
        {
            *pnfTriangleFill = vGradientFill24RGB;
            *pnfRectangleFill = vFillGRectDIB24RGB;
        }
        else if(ppal->bIsBGR())
        {
            *pnfTriangleFill = vGradientFill24BGR;
            *pnfRectangleFill = vFillGRectDIB24BGR;
        }
        else
        {
            *pnfTriangleFill = vGradientFill24Bitfields;
            *pnfRectangleFill = vFillGRectDIB24Bitfields;
        }
        break;

    case BMF_32BPP:
        if (ppal->bIsRGB())
        {
            *pnfTriangleFill = vGradientFill32RGB;
            *pnfRectangleFill = vFillGRectDIB32RGB;
        }
        else if (ppal->bIsBGR())
        {
            *pnfTriangleFill = vGradientFill32BGRA;
            *pnfRectangleFill = vFillGRectDIB32BGRA;
        }
        else
        {
            *pnfTriangleFill = vGradientFill32Bitfields;
            *pnfRectangleFill = vFillGRectDIB32Bitfields;
        }
        break;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vHorizontalLine
*
*   Record information for horizontal line.
*   Colors are recorded as fixed point 8.56
*
* Arguments:
*
*   pv1      - vertex 1
*   pv2      - vertex 2
*   ptData   - triangle data
*   ptridda  - dda data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0;
    LONG yIndex    = yPosition - ptData->y0;

    //
    // check if this line is whithin clipping in y
    //

    if (
         (yPosition >= ptData->rcl.top)   &&
         (yPosition < ptData->rcl.bottom)
       )
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv1->x;
            ptData->TriEdge[yIndex].llRed   = ((LONGLONG)pv1->Red)   << 48;
            ptData->TriEdge[yIndex].llGreen = ((LONGLONG)pv1->Green) << 48;
            ptData->TriEdge[yIndex].llBlue  = ((LONGLONG)pv1->Blue)  << 48;
            ptData->TriEdge[yIndex].llAlpha = ((LONGLONG)pv1->Alpha) << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv2->x;
            ptData->TriEdge[yIndex].llRed   = pv2->Red   << 48;
            ptData->TriEdge[yIndex].llGreen = pv2->Green << 48;
            ptData->TriEdge[yIndex].llBlue  = pv2->Blue  << 48;
            ptData->TriEdge[yIndex].llAlpha = pv2->Alpha << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x;
        }
    }
}

/******************************Public*Routine******************************\
* vEdgeDDA
*
*   Run line DDA down an edge of the triangle recording edge
*   position and color
*
* Arguments:
*
*   ptData  - triangle data
*   ptridda - line dda information
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONGLONG llRed    = ptridda->llRed;
    LONGLONG llGreen  = ptridda->llGreen;
    LONGLONG llBlue   = ptridda->llBlue;
    LONGLONG llAlpha  = ptridda->llAlpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    //
    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)
    //

    while (NumScanLines--)
    {
        //
        // check for and record left edge
        //

        if (yIndex >= 0)
        {
            if (L < ptData->TriEdge[yIndex].xLeft)
            {
                ptData->TriEdge[yIndex].xLeft   = L;
                ptData->TriEdge[yIndex].llRed   = llRed;
                ptData->TriEdge[yIndex].llGreen = llGreen;
                ptData->TriEdge[yIndex].llBlue  = llBlue;
                ptData->TriEdge[yIndex].llAlpha = llAlpha;
            }

            if (L > ptData->TriEdge[yIndex].xRight)
            {
                ptData->TriEdge[yIndex].xRight = L;
            }
        }

        //
        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR
        //

        yIndex++;

        L  += ptridda->dL;
        Rb -= ptridda->dR;

        //
        // inc color components by y and integer x components
        //

        llRed   += (ptridda->lldxyRed);
        llGreen += (ptridda->lldxyGreen);
        llBlue  += (ptridda->lldxyBlue);
        llAlpha += (ptridda->lldxyAlpha);

        //
        // check for DDA error term overflow, add one
        // more step in x and color if true,
        // and correct error term
        //

        if (Rb < 0)
        {
            //
            // fraction step in x
            //

            L += ptridda->Linc;

            //
            // fraction step in color components
            //

            llRed   += ptData->lldRdX;
            llGreen += ptData->lldGdX;
            llBlue  += ptData->lldBdX;
            llAlpha += ptData->lldAdX;

            //
            // adjust error term
            //

            Rb += ptridda->dN;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*   calculate bounding line
*
* Arguments:
*
*   pv1    - vertex 1
*   pv2    - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.lldxyRed   = ptData->lldRdY;
    tridda.lldxyGreen = ptData->lldGdY;
    tridda.lldxyBlue  = ptData->lldBdY;
    tridda.lldxyAlpha = ptData->lldAdY;

    //
    // N0 = integer y starting location
    // M0 = integer x starting location
    // dN = integer delta y
    // dM = integer delta x
    //
    // Arrange lines, must run DDA in positive delta y.
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
    }

    //
    // caclulate initial color value at stating vertex
    //

    tridda.llRed   = ptData->lldRdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldRdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llRA;

    tridda.llGreen = ptData->lldGdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldGdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llGA;

    tridda.llBlue  = ptData->lldBdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldBdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llBA;

    tridda.llAlpha = ptData->lldAdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldAdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +
                     ptData->llAA;

    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        LONGLONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line. Calc number of scan lines
        // and maximum y position
        //

        tridda.yIndex = tridda.N0 - ptData->y0;

        tridda.NumScanLines = tridda.dN;

        LONG NMax   = tridda.N0 + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
             (tridda.N0 > ptData->rcl.bottom) ||
             (NMax < ptData->rcl.top)
           )
        {
            //
            // nothing to draw
            //

            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = tridda.C + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            //
            // negative divide
            //

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            //
            // dM = 0
            //

            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0    = tridda.j * tridda.dL;
        LongL = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);
        }
        else if (LongL < 0)
        {
            LONGLONG Q = ((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = (LONG)(l0 + Frac);
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx
        //

        tridda.lldxyRed   = tridda.lldxyRed   + (ptData->lldRdX * tridda.dL);
        tridda.lldxyGreen = tridda.lldxyGreen + (ptData->lldGdX * tridda.dL);
        tridda.lldxyBlue  = tridda.lldxyBlue  + (ptData->lldBdX * tridda.dL);
        tridda.lldxyAlpha = tridda.lldxyAlpha + (ptData->lldAdX * tridda.dL);

        //
        // run edge dda
        //

        vEdgeDDA(ptData,&tridda);
    }
}

/**************************************************************************\
* bCalulateColorGradient
*
*   Calculate all color gradients
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle verticies
*   ptData      - triangel data
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

BOOL
bCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    GRADSTRUCT g;
    LONGLONG d;
    LONG z;

    g.x1 = pv1->x;
    g.y1 = pv1->y;
    g.x2 = pv2->x;
    g.y2 = pv2->y;

    z = pv0->x;
    g.x1 -= z;
    g.x2 -= z;

    z = pv0->y;
    g.y1 -= z;
    g.y2 -= z;

    g.d  = g.x1 * g.y2 - g.x2 * g.y1;

    LONG tx = MIN(g.x1,0);
    LONG ty = MIN(g.y1,0);

    g.m = MIN(tx,g.x2) + MIN(ty,g.y2);

    d = (LONGLONG) ABS(g.d);
    g.Q = (LONGLONG)TWO_TO_THE_48TH / d;
    g.R = (LONGLONG)TWO_TO_THE_48TH % d;

    ptData->ptColorCalcOrg.x = pv0->x;
    ptData->ptColorCalcOrg.y = pv0->y;

    bDoGradient(  &ptData->lldRdX   // &A
                , &ptData->lldRdY   // &B
                , &ptData->llRA     // &C
                , pv0->Red          // R0
                , pv1->Red          // R1
                , pv2->Red          // R2
                , &g             );

    bDoGradient(  &ptData->lldGdX
                , &ptData->lldGdY
                , &ptData->llGA
                , pv0->Green
                , pv1->Green
                , pv2->Green
                , &g             );

    bDoGradient(  &ptData->lldBdX
                , &ptData->lldBdY
                , &ptData->llBA
                , pv0->Blue
                , pv1->Blue
                , pv2->Blue
                , &g             );


    bDoGradient(  &ptData->lldAdX
                , &ptData->lldAdY
                , &ptData->llAA
                , pv0->Alpha
                , pv1->Alpha
                , pv2->Alpha
                , &g             );

    return(TRUE);
}

/**************************************************************************\
* MDiv64
*   64 bit mul-div
*
* Arguments:
*
*   return = (a * b) / c
*
* Return Value:
*
*
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

LONGLONG
MDiv64(
    LONGLONG a,
    LONGLONG b,
    LONGLONG c)
{
    LONGLONG Result;
    int isNegative=0;

    Result = 0;
    if (a != 0 && b != 0)
    {
        if (a < 0)
        {
            a = -a;
            isNegative = 1;
        }
        else if (b < 0)
        {
            b = -b;
            isNegative = 1;
        }
        a = a * b - (LONGLONG) isNegative;
        Result = a / c;
        if (isNegative)
        {
            Result = - Result - 1;
        }
    }
    return(Result);
}

/**************************************************************************\
* bDoGradient
*
*   calc color gradient for one color
*
* Arguments:
*
*   pA
*   pB
*   pC
*   g0
*   g1
*   g2
*   pg
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk   [kirko]
*
\**************************************************************************/

BOOL
bDoGradient(
    LONGLONG *pA,
    LONGLONG *pB,
    LONGLONG *pC,
    LONG g0,
    LONG g1,
    LONG g2,
    GRADSTRUCT *pg
    )
{
    BOOL bDiv(LONGLONG*, LONGLONG, LONG);
    LONGLONG a,b,c,d;

    g1 = g1 - g0;
    g2 = g2 - g0;

    a = g1 * pg->y2 - g2 * pg->y1;
    b = g2 * pg->x1 - g1 * pg->x2;
    d = pg->d;

    if (d < 0)
    {
        a = -a;
        b = -b;
        d = -d;
    }

    *pA = pg->Q * a + MDiv64(a, pg->R, d);
    *pB = pg->Q * b + MDiv64(b, pg->R, d);

    c = (d >> 1) + 1;
    a = c * pg->R - pg->m - 1;
    a /= d;
    a += c * pg->Q;
    a += pg->m;

    *pC = a + (((LONGLONG) g0) << 48);
    return(TRUE);
}

/**************************************************************************\
* lCalculateTriangleArea
*
* Arguments:
*
*  pv0    - vertex
*  pv1    - vertex
*  pv2    - vertex
*  ptData - triangle data
*
* Return Value:
*
*    < 0 = negative area
*    0   = 0 area
*    > 0 = positive area
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

LONG
lCalculateTriangleArea(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG lRet;

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);

    if (Area == 0)
    {
        lRet = 0;
    }
    else if (Area > 0)
    {
        lRet = 1;

        if (ptData != NULL)
        {
            ptData->Area = Area;
        }
    }
    else
    {
        lRet = -1;
    }

    return(lRet);
}


/**************************************************************************\
* LIMIT_COLOR
*
*   Actual input colors are limited to 0x0000 - 0xff00
*       256 * (0x00 - 0xff)
*
* Arguments:
*
*   pv - vertex
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define LIMIT_COLOR(pv)        \
                               \
    if (pv->Red > 0xff00)      \
    {                          \
        pv->Red = 0xff00;      \
    }                          \
                               \
    if (pv->Green > 0xff00)    \
    {                          \
        pv->Green = 0xff00;    \
    }                          \
                               \
    if (pv->Blue > 0xff00)     \
    {                          \
        pv->Blue = 0xff00;     \
    }

/******************************Public*Routine******************************\
* bCalculateTriangle
*
*   if triangle is too largre, break it in into 2 triangles and call this
*   routine on each (max recursion ~= 16)
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*   pSurfDst - destination surface
*   pInV0    - vertex
*   pInV1    - vertex
*   pInV2    - vertex
*   ptData   - triangle data
*   pfnG     - surface gradient draw routine
*
* Return Value:
*
*   status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateAndDrawTriangle(
    PSURFACE        pSurfDst,
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData,
    PFN_GRADIENT    pfnG
    )
{
    BOOL        bStatus = TRUE;
    LONG        index;
    LONG        lStatus;
    PTRIVERTEX  pv0 = pInV0;
    PTRIVERTEX  pv1 = pInV1;
    PTRIVERTEX  pv2 = pInV2;

    {
        PTRIVERTEX pvt;

        //
        // sort in y for line processing
        //

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        if (pv1->y > pv2->y)
        {
            SWAP_VERTEX(pv1,pv2,pvt);
        }

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);

        //
        // if area is zero then this is a degenerate triangle
        //

        if (lStatus == 0)
        {
            return(FALSE);
        }
        else if (lStatus <0)
        {
            //
            // negative area, swap pv1 and pv2 and recalcualte
            //

            SWAP_VERTEX(pv1,pv2,pvt);

            lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);

            if (lStatus == 0)
            {
                return(FALSE);
            }
            else if (lStatus <0)
            {
                WARNING1("Triangle Area still negative after vertex swap\n");
                return(FALSE);
            }
        }

        //
        // calc min and max drawing y
        //

        ptData->y0   = MAX(pv0->y,ptData->rcl.top);
        LONG MaxY    = MAX(pv1->y,pv2->y);
        ptData->y1   = MIN(MaxY,ptData->rcl.bottom);

        {
            //
            // init ptdata
            //

            LONG lIndex;

            for (lIndex=0;lIndex<(ptData->y1-ptData->y0);lIndex++)
            {
                ptData->TriEdge[lIndex].xLeft  = LONG_MAX;
                ptData->TriEdge[lIndex].xRight = LONG_MIN;
            }
        }

        //
        // calculate color gradients for each color. There is a little redundant
        // work here with calculation of deltas. Should make this one call or
        // do it in place.
        //

        LIMIT_COLOR(pv0);
        LIMIT_COLOR(pv1);
        LIMIT_COLOR(pv2);

        bCalulateColorGradient(pv0,pv1,pv2,ptData);

        //
        // draw lines into data array
        //

        vCalculateLine(pv0,pv1,ptData);
        vCalculateLine(pv1,pv2,ptData);
        vCalculateLine(pv2,pv0,ptData);

        pfnG(pSurfDst,ptData);
    }

    return(bStatus);
}

/**************************************************************************\
* bIsTriangleInBounds
*
*   Is triangle inside bounding rect
*
* Arguments:
*
*   pInV0  - vertex 0
*   pInV1  - vertex 1
*   pInV2  - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   TRUE in any of the triangle is contained in bounding rect
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsTriangleInBounds(
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData
    )
{
    PRECTL prclClip = &ptData->rcl;

    RECTL  rclTri;

    rclTri.left   = MIN(pInV0->x,pInV1->x);
    rclTri.right  = MAX(pInV0->x,pInV1->x);
    rclTri.top    = MIN(pInV0->y,pInV1->y);
    rclTri.bottom = MAX(pInV0->y,pInV1->y);

    rclTri.left   = MIN(rclTri.left,pInV2->x);
    rclTri.right  = MAX(rclTri.right,pInV2->x);
    rclTri.top    = MIN(rclTri.top,pInV2->y);
    rclTri.bottom = MAX(rclTri.bottom,pInV2->y);

    if ((rclTri.left   >= prclClip->right) ||
        (rclTri.right  <= prclClip->left)  ||
        (rclTri.top    >= prclClip->bottom) ||
        (rclTri.bottom <= prclClip->top))
    {
        return(FALSE);
    }

    return(TRUE);
}

/**************************************************************************\
* bTriangleNeedSplit
*   determine whether triangle needs split
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle vertex
*
* Return Value:
*
*   TRUE if triangle needs to be split
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleNeedsSplit(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2
    )
{
    //
    // calc dx,dy for each leg
    //

    LONG dx01 = ABS(pv0->x - pv1->x);
    LONG dy01 = ABS(pv0->y - pv1->y);

    LONG dx02 = ABS(pv0->x - pv2->x);
    LONG dy02 = ABS(pv0->y - pv2->y);

    LONG dx12 = ABS(pv1->x - pv2->x);
    LONG dy12 = ABS(pv1->y - pv2->y);

    //
    // if any length is longer than max, break triangle into two pieces
    // and call this routine for each
    //

    if (
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) ||
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        return(TRUE);
    }

    return(FALSE);
}

/**************************************************************************\
* bSplitTriangle
*   Determine is triangle must be split.
*   Split triangle along longest edge
*
* Arguments:
*
*   pv0,pv1,pv2 - triangle
*   pvNew       - new vertex
*   pGrad       - mesh
*
* Return Value:
*
*   TRUE if split, FALSE otherwise
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bSplitTriangle(
    PTRIVERTEX           pVert,
    PULONG               pFreeVert,
    PGRADIENT_TRIANGLE   pMesh,
    PULONG               pFreeMesh,
    PULONG               pRecurseLevel
    )
{
    BOOL bStatus = FALSE;

    ULONG CurrentMesh = (*pFreeMesh) - 1;

    ULONG ulTM0 = pMesh[CurrentMesh].Vertex1;
    ULONG ulTM1 = pMesh[CurrentMesh].Vertex2;
    ULONG ulTM2 = pMesh[CurrentMesh].Vertex3;

    PTRIVERTEX         pv0 = &pVert[ulTM0];
    PTRIVERTEX         pv1 = &pVert[ulTM1];
    PTRIVERTEX         pv2 = &pVert[ulTM2];

    PTRIVERTEX         pvT0 = pv0;
    PTRIVERTEX         pvT1 = pv1;
    PTRIVERTEX         pvT2 = pv2;

    TRIVERTEX          triNew;

    //
    // find longest edge
    //

    LONGLONG dx01 = ABS(pv0->x - pv1->x);
    LONGLONG dy01 = ABS(pv0->y - pv1->y);

    LONGLONG dx02 = ABS(pv0->x - pv2->x);
    LONGLONG dy02 = ABS(pv0->y - pv2->y);

    LONGLONG dx12 = ABS(pv1->x - pv2->x);
    LONGLONG dy12 = ABS(pv1->y - pv2->y);

    //
    // determine if triangle needs to be split
    //

    if (
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) ||
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        //
        // make sure this is a triangle
        //

        if (lCalculateTriangleArea(pv0,pv1,pv2,NULL) != 0)
        {
            //
            // Find longest edge, swap verticies so edge 0-1 is
            // longest.
            //

            LONGLONG d01Max = dx01 * dx01 + dy01 * dy01;
            LONGLONG d02Max = dx02 * dx02 + dy02 * dy02;
            LONGLONG d12Max = dx12 * dx12 + dy12 * dy12;

            if (d01Max > d02Max)
            {
                if (d01Max > d12Max)
                {
                    //
                    // d01 largest, default
                    //

                }
                else
                {
                    //
                    // d12 largest, swap 0 and 2
                    //

                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex1;
                }
            }
            else
            {
                if (d02Max > d12Max)
                {
                    //
                    // d02 largest, swap 1,2
                    //

                    pvT1  = pv2;
                    pvT2  = pv1;
                    ulTM1 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex2;
                }
                else
                {
                    //
                    // d12 largest, swap 0,2
                    //

                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3;
                    ulTM2 = pMesh[CurrentMesh].Vertex1;
                }
            }

            //
            // 2 new triangles 0,2,N and 1,2,N  (float)
            //

            {
                EFLOAT fpA,fpB;
                EFLOAT fTwo;
                LONG   lTemp;

                fTwo = (LONG)2;

                fpA = pvT0->x;
                fpB = pvT1->x;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);

                fpA.bEfToL(triNew.x);

                fpA = pvT0->y;
                fpB = pvT1->y;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(triNew.y);

                fpA = (LONG)pvT0->Red;
                fpB = (LONG)pvT1->Red;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Red = (USHORT)lTemp;

                fpA = (LONG)pvT0->Green;
                fpB = (LONG)pvT1->Green;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Green = (USHORT)lTemp;

                fpA = (LONG)pvT0->Blue;
                fpB = (LONG)pvT1->Blue;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Blue = (USHORT)lTemp;

                fpA = (LONG)pvT0->Alpha;
                fpB = (LONG)pvT1->Alpha;
                fpB-=(fpA);
                fpB/=(fTwo);
                fpA+=(fpB);
                fpA.bEfToL(lTemp);
                triNew.Alpha = (USHORT)lTemp;
            }

            //
            // add new entry to vertex array and two new entries to mesh array
            //
            // 0,2,New and 1,2,New
            //

            ULONG FreeVert = *pFreeVert;
            ULONG FreeMesh = *pFreeMesh;

            pVert[FreeVert] = triNew;

            pMesh[FreeMesh].Vertex1   = ulTM0;
            pMesh[FreeMesh].Vertex2   = ulTM2;
            pMesh[FreeMesh].Vertex3   = FreeVert;

            pMesh[FreeMesh+1].Vertex1 = ulTM1;
            pMesh[FreeMesh+1].Vertex2 = ulTM2;
            pMesh[FreeMesh+1].Vertex3 = FreeVert;

            pRecurseLevel[FreeMesh]   = 1;
            pRecurseLevel[FreeMesh+1] = 0;

            *pFreeMesh += 2;
            *pFreeVert += 1;

            bStatus = TRUE;
        }
        else
        {
            WARNING("bSplitTriangle:Error: triangle area = 0\n\n");
        }
    }

    return(bStatus);
}

/**************************************************************************\
* bTriangleMesh
*
*   Draw each triangle. If triangle is too big, then split.
*
* Arguments:
*
*   pSurfDst        - destination surface
*   pxlo            - xlate
*   pVertex         - pointer to vertex array
*   nVertex         - elements in vertex array
*   pMesh           - pointer to mesh array
*   nMesh           - elements in mesh array
*   ulMode          - draw mode
*   prclClip        - clip rect
*   prclMeshExtents - triangle extents rect
*   pptlDitherOrg   - dither org
*
* Return Value:
*
*   Status
*
* History:
*
*    5/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleMesh(
    PSURFACE                pSurfDst,
    XLATEOBJ               *pxlo,
    PTRIVERTEX              pVertex,
    ULONG                   nVertex,
    PGRADIENT_TRIANGLE      pMesh,
    ULONG                   nMesh,
    ULONG                   ulMode,
    PRECTL                  prclClip,
    PRECTL                  prclMeshExtents,
    PPOINTL                 pptlDitherOrg
    )
{
    PFN_GRADIENT pfnG;
    PFN_GRADRECT pfnTemp;
    BOOL bStatus = TRUE;
    LONG   dyTri = prclClip->bottom - prclClip->top;
    PTRIANGLEDATA ptData;

    //
    // allocate structure to hold scan line data for all triangles
    // drawn during this call
    //

    ptData = (PTRIANGLEDATA)PALLOCMEM(sizeof(TRIANGLEDATA) + (dyTri-1) * sizeof(TRIEDGE),'gdEg');

    if (ptData)
    {
        //
        // find a palette for the output surface
        //

        XEPALOBJ epal(pSurfDst->ppal());

        if (!epal.bValid())
        {
            PDEVOBJ  pdo(pSurfDst->hdev());
            epal.ppalSet(pdo.ppalSurf());
        }

        if (epal.bValid())
        {
            //
            // find out scan line routine to use to draw pixels
            //

            bDetermineTriangleFillRoutine(pSurfDst,&epal,&pfnG,&pfnTemp);
             
            //
            // Init global data
            //

            ptData->rcl         = *prclClip;
            ptData->DrawMode    = ulMode;
            ptData->pxlo        = pxlo;
            ptData->ppalDstSurf = &epal;
            ptData->ptDitherOrg = *pptlDitherOrg;

            //
            // if triangle does not need to be split, draw each one.
            // Triangles need to be split if any edge exceeds a length
            // that will cause math problems.
            //

            if  (
                 ((prclMeshExtents->right  - prclMeshExtents->left) < MAX_EDGE_LENGTH) &&
                 ((prclMeshExtents->bottom - prclMeshExtents->top) < MAX_EDGE_LENGTH)
                 )
            {
                //
                // no split needed
                //

                ULONG ulIndex;
                for (ulIndex = 0;ulIndex<nMesh;ulIndex++)
                {
                    PTRIVERTEX pv0 = &pVertex[pMesh[ulIndex].Vertex1];
                    PTRIVERTEX pv1 = &pVertex[pMesh[ulIndex].Vertex2];
                    PTRIVERTEX pv2 = &pVertex[pMesh[ulIndex].Vertex3];

                    if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                    {
                        bStatus = bCalculateAndDrawTriangle(pSurfDst,pv0,pv1,pv2,ptData,pfnG);
                    }
                }
            }
            else
            {
                //
                // some triangles exceed maximum length, need to scan through triangles
                // and split triangles that exceed maximum edge length. This routine
                // works in a pseudo recursive manner, by splitting one triangle, then
                // splitting one of those 2 and so on. maximum depth is:
                //
                // 2 * ((log(2)(max dx,dy)) - 10)
                //
                // 10 = log(2) MAX_EDGE_LENGTH (2^14)
                // LOG(2)(2^28) = 28
                //
                // 2 * (28 - 14) = 28
                //

                ULONG              ulMaxVertex = nVertex + 28;
                ULONG              ulMaxMesh   = nMesh   + 28;
                PBYTE              pAlloc      = NULL;
                ULONG              ulSizeAlloc = (sizeof(TRIVERTEX) * ulMaxVertex) +
                                                 (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh) +
                                                 (sizeof(ULONG) * ulMaxMesh);

                pAlloc = (PBYTE)PALLOCNOZ(ulSizeAlloc,'tvtG');

                if (pAlloc != NULL)
                {
                    //
                    // assign buffers
                    //

                    PTRIVERTEX         pTempVertex = (PTRIVERTEX)pAlloc;
                    PGRADIENT_TRIANGLE pTempMesh   = (PGRADIENT_TRIANGLE)(pAlloc + (sizeof(TRIVERTEX) * ulMaxVertex));
                    PULONG             pRecurse    = (PULONG)((PBYTE)pTempMesh + (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh));

                    //
                    // copy initial triangle information
                    //

                    memcpy(pTempVertex,pVertex,sizeof(TRIVERTEX) * nVertex);
                    memcpy(pTempMesh,pMesh,sizeof(TRIVERTEX) * nMesh);
                    memset(pRecurse,0,nMesh * sizeof(ULONG));

                    //
                    // next free location in vertex and mesh arrays
                    //

                    ASSERTGDI(nMesh > 0, "bTriangleMesh: bad nMesh\n");

                    ULONG FreeVertex    = nVertex;
                    ULONG FreeMesh      = nMesh;

                    do
                    {
                        BOOL bSplit = FALSE;

                        //
                        // always operate on the last triangle in array
                        //

                        ULONG CurrentMesh = FreeMesh - 1;


                        //
                        // validate mesh pointers
                        //

                        if (
                            (pTempMesh[CurrentMesh].Vertex1 >= ulMaxVertex) ||
                            (pTempMesh[CurrentMesh].Vertex2 >= ulMaxVertex) ||
                            (pTempMesh[CurrentMesh].Vertex3 >= ulMaxVertex)
                            )
                        {
                             RIP("Error in triangle split routine:Vertex out of range\n");
                             break;
                        }

                        PTRIVERTEX pv0 = &pTempVertex[pTempMesh[CurrentMesh].Vertex1];
                        PTRIVERTEX pv1 = &pTempVertex[pTempMesh[CurrentMesh].Vertex2];
                        PTRIVERTEX pv2 = &pTempVertex[pTempMesh[CurrentMesh].Vertex3];

                        //
                        // check if triangle boundary is inside clip rect
                        //

                        if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                        {
                            bSplit = bSplitTriangle(pTempVertex,&FreeVertex,pTempMesh,&FreeMesh,pRecurse);

                            if (!bSplit)
                            {
                                //
                                // draw triangle
                                //

                                bStatus = bCalculateAndDrawTriangle(pSurfDst,pv0,pv1,pv2,ptData,pfnG);
                            }
                            else
                            {

                                //
                                // validate array indcies
                                //

                                if ((FreeVertex > ulMaxVertex) ||
                                    (FreeMesh   > ulMaxMesh))
                                {
                                    RIP("Error in triangle split routine: indicies out of range\n");
                                    break;
                                }
                            }
                        }

                        //
                        // if triangle was not split, then remove from list.
                        //

                        if (!bSplit)
                        {

                            //
                            // remove triangle just drawn. If this is the second triangle of a
                            // split, then remove the added vertex and the original triangle as
                            // well
                            //

                            do
                            {

                                FreeMesh--;

                                if (pRecurse[FreeMesh])
                                {
                                     FreeVertex--;
                                }

                            } while ((FreeMesh != 0) && (pRecurse[FreeMesh] == 1));
                        }

                    } while (FreeMesh != 0);

                    VFREEMEM(pAlloc);
                }
                else
                {
                    WARNING1("Memory allocation failed for temp triangle buffers\n");
                    bStatus = FALSE;
                }
            }
        }
        else
        {
            RIP("EngGradientFill:Error reading palette from surface\n");
            bStatus = FALSE;
        }

        //
        // free triangle data buffer
        //

        VFREEMEM(ptData);
    }

    return(bStatus);
}


/**************************************************************************\
* vCalcRectOffsets
*
*   calc params for gradient rect
*
* Arguments:
*
*   pGradRect - gradietn rect data
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcGradientRectOffsets(
    PGRADIENTRECTDATA pGradRect
    )
{
    LONG yScanTop     = MAX(pGradRect->rclClip.top,pGradRect->rclGradient.top);
    LONG yScanBottom  = MIN(pGradRect->rclClip.bottom,pGradRect->rclGradient.bottom);
    LONG yScanLeft    = MAX(pGradRect->rclClip.left,pGradRect->rclGradient.left);
    LONG yScanRight   = MIN(pGradRect->rclClip.right,pGradRect->rclGradient.right);

    //
    // calc actual widht, check for early out
    //

    pGradRect->ptDraw.x = yScanLeft;
    pGradRect->ptDraw.y = yScanTop;
    pGradRect->szDraw.cx = yScanRight  - yScanLeft;
    pGradRect->szDraw.cy = yScanBottom - yScanTop;

    LONG ltemp = pGradRect->rclClip.left - pGradRect->rclGradient.left;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->xScanAdjust  = ltemp;

    ltemp = pGradRect->rclClip.top  - pGradRect->rclGradient.top;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->yScanAdjust = ltemp;

    return((pGradRect->szDraw.cx > 0) && (pGradRect->szDraw.cy > 0));
}

/**************************************************************************\
* bRectangleMesh
*
*   Draw rectangle mesh
*
* Arguments:
*
*   pSurfDst      - destination surface
*   pxlo          - clip obj
*   pVertex       - vertex list
*   nVertex       - # in vertex list
*   pMesh         - mesh list
*   nMesh         - # in mesh list
*   ulMode        - draw mode and attributes
*   prclClip      - bounding rect
*   pptlDitherOrg - dither org
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bRectangleMesh(
    PSURFACE        pSurfDst,
    XLATEOBJ       *pxlo,
    PTRIVERTEX      pVertex,
    ULONG           nVertex,
    PGRADIENT_RECT  pMesh,
    ULONG           nMesh,
    ULONG           ulMode,
    PRECTL          prclClip,
    PPOINTL         pptlDitherOrg
    )
{
    PFN_GRADIENT pfnTemp;
    PFN_GRADRECT pfnG;
    BOOL         bStatus = TRUE;
    LONG         dyTri   = prclClip->bottom - prclClip->top;

    GRADIENTRECTDATA grData;

    XEPALOBJ epal(pSurfDst->ppal());

    if (!epal.bValid())
    {
        PDEVOBJ  pdo(pSurfDst->hdev());
        epal.ppalSet(pdo.ppalSurf());
    }


    if (epal.bValid())
    {
        //
        // find out scan line routine to use to draw pixels
        //

        bDetermineTriangleFillRoutine(pSurfDst,&epal,&pfnTemp,&pfnG);

        grData.pxlo        = pxlo;
        grData.ppalDstSurf = &epal;
        grData.ptDitherOrg = *pptlDitherOrg;

        //
        // draw each rectangle
        //

        grData.rclClip   = *prclClip;

        ULONG ulIndex;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            ULONG ulRect0 = pMesh[ulIndex].UpperLeft;
            ULONG ulRect1 = pMesh[ulIndex].LowerRight;

            //
            // make sure index are in array
            //

            if (
                (ulRect0 > (nVertex-1)) ||
                (ulRect1 > (nVertex-1))
            )
            {
                bStatus = FALSE;
                break;
            }

            TRIVERTEX  tvert0 = pVertex[ulRect0];
            TRIVERTEX  tvert1 = pVertex[ulRect1];
            PTRIVERTEX pv0 = &tvert0;
            PTRIVERTEX pv1 = &tvert1;
            PTRIVERTEX pvt;

            //
            // make sure rectangle endpoints are properly ordered
            //

            if (ulMode == GRADIENT_FILL_RECT_H)
            {

                if (pv0->x > pv1->x)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    //
                    // must swap y
                    //

                    LONG ltemp = pv1->y;
                    pv1->y = pv0->y;
                    pv0->y = ltemp;

                }
            }
            else
            {
                
                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }


                if (pv0->x > pv1->x)
                {

                    //
                    // must swap x
                    //

                    LONG ltemp = pv1->x;
                    pv1->x = pv0->x;
                    pv0->x = ltemp;
                }
            }

            //
            // gradient definition rectangle
            //

            grData.rclGradient.left   = pv0->x;
            grData.rclGradient.top    = pv0->y;

            grData.rclGradient.right  = pv1->x;
            grData.rclGradient.bottom = pv1->y;

            grData.ulMode  = ulMode;

            LONG dxGrad = grData.rclGradient.right  - grData.rclGradient.left;
            LONG dyGrad = grData.rclGradient.bottom - grData.rclGradient.top;

            //
            // make sure rect not empty
            //

            if ((dxGrad > 0) && (dyGrad > 0))
            {

                //
                // calculate color gradients for x and y
                //

                grData.llRed   = ((LONGLONG)pv0->Red)   << 40;
                grData.llGreen = ((LONGLONG)pv0->Green) << 40;
                grData.llBlue  = ((LONGLONG)pv0->Blue)  << 40;
                grData.llAlpha = ((LONGLONG)pv0->Alpha) << 40;

                if (ulMode == GRADIENT_FILL_RECT_H)
                {

                    grData.lldRdY = 0;
                    grData.lldGdY = 0;
                    grData.lldBdY = 0;
                    grData.lldAdY = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdX = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldGdX = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldBdX = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldAdX = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dxGrad);
                }
                else
                {

                    grData.lldRdX = 0;
                    grData.lldGdX = 0;
                    grData.lldBdX = 0;
                    grData.lldAdX = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdY = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldGdY = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldBdY = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldAdY = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dyGrad);
                }

                //
                // calculate common offsets
                //

                if (bCalcGradientRectOffsets(&grData))
                {

                    //
                    // call specific drawing routine if output
                    // not totally clipped
                    //

                    (*pfnG)(pSurfDst,&grData);
                }
            }
        }
    }
    else
    {
        WARNING("bRectangleMesh: can't get surface palette\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* EngGradientFill
*
*   Draw gradient fill to memory surface. If complex clipping is used, then
*   draw to a temp dib and blt to destination through clip.
*
* Arguments:
*
*  psoDst   - destination surface
*  pco      - clip obj
*  pVertex  - vertex list
*  nVertex  - # in vertex list
*  pMesh    - mesh list
*  nMesh    - # in mesh list
*  ulMode   - draw mode and attributes
*
* Return Value:
*
*   Status
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
EngGradientFill(
    SURFOBJ         *psoDst,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *ptlDitherOrg,
    ULONG            ulMode
    )
{
    ASSERTGDI(psoDst != NULL, "ERROR EngGradientFill: No destination surface\n");

    BOOL     bStatus     = TRUE;
    PSURFACE pSurfDst    = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfDstTmp = NULL;
    ULONG    ulTri;
    BOOL     bForceDstAlloc = FALSE;
    BOOL     bAllocDstSurf = FALSE;
    RECTL    rclDstTrim;
    RECTL    rclDstWk;
    CLIPOBJ *pcoDstWk = pco;
    SURFMEM  surfTmpDst;
    ULONG    ulIndex;
    PDEVOBJ pdo(pSurfDst->hdev());
    BOOL     bCopyFromDst = TRUE;

    ASSERTGDI(pdo.bValid(), "Invalid HDEV");
    ASSERTGDI((ulMode == GRADIENT_FILL_TRIANGLE) ||
              (ulMode == GRADIENT_FILL_RECT_H)   ||
              (ulMode == GRADIENT_FILL_RECT_V),
        "Invalid gradient mode");

    //
    // sync with driver
    //

    {
        pdo.vSync(psoDst,NULL,0);
    }

    //
    // trim rclDst to clip bounding box
    //

    rclDstTrim = *prclExtents;

    //
    // clip extents to destination clip rect
    //

    if ((pco != NULL) && (pco->iDComplexity > DC_TRIVIAL))
    {
        if (rclDstTrim.left < pco->rclBounds.left)
        {
            rclDstTrim.left = pco->rclBounds.left;
        }

        if (rclDstTrim.right > pco->rclBounds.right)
        {
            rclDstTrim.right = pco->rclBounds.right;
        }

        if (rclDstTrim.top < pco->rclBounds.top)
        {
            rclDstTrim.top = pco->rclBounds.top;
        }

        if (rclDstTrim.bottom > pco->rclBounds.bottom)
        {
            rclDstTrim.bottom = pco->rclBounds.bottom;
        }
    }

    //
    // rclDstWk specifies size of temp surface needed (if temp surface is created)
    // coordinates in this temp surface are referenced to prclExtents, even though the
    // surface may be clipped to a smaller extent
    //

    rclDstWk = rclDstTrim;

    //
    // Force Complex clipping to go through temp surface
    //

    if ((pco != NULL) &&
        (pco->iDComplexity != DC_TRIVIAL) &&
        (pco->iDComplexity != DC_RECT))
    {
        bForceDstAlloc = TRUE;
    }

    //
    // get a dst surface that can be written to, remember since it will have to
    // be written back.
    //

    //
    // If the gradient fill shape is a rectangle, we don't need
    // to copy bits from the destination since they'll all
    // be overwritten
    //

    if ((ulMode == GRADIENT_FILL_RECT_H) || 
        (ulMode == GRADIENT_FILL_RECT_V))
    {
        bCopyFromDst = FALSE;
    }
 
    pSurfDstTmp = psSetupDstSurface(
                       pSurfDst,
                       &rclDstWk,
                       surfTmpDst,
                       bForceDstAlloc,
                       bCopyFromDst);


    if (pSurfDstTmp != NULL)
    {
        if (pSurfDstTmp != pSurfDst)
        {
            bAllocDstSurf = TRUE;
        }

        if (bAllocDstSurf)
        {
            //
            // drawing lies completely in temp rectangle, src surface is read
            // into tmp DIB before drawing, so no clipping is needed when this
            // is copied to destination surface
            //

            pcoDstWk = NULL;

            //
            // subtract rect origin
            //

            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                pVertex[ulIndex].x -= rclDstTrim.left;
                pVertex[ulIndex].y -= rclDstTrim.top;
            }

            //
            // adjust dither org
            //

            ptlDitherOrg->x += rclDstTrim.left;
            ptlDitherOrg->y += rclDstTrim.top;
        }

        //
        // limit recorded triangle to clipped output
        //

        ERECTL *prclClip;
        LONG   dyTri = rclDstWk.bottom - rclDstWk.top;

        if ((pcoDstWk == NULL) || (pcoDstWk->iDComplexity == DC_TRIVIAL))
        {
            prclClip = NULL;
        }
        else
        {
            prclClip = (ERECTL *)&pcoDstWk->rclBounds;
        }

    //
    // draw gradients   
    //

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
       bStatus = bTriangleMesh(pSurfDstTmp,
                   pxlo,
                   pVertex,
                   nVertex,
                   (PGRADIENT_TRIANGLE)pMesh,
                   nMesh,
                   ulMode,
                   &rclDstWk,
                   prclExtents,
                   ptlDitherOrg
                   );
        }
    else 
    {
       ASSERTGDI((ulMode == GRADIENT_FILL_RECT_H) ||
             (ulMode == GRADIENT_FILL_RECT_V),
                     "Unhandle 'ulMode'");

           bStatus = bRectangleMesh(
                   pSurfDstTmp,
                   pxlo,
                   pVertex,
                   nVertex,
                   (PGRADIENT_RECT)pMesh,
                   nMesh,
                   ulMode,
                   &rclDstWk,
                   ptlDitherOrg
                   );

    }

        //
        // write temp destination surface to real dst
        //

        if (bAllocDstSurf)
        {
            PDEVOBJ pdoDst(pSurfDst->hdev());

            ASSERTGDI(pdoDst.bValid(), "Invalid HDEV");

            POINTL ptlCopy = {0,0};

            (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                      pSurfDst->pSurfobj(),
                      pSurfDstTmp->pSurfobj(),
                      pco,
                      &xloIdent,
                      &rclDstTrim,
                      &ptlCopy);

            //
            // undo temporary offseting
            //

            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                pVertex[ulIndex].x += rclDstTrim.left;
                pVertex[ulIndex].y += rclDstTrim.top;
            }

            ptlDitherOrg->x -= rclDstTrim.left;
            ptlDitherOrg->y -= rclDstTrim.top;
        }
    }
    else
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bStatus = FALSE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* vCalcMeshExtent
*
*   Verify mesh, calculate bounding rect of drawing.
*
* Arguments:
*
*  pVertex - vertex array
*  nVertex - number of vertex in array
*  pMesh   - array of rect or tri
*  nMesh   - number in mesh array
*  ulMode  - triangle or rectangle
*  prclExt - return extent rect
*
* Return Value:
*
*  TRUE if mesh is valid
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcMeshExtent(
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode,
    RECTL       *prclExt
    )
{
    LONG xmin = LONG_MAX;
    LONG xmax = LONG_MIN;
    LONG ymin = LONG_MAX;
    LONG ymax = LONG_MIN;

    BOOL bRet = TRUE;

    ULONG ulIndex;

    //
    // triangle or rectangle case
    //

    if (
         (ulMode ==GRADIENT_FILL_RECT_H) ||
         (ulMode == GRADIENT_FILL_RECT_V)
       )
    {
        //
        // verify rectangle mesh, remember extents
        //

        PGRADIENT_RECT pGradRect = (PGRADIENT_RECT)pMesh;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            RECTL rcl;

            ULONG vul = pGradRect->UpperLeft;
            ULONG vlr = pGradRect->LowerRight;

            if ((vul <= nVertex) && (vlr <= nVertex))
            {
                LONG VertLeftX  = pVertex[vul].x;
                LONG VertLeftY  = pVertex[vul].y;
                LONG VertRightX = pVertex[vlr].x;
                LONG VertRightY = pVertex[vlr].y;

                if (VertLeftX < xmin)
                {
                    xmin = VertLeftX;
                }

                if (VertLeftX > xmax)
                {
                    xmax = VertLeftX;
                }

                if (VertLeftY < ymin)
                {
                    ymin = VertLeftY;
                }

                if (VertLeftY > ymax)
                {
                    ymax = VertLeftY;
                }

                if (VertRightX < xmin)
                {
                    xmin = VertRightX;
                }

                if (VertRightX > xmax)
                {
                    xmax = VertRightX;
                }

                if (VertRightY < ymin)
                {
                    ymin = VertRightY;
                }

                if (VertRightY > ymax)
                {
                    ymax = VertRightY;
                }
            }
            else
            {
                //
                // error in mesh/vertex array, return null
                // bounding rect
                //

                prclExt->left   = 0;
                prclExt->right  = 0;
                prclExt->top    = 0;
                prclExt->bottom = 0;

                return(FALSE);
            }

            pGradRect++;
        }
    }
    else if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        //
        // verify triangle mesh, remember extents
        //

        PGRADIENT_TRIANGLE pGradTri = (PGRADIENT_TRIANGLE)pMesh;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            LONG lVertex[3];
            LONG vIndex;

            lVertex[0] = pGradTri->Vertex1;
            lVertex[1] = pGradTri->Vertex2;
            lVertex[2] = pGradTri->Vertex3;

            for (vIndex=0;vIndex<3;vIndex++)
            {
                ULONG TriVertex = lVertex[vIndex];

                if (TriVertex < nVertex)
                {
                    LONG VertX  = pVertex[TriVertex].x;
                    LONG VertY  = pVertex[TriVertex].y;

                    if (VertX < xmin)
                    {
                        xmin = VertX;
                    }

                    if (VertX > xmax)
                    {
                        xmax = VertX;
                    }

                    if (VertY < ymin)
                    {
                        ymin = VertY;
                    }

                    if (VertY > ymax)
                    {
                        ymax = VertY;
                    }
                }
                else
                {
                    //
                    // error in mesh/vertex array, return null
                    // bounding rect
                    //

                    prclExt->left   = 0;
                    prclExt->right  = 0;
                    prclExt->top    = 0;
                    prclExt->bottom = 0;

                    return(FALSE);
                }
            }

            pGradTri++;
        }
    }
    else
    {
        bRet = FALSE;
    }

    //
    // are any parameter out of coordinate space bounds 2^28
    //

    LONG lIntMax = 0x08000000;
    LONG lIntMin = -lIntMax;

    if (
            (xmin < lIntMin) || (xmin > lIntMax) ||
            (xmax < lIntMin) || (xmax > lIntMax) ||
            (ymin < lIntMin) || (ymin > lIntMax) ||
            (ymax < lIntMin) || (ymax > lIntMax)
       )
    {
        prclExt->left   = 0;
        prclExt->right  = 0;
        prclExt->top    = 0;
        prclExt->bottom = 0;

        return(FALSE);
    }

    prclExt->left   = xmin;
    prclExt->right  = xmax;
    prclExt->top    = ymin;
    prclExt->bottom = ymax;

    return(bRet);
}

/******************************Public*Routine******************************\
*   GreGradientFill
*
* Arguments:
*
*   hdc          - dc
*   pLocalVertex - Position and color
*   nVertex      - number of vertex
*   pLocalMesh   - each three USHORTs define 1 triangle
*   nMesh        - Number of triangles
*   ulMode       - drawing mode (rect/tri) and options
*
* Return Value:
*
*   Status
*
* History:
*
*    23-Jun-1997 Added rotation support for rectangles -by- Ori Gershony [orig]
*
*    16-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GreGradientFill(
    HDC        hdc,
    PTRIVERTEX pLocalVertex,
    ULONG      nVertex,
    PVOID      pLocalMesh,
    ULONG      nMesh,
    ULONG      ulMode
    )
{
    GDITraceHandle(GreGradientFill, "(%X, %p, %u, %p, %u, %u)\n", (va_list)&hdc,
                   hdc);

    BOOL  bStatus = FALSE;
    PTRIVERTEX pLocalVertexTmp=NULL;
    PVOID pLocalMeshTmp=NULL;

    //
    // limit ulMode (direct from user)
    //

    ulMode &= GRADIENT_FILL_OP_FLAG;

    //
    // validate DST DC
    //

    DCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // lock device
        //

        DEVLOCKBLTOBJ dlo;

        if (dlo.bLock(dcoDst))
        {
            EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

            //
            // Break each rotated rectangle into two triangles.  This will double 
            // the number of vertices used (4 per two triangles).
            //
            
            if (xoDst.bRotation() && 
                ((ulMode == GRADIENT_FILL_RECT_H) || (ulMode == GRADIENT_FILL_RECT_V)))
            {
                //
                // Allocate two triangles for each rectangle 
                //
                ULONG ulSizeM = nMesh   * 2 * sizeof(GRADIENT_TRIANGLE);
                ULONG ulSizeV = nVertex * 2 * sizeof(TRIVERTEX);

                //
                // Let's make sure nMesh and nVertex are not so high as to cause overflow--this
                // can cause us to allocate too small a buffer and then commit an access 
                // violation.  Also make sure we have enough memory.
                //
                if ((nVertex > MAXULONG/2) ||
                    (nMesh > MAXULONG/2) ||
                    ((nVertex * 2) > (MAXIMUM_POOL_ALLOC / sizeof(TRIVERTEX))) ||
                    ((nMesh * 2)   > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_TRIANGLE)))))
                {
                    WARNING("GreGradientFill: can't allocate input buffer\n");
                    EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }
        
                //
                // Allocate memory and assign to the pointers
                //
                pLocalVertexTmp = (PTRIVERTEX)PALLOCNOZ(ulSizeV + ulSizeM,'pmtG');
                if (!pLocalVertexTmp)
                {
                    EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                pLocalMeshTmp = (PVOID)((PBYTE)pLocalVertexTmp + ulSizeV);
            
                //
                // First copy the old Vertices
                //
                ULONG vertexNum;
                for (vertexNum=0; vertexNum < nVertex; vertexNum++)
                {
                    ((PTRIVERTEX)pLocalVertexTmp)[vertexNum] = ((PTRIVERTEX) pLocalVertex)[vertexNum];
                }

                //
                // Now walk the rectangle list and generate triangles/vertices as needed:
                //
                //    v1              vertexNum 
                //    *------------------*
                //    |                  |
                //    |                  |
                //    *------------------*
                // vertexNum+1          v2
                //
                
                for (ULONG rectNum=0; rectNum < nMesh; rectNum++)
                {
                    ULONG v1,v2;
                    v1 = ((PGRADIENT_RECT)pLocalMesh)[rectNum].UpperLeft;
                    v2 = ((PGRADIENT_RECT)pLocalMesh)[rectNum].LowerRight;

                    if ((v1 >= nVertex) || (v2 >= nVertex))
                    {
                        WARNING("GreGradientFill: vertex is out of range\n");
                        EngSetLastError(ERROR_INVALID_PARAMETER);
                        VFREEMEM(pLocalVertexTmp);
                        return(FALSE);            
                    }                    

                    pLocalVertexTmp[vertexNum].x   = pLocalVertex[v2].x;
                    pLocalVertexTmp[vertexNum].y   = pLocalVertex[v1].y;

                    pLocalVertexTmp[vertexNum+1].x = pLocalVertex[v1].x;
                    pLocalVertexTmp[vertexNum+1].y = pLocalVertex[v2].y;

                    if (ulMode == GRADIENT_FILL_RECT_V)
                    {
                        //
                        // vertexNum has same color as v1, vertexNum+1 has same color as v2
                        //
                
                        pLocalVertexTmp[vertexNum].Red     = pLocalVertex[v1].Red;
                        pLocalVertexTmp[vertexNum].Green   = pLocalVertex[v1].Green;
                        pLocalVertexTmp[vertexNum].Blue    = pLocalVertex[v1].Blue;
                        pLocalVertexTmp[vertexNum].Alpha   = pLocalVertex[v1].Alpha;

                        pLocalVertexTmp[vertexNum+1].Red   = pLocalVertex[v2].Red;
                        pLocalVertexTmp[vertexNum+1].Green = pLocalVertex[v2].Green;
                        pLocalVertexTmp[vertexNum+1].Blue  = pLocalVertex[v2].Blue;
                        pLocalVertexTmp[vertexNum+1].Alpha = pLocalVertex[v2].Alpha;
                    }
                    else 
                    {
                        //
                        // vertexNum has same color as v2, vertexNum+1 has same color as v1
                        //
                
                        pLocalVertexTmp[vertexNum].Red     = pLocalVertex[v2].Red;
                        pLocalVertexTmp[vertexNum].Green   = pLocalVertex[v2].Green;
                        pLocalVertexTmp[vertexNum].Blue    = pLocalVertex[v2].Blue;
                        pLocalVertexTmp[vertexNum].Alpha   = pLocalVertex[v2].Alpha;

                        pLocalVertexTmp[vertexNum+1].Red   = pLocalVertex[v1].Red;
                        pLocalVertexTmp[vertexNum+1].Green = pLocalVertex[v1].Green;
                        pLocalVertexTmp[vertexNum+1].Blue  = pLocalVertex[v1].Blue;
                        pLocalVertexTmp[vertexNum+1].Alpha = pLocalVertex[v1].Alpha;
                    }
                    
                    //
                    // Now add vertices for the two triangles
                    //

                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex1   = v1;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex2   = vertexNum;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2].Vertex3   = vertexNum+1;

                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex1 = v2;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex2 = vertexNum;
                    ((PGRADIENT_TRIANGLE)pLocalMeshTmp)[rectNum*2+1].Vertex3 = vertexNum+1;
                    
                    vertexNum += 2;
                }
 
                //
                // Now modify the arguments so that this change is transparent to the rest of the code
                //
                pLocalMesh   = pLocalMeshTmp;
                pLocalVertex = pLocalVertexTmp;
                ulMode       = GRADIENT_FILL_TRIANGLE;
                nVertex      = vertexNum;
                nMesh        *= 2;
            }


            //
            // should be able to rotate triangle with no problem.  Rotated 
            // rectangles should have already been converted to triangles.
            //

            ULONG     ulIndex;
            ERECTL    erclDst(POS_INFINITY,POS_INFINITY,NEG_INFINITY,NEG_INFINITY);
    
            //
            // Translate to device space. Use integer points, not fixed point
            //
    
            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
            {
                EPOINTL eptl(pLocalVertex[ulIndex].x,pLocalVertex[ulIndex].y);
                xoDst.bXform(eptl);
                //Shift all the points one pixel to the right to include the right edge of the rect.
                if(MIRRORED_DC(dcoDst.pdc)) {
                    ++eptl.x;
                }
                pLocalVertex[ulIndex].x = eptl.x + dcoDst.eptlOrigin().x;
                pLocalVertex[ulIndex].y = eptl.y + dcoDst.eptlOrigin().y;
            }
    
            //
            // verify mesh and calc mesh extents
            //

            bStatus = bCalcMeshExtent(pLocalVertex,nVertex,pLocalMesh,nMesh,ulMode,&erclDst);

            if (bStatus)
            {
                //
                // set up clipping, check if totally excluded
                //
                
                ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);
        
                if (!(eco.erclExclude().bEmpty()))
                {
                    //
                    // Accumulate bounds.  We can do this before knowing if the operation is
                    // successful because bounds can be loose.
                    //
                    //
                    
                    if (dcoDst.fjAccum())
                    { 
                        ERECTL erclBound = erclDst;
                        
                        //
                        // erclDst is adjusted from DC origin,
                        // so that it should be substracted.
                        //
                        erclBound -= dcoDst.eptlOrigin();
                        
                        dcoDst.vAccumulate(erclBound);
                    }

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        PDEVOBJ pdo(pSurfDst->hdev());
                        DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,&eco);
            EXLATEOBJ xlo;
                        XLATEOBJ *pxlo;

            //
                        // Inc the target surface uniqueness
                        //

            INC_SURF_UNIQ(pSurfDst);
                        
            if ((pdo.bPrinter()) || (pSurfDst->iFormat() <= BMF_8BPP)) {
                            // 
                            // 16bpp or greater does not require a translation object. 
                            //
                            // color translate is from RGB (PAL_BGR) 32 to device
                            //
        
                            XEPALOBJ   palDst(pSurfDst->ppal());
                            XEPALOBJ   palDstDC(dcoDst.ppal());
                            XEPALOBJ   palSrc(gppalRGB);
        
                            bStatus = xlo.bInitXlateObj(
                                dcoDst.pdc->hcmXform(),
                                dcoDst.pdc->GetICMMode(),
                                palSrc,
                                palDst,
                                palDstDC,
                                palDstDC,
                                dcoDst.pdc->crTextClr(),
                                dcoDst.pdc->crBackClr(),
                                0
                                );
                        
                pxlo = xlo.pxlo();
    
            }
                        else
                        {
                            pxlo = NULL;
                        }

                        //
                        // must have window offset for dither org
                        //
    
                        POINTL ptlDitherOrg = dcoDst.pdc->eptlOrigin();
    
                        ptlDitherOrg.x = -ptlDitherOrg.x;
                        ptlDitherOrg.y = -ptlDitherOrg.y;

                        //
                        // call driver/engine drawing
                        //

                        PFN_DrvGradientFill pfnGradientFill;
            if (pSurfDst->iFormat() == BMF_8BPP) 
            {
                // Drivers can't really support GradientFill at
                // 8BPP.  Instead of calling them and running
                // the risk of having them mess up, let's call
                // the engine instead.

                pfnGradientFill = EngGradientFill;
            }
            else
            {
                pfnGradientFill = 
                PPFNGET(pdo,GradientFill, pSurfDst->flags());
            }

                        bStatus  = (*pfnGradientFill)(
                            pSurfDst->pSurfobj(),
                            &eco,
                            pxlo,
                            pLocalVertex,
                            nVertex,
                            pLocalMesh,
                            nMesh,
                            &erclDst,
                            &ptlDitherOrg,
                            ulMode
                            );

                    }
                    else
                    {
                        bStatus = TRUE;
                    }
                }
                else
                {
                    bStatus = TRUE;
                }
            }
            else
            {
                WARNING1("GreGradientFill: Invalid mesh or vertex\n");
            }
        }
        else
        {
            bStatus = dcoDst.bFullScreen();
        }
    }
    else
    {
        bStatus = FALSE;
    }

    //
    // If allocated memory to convert rectangles to triangles, free it before
    // leaving this function.
    //
    if (pLocalVertexTmp)
    {
        VFREEMEM(pLocalVertexTmp);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* NtGdiTriangleMesh
*
*   Kernel mode stub for GradientFill
*
* Arguments:
*
*   hdc          - dc
*   pLocalVertex - Position and color
*   nVertex      - number of vertex
*   pLocalMesh   - triangle or rectangle mesh
*   nMesh        - Number of triangles
*   ulMode       - drawing mode (rect/tri) and options
*
* Return Value:
*
*   Status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
NtGdiGradientFill(
    HDC        hdc,
    PTRIVERTEX pVertex,
    ULONG      nVertex,
    PVOID      pMesh,
    ULONG      nMesh,
    ULONG      ulMode
    )
{
    PTRIVERTEX  pLocalVertex;
    PVOID       pLocalMesh;

    //
    // make sure ulMode is not being mis-used
    //

    if ((ulMode & ~GRADIENT_FILL_OP_FLAG)  != 0)
    {
        WARNING("NtGdiGradientFill: illegal parameter\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ulMode &= GRADIENT_FILL_OP_FLAG;

    //
    // validate parameters, make sure one of the mode
    // flags is set, but no invalid mode is set
    //

    if (
         (pVertex == NULL)       || (pMesh == NULL)       ||
         (nVertex == 0)          || (nMesh == 0)          ||
         (nVertex >= 0x80000000) || (nMesh >= 0x80000000) ||
         (
            (ulMode != GRADIENT_FILL_RECT_H) &&
            (ulMode != GRADIENT_FILL_RECT_V) &&
            (ulMode != GRADIENT_FILL_TRIANGLE)
         )
       )
    {
        WARNING("NtGdiGradientFill: illegal parameter\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // attempt to allocate a buffer to copy entire vertex and mesh array
    //

    if (nVertex > (MAXIMUM_POOL_ALLOC / sizeof(TRIVERTEX)))
    {
        WARNING("NtGdiGradientFill: nVertex is too large\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    ULONG       ulSizeV = nVertex * sizeof(TRIVERTEX);
    ULONG       ulSizeM;
    BOOL        bRet = TRUE;

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        if (nMesh > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_TRIANGLE))))
        {
            WARNING("NtGdiGradientFill: nMesh is too large\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);            
        }
        ulSizeM = nMesh * sizeof(GRADIENT_TRIANGLE);
    }
    else
    {
        if (nMesh > ((MAXIMUM_POOL_ALLOC - ulSizeV) / (sizeof(GRADIENT_RECT))))
        {
            WARNING("NtGdiGradientFill: nMesh is too large\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);            
        }
        ulSizeM = nMesh * sizeof(GRADIENT_RECT);
    }

    //
    //  alloc memory for data buffers
    //

    if ((ulSizeM + ulSizeV) >= MAXIMUM_POOL_ALLOC)
    {
        WARNING("NtGdiGradientFill: can't allocate input buffer\n");
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    pLocalVertex = (PTRIVERTEX)PALLOCNOZ(ulSizeV + ulSizeM,'pmtG');

    if (pLocalVertex)
    {
        pLocalMesh = (PVOID)((PBYTE)pLocalVertex + ulSizeV);

        //
        // probe then copy buffers
        //

        __try
        {
            ProbeForRead(pVertex,ulSizeV,sizeof(BYTE));
            RtlCopyMemory(pLocalVertex,pVertex,ulSizeV);

            ProbeForRead(pMesh,ulSizeM,sizeof(BYTE));
            RtlCopyMemory(pLocalMesh,pMesh,ulSizeM);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(2);
            bRet = FALSE;
        }

        if (bRet)
        {
            bRet = GreGradientFill(
                    hdc,
                    pLocalVertex,
                    nVertex,
                    pLocalMesh,
                    nMesh,
                    ulMode
                    );
        }

        VFREEMEM(pLocalVertex);
    }
    else
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\trig.cxx ===
/******************************Module*Header*******************************\
* Module Name: trig.cxx
*
* trigonometric functions
* adjusted andrew code so that it works with wendy's ELOATS
*
* Created: 05-Mar-1991 09:55:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
\**************************************************************************/

#include "precomp.hxx"


/******************************Public*Data******************************\
* It's Hack-o-rama time.  The new 'C' compiler that runs on NT does
* not have support for floating point constants.  All floating point
* constants must be defined in HEX values.  In this file we have a
* variable for each of the HEX constants used in the engine.  flhack.hxx
* has some #defines for casting these into floating point values.
* The end result is a floating point constant like 3.0f get changed
* to FP_3_0.
*
* To add a new floating point constant do the following:
*
*       1) check if already in the list.  If so, no need to add
*          it again.
*       2) Create a definition for it below.  Figuring the exact
*          HEX constant is a little tricky.  See kentd for help.
*       3) Edit flhack.hxx, adding the proper defines.
*       4) Include flhack.hxx in the file with the constant.
*       5) Replace the constant X.Xf with FPX_X.
*
* the proper floating point support.
*
* History:
*  22-Jul-1991 -by- J. Andrew Goossen [andrewgo]
* Nuked all FLOATs.  Will eventually generate this file at compile time.
*
*  01-May-1991 -by- Kent Diamond [kentd]
* Wrote it.
\**************************************************************************/

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)

    //
    // IEEE floats:
    //

extern "C" {
    ULONG gaefArctan[] =
    {
        0x0, 0x3fe51bca, 0x4064e2aa, 0x40ab62eb,
        0x40e40022, 0x410e172e, 0x4129ea1c, 0x41456ce7,
        0x41609474, 0x417b5695, 0x418ad50b, 0x4197c365,
        0x41a472c8, 0x41b0e026, 0x41bd08f7, 0x41c8eb2f,
        0x41d4853a, 0x41dfd5f7, 0x41eadcae, 0x41f59908,
        0x42000583, 0x4205197c, 0x420a08ba, 0x420ed3a7,
        0x42137ac6, 0x4217feb4, 0x421c601d, 0x42209fbe,
        0x4224be63, 0x4228bcdf, 0x422c9c0c, 0x42305ccb,
        0x42340000, 0x0
    };

    ULONG gaefSin[] =
    {
        0x0, 0x3d48fb30, 0x3dc8bd36, 0x3e164083,
        0x3e47c5c2, 0x3e78cfcc, 0x3e94a031, 0x3eac7cd4,
        0x3ec3ef15, 0x3edae880, 0x3ef15aea, 0x3f039c3d,
        0x3f0e39da, 0x3f187fc0, 0x3f226799, 0x3f2beb4a,
        0x3f3504f3, 0x3f3daef9, 0x3f45e403, 0x3f4d9f02,
        0x3f54db31, 0x3f5b941a, 0x3f61c598, 0x3f676bd8,
        0x3f6c835e, 0x3f710908, 0x3f74fa0b, 0x3f7853f8,
        0x3f7b14be, 0x3f7d3aac, 0x3f7ec46d, 0x3f7fb10f,
        0x3f800000
    };

    ULONG gaefAxisCoord[] =
    {
        0x0, 0x3f800000, 0x0, 0xbf800000
    };

    ULONG gaefAxisAngle[] =
    {
        0x0, 0x42b40000, 0x43340000, 0x43870000,
        0x43b40000
    };

    ULONG FP_0_0     = 0x0;
    ULONG FP_0_005   = 0x3ba3d70a;
    ULONG FP_0_5     = 0x3f000000;
    ULONG FP_1_0     = 0x3f800000;
    ULONG FP_2_0     = 0x40000000;
    ULONG FP_3_0     = 0x40400000;
    ULONG FP_4_0     = 0x40800000;
    ULONG FP_90_0    = 0x42b40000;
    ULONG FP_180_0   = 0x43340000;
    ULONG FP_270_0   = 0x43870000;
    ULONG FP_360_0   = 0x43b40000;
    ULONG FP_1000_0  = 0x447a0000;
    ULONG FP_3600_0  = 0x45610000;
    ULONG FP_M3600_0 = 0xc5610000;

    ULONG FP_QUADRANT_TAU = 0x3ee53aef;  // 0.44772...
    ULONG FP_ORIGIN_TAU   = 0x3f0d6289;  // 0.552...
    ULONG FP_SINE_FACTOR  = 0x3eb60b61;  // SINE_TABLE_SIZE / 90.0
    ULONG FP_4DIV3        = 0x3faaaaab;
    ULONG FP_1DIV90       = 0x3c360b61;
    ULONG FP_EPSILON      = 0x37800000;
    ULONG FP_ARCTAN_TABLE_SIZE = 0x42000000;
    ULONG FP_PI           = 0x40490fda;  // 3.1415926...
};

#else

    //
    // Internal EFloats:
    //

extern "C" {
    EFLOAT_S gaefArctan[] =
    {
        {0x0, 0}, {0x728de539, 2}, {0x727154c9, 3},
        {0x55b17599, 4}, {0x72001124, 4}, {0x470b9706, 5},
        {0x54f50dd3, 5}, {0x62b67364, 5}, {0x704a3a03, 5},
        {0x7dab4a4f, 5}, {0x456a856f, 6}, {0x4be1b295, 6},
        {0x523963eb, 6}, {0x5870133a, 6}, {0x5e847b98, 6},
        {0x64759746, 6}, {0x6a429cc6, 6}, {0x6feafb55, 6},
        {0x756e56f1, 6}, {0x7acc8411, 6}, {0x4002c196, 7},
        {0x428cbe1e, 7}, {0x45045d20, 7}, {0x4769d374, 7},
        {0x49bd6339, 7}, {0x4bff59db, 7}, {0x4e300e45, 7},
        {0x504fdf2e, 7}, {0x525f3195, 7}, {0x545e6f5a, 7},
        {0x564e0606, 7}, {0x582e65af, 7}, {0x5a000000, 7},
        {0x0, 0}
    };

    EFLOAT_S gaefSin[] =
    {
        {0x0, 0}, {0x647d97c4, -3}, {0x645e9af0, -2},
        {0x4b2041ba, -1}, {0x63e2e0f1, -1}, {0x7c67e5ec, -1},
        {0x4a5018bb, 0}, {0x563e69d6, 0}, {0x61f78a9a, 0},
        {0x6d744027, 0}, {0x78ad74e0, 0}, {0x41ce1e64, 1},
        {0x471cece6, 1}, {0x4c3fdff3, 1}, {0x5133cc94, 1},
        {0x55f5a4d2, 1}, {0x5a827999, 1}, {0x5ed77c89, 1},
        {0x62f201ac, 1}, {0x66cf811f, 1}, {0x6a6d98a4, 1},
        {0x6dca0d14, 1}, {0x70e2cbc6, 1}, {0x73b5ebd0, 1},
        {0x7641af3c, 1}, {0x78848413, 1}, {0x7a7d055b, 1},
        {0x7c29fbee, 1}, {0x7d8a5f3f, 1}, {0x7e9d55fc, 1},
        {0x7f62368f, 1}, {0x7fd8878d, 1}, {0x40000000, 2}
    };

    EFLOAT_S gaefAxisCoord[] =
    {
        {0x0, 0}, {0x40000000, 2}, {0x0, 0},
        {0xc0000000, 2}
    };

    EFLOAT_S gaefAxisAngle[] =
    {
        {0x0, 0}, {0x5a000000, 8}, {0x5a000000, 9},
        {0x43800000, 10}, {0x5a000000, 10}
    };

    EFLOAT_S FP_0_0     = {0x0, 0};
    EFLOAT_S FP_0_005   = {0x51eb851e, -6};
    EFLOAT_S FP_0_5     = {0x40000000, 1};
    EFLOAT_S FP_1_0     = {0x40000000, 2};
    EFLOAT_S FP_2_0     = {0x40000000, 3};
    EFLOAT_S FP_3_0     = {0x60000000, 3};
    EFLOAT_S FP_4_0     = {0x40000000, 4};
    EFLOAT_S FP_90_0    = {0x5a000000, 8};
    EFLOAT_S FP_180_0   = {0x5a000000, 9};
    EFLOAT_S FP_270_0   = {0x43800000, 10};
    EFLOAT_S FP_360_0   = {0x5a000000, 10};
    EFLOAT_S FP_1000_0  = {0x7d000000, 11};
    EFLOAT_S FP_3600_0  = {0x70800000, 13};
    EFLOAT_S FP_M3600_0 = {0x8f800000, 13};

    EFLOAT_S FP_QUADRANT_TAU = {0x729d7775, 0};  // 0.44772...
    EFLOAT_S FP_ORIGIN_TAU   = {0x46b14445, 1};  // 0.552...
    EFLOAT_S FP_SINE_FACTOR  = {0x5b05b05b, 0};  // SINE_TABLE_SIZE / 90.0
    EFLOAT_S FP_4DIV3        = {0x55555555, 2};
    EFLOAT_S FP_1DIV90       = {0x5b05b05b, -5};
    EFLOAT_S FP_EPSILON      = {0x40000000, -14};
    EFLOAT_S FP_ARCTAN_TABLE_SIZE = {0x40000000, 7};
    EFLOAT_S FP_PI           = {0x6487ed51, 3};  // 3.1415926...
};

#endif


/******************************Public*Routine******************************\
* EFLOAT functions                                                         *
*                                                                          *
* Wrote it.                                                                *
\**************************************************************************/

EFLOAT EFLOAT::eqCross(const POINTFL& ptflA, const POINTFL& ptflB)
{
    EFLOAT efTmp;

    efTmp.eqMul(ptflA.y,ptflB.x);
    eqMul(ptflA.x,ptflB.y);
    return(eqSub(*this,efTmp));
}

EFLOAT EFLOAT::eqDot(const POINTFL& ptflA, const POINTFL& ptflB)
{
    EFLOAT efTmp;

    efTmp.eqMul(ptflA.x,ptflB.x);
    eqMul(ptflA.y,ptflB.y);
    return(eqAdd(*this,efTmp));
}

EFLOAT EFLOAT::eqLength(const POINTFL& ptflA)
{
    return(eqSqrt(eqDot(ptflA,ptflA)));
}

/******************************Public*Routine******************************\
* lNormAngle (lAngle)                                                      *
*                                                                          *
* Given an angle in tenths of a degree, returns an equivalent positive     *
* angle of less than 360.0 degrees.                                        *
*                                                                          *
*  Sat 21-Mar-1992 12:27:18 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG lNormAngle(LONG lAngle)
{
    if (lAngle >= 3600)
	return(lAngle % 3600);

    if (lAngle < 0)
	return(3599 - ((-lAngle-1) % 3600));
    else
	return(lAngle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ugdiport.h ===
/******************************Module*Header*******************************\
* Module Name: ugdiport.h
*
* Macros to ease UGDI porting
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#if defined(_GDIPLUS_)

#define DEREFERENCE_FONTVIEW_SECTION DeleteMemoryMappedSection

#define ZwCreateKey     NtCreateKey
#define ZwQueryKey      NtQueryKey
#define ZwQueryValueKey NtQueryValueKey
#define ZwSetValueKey   NtSetValueKey
#define ZwCloseKey      NtClose

#else // !_GDIPLUS_

#define DEREFERENCE_FONTVIEW_SECTION Win32DestroySection
#define ZwCloseKey  ZwClose

#endif  // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ttgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: ttgdi.cxx
*
* These are TrueType specific calls introduced into GDI by Win 3.1.  They
* all assume the existence of the TrueType font driver (or rasterizer
* as it is known in Win 3.1).
*
* Created: 11-Feb-1992 15:03:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*
;********************************Public*Routine********************************
;This function is used to create a font directory for a given engine font file
;in it's native format.  This font directory can be used to create .FON like
;DLLs.
;Returns:   DX:AX   # of bytes copied into lpFontDir buffer or -1L in case of
;                   some error.
;
; GDI uses the Serif Style value in the Panose record of the OS/2 table to
; drive the Font Family for Windows. This is based on a simple table look
; up and the current mapping is as follows:
;
; Serif Style                              Font Family
; ----------------------------------------------------------------
; 0 (Any)                                    FF_DONTCARE
; 1 (No Fit)                                 FF_DONTCARE
; 2 (Cove)                                   FF_ROMAN
; 3 (Obtuse Cove)                            FF_ROMAN
; 4 (Square Cove)                            FF_ROMAN
; 5 (Obtuse Square Cove)                     FF_ROMAN
; 6 (Square)                                 FF_ROMAN
; 7 (Thin)                                   FF_ROMAN
; 8 (Bone)                                   FF_ROMAN
; 9 (Exaggerated)                            FF_ROMAN
;10 (Triangle)                               FF_ROMAN
;11 (Normal Sans)                            FF_SWISS
;12 (Obtuse Sans)                            FF_SWISS
;13 (Perp Sans)                              FF_SWISS
;14 (Flared)                                 FF_SWISS
;15 (Rounded)                                FF_SWISS
;
;******************************************************************************
*/

// Generic FFH header information.

#define HEADERSTUFFLEN1     (5 * sizeof(USHORT))
#define COPYRIGHTLEN        60
#define MOREHEADERSTUFFLEN  (2 * sizeof(USHORT))
#define HEADERSTUFFLEN      (HEADERSTUFFLEN1 + COPYRIGHTLEN)

static USHORT ausHeaderStuff[5] = {
            1, 0, 0x0200, ((SIZEFFH)+4+LF_FACESIZE), 0
            };

static USHORT ausMoreHeaderStuff[2] = {
            WIN_VERSION, GDI_VERSION
            };


#define MAXPMWEIGHT 9

#define WOW_EMBEDING 2

/**************************************************************************\
 * NtGdiMakeFontDir
 *
 * Code is over here!
\**************************************************************************/

ULONG GreMakeFontDir(
    FLONG    flEmbed,            // mark file as "hidden"
    PBYTE    pjFontDir,          // pointer to structure to fill
    PWSZ     pwszPathname        // path of font file to use
    )
{
    ULONG  cjNames;         // localW   nNamesLength
    HFF    hff;             // localD   lhFontFile
    PIFIMETRICS pifi;       // localV   pIfiMetrics, %(size IFIMETRICS)
    ULONG_PTR  idifi;
    ULONG  cjIFI;

// If TrueType disabled, then fail.

    // Not needed since our TrueType driver is part of the engine DLL and
    // should never be disabled.  At least, not yet...

    if (gppdevTrueType == NULL)
    {
        return ( 0);
    }


// Use TrueType driver to load font file.

    PDEVOBJ pdo((HDEV)gppdevTrueType);

// Create a bogus PFF that only has the file name set.  This insures that
// the call to EngMapFontFile will suceed.

    FONTFILEVIEW fv, *pfv = &fv;

    memset( (PVOID) &fv, 0, sizeof(fv) );

    fv.pwszPath = pwszPathname;

    PVOID pvView;
    ULONG cjView;
    if (!EngMapFontFileFDInternal((ULONG_PTR)&fv, (PULONG *)&pvView, &cjView, FALSE))
    {
        WARNING("GreMakeFontDir: EngMapFontFile failed\n");
        return(FALSE);
    }

    hff = pdo.LoadFontFile(
              1
            , (ULONG_PTR *)&pfv
            , &pvView
            , &cjView
            , 0 // pdv
            , (ULONG) gusLanguageID
            , 0
            );
    if ( !hff )
    {
        KdPrint(("gdisrv!cjMakeFontDir(): failed to load TrueType file %ws\n", pwszPathname));
        return ( 0);
    }

    EngUnmapFontFileFD((ULONG_PTR)&fv);

// Grab a pointer to the IFIMETRICS as well as the size of the structure.

    if ( (pifi = pdo.QueryFont(
                    0,
                    hff,
                    1,                  // currently, only 1 .TTF per .FOT
                    &idifi)) == (PIFIMETRICS) NULL )
    {
    // Make sure to unload on error exit.

        if ( !pdo.UnloadFontFile(hff) )
        {
            WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
            return (FALSE);
        }

    // Error exit.

        WARNING("cjMakeFontDir(): IFI error in TrueType driver\n");
        return (FALSE);
    }
    cjIFI = pifi->cjThis;

// NOTE PERF: [GilmanW] 01-Nov-1992    A note to myself...
//
// Tsk-tsk!  Gilman, this is very inefficient.  You should create a stack
// object that loads the font file and ifimetrics.  Its destructor will
// automatically free the ifimetrics and unload the file.  That saves
// having to do the MALLOCOBJ and copy.

// Copy the IFIMETRICS so we can unload the font file NOW (and simplify
// error cleanup).

    MALLOCOBJ moIFI(cjIFI);

    if ( !moIFI.bValid() )
    {
    // Make sure to unload on error exit.

        if ( !pdo.UnloadFontFile(hff) )
        {
            WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
            return (0);
        }

    // Error exit.

        WARNING("cjMakeFontDir(): could not allocate buffer for IFIMETRICS\n");
        return ( 0);
    }

    RtlCopyMemory(moIFI.pv(), (PVOID) pifi, cjIFI);

// Tell the TrueType driver to free the IFIMETRICS.

    if ( PPFNVALID(pdo, Free) )
    {
        pdo.Free(pifi, idifi);
    }

    pifi = (PIFIMETRICS) moIFI.pv();

    IFIOBJ ifio(pifi);

// Tell the TrueType driver to unload the font file.

    if ( !pdo.UnloadFontFile(hff) )
    {
        WARNING("cjMakeFontDir(): IFI error--failed to unload file\n");
        return (0);
    }

// Copy header info into the font directory.

    PBYTE pjWritePointer = pjFontDir;

    RtlCopyMemory(pjWritePointer, ausHeaderStuff, HEADERSTUFFLEN1);
    pjWritePointer += HEADERSTUFFLEN1;

    //
    // Add the copyright string.
    //

    ULONG cjTmp = strlen("Windows! Windows! Windows!") + 1;
    RtlCopyMemory(pjWritePointer, "Windows! Windows! Windows!", cjTmp);

// If this is an embeded font we need to embed either a PID or TID depending on
// whether or not we were called from WOW.  If we were called from WOW then we
// expect flEmbeded to be WOW_EMBEDING.

    if( flEmbed )
    {
       ULONG pid = (flEmbed == WOW_EMBEDING) ?
            (ULONG) W32GetCurrentTID() : (ULONG) W32GetCurrentPID();

    // we are overwriting the copyright string with the PID or TID but
    // since this is an embeded font we don't care about the copyright
    // string

        //
        // Unaligned write
        //

        RtlCopyMemory( pjWritePointer,
                       &pid,
                       sizeof( ULONG ) );

    }

    RtlZeroMemory(pjWritePointer + cjTmp, COPYRIGHTLEN - cjTmp);
//    pjWritePointer += COPYRIGHTLEN;
    pjWritePointer += cjTmp;

    // Note: version stamps (Win version, Engine version) are put in the
    //       copyright field immediately after the copyright string.

    RtlCopyMemory(pjWritePointer, ausMoreHeaderStuff, MOREHEADERSTUFFLEN);

//    pjWritePointer += MOREHEADERSTUFFLEN;
    pjWritePointer += (COPYRIGHTLEN - cjTmp);

// Engine type and embedded flags.

    *pjWritePointer++ = (BYTE) ( PF_ENGINE_TYPE |
                                 ((flEmbed) ? PF_ENCAPSULATED : 0) |
                                 ((flEmbed == WOW_EMBEDING) ? PF_TID : 0));

// Selection type flag.

    *pjWritePointer++ = (BYTE) (ifio.fsSelection() & 0x00ff);

// Em square.

    WRITE_WORD(pjWritePointer, ifio.fwdUnitsPerEm());
    pjWritePointer += 2;

// Horizontal and vertical resolutions.

    WRITE_WORD(pjWritePointer, 72);
    pjWritePointer += 2;

    WRITE_WORD(pjWritePointer, 72);
    pjWritePointer += 2;

// Ascent.

    WRITE_WORD(pjWritePointer, ifio.fwdWinAscender());
    pjWritePointer += 2;

// Internal leading.

    WRITE_WORD(pjWritePointer, ifio.fwdInternalLeading());
    pjWritePointer += 2;

// External leading.

    WRITE_WORD(pjWritePointer, ifio.fwdExternalLeading());
    pjWritePointer += 2;

// Italic, strikeout, and underline flags.

    *pjWritePointer++ = ifio.bItalic() ? 0xffff : 0;
    *pjWritePointer++ = ifio.lfUnderline() ? 0xffff : 0;
    *pjWritePointer++ = ifio.lfStrikeOut() ? 0xffff : 0;

    WRITE_WORD(pjWritePointer, ifio.lfWeight());
    pjWritePointer += 2;

// Character set.

    // Old Comment:
    //  - is this right?  Maybe we should check.  At least make sure ttfd
    //    handles this so ifi.usCharSet is correct.

    *pjWritePointer++ = ifio.lfCharSet();

// Pix width (set to zero for some reason).     [Windows 3.1 compatibility]

    WRITE_WORD(pjWritePointer, 0);
    pjWritePointer += 2;

// Font height.

    WRITE_WORD(pjWritePointer, (WORD) ifio.lfHeight());
    pjWritePointer += 2;

// PitchAndFamily.

    *pjWritePointer++ = ifio.tmPitchAndFamily();

// Average character width (if zero, estimate as fwdMaxCharInc/2).

    WRITE_WORD(
        pjWritePointer,
        ifio.lfWidth() ? (WORD) ifio.lfWidth() : ifio.fwdMaxCharInc()/2
        );
    pjWritePointer += 2;

// Maximum width.

    WRITE_WORD(pjWritePointer, ifio.fwdMaxCharInc());
    pjWritePointer += 2;

// The special characters (first, last, default, break).

    *pjWritePointer++ = ifio.chFirstChar();
    *pjWritePointer++ = ifio.chLastChar();

    WRITE_WORD(pjWritePointer, DEF_BRK_CHARACTER);  // write it in one shot
    pjWritePointer += 2;

// Force WidthBytes entry to zero, no device name.

    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;
    *pjWritePointer++ = 0;

// Offset to facename.

    WRITE_DWORD(pjWritePointer, (DWORD) SIZEFFH + 4 + 1);
    pjWritePointer += 4;

// Store rasterization thresholds.

    WRITE_WORD(pjWritePointer, (WORD) ifio.fwdLowestPPEm());
    pjWritePointer += 2;

    WRITE_WORD(pjWritePointer, ifio.wCharBias());
    pjWritePointer += 2;

// Move pointer to where facenames belong.

    pjWritePointer = pjFontDir + SIZEFFH + 4 + 1;

// Write out family name.

    vToASCIIN((PSZ) pjWritePointer, LF_FACESIZE, ifio.pwszFamilyName(), wcslen(ifio.pwszFamilyName()) + 1);

// measure the ansi string again. If dbcs, it may be longer than cwcTmp

    cjNames = strlen((PSZ) pjWritePointer) + 1;
    pjWritePointer += cjNames;

// Write out face name.

    vToASCIIN((PSZ) pjWritePointer, LF_FULLFACESIZE, ifio.pwszFaceName(), wcslen(ifio.pwszFaceName()) + 1);

// measure the ansi string again. If dbcs, it may be longer than cwcTmp

    cjTmp = strlen((PSZ) pjWritePointer) + 1;
    cjNames += cjTmp;
    pjWritePointer += cjTmp;

// Write out style name.

    vToASCIIN((PSZ) pjWritePointer, LF_FACESIZE, ifio.pwszStyleName(), wcslen(ifio.pwszStyleName()) + 1);

    cjNames += (strlen((PSZ) pjWritePointer) + 1);

    return (cjNames + SIZEFFH + 4 + 1);
}

/******************************Public*Routine******************************\
* GreGetRasterizerCaps
*
* Fills the RASTERIZER_STATUS structure.
*
* Returns:
*   TRUE if successful; FALSE otherwise.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetRasterizerCaps (
    LPRASTERIZER_STATUS praststat   // pointer to a RASTERIZER_STATUS struc
    )
{
// Parameter check.

    if (praststat == (LPRASTERIZER_STATUS) NULL)
    {
        WARNING("GreGetRasterizerCaps(): bad parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Fill in size.

    praststat->nSize = sizeof(RASTERIZER_STATUS);

// Fill in TrueType driver flags.

    praststat->wFlags = (USHORT) ((gppdevTrueType != NULL) ? TT_ENABLED : 0);
    praststat->wFlags |= (gcTrueTypeFonts != 0) ? TT_AVAILABLE : 0;

// Fill in language id.

    praststat->nLanguageID = gusLanguageID;

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* ulGetFontData2
*
* Effects:
*
* History:
*  17-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



ULONG ulGetFontData2 (
    DCOBJ&       dco,
    DWORD        dwTable,
    DWORD        dwOffset,
    PVOID       pvBuffer,
    ULONG        cjData
    )
{
    ULONG  cjRet = (ULONG) -1;

// Get RFONT user object.  Need this to realize font.

    // Old Comment:
    //  - This should get changed to an LFONTOBJ (paulb)

    RFONTOBJ rfo(dco, FALSE);
    if (!rfo.bValid())
    {
        WARNING("GetFontData(): could not lock HRFONT\n");
        return (cjRet);
    }

// Get PFE user object.  Need this for iFont.

    PFEOBJ pfeo(rfo.ppfe());
    if (!pfeo.bValid())
    {
        WARNING("GetFontData(): could not lock HPFE\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get PFF user object.  Need this for HFF.

    PFFOBJ pffo(pfeo.pPFF());
    if (!pffo.bValid())
    {
        WARNING("GetFontData(): could not lock HPFF\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get FDEV user object.

    PDEVOBJ pdo(rfo.hdevProducer());

// As long as the driver LOOKS like the TrueType driver, we will allow the
// call to succeed.  Otherwise, we quit right now!
//
// In this case, TrueType means supporting the TrueType Tagged File Format.

     cjRet = pdo.QueryTrueTypeTable (
                             pffo.hff(),
                             pfeo.iFont(),
                             (ULONG) dwTable,
                             (PTRDIFF) dwOffset,
                             (ULONG) cjData,
                             (PBYTE) pvBuffer,
                             0,
                             0
                             );

    return (cjRet);
}


/******************************Public*Routine******************************\
* GreGetFontData
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG ulGetFontData (
    HDC          hdc,
    DWORD        dwTable,
    DWORD        dwOffset,
    PVOID       pvBuffer,
    ULONG        cjData
    )
{
    ULONG  cjRet = (ULONG) -1;

// Get DC user object.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("GetFontData(): bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

    return ulGetFontData2(dco, dwTable, dwOffset, pvBuffer, cjData);
}




/******************************Public*Routine******************************\
*
* vFixedToEf
*
* History:
*  Thu 17-Nov-1994 07:15:12 by Kirk Olynyk [kirko]
* Made it simpler.
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFixedToEf (
    EFLOAT  *pef,
    FIXED&  fxd
    )
{
    *pef = *(LONG*) &fxd;
    pef->vMultByPowerOf2(-16);
}


/*********************************Class************************************\
* class RESETFCOBJ
*
*   (brief description)
*
* Public Interface:
*
* History:
*  10-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define B_ONE(e)  (((e).value == 1) &&  ((e).fract == 0))
#define B_ZERO(e) (((e).value == 0) &&  ((e).fract == 0))


class RESETFCOBJ    // resetfco
{
private:

    BOOL        bValid_;
    BOOL        bTrivialXform;
    RFONTOBJ   *prfo;


public:

    RESETFCOBJ(
        DCOBJ&      dco,
        RFONTOBJ&   rfo,
        LPMAT2      lpmat2, // "extra" xform applied after the existing xform in dc
        BOOL        bIgnoreRotation,
        FLONG       flType
        );

   ~RESETFCOBJ();

    BOOL bValid() {return bValid_;};
    BOOL bTrivXform() {return bTrivialXform;};

};


/******************************Public*Routine******************************\
*
* RESETFCOBJ::RESETFCOBJ
*
*
* resets the xform in rfo.hfc() to be what it used to be times lpma2
*
*
* History:
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

RESETFCOBJ::RESETFCOBJ(
DCOBJ&      dco,
RFONTOBJ&   rfo,
LPMAT2      lpmat2,  // "extra" xform applied after the existing xform in dc
BOOL        bIgnoreRotation,
FLONG       flType
)
{
    ASSERTGDI(lpmat2 != (LPMAT2)NULL, "RESETFCOBJ:lpmat2\n");

    bValid_       = TRUE;
    prfo          = &rfo;

    bTrivialXform = (
                     B_ONE(lpmat2->eM11)  && B_ONE(lpmat2->eM22) &&
                     B_ZERO(lpmat2->eM12) && B_ZERO(lpmat2->eM21)
                    );

// If the escapement or orientation values of the LOGFONT are non-zero and
// we are in compatible mode, we will need to recompute the NtoD transform
// while ingnoring these values.  This is for the sake of Win 3.1 compatablity.

    LFONTOBJ lfo(dco.pdc->hlfntNew());

    if (!lfo.bValid())
    {
        WARNING("GreGetGlyphOutline(): bad LFONTHANDLE\n");
        bValid_ = FALSE;
        return;
    }

    if( ( lfo.plfw()->lfEscapement || lfo.plfw()->lfOrientation ) &&
        ( bIgnoreRotation ) )
    {
        bTrivialXform = FALSE;
    }

    if (!bTrivialXform)
    {
    // Create an EXFORMOBJ.  We will use this to hold the transform passed
    // in via the LPMAT2.

        MATRIX mxExtra;
        EXFORMOBJ xoExtra(&mxExtra, XFORM_FORMAT_LTOL);

    // EXFORMOBJ should not be able to fail.

        ASSERTGDI (
            xoExtra.bValid(),
            "GreGetGlyphOutline(): EXFORMOBJ failed\n"
            );

    // Stuff lpMat2 into the "extra" EXFORMOBJ.

        EFLOAT  ef11, ef12, ef21, ef22;

        vFixedToEf(&ef11, lpmat2->eM11);
        vFixedToEf(&ef22, lpmat2->eM22);
        vFixedToEf(&ef12, lpmat2->eM12);
        vFixedToEf(&ef21, lpmat2->eM21);

        {
            ef12.vNegate();
            ef21.vNegate();
            xoExtra.vSetElementsLToL(ef11, ef12, ef21, ef22);
        }

// note that the section above is different from
//        xoExtra.vSetElementsLToL(ef11, ef12, ef21, ef22);
// because of our interpretation of NtoD xform. with our conventions
// ntod xform transforms notional space defined as having y axis pointing down
// to device space also with y axis down by left vector mult.
// vD = vN * N2D. The matrix passed by the user uses different convention:
// y axis up in both spaces. so we have to use
// Sigma_3 M Sigma_3 instead of M, (Sigma_3 = diag(1,-1)) to convert
// from app convetions to our conventions [bodind]

        xoExtra.vRemoveTranslation();   // don't leave translations uninitialized

    // Need these EXFORMOBJs to calculate the new CONTEXTINFO.

        MATRIX mxN2D;
        EXFORMOBJ xoN2D(&mxN2D, XFORM_FORMAT_LTOFX);

        MATRIX mxNewN2D;
        EXFORMOBJ xoNewN2D(&mxNewN2D, XFORM_FORMAT_LTOFX);

    // EXFORMOBJs should not be able to fail.

        ASSERTGDI (
            xoN2D.bValid() && xoNewN2D.bValid(),
            "GreGetGlyphOutline(): EXFORMOBJ failed\n"
            );

        FD_XFORM fdx;

        if( bIgnoreRotation )
        {
        // If bIgnoreRotation is set it means we've been called from WOW and
        // need toingore the orientation and escapment values in the LOGFONT.
        // To do this we will need to recompute the font driver transform.
        // This behavior is neccesary for Corel Draw 5.0 to be able to print
        // rotated text properly.

            PFEOBJ  pfeo(rfo.ppfe());

            ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

            IFIOBJ  ifio(pfeo.pifi());
            POINTL ptlSim;

            ptlSim.x = ptlSim.y = 0;

            if (
                !pfeo.bSetFontXform(
                    dco, lfo.plfw(),
                    &fdx,
                    ND_IGNORE_ESC_AND_ORIENT,
                    0,
                    (POINTL* const) &ptlSim,
                    ifio,
                    FALSE
                    )
            )
            {
                WARNING("RESETFCOBJ: failed to compute font transform\n");
                bValid_ = FALSE;
                return;
            }

            xoN2D.vRemoveTranslation();

            xoN2D.vSetElementsLToFx( fdx.eXX, fdx.eXY, fdx.eYX, fdx.eYY );

            xoN2D.vComputeAccelFlags(XFORM_FORMAT_LTOFX);
        }
        else
        {
            rfo.vSetNotionalToDevice(xoN2D);
        }

    // Combine the transforms.

        if ( !xoNewN2D.bMultiply(xoN2D, xoExtra, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX) )
        {
            WARNING("GreGetGlyphOutline(): EXFORMOBJ::bMultiply failed\n");
            bValid_ = FALSE;
            return;
        }

    // Get the new transform as an FD_XFORM.

        xoNewN2D.vGetCoefficient(&fdx);

    // Attempt to get an RFONT with the new transform.

        bValid_ = rfo.bSetNewFDX(dco, fdx, flType);
    }

}


/******************************Public*Routine******************************\
*
* RESETFCOBJ::~RESETFCOBJ()
*
* resets the xform in rfo.hfc to its original value
*
* History:
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  11-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

RESETFCOBJ::~RESETFCOBJ()
{
    if (bValid_ && !bTrivialXform)
    {
    // Release the cache semaphore and make inactive.

        prfo->vReleaseCache();

        prfo->vMakeInactive();

    }
}



#define BITS_OFFSET   (offsetof(GLYPHBITS,aj))

BOOL IsSingularEudcGlyph
(
    GLYPHDATA *wpgd, BOOL bSimulatedBold
);

/******************************Public*Routine******************************\
* GreGetGlyphOutline
*
* History:
*  05-Mar-1995 Kirk Olynyk [kirko]
* Added support for GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP.
* I have introduced new modes for DrvQueryFontData that require
* that the bitmaps have scans that begin and end on DWORD
* boundaries as required by GetGlyphOutline(). This is the
* natural format of the TrueType driver.
* I also rearranged the code to have a single return point.
*  01-Nov-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG GreGetGlyphOutlineInternal (
  HDC           hdc,
  WCHAR         wch,        // WCHAR or HGLYPH???
  UINT          ulFormat,   // data format
  GLYPHMETRICS *lpgm,       // glyph metrics
  ULONG         cjBuffer,   // size of buffer
  void         *pvBuffer,   // buffer for data in the format, ulFormat
  MAT2         *lpmat2,     // "extra" xform applied after existing Notional to Device xform
  BOOL          bIgnoreRotation
  )
{
  HGLYPH hg;
  GLYPHDATA gd;
  ULONG iMode, uRet, cjRet;
  BOOL bGlyphIndex, bBufferSizeWanted, flTTO;
  BOOL bUnhinted;
  FLONG flType;

  cjRet = GDI_ERROR;                                // assume error
  bGlyphIndex = (ulFormat & GGO_GLYPH_INDEX);       // record glyph index bit
  bUnhinted   = (ulFormat & GGO_UNHINTED);          // remember if unhinted outlines are wanted
  ulFormat &= ~(GGO_GLYPH_INDEX | GGO_UNHINTED);    // and then erase it from ulFormat
  bBufferSizeWanted = (pvBuffer == 0) || (cjBuffer == 0);

  flType = bGlyphIndex ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE;

  if ( (lpgm == 0) || (lpmat2 == 0) )
  {
    WARNING("GreGetGlyphOutline(): bad parameter\n");
    SAVE_ERROR_CODE( ERROR_INVALID_PARAMETER );
  }
  else
  {
    DCOBJ dco(hdc);
    if ( !dco.bValid() )
    {
      WARNING("GreGetGlyphOutline(): bad handle for DC\n");
      SAVE_ERROR_CODE( ERROR_INVALID_HANDLE );
    }
    else
    {

        RFONTOBJ rfo(dco, FALSE);

        RFONTTMPOBJ rfoLinkSystem;
        RFONTTMPOBJ rfoLinkDefault;
        RFONTTMPOBJ rfoLinkFace;

        GLYPHDATA   *wpgdTemp;

        PRFONT      prfnt;
        PRFONT       prfntTmp;
        UINT        EudcType;
        UINT        numFaceName;
        BOOL        bEUDC = FALSE;

    // Set Basefont as default.

        RFONTOBJ *prfo = &rfo;

    // restructure this later

        if(!rfo.bValid())
        {
            goto GetGlyphOutlineData;
        }

    // Get the HGLYPH for the WCHAR.  Note we only check bGlyphIndex for the
    // original font. If this is an hglyph rfont then we wont allow linked
    // glyphs

        hg = (bGlyphIndex) ? (HGLYPH) wch : rfo.hgXlat(wch);

    // Check the target glyph is linked font or base font.

        if ((hg == rfo.hgDefault()) && !bGlyphIndex && rfo.bIsLinkedGlyph(wch))
        {
            prfnt          = rfo.prfntFont();

            GreAcquireSemaphore(prfnt->hsemEUDC);

            HGLYPH hgFound = HGLYPH_INVALID;
            HGLYPH hgLink  = HGLYPH_INVALID;

        // this value will be decremented in RFONTOBJ::dtHeler()

            INCREMENTEUDCCOUNT;
            FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,
                             "GreGetGlyphOutlineInternal():No request to change EUDC \
                              data %d\n",gcEUDCCount);
        // initialize EUDC info

            rfo.vInitEUDC(dco);

        // if we have system wide eudc, lock the cache.

            if( prfnt->prfntSysEUDC != NULL )
            {
                RFONTTMPOBJ rfoTemp( prfnt->prfntSysEUDC );
                rfoTemp.vGetCache();
            }

        // The linked RFONT is initialized for Default EUDC grab the semaphore.

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfoTemp( prfnt->prfntDefEUDC );
                rfoTemp.vGetCache();
            }

        // if we have face name eudc, lock the cache for all the linked fonts

            for( UINT ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                RFONTTMPOBJ rfoTemp( prfnt->paprfntFaceName[ii] );
                rfoTemp.vGetCache();
            }

        // Need to indicate that this RFONT's EUDC data has been initialized.

            prfnt->flEUDCState |= EUDC_INITIALIZED;

            GreReleaseSemaphore(prfnt->hsemEUDC);

        // First, try to find out target glyph from facename linked font.

            numFaceName = 0;

            for( ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                rfoLinkFace.vInit( prfnt->paprfntFaceName[ii] );
                if ((hgLink = rfoLinkFace.hgXlat(wch)) != rfoLinkFace.hgDefault())
                {
                    RFONTTMPOBJ rfoTemp( prfnt->paprfntFaceName[ii] );
                    if (rfoTemp.bValid())
                    {
                        if( (wpgdTemp = rfoTemp.pgdGetEudcMetrics( wch,  &rfo)) != NULL )
                        {
                if( !IsSingularEudcGlyph(wpgdTemp, rfoTemp.pfo()->flFontType & FO_SIM_BOLD))
                            {
                                numFaceName = ii;
                                EudcType = EUDCTYPE_FACENAME;
                                hgFound = hgLink;
                                prfo    = &rfoLinkFace;
                                break;
                            }
                        }
                    }
                }
            }

        // Check if the glyph is in the DEFAULT EUDC font


            if( (hgFound == HGLYPH_INVALID) && (prfnt->prfntDefEUDC != NULL) )
            {
                rfoLinkDefault.vInit( prfnt->prfntDefEUDC );
                if ((hgLink = rfoLinkDefault.hgXlat(wch)) != rfoLinkDefault.hgDefault())
                {
                    RFONTTMPOBJ rfoTemp( prfnt->prfntDefEUDC );
                    if (rfoTemp.bValid())
                    {
                        if( (wpgdTemp = rfoTemp.pgdGetEudcMetrics( wch , &rfo)) != NULL )
                        {
                if( !IsSingularEudcGlyph(wpgdTemp, rfoTemp.pfo()->flFontType & FO_SIM_BOLD) )
                            {
                                numFaceName = 0;
                                EudcType = EUDCTYPE_DEFAULT;
                                hgFound = hgLink;
                                prfo    = &rfoLinkDefault;
                            }
                        }
                    }
                }
            }

        // Try to find out System EUDC.

            if( (hgFound == HGLYPH_INVALID) && (prfnt->prfntSysEUDC != NULL) )
            {
                rfoLinkSystem.vInit( prfnt->prfntSysEUDC );
                if ((hgLink = rfoLinkSystem.hgXlat(wch)) != rfoLinkSystem.hgDefault())
                {
                    numFaceName = 0;
                    EudcType = EUDCTYPE_SYSTEM_WIDE;
                    hgFound = hgLink;
                    prfo    = &rfoLinkSystem;
                }
            }

            if( hgFound != HGLYPH_INVALID )
            {
                hg = hgFound;
                bEUDC = TRUE;  // find any EUDC object. prfo is not rfo object.
            }
            else
            {
                rfo.dtHelper();
                prfnt->flEUDCState = FALSE;
            }
        }

GetGlyphOutlineData:

      if ( !prfo->bValid() )
      {
        WARNING("GreGetGlyphOutline(): could not lock HRFONT\n");
        SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
      }
      else
      {
          PDEVOBJ pdo( prfo->hdevProducer() );

        if ( !pdo.bValid() )
        {
          WARNING("GreGetGlyphOutline -- invalid PDEV\n");
          SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
        }
        else if ( !PPFNVALID(pdo, QueryTrueTypeOutline) )
        {
          WARNING1("GreGetGlyphOuline -- DrvQueryTrueTypeOutline\n");
          SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
        }
        else
        {
          // reset the xform in the rfo.hfc() if needed:

          RESETFCOBJ resetfco( dco, *prfo, lpmat2, bIgnoreRotation, flType );

          if ( !resetfco.bValid() )
          {
            WARNING("GreGetGlyphOutline(): resetfco\n");
            SAVE_ERROR_CODE( ERROR_CAN_NOT_COMPLETE );
          }
          else
          {

            prfntTmp = NULL;

            if (bEUDC && !resetfco.bTrivXform())
            {
                switch (EudcType)
                {
                    case EUDCTYPE_SYSTEM_WIDE:
                        prfntTmp = prfnt->prfntSysEUDC;
                        prfnt->prfntSysEUDC = NULL;
                        break;
                    case EUDCTYPE_DEFAULT:
                        prfntTmp = prfnt->prfntDefEUDC;
                        prfnt->prfntDefEUDC = NULL;
                        break;
                    case EUDCTYPE_FACENAME:
                        prfntTmp = prfnt->paprfntFaceName[numFaceName];
                        prfnt->paprfntFaceName[numFaceName] = NULL;
                        break;
                    default:
                        break;
                }
            }
            switch ( ulFormat )
            {
            case GGO_BITMAP:
            case GGO_GRAY2_BITMAP:
            case GGO_GRAY4_BITMAP:
            case GGO_GRAY8_BITMAP:

              switch ( ulFormat )
              {
              case GGO_BITMAP:
                iMode = QFD_TT_GRAY1_BITMAP;   // 8 pixels per byte
                break;
              case GGO_GRAY2_BITMAP:
                iMode = QFD_TT_GRAY2_BITMAP;   // one byte per pixel: 0..4
                break;
              case GGO_GRAY4_BITMAP:
                iMode = QFD_TT_GRAY4_BITMAP;   // one byte per pixel: 0..16
                break;
              case GGO_GRAY8_BITMAP:
                iMode = QFD_TT_GRAY8_BITMAP;   // one byte per pixel: 0..64
                break;
              }

              cjRet =
                pdo.QueryFontData(
                  0,          // device handle of PDEV
                  prfo->pfo(),
                  iMode,      // QFD_TT_GRAY[1248]_BITMAP
                  hg,         // glyph handle
                  &gd,        // pointer to GLYPHDATA structure
                  pvBuffer,   // pointer to dest buffer
                  cjBuffer    // size of dest buffer
                  );
              break;

            case GGO_NATIVE:
            case GGO_BEZIER:

              flTTO = 0;
              if (ulFormat == GGO_BEZIER)
                flTTO |= TTO_QUBICS;
              if (bUnhinted)
                flTTO |= TTO_UNHINTED;

              // We're lucky, FdQueryTrueTypeOutline will return size if EITHER
              // a NULL buffer or size of zero is passed in.  So we don't need
              // separate cases. Note that this assumes that the outline is
              // appropriate to a monochrome bitmap. There should be no scaling
              // for the case of antialiased fonts.

              cjRet =
                pdo.QueryTrueTypeOutline(
                  0,
                  prfo->pfo(),
                  hg,
                  flTTO,
                  &gd,
                  cjBuffer,
                  (TTPOLYGONHEADER *) pvBuffer
                  );
              if ( cjRet == FD_ERROR )
              {
                ASSERTGDI(cjRet == GDI_ERROR, "FD_ERROR != GDI_ERROR\n");
                WARNING(
                  "GreGetGlyphOutline(): FdQueryTrueTypeOutline()"
                  "--couldn't get buffer size\n"
                  );
              }

              break;

            case GGO_METRICS:

              // Call to get just the metrics.

              cjRet =
                pdo.QueryFontData(
                  0,                        // device handle of PDEV
                  prfo->pfo(),
                  QFD_TT_GLYPHANDBITMAP,    // mode of call
                  hg,                       // glyph handle
                  &gd,                      // pointer to GLYPHDATA structure
                  0,                        // pointer to destination buffer
                  0                         // size of destination buffer in bytes
                  );
              if ( cjRet == FD_ERROR )
              {
                ASSERTGDI(cjRet == GDI_ERROR, "FD_ERROR != GDI_ERROR\n");
                WARNING(
                  "GreGetGlyphOutline(): FdQueryFontData()"
                  "--couldn't get GLYPHMETRICS\n"
                  );
              }
              break;

            default:

              WARNING("GreGetGlyphOutline(): bad parameter, unknown format\n");
              break;
            }

          }


          if ( cjRet != GDI_ERROR )
          {
            // Convert the GLYPHDATA metrics to GLYPHMETRICS.

            lpgm->gmBlackBoxX = (UINT) (gd.rclInk.right  - gd.rclInk.left);
            lpgm->gmBlackBoxY = (UINT) (gd.rclInk.bottom - gd.rclInk.top);

            // this is true by virtue of the fact that for tt fonts bitmap
            // is of the same size as the black box. The exception to this
            // rule is the empty space char which is a blank 1x1 bitmap

            lpgm->gmptGlyphOrigin.x = gd.rclInk.left;
            lpgm->gmptGlyphOrigin.y = - gd.rclInk.top;

            lpgm->gmCellIncX = (WORD) FXTOLROUND(gd.ptqD.x.u.HighPart);
            lpgm->gmCellIncY = (WORD) FXTOLROUND(gd.ptqD.y.u.HighPart);
          }
        }

        if (bEUDC)
        {
            rfo.dtHelper(FALSE);
            prfnt->flEUDCState = FALSE;
            if (prfntTmp)
            {
                switch (EudcType)
                {
                    case EUDCTYPE_SYSTEM_WIDE:
                        prfnt->prfntSysEUDC = prfntTmp;
                        break;
                    case EUDCTYPE_DEFAULT:
                        prfnt->prfntDefEUDC = prfntTmp;
                        break;
                    case EUDCTYPE_FACENAME:
                        prfnt->paprfntFaceName[numFaceName] = prfntTmp;
                        break;
                    default:
                        break;
                }
            }

            ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0");
            DECREMENTEUDCCOUNT;
        }

      }
    }
  }
  return( cjRet );
}



VOID vIFIMetricsToETM(
    EXTTEXTMETRIC    *petm,
    RFONTOBJ&         rfo,
    DCOBJ&            dco,
    IFIMETRICS       *pifi
    );

/******************************Public*Routine******************************\
*
* GreGetETM
*
* support for aldus escape
*
* History:
*  19-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetETM(
    HDC hdc,
    EXTTEXTMETRIC *petm
    )
{

    EXTTEXTMETRIC  kmETM;
    BOOL bRet = FALSE;

    // Get DC user object.

    DCOBJ dco(hdc);

    if (petm && dco.bValid())
    {
        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {

        // see if we can dispatch the call directly to the device driver

            PDEVOBJ pdo(rfo.hdevProducer());

            if (PPFNDRV(pdo,FontManagement))
            {
                ULONG    iMode = GETEXTENDEDTEXTMETRICS;
                SURFOBJ  *pso = NULL;

                if (pdo.bUMPD())
                {
                    // we need to have a dhpdev when calling out to UMPD

                    pso = (SURFOBJ *)pdo.dhpdev();
                }

                BOOL bSupported = GetETMFontManagement(
                                      rfo,
                                      pdo,
                                      pso,
                                      NULL,
                                      QUERYESCSUPPORT,  // iMode
                                      sizeof(ULONG),    // cjIn
                                      (PVOID)&iMode,    // pvIn
                                      0,                // cjOut
                                      (PVOID)NULL       // pvOut
                                      );

                if (bSupported)
                {
                    SURFOBJ  soFake;
                    SURFOBJ *pso = pdo.pSurface()->pSurfobj();

                    if (pso == (SURFOBJ *) NULL) // create vanilla surfobj
                    {
                        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
                        soFake.dhpdev = rfo.prfnt->dhpdev;
                        soFake.hdev   = rfo.hdevConsumer();
                        soFake.iType  = (USHORT)STYPE_DEVICE;
                        pso = &soFake;
                    }

                    bRet = pdo.FontManagement(
                                pso,
                                rfo.pfo(),
                                GETEXTENDEDTEXTMETRICS,
                                0,
                                (PVOID)NULL,
                                (ULONG)sizeof(EXTTEXTMETRIC),
                                (PVOID)&kmETM
                                );
                }
            }

            // if GETEXTENDEDTEXTMETRIC is not supported do something:
            // Get PFE user object.

            if (!bRet)
            {
                PFEOBJ pfeo(rfo.ppfe());
                if (pfeo.bValid())
                {
                    if (pfeo.flFontType() & TRUETYPE_FONTTYPE)
                    {
                        vIFIMetricsToETM(&kmETM,rfo,dco,pfeo.pifi());
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    if (bRet)
    {
        __try
        {
            ProbeForWrite(petm,sizeof(EXTTEXTMETRIC),sizeof(ULONG));
            RtlMoveMemory(petm,&kmETM,sizeof(EXTTEXTMETRIC));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());
            bRet = FALSE;
        }
    }

    return bRet;
}



/******************************Public*Routine******************************\
* GreGetOutlineTextMetricsInternalW
*
* History:
*
*  20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
* Added bTTOnly field so we can service the Aldus escape for Win 3.1 compat.
* Changed to GreGe...InternalW to avoid a header file change in wingdip.h
*
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT   cjOTMAWSize (
    PIFIMETRICS  pifi,        // compute size of OTM produced by this buffer
    UINT        *pcjotmw
    );


ULONG
GreGetOutlineTextMetricsInternalW(
    HDC                  hdc,
    ULONG                cjotm,
    OUTLINETEXTMETRICW   *potmw,
    TMDIFF               *ptmd
    )
{
    ULONG  cjRet = 0;

// Early out test.  Zero data requested.

    if ( (cjotm == 0) && (potmw != (OUTLINETEXTMETRICW*) NULL) )
    {
        WARNING("GreGetOutlineTextMetrics(): bad parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (cjRet);
    }

// Get DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get RFONT user object.

    // Old Comment:
    //  - This should really be an LFONTOBJ

    RFONTOBJ rfo(dco, FALSE);
    if (!rfo.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get PFE user object.

    PFEOBJ pfeo(rfo.ppfe());
    if (!pfeo.bValid())
    {
        WARNING("GreGetOutlineTextMetrics(): could not lock HPFE\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (cjRet);
    }

// Get LDEV user object for the font driver.

    PDEVOBJ pdo(rfo.hdevProducer());

// Check the font driver.  If we are in TT only mode, we will allow only
// the TrueType driver to succeed.  However, in this sense, the TrueType
// driver is any driver that exports DrvQueryTrueTypeOutline.  Afterall,
// if it can supply the actual outlines, it should be able to supply the
// metrics.
//
// Actually, it would be nice to allow this function to work for all
// drivers since all drivers supply the IFIMETRICS and therefore can
// answer this question.  However, we are much too afraid that this will
// break some obscure compatibility so we will let our TT driver and
// 3rd part TT-like drivers succeed.
//
// If we not in TT only mode, then everybody succeed this function! Yay!

    if (PPFNVALID(pdo, QueryTrueTypeOutline))
    {
        // Size if full OUTLINETEXTMETRICW (including strings) is copied.

        UINT cjotmw;

        // use cjotma field of tmd to ship cjotma to the client side, [bodind]

        ptmd->cjotma = (ULONG)cjOTMAWSize(pfeo.pifi(), &cjotmw);

        // If return buffer is NULL, then only size needs to be returned.

        if (potmw == NULL)
        {
            cjRet = cjotmw;
        }
        else
        {
            // Is return buffer big enough for the conversion routine (which is not
            // capable of converting a partial OUTLINETEXTMETRICW structure [unless,
            // of course, it's one without the strings]).

            if (cjotm <= sizeof(OUTLINETEXTMETRICW))
            {
                // Allocate a buffer for a full OUTLINETEXTMETRICW, since conversion
                // routine needs at least that much memory.

                OUTLINETEXTMETRICW otmwTmp;
                RtlZeroMemory(&otmwTmp, sizeof(OUTLINETEXTMETRICW));

                // Convert IFIMETRICS to OUTLINETEXTMETRICW using temp buffer.

                if (
                    (cjRet = cjIFIMetricsToOTMW(
                                   ptmd,
                                   &otmwTmp,
                                   rfo,
                                   dco,
                                   pfeo.pifi(),
                                   FALSE           // do not need strings
                                   )) == 0 )
                {
                    WARNING("GreGetOutlineTextMetrics(): error creating OUTLINETEXTMETRIC\n");
                    return (cjRet);
                }

                // Copy needed part of OUTLINETEXTMETRICW into return buffer.


                RtlCopyMemory((PVOID) potmw, (PVOID) &otmwTmp, cjotm);
                return cjotm;
            }

            // Otherwise asking for strings

            // We have to assume that all the strings are desired.  If
            // cjCopy > sizeof(OUTLINETEXTMETRICW) how can we
            // know how many strings are requested?  Afterall, the app is not
            // supposed to have apriori knowledge of the length of the strings.
            // Note that this is also a Win3.1 compatible assumption.  (They
            // assume the same thing).

            if ( cjotm >= cjotmw )
            {
                // Convert IFIMETRICS to OUTLINETEXTMETRICW using return buffer.

                cjRet = cjIFIMetricsToOTMW(ptmd,potmw, rfo, dco, pfeo.pifi(), TRUE);

                // clean up the rest of the buffer so that neilc - " Mr. c2 guy" is happy

                {
                    LONG lDiff = (LONG)cjotm - (LONG)cjRet;
                    ASSERTGDI(lDiff >= 0, "GetOTM, lDiff < 0");
                    if (lDiff > 0)
                        RtlZeroMemory(((BYTE*)potmw + cjRet), lDiff);
                }
            }
        }
    }

    return (cjRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\umpd.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    umpd.cxx

Abstract:

    User-mode printer driver support

Environment:

    Windows NT 5.0

Revision History:

    07/8/97 -lingyunw-
        Created it.


--*/

#include "precomp.hxx"


#if !defined(_GDIPLUS_)

extern PFN gpUMDriverFunc[];

static const ULONG aiFuncRequired[] =
{
    INDEX_DrvEnablePDEV,
    INDEX_DrvCompletePDEV,
    INDEX_DrvDisablePDEV,
};


//
//                     ()---()
//                     / o o \
//                ___-(       )-___
// --------------(,,,----\_/----,,,)--------------------------------------
//                        O
//
// BOOL UMPD_ldevFillTable
//      Fill the ldev function dispatch table for user mode printer drivers
//
// Returns
//      BOOLEAN
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//
// -----------------------------------------------------------------------
//                    | |---| |
//                  _-+ |   | +-_
//                 (,,,/     \,,,)

UMPD_ldevFillTable(
    PLDEV   pldev,
    BOOL *  pbDrvFn)
{
    //
    // Put the UMPD kernel stubs in the function table.
    //

    ULONG  i;
    PFN   *ppfnTable = pldev->apfn;
    BOOL   bRet = TRUE;

    //
    // fill with zero pointers to avoid possibility of accessing
    // incorrect fields later
    //

    RtlZeroMemory(ppfnTable, INDEX_LAST*sizeof(PFN));

    //
    // Set UMPD thunk pointers in pldev->apfn.
    //

    for (i = 0; i < INDEX_LAST; i++)
    {
         if (pbDrvFn[i])
         {
             ppfnTable[i] = gpUMDriverFunc[i];
         }
    }

    if (bRet)
    {
       //
       // Check for required driver functions.
       //

       i = sizeof(aiFuncRequired) / sizeof(ULONG);
       while (i--)
       {
           if (ppfnTable[aiFuncRequired[i]] == (PFN) NULL)
           {
               ASSERTGDI(FALSE,"UMPDldevFillTable: a required function is missing from driver\n");
               return(FALSE);
           }
       }
    }

    //
    // Always hook up UMPDDRVFREE so we can free our kernel copies
    //
    ppfnTable[INDEX_DrvFree] = gpUMDriverFunc[INDEX_DrvFree];

    return(bRet);
}

//
//                     ()---()
//                     / o o \
//                ___-(       )-___
// --------------(,,,----\_/----,,,)--------------------------------------
//                        O
//
// BOOL UMPD_ldevLoadDriver
//      User mode printer drivers load driver routine.  Create a ldev and
//      fill up the function table.
//
// Returns
//      BOOLEAN
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//
// -----------------------------------------------------------------------
//                    | |---| |
//                  _-+ |   | +-_
//                 (,,,/     \,,,)

PLDEV
UMPD_ldevLoadDriver(
    LPWSTR pwszDriver,
    LDEVTYPE ldt)
{
    PLDEV pldev;
    PFN   *ppdrvfn;

    TRACE_INIT(("ldevLoadInternal ENTERING\n"));

    //
    // Allocate memory for the LDEV.
    //

    pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), UMPD_MEMORY_TAG);

    if (pldev)
    {
        //
        // Call the Enable entry point.
        //
        PVOID           umpdCookie;
        BOOL            bRet = FALSE;

        bRet =  UMPDDrvEnableDriver (pwszDriver, &umpdCookie);

        if (bRet)
        {
            //
            // fill info and apfn into pldev
            //
            pldev->pldevNext = NULL;
            pldev->pldevPrev = NULL;
            pldev->ldevType = ldt;
            pldev->cldevRefs = 1;
            pldev->pGdiDriverInfo = NULL;
            pldev->umpdCookie = umpdCookie;
            pldev->pid = (PW32PROCESS)W32GetCurrentProcess();

            BOOL    bDrvfn[INDEX_LAST];

            if(!UMPDDrvDriverFn(umpdCookie, bDrvfn))
            {
                WARNING("UMPD -- unable to get driver fn support\n");
                bRet = FALSE;
            }

            if(bRet)
            {
                bRet = UMPD_ldevFillTable(pldev, bDrvfn);
            }


        }

        if (!bRet)
        {
            VFREEMEM(pldev);
            pldev = NULL;
        }
    }

    return pldev;
}

PPORT_MESSAGE
PROXYPORT::InitMsg(
    PPROXYMSG       Msg,
    UM64_PVOID      pvIn,
    ULONG           cjIn,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    Msg->h.u1.s1.DataLength = (short) (sizeof(*Msg) - sizeof(Msg->h));
    Msg->h.u1.s1.TotalLength = (short) (sizeof(*Msg));

    Msg->h.u2.ZeroInit = 0;

    if(pvOut == NULL) cjOut = 0;

    Msg->cjIn = cjIn;
    Msg->pvIn = pvIn;
    
    Msg->cjOut = cjOut;
    Msg->pvOut = pvOut;

    return( (PPORT_MESSAGE)Msg );
}

BOOL
PROXYPORT::CheckMsg(
    NTSTATUS        Status,
    PPROXYMSG       Msg,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    ULONG       cbData = Msg->h.u1.s1.DataLength;

    if (cbData == (sizeof(*Msg) - sizeof(Msg->h)))
    {
        if(pvOut != Msg->pvOut)
        {
            return(FALSE);
        }

        if(cjOut != Msg->cjOut)
        {
            return(FALSE);
        }
    }
    else
    {
        return(FALSE);
    }

    return( TRUE );
}

NTSTATUS
PROXYPORT::SendRequest(
    UM64_PVOID      pvIn,
    ULONG           cjIn,
    UM64_PVOID      pvOut,
    ULONG           cjOut
    )
{
    NTSTATUS        Status;
    PROXYMSG        Request;
    PROXYMSG        Reply;

    InitMsg( &Request, pvIn, cjIn, pvOut, cjOut );
    
    Status = ZwRequestWaitReplyPort( pp->PortHandle,
                                     (PPORT_MESSAGE)&Request,
                                     (PPORT_MESSAGE)&Reply
                                   );

    if (!NT_SUCCESS( Status ))
    {
        return( Status );
    }

    if (Reply.h.u2.s2.Type == LPC_REPLY)
    {
        if (!CheckMsg( Status, &Reply, pvOut, cjOut ))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return( Status );
}

UM64_PVOID
PROXYPORT::HeapAlloc(ULONG inSize)
{
    SSIZE_T ptr;

    if(pp->ClientMemoryAllocSize + inSize > pp->ClientMemorySize)
        return NULL;

    ptr = pp->ClientMemoryBase + (SSIZE_T)pp->ClientMemoryAllocSize + pp->ServerMemoryDelta;

    pp->ClientMemoryAllocSize += inSize;

    return (UM64_PVOID)ptr;
}


PROXYPORT::PROXYPORT(ULONGLONG inMaxSize)
{
    NTSTATUS                        Status;
    PORT_VIEW                       ClientView;
    ULONG                           MaxMessageLength;
    LARGE_INTEGER                   MaximumSize;
    UNICODE_STRING                  PortName;
    SECURITY_QUALITY_OF_SERVICE     DynamicQos;
    PROCESS_SESSION_INFORMATION     Info;
    WCHAR                           awcPortName[MAX_PATH] = {0};
    DWORD                           CurrSessionId;
    
    pp = NULL;

    if (NT_SUCCESS(Status = ZwQueryInformationProcess(NtCurrentProcess(),
                                       ProcessSessionInformation,
                                       &Info,
                                       sizeof(Info),
                                       NULL)))
    {
        CurrSessionId = Info.SessionId;
        swprintf(awcPortName, L"%s_%x",L"\\RPC Control\\UmpdProxy", CurrSessionId);
         
        DynamicQos.Length = 0;
        DynamicQos.ImpersonationLevel = SecurityImpersonation;
        DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        DynamicQos.EffectiveOnly = TRUE;
    
        pp = (ProxyPort *) PALLOCMEM(sizeof(ProxyPort), 'tppG');
    
        if(pp != NULL)
        {
            pp->ClientMemoryBase = 0;
            pp->ClientMemorySize = 0;
            pp->ClientMemoryAllocSize = 0;
            pp->PortHandle = NULL;
            pp->ServerMemoryBase = 0;
            pp->ServerMemoryDelta = 0;
    
            Status = STATUS_SUCCESS;
    
            RtlInitUnicodeString( &PortName, awcPortName );
    
            MaximumSize.QuadPart = inMaxSize;
            ClientView.SectionHandle = 0;

            Status = ZwCreateSection( &ClientView.SectionHandle,
                                      SECTION_MAP_READ | SECTION_MAP_WRITE,
                                      NULL,
                                      &MaximumSize,
                                      PAGE_READWRITE,
                                      SEC_COMMIT,
                                      NULL
                                    );
    
            if (NT_SUCCESS( Status ))
            {
                ClientView.Length = sizeof( ClientView );
                ClientView.SectionOffset = 0;
                ClientView.ViewSize = (LPC_SIZE_T) inMaxSize;
                ClientView.ViewBase = 0;
                ClientView.ViewRemoteBase = 0;
    
                Status = ZwConnectPort( &pp->PortHandle,
                                        &PortName,
                                        &DynamicQos,
                                        &ClientView,
                                        NULL,
                                        (PULONG)&MaxMessageLength,
                                        NULL,
                                        0
                                      );
    
                if (NT_SUCCESS( Status ))
                {
                    pp->SectionHandle = ClientView.SectionHandle;
                    pp->ClientMemoryBase = (SSIZE_T)ClientView.ViewBase;
                    pp->ClientMemorySize = ClientView.ViewSize;
                    pp->ServerMemoryBase = (SSIZE_T)ClientView.ViewRemoteBase;
                    pp->ServerMemoryDelta = pp->ServerMemoryBase - pp->ClientMemoryBase;
    
                }
                else
                {
                    WARNING("PROXYPORT::PROXYPORT failed to connect lpc port\n");
                }
            }
            else
            {
                WARNING("PROXYPORT::PROXYPORT failed to create section\n");
            }
    
            if(!NT_SUCCESS( Status ))
            {
                if (ClientView.SectionHandle)
                {
                    ZwClose(ClientView.SectionHandle);
                }
                
                VFREEMEM(pp);
                pp = NULL;
            }
        }
    }
}

VOID
PROXYPORT::Close()
{
    ASSERTGDI(pp->PortHandle, "PROXYPORT::Close() invalid port handle\n");
    ASSERTGDI(pp->SectionHandle, "PROXYPORT::Close() invalid shared section handle\n");
    
    if (pp->SectionHandle)
    {
        if (!ZwClose(pp->SectionHandle))
        {
            WARNING("ZwClose failed to close the shred section handle in PROXYPORT::Close\n");
        }
    }

    if (pp->PortHandle != NULL)
    {
        if (!ZwClose( pp->PortHandle ))
        {
            WARNING("ZwClose failed to close the lpc port handle in PROXYPORT::Close\n");
        }
    }

    VFREEMEM(pp);
}

/*
BOOL UMPDReleaseRFONTSem()
   Used by umpd printing, releasing RFONT caching semaphores
*/

BOOL UMPDReleaseRFONTSem(
    RFONTOBJ& rfo,
    PUMPDOBJ pumpdobj,
    ULONG* pfl,
    ULONG* pnumLinks,
    BOOL** ppFaceLink
)
{
    BOOL bUMPDOBJ, *pFaceLink = NULL;
    ULONG numLinks = 0;

    if (!rfo.bValid())
        return FALSE;

    if (pumpdobj && pfl == NULL && pnumLinks == NULL && ppFaceLink == NULL)
    {
        bUMPDOBJ = TRUE;
    }
    else if (pumpdobj == NULL && pfl && pnumLinks && ppFaceLink)
    {
        bUMPDOBJ = FALSE;
        *pfl = 0;
        *pnumLinks = 0;
    }
    else
    {
        ASSERTGDI(0, "UMPD_ReleaseRFONTSem: it neither umpdobj nor TextOutDrvBitBlt\n");
        return FALSE;
    }

    if (rfo.prfnt->hsemEUDC)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemEUDC);

        if (rfo.prfnt->prfntSystemTT && rfo.prfnt->prfntSystemTT->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntSystemTT->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntSystemTT->hsemCache);
            
            if (bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_SYSTTFONT);
            else
                *pfl |= RELEASE_SYSTTFONT;
        }
        
        if (rfo.prfnt->prfntSysEUDC && rfo.prfnt->prfntSysEUDC->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntSysEUDC->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntSysEUDC->hsemCache);

            if (bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_SYSEUDCFONT);
            else
                *pfl |= RELEASE_SYSEUDCFONT;
        }
                                                                                       
        if (rfo.prfnt->prfntDefEUDC && rfo.prfnt->prfntDefEUDC->hsemCache &&
            GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->prfntDefEUDC->hsemCache))
        {
            GreReleaseSemaphore(rfo.prfnt->prfntDefEUDC->hsemCache);
            
            if(bUMPDOBJ)
                pumpdobj->vSetFlags(RELEASE_DEFEUDCFONT);
            else
                *pfl |= RELEASE_DEFEUDCFONT;
        }
        
        if (numLinks = rfo.uiNumFaceNameLinks())
        {
            BOOL bContinue = FALSE;
            
            if (bUMPDOBJ)
            {
                bContinue = pumpdobj->bAllocFontLinks(numLinks);
            }
            else
            {
                pFaceLink = numLinks > UMPD_MAX_FONTFACELINK ?
                                            (BOOL*)PALLOCNOZ(sizeof(BOOL) * numLinks, UMPD_MEMORY_TAG) :
                                            *ppFaceLink;
                *ppFaceLink = pFaceLink;
                
                if (pFaceLink)
                {
                    bContinue = TRUE;
                    *pnumLinks = numLinks;
                    RtlZeroMemory(pFaceLink, sizeof(BOOL) * numLinks);
                }
            }

            if (bContinue)
            {
                for(ULONG ii = 0; ii < numLinks; ii++)
                {
                    if(rfo.prfnt->paprfntFaceName[ii] &&
                       rfo.prfnt->paprfntFaceName[ii]->hsemCache &&
                       GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->paprfntFaceName[ii]->hsemCache))
                    {
                        GreReleaseSemaphore(rfo.prfnt->paprfntFaceName[ii]->hsemCache);

                        if (bUMPDOBJ)
                            pumpdobj->vSetFontLink(ii);
                        else
                            pFaceLink[ii] = TRUE;
                    }
                }
            }
        }
        
        GreReleaseSemaphore(rfo.prfnt->hsemEUDC);
    }

    if (rfo.prfnt->hsemCache != NULL &&
        GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->hsemCache))
    {
        GreReleaseSemaphore(rfo.prfnt->hsemCache);
        
        if (bUMPDOBJ)
            pumpdobj->vSetFlags(RELEASE_BASEFONT);
        else
            *pfl |= RELEASE_BASEFONT;
    }

    return TRUE;
}

/*
VOID UMPDAcquireRFONTSem()
    Used by umpd printing, acquire all the RFONT caching semaphores.
*/

VOID  UMPDAcquireRFONTSem(
    RFONTOBJ&  rfo,
    PUMPDOBJ   pumpdobj,
    ULONG      fl,
    ULONG      numLinks,
    BOOL*      pFaceLink
)
{
    BOOL  bUMPDOBJ = FALSE;

    if (!rfo.bValid())
        return;

    if (pumpdobj)
    {
        bUMPDOBJ = TRUE;
        fl = pumpdobj->GetFlags();
        numLinks = pumpdobj->bLinkedFonts() ? pumpdobj->numLinkedFonts() : 0;
    }
    
    if ((fl & RELEASE_BASEFONT) && rfo.prfnt->hsemCache != NULL)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemCache);
        if (bUMPDOBJ)
            pumpdobj->vClearFlags(RELEASE_BASEFONT);
    }

    if (rfo.prfnt->hsemEUDC)
    {
        GreAcquireSemaphore(rfo.prfnt->hsemEUDC);

        if ((fl & RELEASE_SYSTTFONT) && rfo.prfnt->prfntSystemTT)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntSystemTT->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_SYSTTFONT);
        }
        
        if ((fl & RELEASE_SYSEUDCFONT) && rfo.prfnt->prfntSysEUDC)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntSysEUDC->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_SYSEUDCFONT);
        }
        
        if ((fl & RELEASE_DEFEUDCFONT) && rfo.prfnt->prfntDefEUDC)
        {
            GreAcquireSemaphore(rfo.prfnt->prfntDefEUDC->hsemCache);
            if (bUMPDOBJ)
                pumpdobj->vClearFlags(RELEASE_DEFEUDCFONT);
        }
        
        if (numLinks)
        {
            BOOL bAcquire;

            numLinks =(numLinks > rfo.uiNumFaceNameLinks()) ? rfo.uiNumFaceNameLinks() : numLinks;

            for (ULONG ii = 0; ii < numLinks; ii++)
            {
                bAcquire = rfo.prfnt->paprfntFaceName[ii] &&
                           (bUMPDOBJ ? pumpdobj->bLinkedFont(ii) : pFaceLink[ii]);

                if (bAcquire)
                {
                    GreAcquireSemaphore(rfo.prfnt->paprfntFaceName[ii]->hsemCache);
                    if (bUMPDOBJ)
                        pumpdobj->vClearFontLink(ii);
                }
            }
        }

        GreReleaseSemaphore(rfo.prfnt->hsemEUDC);
    }
}


VOID TextOutBitBlt(
    SURFACE     *pSurf,
    RFONTOBJ&   rfo,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    RECTL       *prclTrg,
    POINTL      *pptlSrc,
    POINTL      *pptlMask,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrush,
    ROP4        rop4
)
{
    BOOL bSem = FALSE;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    PDEVOBJ po(pSurf->hdev());
    
    if (po.bPrinter() && po.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }
    
    // call driver BitBlt

    (*(pSurf->pfnBitBlt())) (pSurf->pSurfobj(),
                             psoSrc,
                             psoMask,
                             pco,
                             pxlo,
                             prclTrg,
                             pptlSrc,
                             pptlMask,
                             pbo,
                             pptlBrush,
                             rop4);
    
    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
}

BOOL GetETMFontManagement(
    RFONTOBJ& rfo,
    PDEVOBJ pdo,
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
)
{
    BOOL bRet;
    BOOL bSem = FALSE;

    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;
    
    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCache acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    
    if (pdo.bPrinter() && pdo.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }
    
    bRet = pdo.FontManagement(pso,
                              pfo,
                              iEsc,
                              cjIn,
                              pvIn,
                              cjOut,
                              pvOut);

    // acquire the font semaphore(s)

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);
        
        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }        
    }
    
    return bRet;
}

#else // _GDIPLUS_

extern "C" PUMPD UMPDDrvEnableDriver(PWSTR, ULONG);

PLDEV
UMPD_ldevLoadDriver(
    PWSTR pwszDriver,
    LDEVTYPE ldt
    )

{
    PLDEV   pldev = NULL;
    PUMPD   pUMPD;

    if ((pUMPD = UMPDDrvEnableDriver(pwszDriver, DDI_DRIVER_VERSION_NT5_01_SP1)) &&
        (pldev = (PLDEV) PALLOCMEM(sizeof(LDEV), UMPD_MEMORY_TAG)))
    {
        pldev->pldevNext = (PLDEV)pUMPD;
        pldev->pldevPrev = NULL;
        pldev->ldevType = ldt;
        pldev->cldevRefs = 1;
        pldev->pGdiDriverInfo = NULL;

        RtlCopyMemory(pldev->apfn, pUMPD->apfn, sizeof(pldev->apfn));

        return pldev;
    }
    else
    {
        if (pldev)
            VFREEMEM(pldev);

        return NULL;
    }
}

#endif // _GDIPLUS_


VOID UMPD_ldevUnloadImage(PLDEV pldev)
{
    if (pldev)
        VFREEMEM(pldev);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\usersrv.cxx ===
/******************************Module*Header*******************************\
* Module Name: usersrv.c
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

//
// The following methods are thunks to support calls to user mode
// font drivers
//

#define DEFINE_FUNCTION(x, y)     \
    union {                       \
        PFN Generic;              \
        PFN_Drv##x Kernel;        \
    } y = { ppfn(INDEX_Drv##x) };


class ATTACHOBJ {
public:
    PDEVOBJ *pObject;

    ATTACHOBJ(PDEVOBJ *pObject_);
    ~ATTACHOBJ();
};

ATTACHOBJ::ATTACHOBJ(PDEVOBJ *pObject_)
{
    if (pObject_->bFontDriver())
    {
        pObject = pObject_;
        KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
    }
    else
    {
        pObject = 0;
    }
}

ATTACHOBJ::~ATTACHOBJ()
{
    if (pObject)
    {
        KeDetachProcess();
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::EnablePDEV
*
\**************************************************************************/

DHPDEV PDEVOBJ::EnablePDEV(
    DEVMODEW *pdm
  ,   LPWSTR  pwszLogAddress
  ,    ULONG  cPat
  ,    HSURF *phsurfPatterns
  ,    ULONG  cjCaps
  ,  GDIINFO *pGdiInfo
  ,    ULONG  cjDevInfo
  ,  DEVINFO *pdi
  ,     HDEV  hdev
  ,   LPWSTR  pwszDeviceName
  ,   HANDLE  hDriver
    )
{
    DHPDEV ReturnValue;
    DEFINE_FUNCTION(EnablePDEV, pfn);

    ReturnValue = (*pfn.Kernel)(pdm,
                                pwszLogAddress,
                                cPat,
                                phsurfPatterns,
                                cjCaps,
                                pGdiInfo,
                                cjDevInfo,
                                pdi,
                                hdev,
                                pwszDeviceName,
                                hDriver);

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::DisablePDEV
*
\**************************************************************************/

VOID PDEVOBJ::DisablePDEV( DHPDEV dhpdev)
{
    DEFINE_FUNCTION(DisablePDEV, pfn);

    (*pfn.Kernel)(dhpdev);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::CompletePDEV
*
\**************************************************************************/

VOID PDEVOBJ::CompletePDEV( DHPDEV dhpdev, HDEV hdev)
{
    DEFINE_FUNCTION(CompletePDEV, pfn);

    (*pfn.Kernel)(dhpdev, hdev);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFont
*
\**************************************************************************/

IFIMETRICS* PDEVOBJ::QueryFont(
    DHPDEV      dhpdev
  ,  ULONG_PTR  iFile
  ,  ULONG      iFace
  ,  ULONG_PTR      *pid
  )
{
    IFIMETRICS *ReturnValue = NULL;
    DEFINE_FUNCTION(QueryFont, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);
    
        ReturnValue = (*pfn.Kernel)(dhpdev, iFile, iFace, pid);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontTree
*
\**************************************************************************/

PVOID PDEVOBJ::QueryFontTree(
    DHPDEV     dhpdev
  ,  ULONG_PTR  iFile
  ,  ULONG     iFace
  ,  ULONG     iMode
  ,  ULONG_PTR     *pid
    )
{
    PVOID ReturnValue;
    DEFINE_FUNCTION(QueryFontTree, pfn);
    ATTACHOBJ ato(this);

    ReturnValue = (*pfn.Kernel)(dhpdev, iFile, iFace, iMode, pid);
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontData
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontData(
       DHPDEV  dhpdev
  ,   FONTOBJ *pfo
  ,     ULONG  iMode
  ,    HGLYPH  hg
  , GLYPHDATA *pgd
  ,     PVOID  pv
  ,     ULONG  cjSize
    )
{
    LONG ReturnValue = FD_ERROR; 
    DEFINE_FUNCTION(QueryFontData, pfn);
    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev, pfo, iMode, hg, pgd, pv, cjSize);
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::DestroyFont
*
\**************************************************************************/

VOID PDEVOBJ::DestroyFont(FONTOBJ *pfo)
{
    BOOL  bUnmap = FALSE;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    
    // check ref count
    {
        SEMOBJ  so(ghsemPublicPFT);
        
        if (rfo.pPFF()->cRFONT == 1)
            bUnmap = TRUE;
    }

    if (bUnmap)
    {
        UnmapPrintKView(rfo.pPFF()->hff);
    }

    DEFINE_FUNCTION(DestroyFont, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        (*pfn.Kernel)(pfo);
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontCaps
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontCaps(
    ULONG  culCaps
  , ULONG *pulCaps
    )
{
    LONG ReturnValue;
    DEFINE_FUNCTION(QueryFontCaps, pfn);

    ReturnValue = (*pfn.Kernel)(culCaps, pulCaps);
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::LoadFontFile
*
\**************************************************************************/

HFF PDEVOBJ::LoadFontFile(
    ULONG    cFiles
  , ULONG_PTR *piFile
  , PVOID    *ppvView
  , ULONG    *pcjView
  , DESIGNVECTOR *pdv
  , ULONG    ulLangID
  , ULONG    ulFastCheckSum
    )
{
    HFF ReturnValue = 0;
    DEFINE_FUNCTION(LoadFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(cFiles, piFile, ppvView, pcjView, pdv, ulLangID, ulFastCheckSum);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::UnloadFontFile
*
\**************************************************************************/

BOOL PDEVOBJ::UnloadFontFile(ULONG_PTR iFile)
{
    BOOL ReturnValue = TRUE;
    DEFINE_FUNCTION(UnloadFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(iFile);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryFontFile
*
\**************************************************************************/

LONG PDEVOBJ::QueryFontFile(
    ULONG_PTR  iFile
  , ULONG     ulMode
  , ULONG     cjBuf
  , ULONG     *pulBuf
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryFontFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(iFile, ulMode, cjBuf, pulBuf);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryAdvanceWidths
*
\**************************************************************************/

BOOL PDEVOBJ::QueryAdvanceWidths(
     DHPDEV  dhpdev
  , FONTOBJ *pfo
  ,   ULONG  iMode
  ,  HGLYPH *phg
  ,   PVOID  pvWidths
  ,   ULONG  cGlyphs
    )
{
    BOOL ReturnValue = FALSE;
    DEFINE_FUNCTION(QueryAdvanceWidths, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev, pfo, iMode, phg, pvWidths, cGlyphs);
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::Free
*
\**************************************************************************/

VOID PDEVOBJ::Free(PVOID pv, ULONG_PTR id)
{
    DEFINE_FUNCTION(Free, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        (*pfn.Kernel)(pv, id);
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::bQueryGlyphAttrs
*
\**************************************************************************/

PFD_GLYPHATTR  PDEVOBJ::QueryGlyphAttrs(
    FONTOBJ     *pfo,
    ULONG       iMode
)
{
    DEFINE_FUNCTION(QueryGlyphAttrs, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pfn.Kernel)
        {
            return (*pfn.Kernel)(pfo, iMode);
        }
    }

    return NULL;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryTrueTypeTable
*
\**************************************************************************/

LONG PDEVOBJ::QueryTrueTypeTable(
      ULONG_PTR  iFile
  ,   ULONG     ulFont
  ,   ULONG     ulTag
  , PTRDIFF     dpStart
  ,   ULONG     cjBuf
  ,    BYTE     *pjBuf
  ,    BYTE     **ppjTable
  ,   ULONG     *pcjTable
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryTrueTypeTable, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pjBuf)
        {
            *pjBuf = 0;
        }
        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(iFile,
                                        ulFont,
                                        ulTag,
                                        dpStart,
                                        cjBuf,
                                        pjBuf,
                                        ppjTable,
                                        pcjTable);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::QueryTrueTypeOutline
*
\**************************************************************************/

LONG PDEVOBJ::QueryTrueTypeOutline(
             DHPDEV  dhpdev
  ,         FONTOBJ *pfo
  ,          HGLYPH  hglyph
  ,            BOOL  bMetricsOnly
  ,       GLYPHDATA *pgldt
  ,           ULONG  cjBuf
  , TTPOLYGONHEADER *ppoly
    )
{
    LONG ReturnValue = FD_ERROR;
    DEFINE_FUNCTION(QueryTrueTypeOutline, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(dhpdev,
                                    pfo,
                                    hglyph,
                                    bMetricsOnly,
                                    pgldt,
                                    cjBuf,
                                    ppoly);
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::GetTrueTypeFile
*
\**************************************************************************/

PVOID PDEVOBJ::GetTrueTypeFile(ULONG_PTR iFile, ULONG *pcj)
{
    PVOID ReturnValue = 0;
    DEFINE_FUNCTION(GetTrueTypeFile, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        *pcj = 0;
        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(iFile, pcj);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::FontManagement
*
\**************************************************************************/

BOOL PDEVOBJ::FontManagement(
       	SURFOBJ *pso,
        FONTOBJ *pfo,
        ULONG    iEsc,
        ULONG    cjIn,
       	PVOID    pvIn,
        ULONG    cjOut,
       	PVOID    pvOut
    )
{
    BOOL ReturnValue = FALSE;
    DEFINE_FUNCTION(FontManagement, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        if (pfn.Kernel)
        {
            ReturnValue = (*pfn.Kernel)(pso, pfo, iEsc, cjIn, pvIn, cjOut, pvOut);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   PDEVOBJ::Escape
*
\**************************************************************************/

ULONG PDEVOBJ::Escape(
        SURFOBJ *pso
      ,   ULONG  iEsc
      ,   ULONG  cjIn
      ,   PVOID  pvIn
      ,   ULONG  cjOut
      ,   PVOID  pvOut
        )
{
    ULONG ReturnValue = 0;
    DEFINE_FUNCTION(Escape, pfn);

    if (gpepCSRSS)
    {
        ATTACHOBJ ato(this);

        ReturnValue = (*pfn.Kernel)(pso, iEsc, cjIn, pvIn, cjOut, pvOut);
    }

    return(ReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\umpdobj.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpdobj.cxx

Abstract:

    Object and memory management for um-km thunking

Environment:

    Windows NT user mode driver support

Revision History:

    09/16/97 -davidx-
        Created it.

--*/

#include "precomp.hxx"


#if !defined(_GDIPLUS_)

//
// Maximum number of pages for UMPD user mode memory heap
//

#define MAX_UMPD_HEAP   1024

//
// Create or initialize a UMPD user mode memory heap
//

PUMPDHEAP
UMPDOBJ::CreateUMPDHeap(void)
{
    PUMPDHEAP   pHeap;

    //
    // Allocate memory to hold the UMPDHEAP structure if necessary
    //

    if (!(pHeap = (PUMPDHEAP) PALLOCMEM(sizeof(UMPDHEAP), UMPD_MEMORY_TAG)))
        return NULL;

    //
    // Reserve the maximum address range if needed
    //

    NTSTATUS    Status;
    PVOID       p = NULL;
    SIZE_T      cj = MAX_UMPD_HEAP * PAGE_SIZE;

    Status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &p,
                    0,
                    &cj,
                    MEM_RESERVE,
                    PAGE_READWRITE);

    if (NT_SUCCESS(Status))
        pHeap->pAddress = p;
    else
    {
        VFREEMEM(pHeap);
        return NULL;
    }

    pHeap->AllocSize = 0;

    return pHeap;
}

VOID
UMPDOBJ::ResetHeap()
{
    ASSERTGDI(bWOW64(), "UMPDOBJ__ResetHeap called by none WOW64 printing\n");

    PROXYPORT proxyport(m_proxyPort);

    proxyport.HeapInit();
}

PUMPDHEAP
UMPDOBJ::InitUMPDHeap(
    PUMPDHEAP   pHeap
    )

{
    pHeap->AllocSize = 0;
    return pHeap;
}

//
// Grow a UMPD user mode memory heap by one more page
//

BOOL
UMPDOBJ::GrowUMPDHeap(
    PUMPDHEAP   pHeap,
    ULONG       ulBytesNeeded
    )

{
    PVOID       p;
    SIZE_T      NewCommitSize;
    HANDLE      hNewSecure;
    NTSTATUS    Status;

    NewCommitSize = ROUNDUP_MULTIPLE(pHeap->CommitSize + ulBytesNeeded, PAGE_SIZE);

    if (NewCommitSize > MAX_UMPD_HEAP * PAGE_SIZE)
    {
        WARNING("Not enough space for UMPD user mode memory heap\n");
        return FALSE;
    }

    //
    // Commit one more page and secure it
    //

    p = pHeap->pAddress;

    Status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &p,
                    0,
                    &NewCommitSize,
                    MEM_COMMIT,
                    PAGE_READWRITE);

    hNewSecure = NT_SUCCESS(Status) ?
                    MmSecureVirtualMemory(p, NewCommitSize, PAGE_READWRITE) :
                    NULL;

    if (hNewSecure == NULL)
    {
        WARNING("Failed to commit/secure more UMPD user mode memory\n");
        return FALSE;
    }

    if (pHeap->hSecure)
        MmUnsecureVirtualMemory(pHeap->hSecure);

    pHeap->hSecure = hNewSecure;
    pHeap->CommitSize = NewCommitSize;

    return TRUE;
}

//
// Destroy a UMPD user mode memory heap
//

VOID
DestroyUMPDHeap(
    PUMPDHEAP   pHeap
    )

{
    if (pHeap != NULL)
    {
        if (pHeap->hSecure)
            MmUnsecureVirtualMemory(pHeap->hSecure);

        if (pHeap->pAddress != NULL)
        {
            PVOID   pv = pHeap->pAddress;
            SIZE_T  cj = MAX_UMPD_HEAP * PAGE_SIZE;

            ZwFreeVirtualMemory(NtCurrentProcess(), &pv, &cj, MEM_RELEASE);
        }

        VFREEMEM(pHeap);
    }
}


//
// UMPDOBJ constructor
//

BOOL
UMPDOBJ::Init()
{
    PW32THREAD pThread;
    PW32PROCESS pw32Process;
    ULONG_PTR pPeb32;
#if defined(_WIN64)
    BOOL    bWOW64 = TRUE;
#endif
    RtlZeroMemory(this, sizeof(UMPDOBJ));

    m_magic = UMPD_MEMORY_TAG;

    pThread = W32GetCurrentThread();

    m_pNext = (PUMPDOBJ) pThread->pUMPDObjs;
#if defined(_WIN64)    
    if (pThread->pProxyPort == NULL)
    {
        pw32Process = W32GetCurrentProcess();

        if (pw32Process->W32PF_Flags & W32PF_WOW64)
        {
            PROXYPORT proxyport(MAX_UMPD_HEAP * PAGE_SIZE);

            if (proxyport.bValid())
            {
                pThread->pProxyPort = proxyport.GetProxyPort();
            }
            else
            {
                return FALSE;
            }
        }
        else
            bWOW64 = FALSE;
    }

    if (bWOW64)
    {
        m_proxyPort = (ProxyPort *) pThread->pProxyPort;

        ResetHeap();
    }
    else
#endif
    {
        // WINBUG 364408 what happens if these heaps fail to initialize?
        if (m_pNext == NULL)
        {
            if(pThread->pUMPDHeap == NULL)
            {
                pThread->pUMPDHeap = m_pHeap = CreateUMPDHeap();
            }
            else
            {
                m_pHeap = InitUMPDHeap((PUMPDHEAP) pThread->pUMPDHeap);
            }
        }
        else
        {
            m_pHeap = CreateUMPDHeap();
        }
    }
    
    m_clientTid = (PW32THREAD)PsGetCurrentThread();
    m_clientPid = W32GetCurrentPID();

    if (HmgInsertObject(this, HMGR_ALLOC_ALT_LOCK, UMPD_TYPE) == NULL)
    {
        return FALSE;
    }

    pThread->pUMPDObjs = (PVOID) this;

    return TRUE;
}

//
// UMPDOBJ destructor
//

VOID UMPDOBJ::Cleanup()
{
    W32GetCurrentThread()->pUMPDObjs = (PVOID) m_pNext;

    if (HmgRemoveObject((HOBJ)hGet(), 0, 1, TRUE, UMPD_TYPE))
    {
        //
        // Delete any PATHOBJ's returned by CLIPOBJ_ppoGetPath
        //
    
        if (m_poClip.kmobj != NULL)
            EngDeletePath((PATHOBJ *) m_poClip.kmobj);
    
        //
        // Destroy UMPD user mode memory heap if necessary
        //
    
        if(!bWOW64())
        {
            if (m_pNext != NULL && m_pHeap != NULL)
                    DestroyUMPDHeap(m_pHeap);
        }
    
        //
        // Unmap any cached font file view
        //
    
        if (m_pvFontBase != NULL)
            MmUnmapViewOfSection(m_pFontProcess, m_pvFontBase);
    
        vFreeFontLinks();
    }
    else
    {
        ASSERTGDI(FALSE, "UMPDOBJ::Cleanup() leaking UMPD handle\n");
    }    
}



BOOL UMPDOBJ::pxlo(
    XLATEOBJ   **ppxlo
    )

/*++

Routine Description:

    Thunk an XLATEOBJ to user mode

Arguments:

    ppxlo - Address of the variable containing the pointer to the kernel mode
        XLATEOBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    XLATEOBJ    *kmobj;
    PULONG      pulXlate;

    if ((kmobj = *ppxlo) == NULL)
        return TRUE;

    //
    // Copy the color lookup table
    //

    if (kmobj->cEntries)
    {
        PULONG  pulSrc;

        if ((pulXlate = (PULONG) AllocUserMem(kmobj->cEntries * sizeof(ULONG))) == NULL ||
            (pulSrc = kmobj->pulXlate) == NULL &&
            (pulSrc = XLATEOBJ_piVector(kmobj)) == NULL)
        {
            WARNING("Couldn't get XLATEOBJ color lookup table\n");
            return FALSE;
        }

        RtlCopyMemory(GetKernelPtr(pulXlate), pulSrc, kmobj->cEntries * sizeof(ULONG));
    }
    else
        pulXlate = NULL;

    //
    // Perform the standard object thunk
    //

    if (!ThunkDDIOBJ(&m_xlo, (PVOID *) ppxlo, sizeof(XLATEOBJ)))
        return FALSE;

    XLATEOBJ * pxlo = (XLATEOBJ *) GetKernelPtr(*ppxlo);

    pxlo->pulXlate = pulXlate;

    return TRUE;
}



BOOL UMPDOBJ::pso(
    PDDIOBJMAP  pMap,
    SURFOBJ     **ppso,
    BOOL        bLargeBitmap
    )

/*++

Routine Description:

    Thunk an SURFOBJ to user mode

Arguments:

    pMap - Address of the um-to-km object mapping structure

    ppso - Address of the variable containing the pointer to the kernel mode
        SURFOBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    SURFOBJ     *kmobj;
    PVOID       pvBits;

    if ((kmobj = *ppso) == NULL)
        return TRUE;

    //
    // If we're thunking a bitmap surface and the bitmap memory
    // is in kernel address space, we need to make a copy of it
    // in user address space.
    //

    if ((pvBits = kmobj->pvBits) != NULL &&
        (kmobj->iType == STYPE_BITMAP) &&
        bNeedThunk(kmobj->pvBits) &&
        !(bWOW64() && bLargeBitmap))
    {
        if (! ThunkMemBlock(&pvBits, kmobj->cjBits))
            return FALSE;
    }

    //
    // Perform the standard object thunk
    //

    if (! ThunkDDIOBJ(pMap, (PVOID *) ppso, sizeof(SURFOBJ)))
        return FALSE;

    SURFOBJ * pso = (SURFOBJ *) GetKernelPtr(*ppso);

    if (pvBits != kmobj->pvBits)
    {
        pso->pvBits = pvBits;
        pso->pvScan0 = (PBYTE) pvBits + ((PBYTE) kmobj->pvScan0 - (PBYTE) kmobj->pvBits);

        //
        //  umpd64 only
        //

        if (bWOW64())
        {
            kmobj->pvBits = pvBits;
            kmobj->pvScan0 = pso->pvScan0;
        }
    }

    return TRUE;
}


BOOL UMPDOBJ::pstro(
    STROBJ  **ppstro
    )

/*++

Routine Description:

    Thunk an STROBJ to user mode

Arguments:

    ppstro - Address of the variable containing the pointer to the kernel mode
        STROBJ to be thunked. Upon returning from this function, the variable
        contains the user mode object corresponding to the specified kernel mode object.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    STROBJ      *kmobj;
    PWSTR       pwszOrg;
    GLYPHPOS    *pgp;

    if ((kmobj = *ppstro) == NULL)
        return TRUE;

    //
    // Thunk STROBJ.pwszOrg field
    //

    if ((pwszOrg = kmobj->pwszOrg) != NULL &&
        !ThunkMemBlock((PVOID *) &pwszOrg, sizeof(WCHAR) * kmobj->cGlyphs))
    {
        return FALSE;
    }

    //
    // Thunk STROBJ.pgp field
    //

    if ((pgp = kmobj->pgp) != NULL)
    {
        if (! ThunkMemBlock((PVOID *) &pgp, sizeof(GLYPHPOS) * kmobj->cGlyphs))
            return FALSE;

        //
        // NULL out GLYPHPOS.pgdf field to force the driver
        // to call FONTOBJ_cGetGlyphs.
        //
        GLYPHPOS    *kmpgp = (GLYPHPOS *) GetKernelPtr(pgp);

        for (ULONG i=0; i < kmobj->cGlyphs; i++)
            kmpgp[i].pgdf = NULL;
    }

    //
    // Perform the standard object thunk
    //

    if (!ThunkDDIOBJ(&m_stro, (PVOID *) ppstro, sizeof(STROBJ)))
        return FALSE;

    STROBJ * pstro = (STROBJ *) GetKernelPtr(*ppstro);

    pstro->pwszOrg = pwszOrg;
    pstro->pgp = pgp;

    return TRUE;
}



BOOL UMPDOBJ::ThunkLINEATTRS(
    PLINEATTRS *pplineattrs
    )

/*++

Routine Description:

    Thunk a LINEATTRS structure from kernel mode to user mode

Arguments:

    pplineattrs - On input, contains the address of the kernel mode
        LINEATTRS structure to be thunked. On output, contains the
        address of the thunked user mode copy of LINEATTRS structure.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PLINEATTRS  plineattrsKM;
    PVOID       pStyle;
    ULONG       ulStyleSize;

    if ((plineattrsKM = *pplineattrs) == NULL)
        return TRUE;

    pStyle = plineattrsKM->pstyle;
    ulStyleSize = plineattrsKM->cstyle * sizeof(FLOAT_LONG);

    if (! ThunkMemBlock((PVOID *) pplineattrs, sizeof(LINEATTRS)) ||
        ! ThunkMemBlock(&pStyle, ulStyleSize))
    {
        return FALSE;
    }
    else
    {
        PLINEATTRS plineattrs = (PLINEATTRS) GetKernelPtr(*pplineattrs);

        plineattrs->pstyle = (PFLOAT_LONG) pStyle;
        return TRUE;
    }
}


PATHOBJ *UMPDOBJ::GetCLIPOBJPath(
    CLIPOBJ *pco
    )

/*++

Routine Description:

    Implement CLIPOBJ_ppoGetPath for user mode printer driver

Arguments:

    pco - Points to a user mode CLIPOBJ

Return Value:

    Pointer to user mode PATHOBJ structure
    NULL if there is an error

--*/

{
    PATHOBJ *ppokm, *ppoum;

    //
    // Note: During the same DDI entrypoint, drivers must
    // call EngDeletePath after each CLIPOBJ_ppoGetPath.
    //

    if (m_poClip.umobj ||
        ! (ppokm = ppoum = (pco = GetDDIOBJ(pco)) ? CLIPOBJ_ppoGetPath(pco) : NULL))
    {
        return NULL;
    }

    if (! ppoClip(&ppoum))
    {
        EngDeletePath(ppokm);
        return NULL;
    }

    return ppoum;
}



VOID UMPDOBJ::DeleteCLIPOBJPath(
    PATHOBJ *ppo
    )

/*++

Routine Description:

    Implement EngDeletePath for user mode printer driver

Arguments:

    ppo - Points to user mode PATHOBJ to be deleted.
        This pointer must come from GetCLIPOBJPath.

Return Value:

    NONE

--*/

{
    if (ppo != NULL && ppo == m_poClip.umobj)
    {
        EngDeletePath((PATHOBJ *) m_poClip.kmobj);
        m_poClip.umobj = m_poClip.kmobj = NULL;
    }
}



CLIPOBJ *UMPDOBJ::CreateCLIPOBJ()

/*++

Routine Description:

    Implement EngCreateClip for user-mode drivers

Arguments:

    NONE

Return Value:

    Pointer to user mode CLIPOBJ structure
    NULL if there is an error

--*/

{
    CLIPOBJ *pcokm, *pcoum;

    //
    // Note: During the same DDI entrypoint, drivers must
    // call EngDeleteClip after each EngCreateClip.
    //

    if (m_coCreated.umobj ||
        ! (pcokm = pcoum = EngCreateClip()))
    {
        return NULL;
    }

    if (! pcoCreated(&pcoum))
    {
        EngDeleteClip(pcokm);
        return NULL;
    }

    return pcoum;
}



VOID UMPDOBJ::DeleteCLIPOBJ(
    CLIPOBJ *pco
    )

/*++

Routine Description:

    Implement EngDeleteClip for user-mode drivers

Arguments:

    pco - Points to user-mode CLIPOBJ to be deleted
        This must have come from EngCreateClip.

Return Value:

    NONE

--*/

{
    if (pco != NULL && pco == m_coCreated.umobj)
    {
        EngDeleteClip((CLIPOBJ *) m_coCreated.kmobj);
        m_coCreated.umobj = m_coCreated.kmobj = NULL;
    }
}



XFORMOBJ *UMPDOBJ::GetFONTOBJXform(
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Implement FONTOBJ_pxoGetXform for user mode printer driver

Arguments:

    pfo - Points to a user mode FONTOBJ

Return Value:

    Pointer to a user mode XFORMOBJ structure
    NULL if there is an error

--*/

{
    XFORMOBJ *pxo;

    //
    // Check if this function has been called already
    // during the current DDI entrypoint
    //

    if (! (pfo = GetDDIOBJ(pfo)))
        return NULL;

    if (m_xoFont.umobj != NULL)
        pxo = (XFORMOBJ *) m_xoFont.umobj;
    else
    {
        RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
        
        UMPDAcquireRFONTSem(rfto, this, 0, 0, NULL);

        if (!(pxo = FONTOBJ_pxoGetXform(pfo)) || !pxoFont(&pxo))
            pxo = NULL;

        UMPDReleaseRFONTSem(rfto, this, NULL, NULL, NULL);
    }

    return pxo;
}



GLYPHBITS *UMPDOBJ::CacheGlyphBits(
    GLYPHBITS *pgb
    )

/*++

Routine Description:

    Thunk and cache GLYPHBITS structure returned by FONTOBJ_cGetGlyphs

Arguments:

    pgb - Points to kernel mode GLYPHBITS structure

Return Value:

    Pointer to user mode GLYPHBITS structure
    NULL if there is an error

--*/

{
    GLYPHBITS  *pgbum = NULL;
    ULONG       ulSize;

    ASSERTGDI(pgb != NULL, "No glyph bits!\n");

    ulSize = offsetof(GLYPHBITS, aj) +
             ((pgb->sizlBitmap.cx + 7) / 8) * pgb->sizlBitmap.cy;

    if (ulSize <= m_gbSize)
    {
        //
        // Reuse previous GLYPHBITS buffer if possible
        //

        pgbum = m_pgb;
    }
    else
    {
        if ((pgbum = (GLYPHBITS *) AllocUserMem(ulSize)) != NULL)
        {
            m_pgb = pgbum;
            m_gbSize = ulSize;
        }
    }

    if (pgbum != NULL)
        RtlCopyMemory(pgbum, pgb, ulSize);

    return pgbum;
}



PATHOBJ *UMPDOBJ::CacheGlyphPath(
    PATHOBJ *ppo
    )

/*++

Routine Description:

    Thunk and cache PATHOBJ structure returned by FONTOBJ_cGetGlyphs

Arguments:

    pgb - Points to kernel mode PATHOBJ structure

Return Value:

    Pointer to user mode PATHOBJ structure
    NULL if there is an error

--*/

{
    ASSERTGDI(ppo != NULL, "No glyph path!\n");

    if (m_poGlyph.umobj != NULL)
    {
        //
        // Reuse the previous PATHOBJ if possible
        //

        *((PATHOBJ *) m_poGlyph.umobj) = *ppo;
        m_poGlyph.kmobj = ppo;

        ppo = (PATHOBJ *) m_poGlyph.umobj;
    }
    else if (! ppoGlyph(&ppo))
        ppo = NULL;

    return ppo;
}



//
// User mode data structure used for storing the surface object
// thunked by UMPDOBJ::LockSurface.
//

typedef struct _UMSO {

    DWORD   dwSignature;
    HSURF   hsurf;
    SURFOBJ so;

} UMSO, *PUMSO;

#define UMSO_SIGNATURE  'UMSO'



SURFOBJ *UMPDOBJ::LockSurface(
    HSURF   hsurf
    )

/*++

Routine Description:

    Implement EngLockSurface for user mode printer driver

Arguments:

    hsurf - Handle to the surface to be locked

Return Value:

    Pointer to a user-mode SURFOBJ structure corresponding to
    the specified surface handle. NULL if there is an error.

--*/

{
    SURFOBJ *psokm;
    PUMSO   pumso = NULL;

    if (hsurf == NULL || (psokm = EngLockSurface(hsurf)) == NULL)
        return NULL;

    //
    // Check if the surface bitmap uses kernel mode memory
    //

    if (psokm->pvBits != NULL &&
        psokm->iType == STYPE_BITMAP &&
        IS_SYSTEM_ADDRESS(psokm->pvBits))
    {
        WARNING("EngLockSurface can't handle kernel mode bitmap\n");
    }
    else if (pumso = (PUMSO) EngAllocUserMem(sizeof(UMSO), UMPD_MEMORY_TAG))
    {
        //
        // We're can't allocate memory from our cache here because
        // pso returned by EngLockSurface may potentially out-live
        // the current DDI entrypoint and/or the current thread.
        //

        pumso->dwSignature = UMSO_SIGNATURE;
        pumso->hsurf = hsurf;
        pumso->so = *psokm;

        //
        // if this is a surface that has been called by EngAssociateSurface,
        // we give them back the original dhpdev
        //
        if (pumso->so.dhpdev)
        {
            PUMDHPDEV pUMdhpdev = (PUMDHPDEV)pumso->so.dhpdev;
            pumso->so.dhpdev = pUMdhpdev->dhpdev;
        }
    }

    EngUnlockSurface(psokm);

    return pumso ? &pumso->so : NULL;
}



VOID UMPDOBJ::UnlockSurface(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implement EngUnlockSurface for user mode printer driver

Arguments:

    pso - Pointer to user mode SURFOBJ to be unlocked

Return Value:

    NONE

--*/

{
    PUMSO   pumso;

    if (pso != NULL)
    {
        __try
        {
           pumso = (PUMSO) ((PBYTE) pso - offsetof(UMSO, so));

           ProbeForRead (pumso, sizeof(UMSO), sizeof(BYTE));

           if (pumso->dwSignature != UMSO_SIGNATURE ||
               pumso->hsurf == NULL)
           {
               WARNING("Invalid surface in EngUnlockSurface\n");
               return;
           }

           EngFreeUserMem(pumso);

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("Bad user mode SURFOBJ\n");
        }

    }
}



SURFOBJ *UMPDSURFOBJ::GetLockedSURFOBJ(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Map a user mode SURFOBJ to its kernel mode counterpart.
    This pointer must be returned by a previous called to
    UMPDOBJ::LockSurface.

Arguments:

    pso - Pointer to user mode SURFOBJ

Return Value:

    Pointer to kernel mode SURFOBJ corresponding to the specified
    user mode SURFOBJ. NULL if there is an error.

--*/

{
    PUMSO   pumso;
    HSURF   hsurf = NULL;

    if (pso != NULL)
    {
        __try
        {
            pumso = (PUMSO) ((PBYTE) pso - offsetof(UMSO, so));

            ProbeForRead (pumso, sizeof(UMSO), sizeof(BYTE));

            if (pumso->dwSignature == UMSO_SIGNATURE)
                hsurf = pumso->hsurf;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("Bad user mode SURFOBJ\n");
            hsurf = NULL;
        }
    }

    return hsurf ? EngLockSurface(hsurf) : NULL;
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\verifier.cxx ===
/******************************Module*Header*******************************\
* Module Name: verifier.cxx
*
* GRE DriverVerifier support.
*
* If DriverVerifier is enabled for a particular component, the loader will
* substitute VerifierEngAllocMem for EngAllocMem, etc.  The VerifierEngXX
* functions will help test the robustness of components that use EngXX calls
* by injecting random failures and using special pool (i.e., test low-mem
* behavior and check for buffer overruns).
*
* See ntos\mm\verifier.c for further details on DriverVerifier support in
* the memory manager.
*
* See sdk\inc\ntexapi.h for details on the DriverVerifier flags.
*
* Created: 19-Jan-1999 11:51:51
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"
#include "verifier.hxx"

extern BOOL G_fConsole;                 // gre\misc.cxx

//
// Amount of elapsed time before we begin random failures.
// Gives system time to stabilize.
//
// Taken from ntos\mm\verifier.c
//

LARGE_INTEGER GreBootTime;
const LARGE_INTEGER VerifierRequiredTimeSinceBoot = {(ULONG)(40 * 1000 * 1000 * 10), 1};

//
// Global verifier state.
//

VSTATE gvs = {
    0,                  // fl
    FALSE,              // bSystemStable
    0,                  // ulRandomSeed
    0xf,                // ulFailureMask
    0,                  // ulDebugLevel
    (HSEMAPHORE) NULL   // hsemPoolTracker
};

//
// Put initialization functions in the INIT segment.
//

#pragma alloc_text(INIT, VerifierInitialization)


/******************************Public*Routine******************************\
* VerifierInitialization
*
* Initializes the DriverVerifier support in GRE.  The loader will actually
* handle the fixup of the EngAllocMem, etc. during the loading of components
* listed as under the verifier.
*
* History:
*  19-Jan-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define VERIFIERFUNC(pfn)   ((PDRIVER_VERIFIER_THUNK_ROUTINE)(pfn))

const DRIVER_VERIFIER_THUNK_PAIRS gaVerifierFunctionTable[] = {
    {VERIFIERFUNC(EngAllocMem           ), VERIFIERFUNC(VerifierEngAllocMem           )},
    {VERIFIERFUNC(EngFreeMem            ), VERIFIERFUNC(VerifierEngFreeMem            )},
    {VERIFIERFUNC(EngAllocUserMem       ), VERIFIERFUNC(VerifierEngAllocUserMem       )},
    {VERIFIERFUNC(EngFreeUserMem        ), VERIFIERFUNC(VerifierEngFreeUserMem        )},
    {VERIFIERFUNC(EngCreateBitmap       ), VERIFIERFUNC(VerifierEngCreateBitmap       )},
    {VERIFIERFUNC(EngCreateDeviceSurface), VERIFIERFUNC(VerifierEngCreateDeviceSurface)},
    {VERIFIERFUNC(EngCreateDeviceBitmap ), VERIFIERFUNC(VerifierEngCreateDeviceBitmap )},
    {VERIFIERFUNC(EngCreatePalette      ), VERIFIERFUNC(VerifierEngCreatePalette      )},
    {VERIFIERFUNC(EngCreateClip         ), VERIFIERFUNC(VerifierEngCreateClip         )},
    {VERIFIERFUNC(EngCreatePath         ), VERIFIERFUNC(VerifierEngCreatePath         )},
    {VERIFIERFUNC(EngCreateWnd          ), VERIFIERFUNC(VerifierEngCreateWnd          )},
    {VERIFIERFUNC(EngCreateDriverObj    ), VERIFIERFUNC(VerifierEngCreateDriverObj    )},
    {VERIFIERFUNC(BRUSHOBJ_pvAllocRbrush), VERIFIERFUNC(VerifierBRUSHOBJ_pvAllocRbrush)},
    {VERIFIERFUNC(CLIPOBJ_ppoGetPath    ), VERIFIERFUNC(VerifierCLIPOBJ_ppoGetPath    )}
};

BOOL
VerifierInitialization()
{
    BOOL bRet = FALSE;
    NTSTATUS Status;
    ULONG Level;

#ifdef VERIFIER_STATISTICS
    //
    // Clear statistics.
    //

    RtlZeroMemory((VOID *) gvs.avs, sizeof(VSTATS) * VERIFIER_INDEX_LAST);

#endif

    //
    // Get the DriverVerifier flags.  No point in going on if we can't
    // get this.
    //

    Status = MmIsVerifierEnabled (&Level);

    if ((NT_SUCCESS(Status) || (Status == STATUS_INFO_LENGTH_MISMATCH)) &&
        (Level & DRIVER_VERIFIER_GRE_MASK))
    {
        //
        // Some things should only be done once, during system initalization.
        // So don't do them for Hydra sessions.
        //

        if (G_fConsole)
        {
            //
            // Remember the boot time.  We do not allow random failures for
            // a period time right after boot to allow the system time to
            // become quiescent.
            //

            KeQuerySystemTime(&GreBootTime);

            //
            // Give loader Verifier function substitution table.
            //

            Status = MmAddVerifierThunks ((VOID *) gaVerifierFunctionTable,
                                          sizeof(gaVerifierFunctionTable));

            if (NT_SUCCESS(Status))
            {
                VERIFIERWARNING(1, "VerifierInitialization: thunks accepted\n");
                bRet = TRUE;
            }
        }
        else
        {
            //
            // On Hydra systems, allow failures during GRE initialization.
            // So disable the check that allows the system time to stabilize.
            //

            gvs.bSystemStable = TRUE;
            Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
            bRet = TRUE;
        }
    }
    else
    {
        WARNING("VerifierInitialization: failed to get info from ntoskrnl\n");
    }

    //
    // Disable pool tracking always for graphic drivers. (NTBUG:421768)
    //

    Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;

    // //
    // // Initialize pool tracking if needed.
    // //
    // if (Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
    // {
    //     //
    //     // Initialize doubly linked list used to track pool allocations.
    //     //
    //
    //     InitializeListHead(&gvs.lePoolTrackerHead);
    //
    //     //
    //     // Initialize the tracking list lock.  Turn off pool allocations
    //     // if semaphore creation fails.
    //     //
    //
    //     gvs.hsemPoolTracker = GreCreateSemaphore();
    //     if (!gvs.hsemPoolTracker)
    //         Level &= ~DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
    // }

    //
    // Keep a local copy of the DriverVerifier flags.
    //
    // Note that the DriverVerifier flags can change on the fly without
    // rebooting so this is a very transient copy.
    //
    // Wait until we know everthing is OK.
    //

    gvs.fl = (bRet) ? Level : 0;

    return bRet;
}


/******************************Public*Routine******************************\
* VerifierRandomFailure
*
* Occasionally returns TRUE, indicating that Verifier should inject an
* allocation failure.
*
* See ntos\mm\verifier.c for further details.
*
* History:
*  19-Jan-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL
VerifierRandomFailure(ULONG ulEntry)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER CurrentTime;

    #ifdef VERIFIER_STATISTICS
        ASSERTGDI(ulEntry < VERIFIER_INDEX_LAST,
                  "VerifierRandomFailure: bad index\n");
    #else
        DONTUSE(ulEntry);
    #endif

    //
    // Check if random failures enabled.
    //

    if (gvs.fl & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES)
    {
        //
        // Don't fail any requests in the first 7 or 8 minutes as we want to
        // give the system enough time to boot.
        //

        if (gvs.bSystemStable == FALSE)
        {
            KeQuerySystemTime(&CurrentTime);
            if (CurrentTime.QuadPart > (GreBootTime.QuadPart + VerifierRequiredTimeSinceBoot.QuadPart))
            {
                //
                // Enough time has elapsed to begin failures.
                //

                VERIFIERWARNING(1, "VerifierRandomFailure: injected failures enabled\n");
                gvs.bSystemStable = TRUE;
                gvs.ulRandomSeed  = CurrentTime.LowPart;

            #ifdef VERIFIER_STATISTICS
                //
                // Reset statistics.
                //

                RtlZeroMemory((VOID *) gvs.avs, sizeof(VSTATS) * VERIFIER_INDEX_LAST);

            #endif
            }
        }

    #ifdef VERIFIER_STATISTICS
        //
        // Record number of attempts.
        //

        InterlockedIncrement((LONG *) &gvs.avs[ulEntry].ulAttempts);

    #endif

        //
        // Once system is stable, randomly enable failure.
        //

        if (gvs.bSystemStable)
        {
            if ((RtlRandom(&gvs.ulRandomSeed) & gvs.ulFailureMask) == 0)
            {
                bRet = TRUE;

            #ifdef VERIFIER_STATISTICS
                //
                // Record number of injected failures.
                //

                InterlockedIncrement((LONG *) &gvs.avs[ulEntry].ulFailures);

            #endif
            }
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* VerifierEngAllocMem
*
* VerifierEngAllocMem can put allocations under special pool, track
* allocations, and inject random allocation failures.
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY
VerifierEngAllocMem(
    ULONG fl,
    ULONG cj,
    ULONG tag
    )
{
    PVOID pvRet;
    POOL_TYPE poolType;
    EX_POOL_PRIORITY poolPriority;
    ULONG cjOrig = cj;

    //
    // Inject random failures.
    //

    if (VerifierRandomFailure(VERIFIER_INDEX_EngAllocMem))
    {
        VERIFIERWARNING(1, "VerifierEngAllocMem: inject failure\n");
        return NULL;
    }

    //
    // Check if special pool is enabled.
    //

    if (gvs.fl & DRIVER_VERIFIER_SPECIAL_POOLING)
        poolPriority = (EX_POOL_PRIORITY) (HighPoolPrioritySpecialPoolOverrun | POOL_SPECIAL_POOL_BIT);
    else
        poolPriority = HighPoolPrioritySpecialPoolOverrun;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return NULL;

    //
    // Adjust size to include VERIFIERTRACKHDR.
    //

    if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
    {
        if (cj <= (MAXULONG - sizeof(VERIFIERTRACKHDR)))
            cj += ((ULONG) sizeof(VERIFIERTRACKHDR));
        else
            return NULL;
    }

    //
    // Adjust size to include ENGTRACKHDR header.
    //
    // Sundown note: sizeof(ENGTRACKHDR) will fit in 32-bit, so ULONG cast OK
    //

    if (fl & FL_NONPAGED_MEMORY)
        poolType = (POOL_TYPE) (NonPagedPool | gSessionPoolMask);
    else
        poolType = (POOL_TYPE) (PagedPool | gSessionPoolMask);

    if (cj <= (MAXULONG - sizeof(ENGTRACKHDR)))
        cj += ((ULONG) sizeof(ENGTRACKHDR));
    else
        return NULL;

    if (cj >= (PAGE_SIZE * 10000))
    {
        WARNING("EngAllocMem: temp buffer >= 10000 pages");
        return NULL;
    }

    //
    // Need to call ExAllocatePoolWithTagPriority, which allows for
    // special pool allocations.
    //

    pvRet = ExAllocatePoolWithTagPriority(poolType, cj, tag, poolPriority);

    if (pvRet)
    {
        if (fl & FL_ZERO_MEMORY)
        {
            RtlZeroMemory(pvRet, cj);
        }

        //
        // Hydra pool tracking.
        //

        //
        // Add allocation to the tracking list.
        //

        ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pvRet;
        MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_VERIFIERALLOCMEM);

        //
        // Adjust return pointer to hide the LIST_ENTRY header.
        //

        pvRet = (PVOID) (pethNew + 1);

        //
        // Verifier pool tracking.  Separate from Hydra
        // pool tracking which handles session cleanup.
        //

        if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            //
            // Add to the tracking list.
            //

            VERIFIERTRACKHDR *pvthNew = (VERIFIERTRACKHDR *) pvRet;

            pvthNew->ulSize = cjOrig;
            pvthNew->ulTag = tag;

            GreAcquireSemaphore(gvs.hsemPoolTracker);
            InsertTailList(&gvs.lePoolTrackerHead, ((PLIST_ENTRY) pvthNew));
            GreReleaseSemaphore(gvs.hsemPoolTracker);

            //
            // Adjust return pointer to hide the header.
            //

            pvRet = (PVOID) (pvthNew + 1);
        }

    }

    return pvRet;
}


/******************************Public*Routine******************************\
* VerifierEngFreeMem
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY
VerifierEngFreeMem(
    PVOID pv
    )
{
    if (pv)
    {
        //
        // Verifier pool tracking.
        //

        if (gvs.fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            //
            // Remove victim from tracking list.
            //

            VERIFIERTRACKHDR *pvthVictim = ((VERIFIERTRACKHDR *) pv) - 1;

            GreAcquireSemaphore(gvs.hsemPoolTracker);
            RemoveEntryList(((PLIST_ENTRY) pvthVictim));
            GreReleaseSemaphore(gvs.hsemPoolTracker);

            //
            // Adjust pointer to the header.  This is base of allocation
            // if not hydra.
            //

            pv = (PVOID) pvthVictim;
        }

        //
        // Hydra pool tracking.
        //

        //
        // Remove victim from tracking list.
        //

        ENGTRACKHDR *pethVictim = ((ENGTRACKHDR *) pv) - 1;
        MultiUserGreTrackRemoveEngResource(pethVictim);

        //
        // Adjust pointer to the header.  This is base of allocation if
        // hydra.
        //

        pv = (PVOID) pethVictim;

        ExFreePool(pv);
    }

    return;
}


/******************************Public*Routine******************************\
* VerififierEngAllocUserMem
*
* This routine allocates a piece of memory for USER mode and locks it
* down.  A driver must be very careful with this memory as it is only
* valid for this process.
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY
VerifierEngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    )
{
    //
    // Inject random failures.
    //

    if (VerifierRandomFailure(VERIFIER_INDEX_EngAllocUserMem))
    {
        VERIFIERWARNING(1, "VerifierEngAllocUserMem: inject failure\n");
        return NULL;
    }
    else
        return EngAllocUserMem(cj, tag);
}


/******************************Public*Routine******************************\
* VerifierEngFreeUserMem
*
* History:
*  19-Jan-1999 -by-  Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY
VerifierEngFreeUserMem(
    PVOID pv
    )
{
    //
    // Right now, there is no difference between this and EngFreeUserMem.
    // However, we may soon add some tracking info, so here is a stub.
    //

    EngFreeUserMem(pv);

    return;
}

/******************************Public*Routine******************************\
* VerifierEngCreateBitmap
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY VerifierEngCreateBitmap(
    SIZEL sizl,
    LONG  lWidth,
    ULONG iFormat,
    FLONG fl,
    PVOID pvBits
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateBitmap))
    {
        VERIFIERWARNING(1, "VerifierEngCreateBitmap: inject failure\n");
        return NULL;
    }
    else
        return EngCreateBitmap(sizl, lWidth, iFormat, fl, pvBits);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDeviceSurface
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HSURF APIENTRY VerifierEngCreateDeviceSurface(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDeviceSurface))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDeviceSurface: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDeviceSurface(dhsurf, sizl, iFormatCompat);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDeviceBitmap
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY VerifierEngCreateDeviceBitmap(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDeviceBitmap))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDeviceBitmap: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDeviceBitmap(dhsurf, sizl, iFormatCompat);
}

/******************************Public*Routine******************************\
* VerifierEngCreatePalette
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HPALETTE APIENTRY VerifierEngCreatePalette(
    ULONG  iMode,
    ULONG  cColors,
    ULONG *pulColors,
    FLONG  flRed,
    FLONG  flGreen,
    FLONG  flBlue
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreatePalette))
    {
        VERIFIERWARNING(1, "VerifierEngCreatePalette: inject failure\n");
        return NULL;
    }
    else
        return EngCreatePalette(iMode, cColors, pulColors,
                                flRed, flGreen, flBlue);
}

/******************************Public*Routine******************************\
* VerifierEngCreateClip
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

CLIPOBJ * APIENTRY VerifierEngCreateClip()
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateClip))
    {
        VERIFIERWARNING(1, "VerifierEngCreateClip: inject failure\n");
        return NULL;
    }
    else
        return EngCreateClip();
}

/******************************Public*Routine******************************\
* VerifierEngCreatePath
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PATHOBJ * APIENTRY VerifierEngCreatePath()
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreatePath))
    {
        VERIFIERWARNING(1, "VerifierEngCreatePath: inject failure\n");
        return NULL;
    }
    else
        return EngCreatePath();
}

/******************************Public*Routine******************************\
* VerifierEngCreateWnd
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

WNDOBJ * APIENTRY VerifierEngCreateWnd(
    SURFOBJ         *pso,
    HWND             hwnd,
    WNDOBJCHANGEPROC pfn,
    FLONG            fl,
    int              iPixelFormat
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateWnd))
    {
        VERIFIERWARNING(1, "VerifierEngCreateWnd: inject failure\n");
        return NULL;
    }
    else
        return EngCreateWnd(pso, hwnd, pfn, fl, iPixelFormat);
}

/******************************Public*Routine******************************\
* VerifierEngCreateDriverObj
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HDRVOBJ APIENTRY VerifierEngCreateDriverObj(
    PVOID pvObj,
    FREEOBJPROC pFreeObjProc,
    HDEV hdev
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_EngCreateDriverObj))
    {
        VERIFIERWARNING(1, "VerifierEngCreateDriverObj: inject failure\n");
        return NULL;
    }
    else
        return EngCreateDriverObj(pvObj, pFreeObjProc, hdev);
}

/******************************Public*Routine******************************\
* VerifierBRUSHOBJ_pvAllocRbrush
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID APIENTRY VerifierBRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo,
    ULONG     cj
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_BRUSHOBJ_pvAllocRbrush))
    {
        VERIFIERWARNING(1, "VerifierBRUSHOBJ_pvAllocRbrush: inject failure\n");
        return NULL;
    }
    else
        return BRUSHOBJ_pvAllocRbrush(pbo, cj);
}

/******************************Public*Routine******************************\
* VerifierCLIPOBJ_ppoGetPath
*
* Only supports random failure.
*
* History:
*  02-Feb-1999 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PATHOBJ* APIENTRY VerifierCLIPOBJ_ppoGetPath(
    CLIPOBJ* pco
    )
{
    if (VerifierRandomFailure(VERIFIER_INDEX_CLIPOBJ_ppoGetPath))
    {
        VERIFIERWARNING(1, "VerifierCLIPOBJ_ppoGetPath: inject failure\n");
        return NULL;
    }
    else
        return CLIPOBJ_ppoGetPath(pco);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\umpdeng.cxx ===
/******************************Module*Header*******************************\
* Module Name: umpdeng.c
*   This file contains stubs for calls made by umpdeng.c from gdi32.dll
*
* Created: 8/5/97
* Author:  Lingyun Wang [lingyunw]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#if !defined(_GDIPLUS_)

//
// Macro for extracting the topmost UMPDOBJS structure
// associated with the current thread.
//
// Put the following line at the beginning of each NtGdi...
// function (after all other local variable declarations):
//
//  EXTRACT_THREAD_UMPDOBJS retVal;
//
// where retVal is the error return value. If the function doesn't return
// any value, simply omit the retVal.
//

#define EXTRACT_THREAD_UMPDOBJS \
        PUMPDOBJ pUMObjs = (PUMPDOBJ) W32GetCurrentThread()->pUMPDObj; \
        if (pUMObjs)                                                   \
            pUMObjs->vSetFlags(UMPDOBJ_ENGCALL);                       \
        else                                                           \
            return

#define FIXUP_THREAD_UMPDOBJS   \
        if (pUMObjs)                                                   \
            pUMObjs->vClearFlags(UMPDOBJ_ENGCALL);


//
// determine whether a BRUSHOBJ is a pattern brush
//

#define ISPATBRUSH(_pbo) ((_pbo) && (_pbo)->iSolidColor == 0xffffffff)
#define MIXNEEDMASK(_mix) (((_mix) & 0xf) != (((_mix) >> 8) & 0xf))

//
// Map a user-mode BRUSHOBJ to its kernel-mode counterpart
//

#define MAP_UM_BRUSHOBJ(pUMObjs, pbo, pboTemp) \
        { \
            BRUSHOBJ   *tempVar; \
            tempVar = (pUMObjs)->GetDDIOBJ(pbo); \
            pbo = tempVar ? tempVar : CaptureAndFakeBRUSHOBJ(pbo, pboTemp); \
        }

//
// "Manufacture" a kernel-mode BRUSHOBJ structure using
// the user-mode BRUSHOBJ as template
//

BRUSHOBJ *
CaptureAndFakeBRUSHOBJ(
    BRUSHOBJ   *pboUm,
    BRUSHOBJ   *pboKm
    )

{
    if (pboUm)
    {
        __try
        {
            // Copy user-mode BRUSHOBJ structure into kernel-mode memory

            *pboKm = ProbeAndReadStructure(pboUm, BRUSHOBJ);

            // Succeed only if BRUSHOBJ represents a solid color brush

            if (!ISPATBRUSH(pboKm))
                pboKm->pvRbrush = NULL;
            else
                pboKm = NULL;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            pboKm = NULL;
        }
    }
    else
        pboKm = NULL;

    return pboKm;
}


//
// Capture a user-mode CLIPOBJ that orignated from EngCreateClip
//

CLIPOBJ *
CaptureAndMungeCLIPOBJ(
    CLIPOBJ *pcoUm,
    CLIPOBJ *pcoKm,
    SIZEL   *szLimit
    )

{
    CLIPOBJ co;

    //
    // Capture user-mode CLIPOBJ structure into a temporary buffer
    //

    if (pcoUm)
    {
        __try
        {
            co = ProbeAndReadStructure(pcoUm, CLIPOBJ);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            pcoKm = NULL;
        }

        //
        // Munge the relevant fields in kernel-mode CLIPOBJ
        //

        if (pcoKm)
        {
            switch (co.iDComplexity)
            {
            case DC_RECT:

                if (szLimit)
                {
                    co.rclBounds.left = max(0, co.rclBounds.left);
                    co.rclBounds.top = max(0, co.rclBounds.top);
                    co.rclBounds.right = min(szLimit->cx, co.rclBounds.right);
                    co.rclBounds.bottom = min(szLimit->cy, co.rclBounds.bottom);
                }

                pcoKm->rclBounds = co.rclBounds;

                // fall through

            case DC_TRIVIAL:

                pcoKm->iDComplexity = co.iDComplexity;
                break;

            default:

                WARNING("User-mode CLIPOBJ is not DC_TRIVIAL or DC_RECT\n");
                pcoKm = NULL;
                break;
            }
        }
    }
    else
    {
        ASSERTGDI(pcoKm == NULL, "CaptureAndMungeCLIPOBJ: invalid pcoKm\n");
    }

    return pcoKm;
}


/******************************Public*Routine******************************\
* GetSTROBJGlyphMode
*
* helper function to determine the Glyphmode based on strobj
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
ULONG GetSTROBJGlyphMode (STROBJ *pstro)
{
      return (((ESTROBJ*)pstro)->prfo->prfnt->ulContent);
}

__inline
BOOL bOrder (RECTL *prcl)
{
    return ((prcl->left < prcl->right) && (prcl->top < prcl->bottom));
}

/******************************Public*Routine******************************\
* helper functions to copy user memory
*
* CaptureRECTL CapturePOINTL  CapturePOINTFIX
* CaptureLINEATTRS  CaptureCOLORADJUSTMENT
*
* Note: prclFrom points to the captured rect on the way back
* Note: Needs to be called within try/except
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
VOID CaptureRECTL (RECTL **pprclFrom, RECTL *prclTo)
{
    if (*pprclFrom)
    {
        *prclTo = ProbeAndReadStructure(*pprclFrom,RECTL);

        //
        // repoint pprclFrom to prclTo
        //
        *pprclFrom = prclTo;
    }

    return;
}

__inline
VOID CapturePOINTL (POINTL **ppptlFrom, POINTL *pptlTo)
{
    if (*ppptlFrom)
    {
        *pptlTo = ProbeAndReadStructure(*ppptlFrom,POINTL);

        *ppptlFrom = pptlTo;
    }
    return;
}

__inline
VOID CapturePOINTFIX (POINTFIX **ppptfxFrom, POINTFIX *pptfxTo)
{
    if (*ppptfxFrom)
    {
       *pptfxTo = ProbeAndReadStructure(*ppptfxFrom,POINTFIX);

       *ppptfxFrom = pptfxTo;
    }

    return;
}

//
// the calling routine needs to free pStyle
//
// Note: plineFrom will be changed to plineTo upon returning from this routine
// so to save some changes into the lower level calls
//
__inline
BOOL bCaptureLINEATTRS (LINEATTRS **pplineFrom, LINEATTRS *plineTo)
{
    BOOL bRet = TRUE;

    if (*pplineFrom)
    {
        PFLOAT_LONG pstyle = NULL;

        __try
        {

          *plineTo = ProbeAndReadStructure(*pplineFrom,LINEATTRS);

          if (plineTo->pstyle)
          {
              if (BALLOC_OVERFLOW1(plineTo->cstyle, FLOAT_LONG))
                  return FALSE;

              ProbeForRead(plineTo->pstyle, plineTo->cstyle*sizeof(FLOAT_LONG), sizeof(BYTE));

              pstyle = (PFLOAT_LONG)PALLOCNOZ(plineTo->cstyle*sizeof(FLOAT_LONG), UMPD_MEMORY_TAG);

              if (!pstyle)
              {
                  //
                  // so we won't free it later
                  //
                  plineTo->pstyle = NULL;
                  bRet = FALSE;
              }
              else
              {
                 RtlCopyMemory(pstyle, plineTo->pstyle, plineTo->cstyle*sizeof(FLOAT_LONG));

                 plineTo->pstyle = pstyle;
              }
          }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("bCaptureLINEATTRS -- exception in try/except \n");

            if (pstyle)
                VFREEMEM(pstyle);

            bRet = FALSE;
        }

       *pplineFrom = plineTo;
    }

    return bRet;
}

__inline
VOID CaptureCOLORADJUSTMENT (COLORADJUSTMENT **ppcaFrom, COLORADJUSTMENT *pcaTo)
{
    if (*ppcaFrom)
    {
       *pcaTo = ProbeAndReadStructure(*ppcaFrom,COLORADJUSTMENT);

       *ppcaFrom = pcaTo;
    }

    return;
}

__inline
VOID CaptureDWORD (DWORD **ppdwFrom, DWORD *pdwTo)
{
    if (*ppdwFrom)
    {
        *pdwTo = ProbeAndReadStructure(*ppdwFrom,DWORD);

        //
        // repoint pprclFrom to prclTo
        //
        *ppdwFrom = pdwTo;
    }
    return;
}

__inline
VOID CaptureBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     if (pv && pvTmp)
     {
         ProbeAndReadBuffer(pv, pvTmp, cj);
     }
     return;
}

/******************************Public*Routine******************************\
* bSecureBits bSafeReadBits bSafeCopyBits
*
* helper functions to secure or copy user memory
* These donot need to be called from within try/except
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
__inline
BOOL bSecureBits (PVOID pv, ULONG cj, HANDLE *phSecure)
{
    BOOL bRet = TRUE;

    *phSecure = 0;

    if (pv)
    {
        __try
        {
            ProbeForRead(pv,cj,sizeof(BYTE));
            *phSecure = MmSecureVirtualMemory(pv, cj, PAGE_READONLY);

            if (*phSecure == 0)
            {
                bRet = FALSE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("bSecureBits -- exception in try/except \n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

__inline
BOOL bSafeCopyBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     BOOL bRet = TRUE;

     if (pv && pvTmp)
     {
        __try
        {
            ProbeAndWriteBuffer(pv, pvTmp, cj);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail in try/except to write into buffer\n");
            bRet = FALSE;
        }

     }
     return bRet;
}

__inline
BOOL bSafeReadBits (PVOID pv, PVOID pvTmp, ULONG cj)
{
     BOOL bRet = TRUE;

     if (pv && pvTmp)
     {
        __try
        {
            ProbeAndReadBuffer(pv, pvTmp, cj);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail in try/except to read from buffer\n");
            bRet = FALSE;
        }
     }
     return bRet;
}




/******************************Public*Routine******************************\
* bCheckSurfaceRect bCheckSurfaceRectSize
*
* Check rect and pco against the surface, make sure we are not going to
* draw outside the surface
*
* bCheckSurfacePath
*
* Check the path against the surface, make sure not going to draw outside
* the surface
*
* bCheckSurfacePoint
*
* Check the point against the surface
*
* History:
*  26-Sept-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

__inline
BOOL bCheckSurfaceRect(SURFOBJ *pso, RECTL *prcl, CLIPOBJ *pco)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;

    if (pso)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       //
       // if no clipping, check against the rectangle.
       //
       if (!bTrivial)
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prcl = &(pco->rclBounds);
       }

       if (prcl)
       {
          if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
          {
              WARNING ("prcl not well ordered, returing failure\n");
              bRet = FALSE;
          }

          if (bRet && ((prcl->right > pso->sizlBitmap.cx) || (prcl->left < 0)||
              (prcl->bottom > pso->sizlBitmap.cy)|| (prcl->top < 0)))
          {
              WARNING ("we might draw outside the surface, returning failure\n");
              bRet = FALSE;
          }
       }
    }

    return bRet;
}


__inline
BOOL bCheckSurfaceRectSize(SURFOBJ *pso, RECTL *prcl, CLIPOBJ *pco,
                   ULONG *pcx, ULONG *pcy, BOOL bOrder = TRUE)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;
    ERECTL rcl(0, 0, 0, 0);
    PRECTL prclBounds = NULL;

    if (pso)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       //
       // if no clipping, check against the rectangle.
       //
       if (!bTrivial)
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prclBounds = &(pco->rclBounds);
           rcl = *prclBounds;
       }
       else
       {
           if (prcl)
           {
               rcl = *prcl;
           }
       }

       //
       // check the rectangle
       //
       if (bOrder && ((rcl.left > rcl.right) || (rcl.top > rcl.bottom)))
       {
           WARNING ("rcl not well ordered, returing failure\n");
           return FALSE;
       }

       //
       // check that we are not going outside the surface
       //
       if ((rcl.right > pso->sizlBitmap.cx) || (rcl.left < 0)||
           (rcl.bottom > pso->sizlBitmap.cy)|| (rcl.top < 0))
       {
           WARNING ("we might draw outside the surface, returning failure\n");
           return FALSE;
       }

       //
       // figure out the size
       //
       if (prclBounds && prcl)
       {
           RECTL rclIntersect;

           rclIntersect.left = MAX(prclBounds->left, prcl->left);
           rclIntersect.right = MIN(prclBounds->right, prcl->right);
           rclIntersect.top = MAX(prclBounds->top, prcl->top);
           rclIntersect.bottom = MAX(prclBounds->bottom, prcl->bottom);

           *pcx = (rclIntersect.right - rclIntersect.left) > 0 ?
                  rclIntersect.right - rclIntersect.left : 0;

           *pcy = (rclIntersect.bottom - rclIntersect.top) > 0 ?
                   rclIntersect.bottom - rclIntersect.top : 0 ;
        }
        else if (prcl)
        {
            *pcx = (prcl->right - prcl->left) > 0 ?
                    prcl->right - prcl->left : 0;
            *pcy = (prcl->bottom - prcl->top) > 0 ?
                    prcl->bottom - prcl->top : 0;
        }
        else if (prclBounds)
        {
            *pcx = (prclBounds->right - prclBounds->left) > 0 ?
                    prclBounds->right - prclBounds->left : 0;
            *pcy = (prclBounds->bottom - prclBounds->top) > 0 ?
                    prclBounds->bottom - prclBounds->top : 0;

        }
    }

    return bRet;
}


__inline
BOOL bCheckSurfacePath(SURFOBJ *pso, PATHOBJ *ppo, CLIPOBJ *pco)
{
    BOOL bRet = TRUE;
    BOOL bTrivial;
    RECTL *prcl;

    if (pso && ppo)
    {
       if (pco)
       {
          bTrivial = (pco->iDComplexity == DC_TRIVIAL) ? TRUE : FALSE;
       }
       else
       {
          bTrivial = TRUE;
       }

       if (bTrivial)
       {
          //
          // no clipping, check against ppo->rcfxBoundBox.
          //
          RECTFX rcfx;

          rcfx = ((EPATHOBJ *)ppo)->ppath->rcfxBoundBox;

          prcl = (RECTL *)&rcfx;

          prcl->left = FXTOL(rcfx.xLeft);
          prcl->top = FXTOL(rcfx.yTop);
          prcl->right = FXTOL(rcfx.xRight);
          prcl->bottom = FXTOL(rcfx.yBottom);
       }
       else
       {
           //
           // there is clipping invloved, check against pco->rclBounds.
           //
           prcl = &(pco->rclBounds);
       }

       if (prcl)
       {
          if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
          {
              WARNING ("prcl not well ordered, returing failure\n");
              bRet = FALSE;
          }

          if (bRet && (prcl->right > pso->sizlBitmap.cx) || (prcl->left < 0) ||
              (prcl->bottom > pso->sizlBitmap.cy)|| (prcl->top < 0))
          {
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING("bCheckSurfacePath either pso or ppo is NULL\n");
        bRet = FALSE;
    }

    return bRet;
}

__inline
BOOL bCheckSurfacePoint(SURFOBJ *pso, POINTL *ptl)
{
    BOOL bRet = TRUE;

    if (pso && ptl)
    {
       if ((pso->sizlBitmap.cx < ptl->x) || (ptl->x < 0) ||
           (pso->sizlBitmap.cy < ptl->y)|| (ptl->y < 0))
       {
           bRet = FALSE;
       }
    }

    return bRet;
}

__inline
BOOL bCheckMask(SURFOBJ *psoMask, RECTL *prcl)
{
    BOOL bRet = TRUE;

    if (psoMask)
    {
       if (psoMask->iBitmapFormat != BMF_1BPP)
           bRet = FALSE;

       if (bRet)
           bRet = bCheckSurfaceRect(psoMask, prcl, NULL);
    }

    return bRet;
}

//
// Make sure the we are not going to access pulXlate when there is no one
// Any other checks on xlateobj?
//
__inline
BOOL bCheckXlate(SURFOBJ *pso, XLATEOBJ *pxlo)
{
    BOOL bRet = TRUE;

    if (pso)
    {
       if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
       {
           switch (pso->iBitmapFormat)
           {
               case BMF_1BPP:
               {
                   bRet = (pxlo->cEntries == 2) ? TRUE : FALSE;
                   break;
               }

               case BMF_4BPP:
               {
                   //we can have a halftone palette of 8 entries
                   bRet = ((pxlo->cEntries == 16) || (pxlo->cEntries == 8)) ? TRUE : FALSE;
                   break;
               }

               case BMF_8BPP:
               {
                   // halftone palette can be any combination
                   bRet = (pxlo->cEntries <= 256) ? TRUE : FALSE;
                   break;
               }
           }
       }
    }

    return bRet;
}


__inline
PRECTL pRect(POINTL *pptl, RECTL *prcl, ULONG cx, ULONG cy)
{
    PRECTL prclRet;

    if (pptl)
    {
       prcl->left = pptl->x;
       prcl->right = pptl->x + cx;
       prcl->top = pptl->y;
       prcl->bottom = pptl->y + cy;
       prclRet = prcl;
    }
    else
    {
       prclRet = NULL;
    }

    return prclRet;
}


//
// check the order of a rectangle
//
__inline
BOOL bCheckRect(RECTL *prcl)
{
    BOOL bRet = TRUE;

    if (prcl)
    {
       if ((prcl->left > prcl->right) || (prcl->top > prcl->bottom))
       {
           WARNING ("prcl not well ordered, returing failure\n");
           bRet = FALSE;
       }
    }

    return bRet;
}

//
// Validate an HSURF and make sure it refers to a UMPD surface
//

__inline BOOL
ValidUmpdHsurf(
    HSURF   hsurf
    )

{
    SURFREF so(hsurf);

    //
    // Make sure hsurf is valid and it refers to a UMPD surface
    //

    return (so.bValid() && so.ps->bUMPD());
}

//
// Validate an HSURF and Unsecure hSecure
//

__inline BOOL
ValidUmpdHsurfAndUnSecure(
    HSURF   hsurf
    )

{
    SURFREF so(hsurf);

    //
    // Make sure hsurf is valid and it refers to a UMPD surface
    //

    if (so.bValid() && so.ps->bUMPD())
    {
        if (so.ps->hSecureUMPD)
        {
            ASSERTGDI(so.ps->iType() == STYPE_BITMAP, "surf type != STYPE_BITMAP\n");
            MmUnsecureVirtualMemory(so.ps->hSecureUMPD);
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// Validate an HDEV belongs to us
//

BOOL
ValidUmpdHdev(
    HDEV    hdev
    )
{
    BOOL bRet = FALSE;

    if (hdev == NULL)
        return FALSE;

    if (!IS_SYSTEM_ADDRESS(hdev))
        return FALSE;

    PPDEV   ppdev;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    for (ppdev = gppdevList; ppdev != NULL; ppdev = ppdev->ppdevNext)
    {
        if ((HDEV)ppdev == hdev)
        {
            bRet = TRUE;
            break;
        }
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return bRet;
}

//
// Make sure for each HOOK_XXX flag set, we actually
// has the driver function in ppfn
//

BOOL
ValidUmpdHooks (
    HDEV hdev,
    FLONG   flHooks
    )
{
   PDEVOBJ po(hdev);

   return (PPFNGET(po, BitBlt, flHooks) &&
           PPFNGET(po, StretchBlt, flHooks) &&
           PPFNGET(po, PlgBlt, flHooks) &&
           PPFNGET(po, TextOut, flHooks) &&
           PPFNGET(po, StrokePath, flHooks) &&
           PPFNGET(po, FillPath, flHooks) &&
           PPFNGET(po, StrokeAndFillPath, flHooks) &&
           PPFNGET(po, Paint, flHooks) &&
           PPFNGET(po, CopyBits, flHooks) &&
           PPFNGET(po, LineTo, flHooks) &&
           PPFNGET(po, StretchBltROP, flHooks) &&
           PPFNGET(po, TransparentBlt, flHooks) &&
           PPFNGET(po, AlphaBlend, flHooks) &&
           PPFNGET(po, GradientFill, flHooks));
}


//
// Valid size for bitmap/surface creation
//

BOOL
ValidUmpdSizl(
    SIZEL  sizl
    )
{
    if ((sizl.cx <= 0) || (sizl.cy <= 0))
    {
        WARNING("ValidUmpdSizl failed - cx or cy <=0 \n");
        return FALSE;
    }
    else
    {
        ULONGLONG cj = ((ULONGLONG)sizl.cx) * sizl.cy;

        if (cj > MAXULONG)
        {
            WARNING("ValidUmpdSizl failed - cx*cy overflow\n");
            return FALSE;
        }
    }

    return TRUE;
}

ULONG
ValidUmpdOverflow(LONG cx, LONG cy)
{
    ULONGLONG cj = ((ULONGLONG)cx) * cy;

    if (cj > MAXULONG)
        return FALSE;
    else
        return (ULONG)cj;

}

BOOL APIENTRY NtGdiEngAssociateSurface(
    IN HSURF  hsurf,    
    IN HDEV   hdev, 
    IN FLONG  flHooks   
   )
{
    return ValidUmpdHsurf(hsurf) &&
           ValidUmpdHdev(hdev) &&
           (!(flHooks & ~HOOK_FLAGS))&&
           ValidUmpdHooks (hdev, flHooks) &&
           EngAssociateSurface(hsurf, hdev, flHooks);
}

BOOL APIENTRY NtGdiEngDeleteSurface(
    IN HSURF  hsurf 
   )
{
    return ValidUmpdHsurfAndUnSecure(hsurf) &&
           EngDeleteSurface(hsurf);
}


BOOL APIENTRY NtGdiEngMarkBandingSurface(
     HSURF hsurf
     )
{
    return ValidUmpdHsurf(hsurf) &&
           EngMarkBandingSurface(hsurf);
}


HBITMAP APIENTRY NtGdiEngCreateBitmap(
    IN SIZEL  sizl, 
    IN LONG   lWidth,   
    IN ULONG  iFormat,  
    IN FLONG  fl,   
    IN PVOID  pvBits    
   )
{
    HBITMAP hbm = NULL;
    HANDLE  hSecure = NULL;
    ULONG   cj;
    BOOL    bSuccess = TRUE;

    TRACE_INIT (("Entering NtGdiEngCreateBitmap\n"));

    // check sizl.x and y
    if (!ValidUmpdSizl(sizl))
        return 0;

    cj = ValidUmpdOverflow(lWidth, sizl.cy);

    //
    // set the high bit of iFormat to indicate umpd driver
    //
    iFormat |= UMPD_FLAG;

    if (pvBits)
    {
        __try
        {
            ProbeForRead(pvBits,cj,sizeof(BYTE));
            hSecure = MmSecureVirtualMemory(pvBits, cj, PAGE_READWRITE);

            if (!hSecure)
                bSuccess = FALSE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("EngCreateBitmap -- exception in try/except \n");
            bSuccess = FALSE;
        }
    }
    else
    {
        fl |= BMF_USERMEM;
#if defined(_WIN64)
        // wow64 printing

        PW32THREAD    pw32thread = W32GetCurrentThread();
        
        if (pw32thread->pClientID)
            fl |= BMF_UMPDMEM;
#endif
    }

    if (bSuccess)
    {
        hbm = EngCreateBitmap(sizl, lWidth, iFormat, fl, pvBits);
    }

    if (hSecure != NULL)
    {
        if (hbm != NULL)
        {
            //
            // set hSecure into hSecureUMPD, at EngDeleteSurface time,
            // we unsecure it
            //

            SURFREF so((HSURF) hbm);

            if (so.bValid())
            {
                so.ps->hSecureUMPD = hSecure;
            }
            else
            {
                MmUnsecureVirtualMemory(hSecure);

                EngDeleteSurface((HSURF)hbm);

                hbm = NULL;
            }
        }
        else
        {
            //
            // We secured caller's memory but EngCreateBitmap failed.
            //

            MmUnsecureVirtualMemory(hSecure);
        }
    }

    return (hbm);
}

BOOL APIENTRY NtGdiEngCopyBits(
    IN SURFOBJ   *psoDst,   
    OUT SURFOBJ  *psoSrc,   
    IN CLIPOBJ   *pco,  
    IN XLATEOBJ  *pxlo, 
    IN RECTL    *prclDst,   
    IN POINTL   *pptlSrc    
   )
{
    RECTL   rcl;
    POINTL  ptl;
    ULONG   cx, cy;
    BOOL    bRet = TRUE;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();

    if (psoDst && psoSrc && (psoDst->iType == STYPE_BITMAP) && prclDst && pptlSrc)
    {
       __try
       {
           CaptureRECTL(&prclDst, &rcl);
           CapturePOINTL(&pptlSrc, &ptl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngCopyBits failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclDst))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRectSize(psoDst, prclDst, pco, &cx, &cy) && bCheckXlate(psoSrc, pxlo)))
           {
               RECTL rclSrc, *prclSrc;

               prclSrc = psoSrc ? pRect(pptlSrc, &rclSrc, cx, cy) : NULL;

               if (bRet = bCheckSurfaceRect(psoSrc, prclSrc, NULL))
               {
                  bRet = EngCopyBits(psoDst,
                                     psoSrc,
                                     pco,
                                     pxlo,
                                     prclDst,
                                     pptlSrc);
               }
           }
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

BOOL APIENTRY NtGdiEngStretchBlt(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    BOOL   bRet = TRUE;
    RECTL  rclDst, rclSrc;
    POINTL ptlMask, ptlHTOrg;
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    if (!pptlHTOrg && (iMode == HALFTONE))
    {
        WARNING ("pptlHTOrg is NULL for HALFTONE mode\n");
        FIXUP_THREAD_UMPDOBJS;
        return (FALSE);
    }

    if (psoDest && psoSrc && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclDest, &rclDst);
           CapturePOINTL(&pptlMask, &ptlMask);
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureCOLORADJUSTMENT(&pca, &ca);
           CapturePOINTL(&pptlHTOrg, &ptlHTOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStretchBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngStretchBlt does trimming and checking of the dest and src rectangles,
           // but it assumes the src rect is well-ordered.  Check here.
           //
           bRet = bOrder(prclSrc) && bCheckXlate(psoSrc, pxlo);

           if (bRet && psoMask)
           {
              RECTL rclMask, *prclMask;

              ULONG cx, cy;

              if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
              {
                 prclMask = pRect(pptlMask, &rclMask, cx, cy);
                 bRet = bCheckMask(psoMask, prclMask);
              }
            }

            if (bRet)
                bRet = EngStretchBlt(psoDest,
                                   psoSrc,
                                   psoMask,
                                   pco,
                                   pxlo,
                                   pca,
                                   pptlHTOrg,
                                   prclDest,
                                   prclSrc,
                                   pptlMask,
                                   iMode);
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);

}

BOOL APIENTRY NtGdiEngStretchBltROP(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )
{
    BOOL   bRet = TRUE;
    RECTL  rclDst, rclSrc;
    POINTL ptlMask, ptlHTOrg;
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    if (psoDest && psoSrc && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclDest, &rclDst);
           CaptureRECTL(&prclSrc, &rclSrc);
           CapturePOINTL(&pptlMask, &ptlMask);
           CapturePOINTL(&pptlHTOrg, &ptlHTOrg);
           CaptureCOLORADJUSTMENT(&pca, &ca);

       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStretchBltTROP failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           ULONG    cx, cy;
           BRUSHOBJ boTemp;

           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngStretchBlt does trimming and checking of the rectangles,
           // but it assumes the src rect is well-ordered, check here.
           //

           bRet = (!ROP4NEEDSRC(rop4) || bOrder(prclSrc)) && bCheckXlate(psoSrc, pxlo) &&
                  (!ROP4NEEDMASK(rop4) || psoMask || ISPATBRUSH(pbo));

           if (bRet && (rop4 == 0XAACC) && psoMask)
           {
              RECTL rclMask, *prclMask;

              ULONG cx, cy;

              if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
              {
                 prclMask = pRect(pptlMask, &rclMask, cx, cy);
                 bRet = bCheckMask(psoMask, prclMask);
              }
            }

            MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

            bRet = bRet &&
                   EngStretchBltROP(psoDest,
                                psoSrc,
                                psoMask,
                                pco,
                                pxlo,
                                pca,
                                pptlHTOrg,
                                prclDest,
                                prclSrc,
                                pptlMask,
                                iMode,
                                pbo,
                                rop4);
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

BOOL APIENTRY NtGdiEngPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfxDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    BOOL     bRet = TRUE;
    RECTL    rcl;
    POINTL   ptl, ptlBrushOrg;
    POINTFIX pptfx[3];
    COLORADJUSTMENT ca;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoTrg(psoTrg, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMsk(psoMsk, pUMObjs);

    psoTrg = umsoTrg.pso();
    psoSrc = umsoSrc.pso();
    psoMsk = umsoMsk.pso();

    if (psoTrg && psoSrc && prclSrc && pptfxDest)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rcl);
           CaptureCOLORADJUSTMENT(&pca, &ca);
           CapturePOINTL(&pptlMask, &ptl);
           CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
           CaptureBits(pptfx, pptfxDest, sizeof(POINTFIX)*3);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngPlgBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           ULONG cx, cy;

           pco = pUMObjs->GetDDIOBJ(pco, &psoTrg->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           //
           // EngPlgBlt does the rectangle trimming and checking of dest and src
           //

           if (bRet = (bCheckRect(prclSrc) && bCheckXlate(psoSrc, pxlo)))
           {
              if (psoMsk)
              {
                 RECTL rclMask, *prclMask;

                 ULONG cx, cy;

                 if (bRet = bCheckSurfaceRectSize(psoSrc, prclSrc, NULL, &cx, &cy))
                 {
                    prclMask = pRect(pptlMask, &rclMask, cx, cy);
                    bRet = bCheckMask(psoMsk, prclMask);
                 }
               }

               if (bRet)
                  bRet = EngPlgBlt(psoTrg,
                                   psoSrc,
                                   psoMsk,
                                   pco,
                                   pxlo,
                                   pca,
                                   &ptlBrushOrg,
                                   pptfx,
                                   prclSrc,
                                   pptlMask,
                                   iMode);
          }
       }
    }
    else
    {
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

SURFOBJ  *APIENTRY NtGdiEngLockSurface(
    IN HSURF  hsurf 
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);   
    
    SURFOBJ *surfRet = pUMObjs->LockSurface(hsurf);

    FIXUP_THREAD_UMPDOBJS;

    return (surfRet);
}

VOID APIENTRY NtGdiEngUnlockSurface(
    IN SURFOBJ  *pso    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->UnlockSurface(pso);

    FIXUP_THREAD_UMPDOBJS;
}

BOOL APIENTRY NtGdiEngBitBlt(
    IN SURFOBJ  *psoDst,    
    IN SURFOBJ  *psoSrc,    
    IN SURFOBJ  *psoMask,   
    IN CLIPOBJ  *pco,   
    IN XLATEOBJ *pxlo,  
    IN RECTL    *prclDst,   
    IN POINTL   *pptlSrc,   
    IN POINTL   *pptlMask,  
    IN BRUSHOBJ *pbo,   
    IN POINTL   *pptlBrush, 
    IN ROP4     rop4    
   )
{
    BOOL        bRet = TRUE;
    RECTL       rclDst;
    POINTL      ptlSrc, ptlMask, ptlBrush;
    BRUSHOBJ    boTemp;

    TRACE_INIT (("Entering NtGdiEngBitBlt\n"));

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);
    UMPDSURFOBJ umsoMask(psoMask, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();
    psoMask = umsoMask.pso();

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);
    pxlo = pUMObjs->GetDDIOBJ(pxlo);

    if (((rop4 & 0xffff0000) != 0) ||
        !prclDst ||
        (ROP4NEEDPAT(rop4) && (!pbo || ISPATBRUSH(pbo) && !pptlBrush)) ||
        (ROP4NEEDSRC(rop4) && !(pptlSrc && psoSrc)) ||
        (ROP4NEEDMASK(rop4) && !(psoMask || ISPATBRUSH(pbo))))
    {
        WARNING ("NtGdiEngBitBlt invalid parameters passed in\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    if (psoDst)
    {
       __try
       {
           CaptureRECTL(&prclDst, &rclDst);
           CapturePOINTL(&pptlSrc, &ptlSrc);
           CapturePOINTL(&pptlMask, &ptlMask);
           CapturePOINTL(&pptlBrush, &ptlBrush);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngBitBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           ULONG cx, cy;

           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);

           if (bRet = bCheckSurfaceRectSize(psoDst, prclDst, pco, &cx, &cy) &&
                      bCheckXlate(psoSrc, pxlo))
           {
               RECTL    rclSrc, *prclSrc;
               RECTL    rclMask, *prclMask;

               prclSrc = psoSrc ? pRect(pptlSrc, &rclSrc, cx, cy) : NULL;
               prclMask = psoMask ? pRect(pptlMask, &rclMask, cx, cy) : NULL;

               if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) &&
                           bCheckMask(psoMask, prclMask)))
               {
                  bRet = EngBitBlt(psoDst,
                                   psoSrc,
                                   psoMask,
                                   pco,
                                   pxlo,
                                   prclDst,
                                   pptlSrc,
                                   pptlMask,
                                   pbo,
                                   pptlBrush,
                                   rop4);
               }
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    )
{
    BOOL        bRet = TRUE;
    POINTL      ptl;
    LINEATTRS   line;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    TRACE_INIT (("Entering NtGdiEngStrokePath\n"));

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo && ppo)
    {
       __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStrokePath failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
           bRet = bCaptureLINEATTRS(&plineattrs, &line);

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);

           bRet = bCheckSurfacePath(pso, ppo, pco) &&
                  (!MIXNEEDMASK(mix) || ISPATBRUSH(pbo)) &&
                  EngStrokePath(pso,
                                ppo,
                                pco,
                                pUMObjs->GetDDIOBJ(pxo),
                                pbo,
                                pptlBrushOrg,
                                plineattrs,
                                mix);

           if (plineattrs && plineattrs->pstyle)
               VFREEMEM(plineattrs->pstyle);
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )
{
    BOOL        bRet = FALSE;
    POINTL      ptlBrushOrg;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo && ppo && pco && (pco->iMode == TC_RECTANGLES))
    {
        __try
        {
            CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
            bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("NtGdiEngFillPath failed in try/except\n");
        }

        bRet = bRet &&
               bCheckSurfacePath(pso, ppo, pco) &&
               (!MIXNEEDMASK(mix) || ISPATBRUSH(pbo)) &&
               EngFillPath(pso,
                           ppo,
                           pco,
                           pbo,
                           pptlBrushOrg,
                           mix,
                           flOptions);
    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mixFill,
    FLONG      flOptions
    )
{
    BOOL        bRet = FALSE;
    POINTL      ptl;
    LINEATTRS   line;
    BRUSHOBJ    boTempStroke, boTempFill;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pboStroke, &boTempStroke);
    MAP_UM_BRUSHOBJ(pUMObjs, pboFill, &boTempFill);

    if (pso && pboStroke && pboFill && ppo && plineattrs && pco)
    {
       __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptl);
           bRet = TRUE;
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngStrokeAndFillPath failed in try/except\n");
       }

       if (bRet)
           bRet = bCaptureLINEATTRS(&plineattrs, &line);

       if (bRet)
       {
           bRet = bCheckSurfacePath(pso, ppo, pco) &&
                  (!MIXNEEDMASK(mixFill) || ISPATBRUSH(pboFill)) &&
                  EngStrokeAndFillPath(pso,
                                       ppo,
                                       pco,
                                       pUMObjs->GetDDIOBJ(pxo),
                                       pboStroke,
                                       plineattrs,
                                       pboFill,
                                       pptlBrushOrg,
                                       mixFill,
                                       flOptions);

           if (plineattrs && plineattrs->pstyle)
               VFREEMEM(plineattrs->pstyle);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY
NtGdiEngPaint(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )
{
    POINTL      ptlBrushOrg;
    BOOL        bRet = TRUE;
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    pco = pso ? pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap) : NULL;

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pco && (pco->iMode == TC_RECTANGLES) && (mix & 0xff00))
    {
       
        __try
       {
           CapturePOINTL(&pptlBrushOrg, &ptlBrushOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngPaint failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && (bRet = bCheckSurfaceRect(pso, NULL, pco)))
       {
           bRet = EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY NtGdiEngLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )
{
    BOOL        bRet = TRUE;
    RECTL       rcl;
    RECTL       rclline = {x1,y1,x2,y2};
    BRUSHOBJ    boTemp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();

    MAP_UM_BRUSHOBJ(pUMObjs, pbo, &boTemp);

    if (pso && pbo)
    {
       __try
       {
           CaptureRECTL(&prclBounds, &rcl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngLineTo failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);

           if (bRet = bCheckSurfaceRect(pso, &rclline, pco))
           {
              bRet = EngLineTo(pso,
                               pco,
                               pbo,
                               x1,
                               y1,
                               x2,
                               y2,
                               prclBounds,
                               mix);
          }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    BOOL        bRet = TRUE;
    RECTL       rclDest, rclSrc;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    pBlendObj = pUMObjs->GetDDIOBJ(pBlendObj);

    psoDest = umsoDest.pso();
    psoSrc = umsoSrc.pso();

    if (psoDest && psoSrc && pBlendObj && prclDest && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureRECTL(&prclDest, &rclDest);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngAlphaBlend failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclSrc) && bOrder(prclDest))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) && bCheckXlate(psoSrc, pxlo)))
           {
              bRet = EngAlphaBlend(psoDest,
                                   psoSrc,
                                   pco,
                                   pxlo,
                                   prclDest,
                                   prclSrc,
                                   pBlendObj);
          }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}


BOOL APIENTRY NtGdiEngGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    )
{
    BOOL           bRet = TRUE;
    RECTL          rcl;
    POINTL         ptl;
    TRIVERTEX      *pVertexTmp = (TRIVERTEX *)NULL;
    PVOID          pMeshTmp = NULL;
    ULONG          cjMesh;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDest(psoDest, pUMObjs);
    psoDest = umsoDest.pso();

    switch (ulMode)
    {
    case GRADIENT_FILL_RECT_H:
    case GRADIENT_FILL_RECT_V:

        cjMesh = sizeof(GRADIENT_RECT);

        if (BALLOC_OVERFLOW1(nMesh, GRADIENT_RECT))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        break;

    case GRADIENT_FILL_TRIANGLE:

        cjMesh = sizeof(GRADIENT_TRIANGLE);

        if (BALLOC_OVERFLOW1(nMesh, GRADIENT_TRIANGLE))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        break;

    default:

        WARNING ("Invalid ulMode in DrvGradientFill\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    cjMesh *= nMesh;

    if (BALLOC_OVERFLOW1(nVertex, TRIVERTEX))
    {
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    pVertexTmp = (TRIVERTEX *)PALLOCNOZ (sizeof(TRIVERTEX)*nVertex, UMPD_MEMORY_TAG);

    pMeshTmp = PALLOCNOZ (cjMesh, UMPD_MEMORY_TAG);

    if (psoDest && pVertex && pMesh && pVertexTmp && pMeshTmp && prclExtents)
    {
       __try
       {
           CaptureRECTL(&prclExtents, &rcl);
           CapturePOINTL(&pptlDitherOrg, &ptl);
           CaptureBits(pVertexTmp, pVertex, sizeof(TRIVERTEX)*nVertex);
           CaptureBits(pMeshTmp, pMesh, cjMesh);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngAlphaBlend failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDest->sizlBitmap);

           bRet = EngGradientFill(psoDest,
                                  pco,
                                  pUMObjs->GetDDIOBJ(pxlo),
                                  pVertexTmp,
                                  nVertex,
                                  pMeshTmp,
                                  nMesh,
                                  prclExtents,
                                  pptlDitherOrg,
                                  ulMode);
       }
    }
    else
        bRet = FALSE;

    if (pVertexTmp)
        VFREEMEM(pVertexTmp);

    if (pMeshTmp)
        VFREEMEM(pMeshTmp);

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


BOOL APIENTRY NtGdiEngTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    )
{
    BOOL bRet = TRUE;
    RECTL rclDst, rclSrc;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umsoDst(psoDst, pUMObjs);
    UMPDSURFOBJ umsoSrc(psoSrc, pUMObjs);

    psoDst = umsoDst.pso();
    psoSrc = umsoSrc.pso();

    if (psoDst && psoSrc && prclDst && prclSrc)
    {
       __try
       {
           CaptureRECTL(&prclSrc, &rclSrc);
           CaptureRECTL(&prclDst, &rclDst);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngTransparentBlt failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet && bOrder(prclDst) && bOrder(prclSrc))
       {
           pco = pUMObjs->GetDDIOBJ(pco, &psoDst->sizlBitmap);
           pxlo = pUMObjs->GetDDIOBJ(pxlo);

           if (bRet = (bCheckSurfaceRect(psoSrc, prclSrc, NULL) && bCheckXlate(psoSrc, pxlo)))
           {
               bRet = EngTransparentBlt(psoDst,
                                        psoSrc,
                                        pco,
                                        pxlo,
                                        prclDst,
                                        prclSrc,
                                        iTransColor,
                                        ulReserved);
           }
        }
     }
     else
         bRet = FALSE;

     FIXUP_THREAD_UMPDOBJS;
     return (bRet);
}


BOOL APIENTRY NtGdiEngTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )
{
    BOOL        bRet = TRUE;
    RECTL       rclExtra, rclOpaque;
    POINTL      ptlOrg;
    BRUSHOBJ    boTempFore, boTempOpaque;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    pstro = pUMObjs->GetDDIOBJ(pstro);
    pfo = pUMObjs->GetDDIOBJ(pfo);

    MAP_UM_BRUSHOBJ(pUMObjs, pboFore, &boTempFore);
    MAP_UM_BRUSHOBJ(pUMObjs, pboOpaque, &boTempOpaque);

    if (pso && pstro && pfo && pboFore)
    {
       __try
       {
           CaptureRECTL(&prclExtra, &rclExtra);
           CaptureRECTL(&prclOpaque, &rclOpaque);
           CapturePOINTL(&pptlOrg, &ptlOrg);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngTextOut failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);

           if (bRet = (!MIXNEEDMASK(mix) || ISPATBRUSH(pboFore)) &&
                      bCheckSurfaceRect(pso, prclOpaque, pco))
           {

                RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
                
                UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

                bRet = EngTextOut(pso,
                                  pstro,
                                  pfo,
                                  pco,
                                  prclExtra,
                                  prclOpaque,
                                  pboFore,
                                  pboOpaque,
                                  pptlOrg,
                                  mix);

                UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

HPALETTE APIENTRY NtGdiEngCreatePalette(
    ULONG  iMode,   
    ULONG  cColors, 
    ULONG  *pulColors,  
    FLONG  flRed,   
    FLONG  flGreen, 
    FLONG  flBlue   
   )
{
    HPALETTE hpal = (HPALETTE)1;
    ULONG    pulColorsTmp[256];
    HANDLE hSecure = 0;

    TRACE_INIT (("Entering NtGdiEngCreatePalette\n"));

    //
    // cColors has a limit of 64k
    //
    if (cColors > 64 * 1024)
        return 0;

    if ((iMode == PAL_INDEXED) && cColors)
    {
        if (cColors > 256)
            hpal = (HPALETTE)(ULONG_PTR)bSecureBits(pulColors, cColors*sizeof(ULONG), &hSecure);
        else
        {
            hpal = (HPALETTE)(ULONG_PTR)bSafeReadBits(pulColorsTmp, pulColors, cColors*sizeof(ULONG));
        }
    }

    if (hpal)
    {
        //
        // set the high bit of iMode to indicate umpd driver
        //
        iMode |= UMPD_FLAG;

        hpal = EngCreatePalette(iMode, cColors, pulColors, flRed, flGreen, flBlue);
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return hpal;
}

BOOL APIENTRY NtGdiEngDeletePalette(
    IN HPALETTE  hpal   
   )
{
    TRACE_INIT (("Entering NtGdiEngDeletePalette\n"));

    //
    // EngDeletePalette will check if hpal is valid
    // so we don't need to check hpal here
    //
    return (EngDeletePalette(hpal));
}

BOOL APIENTRY NtGdiEngEraseSurface(
    IN SURFOBJ  *pso,   
    IN RECTL    *prcl,  
    IN ULONG    iColor  
   )
{
    BOOL  bRet = TRUE;
    RECTL rcl;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();

    if (pso)
    {
       __try
       {
           CaptureRECTL(&prcl, &rcl);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING ("NtGdiEngEraseSurface failed in try/except\n");
           bRet = FALSE;
       }

       if (bRet)
       {
           if (bRet = bCheckSurfaceRect(pso, prcl, NULL))
           {
               bRet = EngEraseSurface(pso, prcl, iColor);
           }
       }
    }
    else
        bRet = FALSE;

    FIXUP_THREAD_UMPDOBJS;

    return bRet;
}

PATHOBJ* APIENTRY NtGdiCLIPOBJ_ppoGetPath(
    CLIPOBJ  *pco   
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PATHOBJ* poRet = pUMObjs->GetCLIPOBJPath(pco);

    FIXUP_THREAD_UMPDOBJS;

    return poRet;
}

VOID APIENTRY NtGdiEngDeletePath(
    IN PATHOBJ  *ppo    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->DeleteCLIPOBJPath(ppo);

    FIXUP_THREAD_UMPDOBJS;    
}

CLIPOBJ* APIENTRY NtGdiEngCreateClip()

{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    CLIPOBJ* clipRet = pUMObjs->CreateCLIPOBJ();
    
    FIXUP_THREAD_UMPDOBJS;

    return clipRet;
}

VOID APIENTRY NtGdiEngDeleteClip(
    CLIPOBJ *pco
    )

{
    EXTRACT_THREAD_UMPDOBJS;

    pUMObjs->DeleteCLIPOBJ(pco);

    FIXUP_THREAD_UMPDOBJS;
}

ULONG APIENTRY NtGdiCLIPOBJ_cEnumStart(
    CLIPOBJ *pco,
    BOOL     bAll,
    ULONG    iType,
    ULONG    iDirection,
    ULONG    cLimit
    )
{
    EXTRACT_THREAD_UMPDOBJS(0xffffffff);

    ULONG ulRet = 0xffffffff;

    pco = pUMObjs->GetDDIOBJ(pco);

    if (pco)
    {
       ulRet = CLIPOBJ_cEnumStart(pco,
                                 bAll,
                                 iType,
                                 iDirection,
                                 cLimit);
    }

    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

BOOL APIENTRY NtGdiCLIPOBJ_bEnum(
    CLIPOBJ *pco,
    ULONG    cj,
    ULONG   *pul
    )
{
    BOOL    bRet = DDI_ERROR;
    ULONG   *pulTmp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    pco = pUMObjs->GetDDIOBJ(pco);

    if (pco)
    {
       pulTmp = (PULONG)PALLOCNOZ(cj, UMPD_MEMORY_TAG);

       if (pulTmp)
       {
          bRet = CLIPOBJ_bEnum(pco, cj, pulTmp);

          if (bRet != DDI_ERROR)
              if (!bSafeCopyBits(pul, pulTmp, cj))
                  bRet = DDI_ERROR;

           VFREEMEM(pulTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

PVOID APIENTRY NtGdiBRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo,
    ULONG     cj
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID pvRet =  ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_pvAllocRbrushUMPD(pbo, cj) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return pvRet;
}

PVOID APIENTRY NtGdiBRUSHOBJ_pvGetRbrush(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID pvRet =  ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_pvGetRbrushUMPD(pbo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return pvRet;
}


ULONG APIENTRY NtGdiBRUSHOBJ_ulGetBrushColor(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(0);

    ULONG   ulRet = 0;
    BRUSHOBJ  *pbokm;

    if (pbokm = pUMObjs->GetDDIOBJ(pbo))
    {
        if ((pbo->flColorType & BR_ORIGCOLOR) && ((EBRUSHOBJ*)pbokm)->bIsSolid())
        {
            pbokm->flColorType |= BR_ORIGCOLOR;
        }
        ulRet = BRUSHOBJ_ulGetBrushColor(pbokm);
    }
    
    pbo->flColorType &= ~BR_ORIGCOLOR;        
    
    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

HANDLE APIENTRY NtGdiBRUSHOBJ_hGetColorTransform(
    BRUSHOBJ *pbo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    HANDLE hRet = ((pbo = pUMObjs->GetDDIOBJ(pbo)) != NULL) ?
                BRUSHOBJ_hGetColorTransform(pbo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;

    return hRet;
}

BOOL APIENTRY NtGdiXFORMOBJ_bApplyXform(
    XFORMOBJ *pxo,
    ULONG     iMode,
    ULONG     cPoints,
    PVOID     pvIn,
    PVOID     pvOut
    )

#define APPLYXFORM_STACK_POINTS 4

{
    POINTL  ptlIn[APPLYXFORM_STACK_POINTS];
    POINTL  ptlOut[APPLYXFORM_STACK_POINTS];
    PVOID   pvInTmp, pvOutTmp;
    BOOL    bRet = FALSE;

    if (BALLOC_OVERFLOW1(cPoints, POINTL))
        return FALSE;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    pxo = pUMObjs->GetDDIOBJ(pxo);

    if (pxo && pvIn && pvOut && cPoints)
    {
        if (cPoints <= APPLYXFORM_STACK_POINTS)
        {
            pvInTmp  = ptlIn;
            pvOutTmp = ptlOut;
        }
        else
        {
            pvInTmp  = PALLOCNOZ(sizeof(POINTL)*cPoints, UMPD_MEMORY_TAG);
            pvOutTmp = PALLOCNOZ(sizeof(POINTL)*cPoints, UMPD_MEMORY_TAG);
        }

        if (pvInTmp != NULL &&
            pvOutTmp != NULL &&
            bSafeReadBits(pvInTmp, pvIn, cPoints*sizeof(POINTL)))
        {
            bRet = XFORMOBJ_bApplyXform(pxo, iMode, cPoints, pvInTmp, pvOutTmp) &&
                   bSafeCopyBits(pvOut, pvOutTmp, cPoints*sizeof(POINTL));
        }

        if (cPoints > APPLYXFORM_STACK_POINTS)
        {
            if (pvInTmp != NULL)
                VFREEMEM(pvInTmp);

            if (pvOutTmp != NULL)
                VFREEMEM(pvOutTmp);
        }

    }

    FIXUP_THREAD_UMPDOBJS;
    return (bRet);
}

ULONG APIENTRY NtGdiXFORMOBJ_iGetXform(
    XFORMOBJ *pxo,
    XFORML   *pxform
    )
{
    ULONG   ulRet = DDI_ERROR;
    XFORML  xform;

    EXTRACT_THREAD_UMPDOBJS(DDI_ERROR);

    pxo = pUMObjs->GetDDIOBJ(pxo);

    if (pxo)
    {
       ulRet = XFORMOBJ_iGetXform(pxo, pxform? &xform : NULL);

       if ((ulRet != DDI_ERROR) && pxform)
       {
           __try
          {
              ProbeAndWriteStructure (pxform, xform, XFORML);
          }
          __except(EXCEPTION_EXECUTE_HANDLER)
          {
              ulRet = DDI_ERROR;
          }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return (ulRet);
}

VOID APIENTRY NtGdiFONTOBJ_vGetInfo(
    FONTOBJ  *pfo,
    ULONG     cjSize,
    FONTINFO *pfi
    )
{
    FONTINFO *pfiTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS;

    pfo = pUMObjs->GetDDIOBJ(pfo);

    if (pfo)
    {
       if (cjSize && pfi)
       {
           if (pfiTmp = (FONTINFO *)PALLOCNOZ(cjSize, UMPD_MEMORY_TAG))
           {
              FONTOBJ_vGetInfo(pfo, cjSize, pfiTmp);

              bSafeCopyBits(pfi, pfiTmp, cjSize);

              VFREEMEM(pfiTmp);
           }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
}

//
// FONTOBJ_cGetGlyphs is a service to the font consumer that translates glyph handles into
// pointers to glyph data. These pointers are valid until the next call to FONTOBJ_cGetGlyphs.
// this means that we only need to attache one ppvGlyph onto the thread at any time.
//
// Note: another way to do this is to pre-allocate a reasonable size of User memory and
// use that memory for all temporary data buffers, and grow it when we are reaching the limit
// Thus we save the memory allocation calls.
//
ULONG APIENTRY NtGdiFONTOBJ_cGetGlyphs(
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cGlyph,
    HGLYPH  *phg,
    PVOID   *ppvGlyph
    )
{
    GLYPHDATA  *pgd, *pgdkm;
    HGLYPH      hg;
    ULONG       ulRet = 1;

    EXTRACT_THREAD_UMPDOBJS(0);

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) == NULL ||
        (iMode != FO_GLYPHBITS && iMode != FO_PATHOBJ))
    {
        WARNING("Invalid parameter passed to NtGdiFONTOBJ_cGetGlyphs\n");
        FIXUP_THREAD_UMPDOBJS;
        return 0;
    }

    //
    // Call the engine to retrive glyph data
    //
    // NOTE: DDK documentation is bogus.
    // Font driver only supports cGlyph == 1 case.
    //
    __try
    {
        CaptureDWORD (&phg, &hg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING ("NtGdiFONTOBJ_cGetGlyphs failed in try/except\n");
        ulRet = 0;
    }

    if (ulRet)
    {
       RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
       
       UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

       if ((ulRet = FONTOBJ_cGetGlyphs(pfo, iMode, 1, phg, (PVOID *) &pgd)) == 1)
       {
           //
           // Thunk GLYPHDATA structure
           //
    
           pgdkm = pgd;
    
           if (!pUMObjs->ThunkMemBlock((PVOID *) &pgd, sizeof(GLYPHDATA)))
           {
               WARNING("Couldn't thunk GLYPHDATA structure\n");
               ulRet = 0;
           }
           else if (iMode == FO_GLYPHBITS)
           {
               //
               // Thunk GLYPHBITS structure
               //
    
               if (pgdkm->gdf.pgb != NULL &&
                   (pgd->gdf.pgb = pUMObjs->CacheGlyphBits(pgdkm->gdf.pgb)) == NULL)
               {
                   WARNING("Couldn't thunk GLYPHBITS structure\n");
                   ulRet = 0;
               }
           }
           else
           {
               //
               // Thunk PATHOBJ
               //
    
               if (pgdkm->gdf.ppo != NULL &&
                   (pgd->gdf.ppo = pUMObjs->CacheGlyphPath(pgdkm->gdf.ppo)) == NULL)
               {
                   WARNING("Couldn't thunk PATHOBJ structure\n");
                   ulRet = 0;
               }
           }
       }

       UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

       if (ulRet != 0)
       {
           __try
           {
               ProbeAndWriteStructure (ppvGlyph, (PVOID)pgd, PVOID);
           }
           __except(EXCEPTION_EXECUTE_HANDLER)
           {
               WARNING ("fail to write in ppvGlyph\n");
               ulRet = 0;
           }
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}


ULONG APIENTRY NtGdiFONTOBJ_cGetAllGlyphHandles(
    IN FONTOBJ  *pfo,   
    OUT HGLYPH  *phg    
   )
{
    ULONG ulCount = 0;
    HGLYPH *phgTmp = NULL;
    ULONG ulRet = 0;

    EXTRACT_THREAD_UMPDOBJS(0);

    pfo = pUMObjs->GetDDIOBJ(pfo);

    if (pfo)
    {
       if (phg)
       {
           if (ulCount = FONTOBJ_cGetAllGlyphHandles(pfo, NULL))
           {
               // we are a little bit over cautious here,well...
               if (BALLOC_OVERFLOW1(ulCount, HGLYPH))
               {
                   FIXUP_THREAD_UMPDOBJS;
                   return NULL;
               }

               phgTmp = (HGLYPH *)PALLOCNOZ(ulCount*sizeof(HGLYPH), UMPD_MEMORY_TAG);
           }
       }

       ulRet = FONTOBJ_cGetAllGlyphHandles(pfo, phgTmp);

       if (ulRet && phg && phgTmp)
       {
           if (!bSafeCopyBits(phg, phgTmp, ulRet))
               ulRet = NULL;
       }

       if (phgTmp)
       {
           VFREEMEM(phgTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}

XFORMOBJ* APIENTRY NtGdiFONTOBJ_pxoGetXform(
    FONTOBJ *pfo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    XFORMOBJ* xoRet= pUMObjs->GetFONTOBJXform(pfo);

    FIXUP_THREAD_UMPDOBJS;
    return xoRet;
}


//
// If the return value is a system address, we copy it into user memory
//
// IMPORTANT!!
//  We assume FD_GLYPHSET information is stored in one contiguous block
//  of memory and FD_GLYPHSET.cjThis field is the size of the entire block.
//  HGLYPH arrays in each WCRUN are part of the block, placed just after
//  FD_GLYPHSET structure itself.
//
BOOL
GreCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize,
    BOOL        bFromKernel
    )

{
    ULONG   size;
    PBYTE   phg, pbMax;

    //
    // bFromKernel TRUE: we are copying from kernel mode address(src) to user mode address (dst)
    //                   the src should contain everything in one chunk of memory
    //
    //             FALSE: copying from user mode (src) to kernel mode (dst)
    //                   glyph indices in src might be stored in a different chunk of memory from src
    //
    
    size = bFromKernel ? cjSize : offsetof(FD_GLYPHSET, awcrun) + src->cRuns * sizeof(WCRUN);
    RtlCopyMemory(dst, src, size);

    dst->cjThis = cjSize;
    pbMax = (PBYTE)dst + cjSize;
    phg = (PBYTE)dst + size;
    
    //
    // Patch up memory pointers in each WCRUN structure
    //

    ULONG   index, offset;
    
    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            if (bFromKernel)
            {
                offset = (ULONG)((PBYTE) src->awcrun[index].phg - (PBYTE) src);
                
                if (offset >= cjSize)
                {
                    WARNING("GreCopyFD_GLYPHSET failed.\n");
                    return FALSE;
                }
                dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
            }
            else
            {
                size = src->awcrun[index].cGlyphs * sizeof(HGLYPH);

                if (phg + size <= pbMax)
                {
                    RtlCopyMemory(phg, src->awcrun[index].phg, size);
                    dst->awcrun[index].phg = (HGLYPH*) phg;
                    phg += size;
                }
                else
                    return FALSE;
            }
        }
    }

    return TRUE;
}

FD_GLYPHSET * APIENTRY NtGdiFONTOBJ_pfdg(
    FONTOBJ *pfo
    )
{
    FD_GLYPHSET  *pfdg = NULL, *pfdgTmp;
    ULONG        cjSize;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Check if this function has already been
    // called during the current DDI entrypoint
    //

    if (! (pfo = pUMObjs->GetDDIOBJ(pfo)) ||
        (pfdg = pUMObjs->pfdg()) != NULL)
    {
        FIXUP_THREAD_UMPDOBJS;
        return pfdg;
    }

    //
    // Call FONTOBJ_pifi and cache the pointer in UMPDOBJ
    //

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    
    UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

    pfdgTmp = NULL;

    if ((pfdg = FONTOBJ_pfdg(pfo)) != NULL)
    {
        if (IS_SYSTEM_ADDRESS(pfdg))
        {
            if ((cjSize = SZ_GLYPHSET(pfdg->cRuns, pfdg->cGlyphsSupported)) &&
                (pfdgTmp = (FD_GLYPHSET *) pUMObjs->AllocUserMem(cjSize)))
            {
                if (GreCopyFD_GLYPHSET(pfdgTmp, pfdg, cjSize, TRUE))
                    pUMObjs->pfdg(pfdgTmp);
                else
                    pfdgTmp = NULL;
            }
        }
        else
        {
            pfdgTmp = pfdg;
            pUMObjs->pfdg(pfdgTmp);
        }
    }

    UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

    FIXUP_THREAD_UMPDOBJS;
    return pfdgTmp;
}

PFD_GLYPHATTR  APIENTRY NtGdiFONTOBJ_pQueryGlyphAttrs(
    FONTOBJ *pfo,
    ULONG   iMode
)
{
    PFD_GLYPHATTR   pfdga, pfdgaTmp;
    ULONG   i;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) == NULL)
    {
        WARNING("Invalid parameter passed to NtGdiFONTOBJ_pQueryGlyphAttrs\n");
        FIXUP_THREAD_UMPDOBJS;
        return FALSE;
    }

    pfdga = NULL;

    if ((pfdgaTmp = pUMObjs->pfdga()) == NULL)
    {

        RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
        
        UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

        pfdgaTmp = FONTOBJ_pQueryGlyphAttrs(pfo, iMode);

        if (pfdgaTmp)
        {
            ULONG   cjSize;

            cjSize = ((PFD_GLYPHATTR)pfdgaTmp)->cjThis;
            pfdga = (PFD_GLYPHATTR) pUMObjs->AllocUserMem(cjSize);

            if (pfdga)
            {
                RtlCopyMemory((PVOID) pfdga, (PVOID) pfdgaTmp, cjSize);
                pUMObjs->pfdga(pfdga);
            }
        }

        UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);

    }
    else
        pfdga = pfdgaTmp;

    FIXUP_THREAD_UMPDOBJS;
    return pfdga;
}

//
// if the return value is a system address, we copy it into user memory
//
IFIMETRICS * APIENTRY NtGdiFONTOBJ_pifi(
    FONTOBJ *pfo
    )
{
    IFIMETRICS  *pifi = NULL, *pifiTmp;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Check if this function has already been
    // called during the current DDI entrypoint
    //

    if (! (pfo = pUMObjs->GetDDIOBJ(pfo)) ||
        (pifi = pUMObjs->pifi()) != NULL)
    {
        FIXUP_THREAD_UMPDOBJS;
        return pifi;
    }

    //
    // Call FONTOBJ_pifi and cache the pointer in UMPDOBJ
    //

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    
    UMPDAcquireRFONTSem(rfto, pUMObjs, 0, 0, NULL);

    if ((pifi = FONTOBJ_pifi(pfo)) != NULL &&
        IS_SYSTEM_ADDRESS(pifi))
    {
        pifiTmp = pifi;
        pifi = (PIFIMETRICS) pUMObjs->AllocUserMem(pifi->cjThis);

        if (pifi != NULL)
        {
            RtlCopyMemory (pifi, pifiTmp, pifiTmp->cjThis);
            pUMObjs->pifi(pifi);
        }
    }

    UMPDReleaseRFONTSem(rfto, pUMObjs, NULL, NULL, NULL);
    
    FIXUP_THREAD_UMPDOBJS;
    return pifi;
}


BOOL APIENTRY NtGdiSTROBJ_bEnumInternal(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos,
    BOOL       bPositionsOnly
    )
{
    GLYPHPOS    *pgp, *pgpTmp;
    ULONG       c;
    BOOL        bRet;

    EXTRACT_THREAD_UMPDOBJS(DDI_ERROR);

    //
    // bRet from STROBJ_bEnum could have 3 different values:
    // TRUE: more glyphs remained to be enumurated
    // FALSE: no more glyphs to be enumrated
    // DDI_ERROR: failure
    //

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) == NULL ||
        ((bRet = bPositionsOnly ? STROBJ_bEnumPositionsOnly(pstro, &c, &pgp) : STROBJ_bEnum(pstro, &c, &pgp)) == DDI_ERROR))
    {
        FIXUP_THREAD_UMPDOBJS;
        return DDI_ERROR;
    }
    else
    {
        // over cautious here
        if (BALLOC_OVERFLOW1(c, GLYPHPOS) ||
            (!(pgpTmp = (GLYPHPOS *) pUMObjs->AllocUserMem(sizeof(GLYPHPOS) * c))))
        {
            FIXUP_THREAD_UMPDOBJS;
            return DDI_ERROR;
        }
    }

    RtlCopyMemory(pgpTmp, pgp, sizeof(GLYPHPOS)*c);

    __try
    {
        ProbeAndWriteStructure(ppgpos, pgpTmp, PVOID);
        ProbeAndWriteUlong(pc, c);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("fail to write in ppgpos or pc\n");
        c = 0;
        bRet = FALSE;
    }

    //
    // NULL out GLYPHPOS.pgdf field to force the driver
    // to call FONTOBJ_cGetGlyphs.
    //

    for (ULONG i=0; i < c; i++)
        pgpTmp[i].pgdf = NULL;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

BOOL APIENTRY NtGdiSTROBJ_bEnum(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
    return NtGdiSTROBJ_bEnumInternal(pstro, pc, ppgpos, FALSE);
}

BOOL APIENTRY NtGdiSTROBJ_bEnumPositionsOnly(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    )
{
    return NtGdiSTROBJ_bEnumInternal(pstro, pc, ppgpos, TRUE);
}


BOOL APIENTRY NtGdiSTROBJ_bGetAdvanceWidths(
    STROBJ   *pstro,
    ULONG     iFirst,
    ULONG     c,
    POINTQF  *pptqD
)
{

    BOOL      bRet = FALSE;
    POINTQF  *pptqDTmp;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) == NULL ||
        BALLOC_OVERFLOW1(c, POINTQF) ||
        !(pptqDTmp = (POINTQF *) pUMObjs->AllocUserMem(sizeof(POINTQF) * c)))
    {
        FIXUP_THREAD_UMPDOBJS;
        return bRet;
    }

    // kernel mode can not fail

    bRet = STROBJ_bGetAdvanceWidths(pstro, iFirst, c,  pptqDTmp);

    if (bRet)
    {
        __try
        {
            ProbeAndWriteAlignedBuffer( pptqD, pptqDTmp, sizeof(POINTQF) * c, sizeof(LARGE_INTEGER));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("fail to write in ppgpos or pc\n");
            bRet = FALSE;
        }
    }
    
    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}



VOID APIENTRY NtGdiSTROBJ_vEnumStart(
    IN STROBJ  *pstro   
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    if ((pstro = pUMObjs->GetDDIOBJ(pstro)) != NULL)
        STROBJ_vEnumStart(pstro);

    FIXUP_THREAD_UMPDOBJS;
}

DWORD APIENTRY NtGdiSTROBJ_dwGetCodePage(
    STROBJ  *pstro
    )

{
    EXTRACT_THREAD_UMPDOBJS(0);

    DWORD dwRet = ((pstro = pUMObjs->GetDDIOBJ(pstro)) != NULL) ?
               STROBJ_dwGetCodePage(pstro) :
               0;

    FIXUP_THREAD_UMPDOBJS;
    return dwRet;
}

//
// private
//
DHPDEV NtGdiGetDhpdev(HDEV hdev)
{
    return ValidUmpdHdev(hdev) ? ((PPDEV)hdev)->dhpdev : NULL;
}

BOOL NtGdiSetPUMPDOBJ(
    HUMPD   humpd,
    BOOL    bStoreID,
    HUMPD   *phumpd,
    BOOL    *pbWOW64
)
{
    UMPDREF umpdRef(humpd);
    
    if (
        (bStoreID && humpd == NULL)     ||
        (bStoreID && umpdRef.pumpdGet() == NULL) ||
        (!bStoreID && phumpd == NULL)
       )
    {
        return FALSE;
    }

    PW32THREAD      pw32thread = W32GetCurrentThread();
    HUMPD           hSaved = pw32thread->pUMPDObj ? (HUMPD)((PUMPDOBJ)pw32thread->pUMPDObj)->hGet() : 0;
    HUMPD           humpdTmp;
    
    if (!bStoreID)
    {
        __try
        {
            ProbeAndReadBuffer(&humpdTmp,phumpd,sizeof(HUMPD));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetPUMPDOBJ probe phumpd failed\n");
            return FALSE;
        }
    }
    
    if (bStoreID) 
    {
        BOOL        bWOW64;

        bWOW64 = umpdRef.bWOW64();
        
        __try
        {
            if (pbWOW64)
            {
                ProbeAndWriteBuffer(pbWOW64, &bWOW64, sizeof(BOOL));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetPUMPDOBJ: bad pumpdobj or probe pbWOW64 failed\n");
            return FALSE;
        }
#if defined(_WIN64)
        if (bWOW64)
        {
            ASSERTGDI(pw32thread->pClientID == NULL, "NtGdiSetPUMPDOBJ: existing non-null pClientID\n");

            if (pw32thread->pClientID == NULL)
            {
                KERNEL_PVOID  pclientID = (KERNEL_PVOID)PALLOCMEM(sizeof(PRINTCLIENTID), 'dipG');
                
                if (pclientID)
                {
                    __try
                    {
                        ((PRINTCLIENTID*)pclientID)->clientTid = umpdRef.clientTid();
                        ((PRINTCLIENTID*)pclientID)->clientPid = umpdRef.clientPid();
                        pw32thread->pClientID = pclientID;
    
                        ProbeAndWriteBuffer(phumpd, &hSaved, sizeof(HUMPD));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNING("NtGdiSetPUMPDOBJ: wow64 failed to access pumpdobj or ppumpdobj\n");
                        pw32thread->pClientID = NULL;
                        VFREEMEM(pclientID);
                        return FALSE;
                    }
                }
                else
                {
                    WARNING("NtGdiSetPUMPDOBJ: failed to allocate pclientID\n");
                    return FALSE;
                }
            }
            else
            {
                WARNING("NtGdiSetPUMPDOBJ: bWOW64 and existing pClientID\n");
                return FALSE;
            }
        }
        else
#endif
        {
            __try
            {
                ProbeAndWriteBuffer(phumpd, &hSaved, sizeof(HUMPD));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("NtGdiSetPUMPDOBJ: failed to access ppumpdobj\n");
                return FALSE;
            }           
        }
    }
    else
    {
        if (humpdTmp != hSaved)
        {
            WARNING("NtGdiSetPUMPDOBJ: mismatched pumpdobj\n");
            return FALSE;
        }
#if defined(_WIN64)        
        UMPDREF    umpdSaved(hSaved);
        
        ASSERTGDI(umpdSaved.pumpdGet(), "NtGdiSetPUMPDOBJ: saved pumpdobj is NULL\n");

        if (umpdSaved.bWOW64() && pw32thread->pClientID)
        {
            VFREEMEM(pw32thread->pClientID);
            pw32thread->pClientID = NULL;
        }
#endif
    }

    pw32thread->pUMPDObj = umpdRef.pumpdGet();

    return TRUE;
}

//
// private, called only for WOW64 printing
//

BOOL  NtGdiBRUSHOBJ_DeleteRbrush(BRUSHOBJ *pbo, BRUSHOBJ *pboB)
{
    EXTRACT_THREAD_UMPDOBJS(FALSE);
    
    BRUSHOBJ *pbokm;

    if (pbo)
    {
        pbokm = pUMObjs->GetDDIOBJ(pbo);

        if (pbokm && pbokm->pvRbrush && !IS_SYSTEM_ADDRESS(pbokm->pvRbrush))
        {
            EngFreeUserMem(DBRUSHSTART(pbokm->pvRbrush));
            pbokm->pvRbrush = NULL;
        }
    }

    if (pboB)
    {
        pbokm = pUMObjs->GetDDIOBJ(pboB);

        if (pbokm && pbokm->pvRbrush && !IS_SYSTEM_ADDRESS(pbokm->pvRbrush))
        {
            EngFreeUserMem(DBRUSHSTART(pbokm->pvRbrush));
            pbokm->pvRbrush = NULL;
        }
    }

    FIXUP_THREAD_UMPDOBJS;
    return TRUE;
}

// Private, used only for WOW64 printing

BOOL APIENTRY NtGdiUMPDEngFreeUserMem(KERNEL_PVOID *ppv)
{
#if defined(_WIN64)    
    PVOID pv = NULL, pvTmp;

    __try
    {
        if (ppv)
        {
            ProbeAndReadBuffer(&pv, ppv, sizeof(PVOID));            
            ProbeForRead(pv, sizeof(ULONG), sizeof(ULONG));

            // Winbug 397346
            // We are doing the following probing since EngFreeUserMem
            // does NOT try-except/probe while accessing pvTmp.

            pvTmp = (PBYTE)pv - sizeof(ULONG_PTR)*4;
            ProbeForRead(pvTmp, sizeof(ULONG_PTR)*4, sizeof(ULONG_PTR));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiUMPDEngFreeUserMem: bad input pointer\n"); 
        return FALSE;
    }
    
    if (pv)
       EngFreeUserMem(pv);
#endif
    
    return TRUE;
    
}


HSURF APIENTRY NtGdiEngCreateDeviceSurface(
    DHSURF  dhsurf, 
    SIZEL  sizl,    
    ULONG  iFormatCompat    
   )
{
    TRACE_INIT (("Entering NtGdiEngCreateDeviceSurface\n"));

    if ((iFormatCompat > BMF_8RLE) || (iFormatCompat < BMF_1BPP))
        return 0;

    //
    // set high bit of iFormatCompat to indicate umpd driver
    //
    return (EngCreateDeviceSurface(dhsurf, sizl, iFormatCompat|= UMPD_FLAG));
}

HBITMAP APIENTRY NtGdiEngCreateDeviceBitmap(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    )
{
    if (!ValidUmpdSizl(sizl))
        return 0;

    if ((iFormatCompat > BMF_8RLE) || (iFormatCompat < BMF_1BPP))
        return 0;

    return EngCreateDeviceBitmap(dhsurf, sizl, iFormatCompat | UMPD_FLAG);
}

VOID APIENTRY NtGdiPATHOBJ_vGetBounds(
    IN PATHOBJ  *ppo,   
    OUT PRECTFX  prectfx    
   )
{
    RECTFX     rectfx;
    EXTRACT_THREAD_UMPDOBJS;

    ppo = pUMObjs->GetDDIOBJ(ppo);

    if (ppo)
    {
       PATHOBJ_vGetBounds(ppo, &rectfx);

       __try
       {
           ProbeAndWriteStructure(prectfx, rectfx, RECTFX);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
           WARNING("fail to write into prectfx\n");
       }
    }

    FIXUP_THREAD_UMPDOBJS;
}

BOOL APIENTRY NtGdiPATHOBJ_bEnum(
    IN PATHOBJ  *ppo,   
    OUT PATHDATA  *ppd  
   )
{
    PATHDATA    pathdata;
    BOOL        bRet = FALSE;
    PVOID       pvTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if (ppo = pUMObjs->GetDDIOBJ(ppo))
    {
        bRet = PATHOBJ_bEnum(ppo, &pathdata);

        // over cautious
        if (BALLOC_OVERFLOW1(pathdata.count, POINTFIX))
        {
            FIXUP_THREAD_UMPDOBJS;
            return FALSE;
        }

        if (pvTmp = pUMObjs->AllocUserMem(sizeof(POINTFX) * pathdata.count))
        {
            RtlCopyMemory(pvTmp, pathdata.pptfx, sizeof(POINTFX) * pathdata.count);
            pathdata.pptfx = (POINTFIX *) pvTmp;
        }
        else
            bRet = FALSE;
    }

    if (pvTmp == NULL)
        RtlZeroMemory(&pathdata, sizeof(pathdata));

    __try
    {
        ProbeAndWriteStructure(ppd, pathdata, PATHDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("fail to write into ppd\n");
        bRet = FALSE;
    }

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


VOID APIENTRY NtGdiPATHOBJ_vEnumStart(
    IN PATHOBJ  *ppo    
   )
{
    EXTRACT_THREAD_UMPDOBJS;

    if ((ppo = pUMObjs->GetDDIOBJ(ppo)) != NULL)
        PATHOBJ_vEnumStart(ppo);

    FIXUP_THREAD_UMPDOBJS;
}

VOID APIENTRY NtGdiPATHOBJ_vEnumStartClipLines(
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    SURFOBJ   *pso,
    LINEATTRS *pla
    )

{
    LINEATTRS   lineattrs;

    EXTRACT_THREAD_UMPDOBJS;

    UMPDSURFOBJ umso(pso, pUMObjs);

    pso = umso.pso();
    ppo = pUMObjs->GetDDIOBJ(ppo);

    if (pso && ppo && bCaptureLINEATTRS(&pla, &lineattrs))
    {
        pco = pUMObjs->GetDDIOBJ(pco, &pso->sizlBitmap);
        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        if (pla && pla->pstyle)
            VFREEMEM(pla->pstyle);
    }

    FIXUP_THREAD_UMPDOBJS;
}


BOOL APIENTRY NtGdiPATHOBJ_bEnumClipLines(
    PATHOBJ  *ppo,
    ULONG     cb,
    CLIPLINE *pcl
    )

{
    BOOL    bRet = FALSE;
    PVOID   pvTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(FALSE);

    if (cb <= sizeof(CLIPLINE))
    {
        FIXUP_THREAD_UMPDOBJS;
        return(FALSE);
    }

    if ((ppo = pUMObjs->GetDDIOBJ(ppo)) != NULL &&
        (pvTmp = PALLOCNOZ(cb, UMPD_MEMORY_TAG)) != NULL)
    {
        bRet = PATHOBJ_bEnumClipLines(ppo, cb, (CLIPLINE *) pvTmp);
    }

    __try
    {
        ProbeForWrite(pcl, cb, sizeof(ULONG));

        if (pvTmp != NULL)
            RtlCopyMemory(pcl, pvTmp, cb);
        else
            RtlZeroMemory(pcl, cb);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (pvTmp != NULL)
        VFREEMEM(pvTmp);

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}


PVOID APIENTRY  NtGdiFONTOBJ_pvTrueTypeFontFile(
    IN FONTOBJ  *pfo,   
    OUT ULONG  *pcjFile 
   )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    PVOID   pBase, p = NULL;
    ULONG   size;

    if ((pfo = pUMObjs->GetDDIOBJ(pfo)) != NULL &&
        (p = pUMObjs->pvFontFile(&size)) == NULL &&
        (p = FONTOBJ_pvTrueTypeFontFileUMPD(pfo, &size, &pBase)) != NULL)
    {
        pUMObjs->pvFontFile(p, pBase, size);
    }

    if (p == NULL)
        size = 0;

    if (pcjFile != NULL)
    {
        __try
        {
            ProbeAndWriteStructure(pcjFile, size, DWORD);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("fail to write into pcjFilie\n");
            p = NULL;
        }
    }

    FIXUP_THREAD_UMPDOBJS;
    return p;
}

HANDLE APIENTRY NtGdiXLATEOBJ_hGetColorTransform(
    XLATEOBJ *pxlo
    )
{
    EXTRACT_THREAD_UMPDOBJS(NULL);

    HANDLE hRet = ((pxlo = pUMObjs->GetDDIOBJ(pxlo)) != NULL) ?
                XLATEOBJ_hGetColorTransform(pxlo) :
                NULL;

    FIXUP_THREAD_UMPDOBJS;
    return hRet;
}

ULONG APIENTRY NtGdiXLATEOBJ_cGetPalette(
    IN XLATEOBJ* pxlo,  
    IN ULONG     iPal,  
    IN ULONG     cPal,  
    IN ULONG     *pPal  
   )
{
    ULONG       ulRet = 0;
    ULONG       *pPalTmp = NULL;

    EXTRACT_THREAD_UMPDOBJS(0);

    pxlo = pUMObjs->GetDDIOBJ(pxlo);

    if (pxlo)
    {
       if (pPal)
       {
           if (BALLOC_OVERFLOW1(cPal, DWORD))
           {
               FIXUP_THREAD_UMPDOBJS;
               return 0;
           }

           pPalTmp = (PULONG)PALLOCNOZ(sizeof(DWORD)*cPal, UMPD_MEMORY_TAG);
       }

       if (pPalTmp)
       {
          ulRet = XLATEOBJ_cGetPalette(pxlo, iPal, cPal, pPalTmp);

          if (ulRet)
          {
              if (!bSafeCopyBits(pPal, pPalTmp, sizeof(DWORD)*cPal))
              ulRet = 0;
          }

          VFREEMEM(pPalTmp);
       }
    }

    FIXUP_THREAD_UMPDOBJS;
    return ulRet;
}

ULONG APIENTRY NtGdiXLATEOBJ_iXlate(
    IN XLATEOBJ  *pxlo, 
    IN ULONG  iColor    
   )
{
    EXTRACT_THREAD_UMPDOBJS(0xffffffff);

    ULONG ulRet = ((pxlo = pUMObjs->GetDDIOBJ(pxlo)) != NULL ? XLATEOBJ_iXlate(pxlo, iColor) : NULL);

    FIXUP_THREAD_UMPDOBJS;

    return ulRet;
}

BOOL APIENTRY NtGdiEngCheckAbort(
    SURFOBJ *pso
    )

{
    EXTRACT_THREAD_UMPDOBJS(TRUE);

    UMPDSURFOBJ umso(pso, pUMObjs);
    pso = umso.pso();

    BOOL bRet = pso ? EngCheckAbort(pso) : TRUE;

    FIXUP_THREAD_UMPDOBJS;
    return bRet;
}

//
// Ported from EngComputeGlyphSet with necessary changes
//

FD_GLYPHSET* APIENTRY NtGdiEngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )

{
    FD_GLYPHSET *pGlyphSet, *pGlyphSetTmp = NULL;
    ULONG       cjSize;

    EXTRACT_THREAD_UMPDOBJS(NULL);

    //
    // Call kernel-mode EngComputeGlyphSet first and then copy
    // the FD_GLYPHSET structure into a temporary user-mode buffer
    //

    if ((pGlyphSet = EngComputeGlyphSet(nCodePage, nFirstChar, cChars)) &&
        (cjSize = pGlyphSet->cjThis) &&
        (pGlyphSetTmp = (PFD_GLYPHSET) pUMObjs->AllocUserMem(cjSize)))
    {
        if (!GreCopyFD_GLYPHSET(pGlyphSetTmp, pGlyphSet, cjSize, TRUE))
            pGlyphSetTmp = NULL;
    }

    //
    // Free the kernel copy of the FD_GLYPHSET structure right away
    //

    if (pGlyphSet)
        EngFreeMem(pGlyphSet);

    FIXUP_THREAD_UMPDOBJS;

    return (pGlyphSetTmp);
}

LONG APIENTRY NtGdiHT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    )
{
    if (pPaletteEntry)
    {
       LPPALETTEENTRY  pPal = NULL;
       ULONG ulRet = 0;
       ULONG c = HT_Get8BPPFormatPalette(NULL, RedGamma, GreenGamma, BlueGamma);

       if (c)
       {
           if (BALLOC_OVERFLOW1(c, PALETTEENTRY))
               return 0;

           pPal = (LPPALETTEENTRY)PALLOCNOZ(c*sizeof(PALETTEENTRY), UMPD_MEMORY_TAG);
       }

       if (pPal)
       {
           ulRet = HT_Get8BPPFormatPalette(pPal, RedGamma, GreenGamma, BlueGamma);

           if (!bSafeCopyBits(pPaletteEntry, pPal, c*sizeof(PALETTEENTRY)))
               ulRet = 0;

           VFREEMEM(pPal);
       }

       return ulRet;
    }
    else
        return  HT_Get8BPPFormatPalette(NULL, RedGamma, GreenGamma, BlueGamma);

}


LONG APIENTRY NtGdiHT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    )
{
    LONG    c = HT_Get8BPPMaskPalette(NULL, Use8BPPMaskPal, CMYMask, RedGamma, GreenGamma, BlueGamma);

    if (pPaletteEntry) {

        LPPALETTEENTRY  pPal = NULL;
        LONG            cbPal;

        if (((cbPal = c * sizeof(PALETTEENTRY)) > 0)                    &&
            (!BALLOC_OVERFLOW1(c, PALETTEENTRY))                        &&
            (pPal = (LPPALETTEENTRY)PALLOCNOZ(cbPal, UMPD_MEMORY_TAG))  &&
            (bSafeReadBits(pPal, pPaletteEntry, cbPal))                 &&
            (c = HT_Get8BPPMaskPalette(pPal,
                                       Use8BPPMaskPal,
                                       CMYMask,
                                       RedGamma,
                                       GreenGamma,
                                       BlueGamma))                      &&
            (bSafeCopyBits(pPaletteEntry, pPal, cbPal))) {

            NULL;

        } else {

            c = 0;
        }

        if (pPal) {

           VFREEMEM(pPal);
        }
    }

    return(c);
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\umpddrv.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpddrv.cxx

Abstract:

    User-mode printer driver support for Drv callback functions

Environment:

    Windows NT 5.0

Revision History:

    07/8/97 -lingyunw-
        Created it.

    09/17/97 -davidx-
        Clean up km-um thunking.

--*/

#include "precomp.hxx"

#if !defined(_GDIPLUS_)

extern BOOL GreCopyFD_GLYPHSET(FD_GLYPHSET *dst, FD_GLYPHSET *src, ULONG cjSize, BOOL bFromKernel);
extern HSEMAPHORE ghsemEUDC2;

DWORD
UMPDOBJ::Thunk(PVOID pvIn, ULONG cjIn, PVOID pvOut, ULONG cjOut)
{
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPalette),
                "ghsemPalette is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemHmgr),
               "ghsemHmgr is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemDriverMgmt),
               "ghsemDriverMgmt is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemRFONTList),
               "ghsemRFONTList is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPublicPFT),
               "ghsemPublicPFT is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemGdiSpool),
               "ghsemGdiSpool is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemWndobj),
               "ghsemWndobj is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemGlyphSet),
               "ghsemGlyphSet is held calling back to user mode driver\n");

    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemWndobj),
               "ghsemWndobj is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemPrintKView),
               "ghsemPrintKView is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
               "ghsemShareDevLock is held calling back to user mode driver\n");
    
    ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemEUDC1),
               "ghsemEUDC1 is held calling back to user mode driver\n");
    
    // WINBUG #214225 we should enable these assertion when 214225 is fixed.
    //ASSERTGDI(!GreIsSemaphoreOwnedByCurrentThread(ghsemEUDC2),
    //           "ghsemEUDC2 is held calling back to user mode driver\n");
    
    //ASSERTGDI(KeAreApcsDisabled() == 0,
    //           "UMPDOBJ::Thunk(): holding some semaphore(s) while calling back to user mode\n");

    if (KeAreApcsDisabled())
    {
        WARNING("UMPDOBJ:Thunk(): holding kernel semaphore(s) while calling into user mode\n");
    }
    
#if defined(_WIN64)
    if(bWOW64())
    {
        // pvIn and pvOut are pointers to stack ... fix this
        UM64_PVOID      umIn = AllocUserMem(cjIn);
        UM64_PVOID      umOut = AllocUserMem(cjOut);
        KERNEL_PVOID    kmIn = GetKernelPtr(umIn);
        KERNEL_PVOID    kmOut = GetKernelPtr(umOut);
        NTSTATUS        status;
        ULONG           ulType = ((UMPDTHDR*)pvIn)->umthdr.ulType;

        if(umIn == NULL || umOut == NULL) return -1;

        RtlCopyMemory(kmIn, pvIn, cjIn);

        if ((ulType == INDEX_DrvQueryFont && ((QUERYFONTINPUT*)pvIn)->iFace) ||
            (ulType == INDEX_DrvQueryFontTree && (((QUERYFONTINPUT*)pvIn)->iMode & (QFT_GLYPHSET | QFT_KERNPAIRS))))
        {
            ((QUERYFONTINPUT*)pvIn)->cjMaxData = ((QUERYFONTINPUT*)kmIn)->cjMaxData = ulGetMaxSize();
            ((QUERYFONTINPUT*)pvIn)->pv = ((QUERYFONTINPUT*)kmIn)->pv = (PVOID)((PBYTE)umOut + cjOut);
        }

        PROXYPORT proxyport(m_proxyPort);

        status = proxyport.SendRequest(umIn, cjIn, umOut, cjOut);
        RtlCopyMemory(pvOut, kmOut, cjOut);

        if(!status)
            return 0;
        else
            return -1;

    }
    else
#endif
    {
        return ClientPrinterThunk(pvIn, cjIn, pvOut, cjOut);
    }
}

BOOL bIsFreeHooked(DHPDEV dhpdev, PUMPDOBJ pumpdobj)
{
    BOOL bRet = TRUE;

    PUMDHPDEV  pUMdhpdev = (PUMDHPDEV) dhpdev;

    if (!pumpdobj->bWOW64())
    {
        __try
        {
            PUMPD  pUMPD;

            ProbeForRead (pUMdhpdev, sizeof(UMDHPDEV), sizeof(BYTE));
            pUMPD = pUMdhpdev->pUMPD;

            ProbeForRead (pUMPD, sizeof(UMPD), sizeof(BYTE));

            if (pUMPD->apfn[INDEX_DrvFree] == NULL)
            {
                bRet = FALSE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING ("fail to read dhpdev\n");
            bRet = FALSE;;
        }
    }
    return bRet;
}

//
// BOOL UMPDDrvEnableDriver
//      UMPD DrvEnableDriver thunk.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      pswzDriver       Driver Path Name
//      ppUMPD           Pointer to a buffer receiving a PUMPD pointer
//                       which should be filled by the client UMPD thunk
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.

BOOL UMPDDrvDriverFn(
    PVOID          cookie,
    BOOL *         pbDrvFn
    )
{
    DRVDRIVERFNINPUT    Input;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_UMDriverFN;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.cookie = cookie;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), (BOOL *) pbDrvFn, (sizeof(BOOL) * INDEX_LAST)) != 0xffffffff;
    }
    else
    {
        return FALSE;
    }
}

//
// BOOL UMPDDrvEnableDriver
//      UMPD DrvEnableDriver thunk.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      pswzDriver       Driver Path Name
//      ppUMPD           Pointer to a buffer receiving a PUMPD pointer
//                       which should be filled by the client UMPD thunk
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.

BOOL UMPDDrvEnableDriver(
    LPWSTR         pwszDriver,
    PVOID         *pCookie
    )
{
    DRVENABLEDRIVERINPUT Input;
    XUMPDOBJ             XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        if (pwszDriver == NULL)
        {
            WARNING ("null pwszDriver passed in UMPDDrvEnableDriver\n");
            return FALSE;
        }

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_UMPDDrvEnableDriver;   //index for DrvEnableDriver
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pwszDriver = pwszDriver;

        return pumpdobj->ThunkStringW(&Input.pwszDriver) &&
               pumpdobj->Thunk(&Input, sizeof(Input), pCookie, sizeof(PVOID)) != 0xffffffff;
    }
    else
    {
        return FALSE;
    }
}

//
//
// BOOL UMPDDrvDisablePDEV
//      UMPD DrvDisablePDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisablePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisablePDEV(
    DHPDEV  dhpdev
    )
{
    XUMPDOBJ   XUMObjs;

    if(XUMObjs.bValid())
    {
        DHPDEVINPUT Input;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDisablePDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);

        PW32THREAD pThread = W32GetCurrentThread();

        if (pThread->pUMPDObjs == NULL)
        {
            DestroyUMPDHeap((PUMPDHEAP) pThread->pUMPDHeap);
            pThread->pUMPDHeap = NULL;
        }
    }

}

//
// BOOL UMPDDrvEnablePDEV
//      UMPD DrvEnablePDEV thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOLEAN
//
// Arguments:
//      refer to DrvEnablePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

DHPDEV
UMPDDrvEnablePDEV(
    PDEVMODEW pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,        // passed in as ppdev
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )
{
    DRVENABLEPDEVINPUT  Input;
    ULONG               dmSize;
    DHPDEV              dhpdev;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEnablePDEV;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.umpdCookie = (PVOID) (((PPDEV) hdev)->dhpdev);
        Input.pdm = pdm;
        Input.pLogAddress = pLogAddress;
        Input.cPatterns = cPatterns;
        Input.phsurfPatterns = phsurfPatterns;
        Input.cjCaps = cjCaps;
        Input.cjDevInfo = cjDevInfo;
        Input.hdev = hdev;
        Input.pDeviceName = pDeviceName;
        Input.hPrinter = hPrinter;
        Input.bWOW64 = pumpdobj->bWOW64();
        Input.clientPid = Input.bWOW64 ? W32GetCurrentPID() : 0;

        dmSize = pdm ? pdm->dmSize + pdm->dmDriverExtra : 0;

        //
        // Allocate temporary output buffers
        //

        if (phsurfPatterns &&
            !(Input.phsurfPatterns = (HSURF *) pumpdobj->AllocUserMemZ(sizeof(HSURF)*cPatterns)) ||
            pdevcaps && !(Input.pdevcaps = (ULONG *) pumpdobj->AllocUserMemZ(cjCaps)) ||
            pDevInfo && !(Input.pDevInfo = (DEVINFO *) pumpdobj->AllocUserMemZ(cjDevInfo)))
        {
            return NULL;
        }

        //
        // Thunk to user mode
        //

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pdm, dmSize) ||
            !pumpdobj->ThunkStringW(&Input.pLogAddress) ||
            !pumpdobj->ThunkStringW(&Input.pDeviceName) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &dhpdev, sizeof(dhpdev)) == 0xffffffff)
        {
            return NULL;
        }

        if (phsurfPatterns)
            RtlCopyMemory(phsurfPatterns, pumpdobj->GetKernelPtr(Input.phsurfPatterns), cPatterns*sizeof(HSURF));

        if (pdevcaps)
            RtlCopyMemory(pdevcaps, pumpdobj->GetKernelPtr(Input.pdevcaps), cjCaps);

        if (pDevInfo)
        {
            //
            // fail the call if driver gives us back a NULL hpalDefault
            //
            DEVINFO *   kmDevInfo = (DEVINFO *) pumpdobj->GetKernelPtr(Input.pDevInfo);

            if (kmDevInfo->hpalDefault == NULL)
            {
               if (dhpdev)
                   UMPDDrvDisablePDEV(dhpdev);
               return NULL;
            }

            RtlCopyMemory(pDevInfo, kmDevInfo, cjDevInfo);
        }

        return (dhpdev);
    }
    else
    {
        return NULL;
    }
}

//
// BOOL UMPDDrvCompletePDEV
//      UMPD DrvCompletePDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvCompletePDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


VOID
UMPDDrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )
{
    DRVCOMPLETEPDEVINPUT Input;
    XUMPDOBJ             XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvCompletePDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.hdev = hdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}

//
//
// BOOL UMPDDrvResetPDEV
//      UMPD DrvResetPDEV thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvResetPDEV
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL
UMPDDrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )
{
    DRVRESETPDEVINPUT Input;
    BOOL              bRet;
    XUMPDOBJ          XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvResetPDEV;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdevOld = dhpdevOld;
        Input.dhpdevNew = dhpdevNew;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvEnableSurface
//      UMPD DrvEnableSurface thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      HSURF
//
// Arguments:
//      refer to DrvEnableSurface
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//



HSURF
UMPDDrvEnableSurface(
    DHPDEV dhpdev
    )
{
    DHPDEVINPUT Input;
    HSURF       hSurf;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEnableSurface;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        if (XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &hSurf, sizeof(HSURF)) == 0xffffffff)
            hSurf = NULL;

        if (hSurf)
        {
           SURFREF sr(hSurf);

           if (sr.bValid())
           {
              // According to the DDK:
              // If the surface is device-managed, at a minimum,
              // the driver must handle DrvTextOut, DrvStrokePath, and DrvCopyBits
              //

              if (sr.ps->iType() == STYPE_DEVICE)
              {
                 if (!(sr.ps->SurfFlags & HOOK_BITBLT) ||
                     !(sr.ps->SurfFlags & HOOK_STROKEPATH) ||
                     !(sr.ps->SurfFlags & HOOK_TEXTOUT))
                 {
                     hSurf = 0;
                 }
              }
           }
           else
           {
              hSurf = 0;
           }
        }
        return (hSurf);
    }
    else
    {
        return NULL;
    }
}

//
//
// BOOL UMPDDrvDisableSurface
//      UMPD DrvEnableSurface thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisableSurface
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisableSurface(
    DHPDEV dhpdev
    )
{
    DHPDEVINPUT Input;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDisableSurface;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}

//
//
// BOOL UMPDDrvDisableDriver
//      UMPD DrvDisableDriver thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      VOID
//
// Arguments:
//      refer to DrvDisableDriver
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

VOID
UMPDDrvDisableDriver(
    )
{
#if 0
    UMPDTHDR    umpdthdr;
    XUMPDOBJ    XUMObjs;

    if(XUMObjs.bValid())
    {
        umpdthdr.umthdr.cjSize = sizeof(umpdthdr);
        umpdthdr.umthdr.ulType = INDEX_DrvDisableDriver;
        umpdthdr.humpd = XUMObjs.hUMPD();

        XUMObjs.pumpdobjs()->Thunk(&umpdthdr, sizeof(umpdthdr), NULL, 0);
    }
#else
    WARNING("Unsupported UMPD entry point being called\n");
    DbgBreakPoint();
#endif
}


#define  UMPD_SIZEINOUTPUT(Input, Output)                                           \
            ALIGN_UMPD_BUFFER(sizeof(Input)) + ALIGN_UMPD_BUFFER(sizeof(Output))

#define  UMPD_SIZESURFOBJ                           \
            ALIGN_UMPD_BUFFER(sizeof(SURFOBJ))

#define  UMPD_SIZEBITMAP(pso)                       \
            ALIGN_UMPD_BUFFER(pso->cjBits)

#define  UMPD_SIZEXLATEOBJ(pxlo)                                                    \
            (pxlo ? (ALIGN_UMPD_BUFFER(pxlo->cEntries * sizeof(ULONG)) + ALIGN_UMPD_BUFFER(sizeof(XLATEOBJ))) : 0)

#define  UMPD_SIZESTROBJ(pstro)                                                         \
            pstro ? ALIGN_UMPD_BUFFER(sizeof(WCHAR) * pstro->cGlyphs) +                 \
                    ALIGN_UMPD_BUFFER(sizeof(GLYPHPOS) * pstro->cGlyphs) +              \
                    ALIGN_UMPD_BUFFER(sizeof(STROBJ))                                   \
                  : 0

#define  UMPD_SIZELINEATTRS(plineattrs)                                                     \
            plineattrs ? ALIGN_UMPD_BUFFER(plineattrs->cstyle * sizeof(FLOAT_LONG)) +       \
                         ALIGN_UMPD_BUFFER(sizeof(LINEATTRS))                               \
                       : 0

#define  UMPD_SIZEXFORMOBJ      ALIGN_UMPD_BUFFER(sizeof(XFORMOBJ))
#define  UMPD_SIZERECTL         ALIGN_UMPD_BUFFER(sizeof(RECTL))
#define  UMPD_SIZECLIPOBJ       ALIGN_UMPD_BUFFER(sizeof(CLIPOBJ))
#define  UMPD_SIZEPOINTL        ALIGN_UMPD_BUFFER(sizeof(POINTL))
#define  UMPD_SIZEPERBANDI      ALIGN_UMPD_BUFFER(sizeof(PERBANDINFO))
#define  UMPD_SIZECOLORADJ      ALIGN_UMPD_BUFFER(sizeof(COLORADJUSTMENT))
#define  UMPD_SIZEBRUSHOBJ      ALIGN_UMPD_BUFFER(sizeof(BRUSHOBJ))
#define  UMPD_SIZEFONTOBJ       ALIGN_UMPD_BUFFER(sizeof(FONTOBJ))
#define  UMPD_SIZEBLENDOBJ      ALIGN_UMPD_BUFFER(sizeof(BLENDOBJ))
#define  UMPD_SIZEPATHOBJ       ALIGN_UMPD_BUFFER(sizeof(PATHOBJ))

/*
    BOOL UMPDOBJ::bDeleteLargeBitmaps

    Delete the duplicated bitmaps for WOW64 printing only
*/

BOOL UMPDOBJ::bDeleteLargeBitmaps(SURFOBJ *psoTrg, SURFOBJ *psoSrc, SURFOBJ *psoMsk)
{
    UMPDFREEMEMINPUT     Input;
    BOOL                    bRet;

    if (!psoTrg && !psoSrc && !psoMsk)
        return TRUE;

    ASSERTGDI(ulAllocSize() == 0, "bDeleteLargeBitmap ulAllocSize is not 0\n");

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDFreeMemory;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();

    Input.pvTrg = psoTrg ? psoTrg->pvBits : NULL;
    Input.pvSrc = psoSrc ? psoSrc->pvBits : NULL;
    Input.pvMsk = psoMsk ? psoMsk->pvBits : NULL;

    bRet = (Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) && bRet;

    ResetHeap();
    return bRet;
}

/*
    KERNEL_PVLID UMPDOBJ::UMPDAllocUserMem

    Used for WOW64 printing. Allocate user mode memory via LPC calls.
*/

KERNEL_PVOID  UMPDOBJ::UMPDAllocUserMem(ULONG cjSize)
{
    UMPDALLOCUSERMEMINPUT   Input;
    KERNEL_PVOID            pvRet = NULL;

    ASSERTGDI(ulAllocSize() == 0, "UMPDAllocUserMem ulAllocSize is not 0\n");

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDAllocUserMem;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();
    Input.cjSize = cjSize;

    if (Thunk(&Input, sizeof(Input), &pvRet, sizeof(KERNEL_PVOID)) == 0xffffffff)
    {
        ASSERTGDI(pvRet == NULL, "not NULL pvRet returned\n");
    }

    ResetHeap();
    return pvRet;
}

/*  BOOL UMPDOBJ::bSendLargeBitmap

    Used for WOW64 printing when the bitmap size is bigger than 8M.
    The bitmap will be copied into the user mode address returned by UMPDOBJ::UMPDAllocUserMem call.
*/

BOOL UMPDOBJ::bSendLargeBitmap(
    SURFOBJ *pso,
    BOOL    *pbLargeBitmap
)
{
    UMPDCOPYMEMINPUT  Input;
    KERNEL_PVOID    pvRet = NULL, pvDest;
    PVOID       pvSrc, pvBits;
    ULONG   cjBmpSize, cjBuffSize, offset = 0;
    BOOL    bRet = FALSE;

    if (!(pvDest = UMPDAllocUserMem(pso->cjBits)))
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDCopyMemory;
    Input.umpdthdr.humpd = (HUMPD) this->hGet();
    Input.pvDest = pvDest;

    ASSERTGDI(ulAllocSize() == 0, "bSendLargeBitmap ulAllocSize is not 0\n");

    cjBuffSize = ulGetMaxSize() - ALIGN_UMPD_BUFFER(sizeof(Input)) - ALIGN_UMPD_BUFFER(sizeof(KERNEL_PVOID));
    cjBmpSize = pso->cjBits;
    pvBits = pso->pvBits;

    while(cjBmpSize)
    {
        Input.cjSize = (cjBmpSize > cjBuffSize) ? cjBuffSize : cjBmpSize;

        if ((Input.pvSrc = AllocUserMem(Input.cjSize)) == NULL)
            break;

        pvSrc = GetKernelPtr(Input.pvSrc);
        RtlCopyMemory(pvSrc, pvBits, Input.cjSize);

        if ((Thunk(&Input, sizeof(Input), &pvRet, sizeof(pvRet)) == 0xffffffff) || pvRet == NULL)
            break;

        offset += Input.cjSize;
        cjBmpSize -= Input.cjSize;

        Input.pvDest = (PBYTE)pvDest + offset;
        pvBits = (PBYTE)pso->pvBits + offset;

        ResetHeap();
    }

    offset = (ULONG)(LONG_PTR)((PBYTE)pso->pvScan0 - (PBYTE)pso->pvBits);

    pso->pvBits = pvDest;
    pso->pvScan0 = (PBYTE)pso->pvBits + offset;

    if (cjBmpSize == 0)
    {
        *pbLargeBitmap = TRUE;
        bRet = TRUE;
    }
    else
    {
        ResetHeap();
        bDeleteLargeBitmaps(pso, NULL, NULL);
    }

    return bRet;
}


/*
  BOOL UMPDOBJ::bThunkLargeBitmap

  Unsed only for WOW64 printing.

  Save the orignal pvBits and pvScan0 pointers.

  Check to see whether this is a big bitmap that can't fit into the heap.
  If so, send the request to allocate user mode space in the print server
  and copy the bitmap into the new address.

  pcjSize
        At the entry point, it contains the size needed, excluding the SURFOBJ sturct and the bitmap, to thunk the current DDI call.
        When exist, it contains the size needed to thunk the current DDI call, including the SURFOBJ and the bitmap.
*/

BOOL  UMPDOBJ::bThunkLargeBitmap(
    SURFOBJ  *pso,
    PVOID    *ppvBits,
    PVOID    *ppvScan0,
    BOOL     *pbSavePtr,
    BOOL     *pbLargeBitmap,
    ULONG    *pcjSize
)
{
    BOOL    bRet = TRUE;

    ASSERTGDI(bWOW64(), "bThunkLargeBitmap called during NONE wow64 printing\n");

    if (pso && pso->pvBits)
    {
        ULONG   cjSizeNeed, cjMaxSize;

        ASSERTGDI(ulAllocSize() == 0, "bThunkLargeBitmap: ulAllocSize is not 0\n");

        *pbSavePtr = TRUE;
        *ppvBits = pso->pvBits;
        *ppvScan0 = pso->pvScan0;

        cjMaxSize = ulGetMaxSize();
        cjSizeNeed = *pcjSize + UMPD_SIZESURFOBJ;

        if (pso->pvBits)
        {
            if ((cjSizeNeed + UMPD_SIZEBITMAP(pso)) > cjMaxSize)
            {
                bRet = bSendLargeBitmap(pso, pbLargeBitmap);
            }
            else
                cjSizeNeed += UMPD_SIZEBITMAP(pso);
        }

        if (bRet)
            *pcjSize = cjSizeNeed;
    }

    return bRet;
}

/*
    BOOL UMPDOBJ::bThunkLargeBitmaps()

    Only used for WOW64 printing.

    Thunk the large bitmaps by calling UMPDOBJ::bThunkLargeBitmap().

    pbLargeTrg
    pbLargeSrc
    pbLargeMsk
        are all initialized as FALSE before calling this routine.

    cjSize
        Heap size needed, excluding the surfobj's, to thunk the DDI call.

*/

BOOL  UMPDOBJ::bThunkLargeBitmaps(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    PVOID    *ppvBitTrg,
    PVOID    *ppvScanTrg,
    PVOID    *ppvBitSrc,
    PVOID    *ppvScanSrc,
    PVOID    *ppvBitMsk,
    PVOID    *ppvScanMsk,
    BOOL     *pbSaveTrg,
    BOOL     *pbLargeTrg,
    BOOL     *pbSaveSrc,
    BOOL     *pbLargeSrc,
    BOOL     *pbSaveMsk,
    BOOL     *pbLargeMsk,
    ULONG    *pcjSize
)
{
    ULONG   cjSizeNeed, cjMaxSize;
    BOOL    bRet = TRUE;

    ASSERTGDI(bWOW64(), "bThunkLargeBitmaps called during NONE wow64 printing\n");

    if (!psoTrg && !psoSrc && !psoMsk)
        return TRUE;

    if (bRet = bThunkLargeBitmap(psoTrg, ppvBitTrg, ppvScanTrg, pbSaveTrg, pbLargeTrg, pcjSize))
        if (bRet = bThunkLargeBitmap(psoSrc, ppvBitSrc, ppvScanSrc, pbSaveSrc, pbLargeSrc, pcjSize))
            bRet = bThunkLargeBitmap(psoMsk, ppvBitMsk, ppvScanMsk, pbSaveMsk, pbLargeMsk, pcjSize);

    if (!bRet)
    {
        bDeleteLargeBitmaps((pbLargeTrg && *pbLargeTrg) ? psoTrg : NULL,
                            (pbLargeSrc && *pbLargeSrc) ? psoSrc : NULL,
                            (pbLargeMsk && *pbLargeMsk) ? psoMsk : NULL);
    }

    return bRet;
}


/* VOID UMPDOBJ::RestoreBitmap

    Used only for the WOW64 printing.

    Restore the orignal pvBits and pvScan0 pointers in SURFOBJ

*/

VOID UMPDOBJ::RestoreBitmap(
    SURFOBJ *pso,
    PVOID   pvBits,
    PVOID   pvScan0,
    BOOL    bSavePtr,
    BOOL    bLargeBitmap
)
{
    ASSERTGDI(bWOW64(), "UMPDOBJ:RestoreBitmap bSavePtr is TRUE during NONE wow64 printing\n");

    if (bLargeBitmap)
        bDeleteLargeBitmaps(pso, NULL, NULL);

    pso->pvBits = pvBits;
    pso->pvScan0 = pvScan0;
}


/* VOID UMPDOBJ::RestoreBitmaps

    Used only for the WOW64 printing.

    Save as RestoreBitmap but takes three SURFOBJ instead of one.
*/

VOID UMPDOBJ::RestoreBitmaps(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    PVOID    pvBitTrg,
    PVOID    pvScanTrg,
    PVOID    pvBitSrc,
    PVOID    pvScanSrc,
    PVOID    pvBitMsk,
    PVOID    pvScanMsk,
    BOOL     bSaveTrg,
    BOOL     bLargeTrg,
    BOOL     bSaveSrc,
    BOOL     bLargeSrc,
    BOOL     bSaveMsk,
    BOOL     bLargeMsk
)
{
    ASSERTGDI(bWOW64(), "RestoreBitmaps called during NONE wow64 printing\n");

    if (bSaveTrg || bSaveSrc || bSaveMsk)
    {
        bDeleteLargeBitmaps(bLargeTrg ? psoTrg : NULL, bLargeSrc ? psoSrc : NULL, bLargeMsk ? psoMsk : NULL);

        if (bSaveTrg)
        {
            psoTrg->pvBits  = pvBitTrg;
            psoTrg->pvScan0 = pvScanTrg;
        }

        if (bSaveSrc)
        {
            psoSrc->pvBits  = pvBitSrc;
            psoSrc->pvScan0 = pvScanSrc;
        }

        if (bSaveMsk)
        {
            psoMsk->pvBits  = pvBitMsk;
            psoMsk->pvScan0 = pvScanMsk;
        }
    }
}


//
//
// BOOL UMPDDrvStartDoc
//      UMPD DrvStartDoc thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartDoc
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL  UMPDDrvStartDoc(
    SURFOBJ *pso,
    LPWSTR   pwszDocName,
    DWORD    dwJobId
    )
{
    DRVSTARTDOCINPUT Input;
    BOOL             bRet = TRUE;
    BOOL             bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ         XUMObjs;
    PVOID            pvBits, pvScan0;
    PUMPDOBJ         pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) +
                             (pwszDocName ? ALIGN_UMPD_BUFFER((wcslen(pwszDocName) + 1) * sizeof(WCHAR)) : 0));

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartDoc;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pwszDocName = pwszDocName;
        Input.dwJobId = dwJobId;

        bRet =  pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
                pumpdobj->ThunkStringW(&Input.pwszDocName) &&
                (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) &&
                bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvEndDoc
//      UMPD DrvEndDoc thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvEndDoc
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvEndDoc(
    SURFOBJ *pso,
    FLONG fl
    )
{
    DRVENDDOCINPUT  Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEndDoc;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.fl = fl;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvStartPage
//      UMPD DrvStartPage thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartPage
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStartPage(
    SURFOBJ *pso
    )
{
    SURFOBJINPUT    Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartPage;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvSendPage
//      UMPD DrvSendPage thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvSendPage
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvSendPage(
    SURFOBJ *pso
    )
{
    SURFOBJINPUT    Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvSendPage;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


//
//
// BOOL UMPDDrvEscape
//      UMPD DrvEscape thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvEscape
//
// History:
//      8/14/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


ULONG UMPDDrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    )
{
    DRVESCAPEINPUT  Input;
    ULONG           ulRet = GDI_ERROR;
    XUMPDOBJ        XUMObjs;
    BOOL            bContinue = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return GDI_ERROR;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZEXFORMOBJ +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0,
                                                &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvEscape;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        Input.iEsc = iEsc;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer.
        //

        if (iEsc == DRAWPATTERNRECT)
        {
           PDEVOBJ pdo(pso->hdev);

           if (pdo.flGraphicsCaps() & GCAPS_NUP)
           {
               XFORMOBJ *pxo = ((DRAWPATRECTP *)Input.pvIn)->pXformObj;

               if (!pumpdobj->pxo(&pxo))
               {
                   bContinue = FALSE;
               }
               else
               {
                   ((DRAWPATRECTP *)Input.pvIn)->pXformObj = pxo;
               }
           }
        }

        if (bContinue)
        {
           if (cjIn && pumpdobj->bNeedThunk(pvIn) && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
               cjOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut)) ||
               !pumpdobj->psoDest(&Input.pso, bLargeBitmap) ||
               pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
           {
               ulRet = GDI_ERROR;
           }
           else
           {
               if (cjOut)
                   RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
           }
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}

//
//
// BOOL UMPDDrvDrawEscape
//      UMPD DrvDrawEscape thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvDrawEscape
//
// History:
//      10/3/98 -- Lingyun Wang [lingyunw] -- Wrote it.
//


ULONG UMPDDrvDrawEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    CLIPOBJ  *pco,
    RECTL    *prcl,
    ULONG    cjIn,
    PVOID    pvIn
    )
{
    DRVDRAWESCAPEINPUT  Input;
    ULONG           ulRet = GDI_ERROR;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    BOOL            bContinue = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return GDI_ERROR;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZERECTL +
                             UMPD_SIZECLIPOBJ + ALIGN_UMPD_BUFFER(cjIn);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr,
                                                &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDrawEscape;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (cjIn == 0)
            pvIn = NULL;

        Input.iEsc = iEsc;
        Input.pco = pco;
        Input.prcl = prcl;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer.
        //

        if (cjIn && pumpdobj->bNeedThunk(pvIn) && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) || !pumpdobj->pco(&Input.pco) ||
            !pumpdobj->ThunkRECTL(&Input.prcl) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
        {
            ulRet = GDI_ERROR;
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}


//
//
// BOOL UMPDDrvStartBanding
//      UMPD DrvStartBanding thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStartBanding
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    DRVBANDINGINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPOINTL;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStartBanding;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pptl = pptl;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            pumpdobj->ThunkPOINTL(&Input.pptl) &&
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
        {
            if (pptl != NULL)
                RtlCopyMemory(pptl, pumpdobj->GetKernelPtr(Input.pptl), sizeof(POINTL));
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvNextBand
//      UMPD DrvNextBand thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvNextBand
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    DRVBANDINGINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPOINTL;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvNextBand;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pptl = pptl;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap)         &&
            pumpdobj->ThunkPOINTL(&Input.pptl)                  &&
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
        {
            if (pptl != NULL)
                RtlCopyMemory(pptl, pumpdobj->GetKernelPtr(Input.pptl), sizeof(POINTL));
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


ULONG UMPDDrvQueryPerBandInfo(
    SURFOBJ *pso,
    PERBANDINFO *pbi
    )
{
    DRVPERBANDINPUT Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPERBANDI;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryPerBandInfo;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;

        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            (Input.pbi = (PERBANDINFO *) pumpdobj->AllocUserMem(sizeof(PERBANDINFO))) != NULL)
        {
            if (pbi != NULL)
                RtlCopyMemory(pumpdobj->GetKernelPtr(Input.pbi), pbi, sizeof(PERBANDINFO));
            if(pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff)
            {
                if (pbi != NULL)
                    RtlCopyMemory(pbi, pumpdobj->GetKernelPtr(Input.pbi), sizeof(PERBANDINFO));
            }
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

BOOL UMPDDrvQueryDeviceSupport(
    SURFOBJ *pso,
    XLATEOBJ *pxlo,
    XFORMOBJ *pxo,
    ULONG iType,
    ULONG cjIn,
    PVOID pvIn,
    ULONG cjOut,
    PVOID pvOut)
{
    DRVQUERYDEVICEINPUT  Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBits, pvScan0;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEXFORMOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut));

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryDeviceSupport;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pxlo = pxlo;
        Input.pxo = pxo;

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        Input.iType = iType;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        //
        // If the input buffer is not empty and the address is in system
        // address space, then we need to make a copy of the input
        // buffer into temporary user mode buffer for x86.
        //
        // For WOW64, we have to always copy the input buffer.
        //

        if (cjIn && !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn) ||
            cjOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut)) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) || !pumpdobj->pxlo(&Input.pxlo) || !pumpdobj->pxo(&Input.pxo) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(bRet)) == 0xffffffff)
        {
            bRet = FALSE;
        }
        else
        {
            if (cjOut)
                RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvPlgBlt
//      UMPD DrvPlgBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvPlgBlt
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode
    )
{
    DRVPLGBLTINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveTrg = FALSE, bSaveSrc = FALSE ,bSaveMsk = FALSE;
    BOOL           bLargeTrg = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitTrg, pvBitSrc, pvBitMsk;
    PVOID          pvScanTrg, pvScanSrc, pvScanMsk;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZEPOINTL + ALIGN_UMPD_BUFFER(sizeof(POINTFIX)*3) + UMPD_SIZERECTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoTrg, psoSrc, psoMsk,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvPlgBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoTrg;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMsk;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.pptfx = pptfx;
        Input.prcl = prcl;
        Input.pptl = pptl;
        Input.iMode = iMode;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeTrg) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->ThunkMemBlock((PVOID*) &Input.pptfx, sizeof(POINTFIX)*3) &&
               pumpdobj->ThunkRECTL(&Input.prcl) &&
               pumpdobj->ThunkPOINTL(&Input.pptl) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTrg, psoSrc, psoMsk,
                                 pvBitTrg, pvScanTrg, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}


HBITMAP UMPDDrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
    )
{
    return 0;
}

//
// need to pass in a dhpdev here from the calling routine
//
VOID UMPDDrvDeleteDeviceBitmap(
    DHPDEV dhpdev,
    DHSURF dhsurf
    )
{
    XUMPDOBJ       XUMObjs;

    if(XUMObjs.bValid())
    {
        DRVDELETEDEVBITMAP Input;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDeleteDeviceBitmap;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.dhsurf = dhsurf;

        XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), NULL, 0);
    }
}


//
//
// BOOL UMPDDrvDitherColor
//      UMPD DrvDitherColo thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      ULONG
//
// Arguments:
//      refer to DrvDitherColor
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

INT
GetBitDepthFromBMF(
    INT bmf
    )

#define MIN_BMF_INDEX   BMF_1BPP
#define MAX_BMF_INDEX   BMF_8RLE
#define BMF_COUNT       (MAX_BMF_INDEX - MIN_BMF_INDEX + 1)

{
    static const INT bitdepths[BMF_COUNT] =
    {
        1,  // BMF_1BPP
        4,  // BMF_4BPP
        8,  // BMF_8BPP
        16, // BMF_16BPP
        24, // BMF_24BPP
        32, // BMF_32BPP
        4,  // BMF_4RLE
        8   // BMF_8RLE
    };

    if (bmf < MIN_BMF_INDEX || bmf > MAX_BMF_INDEX)
        return 0;
    else
        return bitdepths[bmf - MIN_BMF_INDEX];
}

ULONG UMPDDrvDitherColor(
    DHPDEV dhpdevIn,      // the first parameter is actually a ppdev
    ULONG  iMode,
    ULONG  rgb,
    ULONG  *pul
    )
{
    DRVDITHERCOLORINPUT Input;
    ULONG               ulRet;
    XUMPDOBJ            XUMObjs;
    PDEV                *ppdev;
    DHPDEV              dhpdev;
    INT                 cj;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        ppdev = (PDEV *)dhpdevIn;
        dhpdev = ppdev->dhpdev;

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvDitherColor;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iMode = iMode;
        Input.rgb = rgb;

        if ((cj = GetBitDepthFromBMF(ppdev->devinfo.iDitherFormat)) <= 0)
            return DCR_SOLID;

        cj = ((ppdev->devinfo.cxDither * cj + 7) / 8) * ppdev->devinfo.cyDither;

        if ((Input.pul = (ULONG *) pumpdobj->AllocUserMem(cj)) == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ULONG)) == 0xffffffff)
        {
            return DCR_SOLID;
        }

        if (Input.pul != NULL)
            RtlCopyMemory(pul, pumpdobj->GetKernelPtr(Input.pul), cj);

        return ulRet;
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvRealizeBrush
//      UMPD DrvRealizeBrush thunk.  This routine pack up the input parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      ULONG
//
// Arguments:
//      refer to DrvRealizeBrush
//
// History:
//      8/13/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    )
{
    DRVREALIZEBRUSHINPUT Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSaveTrg = FALSE, bSavePat = FALSE, bSaveMsk = FALSE;
    BOOL                 bLargeTrg = FALSE, bLargePat = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBitTrg, pvBitPat, pvBitMsk;
    PVOID                pvScanTrg, pvScanPat, pvScanMsk;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEBRUSHOBJ + UMPD_SIZEXLATEOBJ(pxlo));

        bRet = pumpdobj->bThunkLargeBitmaps(psoTarget, psoPattern, psoMask,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitPat, &pvScanPat,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSavePat, &bLargePat,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvRealizeBrush;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pbo = pbo;
        Input.psoTrg = psoTarget;
        Input.psoPat = psoPattern;
        Input.psoMsk = psoMask;
        Input.pxlo = pxlo;
        Input.iHatch = iHatch;

        bRet = pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->psoDest(&Input.psoTrg, bLargeTrg)  &&
               pumpdobj->psoSrc(&Input.psoPat, bLargePat)   &&
               pumpdobj->psoMask(&Input.psoMsk, bLargeMsk)  &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTarget, psoPattern, psoMask,
                                 pvBitTrg, pvScanTrg, pvBitPat, pvScanPat, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSavePat, bLargePat, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

// private
VOID UMPDMyDrvFree(
   PUMPDOBJ pumpdobj,
   DHPDEV  dhpdev,
   PVOID   pv,
   ULONG   id)
{
    DRVFREEINPUT Input;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvFree;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.dhpdev = dhpdev;
    Input.pv = pv;
    Input.id = id;

    pumpdobj->Thunk(&Input, sizeof(Input), NULL, NULL);
}


PIFIMETRICS UMPDDrvQueryFont(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     *pid
    )
{
    QUERYFONTINPUT  Input;
    PIFIMETRICS     pifi, pifiKM = NULL;
    XUMPDOBJ        XUMObjs;
    ULONG           cj = 0;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFont;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iFile = iFile;
        Input.iFace = iFace;
        Input.pid = (ULONG *) pumpdobj->AllocUserMemZ(sizeof(ULONG));
        Input.cjMaxData = 0;
        Input.pv = NULL;

        if (Input.pid == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &pifi, sizeof(pifi)) == 0xffffffff)
        {
            return NULL;
        }

        *pid = *((ULONG *) pumpdobj->GetKernelPtr(Input.pid));

        if (pifi)
        {
           if (iFace)
           {
              if (Input.pv)
              {
                  if (Input.cjMaxData)
                  {
                      PIFIMETRICS  kmpifi = (PIFIMETRICS) pumpdobj->GetKernelPtr(Input.pv);

                      cj = kmpifi->cjThis;

                      ASSERTGDI(Input.cjMaxData >= cj, "UMPDDrvQueryFont: not enough buffer\n");

                      if (pifiKM = (PIFIMETRICS)PALLOCMEM(cj, UMPD_MEMORY_TAG))
                        RtlCopyMemory(pifiKM, kmpifi, cj);
                  }
                  else
                  {
                      WARNING("UMPDDrvQueryFont: not enough buffer\n");
                  }
              }
              else
              {
                  __try
                 {
                     ProbeForRead(pifi, sizeof(DWORD), sizeof(BYTE));
                     cj = pifi->cjThis;

                     //
                     // pifiKM is returned to the font code, it will call
                     // on DrvFree to free it later
                     //
                     if (pifiKM = (PIFIMETRICS)PALLOCMEM(cj, UMPD_MEMORY_TAG))
                     {
                        ProbeForRead(pifi, cj, sizeof(BYTE));
                        RtlCopyMemory(pifiKM, pifi, cj);
                     }
                 }
                 __except(EXCEPTION_EXECUTE_HANDLER)
                 {
                     WARNING ("fail to read pifi\n");
                     return NULL;
                 }
              }

              //
              // call DrvFree to free the user mode copy
              //

              if (bIsFreeHooked(dhpdev, pumpdobj))
                  UMPDMyDrvFree(pumpdobj, dhpdev, pifi, *pid);
           }
           else
           {
              //
              // if iFace == 0, it comes from PDEVOBJ__cFonts when cFonts==-1
              // to query number of fonts supported.
              //
              // In this case, pifi will contain the number of fonts supported
              //

              return pifi;
           }
        }


        //
        // we use the lower part of pifiKM pointer as the id,
        // to make sure no one is going to over-write any fields we returned
        //
        *pid = (ULONG)(ULONG_PTR)pifiKM;

        return pifiKM;
    }
    else
    {
        return NULL;
    }
}

BOOL GreFixAndCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize,
    PUMPDOBJ    pumpdobj
    )
{
    ULONG   index, offset;

    RtlCopyMemory(dst, src, cjSize);

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            offset = (ULONG) ((PBYTE)(pumpdobj->GetKernelPtr(src->awcrun[index].phg)) - (PBYTE)src);

            if (offset >= cjSize)
            {
                WARNING("GreFixAndCopyFD_GLYPHSET failed.\n");
                return FALSE;
            }

            dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
        }
    }
    return TRUE;
}

PVOID UMPDDrvQueryFontTree(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     iMode,
    ULONG     *pid
    )
{
    QUERYFONTINPUT  Input;
    PVOID           pv = NULL, kmpv = NULL;
    PVOID           pvKM = NULL;
    XUMPDOBJ        XUMObjs;
    ULONG           cjSize;
    BOOL            bProxyBuffer = FALSE;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFontTree;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.iFile = iFile;
        Input.iFace = iFace;
        Input.iMode = iMode;
        Input.pid = (ULONG *) pumpdobj->AllocUserMemZ(sizeof(ULONG));
        Input.cjMaxData = 0;
        Input.pv = NULL;

        if (Input.pid == NULL ||
            pumpdobj->Thunk(&Input, sizeof(Input), &pv, sizeof(pv)) == 0xffffffff ||
            pv == NULL)
        {
            return NULL;
        }

        *pid = *((ULONG *) pumpdobj->GetKernelPtr(Input.pid));

        cjSize = 0;
        bProxyBuffer = pumpdobj->bWOW64() && Input.pv && Input.cjMaxData;
        kmpv = pumpdobj->GetKernelPtr(Input.pv);

        if (iMode == QFT_GLYPHSET)
        {
            // using proxy

            if (bProxyBuffer)
            {
                cjSize = ((PFD_GLYPHSET)kmpv)->cjThis;
            }
            else if (!pumpdobj->bWOW64())
            {
                __try
                {
                    cjSize = offsetof(FD_GLYPHSET, awcrun) + ((PFD_GLYPHSET)pv)->cRuns * sizeof(WCRUN) + ((PFD_GLYPHSET)pv)->cGlyphsSupported * sizeof(HGLYPH);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING ("fail to read pv\n");
                    return NULL;
                }
            }
        }
        else if (iMode == QFT_KERNPAIRS)
        {
            // Find the end of the kerning pair array (indicated by a zeroed out
            // FD_KERNINGPAIR structure).

            FD_KERNINGPAIR *pkpEnd;

            if (bProxyBuffer)
            {
                pkpEnd = (FD_KERNINGPAIR*)kmpv;
                while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                {
                    pkpEnd += 1;
                    cjSize++;
                }
            }
            else if (!pumpdobj->bWOW64())
            {
                pkpEnd = (FD_KERNINGPAIR *)pv;
                __try
                {
                    while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                    {
                        pkpEnd += 1;
                        cjSize++;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                   WARNING ("fail to read kerning pair\n");
                   return NULL;
                }
            }
            cjSize = (cjSize + 1) * sizeof(FD_KERNINGPAIR);
        }

        if (cjSize && (pvKM = PALLOCMEM(cjSize, UMPD_MEMORY_TAG)))
        {
            if (iMode == QFT_GLYPHSET)
            {
                if (bProxyBuffer)
                {
                    if (!GreFixAndCopyFD_GLYPHSET((FD_GLYPHSET*)pvKM, (FD_GLYPHSET*)kmpv, cjSize, pumpdobj))
                    {
                        VFREEMEM(pvKM);
                        pvKM = NULL;
                    }
                }
                else if (!pumpdobj->bWOW64())
                {
                    __try
                    {
                        if (!GreCopyFD_GLYPHSET((FD_GLYPHSET*)pvKM, (FD_GLYPHSET*)pv, cjSize, FALSE))
                        {
                            VFREEMEM(pvKM);
                            pvKM = NULL;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                       WARNING ("fail to copy pv\n");
                       if (pvKM)
                           VFREEMEM(pvKM);
                       return NULL;
                    }
                }
            }
            else if (iMode == QFT_KERNPAIRS)
            {
                if (bProxyBuffer)
                {
                    RtlCopyMemory(pvKM, kmpv, cjSize);
                }
                else if (!pumpdobj->bWOW64())
                {
                    __try
                    {
                        ProbeForRead(pv, cjSize, sizeof(BYTE));
                        RtlCopyMemory(pvKM, pv, cjSize);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                       WARNING ("fail to copy pv\n");
                       if (pvKM)
                           VFREEMEM(pvKM);
                       return NULL;
                    }
                }
            }
        }

        //
        // free the user mode copy
        //

        if (bIsFreeHooked(dhpdev, pumpdobj))
            UMPDMyDrvFree(pumpdobj, dhpdev, pv, *pid);

        //
        // we use the lower part of pifiKM pointer as the id,
        // to make sure no one is going to over-write any fields we returned
        //
        *pid = (ULONG)(ULONG_PTR)pvKM;
    }
    return pvKM;
}

LONG UMPDDrvQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    QUERYFONTDATAINPUT  Input;
    LONG                lRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryFontData;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        if (cjSize == 0)
            pv = NULL;

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.hg = hg;
        Input.pgd = pgd;
        Input.pv = pv;
        Input.cjSize = cjSize;

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pgd, sizeof(GLYPHDATA)) ||
            !pumpdobj->ThunkMemBlock((PVOID *) &Input.pv, cjSize) ||
            !pumpdobj->pfo(&Input.pfo))
        {
            return FD_ERROR;
        }
        else
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &lRet, sizeof(lRet)) == 0xffffffff)
                lRet = FD_ERROR;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);
        }

        if ((lRet != FD_ERROR) && (pv != NULL))
            RtlCopyMemory(pv, pumpdobj->GetKernelPtr(Input.pv), cjSize);

        if ((lRet != FD_ERROR) && pgd)
            RtlCopyMemory(pgd, pumpdobj->GetKernelPtr(Input.pgd), sizeof(GLYPHDATA));

        return lRet;
    }
    else
    {
        return FD_ERROR;
    }
}

//
// DrvGetGlyphMode is only called from RFONTOBJ::bRealizeFont before the rfont semaphore is
// intialized, no need to release the rfont sem here
//
ULONG UMPDDrvGetGlyphMode(
    DHPDEV dhpdev,
    FONTOBJ *pfo
    )
{
    GETGLYPHMODEINPUT   Input;
    ULONG               ulRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvGetGlyphMode;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;

        if (!pumpdobj->pfo(&Input.pfo) ||
            pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ULONG)) == 0xffffffff)
        {
            ulRet = FO_GLYPHBITS;
        }

        return (ulRet);
    }
    else
    {
        return(FO_GLYPHBITS);
    }
}

ULONG UMPDDrvFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    )
{
    FONTMANAGEMENTINPUT Input;
    ULONG               ulRet = 0xffffffff;
    XUMPDOBJ            XUMObjs;
    PVOID               pvBits, pvScan0;
    BOOL                bContinue = TRUE;
    BOOL                bSavePtr = FALSE, bLargeBitmap = FALSE;
    PUMPDOBJ            pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return 0xffffffff;

    if (pumpdobj->bWOW64() && iMode != QUERYESCSUPPORT && pso && pso->pvBits)
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, ulRet) + UMPD_SIZEFONTOBJ +
                             ALIGN_UMPD_BUFFER(cjIn) + ALIGN_UMPD_BUFFER(cjOut);

        bContinue = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr,
                                                &bLargeBitmap, &cjSizeNeed);
    }

    if (bContinue)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvFontManagement;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        if (cjIn == 0)
            pvIn = NULL;

        if (cjOut == 0)
            pvOut = NULL;

        if (iMode == QUERYESCSUPPORT)
        {
            Input.pso = NULL;
            Input.dhpdev = (DHPDEV) pso;
        }
        else
            Input.pso = pso;

        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.cjIn = cjIn;
        Input.pvIn = pvIn;
        Input.cjOut = cjOut;
        Input.pvOut = pvOut;

        if ((pvOut && !(Input.pvOut = pumpdobj->AllocUserMemZ(cjOut))) ||
            !pumpdobj->psoDest(&Input.pso, bLargeBitmap) ||
            !pumpdobj->pfo(&Input.pfo) ||
            !pumpdobj->ThunkMemBlock(&Input.pvIn, cjIn))
        {
            ulRet = 0xffffffff;
        }
        else
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &ulRet, sizeof(ulRet)) == 0xffffffff)
                ulRet = 0xffffffff;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);

            if ((ulRet != 0xffffffff) && pvOut)
                RtlCopyMemory(pvOut, pumpdobj->GetKernelPtr(Input.pvOut), cjOut);
        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return (ulRet);
}


VOID UMPDDrvFree(
   PVOID   pv,
   ULONG   id)
{

    if (pv)
    {
       //
       // id field is used to keep pv value to make
       // sure pv/pid are returned from umpd
       //
       if (IS_SYSTEM_ADDRESS(pv) && (id == (ULONG)(ULONG_PTR)pv))
       {
           VFREEMEM(pv);
       }
       else
       {
          ASSERTGDI (id == (ULONG)(ULONG_PTR)pv, "UMPDDrvFree -- bad address passed in\n");
       }
    }
}


BOOL UMPDDrvQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs
    )
{
    QUERYADVWIDTHSINPUT Input;
    BOOL                bRet;
    XUMPDOBJ            XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        if (phg == NULL || pvWidths == NULL)
        {
            WARNING("invalid parameter in UMPDDrvQueryAdvanceWidths\n");
            return FALSE;
        }

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvQueryAdvanceWidths;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pfo = pfo;
        Input.iMode = iMode;
        Input.phg = phg;
        Input.pvWidths = pvWidths;
        Input.cGlyphs = cGlyphs;

        if (!(Input.pvWidths = pumpdobj->AllocUserMemZ(sizeof(USHORT)*cGlyphs)) ||
            !pumpdobj->pfo(&Input.pfo) ||
            !pumpdobj->ThunkMemBlock((PVOID *) &Input.phg, sizeof(HGLYPH)*cGlyphs))
        {
            return FALSE;
        }
        else
        {
            // DrvQueryAdvancedWidth is called from NtGdiGetWidthTable with rfo lcok.

            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(bRet)) == 0xffffffff)
                bRet = FALSE;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);
        }

        RtlCopyMemory(pvWidths, pumpdobj->GetKernelPtr(Input.pvWidths), sizeof(USHORT)*cGlyphs);

        return (bRet);
    }
    else
    {
        return FALSE;
    }
}


//
//
// BOOL UMPDDrvBitBlt
//      UMPD DrvBitBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvBitBlt
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvBitBlt(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
    )
{
    DRVBITBLTINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveTrg = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL           bLargeTrg = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitTrg, pvBitSrc, pvBitMsk;
    PVOID          pvScanTrg, pvScanSrc, pvScanMsk;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZERECTL + 3 * UMPD_SIZEPOINTL + UMPD_SIZEBRUSHOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoTrg, psoSrc, psoMask,
                                            &pvBitTrg, &pvScanTrg,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveTrg, &bLargeTrg,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvBitBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoTrg;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclTrg = prclTrg;
        Input.pptlSrc = pptlSrc;
        Input.pptlMask = pptlMask;
        Input.pbo = pbo;
        Input.pptlBrush = pptlBrush;
        Input.rop4 = rop4;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeTrg) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkPOINTL(&Input.pptlSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrush) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoTrg, psoSrc, psoMask,
                                 pvBitTrg, pvScanTrg, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveTrg, bLargeTrg, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvStretchBlt
//      UMPD DrvStretchBlt thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStretchBlt
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    DRVSTRETCHBLTINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSaveDst = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL               bLargeDst = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBitDst, pvBitSrc, pvBitMsk;
    PVOID              pvScanDst, pvScanSrc, pvScanMsk;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if (!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZERECTL + 2 * UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, psoMask,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStretchBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlHTOrg = pptlHTOrg;
        Input.prclTrg = prclDest;
        Input.prclSrc = prclSrc;
        Input.pptlMask = pptlMask;
        Input.iMode = iMode;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlHTOrg) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, psoMask,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvStretchBltROP
//      UMPD DrvStretchBltROP thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStretchBltROP
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )
{
    DRVSTRETCHBLTINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSaveDst = FALSE, bSaveSrc = FALSE, bSaveMsk = FALSE;
    BOOL               bLargeDst = FALSE, bLargeSrc = FALSE, bLargeMsk = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBitDst, pvBitSrc, pvBitMsk;
    PVOID              pvScanDst, pvScanSrc, pvScanMsk;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             UMPD_SIZECOLORADJ + 2 * UMPD_SIZEPOINTL + 2 * UMPD_SIZERECTL + UMPD_SIZEBRUSHOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, psoMask,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            &pvBitMsk, &pvScanMsk,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            &bSaveMsk, &bLargeMsk,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStretchBltROP;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.psoMask = psoMask;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.pca = pca;
        Input.pptlHTOrg = pptlHTOrg;
        Input.prclTrg = prclDest;
        Input.prclSrc = prclSrc;
        Input.pptlMask = pptlMask;
        Input.iMode = iMode;
        Input.pbo = pbo;
        Input.rop4 = rop4;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst)  &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc)   &&
               pumpdobj->psoMask(&Input.psoMask, bLargeMsk) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkCOLORADJUSTMENT(&Input.pca) &&
               pumpdobj->ThunkPOINTL(&Input.pptlHTOrg) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkPOINTL(&Input.pptlMask) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, psoMask,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, pvBitMsk, pvScanMsk,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, bSaveMsk, bLargeMsk);
    }

    return bRet;
}

BOOL UMPDDrvAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    ALPHAINPUT     Input;
    BOOL           bRet = TRUE;
    BOOL           bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL           bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBitDst, pvBitSrc;
    PVOID          pvScanDst, pvScanSrc;
    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             2 * UMPD_SIZERECTL + UMPD_SIZEBLENDOBJ);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvAlphaBlend;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclDest = prclDest;
        Input.prclSrc = prclSrc;
        Input.pBlendObj = pBlendObj;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclDest) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->ThunkBLENDOBJ(&Input.pBlendObj) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

BOOL UMPDDrvGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    )
{
    GRADIENTINPUT   Input;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    ULONG           cjMesh;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvGradientFill;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.psoTrg = psoDest;
    Input.pco = pco;
    Input.pxlo = pxlo;
    Input.pVertex = pVertex;
    Input.nVertex = nVertex;
    Input.pMesh = pMesh;
    Input.nMesh = nMesh;
    Input.prclExtents = prclExtents;
    Input.pptlDitherOrg = pptlDitherOrg;
    Input.ulMode = ulMode;

    //
    // Figure out the size of pMesh input buffer
    //

    switch (ulMode)
    {
    case GRADIENT_FILL_RECT_H:
    case GRADIENT_FILL_RECT_V:

        cjMesh = sizeof(GRADIENT_RECT);
        break;

    case GRADIENT_FILL_TRIANGLE:

        cjMesh = sizeof(GRADIENT_TRIANGLE);
        break;

    default:

        RIP("Invalid ulMode in DrvGradientFill\n");
        return FALSE;
    }

    cjMesh *= nMesh;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEXLATEOBJ(pxlo) +
                             ALIGN_UMPD_BUFFER(sizeof(TRIVERTEX)*nVertex) + ALIGN_UMPD_BUFFER(cjMesh) +
                             UMPD_SIZERECTL + UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmap(psoDest, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkMemBlock((PVOID *)&Input.pVertex, sizeof(TRIVERTEX)*nVertex) &&
               pumpdobj->ThunkMemBlock(&Input.pMesh, cjMesh) &&
               pumpdobj->ThunkRECTL(&Input.prclExtents) &&
               pumpdobj->ThunkPOINTL(&Input.pptlDitherOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(psoDest, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

BOOL UMPDDrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor,
    UINT       ulReserved
)
{
    TRANSPARENTINPUT     Input;
    BOOL                 bRet = TRUE;
    BOOL                 bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL                 bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ             XUMObjs;
    PVOID                pvBitDst, pvBitSrc, pvScanDst, pvScanSrc;
    PUMPDOBJ             pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXLATEOBJ(pxlo) + 2 * UMPD_SIZERECTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDst, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvTransparentBlt;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDst;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclDst = prclDst;
        Input.prclSrc = prclSrc;
        Input.TransColor = TransColor;
        Input.ulReserved = ulReserved;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclDst) &&
               pumpdobj->ThunkRECTL(&Input.prclSrc) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDst, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvCopyBits
//      UMPD DrvCopyBits thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvCopyBits
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvCopyBits(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc
    )
{
    DRVCOPYBITSINPUT Input;
    BOOL             bRet = TRUE;
    BOOL             bSaveDst = FALSE, bSaveSrc = FALSE;
    BOOL             bLargeDst = FALSE, bLargeSrc = FALSE;
    XUMPDOBJ         XUMObjs;
    PVOID            pvBitDst, pvBitSrc, pvScanDst, pvScanSrc;
    PUMPDOBJ         pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG cjSizeNeed = (ULONG)(UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXLATEOBJ(pxlo) + UMPD_SIZERECTL + UMPD_SIZEPOINTL);

        bRet = pumpdobj->bThunkLargeBitmaps(psoDest, psoSrc, NULL,
                                            &pvBitDst, &pvScanDst,
                                            &pvBitSrc, &pvScanSrc,
                                            NULL, NULL,
                                            &bSaveDst, &bLargeDst,
                                            &bSaveSrc, &bLargeSrc,
                                            NULL, NULL,
                                            &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvCopyBits;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.psoTrg = psoDest;
        Input.psoSrc = psoSrc;
        Input.pco = pco;
        Input.pxlo = pxlo;
        Input.prclTrg = prclDest;
        Input.pptlSrc = pptlSrc;

        bRet = pumpdobj->psoDest(&Input.psoTrg, bLargeDst) &&
               pumpdobj->psoSrc(&Input.psoSrc, bLargeSrc)  &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxlo(&Input.pxlo) &&
               pumpdobj->ThunkRECTL(&Input.prclTrg) &&
               pumpdobj->ThunkPOINTL(&Input.pptlSrc) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (pumpdobj->bWOW64())
    {
        pumpdobj->RestoreBitmaps(psoDest, psoSrc, NULL,
                                 pvBitDst, pvScanDst, pvBitSrc, pvScanSrc, NULL, NULL,
                                 bSaveDst, bLargeDst, bSaveSrc, bLargeSrc, FALSE, FALSE);
    }

    return bRet;
}

//
//
// BOOL UMPDDrvTextOut
//      UMPD DrvTextOut thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvTextOut
//
// History:
//      8/14/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

BOOL UMPDDrvTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )
{
    TEXTOUTINPUT    Input;
    ULONG           cjprclExtra;
    BOOL            bRet = TRUE;
    BOOL            bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ        XUMObjs;
    PVOID           pvBits, pvScan0;
    PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    //
    // find out the number of rclextra rectangles
    //

    if (prclExtra != (PRECTL) NULL)
    {
        RECTL *prcl;

        cjprclExtra = 1;
        prcl = prclExtra;

        while (prcl->left != prcl->right)
            cjprclExtra++, prcl++;

        cjprclExtra *= sizeof(RECTL);
    }
    else
        cjprclExtra = 0;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEFONTOBJ +
                             UMPD_SIZESTROBJ(pstro) + ALIGN_UMPD_BUFFER(cjprclExtra) +
                             UMPD_SIZERECTL + UMPD_SIZEPOINTL + 2 * UMPD_SIZEBRUSHOBJ;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvTextOut;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.pso = pso;
    Input.pstro = pstro;
    Input.pfo = pfo;
    Input.pco = pco;
    Input.prclExtra = prclExtra;
    Input.prclOpaque = prclOpaque;
    Input.pboFore = pboFore;
    Input.pboOpaque = pboOpaque;
    Input.pptlOrg = pptlOrg;
    Input.mix = mix;

    if (bRet)
    {
        if (pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
            pumpdobj->pstro(&Input.pstro) &&
            pumpdobj->pfo(&Input.pfo) &&
            pumpdobj->pco(&Input.pco) &&
            pumpdobj->ThunkMemBlock((PVOID *) &Input.prclExtra, cjprclExtra) &&
            pumpdobj->ThunkRECTL(&Input.prclOpaque) &&
            pumpdobj->pbo(&Input.pboFore) &&
            pumpdobj->pboFill(&Input.pboOpaque) &&
            pumpdobj->ThunkPOINTL(&Input.pptlOrg))
        {
            RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));

            UMPDReleaseRFONTSem(rfto, pumpdobj, NULL, NULL, NULL);

            if (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) == 0xffffffff)
                bRet = FALSE;

            UMPDAcquireRFONTSem(rfto, pumpdobj, 0, 0, NULL);

        }
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


//
//
// BOOL UMPDDrvLineTo
//      UMPD DrvLineTo thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvLineTo
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//



BOOL UMPDDrvLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )
{
    DRVLINETOINPUT Input;
    BOOL           bRet = TRUE;
    BOOL           bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ       XUMObjs;
    PVOID          pvBits, pvScan0;

    PUMPDOBJ       pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZERECTL + UMPD_SIZECLIPOBJ + UMPD_SIZEBRUSHOBJ;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvLineTo;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.x1 = x1;
        Input.y1 = y1;
        Input.x2 = x2;
        Input.y2 = y2;
        Input.prclBounds = prclBounds;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkRECTL(&Input.prclBounds) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvStrokePath
//      UMPD DrvStrokePath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStrokePath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEPATHOBJ +
                             UMPD_SIZEXFORMOBJ + UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL + UMPD_SIZELINEATTRS(plineattrs);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStrokePath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pxo = pxo;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.plineattrs = plineattrs;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxo(&Input.pxo) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->ThunkLINEATTRS(&Input.plineattrs) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
//
// BOOL UMPDDrvFillPath
//      UMPD DrvFillPath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvFillPath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPATHOBJ + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvFillPath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;
        Input.flOptions = flOptions;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}

//
// BOOL UMPDStrokeAndFillPath
//      UMPD DrvStrokeAndFillPath thunk.  This routine packs up the parameters
//      and send across to the client side, and copy the output parameters back
//      after returning from client side.
//
// Returns
//      BOOL
//
// Arguments:
//      refer to DrvStrokeAndFillPath
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//


BOOL UMPDDrvStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mix,
    FLONG      flOptions
    )
{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZEPATHOBJ + UMPD_SIZECLIPOBJ +
                             UMPD_SIZEXFORMOBJ + UMPD_SIZELINEATTRS(plineattrs) + 2 * UMPD_SIZEBRUSHOBJ + UMPD_SIZEPOINTL;
        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvStrokeAndFillPath;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.ppo = ppo;
        Input.pco = pco;
        Input.pxo = pxo;
        Input.pbo = pboStroke;
        Input.plineattrs = plineattrs;
        Input.pboFill = pboFill;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;
        Input.flOptions = flOptions;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->ppo(&Input.ppo) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pxo(&Input.pxo) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkLINEATTRS(&Input.plineattrs) &&
               pumpdobj->pboFill(&Input.pboFill) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL APIENTRY
UMPDDrvPaint(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )

{
    STORKEANDFILLINPUT Input;
    BOOL               bRet = TRUE;
    BOOL               bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ           XUMObjs;
    PVOID              pvBits, pvScan0;
    PUMPDOBJ           pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
       return FALSE;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + UMPD_SIZECLIPOBJ + UMPD_SIZEPOINTL + UMPD_SIZEBRUSHOBJ;

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvPaint;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.pso = pso;
        Input.pco = pco;
        Input.pbo = pbo;
        Input.pptlBrushOrg = pptlBrushOrg;
        Input.mix = mix;

        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               pumpdobj->pco(&Input.pco) &&
               pumpdobj->pbo(&Input.pbo) &&
               pumpdobj->ThunkPOINTL(&Input.pptlBrushOrg) &&
               pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL UMPDDrvQuerySpoolType(
    DHPDEV  dhpdev,
    LPWSTR  pwszDataType
    )
{
    WARNING("UMPDDrvQuerySpoolType not needed\n");
    return 0;
}


HANDLE UMPDDrvIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    )
{
    DRVICMCREATECOLORINPUT    Input;
    HANDLE                    hRet;
    XUMPDOBJ                  XUMObjs;

    if(XUMObjs.bValid())
    {
        PUMPDOBJ        pumpdobj = XUMObjs.pumpdobj();

        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmCreateColorTransform;
        Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

        Input.dhpdev = dhpdev;
        Input.pLogColorSpace = pLogColorSpace;
        Input.pvSourceProfile = pvSourceProfile;
        Input.cjSourceProfile = cjSourceProfile;
        Input.pvDestProfile = pvDestProfile;
        Input.cjDestProfile = cjDestProfile;
        Input.pvTargetProfile = pvTargetProfile;
        Input.cjTargetProfile = cjTargetProfile;
        Input.dwReserved = dwReserved;

        if (!pumpdobj->ThunkMemBlock((PVOID *) &Input.pLogColorSpace, sizeof(LOGCOLORSPACE)) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvSourceProfile, cjSourceProfile) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvDestProfile, cjDestProfile) ||
            !pumpdobj->ThunkMemBlock((PVOID *)&Input.pvTargetProfile, cjTargetProfile))
        {
            hRet = 0;
        }
        else
        {
            if (pumpdobj->Thunk(&Input, sizeof(Input), &hRet, sizeof(HANDLE)) == 0xffffffff)
                hRet = 0;
        }

        return (hRet);

    }
    else
    {
        return FALSE;
    }
}

BOOL UMPDDrvIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    )
{
    XUMPDOBJ               XUMObjs;
    DRVICMDELETECOLOR      Input;
    BOOL                   bRet;

    if(XUMObjs.bValid())
    {
        Input.umpdthdr.umthdr.cjSize = sizeof(Input);
        Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmDeleteColorTransform;
        Input.umpdthdr.humpd = XUMObjs.hUMPD();

        Input.dhpdev = dhpdev;
        Input.hcmXform = hcmXform;

        return XUMObjs.pumpdobj()->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff &&
               bRet;
    }
    else
    {
        return FALSE;
    }
}

BOOL UMPDDrvIcmCheckBitmapBits(
    DHPDEV   dhpdev,
    HANDLE   hColorTransform,
    SURFOBJ *pso,
    PBYTE    paResults
    )
{
    DRVICMCHECKBITMAPINPUT Input;
    BOOL                   bRet = TRUE;
    BOOL                   bSavePtr = FALSE, bLargeBitmap = FALSE;
    XUMPDOBJ               XUMObjs;
    ULONG                  cjSize;
    PVOID                  pvBits, pvScan0;
    PUMPDOBJ               pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_DrvIcmCheckBitmapBits;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.dhpdev = dhpdev;
    Input.hColorTransform = hColorTransform;
    Input.pso = pso;
    Input.paResults = paResults;

    //
    // Hideyuki says that paResults size is based on the number of pixels in pso,
    // one byte for each pixel
    //
    cjSize = pso->sizlBitmap.cx * pso->sizlBitmap.cy;

    if (pumpdobj->bWOW64())
    {
        ULONG   cjSizeNeed = UMPD_SIZEINOUTPUT(Input, bRet) + ALIGN_UMPD_BUFFER(sizeof(BYTE) * cjSize);

        bRet = pumpdobj->bThunkLargeBitmap(pso, &pvBits, &pvScan0, &bSavePtr, &bLargeBitmap, &cjSizeNeed);
    }

    if (bRet)
    {
        bRet = pumpdobj->psoDest(&Input.pso, bLargeBitmap) &&
               (Input.paResults = (PBYTE)pumpdobj->AllocUserMemZ(sizeof(BYTE) * cjSize)) &&
               (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) &&
               bRet;
    }

    if (bSavePtr)
        pumpdobj->RestoreBitmap(pso, pvBits, pvScan0, bSavePtr, bLargeBitmap);

    return bRet;
}


BOOL UMPDEngFreeUserMem(KERNEL_PVOID pv)
{
    UMPDFREEMEMINPUT    Input;
    BOOL                bRet;
    XUMPDOBJ            XUMObjs;
    PUMPDOBJ            pumpdobj = XUMObjs.pumpdobj();

    if(!XUMObjs.bValid() || !pumpdobj->bWOW64())
        return FALSE;

    Input.umpdthdr.umthdr.cjSize = sizeof(Input);
    Input.umpdthdr.umthdr.ulType = INDEX_UMPDEngFreeUserMem;
    Input.umpdthdr.humpd = (HUMPD) pumpdobj->hGet();

    Input.pvTrg = pv;
    Input.pvSrc = NULL;
    Input.pvMsk = NULL;

    bRet = (pumpdobj->Thunk(&Input, sizeof(Input), &bRet, sizeof(BOOL)) != 0xffffffff) && bRet;

    return bRet;
}
//
//
// gpUMDriverFunc
//      Our kernel mode thunk functions table.
//
// History:
//      7/17/97 -- Lingyun Wang [lingyunw] -- Wrote it.
//

PFN gpUMDriverFunc[INDEX_LAST] =
{
   (PFN)UMPDDrvEnablePDEV,
   (PFN)UMPDDrvCompletePDEV,
   (PFN)UMPDDrvDisablePDEV,
   (PFN)UMPDDrvEnableSurface,
   (PFN)UMPDDrvDisableSurface,
   (PFN)NULL,
   (PFN)NULL,
   (PFN)UMPDDrvResetPDEV,
   (PFN)UMPDDrvDisableDriver,
   (PFN)NULL,
   (PFN)UMPDDrvCreateDeviceBitmap,
   (PFN)UMPDDrvDeleteDeviceBitmap,
   (PFN)UMPDDrvRealizeBrush,
   (PFN)UMPDDrvDitherColor,
   (PFN)UMPDDrvStrokePath,
   (PFN)UMPDDrvFillPath,
   (PFN)UMPDDrvStrokeAndFillPath,
   (PFN)UMPDDrvPaint,
   (PFN)UMPDDrvBitBlt,
   (PFN)UMPDDrvCopyBits,
   (PFN)UMPDDrvStretchBlt,
   (PFN)NULL,
   (PFN)NULL, //UMPDDrvSetPalette,
   (PFN)UMPDDrvTextOut,
   (PFN)UMPDDrvEscape,
   (PFN)UMPDDrvDrawEscape,
   (PFN)UMPDDrvQueryFont,
   (PFN)UMPDDrvQueryFontTree,
   (PFN)UMPDDrvQueryFontData,
   (PFN)NULL, //UMPDDrvSetPointerShape,
   (PFN)NULL, //UMPDDrvMovePointer,
   (PFN)UMPDDrvLineTo,
   (PFN)UMPDDrvSendPage,
   (PFN)UMPDDrvStartPage,
   (PFN)UMPDDrvEndDoc,
   (PFN)UMPDDrvStartDoc,
   (PFN)NULL,
   (PFN)UMPDDrvGetGlyphMode,
   (PFN)NULL, //DrvSync
   (PFN)NULL,
   (PFN)NULL, //UMPDDrvSaveScreenBits
   (PFN)NULL,
   (PFN)UMPDDrvFree,
   (PFN)NULL, //UMPDDrvDestroyFont,
   (PFN)NULL, //UMPDDrvQueryFontCaps,
   (PFN)NULL, //UMPDDrvLoadFontFile,
   (PFN)NULL, //UMPDDrvUnloadFontFile,
   (PFN)UMPDDrvFontManagement,
   (PFN)NULL, //UMPDDrvQueryTrueTypeTable,
   (PFN)NULL, //UMPDDrvQueryTrueTypeOutline,
   (PFN)NULL, //UMPDDrvGetTrueTypeFile,
   (PFN)NULL, //UMPDDrvQueryFontFile,
   (PFN)NULL, //UMPDDrvMovePanning
   (PFN)UMPDDrvQueryAdvanceWidths,
   (PFN)NULL, //UMPDDrvSetPixelFormat,
   (PFN)NULL, //UMPDDrvDescribePixelFormat,
   (PFN)NULL, //UMPDDrvSwapBuffers,
   (PFN)UMPDDrvStartBanding,
   (PFN)UMPDDrvNextBand,
   (PFN)NULL, //UMPDDrvGetDirectDrawInfo,
   (PFN)NULL, //UMPDDrvEnableDirectDraw,
   (PFN)NULL, //UMPDDrvDisableDirectDraw,
   (PFN)UMPDDrvQuerySpoolType,
   (PFN)NULL, //UMPDDrvCreateLayerBitmap,
   (PFN)UMPDDrvIcmCreateColorTransform,
   (PFN)UMPDDrvIcmDeleteColorTransform,
   (PFN)UMPDDrvIcmCheckBitmapBits,
   (PFN)NULL, //UMPDDrvIcmSetDeviceGammaRamp,
   (PFN)UMPDDrvGradientFill,
   (PFN)UMPDDrvStretchBltROP,
   (PFN)UMPDDrvPlgBlt,
   (PFN)UMPDDrvAlphaBlend,
   (PFN)NULL, //UMPDDrvSynthesizeFont,
   (PFN)NULL, //UMPDDrvGetSynthesizedFontFiles,
   (PFN)UMPDDrvTransparentBlt,
   (PFN)UMPDDrvQueryPerBandInfo,
   (PFN)UMPDDrvQueryDeviceSupport,
};

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\w32kevnt.c ===
/******************************Module*Header*******************************\
* Module Name: w32kevnt.c
*
*   Event handling functions
* 
* Copyright (c) 1996-1999 Microsoft Corporation
* 
\**************************************************************************/

#include "engine.h"
#include "pw32kevt.h"

BOOL
EngCreateEvent(
    OUT PEVENT *ppEvent
    )

/*+++

Routine Description:

    EngCreateEvent creates a synchronization type event object that can 
    be used to synchronize hardware access between a display driver and 
    video miniport.

---*/

{
    PENG_EVENT *ppEngEvent = (PENG_EVENT *)ppEvent;
    PENG_EVENT  pEngEvent;
    PUCHAR      pAllocTmp;
    ULONG       engevtsize = sizeof(ENG_EVENT);

    //
    //  Align size to next higher multiple of 8.
    //

    engevtsize = (engevtsize + 7) & ~7;

    //
    //  Allocate the whole amount and set pEngEvent to the top.
    //

    pAllocTmp = (PUCHAR)ENG_KEVENTALLOC(engevtsize + sizeof(KEVENT));
    pEngEvent = (PENG_EVENT)pAllocTmp;

    if (pEngEvent) {

        RtlZeroMemory(pEngEvent, sizeof(ENG_EVENT));

        //
        //  Skip past the ENG_EVENT and set pEngEvent->pKEvent to that.
        //

        pAllocTmp += engevtsize;
        pEngEvent->pKEvent = (PKEVENT)pAllocTmp;

        //
        //  Initialize the KEVENT and then put the PENG_EVENT in the
        //  PPENG_EVENT. 
        //

        KeInitializeEvent(pEngEvent->pKEvent, SynchronizationEvent, FALSE);
        *ppEngEvent = pEngEvent;

    } else {
        return FALSE;
    }

    return TRUE;
}

BOOL
EngDeleteEvent(
    IN  PEVENT pEvent
    )

/*+++

Routine Description:

    EngDeleteEvent deletes the specified event object.

---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;

    if ( !(pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER)) {

        ENG_KEVENTFREE(pEngEvent);
        return TRUE;

    } else {

        ASSERTGDI(FALSE, "Don't delete MappedUserEvents");
        return FALSE;
    }
}

PEVENT
EngMapEvent(
    IN HDEV           hDev,
    IN HANDLE         hUserObject,
    IN PVOID          Reserved1,
    IN PVOID          Reserved2,
    IN PVOID          Reserved3
    )

/*+++

Routine Description:

    This routine allocates a ENG_EVENT and initialize its pKEvent pointer
    to the event object returned from Object manager. 
    
    The reserved fields must be set to NULL

---*/

{
    LONG status;
    PENG_EVENT pEngEvent;

    //
    //  Allocate a pEngEvent, but don't allocate the PKEvent that
    //  resides within this is done by ObReferenceObjectByHandle().
    //

    pEngEvent = ENG_KEVENTALLOC(sizeof(ENG_EVENT));

    if (!pEngEvent) {
        return NULL;
    }

    RtlZeroMemory(pEngEvent, sizeof(ENG_EVENT));

    //
    //  Create the reference inside a try-except block in case the HANDLE
    //  is bogus. The ObRef call allocates and puts a PKEVENT object at
    //  the location pointed to by pEngEvent.
    //

    try {
        status = ObReferenceObjectByHandle( hUserObject,
                                            GENERIC_ALL,
                                            NULL,
                                            KernelMode,
                                            (PVOID)&(pEngEvent->pKEvent),
                                            NULL);

        //
        //  If the reference was successful, then pulse the event object.
        //
        //  KePulseEvent atomically sets the signal state of an event object
        //  to Signaled, attempts to satisfy as many Waits as possible, and
        //  then resets the signal state of the event object to Not-Signaled.
        //  The previous signalstate of the event object is returned as the
        //  function value.
        //

        if (NT_SUCCESS(status)) {

            KePulseEvent(pEngEvent->pKEvent, EVENT_INCREMENT, FALSE);
            pEngEvent->fFlags |= ENG_EVENT_FLAG_IS_MAPPED_USER;

        } else {

            ENG_KEVENTFREE(pEngEvent);
            pEngEvent = NULL;
        }

    //
    // If an exception occurs during the probe of the previous state, then
    // always handle the exception, get the exception code and return FALSE.
    //

    } except(ExSystemExceptionFilter()) {

        ENG_KEVENTFREE(pEngEvent);
        pEngEvent = NULL;
    }

    //
    // If the caller is using the old prototype of EngMapEvent, we should
    // return the pointer of kernel event to the place pointed by the third 
    // argument.
    //

    if ( Reserved1 != NULL ) {
        *(PENG_EVENT *)Reserved1  = pEngEvent;
    }

    return (PEVENT) pEngEvent;
}


BOOL
EngUnmapEvent(
    IN PEVENT pEvent
    )

/*+++

    Routine Description:

    EngUnmapEvent cleans up the kernel-mode resources allocated for a 
    mapped user-mode event.

---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;

    if ( pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER ) {

        //
        // Decrements the object's reference count free the all the memory
        //

        ObDereferenceObject(pEngEvent->pKEvent);
        ENG_KEVENTFREE(pEngEvent);
        return TRUE;

    } else {

        return FALSE;
    }
}



BOOL
EngWaitForSingleObject(
    IN  PEVENT          pEvent,
    IN  PLARGE_INTEGER  pTimeOut
    )

/*+++

Routine Description:

    Called by Display driver. Can only be called on events created by
    the Display or miniport driver, not on mapped events. 

Return Value: 

    TRUE if successful, FALSE otherwise. A return value of FALSE indicates 
    that either one of the parameters is invalid or a time-out occurred.
  
---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;
    PKEVENT pKEvent;
    NTSTATUS Status;

    pKEvent = pEngEvent->pKEvent;

    //
    //  Don't even wait if it's mapped user. In fact, don't wait if it's
    //  invalid.
    //

    if (pKEvent && (!(pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER))) {

        Status = KeWaitForSingleObject( pKEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        pTimeOut );
    } else {

        ASSERTGDI(FALSE, "No waiting on mapped user events.");
        return FALSE;
    }

    if (NT_SUCCESS(Status))
        return TRUE;
    else 
        return FALSE;

}

LONG
EngSetEvent(
    IN PEVENT pEvent
    )

/*+++

Routine Description:

    EngSetEvent sets the state of the event object to signaled and returns
    the previous state of the event object

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;

    return ( KeSetEvent(pEngEvent->pKEvent, 0, FALSE) );

}

VOID
EngClearEvent (
IN PEVENT pEvent
)

/*+++

Routine Description:

    EngClearEvent sets the given event to a not signaled state.

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;
    KeClearEvent(pEngEvent->pKEvent);
}

LONG
EngReadStateEvent (
IN PEVENT pEvent
)

/*+++

Routine Description:

    EngReadStateEvent returns the current state, signaled or not signaled, 
    of a given event object.

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;
    return ( KeReadStateEvent(pEngEvent->pKEvent) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\xformddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformddi.cxx
*
* Transform DDI callback routines.
*
* Created: 13-May-1991 19:08:43
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* BOOL XFORMOBJ_bApplyXform(
*  XFORMOBJ    *pxo,
*  ULONG       iMode,
*  ULONG       cPoints,
*  PVOID       pvIn,
* PVOID       pvOut)
*
* Applies the transform or its inverse to the given array of points.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL XFORMOBJ_bApplyXform(
 XFORMOBJ    *pxo,
 ULONG       iMode,
 ULONG       cPoints,
 PVOID       pvIn,
 PVOID       pvOut)
{
    if (pxo == NULL)
        return(FALSE);

    if ((pvIn == NULL) || (pvOut == NULL))
        return(FALSE);

    if (iMode == XF_LTOL)
    {
        if (pvIn == pvOut)
            return(((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn,(UINT)cPoints));

        if (((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn, (PPOINTFIX)pvOut,
                                       (UINT)cPoints))
        {
            PPOINTL pptl = (PPOINTL)pvOut;
            PPOINTL pptlEnd = pptl + cPoints;
            while (pptl < pptlEnd)
            {
                pptl->x = (pptl->x + 8) >> 4;       // FXTOLROUND
                pptl->y = (pptl->y + 8) >> 4;       // FXTOLROUND
                pptl++;
            }
            return(TRUE);
        }
        return(FALSE);
    }

    if (iMode == XF_LTOFX)
        return(((EXFORMOBJ *)pxo)->bXform((PPOINTL)pvIn, (PPOINTFIX)pvOut,
                                          (UINT)cPoints));

    MATRIX  mx;
    EXFORMOBJ xo(&mx, DONT_COMPUTE_FLAGS);

    if (xo.bInverse(*((EXFORMOBJ *)pxo)))
    {
        if (iMode == XF_INV_LTOL)
        {
            if (pvIn == pvOut)
                return(xo.bXform((PPOINTL)pvIn,(UINT)cPoints));

            PPOINTL pptl = (PPOINTL)pvIn;
            PPOINTL pptlEnd = pptl + cPoints;
            while (pptl < pptlEnd)
            {
                pptl->x <<= 4;
                pptl->y <<= 4;
                pptl++;
            }

            BOOL bRet = xo.bXform((PPOINTFIX)pvIn, (PPOINTL)pvOut, (UINT)cPoints);

            pptl = (PPOINTL)pvIn;
            while (pptl < pptlEnd)
            {
                pptl->x >>= 4;
                pptl->y >>= 4;
                pptl++;
            }
            return(bRet);
        }

        if (iMode == XF_INV_FXTOL)
            return(xo.bXform((PPOINTFIX)pvIn, (PPOINTL)pvOut, (UINT)cPoints));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo,XFORM *pxform)
*
*  Get the coefficients of the given transform.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo, XFORML *pxform)
{
    if (pxo == NULL)
        return(DDI_ERROR);

    if  (pxform != NULL)
        ((EXFORMOBJ *)pxo)->vGetCoefficient((XFORML *)pxform);

    switch(((EXFORMOBJ *)pxo)->flAccel() &
           (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION))
    {
        case (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION):
            return(GX_IDENTITY);

        case (XFORM_SCALE|XFORM_UNITY):
            return(GX_OFFSET);

        case (XFORM_SCALE):
            return(GX_SCALE);

        default:
            return(GX_GENERAL);
    }
}

/******************************Public*Routine******************************\
* ULONG XFORMOBJ_iGetXform(XFORMOBJ *pxo,XFORM *pxform)
*
*  Get the coefficients of the given transform.
*
* History:
*  13-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG XFORMOBJ_iGetFloatObjXform(XFORMOBJ *pxo, FLOATOBJ_XFORM *pxform)
{
    if (pxo == NULL)
        return(DDI_ERROR);

    if  (pxform != NULL)
        ((EXFORMOBJ *)pxo)->vGetCoefficient(pxform);

    switch(((EXFORMOBJ *)pxo)->flAccel() &
           (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION))
    {
        case (XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION):
            return(GX_IDENTITY);

        case (XFORM_SCALE|XFORM_UNITY):
            return(GX_OFFSET);

        case (XFORM_SCALE):
            return(GX_SCALE);

        default:
            return(GX_GENERAL);
    }
}




/******************************Public*Routine******************************\
*
* a few wrapper functions for EFLOATS.  See winddi for the list.
*
* Note that currently these are only defined for x86 since we allow floating
* point operations in the kernel for MIPS, ALPHA, and PPC where these are macros.
*
* History:
*  16-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if defined(_X86_) && !defined(BUILD_WOW6432)

VOID  FLOATOBJ_SetFloat(
    PFLOATOBJ pf,
    FLOATL f)
{
    *(EFLOAT*)pf = f;
}

VOID  FLOATOBJ_SetLong(
    PFLOATOBJ pf,
    LONG      l)
{
    *(EFLOAT*)pf = l;
}

LONG FLOATOBJ_GetFloat(
    PFLOATOBJ pf)
{
    return(((EFLOAT*)pf)->lEfToF());
}

LONG  FLOATOBJ_GetLong(
    PFLOATOBJ pf)
{
    LONG l;
    ((EFLOAT*)pf)->bEfToLTruncate(l);
    return(l);
}

VOID  FLOATOBJ_AddFloat(
    PFLOATOBJ pf,
    FLOATL f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf += ef;
}

VOID  FLOATOBJ_AddLong(
    PFLOATOBJ pf,
    LONG l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf += ef;
}

VOID  FLOATOBJ_Add(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf += *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_AddFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf += *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_SubFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf -= ef;
}

VOID  FLOATOBJ_SubLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf -= ef;
}

VOID  FLOATOBJ_Sub(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf -= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_SubFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf -= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_MulFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf *= ef;
}

VOID  FLOATOBJ_MulLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf *= ef;
}

VOID  FLOATOBJ_MulFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf *= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_Mul(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf *= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_DivFloat(
    PFLOATOBJ pf,
    FLOATL    f)
{
    EFLOAT ef;
    ef = f;
    *(EFLOAT*)pf /= ef;
}

VOID  FLOATOBJ_DivLong(
    PFLOATOBJ pf,
    LONG      l)
{
    EFLOAT ef;
    ef = l;
    *(EFLOAT*)pf /= ef;
}

VOID  FLOATOBJ_Div(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf /= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_DivFloatObj(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    *(EFLOAT*)pf /= *(EFLOAT*)pf1;
}

VOID  FLOATOBJ_Neg(PFLOATOBJ pf)
{
    ((EFLOAT*)pf)->vNegate();
}

BOOL  FLOATOBJ_EqualLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(((EFLOAT*)pf)->bIsZero());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf == ef);
    }
}

BOOL  FLOATOBJ_GreaterThanLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(!((EFLOAT*)pf)->bIsNegative() && !((EFLOAT*)pf)->bIsZero());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf > ef);
    }
}

BOOL  FLOATOBJ_LessThanLong(
    PFLOATOBJ pf,
    LONG      l)
{
    if (l == 0)
    {
        return(((EFLOAT*)pf)->bIsNegative());
    }
    else
    {
        EFLOAT ef;
        ef = l;
        return(*(EFLOAT*)pf < ef);
    }
}

BOOL  FLOATOBJ_Equal(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf == *(EFLOAT*)pf1);
}

BOOL  FLOATOBJ_GreaterThan(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf > *(EFLOAT*)pf1);
}

BOOL  FLOATOBJ_LessThan(
    PFLOATOBJ pf,
    PFLOATOBJ pf1)
{
    return(*(EFLOAT*)pf < *(EFLOAT*)pf1);
}


#endif _x86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\xformgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformgdi.cxx
*
* Contains all the mapping and coordinate functions.
*
* Created: 09-Nov-1990 16:49:36
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#define UNITS_PER_MILLIMETER_LOMETRIC     10    // .1 mm/unit
#define UNITS_PER_MILLIMETER_HIMETRIC    100    // .01 mm/unit
#define UNITS_PER_METER_LOENGLISH       3937    // (100 units/in) / (0.0254 m/in)
#define UNITS_PER_METER_HIENGLISH      39370    // (1000 units/in) / (0.0254 mm/in)
#define UNITS_PER_METER_TWIPS          56693    // (1440 units/in) / (0.0254 mm/in)

#if DBG
int giXformLevel = 0;
#endif

extern "C" BOOL
ProbeAndConvertXFORM(
      XFORML     *kpXform,
      XFORML     *pXform
      );



/******************************Public*Routine******************************\
* GreGetMapMode(hdc)
*
* Get the mapping mode of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int APIENTRY GreGetMapMode(
    HDC hdc)
{
    DWORD dw = 0;
    XDCOBJ dco( hdc );

    if(dco.bValid())
    {
        dw = dco.ulMapMode();
        dco.vUnlockFast();
    }
    else
    {
        WARNING("Invalid DC passed to GreGetMapMode\n");
    }

    return(dw);
}

/******************************Public*Routine******************************\
* GreGetViewportExt(hdc,pSize)
*
* Get the viewport extents of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetViewportExt(
    HDC     hdc,
    PSIZE   pSize)
{
    return(GreGetDCPoint(hdc,DCPT_VPEXT,(PPOINTL)pSize));
}

/******************************Public*Routine******************************\
* GreGetViewportOrg(hdc,pPoint)
*
* Get the viewport origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetViewportOrg(
    HDC     hdc,
    LPPOINT pPoint)
{
    return(GreGetDCPoint(hdc,DCPT_VPORG,(PPOINTL)pPoint));
}

/******************************Public*Routine******************************\
* GreGetWindowExt(hdc,pSize)
*
* Get the window extents of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetWindowExt(
    HDC     hdc,
    PSIZE   pSize)
{
    return(GreGetDCPoint(hdc,DCPT_WNDEXT,(PPOINTL)pSize));
}

/******************************Public*Routine******************************\
* GreGetWindowOrg(hdc,pPoint)
*
* Get the window origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetWindowOrg(
    HDC     hdc,
    LPPOINT pPoint)
{
    return(GreGetDCPoint(hdc,DCPT_WNDORG,(PPOINTL)pPoint));
}

/******************************Public*Routine******************************\
* GreSetViewportOrg(hdc,x,y,pPoint)
*
* Set the viewport origin of the specified dc.
*
*  15-Sep-1992 -by- Gerrit van Wingerden [gerritv]
* Modified since xforms have moved to client side and this routine is
* now only called by usersrv.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetViewportOrg(
 HDC     hdc,
 int     x,
 int     y,
LPPOINT pPoint)
{


    DCOBJ    dcox(hdc);                 // lock the dc object

    if (!dcox.bValid())                 // check if lock is valid
        return(FALSE);

    if (MIRRORED_DC(dcox.pdc))
        x = -x;

    if (BLTOFXOK(x) && BLTOFXOK(y))
    {
        if (!dcox.pdc->bValidPtlCurrent())
        {
            ASSERTGDI(dcox.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

            EXFORMOBJ exoDtoW(dcox, DEVICE_TO_WORLD);

            if (exoDtoW.bValid())
                exoDtoW.bXform(&dcox.ptfxCurrent(), &dcox.ptlCurrent(), 1);

            dcox.pdc->vValidatePtlCurrent();
        }

    // After the transform, the device space CP will be invalid:

        dcox.pdc->vInvalidatePtfxCurrent();

    // x, y of viewport origin can fit into 28 bits.

    // If we get here it means we've been called by USER and Viewport
    // and Window extents should be (1,1) and Window Orgs should be zero,
    // and the world transform shouldn't be set either.

        DONTUSE(pPoint);    // pPoint is now ignored

        EXFORMOBJ xoWtoD(dcox, WORLD_TO_DEVICE);
        EFLOATEXT efDx((LONG) x);
        EFLOATEXT efDy((LONG) y);

        efDx.vTimes16();
        efDy.vTimes16();
        
        ASSERTGDI(xoWtoD.efM11().bIs16() ||
                  (MIRRORED_DC(dcox.pdc) && xoWtoD.efM11().bIsNeg16()),
                  "efM11 not 16 in GreSetViewportOrg or -16 in Mirroring Mode" );
        ASSERTGDI( xoWtoD.efM22().bIs16(),
                   "efM22 not 16 in GreSetViewportOrg" );

        dcox.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID | PAGE_XLATE_CHANGED);
        //xoWtoD.vSetTranslations( efDx, efDy );
        dcox.pdc->lViewportOrgX(x);
        dcox.pdc->lViewportOrgY(y);

        xoWtoD.vInit(dcox, DEVICE_TO_WORLD);

        return(TRUE);

    }
    else
        return(FALSE);
}


/******************************Public*Routine******************************\
* GreSetWindowOrg(hdc,x,y,pPoint)
*
* Set the window origin of the specified dc.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetWindowOrg(
 HDC     hdc,
 int     x,
 int     y,
LPPOINT pPoint)
{


    DCOBJ    dcox(hdc);                 // lock the dc object

    if (!dcox.bValid())                 // check if lock is valid
        return(FALSE);

// If we get here it means we've been called by USER and Viewport
// and Window extents should be (1,1) and Viewport Orgs should be zero,
// and the world transform shouldn't be set either.

    DONTUSE(pPoint);    // pPoint is now ignored

    EXFORMOBJ xoWtoD(dcox, WORLD_TO_DEVICE);
    EFLOATEXT efDx((LONG) -x);
    EFLOATEXT efDy((LONG) -y);

    efDx.vTimes16();
    efDy.vTimes16();

    ASSERTGDI( xoWtoD.efM11().bIs16() ||
               (MIRRORED_DC(dcox.pdc) && xoWtoD.efM11().bIsNeg16()),
               "efM11 not 16 in GreSetViewportOrg" );

    ASSERTGDI( xoWtoD.efM22().bIs16(),
               "efM22 not 16 in GreSetViewportOrg" );

    if (!dcox.pdc->bValidPtlCurrent())
    {
        ASSERTGDI(dcox.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

        EXFORMOBJ exoDtoW(dcox, DEVICE_TO_WORLD);

        if (exoDtoW.bValid())
            exoDtoW.bXform(&dcox.ptfxCurrent(), &dcox.ptlCurrent(), 1);

        dcox.pdc->vValidatePtlCurrent();
    }

// After the transform, the device space CP will be invalid:

    dcox.pdc->vInvalidatePtfxCurrent();

    dcox.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID | PAGE_XLATE_CHANGED);
    //xoWtoD.vSetTranslations( efDx, efDy );

    //
    // save in DC for USER. Caution: these valuse must be restored before app
    // uses DC again
    //

    dcox.pdc->lWindowOrgX(x);
    dcox.pdc->lWindowOrgY(y);
    dcox.pdc->SetWindowOrgAndMirror(x);

    xoWtoD.vInit(dcox, DEVICE_TO_WORLD);

    return( TRUE );

}


/******************************Public*Routine******************************\
* NtGdiConvertMetafileRect:
*
*   Transform a RECT from inclusive-exclusive to inclusive-inclusive for
*   a rectangle recorded in a metafile.
*
* Arguments:
*
*   hdc   - current device context
*   rect  - rtectangle to convert
*
* Return Value:
*
*   MRI_OK,MRI_NULLBOX,MRI_ERROR
*
* History:
*
*    9-Apr-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

LONG APIENTRY
NtGdiConvertMetafileRect(
    HDC    hdc,
    PRECTL prect
    )
{
    LONG lResult = MRI_ERROR;
    RECTL rclMeta;

    //
    // copy in rect structure
    //

    __try
    {
        rclMeta = ProbeAndReadStructure(prect,RECTL);
        lResult = MRI_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(22);
    }

    if (lResult == MRI_OK)
    {
        //
        //  attempt to lock DC
        //

        DCOBJ  dco(hdc);

        if (dco.bValid())
        {
            ERECTFX rectFX;
            BOOL bResult;

            //
            // DC must be in compatible mode
            //

            ASSERTGDI(dco.pdc->iGraphicsMode() == GM_COMPATIBLE,
                        "NtGdiConvertMetafileRect: Map Mode is not GM_COMPATIBLE");

            //
            // transform rectangle points to device FX
            //

            {
                EXFORMOBJ xo(dco,XFORM_WORLD_TO_DEVICE);

                bResult = xo.bXform((PPOINTL)&rclMeta,(PPOINTFIX)&rectFX,2);
            }

            if (bResult)
            {
                //
                // order device point rectangle
                //

                rectFX.vOrder();

                //
                // adjust lower and right points for exclusive to inclusive
                //

                rectFX.xRight  -= 16;
                rectFX.yBottom -= 16;

                //
                // check for empty rectFX
                //

                if ((rectFX.xRight  < rectFX.xLeft) ||
                    (rectFX.yBottom < rectFX.yTop))
                {
                    lResult = MRI_NULLBOX;
                }

                //
                // convert back to logical space
                //

                EXFORMOBJ xoDev(dco,XFORM_DEVICE_TO_WORLD);

                bResult = xoDev.bXform((PPOINTFIX)&rectFX,(PPOINTL)&rclMeta,2);

                //
                // Write results to caller's buffer
                //

                if (bResult)
                {
                    __try
                    {
                        ProbeAndWriteStructure(prect,rclMeta,RECT);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(8);
                        lResult = MRI_ERROR;
                    }
                }
                else
                {
                    lResult = MRI_ERROR;
                }
            }
            else
            {
                lResult = MRI_ERROR;
            }
        }
        else
        {
            lResult = MRI_ERROR;
        }
    }

    if (lResult == MRI_ERROR)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(lResult);
}

/******************************Public*Routine******************************\
*
*
* History:
*  02-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreTransformPoints(
    HDC    hdc,
    PPOINT pptIn,
    PPOINT pptOut,
    int    c,
    int    iMode
    )
{
    XFORMPRINT(1,"GreTransformPoints, iMode = %ld\n",iMode);

    BOOL bResult = FALSE;

    DCOBJ  dco(hdc);                    // lock the dc object

    if (dco.bValid())                  // check if lock is valid
    {
        if (c <= 0)                    // check if there are points to convert
        {
            bResult = TRUE;
        }
        else
        {
            EXFORMOBJ xo(dco, (iMode == XFP_DPTOLP) ? XFORM_DEVICE_TO_WORLD : XFORM_WORLD_TO_DEVICE);

            if (xo.bValid())
            {
                switch (iMode)
                {
                case XFP_DPTOLP:
                case XFP_LPTODP:
                    bResult = xo.bXform((PPOINTL)pptIn, (PPOINTL)pptOut, c);
                    break;

                case XFP_LPTODPFX:
                    bResult = xo.bXform((PPOINTL)pptIn, (PPOINTFIX)pptOut, c);
                    break;

                default:
                    WARNING("Invalid mode passed to GreTranformPoints\n");
                    break;
                }
            }
        }
    }
    return(bResult);
}

/******************************Public*Routine******************************\
* GreDPtoLP(hdc,ppt,nCount)
*
* Convert the given device points into logical points.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreDPtoLP(
HDC     hdc,
LPPOINT ppt,
int     nCount)
{
    return(GreTransformPoints(hdc,ppt,ppt,nCount,XFP_DPTOLP));
}

/******************************Public*Routine******************************\
* GreLPtoDP(hdc,ppt,nCount)
*
* Convert the given logical points into device points.
*
* History:
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreLPtoDP(
HDC     hdc,
LPPOINT ppt,
int     nCount)
{
    return(GreTransformPoints(hdc,ppt,ppt,nCount,XFP_LPTODP));
}

/******************************Private*Routine*****************************\
* bWorldMatrixInRange(pmx)
*
* See if the coefficients of the world transform matrix are within
* our minimum and maximum range.
*
* History:
*  27-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bWorldMatrixInRange(PMATRIX pmx)
{

    BOOL bRet;

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
/*
    EFLOAT ef = pmx->efM11;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM12;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM21;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efM22;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efDx;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);

    ef = pmx->efDy;
    ef.vAbs();
    if ((ef < (FLOAT)MIN_WORLD_XFORM) || (ef > (FLOAT)MIN_WORLD_XFORM))
        return(FALSE);
*/

    bRet = TRUE;

#else


    bRet =
    ((pmx->efM11.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM12.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM21.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efM22.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efDx.bExpLessThan(MAX_WORLD_XFORM_EXP)) &&
     (pmx->efDy.bExpLessThan(MAX_WORLD_XFORM_EXP)))
     ;

#endif

    if (bRet)
    {
    // at this point bRet == TRUE. We have to figure out the cases
    // when the determinant is zero and set bRet to FALSE;

    // We do what we can to avoid multiplications in common cases
    // when figuring out if this is a singular trasform

        if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
        {
            if (pmx->efM11.bIsZero() || pmx->efM22.bIsZero())
                bRet = FALSE;
        }
        else if (pmx->efM11.bIsZero() && pmx->efM22.bIsZero())
        {
            if (pmx->efM12.bIsZero() || pmx->efM21.bIsZero())
                bRet = FALSE;
        }
        else // general case, have to do multiplications
        {
            EFLOAT ef = pmx->efM11;
            ef *= pmx->efM22;

            EFLOAT ef1 = pmx->efM12;
            ef1 *= pmx->efM21;

            ef -= ef1; // determinant.

            if (ef.bIsZero())
            {
                bRet = FALSE;
            }
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* GreGetDeviceWidth(hdc)
*
* Get the device surface width of the specified dc.
*
* History:
*  26-Jan-1998 -by- Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
LONG  APIENTRY
GreGetDeviceWidth(HDC hdc)
{
    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        return (dco.pdc->GetDeviceWidth());
    }
    else
    {
        WARNING("Invalid DC passed to GreGetDeviceWidth\n");
    }

    return (GDI_ERROR);
}

/******************************Public*Routine******************************\
* GreMirrorWindowOrg(hdc)
*
* Mirror the Window X Org. By calling MirrorWindowOrg
*
* History:
*  26-Jan-1998 -by- Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
BOOL  APIENTRY
GreMirrorWindowOrg(HDC hdc)
{
    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        dco.pdc->MirrorWindowOrg();
        return (TRUE);
    }

    return (FALSE);
}
/******************************Public*Routine******************************\
* GreGetLayout
*
*
* History:
*  Fri 12-Sep-1991 11:29    -by- Mohamed Hassanin [MHamid]
* Wrote it.
\**************************************************************************/
DWORD APIENTRY
GreGetLayout(HDC hdc)
{
    DWORD dwRet = GDI_ERROR;

    DCOBJ dco(hdc);

    if (dco.bValid() != FALSE)
    {
        dwRet = dco.pdc->dwLayout();
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* GreSetLayout
*
*
* History:
*  Fri 12-Sep-1991 11:29    -by- Mohamed Hassanin [MHamid]
* Wrote it.
\**************************************************************************/
DWORD APIENTRY
GreSetLayout
( HDC    hdc,
  LONG   wox,
  DWORD  dwLayout)
{
    DCOBJ dco( hdc );
    if( !dco.bValid() )
    {
       WARNING("Xform update invalid hdc\n");
       return(GDI_ERROR);
    }
    return dco.pdc->dwSetLayout(wox, dwLayout);
}

/******************************Public*Routine******************************\
* GreXformUpdate
*
* Updates the server's copy of the WtoD transform, transform related flags,
* and viewport and window extents.
*
* History:
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/


BOOL GreXformUpdate
( HDC hdc,
  FLONG flXform,
  LONG wex,
  LONG wey,
  LONG vex,
  LONG vey,
  LONG mapMode,
  PVOID pvMatrix
)
{
    DCOBJ dco( hdc );

    if( !dco.bValid() )
    {
       WARNING("Xform update invalid hdc\n");
       return(FALSE);
    }

// Copy window and viewport extents
    dco.pdc->vSet_szlWindowExt( wex, wey );
    dco.pdc->vSet_szlViewportExt( vex, vey );
    dco.pdc->ulMapMode( mapMode );

// Save current position

    ASSERTGDI(dco.bValid(), "DC not valid");

    if (!dco.pdc->bValidPtlCurrent())
    {
        ASSERTGDI(dco.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

        EXFORMOBJ exoDtoW(dco, DEVICE_TO_WORLD);

        if (exoDtoW.bValid())
            exoDtoW.bXform(&dco.ptfxCurrent(), &dco.ptlCurrent(), 1);

        dco.pdc->vValidatePtlCurrent();
    }

// Set the flags

    dco.pdc->flResetflXform( flXform );
    dco.pdc->flSet_flXform( DEVICE_TO_WORLD_INVALID );

// Set the new world transform

    RtlCopyMemory( (PVOID) &dco.pdc->mxWorldToDevice(), pvMatrix, sizeof( MATRIX ));
    RtlCopyMemory( (PVOID) &dco.pdc->mxUserWorldToDevice(), pvMatrix, sizeof( MATRIX ));

// After the transform, the device space CP will be invalid:

    dco.pdc->vInvalidatePtfxCurrent();

    if( flXform & INVALIDATE_ATTRIBUTES )
    {
        EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

        dco.pdc->vRealizeLineAttrs(exo);
        dco.pdc->vXformChange(TRUE);
    }

    return (TRUE);
}

/******************************Member*Function*****************************\
* vConvertXformToMatrix
*
* Convert a xform structure into a matrix struct.
*
* History:
*  27-Mar-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vConvertXformToMatrix(CONST XFORML *pxf, PMATRIX pmx)
{
    pmx->efM11 = pxf->eM11;         // overloading operator = which covert
    pmx->efM12 = pxf->eM12;         // IEEE float to our internal EFLOAT
    pmx->efM21 = pxf->eM21;
    pmx->efM22 = pxf->eM22;
    pmx->efDx = pxf->eDx;
    pmx->efDy = pxf->eDy;
#if DBG
    if (!pmx->efDx.bEfToL(pmx->fxDx))
        WARNING("vConvertXformToMatrix:translation dx overflowed\n");
    if (!pmx->efDy.bEfToL(pmx->fxDy))
        WARNING("vConvertXformToMatrix:translation dy overflowed\n");
#else
    pmx->efDx.bEfToL(pmx->fxDx);
    pmx->efDy.bEfToL(pmx->fxDy);
#endif
    pmx->flAccel = XFORM_FORMAT_LTOL;

    if ((pmx->efDx == pmx->efDy) && pmx->efDy.bIsZero())
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
        pmx->flAccel |= XFORM_SCALE;
        if (pmx->efM11.bIs1() && pmx->efM22.bIs1())
            pmx->flAccel |= XFORM_UNITY;
    }

}

/******************************Private*Routine*****************************\
* vMakeIso()
*
* Shrink viewport extents in one direction to match the aspect ratio of
* the window.
*
* History:
*
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  09-Nov-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vMakeIso()
{
    LONG    lVpExt;
    EFLOAT  efRes, efTemp, efTemp1;

// Calculate the pixel aspect ratio efRes = ASPECTY / ASPECTX.

    if(lVirtualDevicePixelCx() != 0)
    {
        //
        // if lVirtualDeviceCx/Cy are set, use these, they are in micrometers
        // Otherwise use their millimeters counter part
        //
        if ((lVirtualDeviceCx()) != 0 && (lVirtualDeviceCy() != 0))
        {
           efTemp = lVirtualDevicePixelCx();
           efTemp1 = lVirtualDeviceCy();

           LONG lTemp = EngMulDiv(lVirtualDevicePixelCy(), lVirtualDeviceCx(), lVirtualDevicePixelCx());
           efRes = lTemp;
           efRes /= efTemp1;
        }
        else
        {
           efRes = lVirtualDevicePixelCy() * lVirtualDeviceMmCx();
           efTemp = lVirtualDevicePixelCx();
           efTemp1 = lVirtualDeviceMmCy();

           efRes /= efTemp;
           efRes /= efTemp1;
        }
    }
    else
    {
        PDEVOBJ po(hdev());
        ASSERTGDI(po.bValid(), "Invalid PDEV\n");

        efRes  = (LONG)po.ulLogPixelsY();
        efTemp = (LONG)po.ulLogPixelsX();
        efRes /= efTemp;
    }

// Our goal is to make the following formula true
// VpExt.cy / VpExt.cx = (WdExt.cy / WdExt.cx) * (ASPECTY / ASPECTX)

// Let's calculate VpExt.cy assuming VpExt.cx is the limiting factor.
// VpExt.cy = (WdExt.cy * VpExt.cx) / WdExt.cx * efRes

    EFLOATEXT efVpExt = lWindowExtCy();
    efTemp   = lViewportExtCx();
    efTemp1  = lWindowExtCx();
    efVpExt *= efTemp;
    efVpExt /= efTemp1;
    efVpExt *= efRes;
    efVpExt.bEfToL(lVpExt);             // convert efloat to long

    lVpExt = ABS(lVpExt);

// Shrink y if the |original VpExt.cy| > the |calculated VpExt.cy|
// The original signs of the extents are preserved.

    if (lViewportExtCy() > 0)
    {
        if (lViewportExtCy() >= lVpExt)
        {
            lViewportExtCy(lVpExt);
            return;
        }
    }
    else
    {
        if (-lViewportExtCy() >= lVpExt)
        {
            lViewportExtCy(-lVpExt);
            return;
        }
    }

// We know VpExt.cy is the real limiting factor.  Let's calculate the correct
// VpExt.cx.
// VpExt.cx = (WdExt.cx * VpExt.cy) / WdExt.cy / Res

    efVpExt  = lWindowExtCx();
    efTemp   = lViewportExtCy();
    efTemp1  = lWindowExtCy();
    efVpExt *= efTemp;
    efVpExt /= efTemp1;
    efVpExt /= efRes;
    efVpExt.bEfToL(lVpExt);

    lVpExt = ABS(lVpExt);

    if(lViewportExtCx() > 0 )
        lViewportExtCx(lVpExt);
    else
        lViewportExtCx(-lVpExt);

}


/**************************************************************************\
* NtGdiScaleViewportExtEx()
*
* History:
*  07-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL
NtGdiScaleViewportExtEx(
    HDC    hdc,
    int    xNum,
    int    xDenom,
    int    yNum,
    int    yDenom,
    LPSIZE pszOut
    )
{
    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {
        BOOL bNoExcept = TRUE;

        //
        // NOTE: NT 3.51 compatibility.
        // Even if the API failed (returned FALSE), the viewport was returned
        // properly - stay compatible with this.
        //

        if (pszOut)
        {
            __try
            {
                ProbeForWrite(pszOut,sizeof(SIZE), sizeof(DWORD));
                *pszOut = dcox.pdc->szlViewportExt();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());

                bNoExcept = FALSE;
            }
        }

        if (bNoExcept == TRUE)
        {
            // can't change extent if fixed scale

            if (dcox.ulMapMode() <= MM_MAX_FIXEDSCALE)
            {
                bRet = TRUE;
            }
            else
            {
                LONG lx, ly;
                if ((xDenom != 0) &&
                    (yDenom != 0) &&
                    ((lx = (dcox.pdc->lViewportExtCx() * xNum) / xDenom) != 0) &&
                    ((ly = (dcox.pdc->lViewportExtCy() * yNum) / yDenom) != 0))
                {
                    dcox.pdc->lViewportExtCx(lx);
                    dcox.pdc->lViewportExtCy(ly);
                    dcox.pdc->MirrorWindowOrg();
                    dcox.pdc->vPageExtentsChanged();
                    bRet = TRUE;
                }
            }
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* GreScaleWindowExtEx()
*
* History:
*  02-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreScaleWindowExtEx(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    PSIZE psizl)
{
    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);                   // lock the dc object

    if (dcox.bValid())                 // check if lock is valid
    {
        if (psizl != (LPSIZE)NULL)
        {
            *psizl = dcox.pdc->szlWindowExt();      // fetch old extent
            if (MIRRORED_DC(dcox.pdc))
                psizl->cx = -psizl->cx;
        }

    // can't change extent if fixed scale

        if (dcox.ulMapMode() <= MM_MAX_FIXEDSCALE)
        {
            bRet = TRUE;
        }
        else
        {
            LONG lx, ly;
            if ((xDenom != 0) &&
                (yDenom != 0) &&
                ((lx = (dcox.pdc->lWindowExtCx() * xNum) / xDenom) != 0) &&
                ((ly = (dcox.pdc->lWindowExtCy() * yNum) / yDenom) != 0))
            {
                dcox.pdc->lWindowExtCx(lx);
                dcox.pdc->lWindowExtCy(ly);
                dcox.pdc->MirrorWindowOrg();
                dcox.pdc->vPageExtentsChanged();
                bRet = TRUE;
            }
        }
    }
    return(bRet);
}

/******************************Private*Routine*****************************\
* vComputePageXform
*
* Compute the page to device scaling factors.
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*
*  15-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vComputePageXform()
{
    EFLOAT ef;
    EFLOATEXT efTemp;

    ef     = LTOFX(lViewportExtCx());
    efTemp = lWindowExtCx();
    ef    /= efTemp;
    efM11PtoD(ef);

    ef     = LTOFX(lViewportExtCy());
    efTemp = lWindowExtCy();
    ef    /= efTemp;
    efM22PtoD(ef);
}

/******************************Public*Routine******************************\
*
* int EngMulDiv
* I am surprised that there is no system service routine to do this.
* anyway I am just fixing the old routine
*
* History:
*  15-Dec-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int EngMulDiv(
    int a,
    int b,
    int c)
{
    LONGLONG ll;
    int iSign = 1;

    if (a < 0)
    {
        iSign = -iSign;
        a = -a;
    }
    if (b < 0)
    {
        iSign = -iSign;
        b = -b;
    }

    if (c != 0)
    {
        if (c < 0)
        {
            iSign = -iSign;
            c = -c;
        }

        ll = (LONGLONG)a;
        ll *= b;
        ll += (c/2); // used to add (c+1)/2 which is wrong
        ll /= c;

    // at this point ll is guaranteed to be > 0. Thus we will do
    // unsigned compare in the next step which generates two less instructions
    // on x86 [bodind]

        if ((ULONGLONG)ll > (ULONG)INT_MAX) // check for overflow:
        {
            if (iSign > 0)
                return INT_MAX;
            else
                return INT_MIN;
        }
        else
        {
            if (iSign > 0)
                return ((int)ll);
            else
                return (-(int)ll);
        }
    }
    else
    {
        ASSERTGDI(c, "EngMulDiv - c == 0\n");
        ASSERTGDI(a | b, "EngMulDiv - a|b == 0\n");

        if (iSign > 0)
            return INT_MAX;
        else
            return INT_MIN;
    }
}
/******************************Public*Routine******************************\
* dwSetLayout
*
* Mirror the dc, by offsetting the window origin. If wox == -1, then the
* window origin becomes mirrored by the DC window width as follows :
* -((Device_Surface_Width * WindowExtX) / ViewportExtX) + LogicalWindowOrgX
*
* Otherwise mirroring is done by the specified wox amount :
* (wox - Current Window X-Origin)
*
* The function also changes windowExt.cx to be -1 so that positive x will
* go from right to left.
*
* History:
*  09-Dec-1997 -by- Mohammed Abdel-Hamid  [mhamid]
* Wrote it.
\**************************************************************************/

DWORD DC::dwSetLayout(LONG   wox, DWORD dwDefLayout)
{

    POINTL ptWOrg, ptVOrg;
    SIZEL  SzWExt, SzVExt;
    DWORD  dwOldLayout;

    dwOldLayout = dwLayout();
    dwLayout(dwDefLayout);
    if ((dwOldLayout & LAYOUT_ORIENTATIONMASK) == (dwDefLayout & LAYOUT_ORIENTATIONMASK)) {
        return dwOldLayout;
    }

    vGet_szlWindowExt(&SzWExt);
    vGet_ptlViewportOrg(&ptVOrg);

    if (dwDefLayout & LAYOUT_RTL) {
        //Set the rtl layout
        ulMapMode(MM_ANISOTROPIC);
        ASSERTGDI((SzWExt.cx > 0), "GreSetLayout WExt.cx < 0 Check it");
    } else {
        ASSERTGDI((SzWExt.cx < 0), "GreSetLayout WExt.cx > 0 Check it");
    }

    SzWExt.cx = -SzWExt.cx;
    vSet_szlWindowExt(&SzWExt);

    ptVOrg.x = -ptVOrg.x;
    vSet_ptlViewportOrg(&ptVOrg);

    if (wox == -1) {
        MirrorWindowOrg();
    } else {
        vGet_ptlWindowOrg(&ptWOrg);
        ptWOrg.x = wox - ptWOrg.x;
        vSet_ptlWindowOrg(&ptWOrg);
    }

    //
    // TA_CENTER equals 6 (0110 Bin) and TA_RIGHT equals 2 (0010 Binary) numerically.
    // so be careful not to do 'flTextAlign() & TA_CENTER'
    // since this will succeed for RIGHT aligned DCs
    // and as a result, the TA_RIGHT bit won't get cleared. [samera]
    //
    if ((flTextAlign()&TA_CENTER) != TA_CENTER) {
        flTextAlign(flTextAlign() ^ (TA_RIGHT));
    }
    if (bClockwise()) {
        vClearClockwise();
    } else {
        vSetClockwise();
    }
    vPageExtentsChanged();
    return dwOldLayout;
}

EFLOAT ef16 = {EFLOAT_16};

/******************************Public*Routine******************************\
* DC::iSetMapMode()
*
* History:
*  07-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int DC::iSetMapMode(
    int iMode)
{
    int iOldMode;
    DWORD dwOldLayout = 0;

    // If the new map mode is not MM_ANISOTROPIC
    // And the DC in a mirrored mode
    // Then Turn off the mirroring and turn it on back after
    // Setting the new mode.

    if (iMode != MM_ANISOTROPIC) {
        dwOldLayout = dwLayout();
        if (dwOldLayout & LAYOUT_ORIENTATIONMASK) {
            dwSetLayout(-1 , 0);
        }
    }

// If set to the old map mode, don't bother setting it again except
// with MM_ISOTROPIC in which the extents might have been changed.

    iOldMode = ulMapMode();

    if ((iMode != iOldMode) || (iMode == MM_ISOTROPIC))
    {
        if (iMode == MM_TEXT)
        {
            lWindowExtCx(1);
            lWindowExtCy(1);
            lViewportExtCx(1);
            lViewportExtCy(1);
            ulMapMode(iMode);

        // We don't want to recalculate M11 and M22 in vUpdateWtoDXform().
        // Set them correctly here so we can just recalculate translations
        // in vUpdateWtoDXform().

            efM11PtoD(ef16);
            efM22PtoD(ef16);
            mxWorldToDevice().efM11 = ef16;
            mxWorldToDevice().efM22 = ef16;
            mxWorldToDevice().flAccel = XFORM_FORMAT_LTOFX | XFORM_UNITY | XFORM_SCALE;
            RtlCopyMemory(
                  (PVOID) &mxUserWorldToDevice(),
                  (PVOID) &mxWorldToDevice(),
                  sizeof( MATRIX ));

            vSetFlagsMM_TEXT();
        }
        else if (iMode == MM_ANISOTROPIC)
        {
            ulMapMode(iMode);
            vSetFlagsMM_ISO_OR_ANISO();
        }
        else if ((iMode < MM_MIN) || (iMode > MM_MAX))
        {
            return(0);
        }
        else if (lVirtualDevicePixelCx() == 0)
        {
            PDEVOBJ po(hdev());
            ASSERTGDI(po.bValid(), "Invalid PDEV\n");

        // Protect against dynamic mode changes while we compute values
        // using ulHorzSize and ulVertSize:

            DEVLOCKOBJ dlo(po);

        // Get the size of the surface

            lViewportExtCx(po.GdiInfo()->ulHorzRes);
            lViewportExtCy(-(LONG)po.GdiInfo()->ulVertRes);

        // Get the size of the device

            switch (iMode)
            {
            case MM_LOMETRIC:
            //
            // n um. * (1 mm. / 1000 um.) * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 50)/100);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 50)/100);
                vSetFlagsMM_FIXED();
                break;

            case MM_HIMETRIC:
            //
            // n um. * (1 mm. / 1000 um.) * (100 HiMetric units/1 mm.) = y HiMet
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 5)/10);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 5)/10);
                vSetFlagsMM_FIXED();
                break;

            case MM_LOENGLISH:
            //
            // n um. * (1 in. / 25400 um.) * (100 LoEng units/1 in.) = y LoEng
            //
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 127)/254);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 127)/254);
                vSetFlagsMM_FIXED();
                break;

            case MM_HIENGLISH:
            //
            // n um. * (1 in. / 25400 um.) * (1000 HiEng units/1 in.) = m HiEng
            //
                lWindowExtCx(EngMulDiv(po.GdiInfo()->ulHorzSize, 10, 254));
                lWindowExtCy(EngMulDiv(po.GdiInfo()->ulVertSize, 10, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_TWIPS:
            //
            // n um. * (1 in. / 25400 um.) * (1440 Twips/1 in.) = m Twips
            //
                lWindowExtCx(EngMulDiv(po.GdiInfo()->ulHorzSize, 144, 2540));
                lWindowExtCy(EngMulDiv(po.GdiInfo()->ulVertSize, 144, 2540));

            // If it's cached earlier, use it.

            #if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
                if (efM11_TWIPS().e == (FLOAT)0)
            #else
                if (efM11_TWIPS().i.lMant == 0)
            #endif
                {
                    vComputePageXform();
                    efM11_TWIPS(efM11PtoD());
                    efM22_TWIPS(efM22PtoD());
                }
                ulMapMode(MM_TWIPS);

            // We don't want to recalculate M11 and M22 in vUpdateWtoDXform().
            // Set them correctly here so we can just recalculate translations
            // in vUpdateWtoDXform().

                efM11PtoD(efM11_TWIPS());
                efM22PtoD(efM22_TWIPS());
                mxWorldToDevice().efM11 = efM11_TWIPS();
                mxWorldToDevice().efM22 = efM22_TWIPS();
                mxWorldToDevice().flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
                   RtlCopyMemory(
                         (PVOID) &mxUserWorldToDevice(),
                         (PVOID) &mxWorldToDevice(),
                         sizeof( MATRIX ));

                vSetFlagsMM_FIXED_CACHED();
                goto JUST_RETURN;
                //
                // we need to pass thru mirroring code if
                // it is enabled so the followingis commented for
                // the above line
                // return(iOldMode);
                //

            case MM_ISOTROPIC:
                lWindowExtCx((po.GdiInfo()->ulHorzSize + 50)/100);
                lWindowExtCy((po.GdiInfo()->ulVertSize + 50)/100);
                vSetFlagsMM_ISO_OR_ANISO();
                break;

            default:
                return(0);
            }

            ulMapMode(iMode);
            vPageExtentsChanged();
        }
        else
        {
        // Get the size of the virtual surface

            lViewportExtCx(lVirtualDevicePixelCx());
            lViewportExtCy(-lVirtualDevicePixelCy());

        // Get the size of the virtual device

            switch (iMode)
            {
            case MM_LOMETRIC:
            //
            // n mm. * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx(10 * lVirtualDeviceMmCx());
                lWindowExtCy(10 * lVirtualDeviceMmCy());
                vSetFlagsMM_FIXED();
                break;

            case MM_HIMETRIC:
            //
            // n mm. * (100 HiMetric units/1 mm.) = y HiMet
            //
                lWindowExtCx(100 * lVirtualDeviceMmCx());
                lWindowExtCy(100 * lVirtualDeviceMmCy());
                vSetFlagsMM_FIXED();
                break;

            case MM_LOENGLISH:
            //
            // n mm. * (10 in./254 mm.) * (100 LoEng/1 in.) = y LoEng
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),1000, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),1000, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_HIENGLISH:
            //
            // n mm. * (10 in./254 mm.) * (1000 LoEng/1 in.) = y LoEng
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),10000, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),10000, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_TWIPS:
            //
            // n mm. * (10 in./254 mm.) * (1440 Twips/1 in.) = y Twips
            //
                lWindowExtCx(EngMulDiv(lVirtualDeviceMmCx(),14400, 254));
                lWindowExtCy(EngMulDiv(lVirtualDeviceMmCy(),14400, 254));
                vSetFlagsMM_FIXED();
                break;

            case MM_ISOTROPIC:
            //
            // n mm. * (10 LoMetric units/1 mm.) = y LoMet
            //
                lWindowExtCx(10 * lVirtualDeviceMmCx());
                lWindowExtCy(10 * lVirtualDeviceMmCy());
                vSetFlagsMM_ISO_OR_ANISO();
                break;

            default:
                return(0);
            }

            ulMapMode(iMode);
            vPageExtentsChanged();

        }
JUST_RETURN:
        // If turned the mirroring off then turn it on back.
        if (dwOldLayout & LAYOUT_ORIENTATIONMASK) {
            //And then set it again.
            dwSetLayout(-1 , dwOldLayout);
        }
    }

    return(iOldMode);
}

/******************************Public*Routine******************************\
* NtGdiSetVirtualResolution()
*
* Set the virtual resolution of the specified dc.
* The virtual resolution is used to compute transform matrix only.
* If the virtual units are all zeros, the default physical units are used.
* Otherwise, non of the units can be zero.
*
* Currently used by metafile component only.
*
* History:
*
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Moved back to the server
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  Tue Aug 27 13:04:11 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiSetVirtualResolution(
    HDC    hdc,
    int    cxVirtualDevicePixel,    // Width of the virtual device in pels
    int    cyVirtualDevicePixel,    // Height of the virtual device in pels
    int    cxVirtualDeviceMm,       // Width of the virtual device in millimeters
    int    cyVirtualDeviceMm)       // Height of the virtual device in millimeters
{
    XFORMPRINT(1,"GreSetVirtualResolution\n",0);

    BOOL bRet = FALSE;

// The units must be all zeros or all non-zeros.

    if ((cxVirtualDevicePixel != 0 && cyVirtualDevicePixel != 0 &&
         cxVirtualDeviceMm    != 0 && cyVirtualDeviceMm != 0)
        ||
        (cxVirtualDevicePixel == 0 && cyVirtualDevicePixel == 0 &&
         cxVirtualDeviceMm    == 0 && cyVirtualDeviceMm    == 0))
    {
    // now lock down the DC

        DCOBJ dcox(hdc);                   // lock the dc object

        if (dcox.bValid())                 // check if lock is valid
        {

            dcox.pdc->lVirtualDevicePixelCx(cxVirtualDevicePixel);
            dcox.pdc->lVirtualDevicePixelCy(cyVirtualDevicePixel);

            dcox.pdc->lVirtualDeviceMmCx(cxVirtualDeviceMm);
            dcox.pdc->lVirtualDeviceMmCy(cyVirtualDeviceMm);

            bRet = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetSizeDevice()
*
* This is to compensate insufficient precision in SetVirtualResolution
*
* Modified for client side use.
*
*  5/17/99 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL APIENTRY NtGdiSetSizeDevice(
    HDC    hdc,
    int    cxVirtualDevice,       // Width of the virtual device in micrometers
    int    cyVirtualDevice)       // Height of the virtual device in micrometers
{
    BOOL bRet = FALSE;

// The units must be all zeros or all non-zeros.

    if ((cxVirtualDevice != 0) && (cyVirtualDevice != 0))
    {
    // now lock down the DC

        DCOBJ dcox(hdc);                   // lock the dc object

        if (dcox.bValid())                 // check if lock is valid
        {

            dcox.pdc->lVirtualDeviceCx(cxVirtualDevice);
            dcox.pdc->lVirtualDeviceCy(cyVirtualDevice);

            bRet = TRUE;
        }
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* GreGetTransform()
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreGetTransform(
    HDC     hdc,
    DWORD   iXform,
    XFORML *pxf)
{
    XFORMPRINT(1,"GreGetTransform - iXform = %ld\n",iXform);

    BOOL bRet = FALSE;

    // now lock down the DC

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {

        EXFORMOBJ xo(dcox,iXform);
        MATRIX mx;

        if (!xo.bValid() && (iXform == XFORM_PAGE_TO_DEVICE))
        {
            xo.vInitPageToDevice(dcox,&mx);
        }

        if (xo.bValid())
        {
            xo.vGetCoefficient(pxf);

            bRet = TRUE;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* XformUpdate
*
*  Sends update transform information to the server.
*
* History:
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vInit(
    XDCOBJ& dco,
    ULONG iXform)
{
    XFORMPRINT(1,"EXFORMOBJ::vInit - iXform = %lx\n",iXform);

    if (dco.pdc->bDirtyXform())
    {
    // Save current position

        if (!dco.pdc->bValidPtlCurrent())
        {
            ASSERTGDI(dco.pdc->bValidPtfxCurrent(), "Both CPs invalid?");

            EXFORMOBJ exoDtoW(dco.pdc->mxDeviceToWorld());

            if (exoDtoW.bValid())
                exoDtoW.bXform(&dco.ptfxCurrent(), &dco.ptlCurrent(), 1);

            dco.pdc->vValidatePtlCurrent();
        }

    // update the transforms

        dco.pdc->vUpdateWtoDXform();

    // After the transform, the device space CP will be invalid:

        dco.pdc->vInvalidatePtfxCurrent();

        if( dco.pdc->flXform() & INVALIDATE_ATTRIBUTES)
        {

            EXFORMOBJ exoWtoD(dco.pdc->mxWorldToDevice());

            dco.pdc->vRealizeLineAttrs(exoWtoD);
            dco.pdc->vXformChange(TRUE);
            dco.pdc->flClr_flXform(INVALIDATE_ATTRIBUTES);
        }

        dco.pdc->flSet_flXform(DEVICE_TO_WORLD_INVALID);
    }

    switch (iXform)
    {
    case XFORM_WORLD_TO_DEVICE:
        pmx = &dco.pdc->mxWorldToDevice();
        XFORMPRINT(2,"EXFORM::vInit - WtoD, pmx = %p\n",pmx);
        break;

    case XFORM_DEVICE_TO_WORLD:
        pmx = &dco.pdc->mxDeviceToWorld();

        if (dco.pdc->flXform() & DEVICE_TO_WORLD_INVALID)
        {
            if (bInverse(dco.pdc->mxWorldToDevice()))
            {
               dco.pdc->flClr_flXform(DEVICE_TO_WORLD_INVALID);
               RtlCopyMemory(
                              (PVOID)&dco.pdc->mxUserDeviceToWorld(),
                              (PVOID)pmx,
                              sizeof( MATRIX )
                            );

            }
            else
            {
               pmx = (PMATRIX)NULL;
            }
            XFORMPRINT(2,"EXFORM::vInit - DtoW was dirty, pmx = %p\n",pmx);
        }
        break;

    case XFORM_WORLD_TO_PAGE:
        XFORMPRINT(2,"EXFORM::vInit - WtoP, pmx = %p\n",pmx);
        pmx = &dco.pdc->mxWorldToPage();
        break;

    default:
        XFORMPRINT(2,"EXFORM::vInit - NULL",pmx);
        pmx = NULL;
        break;
    }
}

/******************************Public*Routine******************************\
* EXFORMOBJ::vInitPageToDevice()
*
* History:
*  05-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vInitPageToDevice(
    XDCOBJ& dco,
    PMATRIX pmx_)
{
    pmx = pmx_;

    pmx->efM11 = dco.pdc->efM11PtoD();
    pmx->efM12.vSetToZero();
    pmx->efM21.vSetToZero();
    pmx->efM22 = dco.pdc->efM22PtoD();
    pmx->efDx  = dco.pdc->efDxPtoD();
    pmx->efDy  = dco.pdc->efDyPtoD();
    pmx->efDx.bEfToL(pmx->fxDx);
    pmx->efDy.bEfToL(pmx->fxDy);

    vComputeWtoDAccelFlags();
}

/******************************Private*Routine*****************************\
* vUpdateWtoDXform
*
* Update the world to device transform.
*
* History:
*
*  15-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID DC::vUpdateWtoDXform()
{
    PMATRIX pmx = &mxWorldToDevice();

    if (bDirtyXlateOrExt())
    {
        if (bPageExtentsChanged())
        {
        // Recalculate the scaling factors for the page to device xform.

        // M11 = ViewportExt.cx / WindowExt.cx
        // M22 = ViewportExt.cy / WindowExt.cy

            if (ulMapMode() == MM_ISOTROPIC)
                vMakeIso();

            if ((lWindowExtCx() == lViewportExtCx()) &&
                (lWindowExtCy() == lViewportExtCy()))
            {
                efM11PtoD(ef16);
                efM22PtoD(ef16);

                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_UNITY | XFORM_SCALE;

                flSet_flXform(PAGE_TO_DEVICE_SCALE_IDENTITY);
            }
            else
            {
                EFLOATEXT ef1;
                EFLOATEXT ef2;
                ef1 = LTOFX(lViewportExtCx());
                ef2 = lWindowExtCx();
                ef1 /= ef2;
                efM11PtoD(ef1);

                ef1 = LTOFX(lViewportExtCy());
                ef2 = lWindowExtCy();
                ef1 /= ef2;
                efM22PtoD(ef1);

                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
                flClr_flXform(PAGE_TO_DEVICE_SCALE_IDENTITY | PAGE_TO_DEVICE_IDENTITY);
            }

            if (efM11PtoD().bIsNegative())
                flSet_flXform(PTOD_EFM11_NEGATIVE);
            else
                flClr_flXform(PTOD_EFM11_NEGATIVE);

            if (efM22PtoD().bIsNegative())
                flSet_flXform(PTOD_EFM22_NEGATIVE);
            else
                flClr_flXform(PTOD_EFM22_NEGATIVE);
        }

    // Recalculate the translations for the page to device xform.

    // Dx = ViewportOrg.x - (ViewportExt.cx / WindowExt.cx) * WindowOrg.x
    // (ViewportExt.cx / WindowExt.cx) = efM11

    // Dy = ViewportOrg.y - (ViewportExt.cy / WindowExt.cy) * WindowOrg.cy
    // (ViewportExt.cy / WindowExt.cy) = efM22

        if ((lWindowOrgX() == 0) &&
            (lWindowOrgY() == 0))
        {
            if ((lViewportOrgX() == 0) &&
                (lViewportOrgY() == 0))
            {
                EFLOAT efZ;
                efZ.vSetToZero();

                efDxPtoD(efZ);
                efDyPtoD(efZ);
                pmx->fxDx = 0;
                pmx->fxDy = 0;
                pmx->flAccel |= XFORM_NO_TRANSLATION;

                if (bPageToDeviceScaleIdentity())
                    flSet_flXform(PAGE_TO_DEVICE_IDENTITY);
            }
            else
            {
                efDxPtoD(LTOFX(lViewportOrgX()));
                efDyPtoD(LTOFX(lViewportOrgY()));

                pmx->fxDx = LTOFX(lViewportOrgX());
                pmx->fxDy = LTOFX(lViewportOrgY());

                pmx->flAccel &= ~XFORM_NO_TRANSLATION;
                flClr_flXform(PAGE_TO_DEVICE_IDENTITY);
            }
        }
        else
        {
            flClr_flXform(PAGE_TO_DEVICE_IDENTITY);
            pmx->flAccel &= ~XFORM_NO_TRANSLATION;
            if (bPageToDeviceScaleIdentity())
            {
                efDxPtoD(LTOFX(-lWindowOrgX()));
                efDyPtoD(LTOFX(-lWindowOrgY()));

                if ((lViewportOrgX() != 0) ||
                    (lViewportOrgY() != 0))
                {
                    goto ADD_VIEWPORT_ORG;
                }

                pmx->fxDx = LTOFX(-lWindowOrgX());
                pmx->fxDy = LTOFX(-lWindowOrgY());
            }
            else
            {
                {
                    EFLOATEXT ef;
                    ef = -lWindowOrgX();
                    ef *= efrM11PtoD();
                    efDxPtoD(ef);

                    ef = -lWindowOrgY();
                    ef *= efrM22PtoD();
                    efDyPtoD(ef);
                }

                if ((lViewportOrgX()!= 0) ||
                    (lViewportOrgY() != 0))
                {
                ADD_VIEWPORT_ORG:

                    EFLOATEXT efXVO(LTOFX(lViewportOrgX()));
                    efXVO += efrDxPtoD();
                    efDxPtoD(efXVO);

                    EFLOATEXT efYVO(LTOFX(lViewportOrgY()));
                    efYVO += efrDyPtoD();
                    efDyPtoD(efYVO);
                }

                efDxPtoD().bEfToL(pmx->fxDx);
                efDyPtoD().bEfToL(pmx->fxDy);
            }
        }

        if (bWorldToPageIdentity())
        {
        // Copy the PAGE_TO_DEVICE xform to WORLD_TO_DEVICE.
        // pmx->fxDx, fxDy and flAccel has been set earlier in this routine.

            pmx->efM11 = efM11PtoD();
            pmx->efM22 = efM22PtoD();
            pmx->efM12.vSetToZero();
            pmx->efM21.vSetToZero();
            pmx->efDx  = efDxPtoD();
            pmx->efDy  = efDyPtoD();

            if (bPageToDeviceIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY |
                               XFORM_NO_TRANSLATION;
            else if (bPageToDeviceScaleIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
            else
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;

            flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                          WORLD_XFORM_CHANGED);


            RtlCopyMemory( (PVOID) &mxUserWorldToDevice(), pmx, sizeof( MATRIX ));

            return;
        }
    }
    else
    {
        if (bWorldToPageIdentity())
        {
        // World transform has changed to identity.

            pmx->efM11 = efM11PtoD();
            pmx->efM22 = efM22PtoD();
            pmx->efM12.vSetToZero();
            pmx->efM21.vSetToZero();
            pmx->efDx  = efDxPtoD();
            pmx->efDy  = efDyPtoD();

            efDxPtoD().bEfToL(pmx->fxDx);
            efDyPtoD().bEfToL(pmx->fxDy);

            if (bPageToDeviceIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY |
                               XFORM_NO_TRANSLATION;
            else if (bPageToDeviceScaleIdentity())
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
            else
                pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;

            flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                          WORLD_XFORM_CHANGED);

            RtlCopyMemory( (PVOID) &mxUserWorldToDevice(), pmx, sizeof( MATRIX ));
            return;
        }
    }

// Multiply the world to page and page to device xform together.

    PMATRIX pmxWtoP = &mxWorldToPage();

    if (bPageToDeviceScaleIdentity())
    {
        RtlCopyMemory(pmx, pmxWtoP, offsetof(MATRIX, flAccel));
        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();
        pmx->efDx.vTimes16();
        pmx->efDy.vTimes16();
    }
    else
    {
        pmx->efM11.eqMul(pmxWtoP->efM11,efM11PtoD());
        pmx->efM21.eqMul(pmxWtoP->efM21,efM11PtoD());
        pmx->efM12.eqMul(pmxWtoP->efM12,efM22PtoD());
        pmx->efM22.eqMul(pmxWtoP->efM22,efM22PtoD());

        pmx->efDx.eqMul(pmxWtoP->efDx,efM11PtoD());
        pmx->efDy.eqMul(pmxWtoP->efDy,efM22PtoD());
    }

    pmx->efDx += efrDxPtoD();
    pmx->efDx.bEfToL(pmx->fxDx);

    pmx->efDy += efrDyPtoD();
    pmx->efDy.bEfToL(pmx->fxDy);

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
        if (pmx->efM11.bIs16() && pmx->efM22.bIs16())
            pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE | XFORM_UNITY;
        else
            pmx->flAccel = XFORM_FORMAT_LTOFX | XFORM_SCALE;
    }
    else
    {
        pmx->flAccel = XFORM_FORMAT_LTOFX;
    }

    if ((pmx->fxDx == 0) && (pmx->fxDy == 0))
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    flClr_flXform(PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                 WORLD_XFORM_CHANGED);

    RtlCopyMemory((PVOID)&mxUserWorldToDevice(),pmx,sizeof(MATRIX));

}


/******************************Private*Routine*****************************\
* bWordXformIdentity
*
* See is a world transform matrix is identity.
*
* History:
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  26-Dec-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bWorldXformIdentity(CONST XFORML *pxf)
{
    return((pxf->eM11 == IEEE_1_0F) && (pxf->eM12 == IEEE_0_0F) &&
           (pxf->eM21 == IEEE_0_0F) && (pxf->eM22 == IEEE_1_0F) &&
           (pxf->eDx  == IEEE_0_0F) && (pxf->eDy  == IEEE_0_0F));
}


/******************************Public*Routine******************************\
* NtGdiModifyWorldTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiModifyWorldTransform(
    HDC     hdc,
    LPXFORM pxf,
    DWORD   iXform
    )
{
    XFORMPRINT(1,"GreModifyWorldTransform - iXform = %ld\n",iXform);

    ASSERTGDI(sizeof(XFORM) == sizeof(XFORML),"sizeof(XFORM) != sizeof(XFORML)\n");

    BOOL bRet = FALSE;

    DCOBJ dcox(hdc);

    if (dcox.bValid())
    {
        XFORML xf;

        if (pxf)
        {
            bRet = ProbeAndConvertXFORM((XFORML *)pxf, &xf);
        }
        else
        {
            // must be identity to allow pxf == NULL

            bRet = (iXform == MWT_IDENTITY);
        }

        if (bRet)
        {
            bRet = dcox.bModifyWorldTransform(&xf,iXform);
        }
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* XDCOBJ::bModifyWorldTransform()
*
* History:
*  07-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XDCOBJ::bModifyWorldTransform(
    CONST XFORML *pxf,
    ULONG         iMode)
{
    BOOL bRet = FALSE;
    MATRIX  mx;

    switch (iMode)
    {
    case MWT_SET:
        if (!bWorldXformIdentity(pxf))
        {
            vConvertXformToMatrix(pxf, &mx);

            if (bWorldMatrixInRange(&mx))       // check if the new world xform is
            {                                   // within the min, max range.
                RtlCopyMemory(&pdc->mxWorldToPage(), &mx, offsetof(MATRIX, flAccel));
                RtlCopyMemory(&pdc->mxUserWorldToPage(), &mx, offsetof(MATRIX, flAccel));
                pdc->vClrWorldXformIdentity();
                bRet = TRUE;
            }
            break;
        }
    //MWT_IDENTITY must follow MWT_SET.  This will fall through if it is identity

    case MWT_IDENTITY:
        if (!pdc->bWorldToPageIdentity())
        {
            RtlCopyMemory(&pdc->mxWorldToPage(), &gmxIdentity_LToL, offsetof(MATRIX, flAccel));
            RtlCopyMemory(&pdc->mxUserWorldToPage(), &gmxIdentity_LToL, offsetof(MATRIX, flAccel));
            pdc->vSetWorldXformIdentity();
        }
        bRet = TRUE;
        break;

    case MWT_LEFTMULTIPLY:
    case MWT_RIGHTMULTIPLY:
        vConvertXformToMatrix(pxf,&mx);

        if (!pdc->bWorldToPageIdentity())
        {
            EXFORMOBJ xoWtoP(*this,XFORM_WORLD_TO_PAGE);

            if (!xoWtoP.bMultToWorld(&mx, iMode))
                break;
        }

        if (!bWorldMatrixInRange(&mx))      // check if the new world xform is
            break;                          // within the min, max range.

        RtlCopyMemory( &pdc->mxWorldToPage(), &mx, offsetof(MATRIX, flAccel));
        RtlCopyMemory( &pdc->mxUserWorldToPage(), &mx, offsetof(MATRIX, flAccel));

    // Check if the resultant matrix is identity.

        if (memcmp(&mx, &gmxIdentity_LToL, offsetof(MATRIX, flAccel)))
        {
            pdc->vClrWorldXformIdentity();
        }
        else
        {
            pdc->vSetWorldXformIdentity();
        }
        bRet = TRUE;
        break;

    default:
        WARNING("invalid mode passed to GreModifyWorldTransform\n");
        break;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreCombineTransform
*
*  Concatenate two transforms together by (*pxfSrc1) x (*pxfSrc2).
*
* History:
*
*  6-Aug-1992 -by- Gerrit van Wingerden [gerritv]
* Modified for client side use.
*
*  24-Jan-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL GreCombineTransform(
    XFORML *pxfDst,
    XFORML *pxfSrc1,
    XFORML *pxfSrc2)
{
    MATRIX  mx1,mx2,mxDst;

    vConvertXformToMatrix(pxfSrc1, &mx1);
    vConvertXformToMatrix(pxfSrc2, &mx2);

    EXFORMOBJ xoDst(mxDst);

    if (!xoDst.bMultiply(&mx1, &mx2))
        return(FALSE);

    xoDst.flAccel(XFORM_FORMAT_LTOL);

    xoDst.vGetCoefficient(pxfDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* NtGdiUpdateTransform
*
*     This routine flushes the current transform
*
* History:
* 7/2/98 -by- Lingyun Wang [lingyunw]
\**************************************************************************/

BOOL NtGdiUpdateTransform(HDC hdc)
{
    BOOL bRet = TRUE;

    // update the transforms
    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
       dco.pdc->vUpdateWtoDXform();

       dco.vUnlock();
    }
    else
    {
        bRet = FALSE;
    }

    return (bRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ylateddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xlateddi.cxx
*
* This provides the interface for device drivers to call functions
* for xlate objects.
*
* Created: 26-Nov-1990 16:40:24
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* XLATEOBJ_piVector
*
* Returns the translation vector if one exists.
*
* History:
*  03-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PULONG XLATEOBJ_piVector(XLATEOBJ *pxlo)
{
    //
    // This is really strange to have a call back, but the theory was that
    // it could be lazily computed and some drivers would choose to compute
    // it themselves (maybe with hardware help).  Anyhow we know of no driver
    // or hardware that would benefit from this so we just compute it up
    // front every time anyhow.  Drivers are written to check for NULL first
    // and call this routine if it's NULL.
    //

    return(pxlo->pulXlate);
}

/******************************Public*Routine******************************\
* XLATEOBJ_cGetPalette
*
* Used to retrieve information about the palettes used in the blt.
*
* History:
*  03-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XLATEOBJ_cGetPalette(
XLATEOBJ *pxlo,
ULONG iPal,
ULONG cPal,
PULONG ppal)
{
    ULONG ulRet = 0;            // Assume failure

    ASSERTGDI((iPal == XO_SRCPALETTE)   ||
              (iPal == XO_DESTPALETTE)  ||
              (iPal == XO_SRCBITFIELDS) ||
              (iPal == XO_DESTBITFIELDS),
        "ERROR XLATEOBJ_cGetPalette passed undefined iPal");

    if (pxlo != NULL)
    {
        XLATE *pxl = (XLATE *) pxlo;

        if ((iPal == XO_SRCBITFIELDS) || (iPal == XO_DESTBITFIELDS))
        {
            XEPALOBJ pal((iPal == XO_SRCBITFIELDS) ? pxl->ppalSrc : pxl->ppalDst);

            if ((pal.bValid())        &&        // Must be valid
                (pal.cEntries() == 0) &&        // Must be RGB
                (cPal == 3))                    // Must have room for 3 entries
            {
                ulRet = 3;

                *(ppal)     = pal.flRed();
                *(ppal + 1) = pal.flGre();
                *(ppal + 2) = pal.flBlu();
            }
            else
            {
                WARNING("XLATEOBJ_cGetPalette failed - not bitfields, or cPal != 3");
            }
        }
        else
        {
            XEPALOBJ pal((iPal == XO_SRCPALETTE) ? pxl->ppalSrc : pxl->ppalDst);

            if (pal.bValid())
            {
                ulRet = pal.ulGetEntries(0, cPal, (LPPALETTEENTRY) ppal, TRUE);
            }
        }
    }
    else
    {
        WARNING("XLATEOBJ_cGetPalette failed - xlate invalid or identiy, no palette informinformation\n");
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* XLATEOBJ_hGetColorTransform
*
* returns color transform handle.
*
* History:
*  03-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

HANDLE
XLATEOBJ_hGetColorTransform(XLATEOBJ *pxlo)
{
    XLATE *pxl = (XLATE *) pxlo;

    ICMAPI(("XLATEOBJ_hGetColorTransform()\n"));

    //
    // Since our global identity xlate is invalid we need to check for
    // this case since drivers can't tell.
    //
    if (pxl == NULL)
    {
        WARNING("XLATEOBJ_hGetColorTransform() XLATEOBJ is NULL\n");
        return(NULL);
    }

    //
    // if ICM is not enabled for this XLATEOBJ. Or if ICM is done by host,
    // Color transform handle is for host ICM it is no meanings for device
    // driver. then just return NULL.
    //
    if (IS_ICM_DEVICE(pxl->lIcmMode))
    {
        if (pxl->hcmXform)
        {
            COLORTRANSFORMOBJ CXFormObj(pxl->hcmXform);

            if (CXFormObj.bValid())
            {
                return(CXFormObj.hGetDeviceColorTransform());
            }

            ICMMSG(("XLATEOBJ_hGetColorTransform() COLORTRANSFORMREF is invalid\n"));
        }
        else
        {
            ICMMSG(("XLATEOBJ_hGetColorTransform() Ident. color transform\n"));
        }
    }
    else
    {
        ICMMSG(("XLATEOBJ_hGetColorTransform() ICM on device is not enabled\n"));
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\wndobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: wndobj.cxx
*
* WNDOBJ support routines.
*
* Created: 22-Sep-1993 17:42:20
* Author: Wendy Wu [wendywu]
*         Hock San Lee [hockl]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if DBG

long glDebugLevel = 0;
#define DBGINFO(str)  if (glDebugLevel >= 2) DbgPrint("GLSRVL: " str)
#define DBGENTRY(str) if (glDebugLevel >= 8) DbgPrint("GLSRVL: " str)

#else

#define DBGINFO(str)
#define DBGENTRY(str)

#endif


// Global tracking object (TRACKOBJ) pointer.
// If this is non-null, we are tracking some WNDOBJs in the system.

PTRACKOBJ gpto = (PTRACKOBJ)NULL;

// Global that indicates whether to notify driver with the new WNDOBJ
// states following a WNDOBJ creation.  User has not changed the window
// states but this is required to initialize the driver.  The update is
// done in the parent gdi functions (e.g. SetPixelFormat) that allow
// the DDI to create a WNDOBJ.

BOOL gbWndobjUpdate;

// The following is a global uniqueness that gets bumped up anytime USER
// changes anyone's VisRgn:

ULONG giVisRgnUniqueness = 0;

// Maximum region rectangle

RECTL grclMax = {
    MIN_REGION_COORD,
    MIN_REGION_COORD,
    MAX_REGION_COORD,
    MAX_REGION_COORD
};

// Here is a brief description of the semaphore usage.
//
// There are 3 semaphores that this module uses/references.
//
// 1. User critical section.
//    The user critical section ensures that no window moves when a new
//    update occurs.  It is only relevent to the display DCs to ensure a
//    consistent window client regions state.  For example, GreSetClientRgn
//    assumes that no window can move until GreClientRgnUpdated is called.
//
// 2. Display devlock and DC/surface locks.
//    The display devlock must be entered when a WNDOBJ is being used or
//    updated.  This prevents a WNDOBJ from being modified when it is
//    being used in the DDI.  The display devlock applies to the display
//    DCs only.  For memory and printer DCs, the surface is locked when
//    a WNDOBJ is used.  This is the current GDI design to prevent a
//    different thread from deleting a surface while it is being used.
//    Note that this precludes any multi-thread access to the printer or
//    memory DCs.
//
// 3. Window object semaphore.
//    The window object semaphore is used to protect access to the window
//    object data structures.  Note that a semaphore is used instead of
//    a mutex here to allow for process cleanup of the semaphore.  The
//    process cleanup is done in the user process cleanup code.
//
// The above 3 semaphores must be entered in the given order.  Otherwise,
// a deadlock may occur.


/******************************Member*Function*****************************\
* VOID TRACKOBJ::vUpdateDrvDelta
*
* Update driver function for delta regions.  fl must have
* WOC_RGN_CLIENT_DELTA or WOC_RGN_SURFACE_DELTA set.
* Note that if the delta is empty, we do not need to call the driver.
* The compiler does not allow this function to be inline because or forward
* reference.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID TRACKOBJ::vUpdateDrvDelta(EWNDOBJ *pwo, FLONG fl)
{
    ASSERTGDI(fl & (WOC_RGN_CLIENT_DELTA|WOC_RGN_SURFACE_DELTA),
        "TRACKOBJ::vUpdateDrvDelta, Bad flags\n");

    if (!pwo->erclExclude().bEmpty())
        (*pfn)((WNDOBJ *)pwo, fl);
}

/******************************Public*Function*****************************\
* EngCreateWnd
*
* Create a WNDOBJ from a HWND.  This function should only be called
* when the calling thread has the usercrit and devlock in that order.
* GDI will ensure that the thread acquires both locks before calling the
* DDIs that allow EngCreateWnd to be called.  The driver should only call
* this function from those DDI entry points.  Currently, GreSetPixelFormat
* acquires both locks before calling DrvSetPixelFormat; GreExtEscape for
* WNDOBJ_SETUP escape also acquires both locks before calling DrvEscape.
*
* This function allows tracking multiple surfaces (screen, bitmaps and
* printers).  For each display surface being tracked, it further allows
* multiple TRACKOBJs to be created for each driver function.  The TRACKOBJs
* on a device surface are identified by unique pfn function pointers.
* This allows a live video driver and an OpenGL driver to track windows
* independently of each other.  The only restriction is that a window on
* a surface cannot be tracked by more than one TRACKOBJs on that surface.
*
* A WNDOBJ has an associated pixel format.  Once a WNDOBJ is created with
* a given pixel format, it cannot be set to a different pixel format.  If
* there is no pixel format associated with a WNDOBJ, e.g. live video,
* it should be set to zero.
*
* The WNDOBJ created in this function does not have the current states
* until the first driver update function is called.  However, the driver
* may immediately associate its own data with the WNDOBJ by calling the
* WNDOBJ_vSetConsumer function.
*
* Once a WNDOBJ is created, it cannot be deleted by the driver.  Gdi will
* will notifiy the driver of the deletion when the window goes away or
* when the associated surface is deleted.
*
* The given hwnd identifies the user window to be tracked.  It must be 0
* if the surface is a printer or memory bitmap.
*
* Returns the new WNDOBJ pointer if a WNDOBJ is created; 0 if an error
* occurs; -1 if hwnd is already being tracked by this driver function.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  27-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

// This is a private clean up class for this function.

class WO_CLEANUP
{
private:
    BOOL      bKeep;            // TRUE if resouces should not be freed
    PTRACKOBJ pto;
    PEWNDOBJ  pwoSurf;
    PEWNDOBJ  pwoClient;
    PREGION   prgnSurf;
    PREGION   prgnClient;
    HSEMAPHORE hsemClient;

public:
    WO_CLEANUP()
    {
        bKeep      = FALSE;
        pto        = (PTRACKOBJ)NULL;
        pwoSurf    = (PEWNDOBJ)NULL;
        pwoClient  = (PEWNDOBJ)NULL;
        prgnSurf   = (PREGION)NULL;
        prgnClient = (PREGION)NULL;
        hsemClient = NULL;
    }

    VOID vSetTrackobj(PTRACKOBJ pto1)           { pto        = pto1; }
    VOID vSetSurfWndobj(PEWNDOBJ pwo)           { pwoSurf    = pwo; }
    VOID vSetClientWndobj(PEWNDOBJ pwo)         { pwoClient  = pwo; }
    VOID vSetSurfRegion(RGNMEMOBJ &rmo)         { prgnSurf   = rmo.prgnGet();}
    VOID vSetClientRegion(RGNMEMOBJ &rmo)       { prgnClient = rmo.prgnGet();}
    VOID vSetClientSem(HSEMAPHORE hsem)         { hsemClient = hsem; }
    PTRACKOBJ ptoGet()                          { return(pto); }

    VOID vKeepAll()                             { bKeep = TRUE; }

   ~WO_CLEANUP()
    {
        if (bKeep)      return;

        DBGINFO("EngCreateWnd: no WNDOBJ created\n");
        if (pto)        { pto->ident = 0; VFREEMEM(pto); }
        if (pwoSurf)    { pwoSurf->ident = 0; VFREEMEM(pwoSurf); }
        if (pwoClient)  { pwoClient->ident = 0; VFREEMEM(pwoClient); }
        if (prgnSurf)   prgnSurf->vDeleteREGION();
        if (prgnClient) prgnClient->vDeleteREGION();
        if (hsemClient) GreDeleteSemaphore(hsemClient);
    }
};

WNDOBJ * APIENTRY EngCreateWnd
(
    SURFOBJ          *pso,
    HWND             hwnd,
    WNDOBJCHANGEPROC pfn,
    FLONG            fl,
    int              iPixelFormat
)
{
    WO_CLEANUP cleanup;         // prepare for clean up
    PEWNDOBJ   pwoClient;
    PEWNDOBJ   pwoSurf;
    PEWNDOBJ   pwo;
    PTRACKOBJ  pto;
    PEWNDOBJ   pwoGenericSibling = NULL;

    DBGENTRY("EngCreateWnd\n");

    PSURFACE   pSurf = SURFOBJ_TO_SURFACE(pso);

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    if (!UserIsUserCritSecIn())
    {
        RIP("Driver may call EngCreateWnd only from WNDOBJ_SETUP escape\n"
            "(or from OpenGL MCD or ICD escapes)");
        return(NULL);
    }

    CHECKUSERCRITIN;
    if (hwnd)
    {
        CHECKDEVLOCKIN2(pSurf);
    }

// Validate flags.

#if ((WO_VALID_FLAGS & WO_INTERNAL_VALID_FLAGS) != 0)
#error "bad WO_INTERNAL_VALID_FLAGS"
#endif

    if ((fl & ~WO_VALID_FLAGS) != 0)
        return((WNDOBJ *)0);

// If this is the first time we need to track window object, create the
// semaphore for synchronization.  We use a semaphore instead of mutex
// so that we can perform process cleanup of the semaphore.

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// If the window is already being tracked by the same TRACKOBJ and the
// pixel format is the same, return -1.  If the window is being tracked
// by a different TRACKOBJ, return 0.  There may be multiple TRACKOBJs
// on the same device surface but a window can be tracked by only one
// TRACKOBJ.  In addition, pixel format in a window cannot be modified
// once it is set.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            if (pwo->hwnd == hwnd)
            {
                KdPrint(("Failing EngCreateWnd -- hwnd already has a WNDOBJ\n"));

                if (pto->pfn == pfn && pwo->ipfd == iPixelFormat)
                    return((WNDOBJ *)-1);   // return -1
                else
                    return((WNDOBJ *)0);    // tracked by a diff TRACKOBJ
            }
        }
    }

// If this is the first time we track a device surface for this driver
// function, we have to allocate space for the TRACKOBJ.  We determine
// if this is a new TRACKOBJ by comparing the pfn with those of the
// existing ones.  This allows the live video, installable opengl, and
// generic opengl windows to be tracked separately.

    for (pto = gpto; pto; pto = pto->ptoNext)
        if (pto->pSurface == pSurf && pto->pfn == pfn)
                break;
    if (!pto)
    {
// Allocate a new TRACKOBJ.

        if (!(pto = (PTRACKOBJ) PALLOCMEM(sizeof(TRACKOBJ), 'dnwG')))
            return((WNDOBJ *)0);
        cleanup.vSetTrackobj(pto);

        pto->ident   = TRACKOBJ_IDENTIFIER;
        // pto->ptoNext
        pto->pwoSurf  = (PEWNDOBJ)NULL;
        pto->pwo      = (PEWNDOBJ)NULL;
        pto->pSurface = pSurf;
        pto->pfn      = pfn;
        pto->fl       = fl;
        pto->erclSurf.left   = 0;
        pto->erclSurf.top    = 0;
        pto->erclSurf.right  = pSurf->sizl().cx;
        pto->erclSurf.bottom = pSurf->sizl().cy;

// Create a surface WNDOBJ for the TRACKOBJ if it requests WO_RGN_SURFACE or
// WO_RGN_SURFACE_DELTA.

        if (fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))
        {
            if (!(pwoSurf = (PEWNDOBJ) PALLOCMEM(sizeof(EWNDOBJ), 'dnwG')))
                return((WNDOBJ *)0);
            cleanup.vSetSurfWndobj(pwoSurf);

// Create a surface client region that is the entire surface.

            RGNMEMOBJ rmoSurf((BOOL)FALSE);
            if (!rmoSurf.bValid())
                return((WNDOBJ *)0);
            cleanup.vSetSurfRegion(rmoSurf);
            rmoSurf.vSet((RECTL *)&pto->erclSurf);

// Initialize the surface WNDOBJ.

            pwoSurf->pto        = pto;                  // pto used by vSetClip
            rmoSurf.prgnGet()->vStamp();                // init iUniq
            pwoSurf->vSetClip(rmoSurf.prgnGet(), pto->erclSurf);
            pwoSurf->pvConsumer = 0;
            pwoSurf->psoOwner   = pSurf->pSurfobj();
            pwoSurf->ident      = EWNDOBJ_IDENTIFIER;
            pwoSurf->pwoNext    = (PEWNDOBJ)NULL;       // no next pointer
            pwoSurf->hwnd       = 0;                    // no hwnd
            pwoSurf->fl         = fl | WO_SURFACE;
            pwoSurf->ipfd       = 0;                    // no pixel format

// Add WNDOBJ to the TRACKOBJ.

            pto->pwoSurf = pwoSurf;
        }
    }

// The tracking flags must be consistent.

    if ((pto->fl & ~WO_INTERNAL_VALID_FLAGS) != fl)
        return((WNDOBJ *)0);

// Allocate a new client WNDOBJ.

    if (!(pwoClient = (PEWNDOBJ) PALLOCMEM(sizeof(EWNDOBJ), 'dnwG')))
        return((WNDOBJ *)0);
    cleanup.vSetClientWndobj(pwoClient);

// Create an empty window client region.  The client region is still being
// created.  The driver window region update will be done in the parent gdi
// function.

    ERECTL    erclClient(0,0,0,0);
    RGNMEMOBJ rmoClient((BOOL)FALSE);
    if (!rmoClient.bValid())
        return((WNDOBJ *)0);
    cleanup.vSetClientRegion(rmoClient);
    rmoClient.vSet((RECTL *)&erclClient);

// Initialize the per-WNDOBJ semaphore once per window.

    {
        pwoClient->hsem = GreCreateSemaphore();
        if (pwoClient->hsem == NULL)
        {
            return NULL;
        }
        cleanup.vSetClientSem(pwoClient->hsem);
        fl |= WO_HSEM_OWNER;
    }

// Initialize the WNDOBJ.

    pwoClient->pto        = pto;        // pto used by vSetClip
    rmoClient.prgnGet()->vStamp();      // init iUniq
    pwoClient->vSetClip(rmoClient.prgnGet(), erclClient);
    pwoClient->pvConsumer = 0;          // to be set by the driver
    pwoClient->psoOwner   = pSurf->pSurfobj();
    pwoClient->ident      = EWNDOBJ_IDENTIFIER;
    pwoClient->hwnd       = hwnd;
    pwoClient->fl         = fl;
    pwoClient->ipfd       = iPixelFormat;

// Add WNDOBJ to TRACKOBJ.

    pwoClient->pwoNext = pto->pwo;
    pto->pwo = pwoClient;

    ASSERTGDI(offsetof(EWNDOBJ, pvConsumer) == offsetof(WNDOBJ, pvConsumer),
              "EngCreateWnd: rclClient wrong offset\n");

// Add TRACKOBJ to global linked list.

    if (cleanup.ptoGet())
    {
        pto->ptoNext = gpto;
        gpto = pto;
    }

// If hwnd is given, attach the WNDOBJ to the window in user.
// Otherwise, it is a printer surface or memory bitmap.  Attach it to
// the surface.

    if (hwnd)
    {
        UserAssociateHwnd(hwnd, (PVOID) pwoClient);
    }
    else
    {
// Only one WNDOBJ per memory bitmap or printer surface.

        ASSERTGDI(!pSurf->pwo(),
                  "EngCreateWnd: multiple WNDOBJs unexpected in memory DCs\n");
        pSurf->pwo(pwoClient);
    }

// Inform the parent gdi function that it needs to update the new WNDOBJ
// in the driver.

    pto->fl       |= WO_NEW_WNDOBJ;
    pwoClient->fl |= WO_NEW_WNDOBJ;
    gbWndobjUpdate = TRUE;

// Don't free the PDEV until the WNDOBJ is destroyed.

    PDEVOBJ po(pSurf->hdev());
    po.vReferencePdev();

// Everything is golden.  Keep the created objects and return the new WNDOBJ.

    cleanup.vKeepAll();
    return((WNDOBJ *)pwoClient);
}

/******************************Public*Function*****************************\
* GreDeleteWnd
*
* This function is called when the window that is being tracked is deleted
* in user, or when the device surface (printer or memory bitmap) that
* is begin tracked is deleted.  It deletes the WNDOBJ and notifies the
* driver that the WNDOBJ is going away.
*
* This function does not update the driver with the new client regions
* following the WNDOBJ deletion.  It assumes that if the deletion is a
* window, user will update or has updated the client regions; and if the
* deleteion is a printer or memory bitmap, the TRACKOBJ is going away
* and therefore no need to notify driver.
*
* If the deletion is a window, the calling thread must have the usercrit.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreDeleteWnd(PVOID _pwoDelete)
{
    PEWNDOBJ  pwoDelete = (PEWNDOBJ)_pwoDelete;
    PEWNDOBJ  pwo;
    PTRACKOBJ pto;

    DBGENTRY("GreDeleteWnd\n");

// Validate pwoDelete.

    if (!pwoDelete->bValid())
    {
        ASSERTGDI(FALSE, "GreDeleteWnd: Invalid pwoDelete\n");
        return;
    }

// If hwnd is non 0, the user calling thread must hold the usercrit.
// This ensures that no one is updating the hwnd.

    if (pwoDelete->hwnd)
    {
        CHECKUSERCRITIN;
        CHECKDEVLOCKIN2(pwoDelete->pto->pSurface);
    }

    pto = pwoDelete->pto;


// Acquire the device lock.  Note that this may be different from the
// device lock that USER is holding if the PDEV is marked as 'deleted':

    PDEVOBJ po(pto->pSurface->hdev());

    {
        DEVLOCKOBJ dlo(po);

// Enter the semaphore for window object.

        ASSERTGDI(ghsemWndobj, "GreDeleteWnd: bad ghsemWndobj\n");
        SEMOBJ so(ghsemWndobj);

// Notify driver that the WNDOBJ is going away.
// Hold the WNDOBJ stable while doing so by grabbing the per-WNDOBJ semaphore.

        {
            SEMOBJ soClient(pwoDelete->hsem);

            pto->vUpdateDrv(pwoDelete, WOC_DELETE);
        }

// Unlink pwoDelete from chain.

        if (pto->pwo == pwoDelete)
            pto->pwo = pwoDelete->pwoNext;
        else
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                if (pwo->pwoNext == pwoDelete)
                {
                    pwo->pwoNext = pwoDelete->pwoNext;
                    break;
                }
            }

// Free pwoDelete.

        pwoDelete->bDelete();       // delete RGNOBJ
        pwoDelete->ident = 0;
        VFREEMEM(pwoDelete);        // free memory

// Delete the tracking object if there are no more windows to track.

        if (pto->pwo == (PEWNDOBJ)NULL)
        {
// Unlink pto from chain.

            if (pto == gpto)
                gpto = pto->ptoNext;
            else
                for (PTRACKOBJ ptoTmp = gpto; ptoTmp; ptoTmp = ptoTmp->ptoNext)
                {
                    if (ptoTmp->ptoNext == pto)
                    {
                        ptoTmp->ptoNext = pto->ptoNext;
                        break;
                    }
                }

// Delete the pwoSurf if it exists.

            if (pto->pwoSurf)
            {
                ASSERTGDI(pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA),
                    "GreDeleteWnd: WO_RGN_SURFACE or WO_RGN_SURFACE_DELTA not set\n");

                pto->pwoSurf->bDelete();    // delete RGNOBJ
                pto->pwoSurf->ident = 0;
                VFREEMEM(pto->pwoSurf);     // free memory
            }

            pto->ident = 0;
            VFREEMEM(pto);
        }

// Inform the sprite code that a WNDOBJ has been deleted.

        vSpWndobjChange(po.hdev(), NULL);
    }

// Remove the reference to the PDEV.

    po.vUnreferencePdev();
}

/******************************Public*Function*****************************\
* EngDeleteWnd
*
* Driver-callable entry point to delete a WNDOBJ.
*
\**************************************************************************/

VOID EngDeleteWnd(WNDOBJ* _pwoDelete)
{
    EWNDOBJ* pwoDelete = (EWNDOBJ*)_pwoDelete;

    if (!UserIsUserCritSecIn())
    {
        RIP("Driver may call EngDeleteWnd only from WNDOBJ_SETUP escape\n"
            "(or from OpenGL MCD or ICD escapes)");
    }
    else
    {
// Tell USER to disassociate this WNDOBJ from its window:

        if (pwoDelete->hwnd)
        {
            UserAssociateHwnd(pwoDelete->hwnd, NULL);
        }

        GreDeleteWnd(pwoDelete);
    }
}

/******************************Public*Routine******************************\
* VOID vChangeWndObjs
*
* Transfers ownership of WNDOBJs between PDEVs.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vChangeWndObjs(
SURFACE* pSurfaceOld,
HDEV     hdevOld,
SURFACE* pSurfaceNew,
HDEV     hdevNew)
{
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;
    EWNDOBJ*    pwoNext;

    CHECKUSERCRITIN;

    SEMOBJ so(ghsemWndobj);

// Note that we shouldn't use pSurfaceOld->hdev() or pSurfaceNew->hdev()
// becuase they haven't been updated yet:

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

// Changing drivers.  Delete all WNDOBJs belonging to the old
// surface:

    for (pto = gpto; pto != NULL; pto = pto->ptoNext)
    {
        if (pto->pSurface == pSurfaceOld)
        {
// For every WNDOBJ belonging to this TRACKOBJ, transfer
// ownership to the new PDEV:

            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurfaceOld->pSurfobj(),
                    "Old psoOwner mismatch");

                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
            }
        }
        else if (pto->pSurface == pSurfaceNew)
        {
            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurfaceNew->pSurfobj(),
                    "New psoOwner mismatch");

                poOld.vReferencePdev();
                poNew.vUnreferencePdev();
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vTransferWndObjs
*
* Transfers ownership of WNDOBJs from PDEV to other PDEV.
*
* History:
*  2-16-1999 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID vTransferWndObjs(
SURFACE* pSurface,
HDEV     hdevOld,
HDEV     hdevNew)
{
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;
    EWNDOBJ*    pwoNext;

    CHECKUSERCRITIN;

    SEMOBJ so(ghsemWndobj);

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

    for (pto = gpto; pto != NULL; pto = pto->ptoNext)
    {
        if (pto->pSurface == pSurface)
        {
            for (pwo = pto->pwo; pwo != NULL; pwo = pwo->pwoNext)
            {
                ASSERTGDI(pwo->psoOwner == pSurface->pSurfobj(),
                    "New psoOwner mismatch");

                KdPrint(("Transfer wndobj %x - hdevNew %x hdevOld %x \n",
                          pwo,hdevNew,hdevOld));

                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
            }
        }
    }
}

/******************************Public*Function*****************************\
* vForceClientRgnUpdate
*
* This function is called by gdi to force an update of the new WNDOBJ
* that is just created.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.  Currently, it is called from
* GreSetPixelFormat and GreExtEscape for WNDOBJ_SETUP escape after
* they detected that the driver has created a new WNDOBJ.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vForceClientRgnUpdate()
{
    PTRACKOBJ pto;
    PEWNDOBJ  pwo = (PEWNDOBJ)NULL;

    DBGENTRY("vForceClientRgnUpdate\n");

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Update the new WNDOBJ that was just created.
// User has not changed the client regions because we are still in the
// user critical section.  We are updating the client regions ourselves.

    {
// Enter the semphore for window object.

        SEMOBJ so(ghsemWndobj);

// Find the newly created WNDOBJ.

        for (pto = gpto; pto; pto = pto->ptoNext)
        {
            if (!(pto->fl & WO_NEW_WNDOBJ))
                continue;

            pto->fl &= ~WO_NEW_WNDOBJ;
            pto->fl |= WO_NOTIFIED;

            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                if (!(pwo->fl & WO_NEW_WNDOBJ))
                    continue;

                pwo->fl &= ~WO_NEW_WNDOBJ;
                pwo->fl |= WO_NOTIFIED;
                break;          // found it
            }
            break;              // found it
        }

        if (!pwo)
        {
            ASSERTGDI(FALSE, "vForceClientRgnUpdate: no new WNDOBJ found\n");
            return;
        }

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.  We do the check here because we don't have any pSurf
// information earlier.

        if (pwo->hwnd)
        {
            CHECKDEVLOCKIN2(pto->pSurface);
        }

// If hwnd exists, get the client region from user.

        HRGN   hrgnClient;
        ERECTL erclClient;

        if (pwo->hwnd)
        {
            hrgnClient = UserGetClientRgn(pwo->hwnd,
                                          (LPRECT)&erclClient,
                                          pwo->fl & WO_RGN_WINDOW);
        }
        else
        {
// If hwnd does not exist, this is a memory bitmap or printer surface.
// The client region is the whole surface.

            erclClient = pto->erclSurf;
            hrgnClient = GreCreateRectRgnIndirect((LPRECT)&erclClient);
        }

        if (!hrgnClient)
        {
            ASSERTGDI(FALSE, "vForceClientRgnUpdate: hwnd has no rgn\n");
            return;
        }

// Update client region in the WNDOBJ.

        GreSetRegionOwner(hrgnClient, OBJECT_OWNER_PUBLIC);
        RGNOBJAPI roClient(hrgnClient,FALSE);
        ASSERTGDI(roClient.bValid(), "vForceClientRgnUpdate: invalid hrgnClient\n");

#ifdef OPENGL_MM

// Under Multi-mon we need to adjust the client region and
// client rectangle by the offset of the surface.
// Additionally we need to clip the client region to the
// surface of the TRACKOBJ.

        if (!(pwo->fl & WO_RGN_DESKTOP_COORD))
        {
            PDEVOBJ pdo(pwo->pto->pSurface->hdev());

            if (pdo.bValid())
            {
                if (pdo.bPrimary(pwo->pto->pSurface))
                {
                    POINTL ptlOrigin;

                    ptlOrigin.x = -pdo.pptlOrigin()->x;
                    ptlOrigin.y = -pdo.pptlOrigin()->y;

                    if ((ptlOrigin.x != 0) || (ptlOrigin.y != 0))
                    {
// offset the region and window rect if necessary

                        roClient.bOffset(&ptlOrigin);
                        erclClient += ptlOrigin;      /* this offsets by ptl */
                    }
                }
            }

            RGNMEMOBJTMP rmoTmp;
            RGNMEMOBJTMP rmoRcl;

            if (rmoTmp.bValid() && rmoRcl.bValid())
            {
// this clips the client region to the pto surface

                rmoRcl.vSet((RECTL *) &pto->erclSurf);
                rmoTmp.bCopy(roClient);
                roClient.iCombine(rmoTmp, rmoRcl, RGN_AND);
                if (rmoTmp.iCombine(roClient,rmoRcl,RGN_AND) != ERROR)
                {
                    roClient.bSwap(&rmoTmp);
                }
            }
        }

#endif // OPENGL_MM

// We're going to modify the WNDOBJ now.  Grab the per-WNDOBJ semaphore to
// keep it stable.  Don't release until after the driver is called.

        SEMOBJ soClient(pwo->hsem);

        roClient.bSwap(pwo);
        pwo->prgn->vStamp();                 // init iUniq
        pwo->vSetClip(pwo->prgn, erclClient);
        roClient.bDeleteRGNOBJAPI();         // delete handle too

// Call driver with the new WNDOBJ.

        if (pto->fl & WO_RGN_CLIENT_DELTA)
            pto->vUpdateDrvDelta(pwo, WOC_RGN_CLIENT_DELTA);
        if (pto->fl & WO_RGN_CLIENT)
            pto->vUpdateDrv(pwo, WOC_RGN_CLIENT);

// Let the sprite code know that there's a new WNDOBJ, now completely
// formed.        

        vSpWndobjChange(pto->pSurface->hdev(), pwo);
    }

// Update the remaining window client regions.

    GreClientRgnUpdated(GCR_WNDOBJEXISTS);
}

/******************************Member*Function*****************************\
* GreWindowInsteadOfClient
*
* Returns TRUE if the window area instead of the client area should be
* used for the WNDOBJ regions.
*
\**************************************************************************/

BOOL GreWindowInsteadOfClient(PVOID _pwo)
{
    PEWNDOBJ pwo = (PEWNDOBJ) _pwo;

    return(pwo->fl & WO_RGN_WINDOW);
}

/******************************Member*Function*****************************\
* GreClientRgnUpdated
*
* User calls this function after having updated all the vis/client
* region changes and before releasing the devlock.  We have to complete
* the remaining client region update operation.
*
* Gdi calls vForceClientRgnUpdate and this function after a new WNDOBJ
* is created to update the driver.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* If the GCR_DELAYFINALUPDATE flag is specified, the caller must
* subsequently call GreClientRgnDone.  If the driver specified
* the WO_DRAW_NOTIFY flag, the GCR_DELAYFINALUPDATE will suppress
* the WOC_DRAWN notification until GreClientRgnDone is called (or
* the next time GreClientRgnUpdated is called without
* GCR_DELAYFINALUPDATE).
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreClientRgnUpdated(FLONG flUpdate)
{
    PTRACKOBJ pto;
    PEWNDOBJ  pwo;

    DBGENTRY("GreClientRgnUpdated\n");

// Since we are holding the DEVLOCK to the active display, we can
// increment the VisRgn count here without doing an atomic increment.

    giVisRgnUniqueness++;

// Go any further only if some WNDOBJs exist.

    if (!(flUpdate & GCR_WNDOBJEXISTS))
    {
        return;
    }

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// The surface client regions have changed.  Complete the remaining
// client region update.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        if (!(pto->fl & WO_NOTIFIED))
            continue;

        pto->fl &= ~WO_NOTIFIED;

// We need to ensure that user holds the devlock before calling this function.
// Otherwise, some other threads may be drawing into the wrong client region.
// We do the check here because we don't have any pSurface information earlier.
//
// Also, we exclude the entire screen since we are going to touch windows all
// over the place and end with calling driver with WOC_COMPLETE which
// can have an effect anywhere on the screen.

        DEVEXCLUDEOBJ dxo;
        if (pto->pwo->hwnd)
        {
            RECTL rclSurf;
            HDEV  hdev = pto->pSurface->hdev();
            PDEVOBJ po(hdev);

            CHECKDEVLOCKIN2(pto->pSurface);

            ASSERTGDI(po.bValid(), "GreClientRgnUpdated: invalid pdevobj\n");

            if (po.bValid() && !po.bDisabled())
            {
                rclSurf.left = 0;
                rclSurf.top = 0;
                rclSurf.right = pto->pSurface->sizl().cx;
                rclSurf.bottom = pto->pSurface->sizl().cy;

                dxo.vExclude(hdev, &rclSurf, (ECLIPOBJ *) NULL);
            }
        }

// Traverse the chain and call the driver with un-changed windows if
// the WO_RGN_UPDATE_ALL and WO_RGN_CLIENT flags are set.

        if ((pto->fl & (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
         == (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
        {
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                if (pwo->fl & WO_NOTIFIED)
                    pwo->fl &= ~WO_NOTIFIED;
                else
                {
                // Make WNDOBJ stable by holding the per-WNDOBJ semaphore
                // while we call the driver.

                    SEMOBJ soClient(pwo->hsem);

                    pto->vUpdateDrv(pwo, WOC_RGN_CLIENT);
                }
        }

// Update the surface WNDOBJ if requested.

        if (pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))
        {
            PEWNDOBJ     pwoSurf = pto->pwoSurf;
            RGNMEMOBJTMP rmoTmp((BOOL)FALSE);
            RGNMEMOBJTMP rmoSurfNew((BOOL)FALSE);

            if (rmoTmp.bValid() && rmoSurfNew.bValid())
            {
// Construct the new surface region which is the entire surface minus
// the combined client regions.

                rmoSurfNew.vSet(&pwoSurf->rclClient);
                for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                {
                    RGNOBJ  ro(pwo->prgn);
                    if (rmoTmp.iCombine(rmoSurfNew, ro, RGN_DIFF) != ERROR)
                        rmoSurfNew.bSwap(&rmoTmp);
                }

// If WO_RGN_SURFACE_DELTA is set, update the driver with the new surface delta.

                if (pto->fl & WO_RGN_SURFACE_DELTA)
                {
                    RGNOBJ  roSurf(pwoSurf->prgn);
                    if (rmoTmp.iCombine(rmoSurfNew, roSurf, RGN_DIFF) != ERROR)
                    {
                        pwoSurf->bSwap(&rmoTmp);
                        pwoSurf->prgn->vStamp();        // new iUniq
                        pwoSurf->vSetClip(pwoSurf->prgn, *(ERECTL *)&pwoSurf->rclClient);

                        pto->vUpdateDrvDelta(pwoSurf, WOC_RGN_SURFACE_DELTA);
                    }
                }

// Save the new surface region.
// The surface region may be the same as previous one here.  This code can be
// optimized a little.

                pwoSurf->bSwap(&rmoSurfNew);
                pwoSurf->prgn->vStamp();        // new iUniq
                pwoSurf->vSetClip(pwoSurf->prgn, *(ERECTL *)&pwoSurf->rclClient);

// Give the driver the new surface region.

                if (pto->fl & WO_RGN_SURFACE)
                    pto->vUpdateDrv(pwoSurf, WOC_RGN_SURFACE);
            }

        } // if (pto->fl & (WO_RGN_SURFACE|WO_RGN_SURFACE_DELTA))

// Send down the WOC_CHANGED to signify notification complete.

        pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_CHANGED);

// Need WOC_DRAWN notification if requested.  Notification is delayed
// if GCR_DELAYFINALUPDATE is set.  Delayed notification is signaled
// by setting the WO_NEED_DRAW_NOTIFY flag in the trackobj and is
// handled in GreClientRgnDone.

        if (pto->fl & WO_DRAW_NOTIFY)
        {
            if (flUpdate & GCR_DELAYFINALUPDATE)
            {
                pto->fl |= WO_NEED_DRAW_NOTIFY;
            }
            else
            {
                pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_DRAWN);
                pto->fl &= ~WO_NEED_DRAW_NOTIFY;
            }
        }
    } // for (pto = gpto; pto; pto = pto->ptoNext)
}

/******************************Public*Routine******************************\
* GreClientRgnDone
*
* If USER calls GreClientRgnUpdated with the GCR_DELAYFINALUPDATE flag
* set, it must subsequently call this function to complete the update.
*
* If the driver calls EngCreateWnd with the WO_NEED_DRAW_NOTIFY flag,
* the GreClientRgnUpdated function will complete the notification with
* a WOC_CHANGED followed by a WOC_DRAWN.  However, if the
* GCR_DELAYFINALUPDATE flag is specified when calling GreClientRgnUpdated,
* the WOC_DRAWN message is suppressed until GreClientRgnDone is called.
*
* If the driver does not call EngCreateWnd with the WO_NEED_DRAW_NOTIFY
* flag, GreClientRgnDone will only send the WOC_CHANGED notification and
* this function will have no effect.
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* Note: Currently this function does not do anything if GCR_WNDOBJEXISTS
* is not set (GreClientRgnUpdated will update the vis rgn uniqneness and
* so must be called even if there are not WNDOBJs).  Therefore, for now
* it is acceptable for the caller to skip GreClientRgnDone if no WNDOBJs
* exist.
*
* History:
*  19-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreClientRgnDone(FLONG flUpdate)
{
    PTRACKOBJ pto;
    PEWNDOBJ pwo;

    DBGENTRY("GreClientRgnDone\n");

// Go any further only if some WNDOBJs exist.

    if (!(flUpdate & GCR_WNDOBJEXISTS))
    {
        return;
    }

// Assert that we are in user critical section.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// Check which tracking objects need WOC_DRAWN notification.

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        if (pto->pwo->hwnd)
        {
            CHECKDEVLOCKIN2(pto->pSurface);
        }

        if (pto->fl & WO_NEED_DRAW_NOTIFY)
        {
            pto->fl &= ~WO_NEED_DRAW_NOTIFY;

            pto->vUpdateDrv((PEWNDOBJ)NULL, WOC_DRAWN);
        }

// Inform the sprite code of the change in the WNDOBJ.

        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            vSpWndobjChange(pto->pSurface->hdev(), pwo);
        }

    } // for (pto = gpto; pto; pto = pto->ptoNext)
}

/******************************Public*Function*****************************\
* GreSetClientRgn
*
* User calls this function to update the client region in a WNDOBJ.
* After all the regions have been updated, user must call GreClientRgnUpdated
* to complete the update.
*
* User creates a new region to give to this function.  This function must
* delete the region before it returns!
*
* This function should only be called when the calling thread has the
* usercrit and devlock in that order.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID GreSetClientRgn(PVOID _pwoClient, HRGN hrgnClient, LPRECT prcClient)
{
    PEWNDOBJ pwoClient = (PEWNDOBJ)_pwoClient;

    DBGENTRY("GreSetClientRgn\n");

// Assert that we are in user critical section and also hold the devlock.
// This ensures that no one is updating the hwnd.

    CHECKUSERCRITIN;
    if (pwoClient->hwnd)
    {
        CHECKDEVLOCKIN2(pwoClient->pto->pSurface);
    }

// Validate hrgnClient.

    if (!hrgnClient)
    {
        ASSERTGDI(FALSE, "GreSetClientRgn: hrgnClient is NULL\n");
        return;
    }

// Validate pwoClient.

    if (!pwoClient->bValid())
    {
        ASSERTGDI(FALSE, "GreSetClientRgn: Invalid pwoClient\n");
        bDeleteRegion(hrgnClient);
        return;
    }

// The WNDOBJ should only be modified once per update.  A complete
// update includes a call to GreClientRgnUpdated.

#if DBG
    if ((pwoClient->fl & (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
     == (WO_RGN_CLIENT|WO_RGN_UPDATE_ALL))
        if (pwoClient->fl & WO_NOTIFIED)
            DbgPrint("GreSetClientRgn: WNDOBJ updated more than once!\n");
#endif // DBG

// Get new and old regions.

    GreSetRegionOwner(hrgnClient, OBJECT_OWNER_PUBLIC);
    RGNOBJAPI roClient(hrgnClient,FALSE);
    ASSERTGDI(roClient.bValid(), "GreSetClientRgn: invalid hrgnClient\n");
    RGNOBJ    roOld(pwoClient->prgn);
    ERECTL    erclClient(prcClient->left,  prcClient->top,
                         prcClient->right, prcClient->bottom);

#ifdef OPENGL_MM

// Under Multi-mon we need to adjust the client region and
// client rectangle by the offset of the surface.
// Additionally we need to clip the client region to the
// surface of the TRACKOBJ.

    if (!(pwoClient->fl & WO_RGN_DESKTOP_COORD))
    {
        PDEVOBJ pdo(pwoClient->pto->pSurface->hdev());

        if (pdo.bValid())
        {
            if (pdo.bPrimary(pwoClient->pto->pSurface))
            {
                POINTL ptlOrigin;

                ptlOrigin.x = -pdo.pptlOrigin()->x;
                ptlOrigin.y = -pdo.pptlOrigin()->y;

                if ((ptlOrigin.x != 0) || (ptlOrigin.y != 0))
                {
// offset the region and window rect if necessary

                    roClient.bOffset(&ptlOrigin);
                    erclClient += ptlOrigin;      /* this offsets by ptl */
                }
            }
        }

        RGNMEMOBJTMP rmoTmp;
        RGNMEMOBJTMP rmoRcl;

        if (rmoTmp.bValid() && rmoRcl.bValid())
        {
// this clips the client region to the pto surface

            rmoRcl.vSet((RECTL *) &pwoClient->pto->erclSurf);
            rmoTmp.bCopy(roClient);
            roClient.iCombine(rmoTmp,rmoRcl,RGN_AND);

            if (rmoTmp.iCombine(roClient,rmoRcl,RGN_AND) != ERROR)
            {
                roClient.bSwap(&rmoTmp);
            }
        }
    }

#endif // OPENGL_MM

// If the regions are equal, no need to notify driver here.

    if (roOld.bEqual(roClient)
     && ((ERECTL *)&pwoClient->rclClient)->bEqual(erclClient))
    {
        roClient.bDeleteRGNOBJAPI();     // delete handle too
        return;
    }

// Enter the semphore for window object.

    SEMOBJ so(ghsemWndobj);

// Now the WNDOBJ is going to get updated.  Hold the per-WNDOBJ semaphore
// and keep it until we are done modifying and the driver update call has
// been made.

    SEMOBJ soClient(pwoClient->hsem);

// Give the driver the client region delta.
// The delta is valid for this call only!

    if (pwoClient->fl & WO_RGN_CLIENT_DELTA)
    {
        RGNMEMOBJTMP rmoDiff((BOOL)FALSE);
        if (rmoDiff.bValid() &&
            (rmoDiff.iCombine(roClient, roOld, RGN_DIFF) != ERROR))
        {
            pwoClient->bSwap(&rmoDiff);
            pwoClient->prgn->vStamp();          // new iUniq
            pwoClient->vSetClip(pwoClient->prgn, erclClient);

            pwoClient->pto->vUpdateDrvDelta(pwoClient, WOC_RGN_CLIENT_DELTA);
        }
    }

// Update the new client region in WNDOBJ.

    roClient.bSwap(pwoClient);
    pwoClient->prgn->vStamp();       // new iUniq
    pwoClient->vSetClip(pwoClient->prgn, erclClient);
    roClient.bDeleteRGNOBJAPI();     // delete handle too

// Give the driver the new client region.

    if (pwoClient->fl & WO_RGN_CLIENT)
    {
        pwoClient->pto->vUpdateDrv(pwoClient, WOC_RGN_CLIENT);
    }

// Mark that we have visited this WNDOBJ and TRACKOBJ.

    pwoClient->fl      |= WO_NOTIFIED;
    pwoClient->pto->fl |= WO_NOTIFIED;

    return;
}

/******************************Member*Function*****************************\
* WNDOBJ_cEnumStart
*
* Start the window client region enumeration for the window object.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is given.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* In future, we may want to add the pvConsumer and WNDOBJ pointer to the
* CLIPOBJ that is passed to the existing DDI.  In this way, the WNDOBJ
* is always available to the DDI instead of the selected few.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

extern "C" ULONG WNDOBJ_cEnumStart(
WNDOBJ  *pwo,
ULONG    iType,
ULONG    iDir,
ULONG    cLimit)
{
    DBGENTRY("WNDOBJ_cEnumStart\n");

    ASSERTGDI(((PEWNDOBJ)pwo)->bValid(), "WNDOBJ_cEnumStart: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (((PEWNDOBJ)pwo)->hwnd)
    {
        CHECKDEVLOCKIN2(((PEWNDOBJ)pwo)->pto->pSurface);
    }

    return (*(XCLIPOBJ *)pwo).cEnumStart(TRUE, iType, iDir, cLimit);
}

/******************************Member*Function*****************************\
* WNDOBJ_bEnum
*
* Enumerate the client region object in the window object.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is given.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* In future, we may want to add the pvConsumer and WNDOBJ pointer to the
* CLIPOBJ that is passed to the existing DDI.  In this way, the WNDOBJ
* is always available to the DDI instead of the selected few.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  11-Nov-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

extern "C" BOOL WNDOBJ_bEnum(
WNDOBJ  *pwo,
ULONG   cj,
ULONG   *pul)
{
    DBGENTRY("WNDOBJ_bEnum\n");

    ASSERTGDI(((PEWNDOBJ)pwo)->bValid(), "WNDOBJ_bEnum: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (((PEWNDOBJ)pwo)->hwnd)
    {
        CHECKDEVLOCKIN2(((PEWNDOBJ)pwo)->pto->pSurface);
    }

    return (*(XCLIPOBJ *)pwo).bEnum(cj, (VOID *)pul);
}

/******************************Member*Function*****************************\
* WNDOBJ_vSetConsumer
*
* Set the driver pvConsumer value in the window object.  It should be
* used to modify the existing pvConsumer value.
*
* This function can be called from the wndobjchangeproc that is passed to
* EngCreateWnd.  It can also be called from DDI function where a WNDOBJ
* is given.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" VOID WNDOBJ_vSetConsumer(
WNDOBJ  *_pwo,
PVOID   pvConsumer)
{
    PEWNDOBJ pwo = (PEWNDOBJ)_pwo;

    DBGENTRY("WNDOBJ_vSetConsumer\n");

    ASSERTGDI(pwo->bValid(), "WNDOBJ_vSetConsumer: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (pwo->hwnd)
    {
        CHECKDEVLOCKIN2(pwo->pto->pSurface);
    }

// Do not allow changes to surface wndobj.  One reason is that there is
// no delete notification for surface wndobj.

    if (pwo == pwo->pto->pwoSurf)
    {
        KdPrint(("WNDOBJ_vSetConsumer: cannot modify surface wndobj!\n"));
        return;
    }

    pwo->pvConsumer = pvConsumer;
}

/******************************Member*Function*****************************\
* EWNDOBJ::vOffset
*
* Offset the WNDOBJ by some vector.
\**************************************************************************/

VOID EWNDOBJ::vOffset(LONG x, LONG y)
{
    if ((x != 0) || (y != 0))
    {
        EPOINTL eptl(x, y);
    
        bOffset(&eptl);
        *((ERECTL*) &rclBounds) += eptl;
        *((ERECTL*) &rclClient) += eptl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\xformobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformobj.cxx                                                *
*                                                                          *
* Xform object non-inline methods.                                         *
*                                                                          *
* Created: 12-Nov-1990 16:54:37                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
void __cdecl _fltused(void) {}              // just so that we link clean...
};

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
#define vSetTo1Over16(ef)   (ef.e = EFLOAT_1Over16)
#else
#define vSetTo1Over16(ef)   (ef.i.lMant = 0x040000000, ef.i.lExp = -2)
#endif


/******************************Data*Structure******************************\
* matrixIdentity                                                           *
*                                                                          *
* Defines the identity transform matrices in different formats.            *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

MATRIX gmxIdentity_LToFx =
{
    EFLOAT_16,                                          // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_16,                                          // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_LTOFX
};

MATRIX gmxIdentity_LToL =
{
    EFLOAT_1,                                           // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_1,                                           // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_LTOL
};

MATRIX gmxIdentity_FxToL =
{
    EFLOAT_1Over16,                                     // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_1Over16,                                     // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_FXTOL
};

/******************************Member*Function*****************************\
* EXFORMOBJ::EXFORMOBJ                                                     *
*                                                                          *
* Get a transform matrix based on the request type.  The only legitimate   *
* type for now is IDENTITY.                                                *
*                                                                          *
* History:                                                                 *
*  27-Mar-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

EXFORMOBJ::EXFORMOBJ(ULONG iXform, ULONG iFormat)
{
    ASSERTGDI((iXform == IDENTITY),"XFORMOBJ:invalid iXform\n");
    bMirrored = FALSE;
    if (iFormat == XFORM_FORMAT_LTOFX)
        pmx = &gmxIdentity_LToFx;
    else if (iFormat == XFORM_FORMAT_FXTOL)
        pmx = &gmxIdentity_FxToL;
    else
        pmx = &gmxIdentity_LToL;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bEqual(EXFORMOBJ& xo)                                         *
*                                                                          *
* See if two transforms are identical.  Matrices of different formats are  *
* considered different even though the coefficients are same.              *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bEqual(EXFORMOBJ& xo)
{
    if (pmx == xo.pmx)
        return(TRUE);                   // point to the same matrix

// compare each and every element of the matrices as the structures may
// be padded.

    return ((pmx->efM11 == xo.pmx->efM11) && (pmx->efM12 == xo.pmx->efM12) &&
            (pmx->efM21 == xo.pmx->efM21) && (pmx->efM22 == xo.pmx->efM22) &&
            (pmx->efDx == xo.pmx->efDx) && (pmx->efDy == xo.pmx->efDy));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bEqualExceptTranslations                                      *
*                                                                          *
* See if two transforms are identical other than the translations elements.*
* Matrices of different formats are considered different even though the   *
* coefficients are same.                                                   *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bEqualExceptTranslations(PMATRIX pmx_)
{
    if (pmx == pmx_)
        return(TRUE);                   // point to the same matrix

// compare each and every element of the matrices as the structures may
// be padded.

    return ((pmx->efM11 == pmx_->efM11) && (pmx->efM12 == pmx_->efM12) &&
            (pmx->efM21 == pmx_->efM21) && (pmx->efM22 == pmx_->efM22));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTL to a list of POINTL.                          *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTL pptlSrc,
PPOINTL pptlDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::bXformPtlToPtl: wrong xform format\n");

// copy the source to the dest,  This way we can use bCvtPts1 which is more efficient

    if (pptlSrc != pptlDst)
    {
        RtlCopyMemory(pptlDst, pptlSrc, cPts*sizeof(POINTL));
    }

// Straight copy if identity transform.

    if (bIdentity())
    {
        return(TRUE);
    }

    BOOL bReturn = bCvtPts1(pmx, pptlDst, cPts);

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return(bReturn);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTL to a list of POINTFIX.                         *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTL pptlSrc,
PPOINTFIX pptfxDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformPtlToPtfx: wrong xform format\n");

// Convert a list of POINTL to a list of POINTFIX if identity transform.

    if (bIdentity())
    {
        PPOINTL pptlSrcEnd = pptlSrc + cPts;

        for ( ; pptlSrc < pptlSrcEnd; pptlSrc++, pptfxDst++)
        {
            pptfxDst->x = LTOFX(pptlSrc->x);
            pptfxDst->y = LTOFX(pptlSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtPts(pmx, pptlSrc, (PPOINTL)pptfxDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXformRound                                                   *
*                                                                          *
* Transform a list of POINTL to a list of POINTFIX.  Round the resulting   *
* points to the nearest integers for Win31 compatibility.                  *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXformRound(
PPOINTL pptlSrc,
PPOINTFIX pptfxDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformPtlToPtfx: wrong xform format\n");

// Convert a list of POINTL to a list of POINTFIX if identity transform.

    if (bIdentity())
    {
        PPOINTL pptlSrcEnd = pptlSrc + cPts;

        for ( ; pptlSrc < pptlSrcEnd; pptlSrc++, pptfxDst++)
        {
            pptfxDst->x = LTOFX(pptlSrc->x);
            pptfxDst->y = LTOFX(pptlSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtPts(pmx, pptlSrc, (PPOINTL)pptfxDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    if (ulMode != GM_ADVANCED)
    {
        PPOINTFIX pptfxDstEnd = pptfxDst + cPts;

        for ( ; pptfxDst < pptfxDstEnd; pptfxDst++)
        {
            pptfxDst->x = (pptfxDst->x + FIX_HALF) & 0xFFFFFFF0;
            pptfxDst->y = (pptfxDst->y + FIX_HALF) & 0xFFFFFFF0;
        }
    }

    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTFIX to a list of POINTL.                        *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTFIX pptfxSrc,
PPOINTL pptlDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_FXTOL),
              "EXFORMOBJ::bXformPtfxToPtl: wrong xform format\n");

// Convert a list of POINTFIX to a list of POINTL if identity transform.

    if (bIdentity())
    {
        PPOINTFIX pptfxSrcEnd = pptfxSrc + cPts;

        for ( ; pptfxSrc < pptfxSrcEnd; pptfxSrc++, pptlDst++)
        {
            pptlDst->x = FXTOLROUND(pptfxSrc->x);
            pptlDst->y = FXTOLROUND(pptfxSrc->y);
        }

        return(TRUE);                       // never overflows
    }

    BOOL bRet = bCvtPts(pmx, (PPOINTL)pptfxSrc, pptlDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return bRet;

}

/******************************Member*Function*****************************\
* BOOL EXFORMOBJ::bXform
*
*  Given a list of vectors (pptflSrc) and number of points in the list (cVts)
*  transform the vectors and store into another list (pptflDst).
*
* History:
*  28-Jan-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORFL pvtflSrc,
PVECTORFL pvtflDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");

// check for quick exit, if the transform consists of translations
// only, there is nothing to do:

    if (bTranslationsOnly())
    {
        if (pvtflDst != pvtflSrc)  // if not transforming in place
        {
            RtlCopyMemory(pvtflDst, pvtflSrc, cVts*sizeof(VECTORFL));
        }

        return(TRUE);
    }

    BOOL bRet;

    if (pmx->flAccel & XFORM_FORMAT_LTOL)
    {
        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);
    }
    else if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        pmx->efM11.vDivBy16();
        pmx->efM12.vDivBy16();
        pmx->efM21.vDivBy16();
        pmx->efM22.vDivBy16();

        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);

        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();
    }
    else
    {
        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();

        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);

        pmx->efM11.vDivBy16();
        pmx->efM12.vDivBy16();
        pmx->efM21.vDivBy16();
        pmx->efM22.vDivBy16();
    }

    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORL.                        *
*                                                                          *
* History:                                                                 *
*  28-Jan-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORL pvtlSrc,
PVECTORL pvtlDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");

// Straight copy if identity transform.

    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformVtlToVtl: wrong xform format\n");

    if (bTranslationsOnly())
    {
        if (pvtlDst != pvtlSrc)
        {
            RtlCopyMemory(pvtlDst, pvtlSrc, cVts*sizeof(VECTORL));
            return(TRUE);
        }
    }

    pmx->efM11.vDivBy16();
    pmx->efM12.vDivBy16();
    pmx->efM21.vDivBy16();
    pmx->efM22.vDivBy16();

    BOOL bReturn = bCvtVts(pmx, pvtlSrc, pvtlDst, cVts);

    pmx->efM11.vTimes16();
    pmx->efM12.vTimes16();
    pmx->efM21.vTimes16();
    pmx->efM22.vTimes16();

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return(bReturn);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORFX.                       *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORL pvtlSrc,
PVECTORFX pvtfxDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "XFORMOBJ::bXformVtlToVtfx: wrong xform format\n");

// Convert a list of VECTORL to a list of VECTORFX if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORL pvtlSrcEnd = pvtlSrc + cVts;

        for ( ; pvtlSrc < pvtlSrcEnd; pvtlSrc++, pvtfxDst++)
        {
            if (BLTOFXOK(pvtlSrc->x) && BLTOFXOK(pvtlSrc->y))
            {
                pvtfxDst->x = LTOFX(pvtlSrc->x);
                pvtfxDst->y = LTOFX(pvtlSrc->y);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(FALSE);
            }
        }
        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, pvtlSrc, (PVECTORL)pvtfxDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXformRound                                                   *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORFIX.  Round the resulting *
* vectors to the nearest integers for Win31 compatibility.                 *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXformRound(
PVECTORL pvtlSrc,
PVECTORFX pvtfxDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "XFORMOBJ::bXformVtlToVtfx: wrong xform format\n");

// Convert a list of VECTORL to a list of VECTORFX if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORL pvtlSrcEnd = pvtlSrc + cVts;

        for ( ; pvtlSrc < pvtlSrcEnd; pvtlSrc++, pvtfxDst++)
        {
            if (BLTOFXOK(pvtlSrc->x) && BLTOFXOK(pvtlSrc->y))
            {
                pvtfxDst->x = LTOFX(pvtlSrc->x);
                pvtfxDst->y = LTOFX(pvtlSrc->y);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(FALSE);
            }
        }
        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, pvtlSrc, (PVECTORL)pvtfxDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    if (ulMode != GM_ADVANCED)
    {
        PVECTORFX pvtfxDstEnd = pvtfxDst + cVts;

        for ( ; pvtfxDst < pvtfxDstEnd; pvtfxDst++)
        {
            pvtfxDst->x = (pvtfxDst->x + FIX_HALF) & 0xFFFFFFF0;
            pvtfxDst->y = (pvtfxDst->y + FIX_HALF) & 0xFFFFFFF0;
        }
    }
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORFX to a list of VECTORL.                       *
*                                                                          *
* History:                                                                 *
*  06-Feb-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORFX pvtfxSrc,
PVECTORL pvtlDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_FXTOL),
              "EXFORMOBJ::bXformVtfxToVtl: wrong xform format\n");

// Convert a list of VECTORFX to a list of VECTORL if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORFX pvtfxSrcEnd = pvtfxSrc + cVts;

        for ( ; pvtfxSrc < pvtfxSrcEnd; pvtfxSrc++, pvtlDst++)
        {
            pvtlDst->x = FXTOL(pvtfxSrc->x);
            pvtlDst->y = FXTOL(pvtfxSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, (PVECTORL)pvtfxSrc, pvtlDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;

}

/******************************Member*Function*****************************\
* EXFORMOBJ::vComputeAccelFlags                                            *
*                                                                          *
* Set the accelerator flags for a given matrix.                            *
*                                                                          *
* History:                                                                 *
*  06-Dec-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vComputeAccelFlags(FLONG flFormat)
{
    pmx->flAccel = flFormat;                        // clear the flag

// set translation flag

    if ((pmx->fxDx == 0) && (pmx->fxDy == 0))
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
    // off diagonal elements are zeros

        pmx->flAccel |= XFORM_SCALE;

        switch(flFormat)
        {
        case XFORM_FORMAT_LTOFX:
            if (pmx->efM11.bIs16() && pmx->efM22.bIs16())
                pmx->flAccel |= XFORM_UNITY;
            break;

        case XFORM_FORMAT_LTOL:
            if (pmx->efM11.bIs1() && pmx->efM22.bIs1())
                pmx->flAccel |= XFORM_UNITY;
            break;

        default:
            if (pmx->efM11.bIs1Over16() && pmx->efM22.bIs1Over16())
                pmx->flAccel |= XFORM_UNITY;
            break;
        }
    }
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vCopy(EXFORMOBJ& xo)                                          *
*                                                                          *
* Copy the coefficient values of a transform to another.                   *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vCopy(EXFORMOBJ& xo)
{
    RtlCopyMemory(pmx, xo.pmx, sizeof(MATRIX));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vRemoveTranslation()                                          *
*                                                                          *
* Remove the translation coefficients of a transform.                      *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vRemoveTranslation()
{
    pmx->fxDx = 0;
    pmx->fxDy = 0;
    pmx->efDx.vSetToZero();
    pmx->efDy.vSetToZero();
    pmx->flAccel |= XFORM_NO_TRANSLATION;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()                                             *
*                                                                          *
* Get the coefficient of a transform matrix.  This is used to convert      *
* our internal matrix structure into the GDI/DDI transform format.         *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(XFORML *pxf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();
        mxTmp.efDx.vDivBy16();
        mxTmp.efDy.vDivBy16();

        *(LONG *)&pxf->eM11 = mxTmp.efM11.lEfToF();
        *(LONG *)&pxf->eM12 = mxTmp.efM12.lEfToF();
        *(LONG *)&pxf->eM21 = mxTmp.efM21.lEfToF();
        *(LONG *)&pxf->eM22 = mxTmp.efM22.lEfToF();
        *(LONG *)&pxf->eDx = mxTmp.efDx.lEfToF();
        *(LONG *)&pxf->eDy = mxTmp.efDy.lEfToF();

    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(LONG *)&pxf->eM11 = mxTmp.efM11.lEfToF();
        *(LONG *)&pxf->eM12 = mxTmp.efM12.lEfToF();
        *(LONG *)&pxf->eM21 = mxTmp.efM21.lEfToF();
        *(LONG *)&pxf->eM22 = mxTmp.efM22.lEfToF();
        *(LONG *)&pxf->eDx = mxTmp.efDx.lEfToF();
        *(LONG *)&pxf->eDy = mxTmp.efDy.lEfToF();

    }
    else
    {
        *(LONG *)&pxf->eM11 = pmx->efM11.lEfToF();
        *(LONG *)&pxf->eM12 = pmx->efM12.lEfToF();
        *(LONG *)&pxf->eM21 = pmx->efM21.lEfToF();
        *(LONG *)&pxf->eM22 = pmx->efM22.lEfToF();
        *(LONG *)&pxf->eDx = pmx->efDx.lEfToF();
        *(LONG *)&pxf->eDy = pmx->efDy.lEfToF();
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()                                             *
*                                                                          *
* Get the coefficient of a transform matrix.  This is to convert EFLOAT's  *
* into FLOATOBJs which are now the same.                                   *
*                                                                          *
* History:                                                                 *
*  13-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(PFLOATOBJ_XFORM pxf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();
        mxTmp.efDx.vDivBy16();
        mxTmp.efDy.vDivBy16();

        *(EFLOAT *)&pxf->eM11 = mxTmp.efM11;
        *(EFLOAT *)&pxf->eM12 = mxTmp.efM12;
        *(EFLOAT *)&pxf->eM21 = mxTmp.efM21;
        *(EFLOAT *)&pxf->eM22 = mxTmp.efM22;
        *(EFLOAT *)&pxf->eDx  = mxTmp.efDx;
        *(EFLOAT *)&pxf->eDy  = mxTmp.efDy;
    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(EFLOAT *)&pxf->eM11 = mxTmp.efM11;
        *(EFLOAT *)&pxf->eM12 = mxTmp.efM12;
        *(EFLOAT *)&pxf->eM21 = mxTmp.efM21;
        *(EFLOAT *)&pxf->eM22 = mxTmp.efM22;
        *(EFLOAT *)&pxf->eDx  = mxTmp.efDx;
        *(EFLOAT *)&pxf->eDy  = mxTmp.efDy;

    }
    else
    {
        *(EFLOAT *)&pxf->eM11 = pmx->efM11;
        *(EFLOAT *)&pxf->eM12 = pmx->efM12;
        *(EFLOAT *)&pxf->eM21 = pmx->efM21;
        *(EFLOAT *)&pxf->eM22 = pmx->efM22;
        *(EFLOAT *)&pxf->eDx  = pmx->efDx;
        *(EFLOAT *)&pxf->eDy  = pmx->efDy;
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()
*
* Get the coefficient of a transform matrix.  This is used to convert
* our internal matrix structure into the IFI transform format.
*
* History:
*  04-Feb-1992 -by- Gilman Wong [gilmanw]
* Adapted from vGetCoefficient.
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(PFD_XFORM pfd_xf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();

        *(LONG *)&pfd_xf->eXX = mxTmp.efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = mxTmp.efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = mxTmp.efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = mxTmp.efM22.lEfToF();
    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(LONG *)&pfd_xf->eXX = mxTmp.efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = mxTmp.efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = mxTmp.efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = mxTmp.efM22.lEfToF();
    }
    else
    {
        *(LONG *)&pfd_xf->eXX = pmx->efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = pmx->efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = pmx->efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = pmx->efM22.lEfToF();
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vOrder(RECTL &rcl)
*
* Order a rectangle based on the given transform.  The rectangle will be
* well ordered after the transform is applied.  Note that the off-diagonal
* elements of the transform MUST be zero's.  ie. only scaling is allowed.
*
* History:
*  18-Dec-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vOrder(RECTL &rcl)
{
    LONG    lTmp;

    ASSERTGDI(bScale(), "vOrder error: not scaling transform");

    if ((pmx->efM11.bIsNegative() && (rcl.left < rcl.right)) ||
        (!pmx->efM11.bIsNegative() && (rcl.left > rcl.right)))
    {
            SWAPL(rcl.left, rcl.right, lTmp);
    }

    if ((pmx->efM22.bIsNegative() && (rcl.top < rcl.bottom)) ||
        (!pmx->efM22.bIsNegative() && (rcl.top > rcl.bottom)))
    {
            SWAPL(rcl.top, rcl.bottom, lTmp);
    }
}



/******************************Member*Function*****************************\
* bMultiply(PMATRIX pmxLeft, PMATRIX pmxRight)                             *
*                                                                          *
* Multiply two matrices together.  Put the results in the XFORMOBJ.        *
* The target matrix CANNOT be the same as either of the two src matrices.  *
*                                                                          *
* History:                                                                 *
*  Fri 20-Mar-1992 13:54:28 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new EFLOAT math operations.  We should never do any         *
* operations like efA=efB*efC+efD!  They generate intensely bad code.      *
*                                                                          *
*  19-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bMultiply(PMATRIX pmxLeft, PMATRIX pmxRight, FLONG fl)
{

    MATRIX *pmxTemp = pmx;

    ASSERTGDI((pmx != pmxLeft), "bMultiply error: pmx == pmxLeft\n");
    ASSERTGDI((pmx != pmxRight), "bMultiply error: pmx == pmxRight\n");

    EFLOAT efA,efB;

    if (pmxLeft->efM12.bIsZero() && pmxLeft->efM21.bIsZero() &&
        pmxRight->efM12.bIsZero() && pmxRight->efM21.bIsZero())
    {
        pmxTemp->efM11.eqMul(pmxLeft->efM11,pmxRight->efM11);
        pmxTemp->efM22.eqMul(pmxLeft->efM22,pmxRight->efM22);
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();
    }
    else
    {
    // calculate the first row of the results

        efA.eqMul(pmxLeft->efM11,pmxRight->efM11);
        efB.eqMul(pmxLeft->efM12,pmxRight->efM21);
        pmxTemp->efM11.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efM11,pmxRight->efM12);
        efB.eqMul(pmxLeft->efM12,pmxRight->efM22);
        pmxTemp->efM12.eqAdd(efA,efB);

    // calculate the second row of the results

        efA.eqMul(pmxLeft->efM21,pmxRight->efM11);
        efB.eqMul(pmxLeft->efM22,pmxRight->efM21);
        pmxTemp->efM21.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efM21,pmxRight->efM12);
        efB.eqMul(pmxLeft->efM22,pmxRight->efM22);
        pmxTemp->efM22.eqAdd(efA,efB);
    }

// calculate the translation

    if (pmxLeft->efDx.bIsZero() && pmxLeft->efDy.bIsZero())
    {
        pmxTemp->efDx = pmxRight->efDx;
        pmxTemp->efDy = pmxRight->efDy;
        pmxTemp->fxDx = pmxRight->fxDx;
        pmxTemp->fxDy = pmxRight->fxDy;
    }
    else
    {
        efA.eqMul(pmxLeft->efDx,pmxRight->efM11);
        efB.eqMul(pmxLeft->efDy,pmxRight->efM21);
        efB.eqAdd(efB,pmxRight->efDx);
        pmxTemp->efDx.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efDx,pmxRight->efM12);
        efB.eqMul(pmxLeft->efDy,pmxRight->efM22);
        efB.eqAdd(efB,pmxRight->efDy);
        pmxTemp->efDy.eqAdd(efA,efB);

        if (!pmxTemp->efDx.bEfToL(pmxTemp->fxDx))
            return(FALSE);

        if (!pmxTemp->efDy.bEfToL(pmxTemp->fxDy))
            return(FALSE);
    }

    if (fl & COMPUTE_FLAGS)
        vComputeAccelFlags(fl & XFORM_FORMAT);

    return(TRUE);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bInverse(MATRIX& mxSrc)                                       *
*                                                                          *
* Calculate the inverse of a given matrix.                                 *
*                                                                          *
* The inverse is calculated as follows:                                    *
*                                                                          *
*   If x' = D + xM then x = (-DM') + x'M' where M'M = 1.                   *
*                                                                          *
*   M'11 = M22/det, M'12 = -M12/det, M'21 = -M21/det, M'22 = M11/det,      *
*     where det = M11*M22 - M12*M21                                        *
*                                                                          *
* History:                                                                 *
*  Fri 20-Mar-1992 13:54:28 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new EFLOAT math operations.  We should never do any         *
* operations like efA=efB*efC+efD!  They generate intensely bad code.      *
*                                                                          *
*  19-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bInverse(MATRIX& mxSrc)
{

    MATRIX *pmxTemp = pmx;

    ASSERTGDI((&mxSrc != pmx), "bInverse src, dest same matrix\n");
    ASSERTGDI((mxSrc.flAccel & XFORM_FORMAT_LTOFX), "bInverse: wrong xform format\n");

// The accelerators of the destination matrix always equal to the
// accelerators of the source matrix.

    pmxTemp->flAccel = (mxSrc.flAccel & ~XFORM_FORMAT_LTOFX) | XFORM_FORMAT_FXTOL;

    if (mxSrc.flAccel & XFORM_UNITY)
    {
        vSetTo1Over16(pmxTemp->efM11);
        vSetTo1Over16(pmxTemp->efM22);
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();

        pmxTemp->efDx = mxSrc.efDx;
        pmxTemp->efDy = mxSrc.efDy;
        pmxTemp->efDx.vNegate();
        pmxTemp->efDy.vNegate();
        pmxTemp->efDx.vDivBy16();
        pmxTemp->efDy.vDivBy16();
        pmxTemp->fxDx = -FXTOL(mxSrc.fxDx);
        pmxTemp->fxDy = -FXTOL(mxSrc.fxDy);
        return(TRUE);
    }

// calculate the determinant

    EFLOAT efDet;
    EFLOAT efA,efB;

    efA.eqMul(mxSrc.efM11,mxSrc.efM22);
    efB.eqMul(mxSrc.efM12,mxSrc.efM21);
    efDet.eqSub(efA,efB);

// if determinant = 0, return false

    if (efDet.bIsZero())
        return(FALSE);

    if (mxSrc.flAccel & XFORM_SCALE)
    {
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();
    }
    else
    {
        pmxTemp->efM12.eqDiv(mxSrc.efM12,efDet);
        pmxTemp->efM12.vNegate();
        pmxTemp->efM21.eqDiv(mxSrc.efM21,efDet);
        pmxTemp->efM21.vNegate();
    }

    pmxTemp->efM11.eqDiv(mxSrc.efM22,efDet);
    pmxTemp->efM22.eqDiv(mxSrc.efM11,efDet);

// calculate the offset

    if (mxSrc.flAccel & XFORM_NO_TRANSLATION)
    {
        pmxTemp->efDx.vSetToZero();
        pmxTemp->efDy.vSetToZero();
        pmxTemp->fxDx = 0;
        pmxTemp->fxDy = 0;
        return(TRUE);
    }

    if (mxSrc.flAccel & XFORM_SCALE)
    {
        pmxTemp->efDx.eqMul(mxSrc.efDx,pmxTemp->efM11);
        pmxTemp->efDy.eqMul(mxSrc.efDy,pmxTemp->efM22);
    }
    else
    {
        efA.eqMul(mxSrc.efDx,pmxTemp->efM11);
        efB.eqMul(mxSrc.efDy,pmxTemp->efM21);
        pmxTemp->efDx.eqAdd(efA,efB);

        efA.eqMul(mxSrc.efDx,pmxTemp->efM12);
        efB.eqMul(mxSrc.efDy,pmxTemp->efM22);
        pmxTemp->efDy.eqAdd(efA,efB);
    }

    pmxTemp->efDx.vNegate();
    pmxTemp->efDy.vNegate();

// Return FALSE if translations can't fit in LONG type.

    if (!pmxTemp->efDx.bEfToL(pmxTemp->fxDx))
        return(FALSE);

    if (!pmxTemp->efDy.bEfToL(pmxTemp->fxDy))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bComputeUnits (lAngle,ppte,pefWD,pefDW)                                  *
*                                                                          *
* Given an angle in 1/10ths of a degree in logical coordinates, we         *
* transform a vector at that angle into device coordinates.  We normalize  *
* the result into a unit vector and a scaling.                             *
*                                                                          *
* Knowing the unit vector and scaling allows us to quickly calculate the   *
* transform of any vector parallel to the angle.                           *
*                                                                          *
*  Sun 15-Mar-1992 05:26:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bComputeUnits
(
    LONG     lAngle,                // Angle in tenths of a degree.
    POINTFL *ppte,                  // Unit vector in Device Coordinates.
    EFLOAT  *pefWD,                 // World to Device multiplier.
    EFLOAT  *pefDW                  // (Optional) Device to World multiplier.
)
{
    EVECTORFL vt;
    EFLOAT    efA;
    EFLOAT    efB;
    BOOL      bNegate = FALSE;

// Get rid of negative angles.  (Modulo is unreliable on negatives.)

    if (lAngle < 0)
    {
        lAngle = -lAngle;
        bNegate = TRUE;
    }

// Handle simple cases separately for greater accuracy.

    if (bScale() && (lAngle % 900 == 0))
    {
        lAngle /= 900;
        if (lAngle & 1)
        {
            vt.x = (LONG) 0;
            vt.y = (LONG) 1;
            efA = efM22();
        }
        else
        {
            vt.x = (LONG) 1;
            vt.y = (LONG) 0;
            efA = efM11();
        }

        if (efA.bIsZero())
            return(FALSE);

        if (lAngle & 2)
            efA.vNegate();

        if (efA.bIsNegative())
        {
            vt.x.vNegate();
            vt.y.vNegate();
            efA.vNegate();
        }
    }
    else
    {
    // Get the angle.

        EFLOATEXT efAngle = lAngle;
        efAngle /= (LONG) 10;

    // Make a unit vector at that angle.

        vt.x = efCos(efAngle);
        vt.y = efSin(efAngle);

    // Transform it to device coordinates.

        if (!bXform(vt))
            return(FALSE);

    // Determine its length.

        efA.eqLength(*(POINTFL *) &vt);
        if (efA.bIsZero())
            return(FALSE);

    // Make a unit vector.

        vt.x /= efA;
        vt.y /= efA;
        efA.vTimes16();
    }

// Copy the results out.

    if (bNegate)
        vt.y.vNegate();

    *ppte  = vt;
    *pefWD = efA;

    if (pefDW != (EFLOAT *) NULL)
    {
    // Calculate the inverse.

        efB = (LONG) 1;
        efB /= efA;
        *pefDW = efB;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\w32kevnt.h ===
/////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//  Display driver/Eng interface.
//
/////////////////////////////////////////////////////////

//
//  Opaque type for event objects.
//

typedef struct _ENG_EVENT *PEVENT;

BOOL
EngDeleteEvent(
    IN  PEVENT pEvent
    );

BOOL
EngCreateEvent(
    OUT PEVENT *ppEvent
    );

BOOL
EngUnmapEvent(
    IN PEVENT pEvent
    );

PEVENT
EngMapEvent(
    IN  HDEV            hDev,
    IN  HANDLE          hUserObject,
    IN  OUT PVOID       Reserved1,
    IN  PVOID           Reserved2,
    IN  PVOID           Reserved3
    );

BOOL
EngWaitForSingleObject(
    IN  PEVENT          pEvent,
    IN  PLARGE_INTEGER  pTimeOut
    );

LONG
EngSetEvent(
    IN  PEVENT pEvent
    );

VOID
EngClearEvent (
IN PEVENT pEvent
);

LONG
EngReadStateEvent (
IN PEVENT pEvent
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\watchdog.cxx ===
/******************************Module*Header*******************************\
* Module Name: watchdog.cxx                                                *
*                                                                          *
* Copyright (c) 1990-2002 Microsoft Corporation                            *
*                                                                          *
* This module hooks the display drivers "Drv" entry points.  It will       *
* enter/exit the watchdog appropriately, and set up try/except blocks to   *
* catch threads that get stuck in a driver.                                *
*                                                                          *
* Erick Smith  - ericks -                                                  *
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"

#define MAKESOFTWAREEXCEPTION(Severity, Facility, Exception) \
    ((DWORD) ((Severity << 30) | (1 << 29) | (Facility << 16) | (Exception)))

#define SE_THREAD_STUCK MAKESOFTWAREEXCEPTION(3,0,1)

typedef struct _CONTEXT_NODE
{
    PVOID Context;
    PLDEV pldev;
} CONTEXT_NODE, *PCONTEXT_NODE;

PASSOCIATION_NODE gAssociationList = NULL;

//
// The following routines are used to maintain an association between the
// data actually passed into a driver entry point, and the LDEV for the
// driver.  We need this association because we need access to the LDEV
// in order to look up the actual driver entry point.
//
// For example, when the system call the DrvEnablePDEV entry point, the
// driver will create it's own PDEV structure.  We will create an
// association node to associate this driver created PDEV with the LDEV for
// that driver.  Now on subsequent calls into the driver, we can retrieve
// the PDEV via various methods, and then use that to find the LDEV.  Once we
// have the LDEV we can look up the correct entry point into the driver.
//

PASSOCIATION_NODE
AssociationCreateNode(
    VOID
    )

{
    PASSOCIATION_NODE Node;

    Node = (PASSOCIATION_NODE) PALLOCMEM(sizeof(ASSOCIATION_NODE), GDITAG_DRVSUP);

    return Node;
}

VOID
AssociationDeleteNode(
    PASSOCIATION_NODE Node
    )

{
    if (Node) {
        VFREEMEM(Node);
    }
}

VOID
AssociationInsertNode(
    PASSOCIATION_NODE Node
    )

{
    GreAcquireFastMutex(gAssociationListMutex);

    Node->next = gAssociationList;
    gAssociationList = Node;

    GreReleaseFastMutex(gAssociationListMutex);
}

VOID
AssociationInsertNodeAtTail(
    PASSOCIATION_NODE Node
    )

{
    GreAcquireFastMutex(gAssociationListMutex);

    if (gAssociationList) {

        PASSOCIATION_NODE Curr;

        Curr = gAssociationList;

        while (Curr && Curr->next) {
            Curr = Curr->next;
        }

        //
        // The following test for NULL is not really required, but I
        // added it to make prefast happy.
        //

        if (Curr) {
            Curr->next = Node;
        }

    } else {

        gAssociationList = Node;
    }

    GreReleaseFastMutex(gAssociationListMutex);
}

PASSOCIATION_NODE
AssociationRemoveNode(
    ULONG_PTR key
    )

{
    PASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    //
    // first find the correct node
    //

    Node = gAssociationList;

    while (Node && (Node->key != key)) {
        Node = Node->next;
    }

    if (Node) {

        if (gAssociationList == Node) {

            gAssociationList = Node->next;

        } else {

            PASSOCIATION_NODE curr = gAssociationList;

            while (curr && (curr->next != Node)) {
                curr = curr->next;
            }

            if (curr) {
                curr->next = Node->next;
            }
        }
    }

    GreReleaseFastMutex(gAssociationListMutex);

    return Node;
}


BOOLEAN
AssociationIsNodeInList(
    PASSOCIATION_NODE Node
    )

{
    PASSOCIATION_NODE Curr = gAssociationList;

    while (Curr) {

	//
	// We only have to check if the key and the hsurf value
	// are similar.
	//

	if ((Curr->key == Node->key) &&
	    (Curr->hsurf == Node->hsurf)) {

	    return TRUE;
	}

	Curr = Curr->next;
    }

    return FALSE;
}

ULONG_PTR
AssociationRetrieveData(
    ULONG_PTR key
    )

{

    PASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    Node = gAssociationList;

    while (Node) {

        if (Node->key == key) {
            break;
        }

        Node = Node->next;
    }

    GreReleaseFastMutex(gAssociationListMutex);

    if (Node) {
	return Node->data;
    } else {
	return NULL;
    }
}

PFN
dhpdevRetrievePfn(
    ULONG_PTR dhpdev,
    ULONG Index
    )

{
    PLDEV pldev = (PLDEV)AssociationRetrieveData(dhpdev);
    return pldev->apfnDriver[Index];
}

PLDEV
dhpdevRetrieveLdev(
    DHPDEV dhpdev
    )

{
    return (PLDEV)AssociationRetrieveData((ULONG_PTR)dhpdev);
}

ULONG
WatchdogDrvGetModesEmpty(
    IN HANDLE hDriver,
    IN ULONG cjSize,
    OUT DEVMODEW *pdm
    )

/*++

Routine Description:

    This function replaces a drivers DrvGetModes function when
    and EA has occured.  We do this so that we can stop reporting
    modes for this device.

--*/

{
    //
    // Indicate NO modes!
    //

    return 0;
}

VOID
WatchdogRecoveryThread(
    IN PVOID Context
    )

{
    VIDEO_WIN32K_CALLBACKS_PARAMS Params;

    UNREFERENCED_PARAMETER(Context);

    Params.CalloutType = VideoChangeDisplaySettingsCallout;
    Params.Param = 0;
    Params.PhysDisp = NULL;
    Params.Status = 0;

    //
    // It is possible we'll hit an EA and try to recover for USER has
    // finished initializing.  Therefore the VideoPortCallout may fail
    // with a STATUS_INVALID_HANDLE.  We'll keep trying (with a delay)
    // until we get a different status code.
    //

    do {

        VideoPortCallout(&Params);

        if (Params.Status == STATUS_INVALID_HANDLE) {

            ZwYieldExecution();
        }

    } while (Params.Status == STATUS_INVALID_HANDLE);

    PsTerminateSystemThread(STATUS_SUCCESS);
}


VOID
HandleStuckThreadException(
    PLDEV pldev
    )

/*++

    Wake up a user mode thread waiting to reset the display resolution.

--*/

{
    PKEVENT StuckThreadEvent;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    HANDLE ThreadHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    //
    // First disable all entries in the dispatch table in the pldev.  This
    // way we can stop future threads from entring the driver.
    //

    pldev->bThreadStuck = TRUE;

    //
    // Replacd the DrvGetModes function for the driver such that the
    // driver reports no modes!
    //

    pldev->apfn[INDEX_DrvGetModes] = (PFN) WatchdogDrvGetModesEmpty;

    //
    // Remove non-vga device from graphics device list to stop the
    // system from trying to continue using the current device.
    //
    // What do we do about multi-mon?
    //

    DrvPrepareForEARecovery();

    //
    // Create a thread to do the work of changing the display resolution.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = PsCreateSystemThread(&ThreadHandle,
                                  (ACCESS_MASK) 0,
                                  &ObjectAttributes,
                                  NtCurrentProcess(),
                                  NULL,
                                  WatchdogRecoveryThread,
                                  NULL);

    if (NT_SUCCESS(Status) == TRUE) {

        ZwClose(ThreadHandle);

    } else {

        DbgPrint("Warning, we failed to create the Recovery Thread\n");
    }

    //
    // Clean up any pending drivers locks that this thread is holding
    //

    GreFreeSemaphoresForCurrentThread();
}

DHPDEV APIENTRY
WatchdogDrvEnablePDEV(
    DEVMODEW *pdm,
    LPWSTR    pwszLogAddress,
    ULONG     cPat,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pdi,
    HDEV      hdev,
    LPWSTR    pwszDeviceName,
    HANDLE    hDriver
    )

{
    PDEV *ppdev = (PDEV *)hdev;
    DHPDEV dhpdevRet = NULL;

    if (ppdev->pldev->bThreadStuck == FALSE) {

        PFN_DrvEnablePDEV pfn = (PFN_DrvEnablePDEV) ppdev->pldev->apfnDriver[INDEX_DrvEnablePDEV];
        PASSOCIATION_NODE Node = AssociationCreateNode();

        if (Node) {

            Node->data = (ULONG_PTR)ppdev->pldev;
            Node->key = NULL;

            __try {

                Node->key = (ULONG_PTR)pfn(pdm,
                                           pwszLogAddress,
                                           cPat,
                                           phsurfPatterns,
                                           cjCaps,
                                           (GDIINFO *)pdevcaps,
                                           cjDevInfo,
                                           pdi,
                                           hdev,
                                           pwszDeviceName,
                                           hDriver);

            } __except(GetExceptionCode() == SE_THREAD_STUCK) {

                //
                // Handle stuck thread excepton
                //

                HandleStuckThreadException(ppdev->pldev);
            }

            if (Node->key) {

                dhpdevRet = (DHPDEV) Node->key;

                AssociationInsertNode(Node);

            } else {

                AssociationDeleteNode(Node);
            }
        }
    }

    return dhpdevRet;
}

VOID APIENTRY
WatchdogDrvCompletePDEV(
    DHPDEV dhpdev,
    HDEV hdev
    )

{
    PFN_DrvCompletePDEV pfn = (PFN_DrvCompletePDEV) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvCompletePDEV);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev, hdev);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }
}

VOID APIENTRY
WatchdogDrvDisablePDEV(
    DHPDEV dhpdev
    )

{
    PFN_DrvDisablePDEV pfn = (PFN_DrvDisablePDEV) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvDisablePDEV);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    AssociationDeleteNode(AssociationRemoveNode((ULONG_PTR)dhpdev));
}

HSURF APIENTRY
WatchdogDrvEnableSurface(
    DHPDEV dhpdev
    )

{
    PFN_DrvEnableSurface pfn = (PFN_DrvEnableSurface) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvEnableSurface);
    HSURF hsurfRet = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return NULL;
    }

    __try {

        hsurfRet = pfn(dhpdev);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return hsurfRet;
}

VOID APIENTRY
WatchdogDrvDisableSurface(
    DHPDEV dhpdev
    )

{
    PFN_DrvDisableSurface pfn = (PFN_DrvDisableSurface) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvDisableSurface);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

}

BOOL APIENTRY
WatchdogDrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable
    )

{
    PFN_DrvAssertMode pfn = (PFN_DrvAssertMode) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvAssertMode);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(dhpdev, bEnable);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvResetPDEV(
    DHPDEV dhpdevOld,
    DHPDEV dhpdevNew
    )

{
    PFN_DrvResetPDEV pfn = (PFN_DrvResetPDEV) dhpdevRetrievePfn((ULONG_PTR)dhpdevOld,INDEX_DrvResetPDEV);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdevOld)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(dhpdevOld, dhpdevNew);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdevOld));
    }

    return bRet;
}

HBITMAP APIENTRY
WatchdogDrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
    )

{
    PFN_DrvCreateDeviceBitmap pfn = (PFN_DrvCreateDeviceBitmap) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvCreateDeviceBitmap);
    HBITMAP hbitmapRet = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck == FALSE) {

        PASSOCIATION_NODE Node = AssociationCreateNode();

        if (Node) {

            __try {

                hbitmapRet = pfn(dhpdev, sizl, iFormat);

            } __except(GetExceptionCode() == SE_THREAD_STUCK) {

                //
                // Handle stuck thread excepton
                //

                HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
            }

            if (hbitmapRet && ((ULONG_PTR)hbitmapRet != -1)) {

                //
                // Get the DHSURF that is associated with the hbitmap, and
                // cache it away so we can look it up when a DrvDeleteDeviceBitmap
                // call comes down.
                //

                SURFREF so;

                so.vAltCheckLockIgnoreStockBit((HSURF)hbitmapRet);

                Node->key = (ULONG_PTR)so.ps->dhsurf();
		Node->data = (ULONG_PTR)dhpdevRetrieveLdev(dhpdev);
		Node->hsurf = (ULONG_PTR)hbitmapRet;

                //
                // If an association node already exists, with this association
                // then use it.
                //

		if (AssociationIsNodeInList(Node) == FALSE) {

                    AssociationInsertNodeAtTail(Node);

                } else {

                    AssociationDeleteNode(Node);
                }

            } else {

                AssociationDeleteNode(Node);
            }
        }
    }

    return hbitmapRet;
}

VOID APIENTRY
WatchdogDrvDeleteDeviceBitmap(
    IN DHSURF dhsurf
    )

{
    PFN_DrvDeleteDeviceBitmap pfn = (PFN_DrvDeleteDeviceBitmap) dhpdevRetrievePfn((ULONG_PTR)dhsurf,INDEX_DrvDeleteDeviceBitmap);

    if (dhpdevRetrieveLdev((DHPDEV)dhsurf)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhsurf);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)dhsurf));
    }

    AssociationDeleteNode(AssociationRemoveNode((ULONG_PTR)dhsurf));
}

BOOL APIENTRY
WatchdogDrvRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    )

{
    PFN_DrvRealizeBrush pfn = (PFN_DrvRealizeBrush) dhpdevRetrievePfn((ULONG_PTR)psoTarget->dhpdev,INDEX_DrvRealizeBrush);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoTarget->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pbo, psoTarget, psoPattern, psoMask, pxlo, iHatch);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoTarget->dhpdev));
    }

    return bRet;
}

ULONG APIENTRY
WatchdogDrvDitherColor(
    DHPDEV dhpdev,
    ULONG iMode,
    ULONG rgb,
    ULONG *pul
    )

{
    PFN_DrvDitherColor pfn = (PFN_DrvDitherColor) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvDitherColor);
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        ulRet = pfn(dhpdev, iMode, rgb, pul);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return ulRet;
}

BOOL APIENTRY
WatchdogDrvStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX       mix
    )

{
    PFN_DrvStrokePath pfn = (PFN_DrvStrokePath) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvStrokePath);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs, mix);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;
}


BOOL APIENTRY
WatchdogDrvFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )

{
    PFN_DrvFillPath pfn = (PFN_DrvFillPath) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvFillPath);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX       mixFill,
    FLONG     flOptions
    )

{
    PFN_DrvStrokeAndFillPath pfn = (PFN_DrvStrokeAndFillPath) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvStrokeAndFillPath);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pso, ppo, pco, pxo, pboStroke, plineattrs, pboFill, pptlBrushOrg, mixFill, flOptions);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvBitBlt(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4     rop4
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PFN_DrvBitBlt pfn = (PFN_DrvBitBlt) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvBitBlt);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvCopyBits(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PFN_DrvCopyBits pfn = (PFN_DrvCopyBits) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvCopyBits);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PFN_DrvStretchBlt pfn = (PFN_DrvStretchBlt) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvStretchBlt);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

ULONG APIENTRY
WatchdogDrvSetPalette(
    DHPDEV dhpdev,
    PALOBJ *ppalo,
    FLONG  fl,
    ULONG  iStart,
    ULONG  cColors
    )

{
    PFN_DrvSetPalette pfn = (PFN_DrvSetPalette) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvSetPalette);
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        ulRet = pfn(dhpdev, ppalo, fl, iStart, cColors);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return ulRet;
}

BOOL APIENTRY
WatchdogDrvTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )

{
    PFN_DrvTextOut pfn = (PFN_DrvTextOut) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvTextOut);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;

}

ULONG APIENTRY
WatchdogDrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )

{
    PFN_DrvEscape pfn = (PFN_DrvEscape) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvEscape);
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        ulRet = pfn(pso, iEsc, cjIn, pvIn, cjOut, pvOut);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return ulRet;
}

ULONG APIENTRY
WatchdogDrvDrawEscape(
    IN SURFOBJ *pso,
    IN ULONG iEsc,
    IN CLIPOBJ *pco,
    IN RECTL *prcl,
    IN ULONG cjIn,
    IN PVOID pvIn
    )

{
    PFN_DrvDrawEscape pfn = (PFN_DrvDrawEscape) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvDrawEscape);
    ULONG ulRet = -1;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return -1;
    }

    __try {

        ulRet = pfn(pso, iEsc, pco, prcl, cjIn, pvIn);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return ulRet;

}

ULONG APIENTRY
WatchdogDrvSetPointerShape(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
    )

{
    PFN_DrvSetPointerShape pfn = (PFN_DrvSetPointerShape) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvSetPointerShape);
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        ulRet = pfn(pso, psoMask, psoColor, pxlo, xHot, yHot, x, y, prcl, fl);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return ulRet;
}

VOID APIENTRY
WatchdogDrvMovePointer(
    SURFOBJ  *pso,
    LONG      x,
    LONG      y,
    RECTL    *prcl
    )

{
    PFN_DrvMovePointer pfn = (PFN_DrvMovePointer) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvMovePointer);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(pso, x, y, prcl);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }
}

BOOL APIENTRY
WatchdogDrvLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )

{
    PFN_DrvLineTo pfn = (PFN_DrvLineTo) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvLineTo);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;
}

VOID APIENTRY
WatchdogDrvSynchronize(
    DHPDEV dhpdev,
    RECTL *prcl
    )

{
    PFN_DrvSynchronize pfn = (PFN_DrvSynchronize) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvSynchronize);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev, prcl);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }
}

ULONG_PTR APIENTRY
WatchdogDrvSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl
    )

{
    PFN_DrvSaveScreenBits pfn = (PFN_DrvSaveScreenBits) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvSaveScreenBits);
    ULONG_PTR ulptrRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        ulptrRet = pfn(pso, iMode, ident, prcl);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return ulptrRet;
}

DWORD APIENTRY
WatchdogDrvSetPixelFormat(
    IN SURFOBJ *pso,
    IN LONG iPixelFormat,
    IN HWND hwnd
    )

{
    PFN_DrvSetPixelFormat pfn = (PFN_DrvSetPixelFormat) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvSetPixelFormat);
    DWORD dwRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(pso, iPixelFormat, hwnd);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return dwRet;
}

LONG APIENTRY
WatchdogDrvDescribePixelFormat(
    IN DHPDEV dhpdev,
    IN LONG iPixelFormat,
    IN ULONG cjpdf,
    OUT PIXELFORMATDESCRIPTOR *ppfd
    )

{
    PFN_DrvDescribePixelFormat pfn = (PFN_DrvDescribePixelFormat) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvDescribePixelFormat);
    LONG lRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        lRet = pfn(dhpdev, iPixelFormat, cjpdf, ppfd);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return lRet;
}

BOOL APIENTRY
WatchdogDrvSwapBuffers(
    IN SURFOBJ *pso,
    IN WNDOBJ *pwo
    )

{
    PFN_DrvSwapBuffers pfn = (PFN_DrvSwapBuffers) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev,INDEX_DrvSwapBuffers);
    BOOL bRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        bRet = pfn(pso, pwo);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }

    return bRet;
}

DWORD APIENTRY
WatchdogDdContextCreate(
    LPD3DNTHAL_CONTEXTCREATEDATA pccd
    )

{
    PLDEV pldev = (PLDEV)AssociationRetrieveData((ULONG_PTR)pccd->lpDDLcl->lpGbl->dhpdev);
    LPD3DNTHAL_CONTEXTCREATECB pfn = (LPD3DNTHAL_CONTEXTCREATECB) pldev->apfnDriver[INDEX_DdContextCreate];
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    PCONTEXT_NODE Node;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    Node = (PCONTEXT_NODE)PALLOCMEM(sizeof(ASSOCIATION_NODE), GDITAG_DRVSUP);

    if (Node) {

        __try {

            dwRet = pfn(pccd);

        } __except(GetExceptionCode() == SE_THREAD_STUCK) {

            HandleStuckThreadException(pldev);
        }

        if (dwRet == DDHAL_DRIVER_HANDLED) {

            //
            // Store the dwhContext and the associated dhpdev
            //

            Node->Context = (PVOID)pccd->dwhContext;
            Node->pldev = pldev;

            pccd->dwhContext = (DWORD_PTR)Node;

        } else {

            VFREEMEM(Node);
        }
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdContextDestroy(
    LPD3DNTHAL_CONTEXTDESTROYDATA pcdd
    )

{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) pcdd->dwhContext;
    LPD3DNTHAL_CONTEXTDESTROYCB pfn = (LPD3DNTHAL_CONTEXTDESTROYCB) Node->pldev->apfnDriver[INDEX_DdContextDestroy];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (Node->pldev->bThreadStuck) {
        return 0;
    }

    //
    // Restore driver created context
    //

    pcdd->dwhContext = (DWORD_PTR) Node->Context;

    __try {

        dwRet = pfn(pcdd);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)pcdd->dwhContext));
    }

    //
    // Resore our context, just in case this stucture is re-used
    //

    pcdd->dwhContext = (DWORD_PTR) Node;

    if (dwRet == DDHAL_DRIVER_HANDLED) {

        VFREEMEM(Node);
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCanCreateSurface(
    PDD_CANCREATESURFACEDATA lpCanCreateSurface
    )

{
    PDD_CANCREATESURFACE pfn = (PDD_CANCREATESURFACE) dhpdevRetrievePfn((ULONG_PTR)lpCanCreateSurface->lpDD->dhpdev,INDEX_DdCanCreateSurface);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpCanCreateSurface->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpCanCreateSurface);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpCanCreateSurface->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreateSurface(
    PDD_CREATESURFACEDATA lpCreateSurface
    )

{
    PDD_CREATESURFACE pfn = (PDD_CREATESURFACE) dhpdevRetrievePfn((ULONG_PTR)lpCreateSurface->lpDD->dhpdev,INDEX_DdCreateSurface);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpCreateSurface->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpCreateSurface);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpCreateSurface->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdDestroySurface(
    PDD_DESTROYSURFACEDATA lpDestroySurface
    )

{
    PDD_SURFCB_DESTROYSURFACE pfn = (PDD_SURFCB_DESTROYSURFACE) dhpdevRetrievePfn((ULONG_PTR)lpDestroySurface->lpDD->dhpdev,INDEX_DdDestroySurface);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpDestroySurface->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpDestroySurface);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpDestroySurface->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdLockSurface(
    PDD_LOCKDATA lpLockSurface
    )

{
    PDD_SURFCB_LOCK pfn = (PDD_SURFCB_LOCK) dhpdevRetrievePfn((ULONG_PTR)lpLockSurface->lpDD->dhpdev,INDEX_DdLockSurface);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpLockSurface->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpLockSurface);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpLockSurface->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdUnlockSurface(
    PDD_UNLOCKDATA lpUnlockSurface
    )

{
    PDD_SURFCB_UNLOCK pfn = (PDD_SURFCB_UNLOCK) dhpdevRetrievePfn((ULONG_PTR)lpUnlockSurface->lpDD->dhpdev,INDEX_DdUnlockSurface);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpUnlockSurface->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpUnlockSurface);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpUnlockSurface->lpDD->dhpdev));
    }

    return dwRet;
}

#if 0

//
// I'm not sure how I can hook this one since a DD_DRVSETCOLORKEYDATA
// structure doesn't have a way to look up the dhpdev!
//

DWORD APIENTRY
WatchdogDdSetColorKey(
    PDD_DRVSETCOLORKEYDATA lpSetColorKey
    )

{
    PDD_SURFCB_SETCOLORKEY pfn = (PDD_SURFCB_SETCOLORKEY)dhpdevRetrievePfn((ULONG_PTR)lpSetColorKey->lpDD->dhpdev,INDEX_DdSetColorKey);
    DWORD dwRet;

    __try {

        dwRet = pfn(lpSetColorKey);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException();
    }

    return dwRet;
}
#endif

DWORD APIENTRY
WatchdogDdGetScanLine(
    PDD_GETSCANLINEDATA pGetScanLine
    )

{
    PDD_GETSCANLINE pfn = (PDD_GETSCANLINE)dhpdevRetrievePfn((ULONG_PTR)pGetScanLine->lpDD->dhpdev,INDEX_DdGetScanLine);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)pGetScanLine->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(pGetScanLine);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)pGetScanLine->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreatePalette(
    PDD_CREATEPALETTEDATA lpCreatePalette
    )

{
    PDD_CREATEPALETTE pfn = (PDD_CREATEPALETTE) dhpdevRetrievePfn((ULONG_PTR)lpCreatePalette->lpDD->dhpdev,INDEX_DdCreatePalette);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpCreatePalette->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpCreatePalette);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpCreatePalette->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdMapMemory(
    PDD_MAPMEMORYDATA lpMapMemory
    )

{
    PDD_MAPMEMORY pfn = (PDD_MAPMEMORY) dhpdevRetrievePfn((ULONG_PTR)lpMapMemory->lpDD->dhpdev,INDEX_DdMapMemory);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpMapMemory->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpMapMemory);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpMapMemory->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdWaitForVerticalBlank(
    PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank
    )

{
    PDD_WAITFORVERTICALBLANK pfn = (PDD_WAITFORVERTICALBLANK) dhpdevRetrievePfn((ULONG_PTR)lpWaitForVerticalBlank->lpDD->dhpdev,INDEX_DdWaitForVerticalBlank);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpWaitForVerticalBlank->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpWaitForVerticalBlank);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpWaitForVerticalBlank->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdFlip(
    PDD_FLIPDATA lpFlip
    )

{
    PDD_SURFCB_FLIP pfn = (PDD_SURFCB_FLIP) dhpdevRetrievePfn((ULONG_PTR)lpFlip->lpDD->dhpdev,INDEX_DdFlip);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpFlip->lpDD->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpFlip);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpFlip->lpDD->dhpdev));
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetDriverState(
    PDD_GETDRIVERSTATEDATA pgdsd
    )

{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) pgdsd->dwhContext;
    PDD_GETDRIVERSTATE pfn = (PDD_GETDRIVERSTATE) Node->pldev->apfnDriver[INDEX_DdGetDriverState];
    DWORD dwRet = 0;

    //
    // how can I validate if I created this dwhcontext?
    //

    if (pfn == NULL) {
        pgdsd->ddRVal = D3DNTHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }

    if (Node->pldev->bThreadStuck) {
        return 0;
    }

    //
    // restore original context
    //

    pgdsd->dwhContext = (DWORD_PTR) Node->Context;

    __try {

        dwRet = pfn(pgdsd);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(Node->pldev);
    }

    //
    // save our context again in case this structure is re-used
    //

    pgdsd->dwhContext = (DWORD_PTR) Node;

    return dwRet;
}

//
// TODO: I don't think I want to check in with this macro to build
// functions, but for now lets use it.
//

#define BUILD_FUNCTION_1(Func, ArgType, FuncType) \
DWORD APIENTRY \
WatchdogDd##Func( \
    ArgType lp##Func) \
{ \
    FuncType pfn = (FuncType) dhpdevRetrievePfn((ULONG_PTR)lp##Func->lpDD->dhpdev,INDEX_Dd##Func); \
    DWORD dwRet = 0; \
    \
    if (dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDD->dhpdev)->bThreadStuck) { \
        return 0; \
    } \
    \
    __try { \
    \
        dwRet = pfn(lp##Func); \
    \
    } __except(GetExceptionCode() == SE_THREAD_STUCK) {\
    \
        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDD->dhpdev));\
    \
    }\
    \
    return dwRet;\
}

#define BUILD_FUNCTION_2(Func, ArgType, FuncType) \
DWORD APIENTRY \
WatchdogDd##Func( \
    ArgType lp##Func) \
{ \
    PCONTEXT_NODE Node = (PCONTEXT_NODE) lp##Func->dwhContext; \
    FuncType pfn = (FuncType) Node->pldev->apfnDriver[INDEX_Dd##Func]; \
    DWORD dwRet = 0; \
    \
    if (pfn == NULL) {\
        lp##Func->ddrval = D3DNTHAL_CONTEXT_BAD; \
        return DDHAL_DRIVER_HANDLED; \
    }\
    \
    if (Node->pldev->bThreadStuck) { \
        return 0; \
    } \
    \
    lp##Func->dwhContext = (DWORD_PTR) Node->Context; \
    \
    __try { \
    \
        dwRet = pfn(lp##Func); \
    \
    } __except(GetExceptionCode() == SE_THREAD_STUCK) {\
    \
        HandleStuckThreadException(Node->pldev);\
    \
    }\
    \
    lp##Func->dwhContext = (DWORD_PTR) Node; \
    \
    return dwRet;\
}

#define BUILD_FUNCTION_3(Func, ArgType, FuncType) \
DWORD APIENTRY \
WatchdogDd##Func( \
    ArgType lp##Func) \
{ \
    FuncType pfn = (FuncType) dhpdevRetrievePfn((ULONG_PTR)lp##Func->lpDD->lpGbl->dhpdev,INDEX_Dd##Func); \
    DWORD dwRet = 0; \
    \
    if (dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDD->lpGbl->dhpdev)->bThreadStuck) { \
        return 0; \
    } \
    \
    __try { \
    \
        dwRet = pfn(lp##Func); \
    \
    } __except(GetExceptionCode() == SE_THREAD_STUCK) {\
    \
        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDD->lpGbl->dhpdev));\
    \
    }\
    \
    return dwRet;\
}

#define BUILD_FUNCTION_4(Func, ArgType, FuncType) \
DWORD APIENTRY \
WatchdogDd##Func( \
    ArgType lp##Func) \
{ \
    FuncType pfn = (FuncType) dhpdevRetrievePfn((ULONG_PTR)lp##Func->lpDDLcl->lpGbl->dhpdev,INDEX_Dd##Func); \
    DWORD dwRet = 0; \
    \
    if (dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDDLcl->lpGbl->dhpdev)->bThreadStuck) { \
        return 0; \
    } \
    \
    __try { \
    \
        dwRet = pfn(lp##Func); \
    \
    } __except(GetExceptionCode() == SE_THREAD_STUCK) {\
    \
        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lp##Func->lpDDLcl->lpGbl->dhpdev));\
    \
    }\
    \
    return dwRet;\
}

#define BUILD_FUNCTION_5(Func, ArgType, FuncType) \
DWORD APIENTRY \
WatchdogDd##Func( \
    ArgType lp##Func) \
{ \
    FuncType pfn = (FuncType) dhpdevRetrievePfn((ULONG_PTR)lp##Func->pDDLcl->lpGbl->dhpdev,INDEX_Dd##Func); \
    DWORD dwRet = 0; \
    \
    if (dhpdevRetrieveLdev((DHPDEV)lp##Func->pDDLcl->lpGbl->dhpdev)->bThreadStuck) { \
        return 0; \
    } \
    \
    __try { \
    \
        dwRet = pfn(lp##Func); \
    \
    } __except(GetExceptionCode() == SE_THREAD_STUCK) {\
    \
        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lp##Func->pDDLcl->lpGbl->dhpdev));\
    \
    }\
    \
    return dwRet;\
}


BUILD_FUNCTION_1(Lock, PDD_LOCKDATA, PDD_SURFCB_LOCK);
BUILD_FUNCTION_1(Unlock, PDD_UNLOCKDATA, PDD_SURFCB_UNLOCK);
BUILD_FUNCTION_1(Blt, PDD_BLTDATA, PDD_SURFCB_BLT);
BUILD_FUNCTION_1(AddAttachedSurface, PDD_ADDATTACHEDSURFACEDATA, PDD_SURFCB_ADDATTACHEDSURFACE);
BUILD_FUNCTION_1(GetBltStatus, PDD_GETBLTSTATUSDATA, PDD_SURFCB_GETBLTSTATUS);
BUILD_FUNCTION_1(GetFlipStatus, PDD_GETFLIPSTATUSDATA, PDD_SURFCB_GETFLIPSTATUS);
BUILD_FUNCTION_1(UpdateOverlay, PDD_UPDATEOVERLAYDATA, PDD_SURFCB_UPDATEOVERLAY);
BUILD_FUNCTION_1(SetOverlayPosition, PDD_SETOVERLAYPOSITIONDATA, PDD_SURFCB_SETOVERLAYPOSITION);
BUILD_FUNCTION_1(SetPalette, PDD_SETPALETTEDATA, PDD_SURFCB_SETPALETTE);
BUILD_FUNCTION_1(DestroyPalette, PDD_DESTROYPALETTEDATA, PDD_PALCB_DESTROYPALETTE);
BUILD_FUNCTION_1(SetEntries, PDD_SETENTRIESDATA, PDD_PALCB_SETENTRIES);
BUILD_FUNCTION_1(ColorControl, PDD_COLORCONTROLDATA, PDD_COLORCB_COLORCONTROL);
BUILD_FUNCTION_1(CanCreateD3DBuffer, PDD_CANCREATESURFACEDATA, PDD_CANCREATESURFACE);
BUILD_FUNCTION_1(CreateD3DBuffer, PDD_CREATESURFACEDATA, PDD_CREATESURFACE);
BUILD_FUNCTION_1(DestroyD3DBuffer, PDD_DESTROYSURFACEDATA, PDD_SURFCB_DESTROYSURFACE);
BUILD_FUNCTION_1(LockD3DBuffer, PDD_LOCKDATA, PDD_SURFCB_LOCK);
BUILD_FUNCTION_1(UnlockD3DBuffer, PDD_UNLOCKDATA, PDD_SURFCB_UNLOCK);
BUILD_FUNCTION_1(GetAvailDriverMemory, PDD_GETAVAILDRIVERMEMORYDATA, PDD_GETAVAILDRIVERMEMORY);
BUILD_FUNCTION_1(AlphaBlt, PDD_BLTDATA, PDD_ALPHABLT);

BUILD_FUNCTION_2(DrawPrimitives2, LPD3DNTHAL_DRAWPRIMITIVES2DATA, LPD3DNTHAL_DRAWPRIMITIVES2CB);
BUILD_FUNCTION_2(ValidateTextureStageState, LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA, LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB);

BUILD_FUNCTION_3(SyncSurfaceData, PDD_SYNCSURFACEDATA, PDD_KERNELCB_SYNCSURFACE);
BUILD_FUNCTION_3(SyncVideoPortData, PDD_SYNCVIDEOPORTDATA, PDD_KERNELCB_SYNCVIDEOPORT);

BUILD_FUNCTION_4(CreateSurfaceEx, PDD_CREATESURFACEEXDATA, PDD_CREATESURFACEEX);

BUILD_FUNCTION_5(DestroyDDLocal, PDD_DESTROYDDLOCALDATA, PDD_DESTROYDDLOCAL);

BUILD_FUNCTION_1(FreeDriverMemory, PDD_FREEDRIVERMEMORYDATA, PDD_FREEDRIVERMEMORY);
BUILD_FUNCTION_1(SetExclusiveMode, PDD_SETEXCLUSIVEMODEDATA, PDD_SETEXCLUSIVEMODE);
BUILD_FUNCTION_1(FlipToGDISurface, PDD_FLIPTOGDISURFACEDATA, PDD_FLIPTOGDISURFACE);

DWORD APIENTRY
WatchdogDdGetDriverInfo(
    PDD_GETDRIVERINFODATA lpGetDriverInfo
    )

{
    PDD_GETDRIVERINFO pfn = (PDD_GETDRIVERINFO) dhpdevRetrievePfn((ULONG_PTR)lpGetDriverInfo->dhpdev,INDEX_DdGetDriverInfo);
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)lpGetDriverInfo->dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        dwRet = pfn(lpGetDriverInfo);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)lpGetDriverInfo->dhpdev));
    }

    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
        (lpGetDriverInfo->ddRVal == DD_OK)) {

        PLDEV pldev = dhpdevRetrieveLdev((DHPDEV)lpGetDriverInfo->dhpdev);

        if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_ColorControlCallbacks)) {

            PDD_COLORCONTROLCALLBACKS Callbacks = (PDD_COLORCONTROLCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_COLOR_COLORCONTROL) {

                if (Callbacks->ColorControl != WatchdogDdColorControl) {
                    pldev->apfnDriver[INDEX_DdColorControl] = (PFN)Callbacks->ColorControl;
                }
                Callbacks->ColorControl = WatchdogDdColorControl;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_D3DCallbacks)) {

            LPD3DNTHAL_CALLBACKS Callbacks = (LPD3DNTHAL_CALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->ContextCreate) {

                if (Callbacks->ContextCreate != WatchdogDdContextCreate) {
                    pldev->apfnDriver[INDEX_DdContextCreate] = (PFN)Callbacks->ContextCreate;
                }
                Callbacks->ContextCreate = WatchdogDdContextCreate;
            }

            if (Callbacks->ContextDestroy) {

                if (Callbacks->ContextDestroy != WatchdogDdContextDestroy) {
                    pldev->apfnDriver[INDEX_DdContextDestroy] = (PFN)Callbacks->ContextDestroy;
                }
                Callbacks->ContextDestroy = WatchdogDdContextDestroy;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_D3DCallbacks3)) {

            LPD3DNTHAL_CALLBACKS3 Callbacks = (LPD3DNTHAL_CALLBACKS3) lpGetDriverInfo->lpvData;

            if (Callbacks->DrawPrimitives2) {

                if (Callbacks->DrawPrimitives2 != WatchdogDdDrawPrimitives2) {
                    pldev->apfnDriver[INDEX_DdDrawPrimitives2] = (PFN)Callbacks->DrawPrimitives2;
                }
                Callbacks->DrawPrimitives2 = WatchdogDdDrawPrimitives2;
            }

            if (Callbacks->ValidateTextureStageState) {

                if (Callbacks->ValidateTextureStageState != WatchdogDdValidateTextureStageState) {
                    pldev->apfnDriver[INDEX_DdValidateTextureStageState] = (PFN)Callbacks->ValidateTextureStageState;
                }
                Callbacks->ValidateTextureStageState = WatchdogDdValidateTextureStageState;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_KernelCallbacks)) {

            PDD_KERNELCALLBACKS Callbacks = (PDD_KERNELCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_KERNEL_SYNCSURFACEDATA) {

                if (Callbacks->SyncSurfaceData != WatchdogDdSyncSurfaceData) {
                    pldev->apfnDriver[INDEX_DdSyncSurfaceData] = (PFN)Callbacks->SyncSurfaceData;
                }
                Callbacks->SyncSurfaceData = WatchdogDdSyncSurfaceData;
            }

            if (Callbacks->dwFlags & DDHAL_KERNEL_SYNCVIDEOPORTDATA) {

                if (Callbacks->SyncVideoPortData != WatchdogDdSyncVideoPortData) {
                    pldev->apfnDriver[INDEX_DdSyncVideoPortData] = (PFN)Callbacks->SyncVideoPortData;
                }
                Callbacks->SyncVideoPortData = WatchdogDdSyncVideoPortData;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_MiscellaneousCallbacks)) {

            PDD_MISCELLANEOUSCALLBACKS Callbacks = (PDD_MISCELLANEOUSCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_MISCCB32_GETAVAILDRIVERMEMORY) {

                if (Callbacks->GetAvailDriverMemory != WatchdogDdGetAvailDriverMemory) {
                    pldev->apfnDriver[INDEX_DdGetAvailDriverMemory] = (PFN)Callbacks->GetAvailDriverMemory;
                }
                Callbacks->GetAvailDriverMemory = WatchdogDdGetAvailDriverMemory;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_Miscellaneous2Callbacks)) {

            PDD_MISCELLANEOUS2CALLBACKS Callbacks = (PDD_MISCELLANEOUS2CALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_ALPHABLT) {

                if (Callbacks->AlphaBlt != WatchdogDdAlphaBlt) {
                    pldev->apfnDriver[INDEX_DdAlphaBlt] = (PFN)Callbacks->AlphaBlt;
                }
                Callbacks->AlphaBlt = WatchdogDdAlphaBlt;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_CREATESURFACEEX) {

                if (Callbacks->CreateSurfaceEx != WatchdogDdCreateSurfaceEx) {
                    pldev->apfnDriver[INDEX_DdCreateSurfaceEx] = (PFN)Callbacks->CreateSurfaceEx;
                }
                Callbacks->CreateSurfaceEx = WatchdogDdCreateSurfaceEx;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_GETDRIVERSTATE) {

                if (Callbacks->GetDriverState != WatchdogDdGetDriverState) {
                    pldev->apfnDriver[INDEX_DdGetDriverState] = (PFN)Callbacks->GetDriverState;
                }
                Callbacks->GetDriverState = WatchdogDdGetDriverState;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_DESTROYDDLOCAL) {

                if (Callbacks->DestroyDDLocal != WatchdogDdDestroyDDLocal) {
                    pldev->apfnDriver[INDEX_DdDestroyDDLocal] = (PFN)Callbacks->DestroyDDLocal;
                }
                Callbacks->DestroyDDLocal = WatchdogDdDestroyDDLocal;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_MotionCompCallbacks)) {

            //
            // TODO: Still need to implement
            //

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_NTCallbacks)) {

            PDD_NTCALLBACKS Callbacks = (PDD_NTCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_NTCB32_FREEDRIVERMEMORY) {

                if (Callbacks->FreeDriverMemory != WatchdogDdFreeDriverMemory) {
                    pldev->apfnDriver[INDEX_DdFreeDriverMemory] = (PFN)Callbacks->FreeDriverMemory;
                }
                Callbacks->FreeDriverMemory = WatchdogDdFreeDriverMemory;
            }

            if (Callbacks->dwFlags & DDHAL_NTCB32_SETEXCLUSIVEMODE) {

                if (Callbacks->SetExclusiveMode != WatchdogDdSetExclusiveMode) {
                    pldev->apfnDriver[INDEX_DdSetExclusiveMode] = (PFN)Callbacks->SetExclusiveMode;
                }
                Callbacks->SetExclusiveMode = WatchdogDdSetExclusiveMode;
            }

            if (Callbacks->dwFlags & DDHAL_NTCB32_FLIPTOGDISURFACE) {

                if (Callbacks->FlipToGDISurface != WatchdogDdFlipToGDISurface) {
                    pldev->apfnDriver[INDEX_DdFlipToGDISurface] = (PFN)Callbacks->FlipToGDISurface;
                }
                Callbacks->FlipToGDISurface = WatchdogDdFlipToGDISurface;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_VideoPortCallbacks)) {

            //
            // TODO: Still need to implement
            //
        }
    }

    return dwRet;
}

BOOL APIENTRY
WatchdogDrvGetDirectDrawInfo(
    DHPDEV        dhpdev,
    DD_HALINFO   *pHalInfo,
    DWORD        *pdwNumHeaps,
    VIDEOMEMORY  *pvmList,
    DWORD        *pdwNumFourCCCodes,
    DWORD        *pdwFourCC
    )

{
    PFN_DrvGetDirectDrawInfo pfn = (PFN_DrvGetDirectDrawInfo) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvGetDirectDrawInfo);
    BOOL bRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return 0;
    }

    __try {

        bRet = pfn(dhpdev, pHalInfo, pdwNumHeaps, pvmList, pdwNumFourCCCodes, pdwFourCC);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    //
    // If the function succeeded, then try to capture the DdGetDriverInfo
    // function from pHalInfo.
    //

    if (bRet) {

        PLDEV pldev = dhpdevRetrieveLdev(dhpdev);

        if (pHalInfo->GetDriverInfo) {

            if (pHalInfo->GetDriverInfo != WatchdogDdGetDriverInfo) {
                pldev->apfnDriver[INDEX_DdGetDriverInfo] = (PFN)pHalInfo->GetDriverInfo;
            }
            pHalInfo->GetDriverInfo = WatchdogDdGetDriverInfo;
        }

        if (pHalInfo->lpD3DHALCallbacks) {

            LPD3DNTHAL_CALLBACKS lpD3DHALCallbacks;

            lpD3DHALCallbacks = (LPD3DNTHAL_CALLBACKS)pHalInfo->lpD3DHALCallbacks;

            //
            // Create copy of D3DHALCallbacks info - This is done to safely 
            // latch the callbacks witout actually changing driver local data
            //
            
            memcpy(&pldev->D3DHALCallbacks, 
                   lpD3DHALCallbacks, 
                   min(sizeof(pldev->D3DHALCallbacks), lpD3DHALCallbacks->dwSize));

            pHalInfo->lpD3DHALCallbacks = lpD3DHALCallbacks = &pldev->D3DHALCallbacks;

            if (lpD3DHALCallbacks->ContextCreate &&
                lpD3DHALCallbacks->ContextDestroy) {

                if (lpD3DHALCallbacks->ContextCreate != WatchdogDdContextCreate) {
                    pldev->apfnDriver[INDEX_DdContextCreate] = (PFN)lpD3DHALCallbacks->ContextCreate;
                }

                if (lpD3DHALCallbacks->ContextDestroy != WatchdogDdContextDestroy) {
                    pldev->apfnDriver[INDEX_DdContextDestroy] = (PFN)lpD3DHALCallbacks->ContextDestroy;
                }

                lpD3DHALCallbacks->ContextCreate = WatchdogDdContextCreate;
                lpD3DHALCallbacks->ContextDestroy = WatchdogDdContextDestroy;
            }
        }

        if (pHalInfo->lpD3DBufCallbacks) {

            PDD_D3DBUFCALLBACKS lpD3DBufCallbacks;

            lpD3DBufCallbacks = pHalInfo->lpD3DBufCallbacks;

            //
            // Create copy of D3DBufCallbacks info - This is done to safely 
            // latch the callbacks witout actually changing driver local data
            //

            memcpy(&pldev->D3DBufCallbacks, 
                   lpD3DBufCallbacks, 
                   min(sizeof(pldev->D3DBufCallbacks), lpD3DBufCallbacks->dwSize));

            lpD3DBufCallbacks = pHalInfo->lpD3DBufCallbacks = &pldev->D3DBufCallbacks;

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, CanCreateD3DBuffer)) &&
                (lpD3DBufCallbacks->CanCreateD3DBuffer)) {

                if (lpD3DBufCallbacks->CanCreateD3DBuffer != WatchdogDdCanCreateD3DBuffer) {
                    pldev->apfnDriver[INDEX_DdCanCreateD3DBuffer] = (PFN)lpD3DBufCallbacks->CanCreateD3DBuffer;
                }
                lpD3DBufCallbacks->CanCreateD3DBuffer = WatchdogDdCanCreateD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, CreateD3DBuffer)) &&
                (lpD3DBufCallbacks->CreateD3DBuffer)) {

                if (lpD3DBufCallbacks->CreateD3DBuffer != WatchdogDdCreateD3DBuffer) {
                    pldev->apfnDriver[INDEX_DdCreateD3DBuffer] = (PFN)lpD3DBufCallbacks->CreateD3DBuffer;
                }
                lpD3DBufCallbacks->CreateD3DBuffer = WatchdogDdCreateD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, DestroyD3DBuffer)) &&
                (lpD3DBufCallbacks->DestroyD3DBuffer)) {

                if (lpD3DBufCallbacks->DestroyD3DBuffer != WatchdogDdDestroyD3DBuffer) {
                    pldev->apfnDriver[INDEX_DdDestroyD3DBuffer] = (PFN)lpD3DBufCallbacks->DestroyD3DBuffer;
                }
                lpD3DBufCallbacks->DestroyD3DBuffer = WatchdogDdDestroyD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, LockD3DBuffer)) &&
                (lpD3DBufCallbacks->LockD3DBuffer)) {

                if (lpD3DBufCallbacks->LockD3DBuffer != WatchdogDdLockD3DBuffer) {
                    pldev->apfnDriver[INDEX_DdLockD3DBuffer] = (PFN)lpD3DBufCallbacks->LockD3DBuffer;
                }
                lpD3DBufCallbacks->LockD3DBuffer = WatchdogDdLockD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, UnlockD3DBuffer)) &&
                (lpD3DBufCallbacks->UnlockD3DBuffer)) {

                if (lpD3DBufCallbacks->UnlockD3DBuffer != WatchdogDdUnlockD3DBuffer) {
                    pldev->apfnDriver[INDEX_DdUnlockD3DBuffer] = (PFN)lpD3DBufCallbacks->UnlockD3DBuffer;
                }
                lpD3DBufCallbacks->UnlockD3DBuffer = WatchdogDdUnlockD3DBuffer;
            }
        }
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvEnableDirectDraw(
    DHPDEV               dhpdev,
    DD_CALLBACKS        *pCallBacks,
    DD_SURFACECALLBACKS *pSurfaceCallBacks,
    DD_PALETTECALLBACKS *pPaletteCallBacks
    )

{
    PFN_DrvEnableDirectDraw pfn = (PFN_DrvEnableDirectDraw) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvEnableDirectDraw);
    BOOL bRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return FALSE;
    }

    __try {

        bRet = pfn(dhpdev, pCallBacks, pSurfaceCallBacks, pPaletteCallBacks);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    //
    // If the function succeeded, then try to capture the Callback functions.
    //

    if (bRet) {

        PLDEV pldev = dhpdevRetrieveLdev(dhpdev);

        //
        // Capture generic callbacks
        //

        if (pCallBacks->dwFlags & DDHAL_CB32_CANCREATESURFACE) {

            if (pCallBacks->CanCreateSurface != WatchdogDdCanCreateSurface) {
                pldev->apfnDriver[INDEX_DdCanCreateSurface] = (PFN)pCallBacks->CanCreateSurface;
            }
            pCallBacks->CanCreateSurface = WatchdogDdCanCreateSurface;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_CREATESURFACE) {

            if (pCallBacks->CreateSurface != WatchdogDdCreateSurface) {
                pldev->apfnDriver[INDEX_DdCreateSurface] = (PFN)pCallBacks->CreateSurface;
            }
            pCallBacks->CreateSurface = WatchdogDdCreateSurface;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_CREATEPALETTE) {

            if (pCallBacks->CreatePalette != WatchdogDdCreatePalette) {
                pldev->apfnDriver[INDEX_DdCreatePalette] = (PFN)pCallBacks->CreatePalette;
            }
            pCallBacks->CreatePalette = WatchdogDdCreatePalette;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_GETSCANLINE) {

            if (pCallBacks->GetScanLine != WatchdogDdGetScanLine) {
                pldev->apfnDriver[INDEX_DdGetScanLine] = (PFN)pCallBacks->GetScanLine;
            }
            pCallBacks->GetScanLine = WatchdogDdGetScanLine;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_MAPMEMORY) {

            if (pCallBacks->MapMemory != WatchdogDdMapMemory) {
                pldev->apfnDriver[INDEX_DdMapMemory] = (PFN)pCallBacks->MapMemory;
            }
            pCallBacks->MapMemory = WatchdogDdMapMemory;
        }

#if 0
        //
        // We can't hook this because there is no way to get the dhpdev
        // back
        //

        if (pCallBacks->dwFlags & DDHAL_CB32_SETCOLORKEY) {

            if (pCallBacks->SetColorKey != WatchdogDdSetColorKey) {
                pldev->apfnDriver[INDEX_DdSetColorKey] = (PFN)pCallBacks->SetColorKey;
            }
            pCallBacks->SetColorKey = WatchdogDdSetColorKey;
        }
#endif

        if (pCallBacks->dwFlags & DDHAL_CB32_WAITFORVERTICALBLANK) {

            if (pCallBacks->WaitForVerticalBlank != WatchdogDdWaitForVerticalBlank) {
                pldev->apfnDriver[INDEX_DdWaitForVerticalBlank] = (PFN)pCallBacks->WaitForVerticalBlank;
            }
            pCallBacks->WaitForVerticalBlank = WatchdogDdWaitForVerticalBlank;
        }

        //
        // Capture Surface Callbacks
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) {

            if (pSurfaceCallBacks->DestroySurface != WatchdogDdDestroySurface) {
                pldev->apfnDriver[INDEX_DdDestroySurface] = (PFN)pSurfaceCallBacks->DestroySurface;
            }
            pSurfaceCallBacks->DestroySurface = WatchdogDdDestroySurface;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_FLIP) {

            if (pSurfaceCallBacks->Flip != WatchdogDdFlip) {
                pldev->apfnDriver[INDEX_DdFlip] = (PFN)pSurfaceCallBacks->Flip;
            }
            pSurfaceCallBacks->Flip = WatchdogDdFlip;
        }

#if 0
        //
        // SetClipList is obsolete
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETCLIPLIST) {

            if (pSurfaceCallBacks->SetClipList != WatchdogDdSetClipList) {
                pldev->apfnDriver[INDEX_DdSetClipList] = (PFN)pSurfaceCallBacks->SetClipList;
            }
            pSurfaceCallBacks->SetClipList = WatchdogDdSetClipList;
        }
#endif

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_LOCK) {

            if (pSurfaceCallBacks->Lock != WatchdogDdLock) {
                pldev->apfnDriver[INDEX_DdLock] = (PFN)pSurfaceCallBacks->Lock;
            }
            pSurfaceCallBacks->Lock = WatchdogDdLock;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_UNLOCK) {

            if (pSurfaceCallBacks->Unlock != WatchdogDdUnlock) {
                pldev->apfnDriver[INDEX_DdUnlock] = (PFN)pSurfaceCallBacks->Unlock;
            }
            pSurfaceCallBacks->Unlock = WatchdogDdUnlock;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_BLT) {

            if (pSurfaceCallBacks->Blt != WatchdogDdBlt) {
                pldev->apfnDriver[INDEX_DdBlt] = (PFN)pSurfaceCallBacks->Blt;
            }
            pSurfaceCallBacks->Blt = WatchdogDdBlt;
        }

#if 0
        //
        // We can't hook this because there is no way to get the dhpdev
        // back
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETCOLORKEY) {

            if (pSurfaceCallBacks->SetColorKey != WatchdogDdSetColorKey) {
                pldev->apfnDriver[INDEX_DdSetColorKey] = (PFN)pSurfaceCallBacks->SetColorKey;
            }
            pSurfaceCallBacks->SetColorKey = WatchdogDdSetColorKey;
        }
#endif

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_ADDATTACHEDSURFACE) {

            if (pSurfaceCallBacks->AddAttachedSurface != WatchdogDdAddAttachedSurface) {
                pldev->apfnDriver[INDEX_DdAddAttachedSurface] = (PFN)pSurfaceCallBacks->AddAttachedSurface;
            }
            pSurfaceCallBacks->AddAttachedSurface = WatchdogDdAddAttachedSurface;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_GETBLTSTATUS) {

            if (pSurfaceCallBacks->GetBltStatus != WatchdogDdGetBltStatus) {
                pldev->apfnDriver[INDEX_DdGetBltStatus] = (PFN)pSurfaceCallBacks->GetBltStatus;
            }
            pSurfaceCallBacks->GetBltStatus = WatchdogDdGetBltStatus;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_GETFLIPSTATUS) {

            if (pSurfaceCallBacks->GetFlipStatus != WatchdogDdGetFlipStatus) {
                pldev->apfnDriver[INDEX_DdGetFlipStatus] = (PFN)pSurfaceCallBacks->GetFlipStatus;
            }
            pSurfaceCallBacks->GetFlipStatus = WatchdogDdGetFlipStatus;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_UPDATEOVERLAY) {

            if (pSurfaceCallBacks->UpdateOverlay != WatchdogDdUpdateOverlay) {
                pldev->apfnDriver[INDEX_DdUpdateOverlay] = (PFN)pSurfaceCallBacks->UpdateOverlay;
            }
            pSurfaceCallBacks->UpdateOverlay = WatchdogDdUpdateOverlay;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETOVERLAYPOSITION) {

            if (pSurfaceCallBacks->SetOverlayPosition != WatchdogDdSetOverlayPosition) {
                pldev->apfnDriver[INDEX_DdSetOverlayPosition] = (PFN)pSurfaceCallBacks->SetOverlayPosition;
            }
            pSurfaceCallBacks->SetOverlayPosition = WatchdogDdSetOverlayPosition;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETPALETTE) {

            if (pSurfaceCallBacks->SetPalette != WatchdogDdSetPalette) {
                pldev->apfnDriver[INDEX_DdSetPalette] = (PFN)pSurfaceCallBacks->SetPalette;
            }
            pSurfaceCallBacks->SetPalette = WatchdogDdSetPalette;
        }

        //
        // Capture Palette Callbacks
        //

        if (pPaletteCallBacks->dwFlags & DDHAL_PALCB32_DESTROYPALETTE) {

            if (pPaletteCallBacks->DestroyPalette != WatchdogDdDestroyPalette) {
                pldev->apfnDriver[INDEX_DdDestroyPalette] = (PFN)pPaletteCallBacks->DestroyPalette;
            }
            pPaletteCallBacks->DestroyPalette = WatchdogDdDestroyPalette;
        }

        if (pPaletteCallBacks->dwFlags & DDHAL_PALCB32_SETENTRIES) {

            if (pPaletteCallBacks->SetEntries != WatchdogDdSetEntries) {
                pldev->apfnDriver[INDEX_DdSetEntries] = (PFN)pPaletteCallBacks->SetEntries;
            }
            pPaletteCallBacks->SetEntries = WatchdogDdSetEntries;
        }
    }

    return bRet;
}

VOID APIENTRY
WatchdogDrvDisableDirectDraw(
    DHPDEV dhpdev
    )

{
    PFN_DrvDisableDirectDraw pfn = (PFN_DrvDisableDirectDraw) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvDisableDirectDraw);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }
}

BOOL APIENTRY
WatchdogDrvIcmSetDeviceGammaRamp(
    IN DHPDEV dhpdev,
    IN ULONG iFormat,
    IN LPVOID ipRamp
    )

{
    PFN_DrvIcmSetDeviceGammaRamp pfn = (PFN_DrvIcmSetDeviceGammaRamp) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvIcmSetDeviceGammaRamp);
    BOOL bRet = TRUE;

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return bRet;
    }

    __try {

        bRet = pfn(dhpdev, iFormat, ipRamp);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PFN_DrvStretchBltROP pfn = (PFN_DrvStretchBltROP) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvStretchBltROP);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode, pbo, rop4);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvPlgBlt(
    IN SURFOBJ *psoTrg,
    IN SURFOBJ *psoSrc,
    IN SURFOBJ *psoMsk,
    IN CLIPOBJ *pco,
    IN XLATEOBJ *pxlo,
    IN COLORADJUSTMENT *pca,
    IN POINTL *pptlBrushOrg,
    IN POINTFIX *pptfx,
    IN RECTL *prcl,
    IN POINTL *pptl,
    IN ULONG iMode
    )

{
    PFN_DrvPlgBlt pfn = (PFN_DrvPlgBlt) dhpdevRetrievePfn((ULONG_PTR)psoTrg->dhpdev,INDEX_DrvPlgBlt);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoTrg->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoTrg, psoSrc, psoMsk, pco, pxlo, pca, pptlBrushOrg, pptfx, prcl, pptl, iMode);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoTrg->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvAlphaBlend(
    SURFOBJ *psoDest,
    SURFOBJ *psoSrc,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    RECTL *prclDest,
    RECTL *prclSrc,
    BLENDOBJ *pBlendObj
    )

{
    SURFOBJ *psoDevice = (psoDest->dhpdev) ? psoDest : psoSrc;
    PFN_DrvAlphaBlend pfn = (PFN_DrvAlphaBlend) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvAlphaBlend);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDest, psoSrc, pco, pxlo, prclDest, prclSrc, pBlendObj);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvGradientFill(
    SURFOBJ *psoDest,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    TRIVERTEX *pVertex,
    ULONG nVertex,
    PVOID pMesh,
    ULONG nMesh,
    RECTL *prclExtents,
    POINTL *pptlDitherOrg,
    ULONG ulMode
    )

{
    PFN_DrvGradientFill pfn = (PFN_DrvGradientFill) dhpdevRetrievePfn((ULONG_PTR)psoDest->dhpdev,INDEX_DrvGradientFill);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDest->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDest, pco, pxlo, pVertex, nVertex, pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDest->dhpdev));
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvTransparentBlt(
    SURFOBJ *psoDst,
    SURFOBJ *psoSrc,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    RECTL *prclDst,
    RECTL *prclSrc,
    ULONG iTransColor,
    ULONG ulReserved
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PFN_DrvTransparentBlt pfn = (PFN_DrvTransparentBlt) dhpdevRetrievePfn((ULONG_PTR)psoDevice->dhpdev,INDEX_DrvTransparentBlt);
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(psoDevice->dhpdev)->bThreadStuck) {
        return TRUE;
    }

    __try {

        bRet = pfn(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, ulReserved);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(psoDevice->dhpdev));
    }

    return bRet;
}

HBITMAP APIENTRY
WatchdogDrvDeriveSurface(
    DD_DIRECTDRAW_GLOBAL *pDirectDraw,
    DD_SURFACE_LOCAL *pSurface
    )

{
    PFN_DrvDeriveSurface pfn = (PFN_DrvDeriveSurface) dhpdevRetrievePfn((ULONG_PTR)pDirectDraw->dhpdev, INDEX_DrvDeriveSurface);
    HBITMAP hBitmap = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev((DHPDEV)pDirectDraw->dhpdev)->bThreadStuck == FALSE) {

        PASSOCIATION_NODE Node = AssociationCreateNode();

        if (Node) {

            __try {

                hBitmap = pfn(pDirectDraw, pSurface);

            } __except(GetExceptionCode() == SE_THREAD_STUCK) {

                //
                // Handle stuck thread excepton
                //

                HandleStuckThreadException(dhpdevRetrieveLdev((DHPDEV)pDirectDraw->dhpdev));
            }

            if (hBitmap) {

                //
                // Get the DHSURF that is associated with the hbitmap, and
                // cache it away so we can look it up when a DrvDeleteDeviceBitmap
                // call comes down.
                //

                SURFREF so;

                so.vAltCheckLockIgnoreStockBit((HSURF)hBitmap);

                Node->key = (ULONG_PTR)so.ps->dhsurf();
		Node->data = (ULONG_PTR)dhpdevRetrieveLdev((DHPDEV)pDirectDraw->dhpdev);
		Node->hsurf = (ULONG_PTR)hBitmap;

                //
                // If an association node already exists, with this association
                // then use it.
                //

		if (AssociationIsNodeInList(Node) == FALSE) {

                    AssociationInsertNodeAtTail(Node);

                } else {

                    AssociationDeleteNode(Node);
                }

            } else {

                AssociationDeleteNode(Node);
            }
        }
    }

    return hBitmap;
}

VOID APIENTRY
WatchdogDrvNotify(
    IN SURFOBJ *pso,
    IN ULONG iType,
    IN PVOID pvData
    )

{
    PFN_DrvNotify pfn = (PFN_DrvNotify) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev, INDEX_DrvNotify);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(pso, iType, pvData);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }
}

VOID APIENTRY
WatchdogDrvSynchronizeSurface(
    IN SURFOBJ *pso,
    IN RECTL *prcl,
    IN FLONG fl
    )

{
    PFN_DrvSynchronizeSurface pfn = (PFN_DrvSynchronizeSurface) dhpdevRetrievePfn((ULONG_PTR)pso->dhpdev, INDEX_DrvSynchronizeSurface);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(pso->dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(pso, prcl, fl);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(pso->dhpdev));
    }
}

VOID APIENTRY
WatchdogDrvResetDevice(
    DHPDEV dhpdev,
    PVOID Reserved
    )

{
    PFN_DrvResetDevice pfn = (PFN_DrvResetDevice) dhpdevRetrievePfn((ULONG_PTR)dhpdev,INDEX_DrvResetDevice);

    //
    // Return early if we are in a thread stuck condition
    //

    if (dhpdevRetrieveLdev(dhpdev)->bThreadStuck) {
        return;
    }

    __try {

        pfn(dhpdev, Reserved);

    } __except(GetExceptionCode() == SE_THREAD_STUCK) {

        //
        // Handle stuck thread excepton
        //

        HandleStuckThreadException(dhpdevRetrieveLdev(dhpdev));
    }
}

//
// The following table contains the replacement functions which
// hooks the real driver entry points, and set up the try/except
// handlers.
//

PFN WatchdogTable[INDEX_LAST] =
{
    (PFN)WatchdogDrvEnablePDEV,
    (PFN)WatchdogDrvCompletePDEV,
    (PFN)WatchdogDrvDisablePDEV,
    (PFN)WatchdogDrvEnableSurface,
    (PFN)WatchdogDrvDisableSurface,

    (PFN)WatchdogDrvAssertMode,
    0, // DrvOffset - obsolete
    (PFN)WatchdogDrvResetPDEV,
    0, // DrvDisableDriver - don't hook
    0, // not assigned

    (PFN)WatchdogDrvCreateDeviceBitmap,
    (PFN)WatchdogDrvDeleteDeviceBitmap,
    (PFN)WatchdogDrvRealizeBrush,
    (PFN)WatchdogDrvDitherColor,
    (PFN)WatchdogDrvStrokePath,

    (PFN)WatchdogDrvFillPath,
    (PFN)WatchdogDrvStrokeAndFillPath,
    0, // DrvPaint - obsolete
    (PFN)WatchdogDrvBitBlt,
    (PFN)WatchdogDrvCopyBits,

    (PFN)WatchdogDrvStretchBlt,
    0, // not assigned
    (PFN)WatchdogDrvSetPalette,
    (PFN)WatchdogDrvTextOut,
    (PFN)WatchdogDrvEscape,

    (PFN)WatchdogDrvDrawEscape,
    0, // DrvQueryFont
    0, // DrvQueryFontTree
    0, // DrvQueryFontData
    (PFN)WatchdogDrvSetPointerShape,

    (PFN)WatchdogDrvMovePointer,
    (PFN)WatchdogDrvLineTo,
    0, // DrvSendPage
    0, // DrvStartPage
    0, // DrvEndDoc

    0, // DrvStartDoc
    0, // not assigned
    0, // DrvGetGlyphMode
    (PFN)WatchdogDrvSynchronize,
    0, // not assigned

    (PFN)WatchdogDrvSaveScreenBits,
    0, // DrvGetModes - don't hook
    0, // DrvFree
    0, // DrvDestroyFont
    0, // DrvQueryFontCaps

    0, // DrvLoadFontFile
    0, // DrvUnloadFontFile
    0, // DrvFontManagement
    0, // DrvQueryTrueTypeTable
    0, // DrvQueryTrueTypeOutline

    0, // DrvGetTrueTypeFile
    0, // DrvQueryFontFile
    0, // DrvMovePanning
    0, // DrvQueryAdvanceWidths
    (PFN)WatchdogDrvSetPixelFormat,

    (PFN)WatchdogDrvDescribePixelFormat,
    (PFN)WatchdogDrvSwapBuffers,
    0, // DrvStartBanding
    0, // DrvNextBand
    (PFN)WatchdogDrvGetDirectDrawInfo,

    (PFN)WatchdogDrvEnableDirectDraw,
    (PFN)WatchdogDrvDisableDirectDraw,
    0, // DrvQuerySpoolType
    0, // not assigned
    0, // DrvIcmCreateColorTransform

    0, // DrvIcmDeleteColorTransform
    0, // DrvIcmCheckBitmapBits
    (PFN)WatchdogDrvIcmSetDeviceGammaRamp,
    (PFN)WatchdogDrvGradientFill,
    (PFN)WatchdogDrvStretchBltROP,

    (PFN)WatchdogDrvPlgBlt,
    (PFN)WatchdogDrvAlphaBlend,
    0, // DrvSynthesizeFont
    0, // DrvGetSynthesizedFontFiles
    (PFN)WatchdogDrvTransparentBlt,

    0, // DrvQueryPerBandInfo
    0, // DrvQueryDeviceSupport
    0, // reserved
    0, // reserved
    0, // reserved

    0, // reserved
    0, // reserved
    0, // reserved
    0, // reserved
    0, // reserved

    (PFN)WatchdogDrvDeriveSurface,
    0, // DrvQueryGlyphAttrs
    (PFN)WatchdogDrvNotify,
    (PFN)WatchdogDrvSynchronizeSurface,
    (PFN)WatchdogDrvResetDevice,

    0, // reserved
    0, // reserved
    0  // reserved
};

BOOL
WatchdogIsFunctionHooked(
    IN PLDEV pldev,
    IN ULONG functionIndex
    )

/*++

Routine Description:

    This function checks to see whether the Create/DeleteDeviceBitmap
    driver entry points are hooked.

Return Value:

    TRUE if the entry point is hooked,
    FALSE otherwise

--*/

{
    ASSERTGDI(functionIndex < INDEX_LAST, "functionIndex out of range");
    return pldev->apfn[functionIndex] == WatchdogTable[functionIndex];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\daytona\makefile.inc ===
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\gdiplus\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\gdiplus\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* This file contains the virtual driver that is used for user-mode GDI+
* painting on the desktop screen.
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
* Created: 29-Apr-1998
* Author: J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

// @@@ Re-visit headers:

#define NO_DDRAWINT_NO_COM

// @@@ Temporary:

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <ddraw.h>
#include <wingdi.h>
#include <winddi.h>
#include <math.h>

VOID vFreeMem(VOID*);
VOID* pAllocMem(ULONG, ULONG);

#define RIP(x) OutputDebugString(x)
#define WARNING(x) OutputDebugString(x)
#define ASSERTGDI(x, y) if (!(x)) OutputDebugString(y)
#define PALLOCMEM(size, tag) pAllocMem(size, tag);
#define VFREEMEM(p) vFreeMem(p);

ULONG
DbgPrint(
    PCH Format,
    ...
    );


typedef struct _GPDEV 
{
    HDEV                hdev;
    HWND                hwnd;           // @@@ Hwnd this HDEV was created from
    HSURF               hsurfScreen;    // Handle to the screen surface
    SIZEL               sizlScreen;     // Size of the screen
    ULONG               iBitmapFormat;  // The color depth
    ULONG               flRed;          // The RGB color masks
    ULONG               flGreen;
    ULONG               flBlue;
    HPALETTE            hpalDefault;    // The GDI palette handle
    PALETTEENTRY*       pPal;           // The palette table if palette managed
    LPDIRECTDRAW        lpDD;           // DirectDraw object
    LPDIRECTDRAWSURFACE lpDDPrimary;    // DirectDraw primary surface
    LPDIRECTDRAWSURFACE lpDDBuffer;     // DirectDraw buffer surface
    LPDIRECTDRAWCLIPPER lpDDClipper;    // Primary surface DirectDraw clipper
    SURFOBJ*            psoBuffer;      // GDI surface wrapped around buffer
} GDEV;

/******************************Public*Structure****************************\
* GDIINFO ggdiGdiPlusDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiGdiPlusDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    320,                    // ulHorzSize 
    240,                    // ulVertSize 
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    8,                      // ulDACRed (possibly overwritten later)
    8,                      // ulDACGreen (possibly overwritten later)
    8,                      // ulDACBlue (possibly overwritten later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoGdiPlusDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoGdiPlusDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_PALMANAGED       |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER),
                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Routine******************************\
* VOID vGpsUninitializeDirectDraw
*
\**************************************************************************/

VOID vGpsUninitializeDirectDraw(
GDEV*   pgdev)
{
    HSURF hsurf;

    if (pgdev->psoBuffer != NULL)
    {
        hsurf = pgdev->psoBuffer->hsurf;
        EngUnlockSurface(pgdev->psoBuffer);
        EngDeleteSurface(hsurf);
    }
    if (pgdev->lpDDClipper != NULL)
    {
        pgdev->lpDDClipper->lpVtbl->Release(pgdev->lpDDClipper);
        pgdev->lpDDClipper = NULL;
    }
    if (pgdev->lpDDBuffer != NULL)
    {
        pgdev->lpDDBuffer->lpVtbl->Release(pgdev->lpDDBuffer);
        pgdev->lpDDBuffer = NULL;
    }
    if (pgdev->lpDDPrimary != NULL)
    {
        pgdev->lpDDPrimary->lpVtbl->Release(pgdev->lpDDPrimary);
        pgdev->lpDDPrimary = NULL;
    }
    if (pgdev->lpDD != NULL)
    {
        pgdev->lpDD->lpVtbl->Release(pgdev->lpDD);
        pgdev->lpDD = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bGpsInitializeDirectDraw
*
\**************************************************************************/

BOOL bGpsInitializeDirectDraw(
GDEV*   pgdev,
HWND    hwnd,
ULONG*  pScreenWidth,
ULONG*  pScreenHeight,
ULONG*  pBitsPerPlane,
ULONG*  pRedMask,
ULONG*  pGreenMask,
ULONG*  pBlueMask)
{
    LPDIRECTDRAW        lpDD;
    DDSURFACEDESC       DDMode;
    DDSURFACEDESC       ddsd;
    LPDIRECTDRAWSURFACE lpDDPrimary;
    LPDIRECTDRAWSURFACE lpDDBuffer;
    LPDIRECTDRAWCLIPPER lpDDClipper;
    SURFOBJ*            psoBuffer;
    SIZEL               sizl;
    ULONG               iFormat;
    HSURF               hsurf;

    DDMode.dwSize = sizeof(DDMode);

    if (DirectDrawCreate(NULL, &lpDD, NULL) == DD_OK)
    {
        if ((lpDD->lpVtbl->SetCooperativeLevel(lpDD, hwnd, DDSCL_NORMAL) == DD_OK) &&
            (lpDD->lpVtbl->GetDisplayMode(lpDD, &DDMode) == DD_OK))
        {
            *pScreenWidth  = DDMode.dwWidth;
            *pScreenHeight = DDMode.dwHeight;
            *pBitsPerPlane = DDMode.ddpfPixelFormat.dwRGBBitCount;
            *pRedMask      = DDMode.ddpfPixelFormat.dwRBitMask;
            *pGreenMask    = DDMode.ddpfPixelFormat.dwGBitMask;
            *pBlueMask     = DDMode.ddpfPixelFormat.dwBBitMask;

            // Create a primary surface:
    
            RtlZeroMemory(&ddsd, sizeof(ddsd));

            ddsd.dwSize = sizeof(ddsd);
            ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

            if (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDPrimary, NULL) == DD_OK)
            {
                if (lpDD->lpVtbl->CreateClipper(lpDD, 0, &lpDDClipper, NULL) == DD_OK)
                {
                    if ((lpDDClipper->lpVtbl->SetHWnd(lpDDClipper, 0, hwnd) == DD_OK) &&
                        (lpDDPrimary->lpVtbl->SetClipper(lpDDPrimary, lpDDClipper) == DD_OK))
                    {
                        // Create a temporary DirectDraw surface that's used
                        // as a staging area.
                        //
                        // @@@ This darn well better be temporary!
                
                        RtlZeroMemory(&ddsd, sizeof(ddsd));
            
                        ddsd.dwSize         = sizeof(ddsd);
                        ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
                        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN;
                        ddsd.dwWidth        = DDMode.dwWidth;
                        ddsd.dwHeight       = DDMode.dwHeight;
                
                        if (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDBuffer, NULL) == DD_OK) 
                        {
                            if (lpDDBuffer->lpVtbl->Lock(lpDDBuffer, NULL, &ddsd, DDLOCK_WAIT, NULL) 
                                    == DD_OK)
                            {
                                // Create a GDI surface to wrap around the temporary
                                // buffer:
        
                                sizl.cx = ddsd.dwWidth;
                                sizl.cy = ddsd.dwHeight;
        
                                switch (DDMode.ddpfPixelFormat.dwRGBBitCount)
                                {
                                    case 4:  iFormat = BMF_4BPP; break;
                                    case 8:  iFormat = BMF_8BPP; break;
                                    case 16: iFormat = BMF_16BPP; break;
                                    case 24: iFormat = BMF_24BPP; break;
                                    case 32: iFormat = BMF_32BPP; break;
                                    default: RIP("Unexpected dwRGBBitCount");
                                }

                                // !!! @@@ Why did I have to specify BMF_TOPDOWN?
            
                                hsurf = (HSURF) EngCreateBitmap(sizl, 
                                                                ddsd.lPitch, 
                                                                iFormat,
                                                                BMF_TOPDOWN,
                                                                ddsd.lpSurface);
        
                                lpDDBuffer->lpVtbl->Unlock(lpDDBuffer, ddsd.lpSurface);
        
                                if (hsurf != NULL)
                                {
                                    psoBuffer = EngLockSurface(hsurf);
        
                                    pgdev->hwnd        = hwnd;
                                    pgdev->lpDD        = lpDD;
                                    pgdev->lpDDPrimary = lpDDPrimary;
                                    pgdev->lpDDBuffer  = lpDDBuffer;
                                    pgdev->psoBuffer   = psoBuffer;
                
                                    return(TRUE);
                                }
                            }
        
                            lpDDBuffer->lpVtbl->Release(lpDDBuffer);
                        }
                    }

                    lpDDClipper->lpVtbl->Release(lpDDClipper);
                }

                lpDDPrimary->lpVtbl->Release(lpDDPrimary);
            }
        }

        lpDD->lpVtbl->Release(lpDD);
    }

    WARNING("Failed bGpsInitializeDirectDraw");

    return(FALSE);
}


/******************************Public*Routine******************************\
* BOOL bGpsInitializeModeFields
*
* Fill in the GDIINFO and DEVINFO structures required by the engine.
*
\**************************************************************************/

BOOL bGpsInitializeModeFields(
GDEV*       pgdev,
ULONG*      pScreenWidth,
ULONG*      pScreenHeight,
ULONG*      pBitsPerPlane,
ULONG*      pRedMask,
ULONG*      pGreenMask,
ULONG*      pBlueMask,
GDIINFO*    pgdi,
DEVINFO*    pdi)
{
    ULONG   BitsPerPlane;
    ULONG   RedMask;
    ULONG   GreenMask;
    ULONG   BlueMask;
    ULONG   ScreenWidth;
    ULONG   ScreenHeight;

    RedMask      = *pRedMask;
    GreenMask    = *pGreenMask;
    BlueMask     = *pBlueMask;
    BitsPerPlane = *pBitsPerPlane;
    ScreenWidth  = *pScreenWidth;
    ScreenHeight = *pScreenHeight;

    pgdev->sizlScreen.cx = ScreenWidth;
    pgdev->sizlScreen.cy = ScreenHeight;

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiGdiPlusDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzRes         = ScreenWidth;
    pgdi->ulVertRes         = ScreenHeight;
    pgdi->ulPanningHorzRes  = ScreenWidth;
    pgdi->ulPanningVertRes  = ScreenHeight;

    pgdi->cBitsPixel        = BitsPerPlane;
    pgdi->cPlanes           = 1;

    pgdi->ulLogPixelsX      = 120; // @@@
    pgdi->ulLogPixelsY      = 120;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoGdiPlusDefault;

    if (BitsPerPlane == 8)
    {
        pgdev->iBitmapFormat   = BMF_8BPP;

        pgdi->ulDACRed         = 0;
        pgdi->ulDACGreen       = 0;
        pgdi->ulDACBlue        = 0;
    }
    else if ((BitsPerPlane == 16) || (BitsPerPlane == 15))
    {
        pgdev->iBitmapFormat   = BMF_16BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (BitsPerPlane == 24)
    {
        pgdev->iBitmapFormat   = BMF_24BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTGDI(BitsPerPlane == 32,
            "This driver supports only 8, 16, 24 and 32bpp");

        pgdev->iBitmapFormat   = BMF_32BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bGpsInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bGpsInitializePalette(
GDEV*    pgdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (pgdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, 'zzzG');
        if (ppal == NULL)
            goto ReturnFalse;

        pgdev->pPal = ppal;

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTGDI((pgdev->iBitmapFormat == BMF_16BPP) ||
         (pgdev->iBitmapFormat == BMF_24BPP) ||
         (pgdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                pgdev->flRed, pgdev->flGreen, pgdev->flBlue);
    }

    pgdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    WARNING("Failed bInitializePalette");
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vGpsUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vGpsUninitializePalette(GDEV* gpdev)
{
    // Delete the default palette if we created one:

    if (gpdev->hpalDefault != 0)
        EngDeletePalette(gpdev->hpalDefault);

    if (gpdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(gpdev->pPal);
}

/******************************Public*Routine******************************\
* GpsDisablePDEV
*
\**************************************************************************/

VOID GpsDisablePDEV(
DHPDEV  dhpdev)
{
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    vGpsUninitializePalette(pgdev);

    vGpsUninitializeDirectDraw(pgdev);

    VFREEMEM(pgdev);
}

/******************************Public*Routine******************************\
* DHPDEV GpsEnablePDEV
*
\**************************************************************************/

DHPDEV GpsEnablePDEV(
DEVMODEW*   pdm,            
PWSTR       pwszLogAddr,    
ULONG       cPat,           
HSURF*      phsurfPatterns, 
ULONG       cjCaps,         
ULONG*      pdevcaps,       
ULONG       cjDevInfo,      
DEVINFO*    pdi,            
HDEV        hdev,           
PWSTR       pwszDeviceName, 
HANDLE      hDriver)        
{
    GDEV*   pgdev;
    HWND    hwnd;
    ULONG   BitsPerPlane;
    ULONG   RedMask;
    ULONG   GreenMask;
    ULONG   BlueMask;
    ULONG   ScreenWidth;
    ULONG   ScreenHeight;

    pgdev = PALLOCMEM(sizeof(GDEV), 'zzzG');
    if (pgdev == NULL)
    {
        goto ReturnFailure0;
    }

    hwnd = (HWND) pdm;

    if (!bGpsInitializeDirectDraw(pgdev, hwnd, &ScreenWidth, &ScreenHeight,
                                  &BitsPerPlane, &RedMask, &GreenMask,
                                  &BlueMask))
    {
        goto ReturnFailure0;
    }
    
    if (!bGpsInitializeModeFields(pgdev, &ScreenWidth, &ScreenHeight,
                                  &BitsPerPlane, &RedMask, &GreenMask,
                                  &BlueMask, (GDIINFO*) pdevcaps, pdi))
    {
        goto ReturnFailure0;
    }

    if (!bGpsInitializePalette(pgdev, pdi))
    {
        goto ReturnFailure1; 
    }

    return((DHPDEV) pgdev);

ReturnFailure1:
    GpsDisablePDEV((DHPDEV) pgdev);

ReturnFailure0:
    return(0);
}

/******************************Public*Routine******************************\
* VOID GpsCompletePDEV
*
\**************************************************************************/

VOID GpsCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((GDEV*) dhpdev)->hdev = hdev;
}

/******************************Public*Routine******************************\
* VOID GpsDisableSurface
*
\**************************************************************************/

VOID GpsDisableSurface(
DHPDEV dhpdev)
{
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    EngDeleteSurface(pgdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* HSURF GpsEnableSurface
*
\**************************************************************************/

HSURF GpsEnableSurface(
DHPDEV dhpdev)
{
    HSURF   hsurf;
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    hsurf = EngCreateDeviceSurface(NULL, pgdev->sizlScreen, pgdev->iBitmapFormat);
    if (hsurf == 0)
    {
        goto ReturnFailure;
    }

    // Associate surface with a physical device now

    if (!EngAssociateSurface(hsurf, pgdev->hdev, HOOK_BITBLT    
                                               | HOOK_COPYBITS  
                                               | HOOK_STROKEPATH
                                               | HOOK_TEXTOUT))
    {
        goto ReturnFailure;
    }

    pgdev->hsurfScreen = hsurf;             // Remember it for clean-up

    return(hsurf);

ReturnFailure:
    GpsDisableSurface((DHPDEV) pgdev);

    return(0);
}

/******************************Public*Routine******************************\
* VOID vGpsWindowOffset
*
* Hack function to account for the window offset.
*
\**************************************************************************/

VOID
vGpsWindowOffset(
GDEV*   pgdev,
RECTL*  prcl,
RECT*   prc)
{
    RECT rcWindow;

    GetWindowRect(pgdev->hwnd, &rcWindow);

    prc->left   = rcWindow.left + prcl->left;
    prc->right  = rcWindow.left + prcl->right;
    prc->top    = rcWindow.top  + prcl->top;
    prc->bottom = rcWindow.top  + prcl->bottom;
}

/******************************Public*Routine******************************\
* BOOL GpsCopyBits
*
\**************************************************************************/

BOOL GpsCopyBits(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc)
{
    GDEV*   pgdev;
    RECTL   rclSrc;
    HRESULT hr;
    RECT    rcWindow;
    RECT    rcSrc;

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = pptlSrc->x + (prclDst->right - prclDst->left);
    rclSrc.bottom = pptlSrc->y + (prclDst->bottom - prclDst->top);

    if (psoSrc->dhpdev == NULL)
    {
        // DIB-to-screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // Read in a copy of the destination bits in order to handle 
            // complex clipping because we're going to write everything
            // back out:

        Repeat1:

            hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                                (RECT*) prclDst,
                                                pgdev->lpDDPrimary,
                                                &rcWindow,
                                                DDBLT_WAIT,
                                                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                DbgPrint("Lost!\n");
                pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
                goto Repeat1;
            }
        }

        EngCopyBits(pgdev->psoBuffer, psoSrc, pco, pxlo, prclDst, pptlSrc);

    Repeat2:

        hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                             &rcWindow,
                                             pgdev->lpDDBuffer,
                                             (RECT*) prclDst,
                                             DDBLT_WAIT,
                                             NULL);

        if (hr == DDERR_SURFACELOST)
        {
            DbgPrint("Lost2\n");
            pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
            goto Repeat2;
        }
    }
    else if (psoDst->dhpdev == NULL)
    {
        // Screen-to-DIB:

        pgdev = (GDEV*) psoSrc->dhpdev;

        vGpsWindowOffset(pgdev, &rclSrc, &rcWindow);

        pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) &rclSrc,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

        EngCopyBits(psoDst, pgdev->psoBuffer, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {
        // Screen-to-screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);
        vGpsWindowOffset(pgdev, &rclSrc, &rcSrc);

        pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                        &rcWindow,
                                        pgdev->lpDDPrimary,
                                        &rcSrc,
                                        DDBLT_WAIT,
                                        NULL);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GpsBitBlt
*
* An 's' is appended to this function name so that we don't conflict 
* with 'GpsBitBlt' exported from gdiplus.dll.
*
\**************************************************************************/

BOOL GpsBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMsk,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMsk,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;

    if (psoSrc == NULL)
    {
        // Patblt to screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // Read in a copy of the destination bits in order to handle 
            // complex clipping because we're going to write everything
            // back out:

        Repeat1:

            hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                                (RECT*) prclDst,
                                                pgdev->lpDDPrimary,
                                                &rcWindow,
                                                DDBLT_WAIT,
                                                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                DbgPrint("Lost!\n");
                pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
                goto Repeat1;
            }
        }

        EngBitBlt(pgdev->psoBuffer, psoSrc, psoMsk, pco, pxlo, prclDst,
                  pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

    Repeat2:

        hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                             &rcWindow,
                                             pgdev->lpDDBuffer,
                                             (RECT*) prclDst,
                                             DDBLT_WAIT,
                                             NULL);

        if (hr == DDERR_SURFACELOST)
        {
            DbgPrint("Lost2\n");
            pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
            goto Repeat2;
        }

        return(TRUE);
    }
    else
    {
        return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                         pptlMsk, pbo, pptlBrush, rop4));
    }
}

/******************************Public*Routine******************************\
* BOOL GpsStrokePath
*
\**************************************************************************/

BOOL GpsStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxlo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;

Repeat1:

    pgdev = (GDEV*) pso->dhpdev;

    vGpsWindowOffset(pgdev, &pco->rclBounds, &rcWindow);

    hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) &pco->rclBounds,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

    if (hr == DDERR_SURFACELOST)
    {
        DbgPrint("Lost!\n");
        pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
        goto Repeat1;
    }

    EngStrokePath(pgdev->psoBuffer, ppo, pco, pxlo, pbo, pptlBrush,
                  pla, mix);

    hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                         &rcWindow,
                                         pgdev->lpDDBuffer,
                                         (RECT*) &pco->rclBounds,
                                         DDBLT_WAIT,
                                         NULL);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GpsTextOut
*
\**************************************************************************/

BOOL GpsTextOut(
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlOrg,
MIX         mix)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;
    RECTL*  prclDraw;

Repeat1:

    pgdev = (GDEV*) pso->dhpdev;

    prclDraw = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    vGpsWindowOffset(pgdev, prclDraw, &rcWindow);

    hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) prclDraw,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

    if (hr == DDERR_SURFACELOST)
    {
        DbgPrint("Lost!\n");
        pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
        goto Repeat1;
    }

    EngTextOut(pgdev->psoBuffer, pstro, pfo, pco, prclExtra, prclOpaque,
               pboFore, pboOpaque, pptlOrg, mix);

    hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                         &rcWindow,
                                         pgdev->lpDDBuffer,
                                         (RECT*) prclDraw,
                                         DDBLT_WAIT,
                                         NULL);

    return(TRUE);
}

/******************************Public*Structure****************************\
* DFVFN gadrvfnGdiPlus[]
*
\**************************************************************************/

DRVFN gadrvfnGdiPlus[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) GpsEnablePDEV            },
    {   INDEX_DrvCompletePDEV,          (PFN) GpsCompletePDEV          },
    {   INDEX_DrvDisablePDEV,           (PFN) GpsDisablePDEV           },
    {   INDEX_DrvEnableSurface,         (PFN) GpsEnableSurface         },
    {   INDEX_DrvDisableSurface,        (PFN) GpsDisableSurface        },
    {   INDEX_DrvCopyBits,              (PFN) GpsCopyBits              },
    {   INDEX_DrvBitBlt,                (PFN) GpsBitBlt                },
    {   INDEX_DrvStrokePath,            (PFN) GpsStrokePath            },
    {   INDEX_DrvTextOut,               (PFN) GpsTextOut               },
};

ULONG gcdrvfnGdiPlus = sizeof(gadrvfnGdiPlus) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL GpsEnableDriver
*
\**************************************************************************/

BOOL GpsEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnGdiPlus;
    pded->c              = gcdrvfnGdiPlus;
    pded->iDriverVersion = DDI_DRIVER_VERSION;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ylateobj.cxx ===
/****************************Module*Header*******************************\
* Module Name: ylateobj.cxx
*
* This contains the xlate object constructors, destructors and methods
* An xlateobj is used to translate indexes from one palette to another.
*
* When blting between raster surfaces we create a translate object
* between to speed up the BitBlt.  When the destination surface is
* palette managed we have to do a bit more work.
*
* Created: 18-Nov-1990 14:23:55
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" VOID vInitXLATE();

#pragma alloc_text(INIT, vInitXLATE)

// These two variables are for the translate components cacheing of
// translate objects.  There access is restricted to being done only
// after the palette semaphore has been grabbed.

XLATETABLE xlateTable[XLATE_CACHE_SIZE];
ULONG ulTableIndex = 0;

TRANSLATE20 defaultTranslate =
{
    0,
    {0,1,2,3,4,5,6,7,8,9,246,247,248,249,250,251,252,253,254,255}
};

// This is the identity xlate object

XLATE256 xloIdent;

/******************************Public*Routine******************************\
* vInitXLATE
*
* initialize the xlateobj component
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" VOID vInitXLATE()
{
    RtlZeroMemory(xlateTable, (UINT) XLATE_CACHE_SIZE * sizeof(XLATETABLE));

    xloIdent.iUniq    = XLATE_IDENTITY_UNIQ;
    xloIdent.flXlate  = XO_TRIVIAL;
    xloIdent.iSrcType = 0;
    xloIdent.iDstType = 0;
    xloIdent.cEntries = 256;
    xloIdent.pulXlate = xloIdent.ai;
    xloIdent.iBackSrc = 0;
    xloIdent.iForeDst = 0;
    xloIdent.iBackDst = 0;

    //
    // This may seem hackish but XLATE_CACHE_JOURANL ensures that
    // it doesn't cause anything to get unlocked or freed in
    // the destructor.
    //

    xloIdent.lCacheIndex = XLATE_CACHE_JOURNAL;
    xloIdent.ppalSrc = (PPALETTE) NULL;
    xloIdent.ppalDst = (PPALETTE) NULL;
    xloIdent.ppalDstDC = (PPALETTE) NULL;

    xloIdent.hcmXform = NULL;
    xloIdent.lIcmMode = DC_ICM_OFF;

    UINT uiTemp;

    for (uiTemp = 0; uiTemp < 256; uiTemp++)
    {
        xloIdent.ai[uiTemp] = uiTemp;
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::vDelete
*
* Deletes the object.
*
* History:
*  Sun 17-Oct-1993 -by- Patrick Haluptzok [patrickh]
* Kill hmgr references.
*
*  26-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID EXLATEOBJ::vDelete()
{
    if (pxlate != (PXLATE) NULL)
    {
        if (pxlate->lCacheIndex == XLATE_CACHE_JOURNAL)
        {
            if (ppalSrc())
            {
                bDeletePalette((HPAL) ppalSrc()->hGet());
            }
        }

        VFREEMEM(pxlate);
        pxlate = (PXLATE) NULL;
    }
}


/******************************Public*Routine******************************\
* XLATEMEMOBJ destructor
*
* destructor for xlate memory objects
*
* History:
*  Mon 19-Nov-1990 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

XLATEMEMOBJ::~XLATEMEMOBJ()
{
    if (pxlate != (PXLATE) NULL)
    {
        VFREEMEM(pxlate);
        pxlate = (PXLATE) NULL;
    }
}


/******************************Public*Routine******************************\
* XLATE::vMapNewXlate
*
*   Maps a pxlate from being relative to one palette to being relative to
*   another palette.
*
* Arguments:
*
*   ptrans - Translate to map
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
FASTCALL
XLATE::vMapNewXlate(
    PTRANSLATE ptrans
    )
{
    ULONG ulTemp;
    ULONG ulCount = cEntries;

    if (ptrans == NULL)
    {
        //
        // This is the default palette case
        //

        while (ulCount--)
        {
            ulTemp = ai[ulCount];

            if (ulTemp >= 10)
            {
                ai[ulCount] = ulTemp + 236;
            }

            //
            // else
            //
            //
            // do nothing, the first 10 are a 1 to 1 mapping.
            //
        }
    }
    else
    {
        ULONG *pultemp = ai;

        while (ulCount--)
        {
            *pultemp = (ULONG) ptrans->ajVector[*pultemp];
            pultemp++;

            //
            // ai[ulCount] = (ULONG) ptrans->ajVector[ai[ulCount]];
            //
        }
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bMakeXlate
*
*   This is called by SetDIBitsToDevice for the DIB_PAL_COLORS case.
*   This takes the indices in bmiColors and translates them through
*   a logical palette.
*
* Arguments:
*
*   pusIndices      -
*   palDC           -
*   pSurfDst        -
*   cEntriesInit    -
*   cEntriesMax     -
*
* History:
*  17-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bMakeXlate(
    PUSHORT  pusIndices,
    XEPALOBJ palDC,
    SURFACE *pSurfDst,
    ULONG    cEntriesInit,
    ULONG    cEntriesMax
    )
{
    ASSERTGDI(pSurfDst != NULL, "ERROR GDI bMakeXlate1");
    ASSERTGDI(palDC.bValid(), "ERROR bMakeXlate 134");

    XEPALOBJ palDst(pSurfDst->ppal());

    ULONG ulTemp;
    ULONG ulIndex;

    //
    // count of colors in DC
    //

    ULONG cColorsDC;
    PXLATE pXlateTemp;

    ASSERTGDI(palDC.cEntries() != 0, "ERROR 0 entry dc palette isn't allowed");

    //
    // Allocate room for the Xlate.
    //

    pxlate = pXlateTemp = (PXLATE) PALLOCNOZ(sizeof(XLATE) +
                                                (sizeof(ULONG) * cEntriesMax),
                                             'tlxG');

    if (pXlateTemp == (PXLATE)NULL)
    {
        WARNING("GDISRV bMakeXlate failed memory allocation\n");
        return(FALSE);
    }

    pXlateTemp->iUniq       = ulGetNewUniqueness(ulXlatePalUnique);
    pXlateTemp->flXlate     = XO_TABLE;
    pXlateTemp->iSrcType    = pXlateTemp->iDstType = 0;
    pXlateTemp->cEntries    = cEntriesMax;
    pXlateTemp->pulXlate    = pXlateTemp->ai;
    pXlateTemp->iBackSrc    = 0;
    pXlateTemp->iForeDst    = 0;
    pXlateTemp->iBackDst    = 0;
    pXlateTemp->lCacheIndex = XLATE_CACHE_INVALID;
    pXlateTemp->ppalSrc     = (PPALETTE) NULL;
    pXlateTemp->ppalDst     = palDst.ppalGet();
    pXlateTemp->ppalDstDC   = palDC.ppalGet();

    RtlZeroMemory(((ULONG *)pXlateTemp->ai) + cEntriesInit,
                  (UINT) (cEntriesMax - cEntriesInit) * sizeof(ULONG));

    PAL_ULONG palentry;
    PTRANSLATE ptrans;
    cColorsDC = palDC.cEntries();

    //
    // Grab the palette semaphore so you can touch the pxlates.
    //

    SEMOBJ  semo(ghsemPalette);

    //
    // Ok fill in the pxlate correctly.
    //

    if ((!palDst.bValid()) || (palDst.bIsPalManaged()))
    {
        //
        // Do the palette managed cases
        //

        if (palDC.bIsPalDefault())
        {
            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                //
                // Make sure it isn't too large
                //

                if (ulIndex >= 20)
                {
                    ulIndex = ulIndex % 20;
                }

                if (ulIndex < 10)
                {
                    pXlateTemp->ai[ulTemp] = ulIndex;
                }
                else
                {
                    pXlateTemp->ai[ulTemp] = ulIndex + 236;
                }
            }
        }
        else if (palDst.bValid() && (palDC.ptransCurrent() != NULL))
        {
            //
            // Map through the current translate.
            //

            ptrans = palDC.ptransCurrent();

            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                pXlateTemp->ai[ulTemp] = (ULONG) ptrans->ajVector[ulIndex];

                ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
        else if ((!palDst.bValid()) && (palDC.ptransFore() != NULL))
        {
            //
            // It's a bitmap, Map through the foreground translate.
            //

            ptrans = palDC.ptransFore();

            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                pXlateTemp->ai[ulTemp] = (ULONG) ptrans->ajVector[ulIndex];

             ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
        else
        {
            //
            // It's palette hasn't been realized.  Grab the palette value and
            // then map into default palette if not PC_EXPLICIT entry.
            //

            for (ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                palentry.ul = palDC.ulEntryGet(ulIndex);

                if (palentry.pal.peFlags == PC_EXPLICIT)
                {
                    //
                    // Get the correct index in the surface palette.
                    //

                    ulIndex = palentry.ul & 0x0000FFFF;

                    if (ulIndex >= 256)
                    {
                        ulIndex = ulIndex % 256;
                    }
                }
                else
                {
                    //
                    // Match against the default palette entries.
                    //

                    ulIndex = ((XEPALOBJ) ppalDefault).ulGetNearestFromPalentry(palentry.pal);

                    if (ulIndex >= 10)
                    {
                        ulIndex = ulIndex + 236;
                    }
                }

                pXlateTemp->ai[ulTemp] = ulIndex;
                ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
    }
    else
    {
        //
        // Find the RGB in the palDC (reaching down to palDst for
        // PC_EXPLICIT entries).  Then find closest match in surface palette.
        //

        ASSERTGDI(palDst.bValid(), "ERROR palDst is not valid");

        for (ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
        {
            //
            // Get the index into the logical palette
            //

            palentry.ul = (ULONG) pusIndices[ulTemp];

            if (palentry.ul >= cColorsDC)
            {
                palentry.ul = palentry.ul % cColorsDC;
            }

            palentry.pal = palDC.palentryGet(palentry.ul);

            if (palentry.pal.peFlags == PC_EXPLICIT)
            {
                //
                // Get the correct index in the surface palette.
                //

                if (palDst.cEntries())
                {
                    palentry.ul = palentry.ul & 0x0000FFFF;

                    if (palentry.ul >= palDst.cEntries())
                    {
                        palentry.ul = palentry.ul % palDst.cEntries();
                    }
                }
                else
                {
                    //
                    // Well what else can we do ?
                    //

                    palentry.ul = 0;
                }

                pXlateTemp->ai[ulTemp] = palentry.ul;
            }
            else
            {
                pXlateTemp->ai[ulTemp] = palDst.ulGetNearestFromPalentry(palentry.pal);
            }
        }
    }

    pxlate->vCheckForTrivial();
    return(TRUE);
}


//
// This describes the overall logic of surface to surface xlates.
// There are basically n types of xlates to worry about:
//
// 1. XO_TRIVIAL - no translation occurs, identity.
//
// 2. XO_TABLE - look up in a table for the correct table translation.
//
//     a. XO_TO_MONO - look in to table for the correct tranlation,
//        but when getting it out of the cache make sure iBackSrc is the
//        same.  iBackSrc goes to 1, everything else to 0.
//     b. XLATE_FROM_MONO - look into table for the correct translation
//        but when getting it out of the cache make sure iBackDst and
//        iForeDst are both still valid. 1 goes to iBackDst, 0 to iForeDst.
//     c. just plain jane indexed to indexed or rgb translation.
//
// 3. XLATE_RGB_SRC - Have to call XLATEOBJ_iXlate to get it translated.
//
//     a. XO_TO_MONO - we have saved the iBackColor in ai[0]
//     b. just plain jane RGB to indexed.  Grab the RGB, find the closest
//        match in Dst palette.  Lot's of work.
//
// 4. XLATE_RGB_BOTH - Bit mashing time.  Call XLATEOBJ_iXlate
//

/******************************Public*Routine******************************\
* EXLATEOBJ::bInitXlateObj
*
*   Cache aware initializer for Xlates.
*
* Arguments:
*
*   hcmXform - hColorTransform, may be NULL
*   pdc      - pointer to DC object
*   palSrc   - src surface palette
*   palDst   - dst surface palette
*   palSrcDC - src DC palette
*   palDstDC - dst DC palette
*   iForeDst - For Mono->Color this is what a 0 goes to
*   iBackDst - For Mono->Color this is what a 1 goes to
*   iBackSrc - For Color->Mono this is the color that goes to
*              1, all other colors go to 0.
*   flCear   - Used for multi-monitor systems
*
* History:
*  Sun 23-Jun-1991 -by- Patrick Haluptzok [patrickh]
*
\**************************************************************************/

BOOL
EXLATEOBJ::bInitXlateObj(
    HANDLE      hcmXform,
    LONG        lIcmMode,
    XEPALOBJ    palSrc,
    XEPALOBJ    palDst,
    XEPALOBJ    palSrcDC,
    XEPALOBJ    palDstDC,
    ULONG       iForeDst,       
    ULONG       iBackDst,       
    ULONG       iBackSrc,       
    ULONG       flCreate        
    )
{
    //
    // Check if blting from compatible bitmap to screen.  This is a common
    // occurrence on 8bpp devices we want to accelerate.
    //

    if (!palSrc.bValid())
    {
        if (
              !palDst.bValid() ||
              (
                palDst.bIsPalManaged() &&
                (
                  (palDstDC.ptransCurrent() == NULL) ||
                  (palDstDC.ptransCurrent() == palDstDC.ptransFore())
                )
              )
           )
        {
            vMakeIdentity();
            return(TRUE);
        }
    }

    //
    // Check if blting from screen to compatible bitmap.
    //

    if (!palDst.bValid())
    {
        if (palSrc.bIsPalManaged())
        {
            //
            // Blting from screen to memory bitmap.  Check for identity.
            //

            if ((palDstDC.ptransCurrent() == NULL) ||
                (palDstDC.ptransCurrent() == palDstDC.ptransFore()))
            {
                vMakeIdentity();
                return(TRUE);
            }
        }
    }

    ASSERTGDI(palDstDC.bValid(), "7GDIERROR vInitXlateObj");
    ASSERTGDI(palDst.bValid() || palSrc.bValid(), "8GDIERROR vInitXlateObj");

    //
    // Check for the easy identity out.  This check does the right thing for
    // ppal==ppal and equal times of two different ppals.
    //

    if ((palSrc.bValid()) && (palDst.bValid()))
    {
        if (palSrc.ulTime() == palDst.ulTime())
        {
            ASSERTGDI(palSrc.cEntries() == palDst.cEntries(), "Xlateobj matching times, different # of entries");
            vMakeIdentity();
            return(TRUE);
        }
    }

    BOOL bCacheXlate = TRUE;

    if (IS_ICM_ON(lIcmMode) && (hcmXform != NULL))
    {
        //
        // If we enable ICM and have a valid color tranform,
        // don't search from cache and don't insert new Xlate to cache.
        //

        bCacheXlate = FALSE;
    }
    else if ((palSrc.bValid()) && (palDst.bValid()))
    {
        if (bSearchCache(palSrc,    palDst,    palSrcDC,    palDstDC,
                         iForeDst,  iBackDst,  iBackSrc,    flCreate))
        {
            return(TRUE);
        }
    }

    pxlate = CreateXlateObject(hcmXform,
                               lIcmMode,
                               palSrc,
                               palDst,
                               palSrcDC,
                               palDstDC,
                               iForeDst,
                               iBackDst,
                               iBackSrc,
                               flCreate);

    if (pxlate != (PXLATE) NULL)
    {
        if (bCacheXlate     &&
            palSrc.bValid() && 
            palDst.bValid() &&
            (!(pxlate->flPrivate & XLATE_RGB_SRC)))
        {
            vAddToCache(palSrc, palDst, palSrcDC, palDstDC);
        }

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


/******************************Public*Routine******************************\
* CreateXlateObject
*
*   Allocates an xlate sets it up.
*
* Arguments:
*
*   palSrc        - src surface palette
*   palDestSurf   - dst surface palette
*   palSrcDC      - src DC palette
*   palDestDC     - dst DC palette
*   iForeDst      - For Mono->Color this is what a 0 goes to
*   iBackDst      - For Mono->Color this is what a 1 goes to
*   iBackSrc      - For Color->Mono this is the color that goes to
*                   1, all other colors go to 0.
*
* History:
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PXLATE
CreateXlateObject(
    HANDLE      hcmXform,
    LONG        lIcmMode,
    XEPALOBJ    palSrc,
    XEPALOBJ    palDestSurf,
    XEPALOBJ    palSrcDC,
    XEPALOBJ    palDestDC,
    ULONG       iForeDst,
    ULONG       iBackDst,
    ULONG       iBackSrc,
    ULONG       flCreateFlag
    )
{
    ASSERTGDI(palDestDC.bValid(), "CreateXlateObject recieved bad ppalDstDC, bug in GDI");
    ASSERTGDI(palSrc.bValid() || palDestSurf.bValid(), "CreateXlaetObject recieved bad ppalSrc, bug in GDI");
    ASSERTGDI(palSrc.ppalGet() != palDestSurf.ppalGet(), "Didn't recognize ident quickly");

    //
    // cEntry == 0 means the source palette is an RGB/Bitfields type.
    // An invalid palette means it's a compatible bitmap on a palette managed device.
    //

    ULONG ulTemp;
    ULONG cEntry = palSrc.bValid() ? palSrc.cEntries() : 256;

    //
    // Allocate room for the structure.
    //

    PXLATE pxlate = pCreateXlate(cEntry);

    if (pxlate == NULL)
    {
        WARNING("CreateXlateObject failed pCreateXlate\n");
        return(pxlate);
    }

    //
    // Grab the palette semaphore so you can access the ptrans in palDestDC.
    //

    SEMOBJ  semo(ghsemPalette); // ??? This may not need to be grabbed
                               // ??? since we have the DC's locked that
                               // ??? this palette DC is in.  Investigate.

    //
    // Initialize ICM stuffs.
    //

    pxlate->vCheckForICM(hcmXform,lIcmMode);

    BOOL bCMYKColor = ((pxlate->flXlate & XO_FROM_CMYK) ? TRUE : FALSE);

    //
    // See if we should be matching to the Dest DC palette instead of the
    // surface.  This occurs when the surface is palette managed and the
    // user hasn't selected an RGB palette into his destination DC.
    // Note we check for a valid pxlate in the Destination DC palette.
    // In multi-task OS the user can do things to get the translate in a
    // invalid or NULL state easily.  We match against the reserved palette
    // in this case.
    //

    BOOL bPalManaged = (!palDestSurf.bValid()) || (palDestSurf.bIsPalManaged());

    if (bPalManaged)
    {
        //
        // We are blting to a compatible bitmap or the screen on a palette managed
        // device.  Check that we have a foreground realization already done,
        // otherwise just use the default palette for the DC palette.
        //

        ASSERTGDI(((palDestDC.ptransFore() == NULL) && (palDestDC.ptransCurrent() == NULL)) ||
                  ((palDestDC.ptransFore() != NULL) && (palDestDC.ptransCurrent() != NULL)),
                  "ERROR translates are either both valid or both invalid");

        if (palDestDC.ptransFore() == NULL)
        {
            //
            // Match against the default palette, valid translate is not available.
            //

            palDestDC.ppalSet(ppalDefault);
        }

        if (!(flCreateFlag & XLATE_USE_SURFACE_PAL))
        {
            pxlate->flPrivate |= XLATE_PAL_MANAGED;

            //
            // Set a flag that says whether we are background or foreground.
            //

            if (palDestSurf.bValid())
            {
                pxlate->flPrivate |= XLATE_USE_CURRENT;
            }
        }
    }

    pxlate->ppalSrc   = palSrc.ppalGet();
    pxlate->ppalDst   = palDestSurf.ppalGet();
    pxlate->ppalDstDC = palDestDC.ppalGet();

    PTRANSLATE ptransFore = palDestDC.ptransFore();
    PTRANSLATE ptransCurrent = palDestDC.ptransCurrent();

    //
    // Ok, lets build the translate vector.
    //

    if (
        (!palSrc.bValid()) ||
        (
          (palSrc.bIsPalManaged()) &&
          ((ptransFore == ptransCurrent) || (flCreateFlag & XLATE_USE_FOREGROUND))
        )
       )
    {
        //
        // The source is a compatible bitmap on a palette managed device or the screen
        // with Dst DC palette having been realized in the foreground.
        //
        // We start out assuming an identity blt.
        //

        if (ptransFore == NULL)
        {
            //
            // Match against the default palette since a
            // valid translate is not available.
            //

            palDestDC.ppalSet(ppalDefault);
            pxlate->ppalDstDC = ppalDefault;
            ptransFore = ptransCurrent = (TRANSLATE *) &defaultTranslate;
        }

        ASSERTGDI(cEntry == 256, "ERROR xlate too small");

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        if (!palDestSurf.bValid())
        {
            //
            // Compatible bitmap to compatible bitmap on palette managed
            // device. Both are relevant to the foreground realize of the
            // DestDC palette so the xlate is identity.
            //

            pxlate->flXlate |= XO_TRIVIAL;
        }
        else if ((palDestSurf.bIsPalDibsection()) && (bEqualRGB_In_Palette(palDestSurf, palDestDC)))
        {
            //
            // If you blt from a compatible bitmap to a DIBSECTION it will be identity
            // if the RGB's of both the DC palette and the DIBSECTION's palette are the same.
            // We do this special check so that if they contain duplicates we still get an
            // identity xlate.
            //

            pxlate->flXlate |= XO_TRIVIAL;  // Size wise this will combine with first check

        }
        else if ((palDestSurf.bIsPalDibsection()) && (palSrc.bValid()) && (bEqualRGB_In_Palette(palDestSurf, palSrc)))
        {
            pxlate->flXlate |= XO_TRIVIAL;  // Size wise this will combine with first check
        }
        else if (palDestSurf.bIsPalManaged())
        {
            //
            // Compatible bitmap to the screen on a palette managed device.
            // The compatible bitmaps colors are defined as the foreground
            // realization of the destination DC's palette.  If the Dst
            // DC's palette is realized in the foreground it's identity.
            // Otherwise we translate from the current to the foreground
            // indices.
            //

            if (ptransCurrent == ptransFore)
            {
                //
                // It's in the foreground or not realized yet so it's
                // identity.  Not realized case also hits on default logical palette.
                //

                pxlate->flXlate |= XO_TRIVIAL;
            }
            else
            {
                //
                // It's foreground to current translation.
                //

                ASSERTGDI(ptransFore != ptransCurrent, "Should have been identity, never get here");
                ASSERTGDI(ptransFore != NULL, "ERROR this should not have got here Fore");
                ASSERTGDI(ptransCurrent != NULL, "ERROR this should not have got here Current");

                for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
                {
                    pxlate->ai[ptransFore->ajVector[ulTemp]] = (ULONG) ptransCurrent->ajVector[ulTemp];
                }

                //
                // Now map the default colors that are really there independant of logical palette.
                //

                if (palDestSurf.bIsNoStatic())
                {
                    //
                    // Only black and white are here.
                    //

                    pxlate->ai[0] = 0;
                    pxlate->ai[255] = 255;
                }
                else if (!palDestSurf.bIsNoStatic256())
                {
                    //
                    // All the 20 holy colors are here.
                    // Fix them up.
                    //

                    for (ulTemp = 0; ulTemp < 10; ulTemp++)
                    {
                        pxlate->ai[ulTemp] = ulTemp;
                        pxlate->ai[ulTemp + 246] = ulTemp + 246;
                    }
                }
            }
        }
        else if (palDestSurf.bIsMonochrome())
        {
            RtlZeroMemory(pxlate->ai, 256 * sizeof(ULONG));

            ulTemp = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);

            ASSERTGDI(ulTemp < 256, "ERROR palSrc invalid - ulGetNearest is > 256");

            pxlate->vSetIndex(ulTemp, 1);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;
        }
        else
        {
            //
            // Blting from palette-managed bitmap to non-palette managed surface.
            //
            // Do all the non-default colors that are realized.
            //

            if (palDestSurf.cEntries() != 256)
            {
                //
                // If the dest is 256 entries we will just leave
                // the identity xlate as the initial state.
                // Otherwise we 0 it out so we don't have a translation
                // index left that's potentially bigger than the
                // destination palette.
                //

                RtlZeroMemory(pxlate->ai, 256 * sizeof(ULONG));
            }

            //
            // We need to fill in where the default colors map.
            //

            for (ulTemp = 0; ulTemp < 10; ulTemp++)
            {
                pxlate->ai[ulTemp] =
                    palDestSurf.ulGetNearestFromPalentry(logDefaultPal.palPalEntry[ulTemp]);
                pxlate->ai[ulTemp + 246] =
                    palDestSurf.ulGetNearestFromPalentry(logDefaultPal.palPalEntry[ulTemp+10]);
            }

            if (flCreateFlag & XLATE_USE_SURFACE_PAL) 
            {
                //
                // Map directly to destination surface palette from source surface palette.
                //

                for (ulTemp = 0; ulTemp < palSrc.cEntries(); ulTemp++)
                {
                   pxlate->ai[ulTemp] = palDestSurf.ulGetNearestFromPalentry(palSrc.palentryGet(ulTemp));
                }

                pxlate->flPrivate |= XLATE_USE_SURFACE_PAL;
            }
            else
            {
                //
                // Go through DC palette and then map to destination surface palette.
                //

                if (ptransFore != NULL)
                {
                    for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
                    {
                        pxlate->ai[ptransFore->ajVector[ulTemp]] =
                                palDestSurf.ulGetNearestFromPalentry(palDestDC.palentryGet(ulTemp));
                    }
                }
            }
        }
    }
    else if (palSrc.bIsPalDibsection() &&
             ((palDestSurf.bValid() &&
               palDestSurf.bIsPalDibsection() &&
               bEqualRGB_In_Palette(palSrc, palDestSurf)
              ) ||
              (((!palDestSurf.bValid()) ||
                (palDestSurf.bIsPalManaged() && (ptransFore == ptransCurrent))
               ) &&
               bEqualRGB_In_Palette(palSrc, palDestDC)
              )
             )
            )
    {
        //
        // Blting from a Dibsection &&
        // ((To another Dibsection with ident palette) ||
        //  (((To a compatible palette managed bitmap)  ||
        //    (To a palette managed screen with the DstDc's logical palette realized in the foreground)) &&
        //   (the dst logical palette == Dibsection's palette)
        // ))
        //
        // This is identity.  We do this special check so even if there are duplicate
        // colors in the palette we still get identity.
        //

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        pxlate->flXlate |= XO_TRIVIAL;
    }
    else if ((palSrc.bIsPalManaged()) && (!palDestSurf.bValid()))
    {
        //
        // We are blting from the screen to a compatible bitmap on a palette
        // managed device where the screen is realized in the background.
        //

        //
        // Make it identity by default.
        //

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        //
        // We are blting background to foreground.
        // i.e. we are blting current realize to foreground realize.
        //

        ASSERTGDI(pxlate->cEntries == 256, "ERROR xlate too small");
        ASSERTGDI(ptransFore != ptransCurrent, "Should have been identity, never get here");
        ASSERTGDI(ptransFore != NULL, "ERROR this should not have got here Fore");
        ASSERTGDI(ptransCurrent != NULL, "ERROR this should not have got here Current");

        for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
        {
            pxlate->ai[ptransCurrent->ajVector[ulTemp]] = (ULONG) ptransFore->ajVector[ulTemp];
        }

        //
        // Now map the default colors that are really there independant of logical palette realization.
        //

        if (palSrc.bIsNoStatic())
        {
            //
            // Only black and white are here.
            //

            pxlate->ai[0] = 0;
            pxlate->ai[255] = 255;
        }
        else if (!palSrc.bIsNoStatic256())
        {
            //
            // All the 20 holy colors are here.
            // Fix them up.
            //

            for (ulTemp = 0; ulTemp < 10; ulTemp++)
            {
                pxlate->ai[ulTemp] = ulTemp;
                pxlate->ai[ulTemp + 246] = ulTemp + 246;
            }
        }
    }
    else if (palSrc.bIsMonochrome())
    {
        if (palDestSurf.bIsMonochrome())
        {
            //
            // It's identity blt.
            //

            pxlate->vSetIndex(0, 0);
            pxlate->vSetIndex(1, 1);
        }
        else
        {
            if (bCMYKColor)
            {
                pxlate->vSetIndex(0, iForeDst);
                pxlate->vSetIndex(1, iBackDst);
            }
            else
            {
                pxlate->vSetIndex(0, ulGetNearestIndexFromColorref(palDestSurf,
                                                                   palDestDC,
                                                                   iForeDst));
                pxlate->vSetIndex(1, ulGetNearestIndexFromColorref(palDestSurf,
                                                                   palDestDC,
                                                                   iBackDst));
            }

            //
            // XLATE_FROM_MONO is set so we know to look at colors in
            // cache code for getting a hit.
            //

            pxlate->flPrivate |= XLATE_FROM_MONO;
            pxlate->iForeDst = iForeDst;
            pxlate->iBackDst = iBackDst;
        }
    }
    else if (cEntry == 0)
    {
        ASSERTGDI(palSrc.cEntries() == 0, "ERROR how could this happen");

        //
        // Src is a RGB/Bitfields palette.
        //

        if (palDestSurf.bIsMonochrome())
        {
            //
            // Put the color the Background of the source matches in pulXlate[0]
            //

            pxlate->ai[0] = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;

            //
            // The S3 and other snazzy drivers look at this and get the color out
            // of slot 0 when XO_TO_MONO is set to get way better performance in
            // WinBench.
            //

            pxlate->pulXlate = pxlate->ai;
        }
    }
    else
    {
        //
        // Src is a regular indexed palette, it wouldn't have duplicating entries
        // in it so we don't need to check for the Dibsection case.  This is like
        // a palette for a 16 color VGA or a printer or a SetDIBitsToDevice.
        //

        if (palDestSurf.bValid() && palDestSurf.bIsMonochrome())
        {
            RtlZeroMemory(pxlate->ai,(UINT) cEntry * sizeof(*pxlate->ai));
            cEntry = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);
            ASSERTGDI(cEntry < pxlate->cEntries, "ERROR this is not in range");
            pxlate->vSetIndex(cEntry, 1);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;
        }
        else
        {
            if (bCMYKColor)
            {
                //
                // Copy source CMYK color table to index table.
                //

                while(cEntry--)
                {
                    pxlate->ai[cEntry] = palSrc.ulEntryGet(cEntry);
                }
            }
            else
            {
                //
                // If the destination is palette managed, map to logical palette
                // and then translate to physical indices accordingly.  Otherwise
                // map to the physical palette directly.
                //

                PPALETTE ppalTemp;

                if (bPalManaged && !(flCreateFlag & XLATE_USE_SURFACE_PAL))
                {
                    ppalTemp = palDestDC.ppalGet();
                }
                else
                {
                    ppalTemp = palDestSurf.ppalGet();

                    if (flCreateFlag & XLATE_USE_SURFACE_PAL)
                    {
                        pxlate->flPrivate |= XLATE_USE_SURFACE_PAL;
                    }
                }

                XEPALOBJ palTemp(ppalTemp);

                while(cEntry--)
                {

                    pxlate->ai[cEntry] =
                               palTemp.ulGetNearestFromPalentry(
                                                 palSrc.palentryGet(cEntry));
                }

                if (bPalManaged && !(flCreateFlag & XLATE_USE_SURFACE_PAL))
                {
                    //
                    // Map from DC palette to surface palette.
                    //

                    pxlate->vMapNewXlate((palDestSurf.bValid()) ? ptransCurrent
                                                                : ptransFore);
                }
            }
        }
    }

    pxlate->vCheckForTrivial();
    return(pxlate);
}

/******************************Public*Routine******************************\
* pCreateXlate
*
* This allocates an xlate object with ulNumEntries.
*
* Returns: The pointer to the xlate object, NULL for failure.
*
* History:
*  17-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PXLATE pCreateXlate(ULONG ulNumEntries)
{
    //
    // Allocate room for the XLATE.
    //

    PXLATE pxlate = (PXLATE) PALLOCNOZ((sizeof(XLATE) + sizeof(ULONG) * ulNumEntries),
                                       'tlxG');

    if (pxlate != NULL)
    {
        pxlate->iUniq = ulGetNewUniqueness(ulXlatePalUnique);
        if (ulNumEntries > 0)
        {
            pxlate->flXlate = XO_TABLE;
            pxlate->pulXlate = pxlate->ai;
            pxlate->flPrivate = 0;
        }
        else
        {
            pxlate->flXlate = 0;
            pxlate->pulXlate = NULL;
            pxlate->flPrivate = XLATE_RGB_SRC;
        }

        pxlate->iSrcType = pxlate->iDstType = 0;
        pxlate->cEntries = ulNumEntries;
        pxlate->lCacheIndex = XLATE_CACHE_INVALID;
        pxlate->ppalSrc = (PPALETTE) NULL;
        pxlate->ppalDst = (PPALETTE) NULL;
        pxlate->ppalDstDC = (PPALETTE) NULL;
    }
#if DBG
    else
    {
        WARNING("pCreateXlate failed memory allocation\n");
    }
#endif

    return(pxlate);
}


/******************************Public*Routine******************************\
* vCheckForTrivial
*
*   We need to check for trivial translation, it speeds up the inner-loop
*   for blting a great deal.
*
* History:
*
*  11-Oct-1995 -by- Tom Zakrajsek [tomzak]
* Fixed it to not mark xlates as trivial unless the Src and Dst were
* the same color depth.
*
*  17-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XLATE::vCheckForTrivial()
{
    //
    // Check if we already recognized trivial during creation
    //

    if (flXlate & XO_TRIVIAL)
        return;

    //
    // Source Color is CMYK, XO_TRIVIAL will not be on.
    //

    if (flXlate & XO_FROM_CMYK)
        return;

    //
    // See if it's really just a trivial xlate.
    //

    if (cEntries)
    {
        //
        // Just make sure that each index translates to itself, and
        // that the color depths are the same for the source and
        // destination.
        //

        ULONG ulTemp;

        if ((ppalSrc != NULL) &&
            (ppalDst != NULL) &&
            (ppalSrc->cEntries != ppalDst->cEntries))
        {
            return;
        }

        for (ulTemp = 0; ulTemp < cEntries; ulTemp++)
        {
            if (pulXlate[ulTemp] != ulTemp)
                return;
        }
    }
    else
    {
        //
        // If the Src and Dst have the same masks it's identity.
        //

        XEPALOBJ palSrc(ppalSrc);
        XEPALOBJ palDst(ppalDst);

        if ((palSrc.bValid()) &&
            (palDst.bValid()) &&
            (!palDst.bIsIndexed()))
        {
            ASSERTGDI(!palSrc.bIsIndexed(), "ERROR Src not indexed?");

            FLONG flRedSrc, flGreSrc, flBluSrc;
            FLONG flRedDst, flGreDst, flBluDst;

            if (palSrc.bIsBitfields())
            {
                flRedSrc = palSrc.flRed();
                flGreSrc = palSrc.flGre();
                flBluSrc = palSrc.flBlu();
            }
            else
            {
                flGreSrc = 0x0000FF00;

                if (palSrc.bIsRGB())
                {
                    flRedSrc = 0x000000FF;
                    flBluSrc = 0x00FF0000;
                }
                else
                {
                    ASSERTGDI(palSrc.bIsBGR(), "What is it then?");
                    flRedSrc = 0x00FF0000;
                    flBluSrc = 0x000000FF;
                }
            }

            if (palDst.bIsBitfields())
            {
                flRedDst = palDst.flRed();
                flGreDst = palDst.flGre();
                flBluDst = palDst.flBlu();
            }
            else
            {
                flGreDst = 0x0000FF00;

                if (palDst.bIsRGB())
                {
                    flRedDst = 0x000000FF;
                    flBluDst = 0x00FF0000;
                }
                else
                {
                    ASSERTGDI(palDst.bIsBGR(), "What is it then?");
                    flRedDst = 0x00FF0000;
                    flBluDst = 0x000000FF;
                }
            }

            if ((flRedSrc != flRedDst) ||
                (flGreSrc != flGreDst) ||
                (flBluSrc != flBluDst))
            {
                return;
            }
        }
        else
            return;
    }

    //
    // We found it is really just trivial.
    //

    flXlate |= XO_TRIVIAL;
}


/******************************Public*Routine******************************\
* EXLATEOBJ::vAddToCache
*
*   Adds an xlate object to the cache.
*
* Arguments:
*
*   palSrc   -
*   palDst   -
*   palSrcDC -
*   palDstDC -
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
EXLATEOBJ::vAddToCache(
    XEPALOBJ palSrc,
    XEPALOBJ palDst,
    XEPALOBJ palSrcDC,
    XEPALOBJ palDstDC
    )
{
    ULONG   cEntries;
    SEMOBJ  semo(ghsemPalette);

    for (cEntries = 0; cEntries < XLATE_CACHE_SIZE; cEntries++)
    {
        ASSERTGDI(ulTableIndex < XLATE_CACHE_SIZE, "table index out of range");

        if (xlateTable[ulTableIndex].pxlate != (PXLATE) 0)
        {
            if (xlateTable[ulTableIndex].ulReference != 0)
            {
                ulTableIndex = (ulTableIndex + 1) & XLATE_MODULA;
                continue;
            }

            VFREEMEM(xlateTable[ulTableIndex].pxlate);
        }

        //
        // Now add ours into the cache.
        //

        xlateTable[ulTableIndex].ulReference = 1;
        xlateTable[ulTableIndex].pxlate = (PXLATE)pxlate;
        xlateTable[ulTableIndex].ulPalSrc = palSrc.ulTime();
        xlateTable[ulTableIndex].ulPalDst = palDst.ulTime();
        xlateTable[ulTableIndex].ulPalSrcDC = palSrcDC.ulTime();
        xlateTable[ulTableIndex].ulPalDstDC = palDstDC.ulTime();

        //
        // Mark it so the destructor doesn't free it
        //

        pxlate->lCacheIndex = (LONG) ulTableIndex;

        //
        // Put in palSrc the index where to be found most quickly
        //

        palSrc.iXlateIndex(ulTableIndex);

        //
        // Move the cache ahead so we don't get deleted right away
        //

        ulTableIndex = (ulTableIndex + 1) & XLATE_MODULA;
        return;
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bSearchCache
*
*   Searches cache for a previously created xlate.
*
* Arguments:
*
*   palSrc   - src surface palette
*   palDst   - dst surface palette
*   palSrcDC - src DC palette
*   palDstDC - dst DC palette
*   iForeDst - For Mono->Color this is what a 0 goes to
*   iBackDst - For Mono->Color this is what a 1 goes to
*   iBackSrc - For Color->Mono this is the color that goes to
*              1, all other colors go to 0.
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bSearchCache(
    XEPALOBJ palSrc,
    XEPALOBJ palDst,
    XEPALOBJ palSrcDC,
    XEPALOBJ palDstDC,
    ULONG    iForeDst,
    ULONG    iBackDst,
    ULONG    iBackSrc,
    ULONG    flCreate
    )
{
    //
    // Start ulIndex at the last place in the cache that an pxlate match was
    // found for palSrc.
    //

    ULONG ulIndex = palSrc.iXlateIndex();
    ULONG ulLoop;
    SEMOBJ  semo(ghsemPalette);

    for (ulLoop = 0; ulLoop < XLATE_CACHE_SIZE; ulLoop++)
    {
        //
        // If the destination is palette managed we need to make sure we are going
        // through the correct Destination DC and that it is up to date.
        //

        if ((xlateTable[ulIndex].ulPalSrc == palSrc.ulTime()) &&
            (xlateTable[ulIndex].ulPalDst == palDst.ulTime()) &&
            (xlateTable[ulIndex].ulPalDstDC == palDstDC.ulTime()))
        {
            //
            // Lock down all the cache objects.
            //

            pxlate = xlateTable[ulIndex].pxlate;
            ASSERTGDI(bValid(), "GDIERROR:invalid pxlate xlate cache entry\n");
            ASSERTGDI(pxlate->lCacheIndex == (LONG) ulIndex, "GDIERROR:bad xlate.lCacheIndex\n");
            ASSERTGDI(!(pxlate->flPrivate & XLATE_RGB_SRC), "GDIERROR:a RGB_SRC in the cache ???\n");
            ASSERTGDI(palSrc.cEntries() == pxlate->cEntries, "ERROR bSearchCache cEntries not matching palSrc");

            //
            // Now check if it's a to/from monochrome and if it is,
            // are the fore/back colors still valid.
            //

            if (
                 (
                   ((XLATE_USE_SURFACE_PAL|XLATE_USE_FOREGROUND) & pxlate->flPrivate) == flCreate
                 )
                    &&
                 (
                   (
                     !((XO_TO_MONO & pxlate->flXlate) || (XLATE_FROM_MONO & pxlate->flPrivate))
                   )
                     ||
                   (
                     (XO_TO_MONO & pxlate->flXlate) &&
                     (iBackSrc == pxlate->iBackSrc) &&
                     (xlateTable[ulIndex].ulPalSrcDC == palSrcDC.ulTime())
                   )
                     ||
                   (
                     (XLATE_FROM_MONO & pxlate->flPrivate) &&
                     (iForeDst == pxlate->iForeDst) &&
                     (iBackDst == pxlate->iBackDst)
                   )
                 )
               )
            {

                //
                // HOT DOG, valid cache entry.  It isn't deletable now
                // because we have it locked down.  Cache the index in palSrc.
                //

                InterlockedIncrement((LPLONG) &(xlateTable[ulIndex].ulReference));
                palSrc.iXlateIndex(ulIndex);
                return(TRUE);
            }
        }

        ulIndex = (ulIndex + 1) & XLATE_MODULA;
    }

    pxlate = (PXLATE) NULL;
    return(FALSE);
}

/******************************Public*Routine******************************\
* XLATEOBJ_iXlate
*
*   This translates an index of a src palette to the closest index in the
*   dst palette.
*
* Arguments:
*
*   pxlo   -
*   cIndex -
*
* History:
*  Mon 16-Mar-1992 -by- Patrick Haluptzok [patrickh]
* Fixed something.
*
*  Wed 24-Jul-1991 -by- Patrick Haluptzok [patrickh]
* put in support for RGB-->monochrome.
*
*  22-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
ULONG
XLATEOBJ_iXlate(
    XLATEOBJ *pxlo,
    ULONG     cIndex
    )
{
    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
    {
        return(cIndex);
    }

    if (pxlo->flXlate & XO_TABLE)
    {
        if (cIndex > pxlo->cEntries)
        {
            cIndex = cIndex % pxlo->cEntries;
        }

        return(((XLATE *) pxlo)->ai[cIndex]);
    }

    //
    // We are beyond source palette being PAL_INDEXED.
    //

    if (pxlo->flXlate & XO_TO_MONO)
    {
        if (cIndex == ((XLATE *) pxlo)->ai[0])
        {
            return(1);
        }
        else
        {
            return(0);
        }
    }

    ASSERTGDI(((XLATE *) pxlo)->ppalSrc != (PPALETTE) NULL, "ERROR ppalSrc is NULL");

    //
    // For 8bpp destinations, go through MarkE's optimized tablelookup code.  This is
    // not so much for performance reasons (XLATEOBJ_iXlate is already hopelessly slow),
    // but to make sure GDI always performs this translation in the same way (with some drivers,
    // StretchBlt to a device surface ends up in EngCopyBits which uses MarkE's table, but
    // on the same machines StretchBlt to a memory surface goes through ulTranslate)
    //
    
    PPALETTE ppal = (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED ? 
                     ((XLATE *) pxlo)->ppalDstDC : ((XLATE *) pxlo)->ppalDst);

    ASSERTGDI(ppal != (PPALETTE) NULL, "ERROR ppal is NULL");
    ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");

    if ((ppal->flPal & PAL_INDEXED) &&
        (((XLATE *) pxlo)->ppalDstDC->cEntries == 256))
    {
        PBYTE pxlate555 = ((XEPALOBJ) ppal).pGetRGBXlate();
        if (pxlate555 == NULL)
        {
            WARNING1("Error in XLATEOBJ_iXlate:  can't generate pxlate555");
            return 0;
        }
        cIndex = XLATEOBJ_ulIndexToPalSurf(pxlo, pxlate555, cIndex);
    }
    else
    {
        PAL_ULONG palul;

        palul.ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(cIndex);

        if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
        {
            ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");
            
            cIndex = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).ulGetNearestFromPalentry(palul.pal, SE_DONT_SEARCH_EXACT_FIRST);


            if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
            {
                if (cIndex >= 10)
                {
                    cIndex += 236;
                }
            }
            else
            {
                ASSERTGDI(((XLATE *) pxlo)->ppalDstDC->flPal & PAL_DC, "ERROR in ulTranslate XLATEOBJ is hosed \n");
                ASSERTGDI(cIndex < ((XLATE *) pxlo)->ppalDstDC->cEntries, "ERROR in ultranslate3");

                if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
                {
                    cIndex = (ULONG) ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[cIndex];
                }
                else
                {
                    cIndex = (ULONG) ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[cIndex];
                }
            }
        }
        else
        {
            ASSERTGDI(((XLATE *) pxlo)->ppalDst != (PPALETTE) NULL, "ERROR ppalDst is NULL");

            cIndex = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).ulGetNearestFromPalentry(palul.pal, ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).cEntries() ? SE_DONT_SEARCH_EXACT_FIRST : SE_DO_SEARCH_EXACT_FIRST);
        }
    }

    return(cIndex);
}

/**************************************************************************\
* XLATEOBJ_pGetXlate555
*
*   Retrieve 555 rgb xlate vector from appropriate palette
*
* Arguments:
*
*   pxlo
*
* Return Value:
*
*   rgb555 xlate vector or NULL
*
* History:
*
*    2/27/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PBYTE
XLATEOBJ_pGetXlate555(
    XLATEOBJ *pxlo
    )
{
    PBYTE pxlate555 = NULL;

    //
    // return hi color to palette 555 translate table if the xlateobj
    // is appropriate
    //

    if (
         (pxlo == NULL) ||
         (pxlo->flXlate & XO_TRIVIAL) ||
         (pxlo->flXlate & XO_TABLE)   ||
         (pxlo->flXlate & XO_TO_MONO)
       )
    {
        return(NULL);
    }

    //
    // determine palette type to map.
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");

        pxlate555 = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).pGetRGBXlate();
    }
    else
    {
        if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).bValid())
        {
            pxlate555 = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).pGetRGBXlate();
        }
    }

    return(pxlate555);
}


/**************************************************************************\
* XLATEOBJ_ulIndexToPalSurf
*   - take generic pixel input, convert it to RGB, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - index input
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_ulIndexToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    ALPHAPIX apix;
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_ulIndexToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    apix.ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(ulRGB);

    palIndex = pxlate555[((apix.pix.b & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.r & 0xf8) >> 3)];


    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }

    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB32ToPalSurf
*   - take 32 RGB pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 32 bit RGB input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB32ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    ALPHAPIX apix;
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_RGB32ToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    palIndex = pxlate555[((apix.pix.b & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.r & 0xf8) >> 3)];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }

    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB32ToPalSurf
*   - take 32 BGR pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 32 bit BGR input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_BGR32ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex;
    ALPHAPIX apix;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR32ToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    palIndex = pxlate555[((apix.pix.r & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.b & 0xf8) >> 3)];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB16_565ToPalSurf
*   - take 16 bit 565 pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 16 bit 565 input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB16_565ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR16_565ToPalSurf: NULL pxlate555\n");

    palIndex = pxlate555[((ulRGB & 0xf800) >> 1) |
                         ((ulRGB & 0x07c0) >> 1) |
                         ((ulRGB & 0x001f))];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB16_555ToPalSurf
*   - take 16 bit 555 pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 16 bit 555 input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB16_555ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR16_555ToPalSurf: NULL pxlate555\n");

    palIndex = pxlate555[ulRGB & 0x7fff];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}


/******************************Public*Routine******************************\
* XLATEMEMOBJ
*
* This is a special constructor for the UpdateColors case.  It deletes the
* old xlate when it is done.
*
* History:
*  12-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

XLATEMEMOBJ::XLATEMEMOBJ(
    XEPALOBJ palSurf,
    XEPALOBJ palDC
    )
{
    //
    // Assert some fundamental truths.
    //

    ASSERTGDI(palDC.bValid(), "invalid palDC in xlatememobj123\n");
    ASSERTGDI(palSurf.bIsPalManaged(), "invalid surface palette in UpdateColors xlate");
    ASSERTGDI(palSurf.bValid(), "invalid palSurf in xlatememobj123\n");
    ASSERTGDI(!(palDC.bIsRGB()), "RGB palDC in DC->surf xlate constructor123\n");
    ASSERTGDI(!(palSurf.bIsRGB()), "RGB palSurf in DC->surf xlate constructor123\n");
    ASSERTGDI(palDC.bIsPalDC(), "not a palDC for palDC in xlatememobj123\n");
    ASSERTGDI(palDC.ptransCurrent() != NULL, "ERROR ptrans Null UpdateColors");
    ASSERTGDI(palDC.ptransOld() != NULL, "ERROR ptransOld Null UpdateColors");

    ULONG ulTemp;
    PULONG pulTemp;

    pxlate = pCreateXlate(palSurf.cEntries());

    if (pxlate)
    {
        pxlate->ppalSrc = palSurf.ppalGet();
        pxlate->ppalDst = palSurf.ppalGet();
        pxlate->ppalDstDC = palDC.ppalGet();
        pulTemp = pxlate->ai;

        //
        // Set up identity vector for all entries
        //

        for (ulTemp = 0; ulTemp < pxlate->cEntries; ulTemp++)
        {
            pulTemp[ulTemp] = ulTemp;
        }

        //
        // Change the ones that are affected by the palette realizations.
        //

        PTRANSLATE ptransOld = palDC.ptransOld();
        PTRANSLATE ptransCurrent = palDC.ptransCurrent();

        for (ulTemp = 0; ulTemp < palDC.cEntries(); ulTemp++)
        {
            pulTemp[ptransOld->ajVector[ulTemp]] = (ULONG) ptransCurrent->ajVector[ulTemp];
        }

        pxlate->vCheckForTrivial();
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bCreateXlateFromTable
*
* This is used to initialize an xlate when the table is already computed.
* We need this to support journaling.
*
* History:
*  17-Mar-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bCreateXlateFromTable(
    ULONG cEntry,
    PULONG pulVector,
    XEPALOBJ palDst
    )
{
    //
    // Assert good input data.
    //

    ASSERTGDI(palDst.bValid(), "ERROR bInitXlate bad palDst");
    ASSERTGDI(pulVector != (PULONG) NULL, "ERROR bInitXlate bad pulVector");
    ASSERTGDI(cEntry != 0, "ERROR bInitXlate cEntry is 0");

    //
    // Allocate room for the Xlate.
    //

    pxlate = pCreateXlate(cEntry);

    if (pxlate == NULL)
    {
        WARNING("ERROR bInitXlate failed call to pCreateXlate\n");
        return(FALSE);
    }

    pxlate->ppalDst = palDst.ppalGet();
    pxlate->iDstType = (USHORT) palDst.iPalMode();

    //
    // Ok, fill in the xlate vector.
    //

    RtlCopyMemory(pxlate->ai, pulVector, (UINT) (cEntry * sizeof(ULONG)));

    //
    // Init accelerators, out of here.
    //

    pxlate->vCheckForTrivial();
    return(TRUE);
}


/******************************Public*Routine******************************\
* XLATE::vCheckForICM()
*
* History:
*  26-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID XLATE::vCheckForICM(HANDLE _hcmXform,ULONG _lIcmMode)
{
    //
    // First, initialize ICM mode as default (off)
    //
    lIcmMode = DC_ICM_OFF;
    hcmXform = NULL;

    //
    // Check is there any ICM is enabled ?
    //
    if (IS_ICM_ON(_lIcmMode))
    {
        if (IS_ICM_INSIDEDC(_lIcmMode))
        {
            //
            // Inside DC ICM is enabled with valid color transform.
            //

            //
            // Copy mode and color transform handle to XLATE.
            //
            lIcmMode = _lIcmMode;
            hcmXform = _hcmXform;

            if (IS_ICM_DEVICE(lIcmMode))
            {
                COLORTRANSFORMOBJ CXFormObj(_hcmXform);

                //
                // Check transform handle is valid or not.
                //
                if (CXFormObj.bValid())
                {
                    ICMMSG(("vCheckForICM():XO_DEVICE_ICM\n"));

                    //
                    // Device driver will do color matching.
                    //
                    flXlate |= XO_DEVICE_ICM;
                }
            }
            else if (IS_ICM_HOST(lIcmMode))
            {
                ICMMSG(("vCheckForICM():XO_HOST_ICM\n"));

                //
                // Inform the images is corrected by host CMM
                //
                flXlate |= XO_HOST_ICM;

                if (IS_CMYK_COLOR(lIcmMode) && (hcmXform != NULL))
                {
                    ICMMSG(("vCheckForICM():XO_FROM_CMYK\n"));

                    //
                    // The destination surface is 32bits CMYK color,
                    // This is only happen when ICM is done by host.
                    //
                    flXlate |= XO_FROM_CMYK;
                }
            }
        }
        else if (IS_ICM_OUTSIDEDC(_lIcmMode))
        {
            //
            // Outside DC is enabled, color correction is done by application.
            //

            //
            // Copy mode and color transform handle to XLATE.
            //
            lIcmMode = _lIcmMode;
            hcmXform = 0;

            //
            // Inform the images is corrected by Host (application) ICM
            //
            flXlate |= XO_HOST_ICM;
        }
    }
}

/******************************Public*Routine******************************\
* vXlateBitfieldsToBitfields
*
* Translates a color between to arbitrary bitfield (or RGB or BGR) formats.
\**************************************************************************/

ULONG FASTCALL iXlateBitfieldsToBitfields(XLATEOBJ* pxlo, ULONG ul)
{
    ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(ul);
    ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalDst).ulGetNearestFromPalentry(
                                        *((PALETTEENTRY*) &ul));

    return(ul);
}

ULONG FASTCALL iXlate565ToBGR(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul << 8) & 0xf80000)
         | ((ul << 3) & 0x070000)
         | ((ul << 5) & 0x00fc00)
         | ((ul >> 1) & 0x000300)
         | ((ul << 3) & 0x0000f8)
         | ((ul >> 2) & 0x000007));
}

ULONG FASTCALL iXlate555ToBGR(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul << 9) & 0xf80000)
         | ((ul << 4) & 0x070000)
         | ((ul << 6) & 0x00f800)
         | ((ul << 1) & 0x000700)
         | ((ul << 3) & 0x0000f8)
         | ((ul >> 2) & 0x000007));
}

ULONG FASTCALL iXlateBGRTo565(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul >> 8) & 0xf800)
         | ((ul >> 5) & 0x07e0)
         | ((ul >> 3) & 0x001f));
}

ULONG FASTCALL iXlateBGRTo555(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul >> 9) & 0x7c00)
         | ((ul >> 6) & 0x03e0)
         | ((ul >> 3) & 0x001f));
}

/******************************Public*Routine******************************\
* pfnXlateBetweenBitfields
*
* Returns a pointer to an optimized routine for converting between
* two bitfields (or RGB or BGR) colors.
\**************************************************************************/

PFN_pfnXlate XLATE::pfnXlateBetweenBitfields()
{
    PFN_pfnXlate pfnXlate;
    XEPALOBJ palSrc(ppalSrc);
    XEPALOBJ palDst(ppalDst);

    ASSERTGDI(palSrc.bIsBitfields() || palSrc.bIsRGB() || palSrc.bIsBGR(),
        "ERROR: Expected bitfields source");
    ASSERTGDI(palDst.bIsBitfields() || palDst.bIsRGB() || palDst.bIsBGR(),
        "ERROR: Expected bitfields destination");

    pfnXlate = iXlateBitfieldsToBitfields;

    if (palDst.bIsBGR())
    {
        if (palSrc.bIs565())
        {
            pfnXlate = iXlate565ToBGR;
        }
        else if (palSrc.bIs555())
        {
            pfnXlate = iXlate555ToBGR;
        }
    }
    else if (palSrc.bIsBGR())
    {
        if (palDst.bIs565())
        {
            pfnXlate = iXlateBGRTo565;
        }
        else if (palDst.bIs555())
        {
            pfnXlate = iXlateBGRTo555;
        }
    }

    return(pfnXlate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\amd64\tiler.cxx ===
/*******************************Module*Header*****************************\
* 
*  Copyright (c) 1992-1999  Microsoft Corporation
*  Copyright (c) 1992  Digital Equipment Corporation
* 
*  Module Name:
* 
*     tiler.cxx
* 
*  Abstract:
* 
*     This module implements code to copy a pattern to a target surface.
* 
*  Author:
* 
*    David N. Cutler (davec) 4-May-1992
* 
*  Rewritten in C by:
* 
*    Eric Rehm (rehm@zso.dec.com) 15-July-1992
* 
*  Environment:
* 
*     User mode only.
* 
*  Revision History:
* 
\*************************************************************************/

#include "precomp.hxx"

VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);
VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern.
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;       // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;
                                    // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern
      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }
      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                      // set target to complement of 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchNotAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;      // base pattern address
    ULONG   UNALIGNED *pulPatCur;   // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                        // set target to complemented 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftNotAndCopy


/****************************Private*Routine******************************\
*
*  VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for copying an 8-byte pattern to
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to copy.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID CopyPattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat;              // store low 4 bytes of pattern
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    if ((culFill & 0x02) != 0)      // check if even multiple of 8 bytes
    {
      while (pulTrg <= pulTrgEnd)   // if not, move 8 bytes at a time
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        pulTrg += 2;                // advance target address
      }
      return;
    }
    else                            //  move 16 bytes at a time
    {
      pulTrgEnd -= 2;               // ending segement address
      while (pulTrg <= pulTrgEnd)
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        *(pulTrg + 2) = loPat;      // store 8-byte pattern value
        *(pulTrg + 3) = hiPat;
        pulTrg += 4;                // advance target address
      }
    }
}



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using ropt (DPx).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy

    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndMerge



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
      }
    }
} // end vFetchShiftAndMerge


/****************************Private*Routine******************************\
*
*  VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for merging an 8-byte pattern with
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to merge.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID MergePattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR low 4 bytes of pattern w/ target
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    while (pulTrg <= pulTrgEnd)     // if not, move 8 bytes at a time
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
      *pulTrg = hiPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\gdiplus\usermode.cxx ===
/******************************Module*Header*******************************\
* Module Name: usermode.cxx
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
* This file contains all the system abstraction routines required to allow 
* GDI to run as a stand-alone graphics library in user-mode.  
*
* Created: 29-Apr-1998
* Author: J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
    BOOL gbRemoteSession=0;
}

// Temporary HDEV for first bringing up user-mode GDI+, which represents
// the screen 'device'.  This sure as heck had better be temporary!

HDEV ghdevDisplay;

// Copy of a drvsup.cxx structure that should really be moved to engine.h:

typedef struct _DRV_NAMES {
    ULONG            cNames;
    struct {
        HANDLE           hDriver;
        LPWSTR           lpDisplayName;
    } D[1];
} DRV_NAMES, *PDRV_NAMES;

HDEV hCreateHDEV(PGRAPHICS_DEVICE,PDRV_NAMES,PDEVMODEW,PVOID,BOOL,FLONG,HDEV*);

// Some random goop needed for linking user-mode GDI+:

extern "C" {
    PEPROCESS gpepCSRSS;
    ULONG gSessionId;
};

/*****************************Private*Routine******************************\
* BOOL GpInitialize
*
* History:
*  3-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

extern "C"
BOOL 
GpInitialize(
HWND hwnd)
{
    DRV_NAMES   drvName;
    HDEV        hdevDisabled;
    BOOL        bRet = FALSE;

    drvName.cNames             = 1;
    drvName.D[0].hDriver       = NULL;
    drvName.D[0].lpDisplayName = (LPWSTR)GpsEnableDriver;

    if (ghdevDisplay == NULL)
    {
        KdPrint(("hCreateDEV.................\n"));

        ghdevDisplay = hCreateHDEV(NULL,
                                   &drvName,
                                   ((PDEVMODEW)(hwnd)),
                                   NULL,
                                   TRUE, // ignored in this case
                                   GCH_GDIPLUS_DISPLAY,
                                   &hdevDisabled);

        bRet = (ghdevDisplay != NULL);
    }
    else
    {
        WARNING("Can't yet create multiple windows");
    }

    return(bRet);
}

/*****************************Private*Routine******************************\
* HDC UserGetDesktopDC
*
* History:
*  3-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
UserGetDesktopDC(
ULONG   iType,
BOOL    bAltType,
BOOL    bValidate)
{
    HDC hdc = NULL;

    if ((iType == DCTYPE_DIRECT) && (bValidate))
    {
        if (ghdevDisplay != NULL)
        {
            hdc = GreCreateDisplayDC(ghdevDisplay, DCTYPE_DIRECT, bAltType);
        }
        else
        {
            WARNING("ghdevDisplay not initialized");
        }
    }
    else
    {
        WARNING("UserGetDesktopDC functionality not yet handled");
    }

    return(hdc);
}

/*****************************Private*Routine******************************\
* HDEV UserGetHDEV
*
\**************************************************************************/

HDEV
UserGetHDEV()
{
    return(ghdevDisplay);
}

/*****************************Private*Routine******************************\
* BOOL UserVisrgnFromHwnd
*
\**************************************************************************/

BOOL 
UserVisrgnFromHwnd(
HRGN*   phrgn,
HWND    hwnd)
{
    *phrgn = NULL;
    return(FALSE);
}

/*****************************Private*Routine******************************\
* DWORD GetAppCompatFlags
*
\**************************************************************************/

extern "C"
DWORD 
GetAppCompatFlags(
PVOID pv)
{
    return(0);
}

/*****************************Private*Routine******************************\
* VOID* pAllocMem
*
* Hack for screen.c header mess.
*
\**************************************************************************/

extern "C"
VOID*
pAllocMem(
ULONG   size,
ULONG   tag)
{
    return(PALLOCMEM(size, tag));
}

/*****************************Private*Routine******************************\
* VOID vFreeMem
*
* Hack for screen.c header mess.
*
\**************************************************************************/

extern "C"
VOID 
vFreeMem(
VOID*   p)
{
    VFREEMEM(p);
}


NTSTATUS
MapViewInProcessSpace(
    PVOID   pv,
    PVOID  *ppv,
    ULONG  *psize
    )

/*++

Routine Description:

    Map view of a file into current process' address space

Arguments:

    pv - Points to a MEMORY_MAPPED_FILE structure
    ppv - Return the base address of the mapped view
    psize - Return the size of the mapped view

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/

{
    MEMORY_MAPPED_FILE *mappedFile = (MEMORY_MAPPED_FILE *) pv;

    if (!mappedFile ||
        !mappedFile->fileMap ||
        !(*ppv = MapViewOfFile(mappedFile->fileMap,
                               mappedFile->readOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
                               0,
                               0,
                               mappedFile->fileSize)))
    {
        WARNING("MapViewInProcessSpace failed\n");
        *ppv = NULL;
        *psize = 0;
        return STATUS_UNSUCCESSFUL;
    }

    *psize = mappedFile->fileSize;
    return STATUS_SUCCESS;
}


NTSTATUS
UnmapViewInProcessSpace(
    PVOID   pv
    )

/*++

Routine Description:

    Unmap view of a file from the current process' address space

Arguments:

    pv - Base address of the view to be unmapped

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/

{
    return UnmapViewOfFile(pv) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


BOOL
CreateMemoryMappedSection(
    PWSTR     filename,
    FILEVIEW *fileview,
    INT       size
    )

/*++

Routine Description:

    Create a memory-mapped file structure

Arguments:

    filename - Specifies the name of the file to be mapped
    fileview - Return information about the memory-mapped file
    size - Size to be mapped
        0 : map entire content of an existing file for reading
        else : create a file of the specified size for reading & writing

Return Value:

    TRUE if successful, FALSE otherwise

--*/

#define SYSTEM32_STR    L"SYSTEM32"
#define SYSTEM32_LEN    8
#define SYSTEMROOT_STR  L"SYSTEMROOT"
#define SYSTEMROOT_LEN  10

{
    FILEVIEW fv;
    HANDLE fileHandle;
    MEMORY_MAPPED_FILE *mappedFile;
    BY_HANDLE_FILE_INFORMATION fileinfo;
    WCHAR fullpath[MAX_PATH];
    PWSTR p;

    ZeroMemory(&fv, sizeof(FILEVIEW));
    ZeroMemory(fileview, sizeof(FILEVIEW));

    //
    // Expand the input filename to fully qualified path
    //

    p = filename;

    while (*p && _wcsnicmp(p, SYSTEMROOT_STR, SYSTEMROOT_LEN))
        p++;

    if (*p)
    {
        if (GetWindowsDirectoryW(fullpath, MAX_PATH))
        {
            wcscat(fullpath, p + SYSTEMROOT_LEN);
            filename = fullpath;
        }
        else
        {
            WARNING("GetWindowsDirectory failed\n");
            return FALSE;
        }
    }
    else
    {
        p = filename;

        while (*p && _wcsnicmp(p, SYSTEM32_STR, SYSTEM32_LEN))
            p++;

        if (*p)
        {
            if (GetSystemDirectoryW(fullpath, MAX_PATH))
            {
                wcscat(fullpath, p + SYSTEM32_LEN);
                filename = fullpath;
            }
            else
            {
                WARNING("GetSystemDirectory failed\n");
                return FALSE;
            }
        }
    }

    //
    // Allocate memory for a MEMORY_MAPPED_FILE structure
    // (assume content is zero-initialized)
    //

    mappedFile = (MEMORY_MAPPED_FILE *) PALLOCMEM(sizeof(MEMORY_MAPPED_FILE), 'fmmG');

    if (mappedFile == NULL)
        return NULL;

    //
    // Open the file for reading or writing
    //

    if (size != 0)
    {
        mappedFile->readOnly = FALSE;

        fileHandle = CreateFileW(filename,
                                 GENERIC_READ|GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
    }
    else
    {
        mappedFile->readOnly = TRUE;

        fileHandle = CreateFileW(filename,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);
    }

    if (fileHandle == INVALID_HANDLE_VALUE)
        goto errorExit;

    //
    // Get timestamp information about the file
    //

    if (!GetFileInformationByHandle(fileHandle, &fileinfo))
        goto errorExit;

    fv.LastWriteTime.LowPart = fileinfo.ftLastWriteTime.dwLowDateTime;
    fv.LastWriteTime.HighPart = fileinfo.ftLastWriteTime.dwHighDateTime;

    //
    // If file was opened for writing, set it to requested size
    //

    if (size != 0)
    {
        if (size > 0)
            fileinfo.nFileSizeLow = (DWORD) size;

        fileinfo.nFileSizeHigh = 0;

        if (!SetFilePointer(fileHandle, fileinfo.nFileSizeLow, 0, FILE_BEGIN))
            goto errorExit;
    }

    if (fileinfo.nFileSizeHigh != 0)
        goto errorExit;

    mappedFile->fileSize = fv.cjView = fileinfo.nFileSizeLow;

    //
    // Create a file mapping handle
    //

    mappedFile->fileMap = CreateFileMapping(
                                fileHandle,
                                NULL,
                                mappedFile->readOnly ? PAGE_READONLY : PAGE_READWRITE,
                                0,
                                fileinfo.nFileSizeLow,
                                NULL);
    
    if (mappedFile->fileMap != NULL)
    {
        CloseHandle(fileHandle);
        fv.pSection = mappedFile;

        CopyMemory(fileview, &fv, sizeof(FILEVIEW));
        return TRUE;
    }

errorExit:

    WARNING("CreateMemoryMappedSection failed\n");

    if (fileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(fileHandle);
    
    DeleteMemoryMappedSection(mappedFile);
    return FALSE;
}


VOID
DeleteMemoryMappedSection(
    PVOID pv
    )

/*++

Routine Description:

    Dispose of a memory-mapped file structure

Arguments:

    pv - Points to a MEMORY_MAPPED_FILE structure

Return Value:

    NONE

--*/

{
    MEMORY_MAPPED_FILE *mappedFile = (MEMORY_MAPPED_FILE *) pv;

    if (mappedFile != NULL)
    {
        if (mappedFile->fileMap != NULL)
            CloseHandle(mappedFile->fileMap);

        VFREEMEM(mappedFile);
    }
}


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    PHANDLE KeyHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes
    )

{
    if (DesiredAccess == GENERIC_READ || DesiredAccess == 0)
        DesiredAccess = KEY_READ;
    
    return NtOpenKey(KeyHandle, DesiredAccess, ObjectAttributes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\gdiplus\usermode.h ===
/******************************Module*Header*******************************\
* Module Name: usermode.h
*
* This file contains all the system abstraction definitions required to allow 
* GDI to run as a stand-alone graphics library in user-mode.  
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include <nturtl.h>
#include <winbase.h>
#include <winnls.h>

// Prototype for GDI+ virtual screen driver entry point:

BOOL GpsEnableDriver(ULONG, ULONG, DRVENABLEDATA*);

// User-mode GDI doesn't require any security probing:

#undef ProbeForRead
#undef ProbeForWrite
#undef ProbeAndReadStructure
#undef ProbeAndWriteStructure
#undef ProbeAndReadUlong
#undef ProbeAndWriteUlong

#define ProbeForRead(a, b, c) 0
#define ProbeForWrite(a, b, c) 0
#define ProbeAndReadStructure(a, b) (*(b *)(a))
#define ProbeAndWriteStructure(a, b, c) (*(a) = (b))
#define ProbeAndReadUlong(a) (*(ULONG *)(a))
#define ProbeAndWriteUlong(a, b) (*(a) = (b))

#undef IS_SYSTEM_ADDRESS
#undef MM_LOWEST_USER_ADDRESS
#undef MM_HIGHEST_USER_ADDRESS
#undef MM_USER_PROBE_ADDRESS
#define MM_LOWEST_USER_ADDRESS NULL
#define MM_HIGHEST_USER_ADDRESS ((VOID*) 0xffffffff)
#define MM_USER_PROBE_ADDRESS 0xffffffff

#define ExSystemExceptionFilter() EXCEPTION_EXECUTE_HANDLER

// The following are not needed for user-mode GDI:

#define KeSaveFloatingPointState(a) STATUS_SUCCESS
#define KeRestoreFloatingPointState(a) STATUS_SUCCESS

#define UserScreenAccessCheck() TRUE
#define UserGetHwnd(a, b, c, d) 0
#define UserAssertUserCritSecOut()
#define UserEnterUserCritSec()
#define UserLeaveUserCritSec()
#define UserIsUserCritSecIn() 0
#define UserAssertUserCritSecIn()
#define UserRedrawDesktop()
#define UserReleaseDC(a)
#define UserGetClientRgn(a, b, c) 0
#define UserAssociateHwnd(a, b)
#define UserSetTimer(a,b) 1
#define UserKillTimer(a) 

#define ClientPrinterThunk(a, b, c, d) 0xffffffff

#define AlignRects(a, b, c, d) 0

#define IofCallDriver(a, b) STATUS_UNSUCCESSFUL
#define IoBuildSynchronousFsdRequest(a, b, c, d, e, f, g) 0
#define IoInitializeIrp(a, b, c) 
#define IoBuildDeviceIoControlRequest(a, b, c, d, e, f, g, h, i) 0
#define IoBuildAsynchronousFsdRequest(a, b, c, d, e, f) 0
#define IoGetRelatedDeviceObject(a) 0
#define IoReadOperationCount 0
#define IoWriteOperationCount 0
#define IoQueueThreadIrp(a)
#define IoFreeIrp(a)
#define IoAllocateMdl(a, b, c, d, e) 0
#define IoFreeMdl(a)
#define IoAllocateIrp(a, b) 0
#define IoGetDeviceObjectPointer(a, b, c, d) STATUS_UNSUCCESSFUL
#define IoOpenDeviceRegistryKey(a, b, c, d) STATUS_UNSUCCESSFUL
#define IoGetRelatedDeviceObject(a) 0

#define ObOpenObjectByPointer(a, b, c, d, e, f, g) STATUS_UNSUCCESSFUL
#define ObReferenceObjectByHandle(a, b, c, d, e, f) STATUS_UNSUCCESSFUL
#define ObfDereferenceObject(a) STATUS_UNSUCCESSFUL

#define MmResetDriverPaging(a)
#define MmGrowKernelStack(a) STATUS_SUCCESS
#define MmQuerySystemSize() MmMediumSystem

#undef KeEnterCriticalRegion
#undef KeLeaveCriticalRegion
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#define KeInitializeSpinLock(a)
#define KeInitializeDpc(a, b, c)
#define KeGetCurrentIrql() PASSIVE_LEVEL
#define KeSetKernelStackSwapEnable(a) 0
#define KeResetEvent(a)

#undef SeStopImpersonatingClient
#undef SeDeleteClientSecurity
#define SeStopImpersonatingClient()
#define SeDeleteClientSecurity(a)
#define SeImpersonateClientEx(a, b) STATUS_UNSUCCESSFUL
#define SeCreateClientSecurity(a, b, c, d) STATUS_UNSUCCESSFUL

#define Win32UserProbeAddress 0
#define HalRequestSoftwareInterrupt(x) 0         

#undef W32GetCurrentPID
#define W32GetCurrentPID() ((W32PID) NtCurrentTeb()->ClientId.UniqueProcess)

#undef W32GetCurrentProcess
__inline PW32PROCESS W32GetCurrentProcess() { return(NULL); }

#undef PsGetCurrentProcess
__inline PEPROCESS PsGetCurrentProcess() { return(NULL); }

// Re-route all the memory allocations:

#define ExAllocatePoolWithTag(type, size, tag)  \
                        RtlAllocateHeap(RtlProcessHeap(), 0, (size))
#define ExFreePool(p)   RtlFreeHeap(RtlProcessHeap(), 0, (p))

#define ExDeletePagedLookasideList(a)

// Give up our time-slice when KeDelayExecutionThread called:                        

#define KeDelayExecutionThread(a, b, c) Sleep(0)

// @@@ The following are temporary (I hope!)

#undef W32GetCurrentTID
#undef W32GetCurrentThread
__inline PW32THREAD W32GetCurrentThread() { return(NULL); }     // @@@
#define W32GetCurrentTID (W32PID) 0 // @@@

#define ExIsProcessorFeaturePresent(a) 0              


/*
   comma expressions don't work in free builds since
   WARNING(x) and RIP(x) expand to nothing.
*/

#if DBG

#define IS_SYSTEM_ADDRESS(a) (RIP("IS_SYTEM_ADDRESS"), 0)


#define MmSecureVirtualMemory(x, y, z) \
            (WARNING("@@@ MmSecureVirtualMemory"), (HANDLE) 1)
#define MmUnsecureVirtualMemory(x)

#define KeAttachProcess(x) \
            (WARNING("@@@ KeAttachProcess"), STATUS_UNSUCCESSFUL)
#define KeDetachProcess() STATUS_UNSUCCESSFUL

#undef KeInitializeEvent

#define KeInitializeEvent(a, b, c) \
            (WARNING("@@@ KeInitializeEvent"), STATUS_UNSUCCESSFUL)
#define KeSetEvent(a, b, c) \
            (RIP("KeSetEvent"), STATUS_UNSUCCESSFUL)
#define KeWaitForSingleObject(a, b, c, d, e) \
            (RIP("KeWaitForSingleObject"), STATUS_UNSUCCESSFUL)
#define KeWaitForMultipleObjects(a, b, c, d, e, f, g, h) \
                (RIP("KeWaitForMultipleObjects"), STATUS_UNSUCCESSFUL)


#define MmMapViewOfSection(a, b, c, d, e, f, g, h, i, j) \
            (RIP("MmMapViewOfSection"), STATUS_UNSUCCESSFUL)
#define MmUnmapViewOfSection(a, b) STATUS_UNSUCCESSFUL
#define MmMapViewInSessionSpace(a, b, c) \
            (RIP("MmMapViewInSessionSpace"), STATUS_UNSUCCESSFUL)
#define MmUnmapViewInSessionSpace(a) STATUS_UNSUCCESSFUL
#define MmCreateSection(a, b, c, d, e, f, g, h) \
            (RIP("MmCreateSection"), STATUS_UNSUCCESSFUL)


#else // !DBG

#define IS_SYSTEM_ADDRESS(a) 0


#define MmSecureVirtualMemory(x, y, z) ((HANDLE) 1)
#define MmUnsecureVirtualMemory(x)

#define KeAttachProcess(x) STATUS_UNSUCCESSFUL
#define KeDetachProcess() STATUS_UNSUCCESSFUL

#undef KeInitializeEvent

#define KeInitializeEvent(a, b, c) STATUS_UNSUCCESSFUL
#define KeSetEvent(a, b, c) STATUS_UNSUCCESSFUL
#define KeWaitForSingleObject(a, b, c, d, e) STATUS_UNSUCCESSFUL
#define KeWaitForMultipleObjects(a, b, c, d, e, f, g, h) STATUS_UNSUCCESSFUL


#define MmMapViewOfSection(a, b, c, d, e, f, g, h, i, j) STATUS_UNSUCCESSFUL
#define MmUnmapViewOfSection(a, b) STATUS_UNSUCCESSFUL
#define MmMapViewInSessionSpace(a, b, c) STATUS_UNSUCCESSFUL
#define MmUnmapViewInSessionSpace(a) STATUS_UNSUCCESSFUL
#define MmCreateSection(a, b, c, d, e, f, g, h) STATUS_UNSUCCESSFUL

#endif // !DBG


            __inline LARGE_INTEGER KeQueryPerformanceCounter(
PLARGE_INTEGER PerformanceFrequency)
{
    LARGE_INTEGER li = { 0, 0 };
    return(li);
}

#define RtlGetDefaultCodePage(a, b) \
        { \
            *(a) = (USHORT) GetACP(); \
            *(b) = (USHORT) GetOEMCP(); \
        }

typedef struct _MEMORY_MAPPED_FILE
{
    HANDLE  fileMap;
    DWORD   fileSize;
    BOOL    readOnly;
} MEMORY_MAPPED_FILE;

NTSTATUS MapViewInProcessSpace(PVOID, PVOID*, ULONG*);
NTSTATUS UnmapViewInProcessSpace(PVOID);
BOOL CreateMemoryMappedSection(PWSTR, FILEVIEW*, INT);
VOID DeleteMemoryMappedSection(PVOID);

NTSYSAPI
NTSTATUS
NTAPI
ZwCloseKey(
    HANDLE Handle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\cachea.asm ===
page ,132
;*****************************Module*Header*******************************\
; Module Name: cache.asm
;
;
; Created: 9-Dec-1992
; Author:  Paul Butzi
;
; Copyright (c) 1990-1999 Microsoft Corporation
;
;*************************************************************************/
; Note: This module would be more efficient with Frame Pointer Omission
; (FPO), whereby the stack is addressed off ESP rather than EBP, so we
; could stop pushing and popping EBP. However, the ASM macros currently
; don't support FPO.
;*************************************************************************/

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        .list


        .code
EXTRNP  xprunFindRunRFONTOBJ,2
EXTRNP  xpgdDefault,1
EXTRNP  xInsertMetricsRFONTOBJ,3
EXTRNP  xInsertMetricsPlusRFONTOBJ,3
EXTRNP  xInsertGlyphbitsRFONTOBJ,3

ifdef FE_SB
EXTRNP  xwpgdGetLinkMetricsRFONTOBJ,2
EXTRNP  xwpgdGetLinkMetricsPlusRFONTOBJ,3
endif


FAST_WCHAR_BASE equ 20h         ; Most ANSI fonts have a base of 32

;******************************Public*Routine******************************\
;
; BOOL RFONTOBJ::bGetGlyphMetrics (
;     COUNT c,
;     GLYPHPOS *pgp,
;     WCHAR *pwc
;     );
;
; Translate wchars into an array of GLYPHPOS structures, filling in
; the pointer to GLYPHDATA field.  Only the metrics are assured to be
; valid; no attempt is made to ensure that the glyph data itself is
; present in the cache before the return to the caller.
;
; This routine is to be used primarily by GetTextExtent and GetCharWidths,
; which have no need for anything except metrics.
;
; A zero return means that we failed to insert the metrics due to some
; hard error, most likely a failure to commit memory in the glyph
; insertion routine.
;
; History:
;  21-Dec-92 -by- Michael Abrash
; Fixed bug in detecting run inclusion
;  9-Dec-92 -by- Paul Butzi
; Wrote it.
;**************************************************************************/



cPublicProc xGetGlyphMetrics,4,< \
        uses       ebx esi edi,          \
        pThis:     ptr dword,            \
        c_:        dword,                \
        pgp:       ptr dword,            \
        pwc:       dword                 >
        mov     eax, pThis              ; (eax) = ptr to RFONTOBJ
        mov     eax, [eax].prfnt        ; (eax) = ptr to RFONT
        mov     esi, pwc                ; pointer to wchar data
                                        ;*486 pipelining
        mov     eax, [eax].wcgp         ; (eax) = ptr to wcgp
        mov     edi, pgp                ; pointer to glyphpos array to fill
                                        ;*486 pipelining
        lea     ebx, [eax].agprun       ; (ebx) = ptr to first wcgp run
                                        ;*486 pipelining
        mov     ecx, [ebx].wcLow        ; index of start of run
        mov     edx, [ebx].cGlyphs      ; # of glyphs in run
        mov     ebx, [ebx].apgd         ; pointer to run's pointers to cached
                                        ;  glyphdata

        push    ebp
        mov     ebp,c_  ; we'll use EBP for the glyph count
                        ; ***stack frame no longer available***
;
; Invariants:
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to base of current run
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining
loop_top:

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar, zero extended

        sub     eax, ecx                ; get index relative to current run base
        cmp     eax, edx                ; is wchar in this run?
        jae     short find_run          ; wrong run, better go get right one

run_found:

        mov     eax, [ebx+4*eax]        ; (ecx) = ptr to glyphdata


;
; Invariants:
;       (esi, edi, ebx, ecx, edx) as above at loop top
;       (eax) = ptr to glyphdata
;
default_found:
        and     eax, eax                ; is cached glyphdata there?
        jz      short get_glyph         ; no glyphdata, better go get one

;
; Here, we are assured that the glyphdata is present in the cache
;
glyph_found:
        mov     [edi].gp_pgdf, eax      ; set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg
        mov     [edi].gp_hg, eax        ; set hg in glyphpos


        add     edi, SIZE_GLYPHPOS      ; next glyphpos to fill in
        add     esi, 2          ; next wchar to look up

        dec     ebp             ; any more glyphs?
        jnz     loop_top

        pop     ebp             ; ***stack frame available***

        mov     eax, 1          ; success
        stdRET  xGetGlyphMetrics




;=======================================================================
; We got here because the current run does not contain the wchar we're
; interested in.  Note that the following invariants must hold when
; we re-enter the loop (starred items must hold on entry, as well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
find_run:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***
                                ; *****************************************
                                ; * Note that the approach here is to get *
                                ; * EBP off the stack, where it was       *
                                ; * pushed, by addressing off ESP. EBP    *
                                ; * remains pushed, so we don't need to   *
                                ; * re-push it when we're done.           *
                                ; * XCHGing EBP with the top of the stack *
                                ; * would be cleaner, but XCHG locks the  *
                                ; * bus.                                  *
                                ; * This trick is repeated several times  *
                                ; * below.                                *
                                ; *****************************************

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        mov     ebx, pThis
        stdcall xprunFindRunRFONTOBJ, <ebx, eax>        ; find the wchar's run

        pop     ebp                     ; <ebp> = glyph count
                                        ; ***stack frame no longer available***
        mov     ecx, [eax].wcLow        ; index of start of new run
        mov     edx, [eax].cGlyphs      ; # of glyphs in new run
        mov     ebx, [eax].apgd         ; pointer to new run's pointers to
                                        ;  cached glyphdata
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        sub     eax, ecx                ; get index relative to new run base
        cmp     eax, edx                ; is wchar in this run?
        jb      run_found               ; yes, run with it
                                        ; not in any run; use default character
        push    ebp                     ; preserve count of remaining glyphs
        mov     ebp,[esp+4]             ; ***stack frame available***
ifdef FE_SB                          ; call off to linked font handler
        push    ebx                      
        push    ecx
        push    edx
        mov     eax, pThis              ; (eax) = pointer to RFONTOBJ
        sub     ebx,ebx                 ; (ebx) = 0
        mov     bx, [esi]               ; (ebx) = current wchar
        stdcall xwpgdGetLinkMetricsRFONTOBJ,<eax,ebx>
        pop     edx
        pop     ecx
        pop     ebx
else
        mov	eax, pThis
	push	ecx
	push	edx
        stdcall xpgdDefault, <eax>	; eax = ptr to default character
	pop	edx
	pop	ecx
endif
        pop     ebp                     ; <ebp> = glyph count
        jmp     default_found           ; go with the default character

;=======================================================================
; We got here because the glyph pointer in the wcgp run was null, meaning
; we don't yet have the metrics for this glyph. Note that the following
; invariants must be true on exit (starred items must hold on entry, as
; well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run*
;       (ecx) = wcLow of new run*
;       (edx) = cGlyphs of new run*
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
get_glyph:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        push    ebx
        push    edx
        push    ecx

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar
        mov     edx, eax                ; set aside wchar
        sub     eax, ecx                ; (eax) = index into run
        lea     ebx, [ebx+eax*4]        ; (ebx) = ptr to entry
        mov     ecx,pThis
        stdcall xInsertMetricsRFONTOBJ, <ecx, ebx, edx>
        pop     ecx
        pop     edx
        and     eax, eax                ; were we able to get the glyph metrics?
        jz      short failed            ; no

        mov     eax, [ebx]              ; get ptr to glyphdata from cache entry

        pop     ebx

        pop     ebp             ; <ebp> = glyph count
                                ; ***stack frame no longer available***
        jmp     glyph_found

failed:
        pop     ebx

        pop     eax             ; clear glyph count from stack
        pop     eax             ; clear pushed stack frame pointer from stack

        sub     eax, eax        ; failure
        stdRET  xGetGlyphMetrics

stdENDP xGetGlyphMetrics







;******************************Public*Routine******************************\
;
; BOOL RFONTOBJ::bGetGlyphMetricsPlus (
;     COUNT c,
;     GLYPHPOS *pgp,
;     WCHAR *pwc,
;     BOOL *pbAccel
;     );
;
; Translate wchars into an array of GLYPHPOS structures, filling in
; the pointer to GLYPHDATA field.  Although only the metrics are assured to be
; valid, an attempt is made to ensure that the glyph data itself is
; present in the cache before the return to the caller.  Failure in this
; attempt is indicated by clearing the flag *pbAccel.  This allows the
; text code to tell the device driver that the STROBJ_bEnum callback is
; not needed.
;
; This routine is to be used primarily by TextOut and its kin.
;
; A zero return means that we failed to insert the metrics due to some
; hard error, most likely a failure to commit memory in the glyph
; insertion routine.
;
; This is a replacement for the C++ version in cache.cxx
;
; History:
;  21-Dec-92 -by- Michael Abrash
; Fixed bug in detecting run inclusion
;  9-Dec-92 -by- Paul Butzi
; Wrote it.
;**************************************************************************/


cPublicProc xGetGlyphMetricsPlus,5,<         \
        uses       ebx esi edi,         \
        pThis:     ptr dword,           \
        c_:        dword,               \
        pgp:       ptr dword,           \
        pwc:       dword,               \
        pbAccel:   ptr dword            >
        local pbacceltmp : dword        ;1 if all glyph bits have been gotten
                                        ; so far, 0 if not

        mov     eax, pThis              ; (eax) = ptr to RFONTOBJ
        mov     pbacceltmp,1            ; set bAccel to true (all glyph bits
                                        ;  realized so far)
                                        ;*486 pipelining
        mov     eax, [eax].prfnt        ; (eax) = ptr to RFONT
        mov     esi, pwc                ; pointer to wchar data
                                        ;*486 pipelining
        mov     eax, [eax].wcgp         ; (eax) = ptr to wcgp
        mov     edi, pgp                ; pointer to glyphpos array to fill
                                        ;*486 pipelining
        lea     ebx, [eax].agprun       ; (ebx) = ptr to first wcgp run
                                        ;*486 pipelining
        push    ebp                     ;*486 pipelining
        mov     ecx, [ebx].wcLow        ; index of start of run
        mov     edx, [ebx].cGlyphs      ; # of glyphs in run
        mov     ebx, [ebx].apgd         ; pointer to run's pointers to cached
                                        ;  glyphdata

        mov     ebp,c_  ; we'll use EBP for the glyph count
                        ; ***stack frame no longer available***

;--------------------------------------------------------------------------
; Fast two-glyphs-at-a-time Pentium pipe-lined loop
;
; The philosophy of this loop is that for the vast majority of the time,
; all the glyphs will be in the proper range, have cached glyphdata, and
; have cached glyphbits -- and it takes advantage of that to better make
; use of both Pentium pipes by doing two glyphs at once.  If one of those
; conditions fail, it converts to the single-glyph-at-a-time loop when
; that happens.
;
; Invariants:
;       (esi) = ptr to 1st wchar
;       (edi) = ptr to pgp
;       (ecx) = ptr to 2nd wchar
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining
;       [esp] = wcLow of current run

        cmp     ecx, FAST_WCHAR_BASE    ; fast loop handles wcLow values only
        jne     gmp_slow_loop_top       ;  of 32

        dec     ebp                     ; pre-decrement count
        jz      gmp_slow_loop_top       ; only one character.  it's okay to
                                        ;  pop this through to gmp_slow_loop_top
                                        ;  with a zero count -- it's effectively
                                        ;  the same as a one count

        push    ecx                     ; wcLow is now at [esp]

gmp_fast_loop_top:
        mov     eax, [esi]              ; 1U (eax) = first two glyphs
        add     edi, 2*SIZE_GLYPHPOS    ; 1V each iteration does two glyphpos's.
                                        ;     we do this now to eat up a free V
                                        ;     pipe instruction
        mov     ecx, eax                ; 1U
        add     esi, 4                  ; 1V each iteration does two wchars.
                                        ;     we do this now to eat up a free V
                                        ;     pipe instruction
        shr     ecx, 16                 ; 1U (ecx) = 2nd wchar, zero extended
        and     eax, 0ffffh             ; 1V (eax) = 1st wchar, zero extended

        sub     eax, FAST_WCHAR_BASE    ; 1U get index relative to current base
        sub     ecx, FAST_WCHAR_BASE    ; 1V get index relative to current base

        cmp     eax, edx                ; 1U is 1st wchar in this run?
        jae     gmp_restart_in_slow_loop; 1V wrong run, exit fast loop
        cmp     ecx, edx                ; 1U is 2nd wchar in this run?
        jae     gmp_restart_in_slow_loop; 1V wrong run, exit fast loop

        mov     eax, [ebx+4*eax]        ; 2U (eax) = ptr to 1st glyphdata
        mov     ecx, [ebx+4*ecx]        ; 2V (ecx) = ptr to 2nd glyphdata
                                        ;     (could be 3V if in same cache
                                        ;     bank)

        test    eax, eax                ; 1U is 1st cached glyphdata there?
        jz      gmp_restart_in_slow_loop; 1V no glyphdata, exit fast loop
        test    ecx, ecx                ; 1U is 2nd cached glyphdata there?
        jz      gmp_restart_in_slow_loop; 1V no glyphdata, exit fast loop

        cmp     dword ptr [eax].gd_gdf, 0 ; 2U are 1st glyph bits in cache?
        je      gmp_restart_in_slow_loop  ; 1V no, go get them
        cmp     dword ptr [ecx].gd_gdf, 0 ; 2U are 2nd glyph bits in cache?
        je      gmp_restart_in_slow_loop  ; 1V no, go get them

        mov     [edi-2*SIZE_GLYPHPOS].gp_pgdf, eax
                                        ; 1U set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg        ; 1V read 1st glyph handle

        mov     [edi-1*SIZE_GLYPHPOS].gp_pgdf, ecx
                                        ; 1U set ptr to glyphdata in glyphpos
        mov     ecx, [ecx].gd_hg        ; 1V read 2nd glyph handle

        mov     [edi-2*SIZE_GLYPHPOS].gp_hg,eax ; 1U set handle in glyphpos
        mov     [edi-1*SIZE_GLYPHPOS].gp_hg,ecx ; 1V set handle in glyphpos

        sub     ebp, 2                  ; 1U each iteration does two glyphs
        jg      gmp_fast_loop_top       ; 1V more loops to do
        pop     ecx                     ; account for pushed wcLow
        jz      gmp_slow_loop_top       ; odd number of glyphs, handle last one

        pop     ebp                     ; ***stack frame available***
        mov     ebx,pbaccel             ; where we'll store whether all glyph
                                        ;  bits found
        mov     eax, 1                  ; success
        mov     [ebx], 1                ; success

        stdRET  xGetGlyphMetricsPlus

;--------------------------------------------------------------------------
; Not-so-fast one-glyph-at-a-time loop
;
; Invariants:
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to base of current run
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining

gmp_restart_in_slow_loop:
        pop     ecx                     ; (ecx) = wcLow of current run
        inc     ebp                     ; account for fast-loop preadjustments
        sub     edi, 2*SIZE_GLYPHPOS
        sub     esi, 4

gmp_slow_loop_top:
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar, zero extended

        sub     eax, ecx                ; get index relative to current run base
        cmp     eax, edx                ; is wchar in this run?
        jae     short gmp_find_run      ; wrong run, better go get right one

gmp_run_found:
        mov     eax, [ebx+4*eax]        ; (ecx) = ptr to glyphdata


;
; Invariants:
;       (esi, edi, ebx, ecx, edx) as above at loop top
;       (eax) = ptr to glyphdata
;
gmp_default_found:
        and     eax, eax                ; is cached glyphdata there?
        jz      gmp_get_glyph           ; no glyphdata, better go get one

;
; Here, we are assured that the glyphdata is present in the cache
;
gmp_glyph_found:
        cmp     dword ptr [eax].gd_gdf, 0 ; are the glyph bits in the cache?
        jz      gmp_get_bits              ; no, go get them

;
; Here, we have tried to get the glyphbits in the cache
;
gmp_got_bits:
        mov     [edi].gp_pgdf, eax      ; set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg
        mov     [edi].gp_hg, eax        ; set hg in glyphpos


        add     edi, SIZE_GLYPHPOS      ; next glyphpos to fill in
        add     esi, 2                  ; next wchar to look up

        dec     ebp                     ; any more glyphs?
        jg      gmp_slow_loop_top       ; must be 'greater than' check

        pop     ebp                     ; ***stack frame available***

        mov     ebx,pbaccel     ; where we'll store whether all glyph bits found
        mov     eax,pbacceltmp  ; 0 if not all found, 1 if all found
        mov     [ebx],eax       ; return whether we found all glyph bits or not

        mov     eax, 1          ; success
        stdRET  xGetGlyphMetricsPlus



;=======================================================================
; We got here because the current run does not contain the wchar we're
; interested in.  Note that the following invariants must hold when
; we re-enter the loop (starred items must hold on entry, as well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
gmp_find_run:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        mov     ebx, pThis

        stdcall xprunFindRunRFONTOBJ, <ebx, eax>

        pop     ebp     ; <ebp> = glyph count
                        ; ***stack frame no longer available***
        mov     ecx, [eax].wcLow        ; index of start of new run
        mov     edx, [eax].cGlyphs      ; # of glyphs in new run
        mov     ebx, [eax].apgd         ; pointer to new run's pointers to
                                        ;  cached glyphdata
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        sub     eax, ecx                ; get index relative to new run base
        cmp     eax, edx                ; is wchar in this run?
        jb      gmp_run_found           ; yes, run with it
                                        ; not in any run; use default character
        push    ebp                     ; preserve count of remaining glyphs
        mov     ebp,[esp+4]             ; ***stack frame available***

ifdef FE_SB
        push    ebx
        push    ecx
        push    edx
        mov     eax, pThis              ; (eax) = pointer to RFONTOBJ
        lea     ebx, pbacceltmp         ; (ebx) = pointer to pbacceltmp
                                        ; (esi) = pointer to current wchar
        stdcall xwpgdGetLinkMetricsPlusRFONTOBJ,<eax,esi,ebx>
        pop     edx
        pop     ecx
        pop     ebx                     ; (eax) is now proper wpgd
else
        mov     eax,pThis	
	push	ecx
	push	edx
        stdcall xpgdDefault, <eax>	; eax = ptr to default character
	pop	edx
	pop	ecx
endif
        pop     ebp                     ; <ebp> = glyph count
                                        ; ***stack frame no longer available***

        jmp     gmp_default_found       ; go with the default character


;=======================================================================
; We got here because the glyph pointer in the wcgp run was null, meaning
; we don't yet have the metrics for this glyph. Note that the following
; invariants must be true on exit (starred items must hold on entry, as
; well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run*
;       (ecx) = wcLow of new run*
;       (edx) = cGlyphs of new run*
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
gmp_get_glyph:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        push    ebx
        push    edx
        push    ecx

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar
        mov     edx, eax                ; set aside wchar
        sub     eax, ecx                ; (eax) = index into run
        lea     ebx, [ebx+4*eax]        ; (ebx) = ptr to entry
        mov     ecx,pThis
        stdcall xInsertMetricsPlusRFONTOBJ, <ecx, ebx, edx>
        pop     ecx
        pop     edx
        and     eax, eax                ; were we able to get the glyph metrics?
        jz      short gmp_failed        ; no

        mov     eax, [ebx]              ; get ptr to glyphdata from it

        pop     ebx

        pop     ebp             ; <ebp> = glyph count
                                ; ***stack frame no longer available***
        jmp     gmp_glyph_found

gmp_failed:
        pop     ebx

        pop     eax             ; clear glyph count from stack
        pop     eax             ; clear pushed stack frame pointer from stack

        sub     eax, eax        ;failure
        stdRET  xGetGlyphMetricsPlus

;=======================================================================
; We get here if we need to try to load the bits for the glyph we're
; interested in (because the bits havene't been realized yet). We only
; even bother to try if all bits have successfully been realized so far,
; because it's only useful to realize glyphs if we can get all of them.
; Note that the following invariants must be true on both entry and exit.
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining
;=======================================================================
        align   4
gmp_get_bits:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        cmp     pbacceltmp,0            ;if we already failed to get glyph bits
        je      short got_the_bits_done ; once, no point in trying again

        push    ecx
        mov     ecx, pThis
        push    edx             ;*486 pipelining
        mov     edx, [ecx].prfnt
        push    eax             ;*486 pipelining
        cmp     dword ptr [edx].ulContent, FO_HGLYPHS
        je      short got_the_bits

        sub     edx,edx
        cmp     pwc,esi
        sbb     edx,-1          ; EDX == TRUE if first wc, FALSE else
        stdcall xInsertGlyphbitsRFONTOBJ, <ecx, eax, edx> ;try to get the bits

        and     eax, eax             ; did we succeed in getting the bits?
        jnz     short got_the_bits   ; yes, we got the bits
        mov     pbacceltmp, eax      ; didn't get the glyph (note: EAX is zero)
got_the_bits:
        pop     eax
        pop     edx
        pop     ecx
got_the_bits_done:
        pop     ebp     ; <ebp> = glyph count
                        ; ***stack frame no longer available***
        jmp     gmp_got_bits


stdENDP xGetGlyphMetricsPlus



        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\line.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; DFBBLT is used to store DFB BLTing info
;-----------------------------------------------------------------------;
DDALINE		STRUC
ulFlags		dd	? ; dda flags
ptlStart0	dd	? ; point.x
ptlStart1	dd	? ; point.y
cPels		dd	? ; pixel count
dMajor		dd	? ; major axis error term
dMinor		dd	? ; minor axes error term
lErrorTerm	dd	? ; dda error term
xInc		dd	? ; not used
DDALINE         ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vFastText(GLYPHPOS * pGlyphPos, ULONG ulGlyphCount, PBYTE pTempBuffer,
;                ULONG ulBufDelta, ULONG ulCharInc, DEVSURF * pdsurf,
;                RECTL * prclText, RECTL * prclOpaque, INT iFgColor,
;                INT iBgColor, ULONG fDrawFlags, RECTL * prclClip,
;                RECTL * prclExtra, ULONG iTrgType);
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta -
; ulCharInc -
; pdsurf -
; prclText -
; prclOpaque -
; iFgColor -
; iBgColor -
; fDrawFlags -
; prclClip -     array of clipping rectangles
; prclExtra -    array of extra rectanlges to fill in foreground color
; iTrgType -     0 = VGA; 1 = DFB; 2 = NONE
;
; Performs accelerated proportional text drawing.
;
;-----------------------------------------------------------------------;
;
; Note: prclClip and prclExtra are null rectangle (yBottom=0) terminated
;       arrays
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
; Note: The opaquing rectangle is assumed to match the text bounding
; rectangle exactly; prclOpaque is used only to determine whether or
; not opaquing is required.
;
; Note: For maximum performance, we should not bother to draw fully-
; clipped characters to the temp buffer.
;
; Note: We do not handle clipping or bank spanning in the very fast
; byte-wide-aligned-fixed-pitch console text. This would be an
; opportunity for somewhat faster console text performance.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to draw the text into a system
memory buffer, then copy the buffer to the screen a word at a time
using write mode 3 so that no OUTs and a minimum of display memory reads
are required.

        commend $

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include callconv.inc
        include gdii386.inc
        .list

;-----------------------------------------------------------------------;

        .data

        align   4
                               

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;


; Masks for clipping for the eight possible left and right edge alignments
jOpaqueLeftMasks        label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

jOpaqueRightMasks       label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

dfbfill_jLeftMasks      label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      07fh,0ffh,0ffh,0ffh
                db      03fh,0ffh,0ffh,0ffh
                db      01fh,0ffh,0ffh,0ffh
                db      00fh,0ffh,0ffh,0ffh
                db      007h,0ffh,0ffh,0ffh
                db      003h,0ffh,0ffh,0ffh
                db      001h,0ffh,0ffh,0ffh
                db      000h,0ffh,0ffh,0ffh
                db      000h,07fh,0ffh,0ffh
                db      000h,03fh,0ffh,0ffh
                db      000h,01fh,0ffh,0ffh
                db      000h,00fh,0ffh,0ffh
                db      000h,007h,0ffh,0ffh
                db      000h,003h,0ffh,0ffh
                db      000h,001h,0ffh,0ffh
                db      000h,000h,0ffh,0ffh
                db      000h,000h,07fh,0ffh
                db      000h,000h,03fh,0ffh
                db      000h,000h,01fh,0ffh
                db      000h,000h,00fh,0ffh
                db      000h,000h,007h,0ffh
                db      000h,000h,003h,0ffh
                db      000h,000h,001h,0ffh
                db      000h,000h,000h,0ffh
                db      000h,000h,000h,07fh
                db      000h,000h,000h,03fh
                db      000h,000h,000h,01fh
                db      000h,000h,000h,00fh
                db      000h,000h,000h,007h
                db      000h,000h,000h,003h
                db      000h,000h,000h,001h
                                 
dfbfill_jRightMasks     label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      080h,000h,000h,000h
                db      0c0h,000h,000h,000h
                db      0e0h,000h,000h,000h
                db      0f0h,000h,000h,000h
                db      0f8h,000h,000h,000h
                db      0fch,000h,000h,000h
                db      0feh,000h,000h,000h
                db      0ffh,000h,000h,000h
                db      0ffh,080h,000h,000h
                db      0ffh,0c0h,000h,000h
                db      0ffh,0e0h,000h,000h
                db      0ffh,0f0h,000h,000h
                db      0ffh,0f8h,000h,000h
                db      0ffh,0fch,000h,000h
                db      0ffh,0feh,000h,000h
                db      0ffh,0ffh,000h,000h
                db      0ffh,0ffh,080h,000h
                db      0ffh,0ffh,0c0h,000h
                db      0ffh,0ffh,0e0h,000h
                db      0ffh,0ffh,0f0h,000h
                db      0ffh,0ffh,0f8h,000h
                db      0ffh,0ffh,0fch,000h
                db      0ffh,0ffh,0feh,000h
                db      0ffh,0ffh,0ffh,000h
                db      0ffh,0ffh,0ffh,080h
                db      0ffh,0ffh,0ffh,0c0h
                db      0ffh,0ffh,0ffh,0e0h
                db      0ffh,0ffh,0ffh,0f0h
                db      0ffh,0ffh,0ffh,0f8h
                db      0ffh,0ffh,0ffh,0fch
                db      0ffh,0ffh,0ffh,0feh

dfbfill_pfnScanHandlers label   dword
                dd      0
                dd      0
                dd      0
                dd      0


;-----------------------------------------------------------------------;

                .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;


extrn draw_gray_nf_ntb_o_to_temp_start@28:NEAR
extrn draw_gray_f_ntb_o_to_temp_start@28:NEAR

cProc vFastText,52,<\
 uses esi edi ebx,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 pdsurf:ptr,\
 prclText:ptr,\
 prclOpaque:ptr,\
 iFgColor:dword,\
 iBgColor:dword,\
 fDrawFlags:dword,\
 prclClip:dword,\
 prclExtra:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulTempTop:dword   ;Y coordinate on screen of top edge of temp
                                ; buffer
        local ulLoopCount:dword ;general loop count storage
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulTopScan:dword     ;top scan of dest text rect in current bank
        local ulBottomScan:dword  ;bottom scan of dest text rect
        local ulNumScans:dword    ;# of scans to draw
        local ulScreenDelta:dword ;scan-to-scan offset in screen
        local ulTextWidthInBytes:dword ;# of bytes across spanned by text
        local pScreen:dword     ;pointer to first screen byte to which to draw
        local pfnEdgeVector:dword ;pointer to routine to draw any needed edges
        local pfnFirstOpaqVector:dword ;pointer to initial drawing routine
                                       ; called for opaque (either whole
                                       ; bytes, or edge(s) if no whole bytes)
        local ulWholeWidthInWords:dword ;# of whole words to copy
        local ulWholeWidthInWordsMinus1:dword ;# of whole words to copy, -1
        local ulOddByte:dword   ;1 if odd byte in whole word copy
        local ulTextLeft:dword  ;left edge of leftmost glyph
        local ulLeftMask:dword  ;for opaque text, left edge mask for string
        local ulRightMask:dword ;for opaque text, right edge mask for string
        local ulScans:dword     ;# of scans to draw
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local rclClippedBounds[16]:byte ;clipped destination rectangle;
                                        ; defined as "byte" due to assembler
                                        ; limitations

        local ulRectLeft:dword
        local ulRectRight:dword
        local pfnDrawScans:dword         ;ptr to correct scan drawing function
        local pTempBufferSaved:dword
        local ulEdgeFlags:dword
        local ulBytesPerDstPlane:dword
        local ulLeftOffset:dword
        local pSrc:dword
        local pDst:dword
        local ulPlaneBit:dword

TRAILING_PARTIAL        equ     01h      ;partial trailing dword should be copied
LEADING_PARTIAL         equ     02h      ;partial leading dword should be copied

;-----------------------------------------------------------------------;
;
; For the moment, handle grayed text using the most general routine
; This means that we will be handing it back to the most general of
; of the C routines, namely
;
;       VOID
;       draw_gray_nf_ntb_o_to_temp_start(
;           PGLYPHPOS  pGlyphPos
;           ULONG      cGlyph
;           PUCHAR     pjTempBuffer
;           ULONG      BufferOffset
;           ULONG      ulBufferWidthInBytes
;           ULONG      ulCharInc
;           ULONG      ulTempTop
;           )
;
;   or for fixed pitch fonts
;
;       VOID
;       draw_gray_f_ntb_o_to_temp_start(
;           PGLYPHPOS  pGlyphPos
;           ULONG      cGlyph
;           PUCHAR     pjTempBuffer
;           ULONG      BufferOffset
;           ULONG      ulBufferWidthInBytes
;           ULONG      ulCharInc
;           ULONG      ulTempTop
;           )
;
; Most of these parameters are in the arguments passed to vFastText.
; However, there are a couple that we must reconstruct. The first
; parameter to be pushed is ulTempTop. I look into the calling
; routine (vExpandAndCopyText) and find
;
;       ulTempTop = prclText->top
;       BufferOffset = 8 * floor(prclText->left/8)
;
; The factor of 8 is equal to the number of pixels contained in
; a DWORD. For monochrome text, this number would become 32
;
; The third argument to vFastText is pjTempBuffer which is equal to
;
;      pjTempBuffer = pTempBuffer - ((prclText->left >> 3) & 3)
;
;  (to draw_gray..)   (input to vFastText)
;
;-----------------------------------------------------------------------;

;gray_text_test:
        mov     edx,fDrawFlags          ; Is this call for grayed text?
        test    edx,8                   ; test for ETO_GRAY in fDrawFlags
        jz      monochrome_text         ; if not go to monochrome code
;gray_text:
        mov     ebx,prclText            ; ebx = useful pointer to text rect
        push    [ebx].yTop              ; ulTempTop: 7'th argument
        push    ulCharInc               ; ulCharInc: 6'th argument
        push    ulBufDelta              ; dpDst:     5'th argument
        mov     eax,[ebx].xLeft         ; eax = prclText->left
        mov     ecx,eax                 ; ecx = prclText->left
        and     ecx,not 7               ; ecx = 8 * (prclText->left / 8)
        push    ecx                     ; BufferOffset: 4'th argument
        sar     eax,3                   ; This is the part where we
        and     eax,3                   ; correct pjTempBuffer by subtracting
        neg     eax                     ; off an additional factor (see above)
        add     eax,pTempBuffer         ; eax = pjTempBuffer[draw_gray..]
        push    eax                     ; pjTempBuffer: 3'rd argument
        push    ulGlyphCount            ; cGlyph:       2'nd argument
        push    pGlyphPos               ; pGlyphPos:    1'st argument
        mov     eax,draw_gray_f_ntb_o_to_temp_start@28
        test    edx,1                   ; fixed pitch ?
        jnz     @f                      ; yes, eax is good, jump
        mov     eax,draw_gray_nf_ntb_o_to_temp_start@28
@@:
        call    eax
        jmp     exit_fast_text
monochrome_text:

        cld

;-----------------------------------------------------------------------;
; Draws either a fixed or a non-fixed-pitch string to the temporary
; buffer. Assumes this is a horizontal string, so the origins of all glyphs
; are at the same Y coordinate. Draws leftmost glyph entirely with MOVs,
; even if it's not aligned, in order to ensure that the leftmost byte
; gets cleared when we're working with butted characters. For other
; non-aligned glyphs, leftmost byte is ORed, other bytes are MOVed.
;
; Input:
;       pGlyphPos = pointer to array of GLYPHPOS structures to draw
;       ulGlyphCount = # of glyphs to draw
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       ulCharInc = offset from one glyph to next (fixed-pitch only)
;       fDrawFlags = indicate the type of text to be drawn
;       Temp buffer zeroed if text doesn't cover every single pixel
;
; Fixed-pitch means equal spacing between glyph positions, not that all
; glyphs butt together or equal spacing between upper left corners.
;-----------------------------------------------------------------------;

        mov     ebx,prclText
        sub     eax,eax

;-----------------------------------------------------------------------;
; Handle all cases other than 8-wide byte-aligned.
;-----------------------------------------------------------------------;

general_handler:
        mov     esi,pdsurf
        mov     eax,[ebx].yTop
        mov     ulTempTop,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulScreenDelta,eax

        mov     eax,fDrawFlags

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        mov     eax,ulYOrigin           ;dest Y coordinate
        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, draw the extra rectangles to the temp buffer.
;
; Input:
;       pdsurf = pointer to target surface (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
glyphs_are_done::
extra_rects_are_done::
exit_fast_text::

        cRet    vFastText

endProc vFastText

public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public glyphs_are_done
public exit_fast_text

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\locka.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: lock.asm                                                 ;
;                                                                       ;
; Contains the ASM versions of locking routines.                        ;
;                                                                       ;
; Copyright (c) 1992-1999 Microsoft Corporation                         ;
;-----------------------------------------------------------------------;

        .386
        .model  small

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        include gdii386.inc
        .list

if GDIPLUS

        ; See hmgrapi.cxx

else

        .data

if DBG
  HL_AlreadyLocked    db     'HmgLock Error: GDI handle already locked by another thread',10,0
  HL_OverFlowShareRef db     'Hmg Error: GDI handle share reference count over flowed',10,0
endif


_DATA   SEGMENT DWORD PUBLIC 'DATA'

        public _GDIpLockPrefixTable
_GDIpLockPrefixTable    label dword
        dd offset FLAT:Lock1
        dd offset FLAT:Lock4
        dd offset FLAT:Lock5
        dd offset FLAT:Lock6
        dd offset FLAT:Lock7
        dd offset FLAT:Lock8
        dd 0
_DATA   ENDS




OBJECTOWNER_LOCK     equ          1h ; First bit of the objectowner
OBJECTOWNER_PID      equ  0fffffffeh ; The PID bits

        .code

extrn   _gpentHmgr:dword             ; Address of ENTRY array.
extrn   _gcMaxHmgr:dword
extrn   _gpLockShortDelay:dword      ; Pointer to global constant 10 ms delay

if DBG
        extrn   _DbgPrint:proc
        EXTRNP  _HmgPrintBadHandle,2
endif

        EXTRNP  _KeDelayExecutionThread,3
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _PsGetCurrentProcessId,0

;------------------------------Public-Routine------------------------------;
; HmgInterlockedCompareAndSwap(pul,ulong0,ulong1)
;
;  Compare *pul with ulong1, if equal then replace with ulong2 interlocked
;
; Returns:
;   EAX = 1 if memory written, 0 if not
;
;--------------------------------------------------------------------------;
;
        public  @HmgInterlockedCompareAndSwap@12
@HmgInterlockedCompareAndSwap@12    proc    near

        mov     eax,edx
        mov     edx,[esp]+4
        .486
Lock1:
lock    cmpxchg [ecx],edx
        .386
        jnz     Return_Zero

        mov     eax,1
        ret     4

Return_Zero:
        xor     eax,eax
        ret     4

@HmgInterlockedCompareAndSwap@12    endp

;------------------------------Public-Routine------------------------------;
; HmgLock (hobj,objt)
;
; Lock a user object.
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to locked object
;
; Error Return:
;   EAX = 0, No error logged.
;
; History:
;  14-Jun-1995 -by- J. Andrew Goossen [andrewgo]
; Rewrote for Kernel Mode.
;
;  20-Dec-1993 -by- Patrick Haluptzok [patrickh]
; Move lock counts into object.
;
;  23-Sep-1993 -by- Michael Abrash [mikeab]
; Tuned ASM code.
;
;    -Sep-1992 -by- David Cutler [DaveC]
; Write HmgAltLock, HmgAltCheckLock, and HmgObjtype in ASM.
;
;  Thu 13-Aug-1992 13:21:47 -by- Charles Whitmer [chuckwh]
; Wrote it in ASM.  The common case falls straight through.
;
;  Wed 12-Aug-1992 17:38:27 -by- Charles Whitmer [chuckwh]
; Restructured the C code to minimize jumps.
;
;  29-Jun-1991 -by- Patrick Haluptzok patrickh
; Wrote it.
;--------------------------------------------------------------------------;

        public @HmgLock@8
@HmgLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        dec     DWORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgLock_resume::

        ; Perf: It would be nice if we could avoid these word size overrides,
        ;       but unfortunately objectowner_Pid is currently a non-dword
        ;       aligned offset.

        mov     ebx,[ecx].entry_ObjectOwner
        stdCall _PsGetCurrentProcessId,<>
        and     eax,OBJECTOWNER_PID
        and     ebx,OBJECTOWNER_PID
        cmp     eax,ebx
        jne     HmgLock_check_for_public_owner

HmgLock_after_check_for_public_owner::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock4:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgLock_bad_handle_after_lock

        mov     eax,[ecx].entry_einfo
        mov     edx,fs:[PcPrcbData].PbCurrentThread     ;edx ->KeGetCurrentThread()
        cmp     word ptr [eax].object_cExclusiveLock,0  ;Note, testing here...
                                                                                                        ;cExclusiveLock is a USHORT

        jnz     HmgLock_check_if_same_thread  ;...and jumping here
        mov     byte ptr [eax].object_cExclusiveLock,1
                                                    ;We can do a byte move
                                                    ;  because we know it was
                                                    ;  a zero word before
HmgLock_after_same_thread::
        mov     [eax].object_Tid,edx
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

        ; eax is set to the proper return value

HmgLock_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        inc     DWORD PTR [ebx].ThKernelApcDisable
        jz      HmgLock_LeaveCriticalRegion

HmgLock_Done::

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgLock_check_for_public_owner:
        test    ebx,ebx
        .errnz  OBJECT_OWNER_PUBLIC
        jz      HmgLock_after_check_for_public_owner

HmgLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgLock_bad_handle

HmgLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgLock_bad_handle:
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgLock_incAPC

HmgLock_check_if_same_thread::
        inc     dword ptr [eax].object_cExclusiveLock   ; cExclusiveLock is USHORT
        cmp     edx,[eax].object_Tid                    ; but dword operation is faster on P5
        je      HmgLock_after_same_thread               ; than a word operation

; Error case if already locked:

        dec     dword ptr [eax].object_cExclusiveLock   ; same remark as for inc above
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it
    if DBG
        push    offset HL_AlreadyLocked
        call    _DbgPrint
        add     esp,4
    endif
        jmp     HmgLock_bad_handle

HmgLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        jmp     HmgLock_resume

HmgLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgLock_Done

@HmgLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgShareCheckLock (hobj,objt)
;
; Acquire a share lock on an object, PID owner must match current PID
; or be a public.
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgShareCheckLock@8
@HmgShareCheckLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        dec     DWORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgShareCheckLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgShareCheckLock_resume::

        ; Perf: It would be nice if we could avoid these word size overrides,
        ;       but unfortunately objectowner_Pid is currently a non-dword
        ;       aligned offset.

        mov     ebx,[ecx].entry_ObjectOwner
        stdCall _PsGetCurrentProcessId,<>
        and     eax,OBJECTOWNER_PID
        and     ebx,OBJECTOWNER_PID
        cmp     eax,ebx
        
        jne     HmgShareCheckLock_check_for_public_owner

HmgShareCheckLock_after_check_for_public_owner::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock5:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgShareCheckLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgShareCheckLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgShareCheckLock_bad_handle_after_lock
        mov     eax,[ecx].entry_einfo               ;Get pointer to object
    if DBG
        cmp     [eax].object_ulShareCount, 0ffffffffH       ;Check for overflow
        jne     HmgShareCheckLock_go
        push    offset HL_OverFlowShareRef
        call    _DbgPrint
        add     esp,4
        int     3
HmgShareCheckLock_go:   
    endif       
        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it


HmgShareCheckLock_IncAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        inc     DWORD PTR [ebx].ThKernelApcDisable
        jz      HmgShareCheckLock_LeaveCriticalRegion

        ; eax is set to the proper return value

HmgShareCheckLock_Done::
    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgShareCheckLock_check_for_public_owner:
        test    ebx,ebx
        .errnz  OBJECT_OWNER_PUBLIC
        jz      HmgShareCheckLock_after_check_for_public_owner
HmgShareCheckLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgShareCheckLock_bad_handle

HmgShareCheckLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareCheckLock_bad_handle::
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgShareCheckLock_IncAPC

HmgShareCheckLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        jmp     HmgShareCheckLock_resume

HmgShareCheckLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgShareCheckLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgShareCheckLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgShareCheckLock_Done

@HmgShareCheckLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgShareLock (obj,objt)
;
;
; Acquire a share lock on an object, don't check PID owner
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgShareLock@8
@HmgShareLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     DWORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgShareLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgShareLock_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock6:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgShareLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgShareLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgShareLock_bad_handle_after_lock
        mov     eax,[ecx].entry_einfo               ;Get pointer to object
    if DBG
        cmp     [eax].object_ulShareCount, 0ffffffffH       ;Check for overflow
        jne     HmgShareLock_go
        push    offset HL_OverFlowShareRef
        call    _DbgPrint
        add     esp,4
        int     3
HmgShareLock_go:        
    endif       
        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareLock_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     DWORD PTR [ebx].ThKernelApcDisable
        jz      HmgShareLock_LeaveCriticalRegion

HmgShareLock_Done::

        ; eax is set to the proper return value

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgShareLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgShareLock_bad_handle

HmgShareLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareLock_bad_handle::
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgShareLock_incAPC

HmgShareLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        jmp     HmgShareLock_resume

HmgShareLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgShareLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgShareLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgShareLock_Done

@HmgShareLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgIncrementShareReferenceCount (pobj)
;
;
; Increment shared reference count, no checking
;
; Input:
;   EAX -- scratch
;   ECX -- pobj
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgIncrementShareReferenceCount@4
@HmgIncrementShareReferenceCount@4 proc near
        push    ebx                                 ;Preserve register in call
        push    ecx                                 ;Stash pobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     DWORD PTR [ebx].ThKernelApcDisable

        mov     ecx, [ecx]
        and     ecx,INDEX_MASK

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgIncrementShareReferenceCount_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock7:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgIncrementShareReferenceCount_delay

        ; The handle is now locked
        mov     eax,[ecx].entry_einfo               ;Get pointer to object

        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgIncrementShareReferenceCount_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     DWORD PTR [ebx].ThKernelApcDisable
        jz      HmgIncrementShareReferenceCount_LeaveCriticalRegion

HmgIncrementShareReferenceCount_Done::

        ; eax is set to the proper return value

        pop     ecx
        pop     ebx
        ret

; Roads less travelled...

HmgIncrementShareReferenceCount_delay::
        push    ecx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     ecx
        jmp     HmgIncrementShareReferenceCount_resume

HmgIncrementShareReferenceCount_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgIncrementShareReferenceCount_CallInterrupt

        pop     ecx
        pop     ebx
        ret

HmgIncrementShareReferenceCount_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgIncrementShareReferenceCount_Done

@HmgIncrementShareReferenceCount@4 endp

;------------------------------Public-Routine------------------------------;
; HmgDecrementShareReferenceCount (pobj)
;
;
; Decrement shared reference count, no checking
;
; Input:
;   EAX -- scratch
;   ECX -- pobj
;
; Returns:
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgDecrementShareReferenceCount@4
@HmgDecrementShareReferenceCount@4 proc near
        push    ebx                                 ;Preserve register in call
        push    ecx                                 ;Stash pobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     DWORD PTR [ebx].ThKernelApcDisable

        mov     ecx, [ecx]
        and     ecx,INDEX_MASK

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgDecrementShareReferenceCount_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock8:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgDecrementShareReferenceCount_delay

        ; The handle is now locked
        mov     edx,[ecx].entry_einfo               ;Get pointer to object

        mov     eax, [edx].object_ulShareCount
        dec     DWORD PTR [edx].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgDecrementShareReferenceCount_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     DWORD PTR [ebx].ThKernelApcDisable
        jz      HmgDecrementShareReferenceCount_LeaveCriticalRegion

HmgDecrementShareReferenceCount_Done::

        ; eax is set to the proper return value
        pop     ecx
        pop     ebx
        ret

; Roads less travelled...

HmgDecrementShareReferenceCount_delay::
        push    ecx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     ecx
        jmp     HmgDecrementShareReferenceCount_resume

HmgDecrementShareReferenceCount_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgDecrementShareReferenceCount_CallInterrupt

        pop     ecx
        pop     ebx
        ret

HmgDecrementShareReferenceCount_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgDecrementShareReferenceCount_Done

@HmgDecrementShareReferenceCount@4 endp


_TEXT   ends

endif

        end



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\glyphout.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: line.asm
;
; Transparent and Opaque output for 1Bpp to 1Bpp drawing
;
; Created: 24-Aug-1994
; Author: Mark Enstrom
;
; Copyright (c) 1994-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        include line.inc

spt_lEndOffset  equ 000H
spt_ulEndMask   equ 004H
spt_ulStartMask equ 008H
spt_ebp         equ 00CH
spt_esi         equ 010H
spt_edi         equ 014H
spt_ebx         equ 018H
spt_ulRetAddr   equ 01CH
spt_pjSrcIn     equ 020H
spt_SrcLeft     equ 024H
spt_DeltaSrcIn  equ 028H
spt_pjDstIn     equ 02CH
spt_DstLeft     equ 030H
spt_DstRight    equ 034H
spt_DeltaDstIn  equ 038H
spt_cy          equ 03CH
spt_uF          equ 040H
spt_uB          equ 044H
spt_pS          equ 048H

        .list



;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING



;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vSrcTranCopyS1D1
;
;   Transparent copy from 1Bpp to 1Bpp (DWORD ALIGNED)
;
; Entry:
;
;   pjSrcIn
;   SrcLeft
;   DeltaSrcIn
;   pjDstIn
;   DstLeft
;   DstRight
;   DeltaDstIn
;   cy
;   uF
;   uB
;   pS
;
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

        public vSrcTranCopyS1D1@44

vSrcTranCopyS1D1@44 proc near

        ;
        ;  use ebp as general register, use esp for parameter and local access
        ;  save ebp,ebx,esi,edi

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,3 * 4

        ;
        ;  Start and end cases and masks. Start case is the first partial
        ;  DWORD (if needed) and end case is the last partial DWORD (if needed)
        ;

        mov     ecx,spt_DstLeft[esp]            ; Left (startint Dst Location)
        sub     edi,edi                         ; zero
        not     edi                             ; flag = 0xffffff
        mov     esi,edi                         ; flag = 0xffffff
        and     ecx,01Fh                        ; DstLeftAln,if 0 then don't make mask
        jz      @F

        ;
        ; ulStartMask >>= lStartCase, shift ulStartMask right by starting alignment,
        ; then BSWAP this back to little endian
        ;

        shr     edi,cl                          ; ulStartMask >> lStartCase
        ror     di,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     edi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     di,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     eax,spt_DstRight[esp]           ; right (last pixel)
        and     eax,01Fh                        ; DstRightAln = DstRight & 0x1F
        jz      @F                              ; if 0, mask = 0xffffffff

        ;
        ; ulEndMask = 0xFFFFFF << ( 32 - lEndCase). Shift big endian 0xFFFFFF left
        ; by lEndCase, then BSWAP
        ;

        mov     ecx,32                          ; shift 32 - lEndCase
        sub     ecx,eax                         ; 32 - lEndCase
        shl     esi,cl                          ; ulEndMask << lEndCase
        ror     si,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     esi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     si,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     spt_ulStartMask[esp],edi        ; save
        mov     spt_ulEndMask[esp],esi          ; save

        ;
        ; check for transparent 1 or transparent 0 foreground color
        ;

        test    spt_uF[esp],1
        jz      Trans1to1Invert

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spt_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spt_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Tran1to1Partial

        mov     spt_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spt_pjDstIn[esp]
        mov     esi,spt_pjSrcIn[esp]
        mov     ebx,spt_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spt_cy[esp]                 ; keep track of # of scan lines

Tran1to1DwordLoop:

        ;
        ; DWORD loop
        ;

        mov     eax,spt_lEndOffset[esp]         ; get inner loop count
@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax - 4 + esi]         ; load dw 0
        or      [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

Tran1to1DwordLoopComplete:

        ;
        ; done with scan line, add strides
        ;

        add     edi,spt_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,spt_DeltaSrcIn[esp]         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Tran1to1DwordLoop


Tran1to1Partial:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spt_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Tran1to1RightEdge               ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spt_DstLeft[esp]            ; left position
        mov     edx,spt_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spt_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal, start and stop
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Tran1to1RightEdge won't run
        ;

        and     ecx,spt_ulEndMask[esp]          ; combine with start mask
        mov     spt_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spt_DstLeft[esp]            ; load
        mov     ebx,spt_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spt_pjDstIn[esp]            ; load dst addr
        mov     esi,spt_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ebp,spt_DeltaSrcIn[esp]         ; scr scan line stride
        mov     ebx,spt_DeltaDstIn[esp]         ; dst scan line stride
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll loop 2 times, this requires address fix-up
        ;

        sub     edi,ebx                         ; fix-up for odd cycle
        sub     esi,ebp                         ; fix-up for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Tran1to1LeftEdgeOdd             ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up for even cycle
        add     esi,ebp                         ; un-fix-up for even cycle

@@:
        mov     eax,[esi]                       ; load src
        and     eax,ecx                         ; mask
        or      [edi],eax                       ; store

Tran1to1LeftEdgeOdd:

        mov     eax,[esi + ebp]                 ; load src
        and     eax,ecx                         ; mask
        or      [edi + ebx],eax                 ; store

        lea     esi,[esi][ebp*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Tran1to1RightEdge:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spt_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndTran1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spt_DstRight[esp]           ; DstRight
        mov     ecx,spt_DstLeft[esp]            ; load DstLeft
        mov     eax,spt_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spt_pjDstIn[esp]            ;
        mov     esi,spt_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset

        mov     ecx,spt_ulEndMask[esp]          ; load end mask
        mov     ebx,spt_DeltaSrcIn[esp]         ; src scan line inc
        mov     ebp,spt_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll loop 2 times, fix up address for odd cycle
        ;

        sub     edi,ebp                         ; fix-up for odd cycle
        sub     esi,ebx                         ; fix-up for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Tran1to1RightEdgeOdd            ; do single "odd" DWORD

        add     edi,ebp                         ; un-fix-up for odd cycle
        add     esi,ebx                         ; un-fix-up for odd cycle

@@:
        mov     eax,[esi]                       ; load src dword
        and     eax,ecx                         ; mask
        or      [edi],eax                       ; or in src

Tran1to1RightEdgeOdd:

        mov     eax,[esi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        or      [edi+ebp],eax                   ; or in src

        lea     esi,[esi][ebx*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebp*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        jmp     EndTran1to1

        ;
        ; transparent invert (uF = 0)
        ;


Trans1to1Invert:

        ;
        ; Transparent text where the foreground color is 0, must invert the
        ; src DWORD and then and it onto the dest.
        ;

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spt_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spt_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Tran1to1PartialInvert

        mov     spt_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spt_pjDstIn[esp]
        mov     esi,spt_pjSrcIn[esp]
        mov     ebx,spt_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spt_cy[esp]                 ; keep track of # of scan lines

Tran1to1DwordLoopInvert:

        ;
        ; DWORD loop
        ;

        mov     eax,spt_lEndOffset[esp]         ; get inner loop count

@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax - 4 + esi]         ; load dw 0
        not     ebx                             ; invert
        and     [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

Tran1to1DwordLoopCompleteInvert:

        ;
        ; done with scan line, add strides
        ;

        add     edi,spt_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,spt_DeltaSrcIn[esp]         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Tran1to1DwordLoopInvert


Tran1to1PartialInvert:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spt_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Tran1to1RightEdgeInvert         ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spt_DstLeft[esp]            ; left position
        mov     edx,spt_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spt_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal then start and end
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Tran1to1RightEdge won't run
        ;

        and     ecx,spt_ulEndMask[esp]          ; combine with start mask
        mov     spt_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spt_DstLeft[esp]            ; load
        mov     ebx,spt_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spt_pjDstIn[esp]            ; load dst addr
        mov     esi,spt_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ebp,spt_DeltaSrcIn[esp]         ; scr scan line stride
        mov     ebx,spt_DeltaDstIn[esp]         ; dst scan line stride
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll left edge loop 2 times, this requires address fix-up
        ;

        sub     edi,ebx                         ; fix-up for odd cycle
        sub     esi,ebp                         ; fix-up for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Tran1to1LeftEdgeOddInvert       ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up for even cycle
        add     esi,ebp                         ; un-fix-up for even cycle

@@:
        mov     eax,[esi]                       ; load src
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi],eax                       ; store

Tran1to1LeftEdgeOddInvert:

        mov     eax,[esi + ebp]                 ; load src
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi + ebx],eax                 ; store

        lea     esi,[esi][ebp*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Tran1to1RightEdgeInvert:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spt_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndTran1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spt_DstRight[esp]           ; DstRight
        mov     ecx,spt_DstLeft[esp]            ; load DstLeft
        mov     eax,spt_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spt_pjDstIn[esp]            ;
        mov     esi,spt_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset

        mov     ecx,spt_ulEndMask[esp]          ; load end mask
        mov     ebx,spt_DeltaSrcIn[esp]         ; src scan line inc
        mov     ebp,spt_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll right edge loop 2 times. This requires address fix-up
        ;

        sub     esi,ebx                         ; fix-up address for odd cycle
        sub     edi,ebp                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Tran1to1RightEdgeOddInvert      ; do single "odd" DWORD

        add     esi,ebx                         ; fix-up address for odd cycle
        add     edi,ebp                         ; fix-up address for odd cycle

@@:
        mov     eax,[esi]                       ; load src dword
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi],eax                       ; or in src

Tran1to1RightEdgeOddInvert:

        mov     eax,[esi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi+ebp],eax                   ; or in src

        lea     esi,[esi][ebx*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebp*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        ;
        ; done!
        ;

EndTran1to1:

        add     esp,3*4
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     44

vSrcTranCopyS1D1@44 endp

spo_tMask       equ 000H
spo_lXorMask    equ 004H
spo_lEndOffset  equ 008H
spo_ulEndMask   equ 00CH
spo_ulStartMask equ 010H
spo_ebp         equ 014H
spo_esi         equ 018H
spo_edi         equ 01CH
spo_ebx         equ 020H
spo_ulRetAddr   equ 024H
spo_pjSrcIn     equ 028H
spo_SrcLeft     equ 02CH
spo_DeltaSrcIn  equ 030H
spo_pjDstIn     equ 034H
spo_DstLeft     equ 038H
spo_DstRight    equ 03CH
spo_DeltaDstIn  equ 040H
spo_cy          equ 044H
spo_uF          equ 048H
spo_uB          equ 04CH
spo_pS          equ 050H

;
;---------------------------Private-Routine-----------------------------;
; vSrcOpaqCopyS1D1
;
;   Opaque copy from 1Bpp to 1Bpp (DWORD ALIGNED)
;
; Entry:
;
;   pjSrcIn
;   SrcLeft
;   DeltaSrcIn
;   pjDstIn
;   DstLeft
;   DstRight
;   DeltaDstIn
;   cy
;   uF
;   uB
;   pS
;
;
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;-----------------------------------------------------------------------;

        public vSrcOpaqCopyS1D1@44

vSrcOpaqCopyS1D1@44 proc near

        ;
        ; opaque expansion requires a check for masking, if
        ; uF and uB are the same color, then the and mask is set to
        ; 0, this really means the src is ignored. The and mask is
        ; set to 0xFFFFFFFF if the uF = 0, this causes an inversion
        ; from src to dst.
        ;
        ; This routine is split into 2 sections, section 1 has an and
        ; mask value of 0xFFFFFFFF, so it is ignored. Section 2 has an
        ; and mask value if 0, so no src needs to be read.
        ;
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp
        sub     esp,5*4

        mov     spo_lXorMask[esp],0

        test    spo_uF[esp],1
        jnz     @F
        mov     spo_lXorMask[esp],0FFFFFFFFh
@@:

        ;
        ;  Start and end cases and masks. Start case is the first partial
        ;  DWORD (if needed) and end case is the last partial DWORD (if needed)
        ;

        mov     ecx,spo_DstLeft[esp]            ; Left (startint Dst Location)
        sub     edi,edi                         ; zero
        not     edi                             ; flag = 0xffffff
        mov     esi,edi                         ; flag = 0xffffff
        and     ecx,01Fh                        ; DstLeftAln,if 0 then don't make mask
        jz      @F

        ;
        ; ulStartMask >>= lStartCase, shift ulStartMask right by starting alignment,
        ; then BSWAP this back to little endian
        ;

        shr     edi,cl                          ; ulStartMask >> lStartCase
        ror     di,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     edi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     di,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     eax,spo_DstRight[esp]           ; right (last pixel)
        and     eax,01Fh                        ; DstRightAln = DstRight & 0x1F
        jz      @F                              ; if 0, mask = 0xffffffff

        ;
        ; ulEndMask = 0xFFFFFF << ( 32 - lEndCase). Shift big endian 0xFFFFFF left
        ; by lEndCase, then BSWAP
        ;

        mov     ecx,32                          ; shift 32 - lEndCase
        sub     ecx,eax                         ; 32 - lEndCase
        shl     esi,cl                          ; ulEndMask << lEndCase
        ror     si,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     esi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     si,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     spo_ulStartMask[esp],edi        ; save
        mov     spo_ulEndMask[esp],esi          ; save

        ;
        ; check for uF == uB, if so then branch to second section of routine
        ;

        mov     eax,spo_uF[esp]
        cmp     eax,spo_uB[esp]
        jz      Opaq1to1NoSrc

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spo_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spo_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Opaq1to1Partial

        mov     spo_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spo_pjDstIn[esp]
        mov     esi,spo_pjSrcIn[esp]
        mov     ebx,spo_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spo_cy[esp]                 ; keep track of # of scan lines
        mov     ecx,spo_lXorMask[esp]           ; load xor mask
        mov     ebp,spo_DeltaSrcIn[esp]

Opaq1to1DwordLoop:

        mov     eax,spo_lEndOffset[esp]         ; load loop x count

@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax -4 + esi]          ; load dw 0
        xor     ebx,ecx                         ; xor mask
        mov     [4 * eax -4 + edi],ebx          ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

        ;
        ; done with scan line, add strides
        ;

        add     edi,spo_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,ebp                         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Opaq1to1DwordLoop

Opaq1to1Partial:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spo_DstLeft[esp]                     ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Opaq1to1RightEdge               ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spo_DstRight[esp]           ; right edge
        mov     edx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,edx                         ; DstRight & ~0x1F
        and     edx,spo_DstLeft[esp]            ; DstLeft  & ~0x1F

        mov     ecx,spo_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal, start and stop
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Opaq1to1RightEdge won't run
        ;

        and     ecx,spo_ulEndMask[esp]          ; combine with start mask
        mov     spo_DstRight[esp],0             ; save 0
@@:

        mov     spo_ulStartMask[esp],ecx        ; Src Mask
        not     ecx
        mov     spo_tMask[esp],ecx              ; Dst Mask = ~SrcMask

        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spo_DstLeft[esp]            ; load
        mov     ebx,spo_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spo_pjDstIn[esp]            ; load dst addr
        mov     esi,spo_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ecx,spo_DeltaDstIn[esp]
        mov     ebp,spo_DeltaSrcIn[esp]
        mov     edx,spo_cy[esp]

        ;
        ; unroll left edge loop 2 times. Address fix-up is needed
        ;

        sub     esi,ebp                         ; fix-up address for odd cycle
        sub     edi,ecx                         ; fix-up address for odd cycle

        add     edx,1
        shr     edx,1
        jnc     Opaq1to1PartialLeftOdd

        add     esi,ebp                         ; un-fix-up address for even cycle
        add     edi,ecx                         ; un-fix-up address for even cycle

@@:

        mov     eax,[esi]                       ; load src
        mov     ebx,[edi]                       ; load dst
        xor     eax,spo_lXorMask[esp]           ; xor
        and     ebx,spo_tMask[esp]
        and     eax,spo_ulStartMask[esp]
        or      eax,ebx                         ; mask src with lStartMask
        mov     [edi],eax

Opaq1to1PartialLeftOdd:

        mov     eax,[esi + ebp]                 ; load src
        mov     ebx,[edi + ecx]                 ; load dst
        xor     eax,spo_lXorMask[esp]           ; xor
        and     ebx,spo_tMask[esp]
        and     eax,spo_ulStartMask[esp]
        or      eax,ebx                         ; mask src with lStartMask
        mov     [edi + ecx],eax

        lea     esi,[esi + 2*ebp]
        lea     edi,[edi + 2*ecx]

        dec     edx
        jnz     @B

        ;
        ; done with left edge
        ;

Opaq1to1RightEdge:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spo_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndOpaq1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spo_DstRight[esp]           ; DstRight
        mov     ecx,spo_DstLeft[esp]            ; load DstLeft
        mov     eax,spo_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spo_pjDstIn[esp]            ;
        mov     esi,spo_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset
        mov     ecx,spo_DeltaDstIn[esp]
        mov     ebp,spo_DeltaSrcIn[esp]
        mov     edx,spo_cy[esp]

        mov     eax,spo_ulEndMask[esp]          ; load end mask
        not     eax                             ; invert  for dst mask
        mov     spo_ulStartMask[esp],eax        ; not mask for dst

        ;
        ; unroll right edge 2 times. Address fix-up is needed.
        ;

        sub     esi,ebp                         ; fix up address for odd cycle
        sub     edi,ecx                         ; fix up address for odd cycle

        inc     edx                             ; add 1 to loop count
        shr     edx,1                           ; device loop count by 2
        jnc     Opaq1to1PartialRightOdd         ; if carry, loop was initially even

        add     esi,ebp                         ; fix up address for odd cycle
        add     edi,ecx                         ; fix up address for odd cycle

@@:

        mov     eax,[esi]                       ; load src dw 0
        mov     ebx,[edi]                       ; load dst dw 0
        xor     eax,spo_lXorMask[esp]           ; xor src dw
        and     ebx,spo_ulStartMask[esp]        ; mask dst dw
        and     eax,spo_ulEndMask[esp]          ; mask src dw
        or      eax,ebx                         ; combine
        mov     [edi],eax                       ; store

Opaq1to1PartialRightOdd:

        mov     eax,[esi + ebp]                 ; load src dw 1
        mov     ebx,[edi + ecx]                 ; load dst dw 1
        xor     eax,spo_lXorMask[esp]           ; xor src dw
        and     ebx,spo_ulStartMask[esp]        ; mask dst dw
        and     eax,spo_ulEndMask[esp]          ; mask src dw
        or      eax,ebx                         ; combine
        mov     [edi + ecx],eax                 ; store

        lea     esi,[esi + 2 * ebp]             ; 2nd next scan line
        lea     edi,[edi + 2 * ecx]             ; 2nd next scan line

        dec     edx                             ; dec loop count
        jnz     @B                              ; repeat

        jmp     EndOpaq1to1

        ;
        ; Opaque text expansion, no src required. lXorMask is masked and written to dest
        ;


Opaq1to1NoSrc:

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spo_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spo_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Opaq1to1PartialNoSrc

        mov     spo_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ;

        mov     edi,spo_pjDstIn[esp]
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spo_cy[esp]                 ; keep track of # of scan lines
        mov     ebx,spo_lXorMask[esp]           ; xor mask
        not     ebx                             ; not xor mask
        mov     esi,spo_DeltaDstIn[esp]         ; dest scan line inc

Opaq1to1DwordLoopNoSrc:

        ;
        ; DWORD loop, unrolled 2 times. lEndOffset has been pre-incremented so
        ; a loop count of 1 is incremented to 2, then shifted to make a loop
        ; count of 1 with a carry of zero. ( no carry represents a odd element)
        ; Address fix-up is required.
        ;

        mov     eax,spo_lEndOffset[esp]         ; get inner loop count
@@:
        ;
        ; write 1 DWORD
        ;

        mov     [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

        ;
        ; done with scan line, add strides
        ;

        add     edi,esi                         ; pjDst += DeltaDst

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Opaq1to1DwordLoopNoSrc


Opaq1to1PartialNoSrc:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spo_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Opaq1to1RightEdgeNoSrc          ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     edx,spo_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spo_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal then start and end
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Opaq1to1RightEdge won't run
        ;

        and     ecx,spo_ulEndMask[esp]          ; combine with start mask
        mov     spo_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;

        mov     eax,spo_DstLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        mov     edi,spo_pjDstIn[esp]            ; load dst addr
        lea     edi,[edi + 4*eax]               ; dest address
        mov     ebx,spo_DeltaDstIn[esp]         ; dst scan line stride
        mov     esi,spo_lXorMask[esp]           ; load xor mask
        not     esi                             ; invert
        and     esi,ecx                         ; masked constant src
        not     ecx                             ; ~lStartMask
        mov     edx,spo_cy[esp]                 ; loop count

        ;
        ; unroll left edge loop 2 times. Address fix-up is needed
        ;

        sub     edi,ebx                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Opaq1to1LeftEdgeOddNoSrc        ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up address for even cycle

@@:
        mov     eax,[edi]                       ; load src
        and     eax,ecx                         ; mask
        or      eax,esi                         ; invert
        mov     [edi],eax                       ; store

Opaq1to1LeftEdgeOddNoSrc:

        mov     eax,[edi + ebx]                 ; load src
        and     eax,ecx                         ; mask
        or      eax,esi                         ; invert
        mov     [edi + ebx],eax                 ; store

        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Opaq1to1RightEdgeNoSrc:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spo_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndOpaq1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ;

        mov     ebx,spo_DstRight[esp]           ; DstRight
        shr     ebx,5                           ; DstRight >> 5
        mov     edi,spo_pjDstIn[esp]            ;
        lea     edi,[edi + 4*ebx]               ; pjDstIn + DstOffset

        mov     ecx,spo_ulEndMask[esp]          ; load end mask
        mov     esi,spo_lXorMask[esp]           ; load xor mask
        not     esi                             ; invert
        and     esi,ecx                         ; mask with endmask
        not     ecx                             ; invert end mask
        mov     ebx,spo_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spo_cy[esp]                 ; loop count

        ;
        ; unroll right edge 2 times, address fix-up is needed
        ;

        sub     edi,ebx                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Opaq1to1RightEdgeOddNoSrc       ; do single "odd" DWORD

        add     edi,ebx                         ; un-fix-up address for even cycle

@@:
        mov     eax,[edi]                       ; load src dword
        and     eax,ecx                         ; mask
        or      eax,esi                         ; combine
        mov     [edi],eax                       ; store

Opaq1to1RightEdgeOddNoSrc:

        mov     eax,[edi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        or      eax,esi                         ; combine
        mov     [edi+ebx],eax                   ; store

        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        ;
        ; done!
        ;

EndOpaq1to1:

        add     esp,5*4

        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     44

vSrcOpaqCopyS1D1@44 endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\keizon\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\line.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: line.asm
;
; Routines for drawing line DDAs for 8BPP
;
; Created: 10-DEC-1993
; Author: Mark Enstrom
;
; Copyright (c) 1993-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        include line.inc
        .list

        .code

;---------------------------Private-Routine-----------------------------;
; vLine1Octant07
;
;   Line drawing DDA for 8BPP X major line in octant 0 or 7
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
; Wrote it
;-----------------------------------------------------------------------;

cProc   vLine8Octant07,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

        ;
        ; while (TRUE)
        ;

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;       if (--cPels == 0)
        ;               return
        ;

        dec     edi             ; --cPels
        jz      short Done      ; if zero, done

        ;
        ; this  is  an  x major line,  always
        ; add dN to the error term and always
        ; increment pjDst by 1.  If the error
        ; term  is  not  negative  after  the
        ; addition of dN, then add dM and inc
        ; pjDst by lDelta
        ; 

        inc     eax             ; pjDst++
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        add     eax,lDelta      ; pjDst += lDelta
        jmp     short LoopStart

Done:
        cRet vLine8Octant07 

endProc vLine8Octant07

;---------------------------Private-Routine-----------------------------;
; vLine1Octant34
;
;   Line drawing DDA for 8BPP X major line in octant 3 or 4
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant34,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

        ;
        ; while (TRUE)
        ;

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;       if (--cPels == 0)
        ;               return
        ;

        dec     edi             ; --cPels
        jz      short Done      ; if zero, done

        ;
        ; this  is  an  x major line,  always
        ; add dN to the error term and always
        ; increment pjDst by 1.  If the error
        ; term  is  not  negative  after  the
        ; addition of dN, then add dM and inc
        ; pjDst by lDelta
        ; 

        dec     eax             ; pjDst--
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        add     eax,lDelta      ; pjDst += lDelta
        jmp     short LoopStart

Done:

        cRet vLine8Octant34

endProc vLine8Octant34

;---------------------------Private-Routine-----------------------------;
; vLine1Octant16
;
;   Draw Y-Major line in octant 1 or 6
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant16,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;      while cPels--
        ;

        dec     edi
        jz      short Done

        ;
        ; This is a y-major line, every loop throuhg
        ; the DDA, add lDelta to pjDst to  increment
        ; to the next scan line.  Also add dN to the
        ; error term, if the error term is >= 0 after
        ; the addition them add xInc to pjDst and add
        ; dM to the error term
        ;

        add     eax,lDelta      ; pjDst += lDelta
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        inc     eax             ; pjDst ++
        jmp     short LoopStart

Done:

        cRet vLine8Octant16

endProc vLine8Octant16

;---------------------------Private-Routine-----------------------------;
; vLine1Octant25
;
;   Draw Y-Major line in octant 5 or 6
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant25,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;      while cPels--
        ;

        dec     edi
        jz      short Done

        ;
        ; This is a y-major line, every loop throuhg
        ; the DDA, add lDelta to pjDst to  increment
        ; to the next scan line.  Also add dN to the
        ; error term, if the error term is >= 0 after
        ; the addition them add xInc to pjDst and add
        ; dM to the error term
        ;

        add     eax,lDelta      ; pjDst += lDelta
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        dec     eax             ; pjDst --
        jmp     short LoopStart

Done:

        cRet vLine8Octant25

endProc vLine8Octant25

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\str.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: str.asm
;
; Same format, no translation stretch blt inner loop
;
; Created: 17-Oct-1994
; Author: Mark Enstrom
;
; Copyright (c) 1994-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
;
;  stack based params and local variables
;

sp_TempXFrac           equ 000H
sp_YCarry              equ 004H
sp_LeftCase            equ 008H
sp_RightCase           equ 00CH
sp_pjSrcScan           equ 010H
sp_SrcIntStep          equ 014H
sp_DstStride           equ 018H
sp_XCount              equ 01CH
sp_ebp                 equ 020H
sp_esi                 equ 024H
sp_edi                 equ 028H
sp_ebx                 equ 02CH
sp_RetAddr             equ 030H
sp_pSTR_BLT            equ 034H

        .list

;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vDirectStretch8
;
;   Stretcg 8 to 8
;
; Entry:
;
;   pSTR_BLT - pointer to stretch blt parameter block
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING   This routine uses EBP as a general variable.
;           Also, if parameters are changed, the ret statement must
;           also be fixed
;
;------------------------------------------------------------------------------;

        public vDirectStretch8@4

vDirectStretch8@4 proc near

        ;
        ;  use ebp as general register, use esp for parameter and local access
        ;  save ebp,ebx,esi,edi

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,8 * 4

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add strarting Src Pixel
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        add     edi,[ebp].str_XDstStart                 ; add strarting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     dword ptr [ebp].str_lDeltaSrc           ; calc scan line int lines to step
	mov	[esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     eax,edi                                 ; make copy of pjDst
        and     eax,3                                   ; calc left edge case
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,eax                                 ; 4 - LeftCase
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count
        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

LoopTop::

        ;
        ; can 2 scan dst lines be drawn from 1 src?
        ;

        xor     ebx,ebx                                 ; zero ebx
	mov	eax,[ebp].str_ulYFracAccumulator	; get .32 part of Y pointer
	add	eax,[ebp].str_ulYDstToSrcFracCeil	; add in fractional step
        adc     ebx,0
        mov     [esp].sp_YCarry,ebx                     ; save carry for end of loop
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        cmp     [esp].sp_SrcIntStep,0                   ; int step must be zero
        jne     SingleLoop

        cmp     ebx,0                                   ; carry must be zero
        jne     SingleLoop

        cmp     [ebp].str_YDstCount,2                   ; y count must be at least 2
        jl      SingleLoop

        ;
        ; there was no carry, draw 2 dst scan lines. Add 1 extra y Frac, and subtract
        ; one extra Y Count
        ;

	add	eax,[ebp].str_ulYDstToSrcFracCeil	; add in fractional step
        adc     ebx,0                                   ; get new carry
        mov     [esp].sp_YCarry,ebx                     ; save carry for end of loop
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator
	dec	dword ptr [ebp].str_YDstCount           ; dec y count

        ;
        ; Draw 2 Dst scan lines from 1 src scan
        ;

	mov	eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
	mov	edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

	mov	ebx,[ebp].str_lDeltaDst                 ; Get Dst Scan line delta
        mov	ebp,edi				        ; get dst pointer to ebp (ebp uses ss:)

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

	mov	edi,edx				        ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

	; esi = pointer to source pixel
	; ebp = pointer to dest pixel
	; ecx = Left edge case
	; eax = integer step in source
	; ebx = Dst scan line delta
	; edi = fractional accumulator
	; edx = free for pixel data

        ;
	; first do the left side to align dwords
        ;

        cmp     ecx,0
        je      DualDwordAligned

DualLeftEdge:

	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	mov	[ebp+ebx],dl				; write it out to next scan line
	add	edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec and repeat for left edge
        jne     DualLeftEdge

DualDwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
	mov	dl,[esi]				; get a source pixel edx = ???0
        add     edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add integer and carry

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dh,[esi]				; get source pixel edx = ??10
	adc	esi,eax					; add integer and carry

	shl     edx,16  				; edx = 10??

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dl,[esi]				; get a source pixel edx = 10?2
	adc	esi,eax					; add integer and carry

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dh,[esi]				; get source pixel edx = 0132
	adc	esi,eax					; add integer and carry

	ror     edx,16          			; edx = 3210

	mov	[ebp],edx			        ; write everything to dest
	mov	[ebp+ebx],edx			        ; write everything to dest plus 1 scan line

	add	ebp,4					; increment dest pointer by 2 dwords
	dec	ecx					; decrement count
	jnz	@b     					; do more pixels

DualRightEdge:

        ;
	; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        cmp     ecx,0
        je      DualAddScanLine

@@:
	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	mov	[ebp+ebx],dl				; write it out to next scan line
        add     edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx
        jne     @B

        ;
        ; add one extra lDeltaDst (ebx) tp ebp for the
        ; extra dst scan line
        ;

DualAddScanLine:

        add     ebp,ebx

        jmp     EndScanLine                             ; skip to end

        ;
        ; Expand and draw 1 scan line
        ;

SingleLoop:

	mov	eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
	mov	ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
	mov	edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

	mov	ebp,edi				        ; get dst pointer to ebp (ebp uses ss:)

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

	mov	edi,edx				        ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

	; esi = pointer to source pixel
	; ebp = pointer to dest pixel
	; ecx = Left edge case
	; eax = integer step in source
	; ebx = fractional step in source
	; edi = fractional accumulator
	; edx = free for pixel data

        ;
	; first do the left side to align dwords
        ;

        cmp     ecx,0
        je      DwordAligned

@@:
	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	add	edi,ebx					; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
	mov	dl,[esi]				; get a source pixel edx = ???0
	add	edi,ebx					; step fraction
	adc	esi,eax					; add integer and carry

	add	edi,ebx					; step fraction
	mov	dh,[esi]				; get source pixel edx = ??10
	adc	esi,eax					; add integer and carry

	shl     edx,16  				; edx = 10??

	add	edi,ebx					; step fraction
	mov	dl,[esi]				; get a source pixel edx = 10?2
	adc	esi,eax					; add integer and carry

	add	edi,ebx					; step fraction
	mov	dh,[esi]				; get source pixel edx = 0132
	adc	esi,eax					; add integer and carry

	ror     edx,16          			; edx = 3210

	mov	[ebp],edx			        ; write everything to dest

	add	ebp,4					; increment dest pointer by 1 dword
	dec	ecx					; decrement count
	jnz	@b     					; do more pixels

        ;
	; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        cmp     ecx,0
        je      EndScanLine

@@:

	mov	dl,[esi]				; fetch pixel
	mov	ss:[ebp],dl				; write it out
	add	edi,ebx					; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

	mov	edi,ebp					; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        cmp     [esp].sp_YCarry,1                       ; is there a carry
	jne	@f	                                ; no additional int step

	add	esi,[ebp].str_lDeltaSrc		        ; step one extra in src
@@:
	add	esi,[esp].sp_SrcIntStep			; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
	add	edi,[esp].sp_DstStride		        ; step to next scan in dst
	dec	dword ptr [ebp].str_YDstCount
	jnz	LoopTop


        add     esp,8*4
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch8@4 endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\tiler.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: tiler.asm
;
; Helper routines for P, Pn and DPx tiling algorithm.
;
; Created: 28-Jan-1992 10:20:08
; Author: Donald Sidoroff [donalds]
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        .list

        .code

;---------------------------Private-Routine-----------------------------;
; vFetchAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchAndCopy,4,<       \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfc_copy_body

vfc_copy_head:
        mov     eax,[esi+ebx]
        stosd

        dec     edx
        jz      vfc_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfc_copy_head

vfc_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfc_copy_tail

        rep     movsd

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfc_copy_body

vfc_copy_tail:
        add     edx,ecx
        mov     ecx,edx                 ; This many left!

        rep     movsd

vfc_done:
        pop     ebp

        cRet    vFetchAndCopy

endProc vFetchAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchShiftAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftAndCopy,4,<  \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsc_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsc_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        stosd

        dec     dword ptr [ebp].ff_culFillTmp          ; Are we done?
        jz      vfsc_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsc_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsc_in_pipeline


vfsc_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsc_loop                   ; Restart pipeline

vfsc_done:
        pop     ebp

        cRet    vFetchShiftAndCopy

endProc vFetchShiftAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchNotAndCopy
;
;   Fetch one row of a pattern, negate it and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchNotAndCopy,4,<    \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfnc_copy_body

vfnc_copy_head:
        mov     eax,[esi+ebx]
        not     eax
        stosd

        dec     edx
        jz      vfnc_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfnc_copy_head

vfnc_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfnc_copy_tail

@@:
        lodsd
        not     eax
        stosd
        loop    @B

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfnc_copy_body

vfnc_copy_tail:
        add     edx,ecx
        jz      vfnc_done
        mov     ecx,edx                 ; This many left!

@@:
        lodsd
        not     eax
        stosd
        loop    @B

vfnc_done:
        pop     ebp

        cRet    vFetchNotAndCopy

endProc vFetchNotAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchShiftNotAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftNotAndCopy,4,<   \
        uses    ebx esi edi,        \
        pff:    ptr FETCHFRAME      >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsnc_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsnc_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        not     eax
        stosd

        dec     dword ptr [ebp].ff_culFillTmp ; Are we done?
        jz      vfsnc_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsnc_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsnc_in_pipeline

vfsnc_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsnc_loop                  ; Restart pipeline

vfsnc_done:
        pop     ebp

        cRet    vFetchShiftNotAndCopy

endProc vFetchShiftNotAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchAndMerge
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchAndMerge,4,<      \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfm_copy_body

vfm_copy_head:
        mov     eax,[esi+ebx]
        xor     [edi],eax
        add     edi,4

        dec     edx
        jz      vfm_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfm_copy_head

vfm_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfm_copy_tail

@@:
        lodsd
        xor     [edi],eax
        add     edi,4
        loop    @B

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfm_copy_body

vfm_copy_tail:
        add     edx,ecx
        jz      vfm_done
        mov     ecx,edx                 ; This many left!

@@:
        lodsd
        xor     [edi],eax
        add     edi,4
        loop    @B

vfm_done:
        pop     ebp

        cRet    vFetchAndMerge

endProc vFetchAndMerge

;---------------------------Private-Routine-----------------------------;
; vFetchShiftAndMerge
;
;   Fetch one row of a pattern and XOR it into destination
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftAndMerge,4,< \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsm_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsm_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        xor     [edi],eax
        add     edi,4

        dec     dword ptr [ebp].ff_culFillTmp ; Are we done?
        jz      vfsm_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsm_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsm_in_pipeline

vfsm_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsm_loop                   ; Restart pipeline

vfsm_done:
        pop     ebp

        cRet    vFetchShiftAndMerge

endProc vFetchShiftAndMerge

    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\overblend.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: alphaimg.asm
;
; Inner loop for alpha blending
; See alphablt.cxx:vAlphaPerPixelOnly() for explanation
;   of algorithm.
;
; Created: 12-Mar-1997
; Author: Mark Enstrom
;
; Copyright (c) 1997-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        include gdii386.inc



ovr_DstLast     equ 000H
ovr_EDI         equ 004H
ovr_ESI         equ 008H
ovr_EDX         equ 00cH
ovr_ECX         equ 010H
ovr_EBX         equ 014H
ovr_ppixEBP     equ 018H
ovr_RA          equ 01cH
ovr_ppixDst     equ 020H
ovr_ppixSrc     equ 024H
ovr_cx          equ 028H
ovr_Blend       equ 02cH

ble_ConstAlpha  equ 000H
ble_LastX       equ 004H
ble_EDI         equ 008H
ble_ESI         equ 00cH
ble_EDX         equ 010H
ble_ECX         equ 014H
ble_EBX         equ 018H
ble_EBP         equ 01cH
ble_RA          equ 020H
ble_ppixDst     equ 024H
ble_ppixSrc     equ 028H
ble_cx          equ 02cH
ble_Blend       equ 030H

ble16_tSrc        equ 000H
ble16_tDst        equ 004H
ble16_ConstAlpha  equ 008H
ble16_LastX       equ 00cH
ble16_EDI         equ 010H
ble16_ESI         equ 014H
ble16_EDX         equ 018H
ble16_ECX         equ 01cH
ble16_EBX         equ 020H
ble16_EBP         equ 024H
ble16_RA          equ 028H
ble16_ppixDst     equ 02cH
ble16_ppixSrc     equ 030H
ble16_cx          equ 034H
ble16_Blend       equ 038H

;
; locals
;


        .list



;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vAlphaPerPixelOnly
;
;   Blend source and destination scan line. Source and destination are 32bpp
;   BGRA scan lines.
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;
;
;   VOID
;   vPixelOver(
;       ALPHAPIX       *ppixDst,
;       ALPHAPIX       *ppixSrc,
;       LONG           cx,
;       BLENDFUNCTION  BlendFunction
;       )
;   {
;       ALPHAPIX pixSrc;
;       ALPHAPIX pixDst;
;
;       while (cx--)
;       {
;           pixSrc = *ppixSrc;
;
;           if (pixSrc.pix.a != 0)
;           {
;               pixDst = *ppixDst;
;
;               if (pixSrc.pix.a == 255)
;               {
;                   pixDst = pixSrc;
;               }
;               else
;               {
;                   long    SrcTran = 255 - pixSrc->a;
;                   PBYTE   pTable = &pAlphaMulTable[SrcTran * 256];
;
;                   pixDst->r = pixSrc->r + *(pTable + pixDst->r);
;                   pixDst->g = pixSrc->g + *(pTable + pixDst->g);
;                   pixDst->b = pixSrc->b + *(pTable + pixDst->b);
;                   pixDst->a = pixSrc->a + *(pTable + pixDst->a);
;               }
;
;               *pwrMask = 1;
;               *ppixDst = pixDst;
;           }
;
;           pwrMask++;
;           ppixSrc++;
;           ppixDst++;
;       }
;   }
;
;
;

;
; parameters
;



        public  vAlphaPerPixelOnly@16

vAlphaPerPixelOnly@16 proc near


        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,4

        mov     ecx,ovr_cx[esp]         ; ecx = pixel count
        mov     edi,ovr_ppixDst[esp]    ; edi = destination address
        shl     ecx,2                   ; ecx = DWORD offset
        mov     esi,ovr_ppixSrc[esp]    ; esi = source address
        add     ecx,edi                 ; end dst addr
        cmp     edi,ecx                 ; end of scan line
        mov     ovr_DstLast[esp],ecx    ; save end scan line
        jz      PixelReturn
        
PixelLoop:
	mov     ecx,0FFH                ; ecx = 00 00 00 FF    
        mov     eax,[esi]               ; eax = AA RR GG BB    
	
	mov	edx,eax			; edx = AA RR GG BB
        
	shr     eax,24                  ; eax = 00 00 00 AA    
        add     esi,4                   ; inc src pointer      

        ;
        ; check for alpha == 0 and alpha == 0xff, these
        ; checks allow not writing output pixels that
        ; don't change, but this test decreases performance of the
        ; loop by 10%
        ;

        test    al,al                   ; test for 0
        jz      PixelZeroAlpha          ; jump to 0 quick out
                                        ;
        cmp     al,0ffH                 ; alpha = 0xff
        jz      PixelFFAlpha            ; jump to case ff
                                        
        sub     ecx,eax                 ; ecx = 00 00 00 255-sA
        mov     eax,[edi]               ; eax = dA dR dG dB
        
        mov     ebp,eax                 ; ebp = dA dR dG dB
        and     eax,0FF00FFFFH          ; eax = dA 00 dG dB
        
        shr     eax,8                   ; eax = 00 dA 00 dG
        and     ebp,000FF00FFH          ; ebp = 00 dR 00 dB
        
        imul    ebp,ecx                 ; ebp = dR*sA dB*sA     10 cycle delay
        
	imul    eax,ecx                 ; eax = dA*sA dG*sG     10 cycles
        
        add     ebp,0800080H            ; ebp = ( eR) ( eB)
        add     eax,0800080H            ; ebp = ( eA) ( eG)
        
        mov     ebx,ebp                 ; ebx = ( eR) ( eB)
        mov     ecx,eax                 ; ecx = ( eA) ( eG)
        
        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)
        and     ecx,0FF00FFFFH          ; ecx = eA 00 ( eG)
        
        shr     ebx,8                   ; ebx = 00 eR 00 eB
        add     edi,4                   ; inc dst pointer
        
        shr     ecx,8                   ; ecx = 00 eA 00 eG
        add     ebx,ebp                 ; ebx = ( eR) ( eB)
        
        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)
        add     ecx,eax                 ; ecx = ( eA) ( eG)
        
        mov     eax,ovr_DstLast[esp]
	and     ecx,0FF00FF00H          ; ecx = eA 00 eG 00
        
	shr     ebx,8                   ; ebx = 00 eR 00 eB
        add     ecx,edx                 ; ecx = AA sR GG sB     AA = sA + (1-sA)Da
        
        add     ecx,ebx                 ; ecx = AA RR GG BB
        cmp     edi,eax
        
        mov     [edi-4],ecx             ; save result
        jnz     PixelLoop

        ;
        ; restore stack frame
        ;

PixelReturn:

        add     esp,4
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16


PixelZeroAlpha:

        mov     eax,ovr_DstLast[esp]    ; end scan line
        add     edi,4                   ; inc dst
	
        cmp     edi,eax                 ; dst == dstEnd
        jnz     PixelLoop               ; loop

        jmp     PixelReturn

PixelFFAlpha:

        mov     ecx,ovr_DstLast[esp]    ; end scan line
        mov     [edi],edx               ; write pixel
        add     edi,4                   ; inc dst pointer
        cmp     edi,ecx
        jnz     PixelLoop

        jmp     PixelReturn




vAlphaPerPixelOnly@16 endp


;------------------------------------------------------------------------------;
; vAlphaConstOnly
;
;   Dst = Dst + Alpha * (Src - Dst)
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly@16
        
vAlphaConstOnly@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,8


        movzx   eax,BYTE PTR ble_Blend+2[esp]
        mov     ebx,ble_cx[esp]         ; ebx = pixel count
        mov     edi,ble_ppixDst[esp]    ; edi = destination address
        mov     esi,ble_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 4 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn
        
        mov     ble_LastX[esp],edx      ; save end x address

BlendLoop:

        mov     ebx,[edi]               ; ebx = D aa rr gg bb
        mov     ecx,[esi]               ; ecx = S aa rr bb bb
        and     ebx,000ff00ffH          ; ebx = D 00 rr 00 bb
        and     ecx,000ff00ffH          ; ecx = S 00 rr 00 bb
        
        mov     ebp,ebx                 ; ebp = D 00 rr 00 bb
        sub     ecx,ebx                 ; ecx = s 00 rr 00 bb
        imul    ecx,eax                 ; ecx =   rr rr bb bb      u
        shl     ebp,8                   ; ebp = D rr 00 bb 00      u
        mov     edx,[edi]               ; edx = D aa rr gg bb        v
        and     edx,0ff00ff00H          ; edx = D aa 00 gg 00      u
        sub     ebp,ebx                 ; ebp = D rr ee bb ee        v
        shr     edx,8                   ; edx = D 00 aa 00 gg      u
        add     ecx,000800080H          ; ecx =   rr rr bb bb + e    v
        add     ecx,ebp                 ; ecx =   rr rr bb bb      u
        mov     ebp,[esi]               ; ebp = S aa rr gg bb        v
        shr     ebp,8                   ; ebp = S ?? aa rr gg      u
        mov     ebx,ecx                 ; ebx =   rr rr bb bb        v
        and     ecx,0ff00ff00H          ; ecx =   rr 00 bb 00      u
        and     ebp,000ff00ffH          ; ebp = S 00 aa 00 gg        v
        shr     ecx,8                   ; ecx =   00 rr 00 bb      u
        sub     ebp,edx                 ; ebp =   del a del g        v
        add     ebx,ecx                 ; ebx =   rr rr bb bb      u
        mov     ecx,edx                 ; ecx = D 00 aa 00 gg        v
        imul    ebp,eax                 ; ebp = m aa aa gg gg      u
        shl     ecx,8                   ; ecx = D aa 00 gg 00      u
        and     ebx,0FF00FF00H          ; ebx =   rr 00 bb 00        v
        add     ebp,000800080H          ; ebp = m aa aa gg gg      u
        sub     ecx,edx                 ; ecx = D aa 00 gg 00        v
        shr     ebx,8                   ; ebx =   00 rr 00 bb      u
        add     ecx,ebp                 ; ecx = M aa aa gg gg        v
        mov     edx,ecx                 ; edx = M aa aa gg gg      u  
        and     ecx,0ff00ff00H          ; ecx = M aa 00 gg 00        v
        shr     ecx,8                   ; ecx = M 00 aa 00 gg      u
        add     esi,4                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M aa aa gg gg      u
        mov     ebp,ble_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0FF00FF00H          ; ecx = D aa 00 gg 00      u
        add     edi,4                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D aa rr gg bb      u
        cmp     edi,ebp                 ;                            v
        mov     [edi-4],ecx             ; store dst pixel          u
        jnz     BlendLoop               ;                            v
        

        ;
        ; restore stack frame
        ;

BlendReturn:

        add     esp,8
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly@16 endp

;------------------------------------------------------------------------------;
; vAlphaConstOnly16_555
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 555 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly16_555@16

vAlphaConstOnly16_555@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]       ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]  ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]  ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16
        
        mov     ble16_LastX[esp],edx    ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        
        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx
        
        and     ebx,000007c1fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,000007c1fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb 
        
        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb  
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb 
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000003e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000 
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000004010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M 
        and     ecx,0000F83E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000001fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ecx,5                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0000f83e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000004010H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,5                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly16_555@16 endp


;------------------------------------------------------------------------------;
; vAlphaConstOnly16_565
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 565 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly16_565@16

vAlphaConstOnly16_565@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]         ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]    ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16
        
        mov     ble16_LastX[esp],edx      ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        
        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx
        
        and     ebx,00000f81fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,00000f81fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb 
        
        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb  
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb 
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000007e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000 
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000008010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M 
        and     ecx,0001f03E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000003fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ebp,1                   ; ConstAlpha *2
        shl     ecx,6                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0001f03e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000000020H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,6                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        shr     ecx,1                   ;       D 0000 0000 0000 0GGG GGG0 0000
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly16_565@16 endp



_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\i386\xline.asm ===
page    ,132
;------------------------------Module-Header-------------------------------;
; Module Name: xline.asm                                                   ;
;                                                                          ;
; Contains the line intersection routine.                                  ;
;                                                                          ;
; Created: 26-Apr-1991 10:49:53                                            ;
; Author: Charl