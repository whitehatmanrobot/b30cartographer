           pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

        } else
           dprintf("  No public key\n");
    }

    PrintExtensions(pCert->pCertInfo->cExtension,
        pCert->pCertInfo->rgExtension, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCERTIFICATE_STRUCTW CertViewInfo;

        memset(&CertViewInfo, 0, sizeof(CertViewInfo));
        CertViewInfo.pCertContext = pCert;
        CertViewInfo.dwSize = sizeof(CertViewInfo);

        if (!CryptUIDlgViewCertificateW(
                &CertViewInfo,
                NULL                        // pfPropertiesChanged
                ))
            PrintLastError("CryptUIDlgViewCertificateW");
    }
}

void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            dprintf(" [%d] SerialNumber::", i);
            DisplaySerialNumber(&pEntry->SerialNumber);
        }

        dprintf(" [%d] RevocationDate:: %s\n", i,
            FileTimeText(&pEntry->RevocationDate));

        if (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_EXT_FLAG)) {
            if (pEntry->cExtension == 0)
                dprintf(" [%d] Extensions:: NONE\n", i);
            else {
                dprintf(" [%d] Extensions::\n", i);
                PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
            }
        }
    }
}

void DisplayCrl(
    IN PCCRL_CONTEXT pCrl,
    IN DWORD dwDisplayFlags
    )
{
    dprintf("Issuer::\n");
    DisplayName(&pCrl->pCrlInfo->Issuer);
    dprintf("ThisUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
    dprintf("NextUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

        CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    PrintExtensions(pCrl->pCrlInfo->cExtension, pCrl->pCrlInfo->rgExtension,
        dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        if (pCrl->pCrlInfo->cCRLEntry == 0)
            dprintf("Entries:: NONE\n");
        else {
            dprintf("Entries::\n");
            PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
                pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCRL_STRUCTW CrlViewInfo;

        memset(&CrlViewInfo, 0, sizeof(CrlViewInfo));
        CrlViewInfo.pCRLContext = pCrl;
        CrlViewInfo.dwSize = sizeof(CrlViewInfo);

        if (!CryptUIDlgViewCRLW(
                &CrlViewInfo
                ))
            PrintLastError("CryptUIDlgViewCRLW");
    }
}

static void PrintCtlEntries(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwDisplayFlags
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    DWORD cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        dprintf(" [%d] SubjectIdentifier::\n", i);
        PrintBytes("      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);

    }
}

void DisplayCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwDisplayFlags
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    dprintf("Version:: %d\n", pInfo->dwVersion);

    {
        DWORD cId;
        LPSTR *ppszId;
        DWORD i;

        dprintf("SubjectUsage::\n");
        cId = pInfo->SubjectUsage.cUsageIdentifier;
        ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
        if (cId == 0)
            dprintf("  No Usage Identifiers\n");
        for (i = 0; i < cId; i++, ppszId++)
            dprintf("  [%d] %s\n", i, *ppszId);
    }

    if (pInfo->ListIdentifier.cbData) {
        dprintf("ListIdentifier::\n");
        PrintBytes("    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }
    if (pInfo->SequenceNumber.cbData) {
        dprintf("SequenceNumber::");
        DisplaySerialNumber(&pInfo->SequenceNumber);
    }

    dprintf("ThisUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
    dprintf("NextUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        pszObjId = pInfo->SubjectAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SubjectAlgorithm:: %s\n", pszObjId);
        if (pInfo->SubjectAlgorithm.Parameters.cbData) {
            dprintf("SubjectAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

    }
    PrintExtensions(pInfo->cExtension, pInfo->rgExtension, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DWORD dwSignerCount;
        DWORD cbData;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData)) {
            dprintf("-----  Signer  -----\n");
            PrintLastError("CryptMsgGetParam(SIGNER_COUNT)");
        } else if (0 == dwSignerCount)
            dprintf("-----  No Signers  -----\n");
        else {
            DWORD dwSignerIndex;
            for (dwSignerIndex = 0; dwSignerIndex < dwSignerCount;
                                                            dwSignerIndex++) {
                DWORD dwFlags;
                PCCERT_CONTEXT pSigner;

                dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
                if (CryptMsgGetAndVerifySigner(
                        pCtl->hCryptMsg,
                        0,                  // cSignerStore
                        NULL,               // rghSignerStore
                        dwFlags,
                        &pSigner,
                        &dwSignerIndex
                        )) {
                    dprintf("-----  Signer [%d]  -----\n", dwSignerIndex);
                    DisplayCert(pSigner, 0);
                    CertFreeCertificateContext(pSigner);
                } else {
                    DWORD dwErr = GetLastError();
                    if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                        dprintf("-----  No Trusted Signer [%d]  -----\n",
                            dwSignerIndex);
                    else {
                        dprintf("-----  Signer [%d]  -----\n", dwSignerIndex);
                        PrintLastError("CryptMsgGetAndVerifySigner");
                    }
                }

            }
        }
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        if (pInfo->cCTLEntry == 0)
            dprintf("-----  No Entries  -----\n");
        else {
            dprintf("-----  Entries  -----\n");
            PrintCtlEntries(pCtl, dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        CRYPTUI_VIEWCTL_STRUCTW CtlViewInfo;

        memset(&CtlViewInfo, 0, sizeof(CtlViewInfo));
        CtlViewInfo.pCTLContext = pCtl;
        CtlViewInfo.dwSize = sizeof(CtlViewInfo);

        if (!CryptUIDlgViewCTLW(
                &CtlViewInfo
                ))
            PrintLastError("CryptUIDlgViewCTLW");
    }
}

#define MAX_LINK_DEPTH  20

PPROP_ELEMENT GetCachePropHead(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwInnerDepth;

    if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
        return pEle->Cache.pPropHead;

    pEle = pEle->pEle;

    // Skip past any links to get to the cache element
    dwInnerDepth = 0;
    while (pEle && dwInnerDepth++ < MAX_LINK_DEPTH) {
        CONTEXT_ELEMENT Ele;

        __try {
            memset(&Ele, 0, sizeof(Ele));
            ReadMemory((LPVOID) pEle, &Ele, sizeof(Ele), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Context Element at 0x%p\n", pEle);
            return NULL;
        }

        if (ELEMENT_TYPE_CACHE == Ele.dwElementType)
            return Ele.Cache.pPropHead;

        pEle = Ele.pEle;
    }

    return NULL;
}


void DisplayContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwDisplayFlags,
    IN BOOL fNext = FALSE
    )
{
    DWORD i;

    i = 0;
    while (pEle) {
        CONTEXT_ELEMENT Ele;
        const void *pvContext = (const void *) ((BYTE *) pEle +
            sizeof(CONTEXT_ELEMENT));

        __try {
            memset(&Ele, 0, sizeof(Ele));
            ReadMemory((LPVOID) pEle, &Ele, sizeof(Ele), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Context Element at 0x%p\n", pEle);
            goto ErrorReturn;
        }

        dprintf("====  ");

        switch (Ele.dwContextType + 1) {
            case CERT_STORE_CERTIFICATE_CONTEXT:
                dprintf("Certificate");
                break;
            case CERT_STORE_CRL_CONTEXT:
                dprintf("CRL");
                break;
            case CERT_STORE_CTL_CONTEXT:
                dprintf("CTL");
                break;
            default:
                dprintf("ContextType[%ld]", Ele.dwContextType);
        }

        dprintf("[");

        if (fNext)
            dprintf("%ld : ", i);
        dprintf("0x%p]  ====\n", pvContext);


        if (0 == (dwDisplayFlags & DISPLAY_SHORT_FLAG)) {
            dprintf("Element[0x%p]:: Type: ", pEle);
            switch (Ele.dwElementType) {
                case ELEMENT_TYPE_CACHE:
                    dprintf("CACHE");
                    break;
                case ELEMENT_TYPE_LINK_CONTEXT:
                    dprintf("LINK");
                    break;
                case ELEMENT_TYPE_EXTERNAL:
                    dprintf("EXTERNAL");
                    break;
                case ELEMENT_TYPE_COLLECTION:
                    dprintf("COLLECTION");
                    break;
                default:
                    dprintf("%ld", Ele.dwElementType);
            }

            dprintf(" RefCnt: %ld", Ele.lRefCnt);
            dprintf(" Flags: 0x%lx", Ele.dwFlags);
            if (Ele.pEle != pEle)
                dprintf(" pEle: 0x%p", Ele.pEle);
            dprintf(" NextContext: 0x%p", ToCertContext(Ele.pNext));
            dprintf(" PrevContext: 0x%p", ToCertContext(Ele.pPrev));
            dprintf(" Store: 0x%p", Ele.pStore);
            dprintf(" ProvStore: 0x%p", Ele.pProvStore);
            dprintf("\n");

            switch (Ele.dwContextType + 1) {
                case CERT_STORE_CERTIFICATE_CONTEXT:
                    {
                        CERT_CONTEXT CertContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCERT_CONTEXT pCert;

                        __try {
                            memset(&CertContext, 0, sizeof(CertContext));
                            ReadMemory(pvContext, &CertContext,
                                sizeof(CertContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CertContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CertContext.pbCertEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCert) {
                            DisplayCert(pCert, dwDisplayFlags);
                            CertFreeCertificateContext(pCert);
                        } else 
                            PrintLastError("CertCreateCertificateContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
                case CERT_STORE_CRL_CONTEXT:
                    {
                        CRL_CONTEXT CrlContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCRL_CONTEXT pCrl;

                        __try {
                            memset(&CrlContext, 0, sizeof(CrlContext));
                            ReadMemory(pvContext, &CrlContext,
                                sizeof(CrlContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CrlContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CrlContext.pbCrlEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCrl = CertCreateCRLContext(
                            X509_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCrl) {
                            DisplayCrl(pCrl, dwDisplayFlags);
                            CertFreeCRLContext(pCrl);
                        } else 
                            PrintLastError("CertCreateCRLContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
                case CERT_STORE_CTL_CONTEXT:
                    {
                        CTL_CONTEXT CtlContext;
                        BYTE *pbEncoded;
                        DWORD cbEncoded;
                        PCCTL_CONTEXT pCtl;

                        __try {
                            memset(&CtlContext, 0, sizeof(CtlContext));
                            ReadMemory(pvContext, &CtlContext,
                                sizeof(CtlContext), NULL);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            dprintf("Unable to read CtlContext at 0x%p\n",
                                pvContext);
                            break;
                        }
                        if (!GetEncodedBlob(CtlContext.pbCtlEncoded,
                                &pbEncoded, &cbEncoded))
                            break;
                        pCtl = CertCreateCTLContext(
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pbEncoded,
                            cbEncoded
                            );
                        if (pCtl) {
                            DisplayCtl(pCtl, dwDisplayFlags);
                            CertFreeCTLContext(pCtl);
                        } else 
                            PrintLastError("CertCreateCTLContext");
                        CertExtsFree(pbEncoded);
                    }
                    break;
            }

            PrintProperties(GetCachePropHead(&Ele), dwDisplayFlags);
        }


        if (!fNext)
            break;

        pEle = Ele.pNext;
        if (i++ > MAX_CONTEXT_CNT) {
            dprintf("Exceeded maximum context count of %d\n", MAX_CONTEXT_CNT);
            break;
        }
    }


CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;

}

void DisplayContext(
    IN const void *pvContext,
    IN DWORD dwDisplayFlags
    )
{
    if (((const void *)(UINT_PTR) sizeof(CONTEXT_ELEMENT)) > pvContext) {
        dprintf("Invalid, NULL Context address\n");
        return;
    }

    DisplayContextElement(
        ToContextElement((PCCERT_CONTEXT) pvContext),
        dwDisplayFlags
        );
}
    

void DisplayStore(
    IN PCERT_STORE pStore,
    IN DWORD dwDisplayFlags,
    IN DWORD dwNest
    )
{
    CERT_STORE Store;
    PCERT_STORE_LINK pStoreLink;
    DWORD i;

    __try {
        memset(&Store, 0, sizeof(Store));
        ReadMemory((LPVOID) pStore, &Store, sizeof(Store), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Store at 0x%p\n", pStore);
        goto ErrorReturn;
    }

    dprintf("Store[0x%p]:: Type: ", pStore);
    switch (Store.dwStoreType) {
        case STORE_TYPE_CACHE:
            dprintf("CACHE");
            break;
        case STORE_TYPE_EXTERNAL:
            dprintf("EXTERNAL");
            break;
        case STORE_TYPE_COLLECTION:
            dprintf("COLLECTION");
            break;
        default:
            dprintf("%ld", Store.dwStoreType);
    }
    dprintf(" RefCnt: %ld", Store.lRefCnt);
    dprintf(" Flags: 0x%lx", Store.dwFlags);
    dprintf(" State: ");
    switch (Store.dwState) {
        case STORE_STATE_DELETED:
            dprintf("DELETED");
            break;
        case STORE_STATE_NULL:
            dprintf("NULL");
            break;
        case STORE_STATE_OPENING:
            dprintf("OPENING");
            break;
        case STORE_STATE_OPEN:
            dprintf("OPEN");
            break;
        case STORE_STATE_DEFER_CLOSING:
            dprintf("DEFER_CLOSING");
            break;
        case STORE_STATE_CLOSING:
            dprintf("CLOSING");
            break;
        case STORE_STATE_CLOSED:
            dprintf("CLOSED");
            break;
        default:
            dprintf("%ld", Store.dwState);
    }
    dprintf("\n");

    PrintProperties(Store.pPropHead, dwDisplayFlags | DISPLAY_PROP_FLAG);

    for (i = 0; i < CONTEXT_COUNT; i++)
        DisplayContextElement(Store.rgpContextListHead[i], dwDisplayFlags,
            TRUE);

    i = 0;
    pStoreLink = Store.pStoreListHead;
    while (pStoreLink) {
        CERT_STORE_LINK StoreLink;
        DWORD j;

        __try {
            memset(&StoreLink, 0, sizeof(StoreLink));
            ReadMemory((LPVOID) pStoreLink, &StoreLink, sizeof(StoreLink),
                NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read StoreLink at 0x%p\n", pStoreLink);
            goto ErrorReturn;
        }

        dprintf("######  SiblingStore[%ld, %ld]  ######\n", dwNest, i);
        dprintf("Link[0x%p]:: Flags: 0x%lx", pStoreLink, StoreLink.dwFlags);
        dprintf(" RefCnt: %ld", StoreLink.lRefCnt);
        dprintf(" UpdateFlags: 0x%lx", StoreLink.dwUpdateFlags);
        dprintf(" Priority: %ld", StoreLink.dwPriority);
        dprintf("\n");
        if (dwNest > MAX_STORE_NEST_CNT) {
            dprintf("Exceeded maximum store nest count of %d\n",
                MAX_STORE_NEST_CNT);
            break;
        }
        DisplayStore(StoreLink.pSibling, dwDisplayFlags, dwNest + 1);

        pStoreLink = StoreLink.pNext;
        if (i++ > MAX_STORE_SIBLING_CNT) {
            dprintf("Exceeded maximum store sibling count of %d\n",
                MAX_STORE_SIBLING_CNT);
            break;
        }
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
}

DWORD GetDisplayFlags(
    IN OUT LPSTR *lppArgumentString
    )
{
    DWORD dwDisplayFlags = 0;
    LPSTR lpArgumentString = *lppArgumentString;

    while (TRUE) {
        while (*lpArgumentString == ' ')
            lpArgumentString++;

        if (*lpArgumentString == 's') {
            dwDisplayFlags |= DISPLAY_SHORT_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'v') {
            dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'u') {
            dwDisplayFlags |= DISPLAY_UI_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'x') {
            dwDisplayFlags |= DISPLAY_EXT_FLAG;
            lpArgumentString++;
        } else if (*lpArgumentString == 'p') {
            dwDisplayFlags |= DISPLAY_PROP_FLAG;
            lpArgumentString++;
        } else
            break;
    }

    *lppArgumentString = lpArgumentString;

    return dwDisplayFlags;
}

//
// context {[s|v|u|x|p]} address
//

DECLARE_API( context )
{
    DWORD dwDisplayFlags;
    const void *pvContext;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvContext = (const void *)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvContext) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayContext(
        pvContext,
        dwDisplayFlags
        );
}

//
// ele {[s|v|u|x|p]} address
//

DECLARE_API( ele )
{
    DWORD dwDisplayFlags;
    PCONTEXT_ELEMENT pEle;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pEle = (PCONTEXT_ELEMENT)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pEle) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayContextElement(
        pEle,
        dwDisplayFlags
        );
}

//
// store {[s|v|x|p]} address
//

DECLARE_API( store )
{
    DWORD dwDisplayFlags;
    PCERT_STORE pStore;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);
    dwDisplayFlags &= ~DISPLAY_UI_FLAG;

    pStore = (PCERT_STORE)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pStore) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    dprintf("######  Parent Store  ######\n");
    DisplayStore(
        pStore,
        dwDisplayFlags,
        0                   // dwNest
        );
}

//
// cert {[s|v|u|x|p]} address
//

DECLARE_API( cert )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCert = CertCreateCertificateContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    dprintf("=====  Certificate  =====\n");
    DisplayCert(pCert, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCertificateContext(pCert);
    return;
ErrorReturn:
    goto CommonReturn;

}

//
// crl {[s|v|u|x|p]} address
//

DECLARE_API( crl )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCRL_CONTEXT pCrl = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCrl = CertCreateCRLContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCrl == NULL) {
        PrintLastError("CertCreateCRLContext");
        goto ErrorReturn;
    }

    dprintf("=====  CRL  =====\n");
    DisplayCrl(pCrl, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCRLContext(pCrl);
    return;
ErrorReturn:
    goto CommonReturn;

}

//
// ctl {[s|v|u|x|p]} address
//

DECLARE_API( ctl )
{
    DWORD dwDisplayFlags;
    LPVOID pvAddr;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCCTL_CONTEXT pCtl = NULL;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);

    pvAddr = (LPVOID)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pvAddr) {
        dprintf("Invalid, NULL address\n");
        goto ErrorReturn;
    }

    //dprintf("Expression:: 0x%p\n", pvAddr);

    if (!GetEncodedBlob(pvAddr, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    pCtl = CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );
    if (pCtl == NULL) {
        PrintLastError("CertCreateCTLContext");
        goto ErrorReturn;
    }

    dprintf("=====  CTL  =====\n");
    DisplayCtl(pCtl, dwDisplayFlags);

CommonReturn:
    CertExtsFree(pbEncoded);
    CertFreeCTLContext(pCtl);
    return;
ErrorReturn:
    goto CommonReturn;

}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPCSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",             // 0x00000001
    "CERT_TRUST_IS_NOT_TIME_NESTED",            // 0x00000002
    "CERT_TRUST_IS_REVOKED",                    // 0x00000004
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",        // 0x00000008
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",        // 0x00000010
    "CERT_TRUST_IS_UNTRUSTED_ROOT",             // 0x00000020
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",     // 0x00000040
    "CERT_TRUST_IS_CYCLIC",                     // 0x00000080
    "Unknown Error Status",                     // 0x00000100
    "Unknown Error Status",                     // 0x00000200
    "Unknown Error Status",                     // 0x00000400
    "Unknown Error Status",                     // 0x00000800
    "Unknown Error Status",                     // 0x00001000
    "Unknown Error Status",                     // 0x00002000
    "Unknown Error Status",                     // 0x00004000
    "Unknown Error Status",                     // 0x00008000
    "CERT_TRUST_IS_PARTIAL_CHAIN",              // 0x00010000
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",         // 0x00020000
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",    // 0x00040000
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",    // 0x00080000
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status"
};

LPCSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "Unknown Info Status",              // 0x00000100
    "Unknown Info Status",              // 0x00000200
    "Unknown Info Status",              // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "Unknown Info Status",              // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN PCERT_TRUST_STATUS pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    dprintf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                dprintf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                dprintf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dprintf("\n");
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement,
    IN DWORD dwDisplayFlags
    )
{
    CERT_CHAIN_ELEMENT Element;

    __try {
        memset(&Element, 0, sizeof(Element));
        ReadMemory((LPVOID) pElement, &Element, sizeof(Element), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Chain Element at 0x%p\n", pElement);
        return;
    }
    DisplayContext( Element.pCertContext, dwDisplayFlags );
    dprintf("\n");
    DisplayTrustStatus( &Element.TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain,
    IN DWORD dwDisplayFlags
    )
{
    CERT_SIMPLE_CHAIN Chain;
    DWORD cElement;
    PCERT_CHAIN_ELEMENT *ppElement = NULL;

    if (NULL == pChain)
        return;

    __try {
        memset(&Chain, 0, sizeof(Chain));
        ReadMemory((LPVOID) pChain, &Chain, sizeof(Chain), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read Simple Chain at 0x%p\n", pChain);
        goto ErrorReturn;
    }

    DisplayTrustStatus( &Chain.TrustStatus );
    dprintf("Chain Element Count = %d\n", Chain.cElement);

    if (MAX_CHAIN_ELEMENT_CNT < Chain.cElement) {
        dprintf("Exceeded maximum chain element count of %d\n",
            MAX_CHAIN_ELEMENT_CNT);
        goto ErrorReturn;
    }

    if (Chain.cElement) {
        if (NULL == (ppElement = (PCERT_CHAIN_ELEMENT *) CertExtsAlloc(
                Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT))))
            goto ErrorReturn;

        __try {
            memset(ppElement, 0, Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT));
            ReadMemory((LPVOID) Chain.rgpElement, ppElement,
                 Chain.cElement * sizeof(PCERT_CHAIN_ELEMENT), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read ChainElement pointers at 0x%p\n",
                Chain.rgpElement);
            goto ErrorReturn;
        }
    }

    for ( cElement = 0; cElement < Chain.cElement; cElement++ )
    {
        dprintf("Chain Element [%d]\n", cElement);
        DisplayChainElement( ppElement[ cElement ], dwDisplayFlags );
    }
CommonReturn:
    CertExtsFree(ppElement);
    return;
ErrorReturn:
    goto CommonReturn;
}

void DisplayChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwDisplayFlags
    )
{
    CERT_CHAIN_CONTEXT ChainContext;
    DWORD cChain;
    PCERT_SIMPLE_CHAIN *ppChain = NULL;

    if (NULL == pChainContext)
        return;

    __try {
        memset(&ChainContext, 0, sizeof(ChainContext));
        ReadMemory((LPVOID) pChainContext, &ChainContext,
            sizeof(ChainContext), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read ChainContext at 0x%p\n", pChainContext);
        goto ErrorReturn;
    }

    dprintf("Chain Context\n\n");
    DisplayTrustStatus( (PCERT_TRUST_STATUS)&ChainContext.TrustStatus );
    dprintf("Simple Chain Count = %d\n\n", ChainContext.cChain );

    if (MAX_SIMPLE_CHAIN_CNT < ChainContext.cChain) {
        dprintf("Exceeded maximum simple chain count of %d\n",
            MAX_SIMPLE_CHAIN_CNT);
        goto ErrorReturn;
    }

    if (ChainContext.cChain) {
        if (NULL == (ppChain = (PCERT_SIMPLE_CHAIN *) CertExtsAlloc(
                ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN))))
            goto ErrorReturn;

        __try {
            memset(ppChain, 0,
                ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN));
            ReadMemory((LPVOID) ChainContext.rgpChain, ppChain,
                 ChainContext.cChain * sizeof(PCERT_SIMPLE_CHAIN), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read SimpleChain pointers at 0x%p\n",
                ChainContext.rgpChain);
            goto ErrorReturn;
        }
    }

    for ( cChain = 0; cChain < ChainContext.cChain; cChain++ )
    {
        dprintf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( ppChain[ cChain ], dwDisplayFlags );
    }

CommonReturn:
    CertExtsFree(ppChain);
    return;
ErrorReturn:
    goto CommonReturn;
}

//
// chain {[s|v|x|p]} address
//

DECLARE_API( chain )
{
    DWORD dwDisplayFlags;
    PCCERT_CHAIN_CONTEXT pChainContext;

    INIT_API();

    dwDisplayFlags = GetDisplayFlags(&lpArgumentString);
    dwDisplayFlags &= ~DISPLAY_UI_FLAG;

    pChainContext = (PCCERT_CHAIN_CONTEXT)(ULONG_PTR) GetExpression(lpArgumentString);
    if (NULL == pChainContext) {
        dprintf("Invalid, NULL address\n");
        return;
    }

    DisplayChain(
        pChainContext,
        dwDisplayFlags
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasnx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       xmsasnx.cpp
//
//  Contents:   
//              Encode/Decode APIs
//
//              Implementation using the MS ASN1 compiler / RTS.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//
//  History:    02-Nov-98       philh   created
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <malloc.h>

#include "xenroll.h"
#include "cenroll.h"

#include "pkiasn1.h"      
#include "pkialloc.h"      
#include "crypttls.h"


extern "C" 
{              
#include "xmsasn.h"
}  

#define NO_OSS_DEBUG
#include <dbgdef.h>


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


HCRYPTASN1MODULE hAsn1Module = NULL;
HMODULE hCrypt32Dll = NULL;

typedef HCRYPTASN1MODULE (WINAPI *PFN_CRYPT_INSTALL_ASN1_MODULE) (
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );
typedef BOOL (WINAPI *PFN_CRYPT_UNINSTALL_ASN1_MODULE) (
    IN HCRYPTASN1MODULE hAsn1Module
    );

typedef ASN1encoding_t (WINAPI *PFN_CRYPT_GET_ASN1_ENCODER)(
    IN HCRYPTASN1MODULE hAsn1Module
    );
typedef ASN1decoding_t (WINAPI *PFN_CRYPT_GET_ASN1_DECODER)(
    IN HCRYPTASN1MODULE hAsn1Module
    );

PFN_CRYPT_INSTALL_ASN1_MODULE pfnCryptInstallAsn1Module = NULL;
PFN_CRYPT_UNINSTALL_ASN1_MODULE pfnCryptUninstallAsn1Module = NULL;
PFN_CRYPT_GET_ASN1_ENCODER pfnCryptGetAsn1Encoder = NULL;
PFN_CRYPT_GET_ASN1_DECODER pfnCryptGetAsn1Decoder = NULL;


//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    if (hAsn1Module)
        return pfnCryptGetAsn1Encoder(hAsn1Module);
    else
        return NULL;
}

static ASN1decoding_t GetDecoder(void)
{
    if (hAsn1Module)
        return pfnCryptGetAsn1Decoder(hAsn1Module);
    else
        return NULL;
}


//+-------------------------------------------------------------------------
//  Cert allocation and free functions
//--------------------------------------------------------------------------
static void *CertAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void CertFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncode(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t ge = GetEncoder();

    if (NULL == ge)
        return FALSE;

    return PkiAsn1EncodeInfo(
        ge,
        pdunum,
        pAsn1Info,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppAsn1Info
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    if (pAsn1Info) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL Asn1X509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pAsn1
        )
{
    pAsn1->count = sizeof(pAsn1->value) / sizeof(pAsn1->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pAsn1->count, pAsn1->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void Asn1X509GetObjId(
        IN ObjectID *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pAsn1->count,
        pAsn1->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static BOOL WINAPI Asn1X509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
	    IN OUT DWORD *pcbEncoded
	);

static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
	);

static BOOL WINAPI Asn1RequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI Asn1RequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
static BOOL WINAPI Asn1CSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI Asn1NameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncode,
    XENROLL_REQUEST_INFO,    Asn1RequestInfoEncode,
    szOID_ENROLLMENT_CSP_PROVIDER,  Asn1CSPProviderEncode,
    szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecode,
    XENROLL_REQUEST_INFO,    Asn1RequestInfoDecode
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))


//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

static const CRYPT_OID_FUNC_ENTRY CmcEncodeExFuncTable[] = {
    CMC_DATA, Asn1CmcDataEncodeEx,
    CMC_RESPONSE, Asn1CmcResponseEncodeEx,
    CMC_STATUS, Asn1CmcStatusEncodeEx,
    CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsEncodeEx,
    CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesEncodeEx,
};
#define CMC_ENCODE_EX_FUNC_COUNT (sizeof(CmcEncodeExFuncTable) / \
                                    sizeof(CmcEncodeExFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY CmcDecodeExFuncTable[] = {
    CMC_DATA, Asn1CmcDataDecodeEx,
    CMC_RESPONSE, Asn1CmcResponseDecodeEx,
    CMC_STATUS, Asn1CmcStatusDecodeEx,
    CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsDecodeEx,
    CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesDecodeEx,
};
#define CMC_DECODE_EX_FUNC_COUNT (sizeof(CmcDecodeExFuncTable) / \
                                    sizeof(CmcDecodeExFuncTable[0]))


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL MSAsnInit(
        HMODULE hInst)
{
    BOOL fRet;
    DWORD dwExceptionCode;


    if (NULL == (hCrypt32Dll = LoadLibraryA("crypt32.dll"))) 
        goto LoadCrypt32DllError;

    if (NULL == (pfnCryptInstallAsn1Module =
            (PFN_CRYPT_INSTALL_ASN1_MODULE) GetProcAddress(
                hCrypt32Dll, "I_CryptInstallAsn1Module")))
        goto I_CryptInstallAsn1ModuleProcAddressError;
    if (NULL == (pfnCryptUninstallAsn1Module =
            (PFN_CRYPT_UNINSTALL_ASN1_MODULE) GetProcAddress(
                hCrypt32Dll, "I_CryptUninstallAsn1Module")))
        goto I_CryptUninstallAsn1ModuleProcAddressError;
    if (NULL == (pfnCryptGetAsn1Encoder =
            (PFN_CRYPT_GET_ASN1_ENCODER) GetProcAddress(
                hCrypt32Dll, "I_CryptGetAsn1Encoder")))
        goto I_CryptGetAsn1EncoderProcAddressError;
    if (NULL == (pfnCryptGetAsn1Decoder =
            (PFN_CRYPT_GET_ASN1_DECODER) GetProcAddress(
                hCrypt32Dll, "I_CryptGetAsn1Decoder")))
        goto I_CryptGetAsn1DecoderProcAddressError;


    __try {
        XMSASN_Module_Startup();
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto MSAsn1DllException;
    }
    if (0 == (hAsn1Module = pfnCryptInstallAsn1Module(XMSASN_Module, 0, NULL)))
        goto InstallAsn1ModuleError;

    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            X509_ENCODE_FUNC_COUNT,
            X509EncodeFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;
    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_FUNC,
            X509_DECODE_FUNC_COUNT,
            X509DecodeFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;

    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
            CMC_ENCODE_EX_FUNC_COUNT,
            CmcEncodeExFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;
    if (!CryptInstallOIDFunctionAddress(
            hInst,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_EX_FUNC,
            CMC_DECODE_EX_FUNC_COUNT,
            CmcDecodeExFuncTable,
            0))                         // dwFlags
        goto InstallOidFuncError;

    fRet = TRUE;

CommonReturn:
    return fRet;

InstallOidFuncError:
    fRet = FALSE;
    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;

    if (hCrypt32Dll) {
        FreeLibrary(hCrypt32Dll);
        hCrypt32Dll = NULL;
    }

    pfnCryptInstallAsn1Module = NULL;
    pfnCryptUninstallAsn1Module = NULL;
    pfnCryptGetAsn1Encoder = NULL;
    pfnCryptGetAsn1Decoder = NULL;
    hAsn1Module = NULL;

    goto CommonReturn;

TRACE_ERROR(LoadCrypt32DllError)
TRACE_ERROR(I_CryptInstallAsn1ModuleProcAddressError)
TRACE_ERROR(I_CryptUninstallAsn1ModuleProcAddressError)
TRACE_ERROR(I_CryptGetAsn1EncoderProcAddressError)
TRACE_ERROR(I_CryptGetAsn1DecoderProcAddressError)
SET_ERROR_VAR(MSAsn1DllException, dwExceptionCode)
TRACE_ERROR(InstallAsn1ModuleError)
}

void MSAsnTerm()
{
    if (hAsn1Module) {
        pfnCryptUninstallAsn1Module(hAsn1Module);
        __try {
            XMSASN_Module_Cleanup();
        } __except(EXCEPTION_EXECUTE_HANDLER) {
        }

        hAsn1Module = NULL;
    }

    if (hCrypt32Dll) {
        FreeLibrary(hCrypt32Dll);
        hCrypt32Dll = NULL;
    }
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
static BOOL Asn1X509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pAsn1
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pAsn1Id;

    pAsn1->count = 0;
    pAsn1->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pAsn1Id = (UsageIdentifier *) CertAlloc(cId * sizeof(UsageIdentifier));
    if (pAsn1Id == NULL)
        return FALSE;

    pAsn1->count = cId;
    pAsn1->value = pAsn1Id;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pAsn1Id++) {
        if (!Asn1X509SetObjId(*ppszId, pAsn1Id))
            return FALSE;
    }

    return TRUE;
}

static void Asn1X509FreeCtlUsage(
        IN EnhancedKeyUsage *pAsn1)
{
    if (pAsn1->value) {
        CertFree(pAsn1->value);
        pAsn1->value = NULL;
    }
}

static void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (ASN1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage Asn1Info;

    if (!Asn1X509SetCtlUsage(pInfo, &Asn1Info)) {
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = Asn1InfoEncode(
            EnhancedKeyUsage_PDU,
            &Asn1Info,
            pbEncoded,
            pcbEncoded
            );
    Asn1X509FreeCtlUsage(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (ASN1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pAsn1Info = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!Asn1InfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    Asn1InfoFree(EnhancedKeyUsage_PDU, pAsn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Request Info Encode
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1RequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    fResult = Asn1InfoEncode(
	        RequestFlags_PDU,
	        pInfo,
            pbEncoded,
            pcbEncoded
            );
            
    return fResult;
}



//+-------------------------------------------------------------------------
//  Request Info Decode
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1RequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
	    OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    RequestFlags *  pAsn1 = NULL;

    if (NULL == pInfo || NULL == pcbInfo)
        goto ParamError;

    if( *pcbInfo < sizeof(RequestFlags) )
	goto LengthError;

    else if (!Asn1InfoDecodeAndAlloc(
	    RequestFlags_PDU,
        pbEncoded,
        cbEncoded,
	    (void **) &pAsn1) || NULL == pAsn1)
        goto ErrorReturn;

    memcpy(pInfo, pAsn1, sizeof(RequestFlags));
    fResult = TRUE;
    goto CommonReturn;

ParamError:
    SetLastError((DWORD)ERROR_INVALID_PARAMETER);
    fResult = FALSE;
    goto CommonReturn;
LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    if (NULL != pAsn1)
    {
        Asn1InfoFree(RequestFlags_PDU, pAsn1);
    }
    return fResult;
}

static BOOL WINAPI Asn1CSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;

    PkiAsn1SetBitString(&pCSPProvider->Signature, &CspProvider.signature.length, &CspProvider.signature.value);

    fResult = Asn1InfoEncode(
	        CSPProvider_PDU,
	        &CspProvider,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}

static BOOL WINAPI Asn1NameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;

    fResult = Asn1InfoEncode(
	        EnrollmentNameValuePair_PDU,
	        &NameValue,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}


//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeEx(
        IN int pdunum,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        GetEncoder(),
        pdunum,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an ASN1 formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void Asn1X509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pAsn1
        )
{
    pAsn1->value = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}
inline void Asn1X509GetOctetString(
        IN OCTETSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pAsn1
        )
{
    PkiAsn1SetAny(pInfo, pAsn1);
}
inline void Asn1X509GetAny(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pAsn1, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
        OUT ASN1uint32_t *pAsn1Count,
        OUT NOCOPYANY **ppAsn1Value
        )
{
    
    *pAsn1Count = 0;
    *ppAsn1Value = NULL;
    if (cValue > 0) {
        NOCOPYANY *pAsn1Value;

        pAsn1Value = (NOCOPYANY *) PkiZeroAlloc(cValue * sizeof(NOCOPYANY));
        if (pAsn1Value == NULL)
            return FALSE;
        *pAsn1Count = cValue;
        *ppAsn1Value = pAsn1Value;
        for ( ; cValue > 0; cValue--, pValue++, pAsn1Value++)
            Asn1X509SetAny(pValue, pAsn1Value);
    }
    return TRUE;
}

void Asn1X509FreeSeqOfAny(
        IN NOCOPYANY *pAsn1Value
        )
{
    if (pAsn1Value)
        PkiFree(pAsn1Value);
}

void Asn1X509GetSeqOfAny(
        IN unsigned int Asn1Count,
        IN NOCOPYANY *pAsn1Value,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(Asn1Count * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = Asn1Count;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; Asn1Count > 0; Asn1Count--, pAsn1Value++, pValue++)
        Asn1X509GetAny(pAsn1Value, dwFlags, pValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Extensions
//--------------------------------------------------------------------------
BOOL Asn1X509SetExtensions(
        IN DWORD cExtension,
        IN PCERT_EXTENSION pExtension,
        OUT Extensions *pAsn1
        )
{
    Extension *pAsn1Ext;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cExtension == 0)
        return TRUE;

    pAsn1Ext = (Extension *) PkiZeroAlloc(cExtension * sizeof(Extension));
    if (pAsn1Ext == NULL)
        return FALSE;
    pAsn1->value = pAsn1Ext;
    pAsn1->count = cExtension;

    for ( ; cExtension > 0; cExtension--, pExtension++, pAsn1Ext++) {
        if (!Asn1X509SetObjId(pExtension->pszObjId, &pAsn1Ext->extnId))
            return FALSE;
        if (pExtension->fCritical) {
            pAsn1Ext->critical = TRUE;
            pAsn1Ext->bit_mask |= critical_present;
        }
        Asn1X509SetOctetString(&pExtension->Value, &pAsn1Ext->extnValue);
    }
    return TRUE;
}

void Asn1X509FreeExtensions(
        IN Extensions *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetExtensions(
        IN Extensions *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcExtension,
        OUT PCERT_EXTENSION *ppExtension,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cExt;
    Extension *pAsn1Ext;
    PCERT_EXTENSION pGetExt;

    cExt = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cExt * sizeof(CERT_EXTENSION));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcExtension = cExt;
        pGetExt = (PCERT_EXTENSION) pbExtra;
        *ppExtension = pGetExt;
        pbExtra += lAlignExtra;
    } else
        pGetExt = NULL;

    pAsn1Ext = pAsn1->value;
    for ( ; cExt > 0; cExt--, pAsn1Ext++, pGetExt++) {
        Asn1X509GetObjId(&pAsn1Ext->extnId, dwFlags, &pGetExt->pszObjId,
                &pbExtra, &lRemainExtra);
        if (lRemainExtra >= 0) {
            pGetExt->fCritical = FALSE;
            if (pAsn1Ext->bit_mask & critical_present)
                pGetExt->fCritical = (BOOLEAN) pAsn1Ext->critical;
        }

        Asn1X509GetOctetString(&pAsn1Ext->extnValue, dwFlags, &pGetExt->Value,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (!Asn1X509SetObjId(pInfo->pszObjId, &pAsn1->type))
        return FALSE;

    return Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pAsn1->values.count,
            &pAsn1->values.value);
}

void Asn1X509FreeAttribute(
        IN OUT Attribute *pAsn1
        )
{
    Asn1X509FreeSeqOfAny(pAsn1->values.value);
}

void Asn1X509GetAttribute(
        IN Attribute *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetObjId(&pAsn1->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    Asn1X509GetSeqOfAny(pAsn1->values.count, pAsn1->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Attributes
//--------------------------------------------------------------------------
BOOL Asn1X509SetAttributes(
        IN DWORD cAttribute,
        IN PCRYPT_ATTRIBUTE pAttribute,
        OUT Attributes *pAsn1
        )
{
    Attribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cAttribute == 0)
        return TRUE;

    pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttribute * sizeof(Attribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cAttribute;

    for ( ; cAttribute > 0; cAttribute--, pAttribute++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttribute, pAsn1Attr))
            return FALSE;
    }
    return TRUE;
}

void Asn1X509FreeAttributes(
        IN Attributes *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cAttr = pAsn1->count;
        Attribute *pAsn1Attr = pAsn1->value;

        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetAttributes(
        IN Attributes *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcAttribute,
        OUT PCRYPT_ATTRIBUTE *ppAttribute,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cAttr;
    Attribute *pAsn1Attr;
    PCRYPT_ATTRIBUTE pGetAttr;

    cAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcAttribute = cAttr;
        pGetAttr = (PCRYPT_ATTRIBUTE) pbExtra;
        *ppAttribute = pGetAttr;
        pbExtra += lAlignExtra;
    } else
        pGetAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cAttr > 0; cAttr--, pAsn1Attr++, pGetAttr++) {
        Asn1X509GetAttribute(pAsn1Attr, dwFlags, pGetAttr,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Attributes
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedAttributes(
        IN DWORD cTaggedAttr,
        IN PCMC_TAGGED_ATTRIBUTE pTaggedAttr,
        OUT ControlSequence *pAsn1
        )
{
    TaggedAttribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedAttr == 0)
        return TRUE;

    pAsn1Attr = (TaggedAttribute *) PkiZeroAlloc(
        cTaggedAttr * sizeof(TaggedAttribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cTaggedAttr;

    for ( ; cTaggedAttr > 0; cTaggedAttr--, pTaggedAttr++, pAsn1Attr++) {
        pAsn1Attr->bodyPartID = pTaggedAttr->dwBodyPartID;
        if (!Asn1X509SetObjId(pTaggedAttr->Attribute.pszObjId,
                &pAsn1Attr->type))
            return FALSE;

        if (!Asn1X509SetSeqOfAny(
                pTaggedAttr->Attribute.cValue,
                pTaggedAttr->Attribute.rgValue,
                &pAsn1Attr->values.count,
                &pAsn1Attr->values.value))
            return FALSE;
    }
    return TRUE;
}

void Asn1CmcFreeTaggedAttributes(
        IN OUT ControlSequence *pAsn1
        )
{
    if (pAsn1->value) {
        TaggedAttribute *pAsn1Attr = pAsn1->value;
        DWORD cTaggedAttr = pAsn1->count;

        for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++) {
            Asn1X509FreeSeqOfAny(pAsn1Attr->values.value);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedAttributes(
        IN ControlSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedAttr,
        OUT PCMC_TAGGED_ATTRIBUTE *ppTaggedAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedAttr;
    TaggedAttribute *pAsn1Attr;
    PCMC_TAGGED_ATTRIBUTE pTaggedAttr;

    cTaggedAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedAttr * sizeof(CMC_TAGGED_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedAttr = cTaggedAttr;
        pTaggedAttr = (PCMC_TAGGED_ATTRIBUTE) pbExtra;
        *ppTaggedAttr = pTaggedAttr;
        pbExtra += lAlignExtra;
    } else
        pTaggedAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++, pTaggedAttr++) {
        if (lRemainExtra >= 0) {
            pTaggedAttr->dwBodyPartID = pAsn1Attr->bodyPartID;
        }
        Asn1X509GetObjId(&pAsn1Attr->type, dwFlags,
            &pTaggedAttr->Attribute.pszObjId, &pbExtra, &lRemainExtra);
        Asn1X509GetSeqOfAny(
            pAsn1Attr->values.count, pAsn1Attr->values.value, dwFlags,
            &pTaggedAttr->Attribute.cValue, &pTaggedAttr->Attribute.rgValue,
            &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Requests
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedRequests(
        IN DWORD cTaggedReq,
        IN PCMC_TAGGED_REQUEST pTaggedReq,
        OUT ReqSequence *pAsn1
        )
{
    TaggedRequest *pAsn1Req;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedReq == 0)
        return TRUE;

    pAsn1Req = (TaggedRequest *) PkiZeroAlloc(
        cTaggedReq * sizeof(TaggedRequest));
    if (pAsn1Req == NULL)
        return FALSE;
    pAsn1->value = pAsn1Req;
    pAsn1->count = cTaggedReq;

    for ( ; cTaggedReq > 0; cTaggedReq--, pTaggedReq++, pAsn1Req++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pTaggedReq->dwTaggedRequestChoice) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
        
        pAsn1Req->choice = tcr_chosen;
        ptcr = &pAsn1Req->u.tcr;
        pTaggedCertReq = pTaggedReq->pTaggedCertRequest;

        ptcr->bodyPartID = pTaggedCertReq->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCertReq->SignedCertRequest,
            &ptcr->certificationRequest);
    }
    return TRUE;
}

void Asn1CmcFreeTaggedRequests(
        IN OUT ReqSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1CmcGetTaggedRequests(
        IN ReqSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedReq,
        OUT PCMC_TAGGED_REQUEST *ppTaggedReq,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedReq;
    TaggedRequest *pAsn1Req;
    PCMC_TAGGED_REQUEST pTaggedReq;

    cTaggedReq = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedReq * sizeof(CMC_TAGGED_REQUEST));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedReq = cTaggedReq;
        pTaggedReq = (PCMC_TAGGED_REQUEST) pbExtra;
        *ppTaggedReq = pTaggedReq;
        pbExtra += lAlignExtra;
    } else
        pTaggedReq = NULL;

    pAsn1Req = pAsn1->value;
    for ( ; cTaggedReq > 0; cTaggedReq--, pAsn1Req++, pTaggedReq++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (tcr_chosen != pAsn1Req->choice) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            goto ErrorReturn;
        }

        ptcr = &pAsn1Req->u.tcr;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_TAGGED_CERT_REQUEST));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pTaggedReq->dwTaggedRequestChoice =
                CMC_TAGGED_CERT_REQUEST_CHOICE;

            pTaggedCertReq = (PCMC_TAGGED_CERT_REQUEST) pbExtra;
            pbExtra += lAlignExtra;

            pTaggedReq->pTaggedCertRequest = pTaggedCertReq;
            pTaggedCertReq->dwBodyPartID = ptcr->bodyPartID;
        } else
            pTaggedCertReq = NULL;

        Asn1X509GetAny(&ptcr->certificationRequest, dwFlags,
            &pTaggedCertReq->SignedCertRequest, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged ContentInfo
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedContentInfos(
        IN DWORD cTaggedCI,
        IN PCMC_TAGGED_CONTENT_INFO pTaggedCI,
        OUT CmsSequence *pAsn1
        )
{
    TaggedContentInfo *pAsn1CI;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedCI == 0)
        return TRUE;

    pAsn1CI = (TaggedContentInfo *) PkiZeroAlloc(
        cTaggedCI * sizeof(TaggedContentInfo));
    if (pAsn1CI == NULL)
        return FALSE;
    pAsn1->value = pAsn1CI;
    pAsn1->count = cTaggedCI;

    for ( ; cTaggedCI > 0; cTaggedCI--, pTaggedCI++, pAsn1CI++) {
        pAsn1CI->bodyPartID = pTaggedCI->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCI->EncodedContentInfo, &pAsn1CI->contentInfo);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedContentInfos(
        IN OUT CmsSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedContentInfos(
        IN CmsSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedCI,
        OUT PCMC_TAGGED_CONTENT_INFO *ppTaggedCI,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedCI;
    TaggedContentInfo *pAsn1CI;
    PCMC_TAGGED_CONTENT_INFO pTaggedCI;

    cTaggedCI = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedCI * sizeof(CMC_TAGGED_CONTENT_INFO));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedCI = cTaggedCI;
        pTaggedCI = (PCMC_TAGGED_CONTENT_INFO) pbExtra;
        *ppTaggedCI = pTaggedCI;
        pbExtra += lAlignExtra;
    } else
        pTaggedCI = NULL;

    pAsn1CI = pAsn1->value;
    for ( ; cTaggedCI > 0; cTaggedCI--, pAsn1CI++, pTaggedCI++) {
        if (lRemainExtra >= 0) {
            pTaggedCI->dwBodyPartID = pAsn1CI->bodyPartID;
        }

        Asn1X509GetAny(&pAsn1CI->contentInfo, dwFlags,
            &pTaggedCI->EncodedContentInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged OtherMsg
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedOtherMsgs(
        IN DWORD cTaggedOM,
        IN PCMC_TAGGED_OTHER_MSG pTaggedOM,
        OUT OtherMsgSequence *pAsn1
        )
{
    TaggedOtherMsg *pAsn1OM;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedOM == 0)
        return TRUE;

    pAsn1OM = (TaggedOtherMsg *) PkiZeroAlloc(
        cTaggedOM * sizeof(TaggedOtherMsg));
    if (pAsn1OM == NULL)
        return FALSE;
    pAsn1->value = pAsn1OM;
    pAsn1->count = cTaggedOM;

    for ( ; cTaggedOM > 0; cTaggedOM--, pTaggedOM++, pAsn1OM++) {
        pAsn1OM->bodyPartID = pTaggedOM->dwBodyPartID;

        if (!Asn1X509SetObjId(pTaggedOM->pszObjId,
                &pAsn1OM->otherMsgType))
            return FALSE;

        Asn1X509SetAny(&pTaggedOM->Value, &pAsn1OM->otherMsgValue);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedOtherMsgs(
        IN OUT OtherMsgSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedOtherMsgs(
        IN OtherMsgSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedOM,
        OUT PCMC_TAGGED_OTHER_MSG *ppTaggedOM,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedOM;
    TaggedOtherMsg *pAsn1OM;
    PCMC_TAGGED_OTHER_MSG pTaggedOM;

    cTaggedOM = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedOM * sizeof(CMC_TAGGED_OTHER_MSG));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedOM = cTaggedOM;
        pTaggedOM = (PCMC_TAGGED_OTHER_MSG) pbExtra;
        *ppTaggedOM = pTaggedOM;
        pbExtra += lAlignExtra;
    } else
        pTaggedOM = NULL;

    pAsn1OM = pAsn1->value;
    for ( ; cTaggedOM > 0; cTaggedOM--, pAsn1OM++, pTaggedOM++) {
        if (lRemainExtra >= 0) {
            pTaggedOM->dwBodyPartID = pAsn1OM->bodyPartID;
        }

        Asn1X509GetObjId(&pAsn1OM->otherMsgType, dwFlags,
            &pTaggedOM->pszObjId, &pbExtra, &lRemainExtra);

        Asn1X509GetAny(&pAsn1OM->otherMsgValue, dwFlags,
            &pTaggedOM->Value, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CMC Data Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcData Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedRequests(pInfo->cTaggedRequest,
            pInfo->rgTaggedRequest, &Asn1Info.reqSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcData_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedRequests(&Asn1Info.reqSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Data Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcData *pAsn1 = (CmcData *) pvAsn1Info;
    PCMC_DATA_INFO pInfo = (PCMC_DATA_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_DATA_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_DATA_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    if (!Asn1CmcGetTaggedRequests(&pAsn1->reqSequence,
            dwFlags,
            &pInfo->cTaggedRequest,
            &pInfo->rgTaggedRequest,
            &pbExtra,
            &lRemainExtra
            ))
        goto ErrorReturn;

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcData_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcDataDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Response Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcResponseBody Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcResponseBody_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Response Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcResponseBody *pAsn1 = (CmcResponseBody *) pvAsn1Info;
    PCMC_RESPONSE_INFO pInfo = (PCMC_RESPONSE_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_RESPONSE_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_RESPONSE_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_RESPONSE_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcResponseBody_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcResponseDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Status Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcStatusInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.cmcStatus = pInfo->dwStatus;
    if (pInfo->cBodyList) {
        Asn1Info.bodyList.count = pInfo->cBodyList;
        Asn1Info.bodyList.value = pInfo->rgdwBodyList;
    }

    if (pInfo->pwszStatusString && L'\0' != *pInfo->pwszStatusString) {
        Asn1Info.bit_mask |= statusString_present;
        Asn1Info.statusString.length = wcslen(pInfo->pwszStatusString);
        Asn1Info.statusString.value = pInfo->pwszStatusString;
    }

    if (CMC_OTHER_INFO_NO_CHOICE != pInfo->dwOtherInfoChoice) {
        Asn1Info.bit_mask |= otherInfo_present;

        switch (pInfo->dwOtherInfoChoice) {
            case CMC_OTHER_INFO_FAIL_CHOICE:
                Asn1Info.otherInfo.choice = failInfo_chosen;
                Asn1Info.otherInfo.u.failInfo = pInfo->dwFailInfo;
                break;
            case CMC_OTHER_INFO_PEND_CHOICE:
                Asn1Info.otherInfo.choice = pendInfo_chosen;
                Asn1X509SetOctetString(&pInfo->pPendInfo->PendToken,
                    &Asn1Info.otherInfo.u.pendInfo.pendToken);
                if (!PkiAsn1ToGeneralizedTime(
                        &pInfo->pPendInfo->PendTime,
                        &Asn1Info.otherInfo.u.pendInfo.pendTime))
                    goto GeneralizedTimeError;
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }


    fResult = Asn1InfoEncodeEx(
        CmcStatusInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOtherInfoChoiceError, E_INVALIDARG)
SET_ERROR(GeneralizedTimeError, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  CMC Status Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcStatusInfo *pAsn1 = (CmcStatusInfo *) pvAsn1Info;
    PCMC_STATUS_INFO pInfo = (PCMC_STATUS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_STATUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_STATUS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_STATUS_INFO);

        pInfo->dwStatus = pAsn1->cmcStatus;
    }

    if (pAsn1->bodyList.count > 0) {
        ASN1uint32_t count = pAsn1->bodyList.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwBodyList;

            value = pAsn1->bodyList.value;
            pdwBodyList = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cBodyList = count;
            pInfo->rgdwBodyList = pdwBodyList;

            for ( ; count > 0; count--, value++, pdwBodyList++)
                *pdwBodyList = *value;
        }
    }


    if (pAsn1->bit_mask & statusString_present) {
        ASN1uint32_t length = pAsn1->statusString.length;

        lAlignExtra = INFO_LEN_ALIGN((length + 1) * sizeof(WCHAR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(pbExtra, pAsn1->statusString.value, length * sizeof(WCHAR));
            memset(pbExtra + (length * sizeof(WCHAR)), 0, sizeof(WCHAR));

            pInfo->pwszStatusString = (LPWSTR) pbExtra;
            pbExtra += lAlignExtra;
        }
    }

    if (pAsn1->bit_mask & otherInfo_present) {
        switch (pAsn1->otherInfo.choice) {
            case failInfo_chosen:
                if (lRemainExtra >= 0) {
                    pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
                    pInfo->dwFailInfo = pAsn1->otherInfo.u.failInfo;
                }
                break;
            case pendInfo_chosen:
                {
                    PCMC_PEND_INFO pPendInfo;

                    lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_PEND_INFO));
                    lRemainExtra -= lAlignExtra;
                    if (lRemainExtra >= 0) {
                        pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
                        pPendInfo = (PCMC_PEND_INFO) pbExtra;
                        pInfo->pPendInfo = pPendInfo;
                        pbExtra += lAlignExtra;

                        if (!PkiAsn1FromGeneralizedTime(
                                &pAsn1->otherInfo.u.pendInfo.pendTime,
                                &pPendInfo->PendTime))
                            goto GeneralizedTimeDecodeError;
                    } else
                        pPendInfo = NULL;

                    Asn1X509GetOctetString(
                        &pAsn1->otherInfo.u.pendInfo.pendToken, dwFlags,
                        &pPendInfo->PendToken, &pbExtra, &lRemainExtra);
                }
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidOtherInfoChoiceError, CRYPT_E_BAD_ENCODE)
SET_ERROR(GeneralizedTimeDecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcStatusInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcStatusDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddExtensions Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
            &Asn1Info.extensions))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddExtensions_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeExtensions(&Asn1Info.extensions);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddExtensions *pAsn1 = (CmcAddExtensions *) pvAsn1Info;
    PCMC_ADD_EXTENSIONS_INFO pInfo = (PCMC_ADD_EXTENSIONS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_EXTENSIONS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_EXTENSIONS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_EXTENSIONS_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetExtensions(&pAsn1->extensions, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddExtensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Add Attributes Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddAttributes Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &Asn1Info.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddAttributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info.attributes);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Attributes Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddAttributes *pAsn1 = (CmcAddAttributes *) pvAsn1Info;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = (PCMC_ADD_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_ATTRIBUTES_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetAttributes(&pAsn1->attributes, dwFlags,
        &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certperf\certctr.h ===
//
//  certctr.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define CERT_OBJ                                    0
#define CERT_CHAIN_CNT                              2
#define CERT_CHAIN_ELEMENT_CNT                      4
#define CERT_CHAIN_ENGINE_CURRENT_CNT               6
#define CERT_CHAIN_ENGINE_TOTAL_CNT                 8
#define CERT_CHAIN_ENGINE_RESYNC_CNT                10
#define CERT_CHAIN_CERT_CACHE_CNT                   12
#define CERT_CHAIN_CTL_CACHE_CNT                    14
#define CERT_CHAIN_END_CERT_IN_CACHE_CNT            16
#define CERT_CHAIN_CACHE_END_CERT_CNT               18
#define CERT_CHAIN_REVOCATION_CNT                   20
#define CERT_CHAIN_REVOKED_CNT                      22
#define CERT_CHAIN_REVOCATION_OFFLINE_CNT           24
#define CERT_CHAIN_NO_REVOCATION_CHECK_CNT          26
#define CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT        28
#define CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT    30
#define CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT         32
#define CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT  34
#define CERT_CHAIN_URL_ISSUER_CNT                   36
#define CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT        38
#define CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT      40
#define CERT_CHANGE_NOTIFY_CNT                      42
#define CERT_CHANGE_NOTIFY_LM_GP_CNT                44
#define CERT_CHANGE_NOTIFY_CU_GP_CNT                46
#define CERT_CHANGE_NOTIFY_CU_MY_CNT                48
#define CERT_CHANGE_NOTIFY_REG_CNT                  50
#define CERT_STORE_CURRENT_CNT                      52
#define CERT_STORE_TOTAL_CNT                        54
#define CERT_STORE_REG_CURRENT_CNT                  56
#define CERT_STORE_REG_TOTAL_CNT                    58
#define CERT_REG_ELEMENT_READ_CNT                   60
#define CERT_REG_ELEMENT_WRITE_CNT                  62
#define CERT_REG_ELEMENT_DELETE_CNT                 64
#define CERT_CERT_ELEMENT_CURRENT_CNT               66
#define CERT_CERT_ELEMENT_TOTAL_CNT                 68
#define CERT_CRL_ELEMENT_CURRENT_CNT                70
#define CERT_CRL_ELEMENT_TOTAL_CNT                  72
#define CERT_CTL_ELEMENT_CURRENT_CNT                74
#define CERT_CTL_ELEMENT_TOTAL_CNT                  76
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certperf\certperf.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certperf.cpp
//
//  Contents:   Certificate Performance Counter Functions
//
//  Functions:
//              OpenCertPerformanceData
//              CollectCertPerformanceData
//              CloseCertPerformanceData
//              CertPerfDllMain
//
//              CertPerfGetCertificateChainBefore
//              CertPerfGetCertificateChainAfter
//
//  History:    04-May-99    philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))


#define CERT_PERF_REGPATH                   \
            L"SYSTEM\\CurrentControlSet\\Services\\crypt32\\Performance"

#define CERT_PERF_SHARED_MEMORY_FILE_NAME       \
            L"crypt32CertPerfFile"
#define CERT_PERF_SHARED_MEMORY_MUTEX_NAME      \
            L"crypt32CertPerfMutex"

#define CERT_PERF_TS_GLOBAL_PREFIX              \
            L"Global\\"
#define CERT_PERF_TS_SHARED_MEMORY_FILE_NAME    \
        CERT_PERF_TS_GLOBAL_PREFIX CERT_PERF_SHARED_MEMORY_FILE_NAME
#define CERT_PERF_TS_SHARED_MEMORY_MUTEX_NAME    \
        CERT_PERF_TS_GLOBAL_PREFIX CERT_PERF_SHARED_MEMORY_MUTEX_NAME



#define CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT   ((DWORD) 5000L)
#define CERT_PERF_MAX_PROCESS_NAME_LEN      32
#define CERT_PERF_MAX_PROCESS_CNT           50

#include <pshpack8.h>


// Note, a dwIndex >= CERT_PERF_MAX_PROCESS_CNT indicates an empty or
// the end of a list
typedef struct _CERT_PERF_PROCESS_DATA {
    DWORD           dwNextIndex;
    DWORD           dwPrevIndex;
    DWORD           dwProcessId;
    DWORD           dwReserved;
    WCHAR           wcszProcessName[CERT_PERF_MAX_PROCESS_NAME_LEN];
    CERT_PERF_PROCESS_COUNTERS Counters;
} CERT_PERF_PROCESS_DATA, *PCERT_PERF_PROCESS_DATA;

typedef struct _CERT_PERF_SHARED_MEMORY {
    DWORD                   dwProcessCnt;
    DWORD                   dwFirstInUseIndex;
    DWORD                   dwFirstFreeIndex;
    DWORD                   dwReserved;
    CERT_PERF_PROCESS_DATA  rgProcessData[CERT_PERF_MAX_PROCESS_CNT];
} CERT_PERF_SHARED_MEMORY, *PCERT_PERF_SHARED_MEMORY;


//  Certificate performance counters
typedef struct _CERT_PERF_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     ChainCnt;
    PERF_COUNTER_DEFINITION     ChainElementCnt;
    PERF_COUNTER_DEFINITION     ChainEngineCurrentCnt;
    PERF_COUNTER_DEFINITION     ChainEngineTotalCnt;
    PERF_COUNTER_DEFINITION     ChainEngineResyncCnt;
    PERF_COUNTER_DEFINITION     ChainCertCacheCnt;
    PERF_COUNTER_DEFINITION     ChainCtlCacheCnt;
    PERF_COUNTER_DEFINITION     ChainEndCertInCacheCnt;
    PERF_COUNTER_DEFINITION     ChainCacheEndCertCnt;
    PERF_COUNTER_DEFINITION     ChainRevocationCnt;
    PERF_COUNTER_DEFINITION     ChainRevokedCnt;
    PERF_COUNTER_DEFINITION     ChainRevocationOfflineCnt;
    PERF_COUNTER_DEFINITION     ChainNoRevocationCheckCnt;
    PERF_COUNTER_DEFINITION     ChainVerifyCertSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainCompareIssuerPublicKeyCnt;
    PERF_COUNTER_DEFINITION     ChainVerifyCtlSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainBeenVerifiedCtlSignatureCnt;
    PERF_COUNTER_DEFINITION     ChainUrlIssuerCnt;
    PERF_COUNTER_DEFINITION     ChainCacheOnlyUrlIssuerCnt;
    PERF_COUNTER_DEFINITION     ChainRequestedEngineResyncCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyLmGpCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCuGpCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyCuMyCnt;
    PERF_COUNTER_DEFINITION     ChangeNotifyRegCnt;
    PERF_COUNTER_DEFINITION     StoreCurrentCnt;
    PERF_COUNTER_DEFINITION     StoreTotalCnt;
    PERF_COUNTER_DEFINITION     StoreRegCurrentCnt;
    PERF_COUNTER_DEFINITION     StoreRegTotalCnt;
    PERF_COUNTER_DEFINITION     RegElementReadCnt;
    PERF_COUNTER_DEFINITION     RegElementWriteCnt;
    PERF_COUNTER_DEFINITION     RegElementDeleteCnt;
    PERF_COUNTER_DEFINITION     CertElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CertElementTotalCnt;
    PERF_COUNTER_DEFINITION     CrlElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CrlElementTotalCnt;
    PERF_COUNTER_DEFINITION     CtlElementCurrentCnt;
    PERF_COUNTER_DEFINITION     CtlElementTotalCnt;


    //--###  Add New Counters  ###--
} CERT_PERF_DATA_DEFINITION, *PCERT_PERF_DATA_DEFINITION;

typedef struct _CERT_PERF_COUNTERS {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       dwChainCnt;
    DWORD                       dwChainElementCnt;
    DWORD                       dwChainEngineCurrentCnt;
    DWORD                       dwChainEngineTotalCnt;
    DWORD                       dwChainEngineResyncCnt;
    DWORD                       dwChainCertCacheCnt;
    DWORD                       dwChainCtlCacheCnt;
    DWORD                       dwChainEndCertInCacheCnt;
    DWORD                       dwChainCacheEndCertCnt;
    DWORD                       dwChainRevocationCnt;
    DWORD                       dwChainRevokedCnt;
    DWORD                       dwChainRevocationOfflineCnt;
    DWORD                       dwChainNoRevocationCheckCnt;
    DWORD                       dwChainVerifyCertSignatureCnt;
    DWORD                       dwChainCompareIssuerPublicKeyCnt;
    DWORD                       dwChainVerifyCtlSignatureCnt;
    DWORD                       dwChainBeenVerifiedCtlSignatureCnt;
    DWORD                       dwChainUrlIssuerCnt;
    DWORD                       dwChainCacheOnlyUrlIssuerCnt;
    DWORD                       dwChainRequestedEngineResyncCnt;
    DWORD                       dwChangeNotifyCnt;
    DWORD                       dwChangeNotifyLmGpCnt;
    DWORD                       dwChangeNotifyCuGpCnt;
    DWORD                       dwChangeNotifyCuMyCnt;
    DWORD                       dwChangeNotifyRegCnt;
    DWORD                       dwStoreCurrentCnt;
    DWORD                       dwStoreTotalCnt;
    DWORD                       dwStoreRegCurrentCnt;
    DWORD                       dwStoreRegTotalCnt;
    DWORD                       dwRegElementReadCnt;
    DWORD                       dwRegElementWriteCnt;
    DWORD                       dwRegElementDeleteCnt;
    DWORD                       dwCertElementCurrentCnt;
    DWORD                       dwCertElementTotalCnt;
    DWORD                       dwCrlElementCurrentCnt;
    DWORD                       dwCrlElementTotalCnt;
    DWORD                       dwCtlElementCurrentCnt;
    DWORD                       dwCtlElementTotalCnt;

    //--###  Add New Counters  ###--
} CERT_PERF_COUNTERS, *PCERT_PERF_COUNTERS;

#include <poppack.h>


//+----------------------------------------------------------------------
// The following are set at DLL_PROCESS_ATTACH if certperf.reg has been
// regedit'ed and certperf.ini has been lodctr'ed. Otherwise, they remain
// NULL.
//-----------------------------------------------------------------------
HANDLE hCertPerfSharedMemoryMutex;
HANDLE hCertPerfSharedMemoryFile;
PCERT_PERF_SHARED_MEMORY pCertPerfSharedMemory;
PCERT_PERF_PROCESS_DATA pCertPerfProcessData;
PCERT_PERF_PROCESS_COUNTERS pCertPerfProcessCounters;

// Always initialized
CRITICAL_SECTION CertPerfProcessCriticalSection;

#define IMPURE  0

CERT_PERF_DATA_DEFINITION CertPerfDataDefinition = {
    // PERF_OBJECT_TYPE ObjectType
    {
        IMPURE,             // TotalByteLength
        sizeof(CERT_PERF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        IMPURE,             // ObjectNameTitleIndex: dwFirstCounter + CERT_OBJ
        0,
        IMPURE,             // ObjectHelpTitleIndex: dwFirstHelp + CERT_OBJ
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(CERT_PERF_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE))/
            sizeof(PERF_COUNTER_DEFINITION),
        0,  // ChainCnt is the default counter
        IMPURE,             // NumInstances
        0,  // unicode instance names
        {0,0},
        {0,0}
    },

    // 0 - PERF_COUNTER_DEFINITION ChainCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCnt),
    },

    // 1 - PERF_COUNTER_DEFINITION ChainElementCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainElementCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainElementCnt),
    },

    // 2 - PERF_COUNTER_DEFINITION ChainEngineCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineCurrentCnt),
    },

    // 3 - PERF_COUNTER_DEFINITION ChainEngineTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineTotalCnt),
    },

    // 4 - PERF_COUNTER_DEFINITION ChainEngineResyncCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEngineResyncCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEngineResyncCnt),
    },

    // 5 - PERF_COUNTER_DEFINITION ChainCertCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCertCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCertCacheCnt),
    },

    // 6 - PERF_COUNTER_DEFINITION ChainCtlCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCtlCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCtlCacheCnt),
    },

    // 7 - PERF_COUNTER_DEFINITION ChainEndCertInCacheCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainEndCertInCacheCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainEndCertInCacheCnt),
    },

    // 8 - PERF_COUNTER_DEFINITION ChainCacheEndCertCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCacheEndCertCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCacheEndCertCnt),
    },

    // 9 - PERF_COUNTER_DEFINITION ChainRevocationCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevocationCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevocationCnt),
    },

    // 10 - PERF_COUNTER_DEFINITION ChainRevokedCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevokedCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevokedCnt),
    },

    // 11 - PERF_COUNTER_DEFINITION ChainRevocationOfflineCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRevocationOfflineCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRevocationOfflineCnt),
    },

    // 12 - PERF_COUNTER_DEFINITION ChainNoRevocationCheckCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainNoRevocationCheckCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainNoRevocationCheckCnt),
    },

    // 13 - PERF_COUNTER_DEFINITION ChainVerifyCertSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainVerifyCertSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainVerifyCertSignatureCnt),
    },

    // 14 - PERF_COUNTER_DEFINITION ChainCompareIssuerPublicKeyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCompareIssuerPublicKeyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCompareIssuerPublicKeyCnt),
    },

    // 15 - PERF_COUNTER_DEFINITION ChainVerifyCtlSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainVerifyCtlSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainVerifyCtlSignatureCnt),
    },

    // 16 - PERF_COUNTER_DEFINITION ChainBeenVerifiedCtlSignatureCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainBeenVerifiedCtlSignatureCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainBeenVerifiedCtlSignatureCnt),
    },

    // 17 - PERF_COUNTER_DEFINITION ChainUrlIssuerCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainUrlIssuerCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainUrlIssuerCnt),
    },

    // 18 - PERF_COUNTER_DEFINITION ChainCacheOnlyUrlIssuerCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainCacheOnlyUrlIssuerCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainCacheOnlyUrlIssuerCnt),
    },

    // 19 - PERF_COUNTER_DEFINITION ChainRequestedEngineResyncCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChainRequestedEngineResyncCnt),
        offsetof(CERT_PERF_COUNTERS, dwChainRequestedEngineResyncCnt),
    },

    // 20 - PERF_COUNTER_DEFINITION ChangeNotifyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCnt),
    },

    // 21 - PERF_COUNTER_DEFINITION ChangeNotifyLmGpCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyLmGpCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyLmGpCnt),
    },

    // 22 - PERF_COUNTER_DEFINITION ChangeNotifyCuGpCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCuGpCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCuGpCnt),
    },

    // 23 - PERF_COUNTER_DEFINITION ChangeNotifyCuMyCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyCuMyCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyCuMyCnt),
    },

    // 24 - PERF_COUNTER_DEFINITION ChangeNotifyRegCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwChangeNotifyRegCnt),
        offsetof(CERT_PERF_COUNTERS, dwChangeNotifyRegCnt),
    },

    // 25 - PERF_COUNTER_DEFINITION StoreCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreCurrentCnt),
    },

    // 26 - PERF_COUNTER_DEFINITION StoreTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreTotalCnt),
    },

    // 27 - PERF_COUNTER_DEFINITION StoreRegCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreRegCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreRegCurrentCnt),
    },

    // 28 - PERF_COUNTER_DEFINITION StoreRegTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwStoreRegTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwStoreRegTotalCnt),
    },

    // 29 - PERF_COUNTER_DEFINITION RegElementReadCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementReadCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementReadCnt),
    },

    // 30 - PERF_COUNTER_DEFINITION RegElementWriteCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementWriteCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementWriteCnt),
    },

    // 31 - PERF_COUNTER_DEFINITION RegElementDeleteCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwRegElementDeleteCnt),
        offsetof(CERT_PERF_COUNTERS, dwRegElementDeleteCnt),
    },

    // 32 - PERF_COUNTER_DEFINITION CertElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCertElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCertElementCurrentCnt),
    },

    // 33 - PERF_COUNTER_DEFINITION CertElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCertElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCertElementTotalCnt),
    },

    // 34 - PERF_COUNTER_DEFINITION CrlElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCrlElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCrlElementCurrentCnt),
    },

    // 35 - PERF_COUNTER_DEFINITION CrlElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCrlElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCrlElementTotalCnt),
    },

    // 36 - PERF_COUNTER_DEFINITION CtlElementCurrentCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCtlElementCurrentCnt),
        offsetof(CERT_PERF_COUNTERS, dwCtlElementCurrentCnt),
    },

    // 37 - PERF_COUNTER_DEFINITION CtlElementTotalCnt
    {
        sizeof(PERF_COUNTER_DEFINITION),
        IMPURE,     // CounterNameTitleIndex: dwFirstCounter +
        0,
        IMPURE,     // CounterHelpTitleIndex: dwFirstHelp +
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(((PCERT_PERF_COUNTERS) 0)->dwCtlElementTotalCnt),
        offsetof(CERT_PERF_COUNTERS, dwCtlElementTotalCnt),
    },


    //--###  Add New Counters  ###--
};


STATIC
BOOL
I_CertPerfSetNameAndHelpIndices()
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD dwType;
    DWORD cbValue;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    if (!FIsWinNT())
        return FALSE;

    if (ERROR_SUCCESS != RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            CERT_PERF_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey))
        goto ErrorReturn;

    cbValue = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueExW(
            hKey,
            L"First Counter",
            NULL,       // pdwReserved
            &dwType,
            (PBYTE) &dwFirstCounter,
            &cbValue))
        goto ErrorReturn;
    cbValue = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueExW(
            hKey,
            L"First Help",
            NULL,       // pdwReserved
            &dwType,
            (PBYTE) &dwFirstHelp,
            &cbValue))
        goto ErrorReturn;


    // Update CertPerfDataDefinitions' counter and help name indices
    CertPerfDataDefinition.ObjectType.ObjectNameTitleIndex =
        dwFirstCounter + CERT_OBJ;
    CertPerfDataDefinition.ObjectType.ObjectHelpTitleIndex =
        dwFirstHelp + CERT_OBJ;

    CertPerfDataDefinition.ChainCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CNT;
    CertPerfDataDefinition.ChainCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CNT;

    CertPerfDataDefinition.ChainElementCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ELEMENT_CNT;
    CertPerfDataDefinition.ChainElementCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ELEMENT_CNT;

    CertPerfDataDefinition.ChainEngineCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_CURRENT_CNT;
    CertPerfDataDefinition.ChainEngineCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_CURRENT_CNT;

    CertPerfDataDefinition.ChainEngineTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_TOTAL_CNT;
    CertPerfDataDefinition.ChainEngineTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_TOTAL_CNT;

    CertPerfDataDefinition.ChainEngineResyncCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_ENGINE_RESYNC_CNT;
    CertPerfDataDefinition.ChainEngineResyncCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_ENGINE_RESYNC_CNT;

    CertPerfDataDefinition.ChainCertCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CERT_CACHE_CNT;
    CertPerfDataDefinition.ChainCertCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CERT_CACHE_CNT;

    CertPerfDataDefinition.ChainCtlCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CTL_CACHE_CNT;
    CertPerfDataDefinition.ChainCtlCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CTL_CACHE_CNT;

    CertPerfDataDefinition.ChainEndCertInCacheCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_END_CERT_IN_CACHE_CNT;
    CertPerfDataDefinition.ChainEndCertInCacheCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_END_CERT_IN_CACHE_CNT;

    CertPerfDataDefinition.ChainCacheEndCertCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CACHE_END_CERT_CNT;
    CertPerfDataDefinition.ChainCacheEndCertCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CACHE_END_CERT_CNT;

    CertPerfDataDefinition.ChainRevocationCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOCATION_CNT;
    CertPerfDataDefinition.ChainRevocationCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOCATION_CNT;

    CertPerfDataDefinition.ChainRevokedCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOKED_CNT;
    CertPerfDataDefinition.ChainRevokedCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOKED_CNT;

    CertPerfDataDefinition.ChainRevocationOfflineCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REVOCATION_OFFLINE_CNT;
    CertPerfDataDefinition.ChainRevocationOfflineCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REVOCATION_OFFLINE_CNT;

    CertPerfDataDefinition.ChainNoRevocationCheckCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_NO_REVOCATION_CHECK_CNT;
    CertPerfDataDefinition.ChainNoRevocationCheckCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_NO_REVOCATION_CHECK_CNT;

    CertPerfDataDefinition.ChainVerifyCertSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainVerifyCertSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_VERIFY_CERT_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainCompareIssuerPublicKeyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT;
    CertPerfDataDefinition.ChainCompareIssuerPublicKeyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_COMPARE_ISSUER_PUBLIC_KEY_CNT;

    CertPerfDataDefinition.ChainVerifyCtlSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainVerifyCtlSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_VERIFY_CTL_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainBeenVerifiedCtlSignatureCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT;
    CertPerfDataDefinition.ChainBeenVerifiedCtlSignatureCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_BEEN_VERIFIED_CTL_SIGNATURE_CNT;

    CertPerfDataDefinition.ChainUrlIssuerCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_URL_ISSUER_CNT;
    CertPerfDataDefinition.ChainUrlIssuerCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_URL_ISSUER_CNT;

    CertPerfDataDefinition.ChainCacheOnlyUrlIssuerCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT;
    CertPerfDataDefinition.ChainCacheOnlyUrlIssuerCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_CACHE_ONLY_URL_ISSUER_CNT;

    CertPerfDataDefinition.ChainRequestedEngineResyncCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT;
    CertPerfDataDefinition.ChainRequestedEngineResyncCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHAIN_REQUESTED_ENGINE_RESYNC_CNT;

    CertPerfDataDefinition.ChangeNotifyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CNT;
    CertPerfDataDefinition.ChangeNotifyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CNT;

    CertPerfDataDefinition.ChangeNotifyLmGpCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_LM_GP_CNT;
    CertPerfDataDefinition.ChangeNotifyLmGpCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_LM_GP_CNT;

    CertPerfDataDefinition.ChangeNotifyCuGpCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CU_GP_CNT;
    CertPerfDataDefinition.ChangeNotifyCuGpCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CU_GP_CNT;

    CertPerfDataDefinition.ChangeNotifyCuMyCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_CU_MY_CNT;
    CertPerfDataDefinition.ChangeNotifyCuMyCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_CU_MY_CNT;

    CertPerfDataDefinition.ChangeNotifyRegCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CHANGE_NOTIFY_REG_CNT;
    CertPerfDataDefinition.ChangeNotifyRegCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CHANGE_NOTIFY_REG_CNT;

    CertPerfDataDefinition.StoreCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_CURRENT_CNT;
    CertPerfDataDefinition.StoreCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_CURRENT_CNT;

    CertPerfDataDefinition.StoreTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_TOTAL_CNT;
    CertPerfDataDefinition.StoreTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_TOTAL_CNT;

    CertPerfDataDefinition.StoreRegCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_REG_CURRENT_CNT;
    CertPerfDataDefinition.StoreRegCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_REG_CURRENT_CNT;

    CertPerfDataDefinition.StoreRegTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_STORE_REG_TOTAL_CNT;
    CertPerfDataDefinition.StoreRegTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_STORE_REG_TOTAL_CNT;

    CertPerfDataDefinition.RegElementReadCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_READ_CNT;
    CertPerfDataDefinition.RegElementReadCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_READ_CNT;

    CertPerfDataDefinition.RegElementWriteCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_WRITE_CNT;
    CertPerfDataDefinition.RegElementWriteCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_WRITE_CNT;

    CertPerfDataDefinition.RegElementDeleteCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_REG_ELEMENT_DELETE_CNT;
    CertPerfDataDefinition.RegElementDeleteCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_REG_ELEMENT_DELETE_CNT;

    CertPerfDataDefinition.CertElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CERT_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CertElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CERT_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CertElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CERT_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CertElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CERT_ELEMENT_TOTAL_CNT;

    CertPerfDataDefinition.CrlElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CRL_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CrlElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CRL_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CrlElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CRL_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CrlElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CRL_ELEMENT_TOTAL_CNT;

    CertPerfDataDefinition.CtlElementCurrentCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CTL_ELEMENT_CURRENT_CNT;
    CertPerfDataDefinition.CtlElementCurrentCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CTL_ELEMENT_CURRENT_CNT;

    CertPerfDataDefinition.CtlElementTotalCnt.CounterNameTitleIndex =
        dwFirstCounter + CERT_CTL_ELEMENT_TOTAL_CNT;
    CertPerfDataDefinition.CtlElementTotalCnt.CounterHelpTitleIndex =
        dwFirstHelp + CERT_CTL_ELEMENT_TOTAL_CNT;

    //--###  Add New Counters  ###--

    fResult = TRUE;

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

STATIC
void
I_CertPerfGetProcessName(
    OUT WCHAR wcszProcessName[CERT_PERF_MAX_PROCESS_NAME_LEN]
    )
{
    WCHAR wszModule[MAX_PATH + 1];
    LPWSTR pwsz;
    LPWSTR pwszSlash;
    LPWSTR pwszPeriod;
    WCHAR wc;
    DWORD cchProcessName;

    wszModule[MAX_PATH] = L'\0';
    if (0 == GetModuleFileNameW(NULL, wszModule, MAX_PATH))
        goto GetModuleFileNameError;

    // Go from beginning to end and find last backslash and
    // last period in name
    pwszPeriod = NULL;
    pwszSlash = NULL;
    for (pwsz = wszModule; L'\0' != (wc = *pwsz); pwsz++) {
        if (L'\\' == wc)
            pwszSlash = pwsz;
        else if (L'.' == wc)
            pwszPeriod = pwsz;
    }

    // If present, the process name is between the last \ and the last period.
    // Otherwise, between beginning and/or end of entire module name
    if (pwszSlash)
        pwszSlash++;
    else
        pwszSlash = wszModule;

    if (NULL == pwszPeriod)
        pwszPeriod = pwsz;

    if (pwszSlash >= pwszPeriod)
        goto InvalidModuleName;
    cchProcessName = (DWORD) (pwszPeriod - pwszSlash);
    if (cchProcessName > (CERT_PERF_MAX_PROCESS_NAME_LEN - 1))
        cchProcessName = CERT_PERF_MAX_PROCESS_NAME_LEN - 1;

    memcpy(wcszProcessName, pwszSlash, cchProcessName * sizeof(WCHAR));
    wcszProcessName[cchProcessName] = L'\0';

CommonReturn:
    return;
ErrorReturn:
    wcscpy(wcszProcessName, L"???");
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(InvalidModuleName)
}

// The returnd ACL must be freed via PkiFree()
STATIC
PACL
CreateEveryoneAcl(
    IN DWORD dwAccessMask
    )
{
    DWORD dwLastErr = 0;
    PACL pEveryoneAcl = NULL;
    PSID psidEveryone = NULL;
    DWORD dwAclSize;

    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            ))
        goto AllocateAndInitializeSidError;

    //
    // compute size of ACL
    //
    dwAclSize =
        sizeof(ACL) +
        ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidEveryone);

    //
    // allocate storage for Acl
    //
    if (NULL == (pEveryoneAcl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pEveryoneAcl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pEveryoneAcl,
            ACL_REVISION,
            dwAccessMask,
            psidEveryone
            ))
        goto AddAceError;

CommonReturn:
    if (psidEveryone)
        FreeSid(psidEveryone);
    if (dwLastErr)
        SetLastError(dwLastErr);

    return pEveryoneAcl;

ErrorReturn:
    dwLastErr = GetLastError();
    if (pEveryoneAcl) {
        PkiFree(pEveryoneAcl);
        pEveryoneAcl = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(AllocateAndInitializeSidError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
}

STATIC
BOOL
InitializeSecurityDescriptorAndAttributes(
    IN PACL pAcl,
    OUT SECURITY_DESCRIPTOR *psd,
    OUT SECURITY_ATTRIBUTES *psa
    )
{
    BOOL fResult;

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;
    if (!SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE))
        goto SetSecurityDescriptorDaclError;

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
}

STATIC
HANDLE
CreateMutexWithSynchronizeAccess(
    IN LPWSTR pwszMutexName
    )
{
    HANDLE hMutex = NULL;
    PACL pEveryoneAcl = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    DWORD i;

    if (NULL == (pEveryoneAcl = CreateEveryoneAcl(SYNCHRONIZE)))
        goto CreateEveryoneAclError;
    if (!InitializeSecurityDescriptorAndAttributes(pEveryoneAcl, &sd, &sa))
        goto InitializeSecurityDescriptorAndAttributesError;

    // Retry a couple of times. There is a small window between the
    // CreateMutex and OpenMutex where the mutex is deleted.
    for (i = 0; i < 5; i++) {
        hMutex = CreateMutexU(
            &sa,
            FALSE,      // fInitialOwner
            pwszMutexName
            );
        if (NULL != hMutex)
            goto CommonReturn;

        hMutex = OpenMutexU(
            SYNCHRONIZE,
            FALSE,      // bInheritHandle
            pwszMutexName
            );
        if (NULL != hMutex) {
            SetLastError(ERROR_ALREADY_EXISTS);
            goto CommonReturn;
        }

        if (ERROR_FILE_NOT_FOUND != GetLastError())
            break;
    }

    assert(NULL == hMutex);
    goto OpenMutexError;

CommonReturn:
    if (pEveryoneAcl)
        PkiFree(pEveryoneAcl);

    return hMutex;

ErrorReturn:
    assert(NULL == hMutex);
    goto CommonReturn;

TRACE_ERROR(CreateEveryoneAclError)
TRACE_ERROR(InitializeSecurityDescriptorAndAttributesError)
TRACE_ERROR(OpenMutexError)
}

STATIC
HANDLE
CreateFileMappingWithWriteAccess(
    IN DWORD dwMaximumSizeLow,
    IN LPWSTR pwszFileName
    )
{
    HANDLE hFile = NULL;
    PACL pEveryoneAcl = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    DWORD i;

    if (NULL == (pEveryoneAcl = CreateEveryoneAcl(FILE_MAP_WRITE)))
        goto CreateEveryoneAclError;
    if (!InitializeSecurityDescriptorAndAttributes(pEveryoneAcl, &sd, &sa))
        goto InitializeSecurityDescriptorAndAttributesError;

    // Retry a couple of times. There is a small window between the
    // CreateFileMapping and OpenFileMapping where the file is closed.
    for (i = 0; i < 5; i++) {
        hFile = CreateFileMappingW(
            INVALID_HANDLE_VALUE,
            &sa,
            PAGE_READWRITE,
            0,                  // dwMaximumSizeHigh
            dwMaximumSizeLow,
            pwszFileName
            );

        if (NULL != hFile)
            goto CommonReturn;

        hFile = OpenFileMappingW(
            FILE_MAP_WRITE,
            FALSE,      // bInheritHandle
            pwszFileName
            );
        if (NULL != hFile) {
            SetLastError(ERROR_ALREADY_EXISTS);
            goto CommonReturn;
        }

        if (ERROR_FILE_NOT_FOUND != GetLastError())
            break;
    }

    assert(NULL == hFile);
    goto OpenFileError;

CommonReturn:
    if (pEveryoneAcl)
        PkiFree(pEveryoneAcl);

    return hFile;

ErrorReturn:
    assert(NULL == hFile);
    goto CommonReturn;

TRACE_ERROR(CreateEveryoneAclError)
TRACE_ERROR(InitializeSecurityDescriptorAndAttributesError)
TRACE_ERROR(OpenFileError)
}

STATIC
void
I_CertPerfGetSharedMemory()
{
    DWORD dwFileMappingStatus;
    BOOL fReleaseMutex = FALSE;
    DWORD dwIndex;
    DWORD dwNextIndex;
    BOOL fTerminalServerGlobalName;

    if (!I_CertPerfSetNameAndHelpIndices())
        return;

    // First try with W2K Terminal Server "Global\" prefix
    if (NULL == (hCertPerfSharedMemoryMutex = CreateMutexWithSynchronizeAccess(
            CERT_PERF_TS_SHARED_MEMORY_MUTEX_NAME
            ))) {
        if (NULL == (hCertPerfSharedMemoryMutex =
                CreateMutexWithSynchronizeAccess(
                    CERT_PERF_SHARED_MEMORY_MUTEX_NAME
                    )))
            goto CreateMutexError;
        else
            fTerminalServerGlobalName = FALSE;
    } else
        fTerminalServerGlobalName = TRUE;
    if (WAIT_OBJECT_0 != WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            ))
        goto WaitForMutexError;
    else
        fReleaseMutex = TRUE;

    if (NULL == (hCertPerfSharedMemoryFile = CreateFileMappingWithWriteAccess(
            sizeof(CERT_PERF_SHARED_MEMORY),
            fTerminalServerGlobalName ?
                CERT_PERF_TS_SHARED_MEMORY_FILE_NAME :
                CERT_PERF_SHARED_MEMORY_FILE_NAME
            )))
        goto CreateFileMappingError;
    dwFileMappingStatus = GetLastError();

    if (NULL == (pCertPerfSharedMemory =
           (PCERT_PERF_SHARED_MEMORY) MapViewOfFile(
                hCertPerfSharedMemoryFile,
                FILE_MAP_WRITE,
                0,                  // dwOffsetHigh
                0,                  // dwOffsetLow
                sizeof(CERT_PERF_SHARED_MEMORY)
                )))
        goto MapViewOfFileError;

    if (ERROR_ALREADY_EXISTS != dwFileMappingStatus) {
        DWORD i;

        assert(ERROR_SUCCESS == dwFileMappingStatus);

        // Need to initialize the shared memory
        memset(pCertPerfSharedMemory, 0, sizeof(CERT_PERF_SHARED_MEMORY));

        // Create linked list of process free elements.
        //
        // Only need forward indices for the free list
        for (i = 0; i < CERT_PERF_MAX_PROCESS_CNT; i++) {
            // An index >= CERT_PERF_MAX_PROCESS_CNT indicates end of list
            pCertPerfSharedMemory->rgProcessData[i].dwNextIndex = i + 1;

        }
        pCertPerfSharedMemory->dwFirstFreeIndex = 0;

        // An index >= CERT_PERF_MAX_PROCESS_CNT indicates an empty list
        pCertPerfSharedMemory->dwFirstInUseIndex = CERT_PERF_MAX_PROCESS_CNT;
    }

    if (CERT_PERF_MAX_PROCESS_CNT <=
            (dwIndex = pCertPerfSharedMemory->dwFirstFreeIndex))
        goto OutOfSharedMemoryProcessData;
    pCertPerfProcessData = &pCertPerfSharedMemory->rgProcessData[dwIndex];

    // Remove process data element from the free list
    pCertPerfSharedMemory->dwFirstFreeIndex =
        pCertPerfProcessData->dwNextIndex;

    // Add process data element to the in use list
    dwNextIndex = pCertPerfSharedMemory->dwFirstInUseIndex;
    if (CERT_PERF_MAX_PROCESS_CNT > dwNextIndex)
        pCertPerfSharedMemory->rgProcessData[dwNextIndex].dwPrevIndex =
            dwIndex;
    pCertPerfProcessData->dwNextIndex = dwNextIndex;
    pCertPerfProcessData->dwPrevIndex = CERT_PERF_MAX_PROCESS_CNT;
    pCertPerfSharedMemory->dwFirstInUseIndex = dwIndex;
    pCertPerfSharedMemory->dwProcessCnt++;

    pCertPerfProcessData->dwProcessId = GetCurrentProcessId();
    I_CertPerfGetProcessName(pCertPerfProcessData->wcszProcessName);
    memset(&pCertPerfProcessData->Counters, 0,
        sizeof(pCertPerfProcessData->Counters));

    ReleaseMutex(hCertPerfSharedMemoryMutex);

    pCertPerfProcessCounters = &pCertPerfProcessData->Counters;

CommonReturn:
    return;

ErrorReturn:
    assert(NULL == pCertPerfProcessData);

    if (pCertPerfSharedMemory) {
        UnmapViewOfFile(pCertPerfSharedMemory);
        pCertPerfSharedMemory = NULL;
    }

    if (hCertPerfSharedMemoryFile) {
        CloseHandle(hCertPerfSharedMemoryFile);
        hCertPerfSharedMemoryFile = NULL;
    }

    if (hCertPerfSharedMemoryMutex) {
        if (fReleaseMutex)
            ReleaseMutex(hCertPerfSharedMemoryMutex);

        CloseHandle(hCertPerfSharedMemoryMutex);
        hCertPerfSharedMemoryMutex = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(CreateMutexError)
TRACE_ERROR(WaitForMutexError)
TRACE_ERROR(CreateFileMappingError)
TRACE_ERROR(MapViewOfFileError)
TRACE_ERROR(OutOfSharedMemoryProcessData)
}


STATIC
void
I_CertPerfFreeSharedMemory()
{
    if (NULL == pCertPerfProcessData)
        return;

    pCertPerfProcessData->dwProcessId = 0;
    if (WAIT_OBJECT_0 == WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            )) {
        DWORD dwIndex;
        DWORD dwPrevIndex;
        DWORD dwNextIndex;

        // Remove process data element from the in use list
        dwIndex = (DWORD)(pCertPerfProcessData -
            pCertPerfSharedMemory->rgProcessData);
        assert(CERT_PERF_MAX_PROCESS_CNT > dwIndex);

        dwPrevIndex = pCertPerfProcessData->dwPrevIndex;
        dwNextIndex = pCertPerfProcessData->dwNextIndex;

        if (CERT_PERF_MAX_PROCESS_CNT > dwNextIndex)
            pCertPerfSharedMemory->rgProcessData[dwNextIndex].dwPrevIndex =
                dwPrevIndex;
        if (CERT_PERF_MAX_PROCESS_CNT > dwPrevIndex)
            pCertPerfSharedMemory->rgProcessData[dwPrevIndex].dwNextIndex =
                dwNextIndex;
        else
            pCertPerfSharedMemory->dwFirstInUseIndex = dwNextIndex;


        if (pCertPerfSharedMemory->dwProcessCnt)
            pCertPerfSharedMemory->dwProcessCnt--;

        // Add to the free list
        pCertPerfProcessData->dwNextIndex =
            pCertPerfSharedMemory->dwFirstFreeIndex;
        pCertPerfSharedMemory->dwFirstFreeIndex = dwIndex;

        ReleaseMutex(hCertPerfSharedMemoryMutex);
    }

    assert(pCertPerfSharedMemory);
    UnmapViewOfFile(pCertPerfSharedMemory);
    pCertPerfSharedMemory = NULL;

    assert(hCertPerfSharedMemoryFile);
    CloseHandle(hCertPerfSharedMemoryFile);
    hCertPerfSharedMemoryFile = NULL;

    assert(hCertPerfSharedMemoryMutex);
    CloseHandle(hCertPerfSharedMemoryMutex);
    hCertPerfSharedMemoryMutex = NULL;

    pCertPerfProcessCounters = NULL;
    pCertPerfProcessData = NULL;
}



BOOL
WINAPI
CertPerfDllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved
    )
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = Pki_InitializeCriticalSection(&CertPerfProcessCriticalSection);
        if (fRet)
            I_CertPerfGetSharedMemory();
        break;
    case DLL_PROCESS_DETACH:
        I_CertPerfFreeSharedMemory();
        DeleteCriticalSection(&CertPerfProcessCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}


//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenCertPerformanceData;
PM_COLLECT_PROC CollectCertPerformanceData;
PM_CLOSE_PROC   CloseCertPerformanceData;

DWORD
APIENTRY
OpenCertPerformanceData(
    IN LPWSTR lpDeviceNames
    )
{
    if (NULL == pCertPerfProcessData)
        return ERROR_FILE_NOT_FOUND;

    return ERROR_SUCCESS;
}

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

#define GLOBAL_STRING   L"Global"
#define FOREIGN_STRING  L"Foreign"
#define COSTLY_STRING   L"Costly"

// test for delimiter, end of line and non-digit characters
// used by I_CertPerfIsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
I_CertPerfGetQueryType(
     IN LPWSTR pwszValue
     )
/*++

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN pwszValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if pwszValue == 0 (null pointer)
           pwszValue == pointer to Null string
           pwszValue == pointer to "Global" string

    QUERY_FOREIGN
        if pwszValue == pointer to "Foreign" string

    QUERY_COSTLY
        if pwszValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    DWORD dwQueryType;
    if (NULL == pwszValue || L'\0' == *pwszValue ||
            0 == _wcsnicmp(pwszValue, GLOBAL_STRING, wcslen(GLOBAL_STRING)))
        dwQueryType = QUERY_GLOBAL;
    else if (0 == _wcsnicmp(pwszValue, COSTLY_STRING, wcslen(COSTLY_STRING)))
        dwQueryType = QUERY_COSTLY;
    else if (0 == _wcsnicmp(pwszValue, FOREIGN_STRING, wcslen(FOREIGN_STRING)))
        dwQueryType = QUERY_FOREIGN;
    else
        dwQueryType = QUERY_ITEMS;

    return dwQueryType;
}

BOOL
I_CertPerfIsNumberInUnicodeList (
                      IN DWORD   dwNumber,
                      IN LPWSTR  lpwszUnicodeList
                      )
/*++

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
   DWORD   dwThisNumber;
   WCHAR   *pwcThisChar;
   BOOL    bValidNumber;
   BOOL    bNewItem;
   WCHAR   wcDelimiter;    // could be an argument to be more flexible

   if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

   pwcThisChar = lpwszUnicodeList;
   dwThisNumber = 0;
   wcDelimiter = (WCHAR)' ';
   bValidNumber = FALSE;
   bNewItem = TRUE;

   while (TRUE)
   {
      switch (EvalThisChar (*pwcThisChar, wcDelimiter))
      {
      case DIGIT:
         // if this is the first digit after a delimiter, then
         // set flags to start computing the new number
         if (bNewItem)
         {
            bNewItem = FALSE;
            bValidNumber = TRUE;
         }
         if (bValidNumber)
         {
            dwThisNumber *= 10;
            dwThisNumber += (*pwcThisChar - (WCHAR)'0');
         }
         break;

      case DELIMITER:
         // a delimter is either the delimiter character or the
         // end of the string ('\0') if when the delimiter has been
         // reached a valid number was found, then compare it to the
         // number from the argument list. if this is the end of the
         // string and no match was found, then return.
         //
         if (bValidNumber)
         {
            if (dwThisNumber == dwNumber) return TRUE;
            bValidNumber = FALSE;
         }
         if (*pwcThisChar == 0)
         {
            return FALSE;
         }
         else
         {
            bNewItem = TRUE;
            dwThisNumber = 0;
         }
         break;

      case INVALID:
         // if an invalid character was encountered, ignore all
         // characters up to the next delimiter and then start fresh.
         // the invalid number is not compared.
         bValidNumber = FALSE;
         break;

      default:
         break;

      }
      pwcThisChar++;
   }

    return FALSE;
}

DWORD
APIENTRY
CollectCertPerformanceData(
    IN      LPWSTR  pwszValueName,
    IN OUT  LPVOID  *ppvData,
    IN OUT  LPDWORD pcbTotalBytes,
    IN OUT  LPDWORD pNumObjectTypes
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fReleaseMutex = FALSE;
    PCERT_PERF_DATA_DEFINITION pDataDef;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    DWORD cbNeededBytes;
    DWORD dwProcessCnt;
    DWORD dwInUseIndex;
    LONG NumInstances;
    DWORD dwQueryType;

    if (NULL == pCertPerfProcessData)
        goto NoProcessDataError;

    dwQueryType = I_CertPerfGetQueryType(pwszValueName);
    if (QUERY_FOREIGN == dwQueryType)
        goto ForeignQueryNotSupported;

    if (QUERY_ITEMS == dwQueryType) {
        if (!(I_CertPerfIsNumberInUnicodeList(
                CertPerfDataDefinition.ObjectType.ObjectNameTitleIndex,
                pwszValueName)))
            goto ObjectTypeQueryNotSupported;
    }

    if (WAIT_OBJECT_0 != WaitForSingleObject(
            hCertPerfSharedMemoryMutex,
            CERT_PERF_SHARED_MEMORY_MUTEX_TIMEOUT
            ))
        goto WaitForMutexError;
    else
        fReleaseMutex = TRUE;

    pDataDef = (PCERT_PERF_DATA_DEFINITION) *ppvData;

    // always return an "instance sized" buffer after the definition blocks
    // to prevent perfmon from reading bogus data. This is strictly a hack
    // to accomodate how PERFMON handles the "0" instance case.
    // By doing this, perfmon won't choke when there are no instances
    // and the counter object & counters will be displayed in the
    // list boxes, even though no instances will be listed.

    dwProcessCnt = pCertPerfSharedMemory->dwProcessCnt;
    if (CERT_PERF_MAX_PROCESS_CNT < dwProcessCnt)
        goto InvalidProcessData;

    cbNeededBytes = sizeof(CERT_PERF_DATA_DEFINITION) +
        (dwProcessCnt > 0 ? dwProcessCnt : 1 ) * (
            sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS));
    if (*pcbTotalBytes < cbNeededBytes) {
        dwErr = ERROR_MORE_DATA;
        goto MoreDataError;
    }

    // copy the object & counter definition information
    memcpy(pDataDef, &CertPerfDataDefinition,
        sizeof(CERT_PERF_DATA_DEFINITION));

    // Update the instance data for each InUse process.
    pInstanceDef = (PERF_INSTANCE_DEFINITION *) &pDataDef[1];
    dwInUseIndex = pCertPerfSharedMemory->dwFirstInUseIndex;
    NumInstances = 0;
    while (NumInstances < (LONG) dwProcessCnt &&
            CERT_PERF_MAX_PROCESS_CNT > dwInUseIndex) {
        PCERT_PERF_PROCESS_DATA pInUseData;
        PCERT_PERF_COUNTERS pCtr;
        DWORD cchProcessName;
        DWORD NameLength;
        DWORD ByteLength;

        pInUseData = &pCertPerfSharedMemory->rgProcessData[dwInUseIndex];
        dwInUseIndex = pInUseData->dwNextIndex;

        if (0 == pInUseData->dwProcessId)
            continue;

        // The following is updated for each InUse process:
        //  - PERF_INSTANCE_DEFINITION
        //  - wcszProcessName
        //  - optional padding for DWORD alignment
        //  - CERT_PERF_COUNTERS

        // Get process name and instance definition byte lengths
        for (cchProcessName = 0;
                cchProcessName < CERT_PERF_MAX_PROCESS_NAME_LEN &&
                    L'\0' != pInUseData->wcszProcessName[cchProcessName];
                                        cchProcessName++)
            ;
        if (CERT_PERF_MAX_PROCESS_NAME_LEN <= cchProcessName)
            goto InvalidProcessData;

        // Include trailing null in name length
        NameLength = cchProcessName * sizeof(WCHAR) + sizeof(WCHAR);
        ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
            DWORD_MULTIPLE(NameLength);


        // Update the instance definition fields
        pInstanceDef->ByteLength = ByteLength;
        pInstanceDef->ParentObjectTitleIndex = 0;   // no parent
        pInstanceDef->ParentObjectInstance = 0;     // "    "
        pInstanceDef->UniqueID = PERF_NO_UNIQUE_ID;
        pInstanceDef->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
        pInstanceDef->NameLength = NameLength;

        // Update the process name that immediately follows the
        // instance definition
        memcpy(&pInstanceDef[1], pInUseData->wcszProcessName,
            NameLength);

        // Update the performance counters immediately following the
        // above process name. Note, start of counters is DWORD aligned
        pCtr = (PCERT_PERF_COUNTERS) (((PBYTE) pInstanceDef) + ByteLength);
        pCtr->CounterBlock.ByteLength = sizeof(CERT_PERF_COUNTERS);
        pCtr->dwChainCnt = (DWORD) pInUseData->Counters.lChainCnt;
        pCtr->dwChainElementCnt = (DWORD) pInUseData->Counters.lChainElementCnt;
        pCtr->dwChainEngineCurrentCnt =
            (DWORD) pInUseData->Counters.lChainEngineCurrentCnt;
        pCtr->dwChainEngineTotalCnt =
            (DWORD) pInUseData->Counters.lChainEngineTotalCnt;
        pCtr->dwChainEngineResyncCnt =
            (DWORD) pInUseData->Counters.lChainEngineResyncCnt;
        pCtr->dwChainCertCacheCnt =
            (DWORD) pInUseData->Counters.lChainCertCacheCnt;
        pCtr->dwChainCtlCacheCnt =
            (DWORD) pInUseData->Counters.lChainCtlCacheCnt;
        pCtr->dwChainEndCertInCacheCnt =
            (DWORD) pInUseData->Counters.lChainEndCertInCacheCnt;
        pCtr->dwChainCacheEndCertCnt =
            (DWORD) pInUseData->Counters.lChainCacheEndCertCnt;
        pCtr->dwChainRevocationCnt =
            (DWORD) pInUseData->Counters.lChainRevocationCnt;
        pCtr->dwChainRevokedCnt =
            (DWORD) pInUseData->Counters.lChainRevokedCnt;
        pCtr->dwChainRevocationOfflineCnt =
            (DWORD) pInUseData->Counters.lChainRevocationOfflineCnt;
        pCtr->dwChainNoRevocationCheckCnt =
            (DWORD) pInUseData->Counters.lChainNoRevocationCheckCnt;
        pCtr->dwChainVerifyCertSignatureCnt =
            (DWORD) pInUseData->Counters.lChainVerifyCertSignatureCnt;
        pCtr->dwChainCompareIssuerPublicKeyCnt =
            (DWORD) pInUseData->Counters.lChainCompareIssuerPublicKeyCnt;
        pCtr->dwChainVerifyCtlSignatureCnt =
            (DWORD) pInUseData->Counters.lChainVerifyCtlSignatureCnt;
        pCtr->dwChainBeenVerifiedCtlSignatureCnt =
            (DWORD) pInUseData->Counters.lChainBeenVerifiedCtlSignatureCnt;
        pCtr->dwChainUrlIssuerCnt =
            (DWORD) pInUseData->Counters.lChainUrlIssuerCnt;
        pCtr->dwChainCacheOnlyUrlIssuerCnt =
            (DWORD) pInUseData->Counters.lChainCacheOnlyUrlIssuerCnt;
        pCtr->dwChainRequestedEngineResyncCnt =
            (DWORD) pInUseData->Counters.lChainRequestedEngineResyncCnt;
        pCtr->dwChangeNotifyCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCnt;
        pCtr->dwChangeNotifyLmGpCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyLmGpCnt;
        pCtr->dwChangeNotifyCuGpCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCuGpCnt;
        pCtr->dwChangeNotifyCuMyCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyCuMyCnt;
        pCtr->dwChangeNotifyRegCnt =
            (DWORD) pInUseData->Counters.lChangeNotifyRegCnt;
        pCtr->dwStoreCurrentCnt =
            (DWORD) pInUseData->Counters.lStoreCurrentCnt;
        pCtr->dwStoreTotalCnt =
            (DWORD) pInUseData->Counters.lStoreTotalCnt;
        pCtr->dwStoreRegCurrentCnt =
            (DWORD) pInUseData->Counters.lStoreRegCurrentCnt;
        pCtr->dwStoreRegTotalCnt =
            (DWORD) pInUseData->Counters.lStoreRegTotalCnt;
        pCtr->dwRegElementReadCnt =
            (DWORD) pInUseData->Counters.lRegElementReadCnt;
        pCtr->dwRegElementWriteCnt =
            (DWORD) pInUseData->Counters.lRegElementWriteCnt;
        pCtr->dwRegElementDeleteCnt =
            (DWORD) pInUseData->Counters.lRegElementDeleteCnt;
        pCtr->dwCertElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCertElementCurrentCnt;
        pCtr->dwCertElementTotalCnt =
            (DWORD) pInUseData->Counters.lCertElementTotalCnt;
        pCtr->dwCrlElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCrlElementCurrentCnt;
        pCtr->dwCrlElementTotalCnt =
            (DWORD) pInUseData->Counters.lCrlElementTotalCnt;
        pCtr->dwCtlElementCurrentCnt =
            (DWORD) pInUseData->Counters.lCtlElementCurrentCnt;
        pCtr->dwCtlElementTotalCnt =
            (DWORD) pInUseData->Counters.lCtlElementTotalCnt;


        //--###  Add New Counters  ###--

        NumInstances++;

        // setup for the next instance
        // Next instance starts immediately after the counters
        pInstanceDef = (PERF_INSTANCE_DEFINITION *) &pCtr[1];
    }

    if (0 == NumInstances) {
        // zero fill one instance sized block of data if there are no
        // data instances

        memset(pInstanceDef, 0, sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS));

        // Advance past the zero'ed instance
        pInstanceDef = (PERF_INSTANCE_DEFINITION *) ((PBYTE) pInstanceDef +
            sizeof(PERF_INSTANCE_DEFINITION) +
            CERT_PERF_MAX_PROCESS_NAME_LEN +
            sizeof(CERT_PERF_COUNTERS));
    }

    // update arguments for return
    *ppvData = (LPVOID) pInstanceDef;
    *pNumObjectTypes = 1;

    pDataDef->ObjectType.NumInstances = NumInstances;
    pDataDef->ObjectType.TotalByteLength = *pcbTotalBytes =
        (DWORD)((PBYTE) pInstanceDef - (PBYTE) pDataDef);

    assert(*pcbTotalBytes <= cbNeededBytes);


CommonReturn:
    if (fReleaseMutex)
        ReleaseMutex(hCertPerfSharedMemoryMutex);
    return dwErr;
ErrorReturn:
    *pcbTotalBytes = 0;
    *pNumObjectTypes = 0;
    goto CommonReturn;

TRACE_ERROR(NoProcessDataError)
TRACE_ERROR(ForeignQueryNotSupported)
TRACE_ERROR(ObjectTypeQueryNotSupported)
TRACE_ERROR(WaitForMutexError)
TRACE_ERROR(InvalidProcessData)
TRACE_ERROR(MoreDataError)
}

DWORD
APIENTRY
CloseCertPerformanceData()
{
    return ERROR_SUCCESS;
}



#if 0

// Example of timing the CertGetCertificateChain API

typedef struct _CERT_PERF_CHAIN_DATA {
    union {
        SYSTEMTIME          stBefore;
        LARGE_INTEGER       liBefore;
    };
} CERT_PERF_CHAIN_DATA, *PCERT_PERF_CHAIN_DATA;


void
WINAPI
CertPerfGetCertificateChainBefore(
    OUT PCERT_PERF_CHAIN_DATA pData
    )
{
    if (pCertPerfProcessData) {
        if (fCertPerfHighFreq)
            QueryPerformanceCounter(&pData->liBefore);
        else
            GetSystemTime(&pData->stBefore);
    }
}

void
WINAPI
CertPerfGetCertificateChainAfter(
    IN PCERT_PERF_CHAIN_DATA pData,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    if (pCertPerfProcessData) {
        if (fCertPerfHighFreq) {
            LARGE_INTEGER liAfter;
            _int64 i64DeltaTime;

            QueryPerformanceCounter(&liAfter);
            i64DeltaTime = liAfter.QuadPart - pData->liBefore.QuadPart;

            EnterCriticalSection(&CertPerfProcessCriticalSection);

            pCertPerfProcessData->Counters.dwChainCnt++;
            pCertPerfProcessData->Counters.i64TotalChainTime =
                pCertPerfProcessData->Counters.i64TotalChainTime +
                i64DeltaTime;

            if (0 == pCertPerfProcessData->Counters.i64MinChainTime ||
                    i64DeltaTime <
                        pCertPerfProcessData->Counters.i64MinChainTime)
                pCertPerfProcessData->Counters.i64MinChainTime =
                    i64DeltaTime;

            if (i64DeltaTime > pCertPerfProcessData->Counters.i64MaxChainTime)
                pCertPerfProcessData->Counters.i64MaxChainTime =
                    i64DeltaTime;

            LeaveCriticalSection(&CertPerfProcessCriticalSection);
        } else {
            SYSTEMTIME stAfter;
            FILETIME ftBefore;
            FILETIME ftAfter;
            _int64 i64DeltaTime;

            GetSystemTime(&stAfter);
            SystemTimeToFileTime(&pData->stBefore, &ftBefore);
            SystemTimeToFileTime(&stAfter, &ftAfter);

            i64DeltaTime = *((_int64 *) &ftAfter) - *((_int64 *) &ftBefore);

            EnterCriticalSection(&CertPerfProcessCriticalSection);

            pCertPerfProcessData->Counters.dwChainCnt++;
            pCertPerfProcessData->Counters.i64TotalChainTime =
                pCertPerfProcessData->Counters.i64TotalChainTime +
                i64DeltaTime;

            if (0 == pCertPerfProcessData->Counters.i64MinChainTime ||
                    i64DeltaTime <
                        pCertPerfProcessData->Counters.i64MinChainTime)
                pCertPerfProcessData->Counters.i64MinChainTime =
                    i64DeltaTime;

            if (i64DeltaTime > pCertPerfProcessData->Counters.i64MaxChainTime)
                pCertPerfProcessData->Counters.i64MaxChainTime =
                    i64DeltaTime;

            LeaveCriticalSection(&CertPerfProcessCriticalSection);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\async.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.cpp
//
//  Contents:   Async Parameter Management
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <async.h>
//+---------------------------------------------------------------------------
//
//  Function:   CryptCreateAsyncHandle
//
//  Synopsis:   create async param handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCreateAsyncHandle (
     IN DWORD dwFlags,
     OUT PHCRYPTASYNC phAsync
     )
{
    CCryptAsyncHandle* pAsyncHandle;

    pAsyncHandle = new CCryptAsyncHandle( dwFlags );
    if ( pAsyncHandle == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *phAsync = pAsyncHandle;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptSetAsyncParam
//
//  Synopsis:   set async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptSetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     IN LPVOID pvParam,
     IN OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->SetAsyncParam(
                                                 pszParamOid,
                                                 pvParam,
                                                 pfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptGetAsyncParam
//
//  Synopsis:   get async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     OUT LPVOID* ppvParam,
     OUT OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->GetAsyncParam(
                                                 pszParamOid,
                                                 ppvParam,
                                                 ppfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptCloseAsyncHandle
//
//  Synopsis:   close async handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCloseAsyncHandle (
     IN HCRYPTASYNC hAsync
     )
{
    delete ( CCryptAsyncHandle * )hAsync;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::CCryptAsyncHandle, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::CCryptAsyncHandle (DWORD dwFlags)
{
    m_pConstOidList = NULL;
    m_pStrOidList = NULL;
    Pki_InitializeCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::~CCryptAsyncHandle, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::~CCryptAsyncHandle ()
{
    FreeOidList( m_pConstOidList, TRUE );
    FreeOidList( m_pStrOidList, FALSE );
    DeleteCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::SetAsyncParam, public
//
//  Synopsis:   set an async parameter, if the pvParam is NULL then
//              the parameter is removed and freed if a free function
//              has been specified
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::SetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID pvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
                      )
{
    BOOL               fReturn = FALSE;
    PCRYPT_ASYNC_PARAM pParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pParam = FindAsyncParam( pszParamOid, fConstOid );

    if ( pvParam == NULL )
    {
        if ( pParam != NULL )
        {
            RemoveAsyncParam( pParam );
            FreeAsyncParam( pParam, fConstOid );
            fReturn = TRUE;
        }
        else
        {
            SetLastError( (DWORD) E_INVALIDARG );
        }

        LeaveCriticalSection( &m_AsyncLock );
        return( fReturn );
    }

    if ( pParam != NULL )
    {
        if ( pParam->pfnFree != NULL )
        {
            (*pParam->pfnFree)( pszParamOid, pvParam );
        }

        pParam->pvParam = pvParam;

        LeaveCriticalSection( &m_AsyncLock );
        return( TRUE );
    }

    if ( AllocAsyncParam(
              pszParamOid,
              fConstOid,
              pvParam,
              pfnFree,
              &pParam
              ) == TRUE )
    {
        AddAsyncParam( pParam, fConstOid );
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( fReturn );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::GetAsyncParam, public
//
//  Synopsis:   get an async parameter
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::GetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID* ppvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
                      )
{
    PCRYPT_ASYNC_PARAM pFoundParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pFoundParam = FindAsyncParam( pszParamOid, fConstOid );
    if ( pFoundParam == NULL )
    {
        LeaveCriticalSection( &m_AsyncLock );
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    *ppvParam = pFoundParam->pvParam;
    if ( ppfnFree != NULL )
    {
        *ppfnFree = pFoundParam->pfnFree;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AllocAsyncParam, private
//
//  Synopsis:   allocate an async parameter block
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::AllocAsyncParam (
                        LPSTR pszParamOid,
                        BOOL fConstOid,
                        LPVOID pvParam,
                        PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
                        PCRYPT_ASYNC_PARAM* ppParam
                        )
{
    HRESULT            hr = S_OK;
    PCRYPT_ASYNC_PARAM pParam;

    pParam = new CRYPT_ASYNC_PARAM;
    if ( pParam != NULL )
    {
        memset( pParam, 0, sizeof( CRYPT_ASYNC_PARAM ) );
        if ( fConstOid == FALSE )
        {
            pParam->pszOid = new CHAR [strlen( pszParamOid ) + 1];
            if ( pParam->pszOid != NULL )
            {
                strcpy( pParam->pszOid, pszParamOid );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pParam->pszOid = pszParamOid;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr != S_OK )
    {
        SetLastError( hr );
        return( FALSE );
    }

    pParam->pvParam = pvParam,
    pParam->pfnFree = pfnFree;
    *ppParam = pParam;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeAsyncParam, private
//
//  Synopsis:   free an async param
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeAsyncParam (
                       PCRYPT_ASYNC_PARAM pParam,
                       BOOL fConstOid
                       )
{
    if ( pParam->pfnFree != NULL )
    {
        (*pParam->pfnFree)( pParam->pszOid, pParam->pvParam );
    }

    if ( fConstOid == FALSE )
    {
        delete pParam->pszOid;
    }

    delete pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AddAsyncParam, private
//
//  Synopsis:   add an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::AddAsyncParam (
                      PCRYPT_ASYNC_PARAM pParam,
                      BOOL fConstOid
                      )
{
    PCRYPT_ASYNC_PARAM* ppOidList;

    if ( fConstOid == TRUE )
    {
        ppOidList = &m_pConstOidList;
    }
    else
    {
        ppOidList = &m_pStrOidList;
    }

    pParam->pNext = *ppOidList;
    pParam->pPrev = NULL;
    *ppOidList = pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::RemoveAsyncParam, private
//
//  Synopsis:   remove an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::RemoveAsyncParam (
                         PCRYPT_ASYNC_PARAM pParam
                         )
{
    if ( pParam->pPrev != NULL )
    {
        pParam->pPrev->pNext = pParam->pNext;
    }

    if ( pParam->pNext != NULL )
    {
        pParam->pNext->pPrev = pParam->pPrev;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FindAsyncParam, private
//
//  Synopsis:   find an async parameter
//
//----------------------------------------------------------------------------
PCRYPT_ASYNC_PARAM
CCryptAsyncHandle::FindAsyncParam (
                       LPSTR pszParamOid,
                       BOOL fConstOid
                       )
{
    PCRYPT_ASYNC_PARAM pParam;

    if ( fConstOid == TRUE )
    {
        pParam = m_pConstOidList;
    }
    else
    {
        pParam = m_pStrOidList;
    }

    while ( pParam != NULL )
    {
        if ( fConstOid == TRUE )
        {
            if ( pParam->pszOid == pszParamOid )
            {
                break;
            }
        }
        else
        {
            if ( _stricmp( pParam->pszOid, pszParamOid ) == 0 )
            {
                break;
            }
        }

        pParam = pParam->pNext;
    }

    return( pParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeOidList, private
//
//  Synopsis:   free an OID list
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeOidList (
                       PCRYPT_ASYNC_PARAM pOidList,
                       BOOL fConstOidList
                       )
{
    PCRYPT_ASYNC_PARAM pParam;
    PCRYPT_ASYNC_PARAM pParamNext;

    pParam = pOidList;

    while ( pParam != NULL )
    {
        pParamNext = pParam->pNext;
        FreeAsyncParam( pParam, fConstOidList );
        pParam = pParamNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\async.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.h
//
//  Contents:   Async Parameter Management definitions
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ASYNC_H__)
#define __ASYNC_H__

//
// CCryptAsyncHandle.  Async parameter handle class, a list of OID
// specified parameters.
//

typedef struct _CRYPT_ASYNC_PARAM {

    LPSTR pszOid;
    LPVOID pvParam;
    PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree;
    struct _CRYPT_ASYNC_PARAM* pPrev;
    struct _CRYPT_ASYNC_PARAM* pNext;

} CRYPT_ASYNC_PARAM, *PCRYPT_ASYNC_PARAM;

class CCryptAsyncHandle
{
public:

    //
    // Construction
    //

    CCryptAsyncHandle (DWORD dwFlags);
    ~CCryptAsyncHandle ();

    //
    // Management methods
    //

    BOOL SetAsyncParam (
            LPSTR pszParamOid,
            LPVOID pvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
            );

    BOOL GetAsyncParam (
            LPSTR pszParamOid,
            LPVOID* ppvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
            );

private:

    //
    // Lock
    //

    CRITICAL_SECTION   m_AsyncLock;

    //
    // Parameter lists
    //

    PCRYPT_ASYNC_PARAM m_pConstOidList;
    PCRYPT_ASYNC_PARAM m_pStrOidList;

    //
    // Private methods
    //

    BOOL AllocAsyncParam (
              LPSTR pszParamOid,
              BOOL fConstOid,
              LPVOID pvParam,
              PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
              PCRYPT_ASYNC_PARAM* ppParam
              );

    VOID FreeAsyncParam (
             PCRYPT_ASYNC_PARAM pParam,
             BOOL fConstOid
             );

    VOID AddAsyncParam (
            PCRYPT_ASYNC_PARAM pParam,
            BOOL fConstOid
            );

    VOID RemoveAsyncParam (
            PCRYPT_ASYNC_PARAM pParam
            );

    PCRYPT_ASYNC_PARAM FindAsyncParam (
                           LPSTR pszParamOid,
                           BOOL fConstOid
                           );

    VOID FreeOidList (
             PCRYPT_ASYNC_PARAM pOidList,
             BOOL fConstOidList
             );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\certhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   Certificate and CRL Helper APIs
//
//  Functions:  CertHelperDllMain
//              I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              CertCompareIntegerBlob
//              CertCompareCertificate
//              CertCompareCertificateName
//              CertIsRDNAttrsInCertificateName
//              CertComparePublicKeyInfo
//              CryptVerifyCertificateSignature
//              CryptHashCertificate
//              CryptHashToBeSigned
//              CryptSignCertificate
//              CryptSignAndEncodeCertificate
//              CertVerifyTimeValidity
//              CertVerifyCRLTimeValidity
//              CertVerifyValidityNesting
//              CertVerifyCRLRevocation
//              CertAlgIdToOID
//              CertOIDToAlgId
//              CertFindExtension
//              CertFindAttribute
//              CertFindRDNAttr
//              CertGetIntendedKeyUsage
//              CertGetPublicKeyLength
//              CryptHashPublicKeyInfo
//
//              I_CertCompareCertAndProviderPublicKey
//              CryptFindCertificateKeyProvInfo
//
//              CryptCreatePublicKeyInfo
//              CryptConvertPublicKeyInfo
//              CryptExportPublicKeyInfo
//              CryptExportPublicKeyInfoEx
//              CryptImportPublicKeyInfo
//              CryptImportPublicKeyInfoEx
//              CryptCreateKeyIdentifierFromCSP
//
//              CryptInstallDefaultContext
//              CryptUninstallDefaultContext
//
//  History:    23-Feb-96   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define NULL_ASN_TAG        0x05

//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

// The following should be moved to wincrypt.x

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyInfo is updated with a LocalAlloc'ed
// pointer to a CERT_PUBLIC_KEY_INFO data structure which must be freed by
// calling LocalFree. Otherwise, pvPubKeyInfo points to a user allocated
// CERT_PUBLIC_KEY_INFO data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    );

#define CRYPT_ALLOC_FLAG            0x8000


#define CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC  \
    "CryptDllEncodePublicKeyAndParameters"

// The returned encoded public keys and parameters are LocalAlloc'ed.
typedef BOOL (WINAPI *PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS)(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyStruc is updated with a LocalAlloc'ed
// pointer to a PUBLICKEYSTRUC data structure which must be freed by calling
// LocalFree. Otherwise, pvPubKeyStruc points to a user allocated
// PUBLICKEYSTRUC data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );


#define CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC  "CryptDllConvertPublicKeyInfo"

typedef BOOL (WINAPI *PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO)(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

// End of what should be moved to wincrypt.x

static HCRYPTOIDFUNCSET hEncodePubKeyFuncSet;
static HCRYPTOIDFUNCSET hConvertPubKeyFuncSet;

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the RSA DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSADHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Encode the X942 DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeX942DHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

static const CRYPT_OID_FUNC_ENTRY EncodePubKeyFuncTable[] = {
    szOID_RSA_RSA, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_rsaXchg, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_dsa, EncodeDSSPublicKeyAndParameters,
    szOID_X957_DSA, EncodeDSSPublicKeyAndParameters,
    szOID_ANSI_X942_DH, EncodeX942DHPublicKeyAndParameters,
    szOID_RSA_DH, EncodeRSADHPublicKeyAndParameters,
};
#define ENCODE_PUB_KEY_FUNC_COUNT (sizeof(EncodePubKeyFuncTable) / \
                                    sizeof(EncodePubKeyFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY ConvertPubKeyFuncTable[] = {
    szOID_RSA_RSA, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_rsaXchg, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_dsa, ConvertDSSPublicKeyInfo,
    szOID_X957_DSA, ConvertDSSPublicKeyInfo,
};
#define CONVERT_PUB_KEY_FUNC_COUNT (sizeof(ConvertPubKeyFuncTable) / \
                                    sizeof(ConvertPubKeyFuncTable[0]))


//+=========================================================================
//  CryptExportPublicKeyInfoEx and CryptImportPublicKeyInfoEx OID
//  installable functions.
//-=========================================================================

typedef BOOL (WINAPI *PFN_EXPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    );

typedef BOOL (WINAPI *PFN_IMPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    );

static HCRYPTOIDFUNCSET hExportPubKeyFuncSet;
static HCRYPTOIDFUNCSET hImportPubKeyFuncSet;


//+-------------------------------------------------------------------------
//  Default CryptProvs. Once acquired, not released until ProcessDetach.
//--------------------------------------------------------------------------
#define DEFAULT_RSA_CRYPT_PROV                  0
#define DEFAULT_DSS_CRYPT_PROV                  1
#define DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV     2
#define DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV      3
#define DEFAULT_ENCRYPT_DH_CRYPT_PROV           4
#define DEFAULT_CRYPT_PROV_CNT                  5

static HCRYPTPROV rghDefaultCryptProv[DEFAULT_CRYPT_PROV_CNT];
static CRITICAL_SECTION DefaultCryptProvCriticalSection;

typedef struct _ENCRYPT_ALG_INFO ENCRYPT_ALG_INFO, *PENCRYPT_ALG_INFO;
struct _ENCRYPT_ALG_INFO {
    ALG_ID              aiAlgid;
    DWORD               dwMinLen;
    DWORD               dwMaxLen;
    PENCRYPT_ALG_INFO   pNext;
};

static BOOL fLoadedRSAEncryptAlgInfo = FALSE;
static PENCRYPT_ALG_INFO pRSAEncryptAlgInfoHead = NULL;

//+=========================================================================
//  DefaultContext Function Forward References and Data Structures
//-=========================================================================

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    );

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    );

typedef struct _DEFAULT_CONTEXT DEFAULT_CONTEXT, *PDEFAULT_CONTEXT;
struct _DEFAULT_CONTEXT {
    HCRYPTPROV                              hCryptProv;
    DWORD                                   dwDefaultType;
    union   {
        // CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (note, converted to MULTI_)
        // CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID
        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA   pOIDDefaultPara;
    };

    DWORD                                   dwFlags;
    PDEFAULT_CONTEXT                        pNext;
    PDEFAULT_CONTEXT                        pPrev;

    // Following applicable to Process DefaultContext
    LONG                                    lRefCnt;
    HANDLE                                  hWait;
};

static BOOL fHasThreadDefaultContext;
static HCRYPTTLS hTlsDefaultContext;

static BOOL fHasProcessDefaultContext;
static CRITICAL_SECTION DefaultContextCriticalSection;
static PDEFAULT_CONTEXT pProcessDefaultContextHead;


//+-------------------------------------------------------------------------
//  Default CryptProv: initialization and free
//--------------------------------------------------------------------------
static BOOL InitDefaultCryptProv()
{
    return Pki_InitializeCriticalSection(&DefaultCryptProvCriticalSection);
}
static void FreeDefaultCryptProv()
{
    PENCRYPT_ALG_INFO pAlgInfo;

    DWORD cProv = DEFAULT_CRYPT_PROV_CNT;
    while (cProv--) {
        HCRYPTPROV hProv = rghDefaultCryptProv[cProv];
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }

    pAlgInfo = pRSAEncryptAlgInfoHead;
    while (pAlgInfo) {
        PENCRYPT_ALG_INFO pDeleteAlgInfo = pAlgInfo;
        pAlgInfo = pAlgInfo->pNext;
        PkiFree(pDeleteAlgInfo);
    }

    DeleteCriticalSection(&DefaultCryptProvCriticalSection);
}

static
VOID
WINAPI
DetachDefaultContext(
    IN LPVOID pv
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) pv;

    while (pDefaultContext) {
        PDEFAULT_CONTEXT pFree = pDefaultContext;
        pDefaultContext = pDefaultContext->pNext;
        if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
            CryptReleaseContext(pFree->hCryptProv, 0);
        PkiFree(pFree);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertHelperDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
		// Public key function setup
        if (NULL == (hExportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hEncodePubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hConvertPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                ENCODE_PUB_KEY_FUNC_COUNT,
                EncodePubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                CONVERT_PUB_KEY_FUNC_COUNT,
                ConvertPubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!InitDefaultCryptProv())
            goto InitDefaultCryptProvError;

        if (!Pki_InitializeCriticalSection(&DefaultContextCriticalSection))
            goto InitCritSectionError;

        if (NULL == (hTlsDefaultContext = I_CryptAllocTls()))
            goto CryptAllocTlsError;
        break;


    case DLL_PROCESS_DETACH:
        FreeDefaultCryptProv();

        while (pProcessDefaultContextHead) {
            PDEFAULT_CONTEXT pFree = pProcessDefaultContextHead;
            pProcessDefaultContextHead = pProcessDefaultContextHead->pNext;
            if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
                CryptReleaseContext(pFree->hCryptProv, 0);
            PkiFree(pFree);
        }
        DeleteCriticalSection(&DefaultContextCriticalSection);
        I_CryptFreeTls(hTlsDefaultContext, DetachDefaultContext);
        break;

    case DLL_THREAD_DETACH:
        DetachDefaultContext(I_CryptDetachTls(hTlsDefaultContext));
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

CryptAllocTlsError:
    DeleteCriticalSection(&DefaultContextCriticalSection);
InitCritSectionError:
    FreeDefaultCryptProv();
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitDefaultCryptProvError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)

}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;

    switch (aiPubKey) {
        case 0:
        case CALG_RSA_SIGN:
        case CALG_RSA_KEYX:
        case CALG_NO_SIGN:
            dwProvType = PROV_RSA_FULL;
            dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
            break;
        case CALG_DSS_SIGN:
            dwProvType = PROV_DSS_DH;
            dwDefaultProvIndex = DEFAULT_DSS_CRYPT_PROV;
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return 0;
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    NULL,               // pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    )) {
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                if (DEFAULT_DSS_CRYPT_PROV == dwDefaultProvIndex) {
                    if (!CryptAcquireContext(
                            &hProv,
                            NULL,               // pszContainer
                            NULL,               // pszProvider,
                            PROV_DSS,
                            CRYPT_VERIFYCONTEXT // dwFlags
                            ))
                        hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                }
            }
            rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


// Note, PP_ENUMALGS_EX returns the bit range. However, this parameter type
// may not be supported by all CSPs. If this fails, try PP_ENUMALGS which only
// returns a single, default bit length.
static void LoadRSAEncryptAlgInfo()
{
    EnterCriticalSection(&DefaultCryptProvCriticalSection);

    if (!fLoadedRSAEncryptAlgInfo) {
        HCRYPTPROV hProv;
        if (hProv = I_CryptGetDefaultCryptProv(CALG_RSA_KEYX)) {
            DWORD dwFlags = CRYPT_FIRST;
            BOOL fEx = TRUE;

            while (TRUE) {
                ENCRYPT_ALG_INFO AlgInfo;
                PENCRYPT_ALG_INFO pAllocAlgInfo;

                if (fEx) {
                    PROV_ENUMALGS_EX Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS_EX,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            )) {
                        if (0 != dwFlags) {
                            // Try PP_ENUMALGS
                            fEx = FALSE;
                            continue;
                        } else
                            break;
                    }
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwMinLen;
                    AlgInfo.dwMaxLen = Data.dwMaxLen;
                } else {
                    PROV_ENUMALGS Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            ))
                        break;
                    // Only know about a single length
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwBitLen;
                    AlgInfo.dwMaxLen = Data.dwBitLen;
                }

                dwFlags = 0;    // CRYPT_NEXT

                // Only interested in encrypt algorithms
                if (ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(AlgInfo.aiAlgid))
                    continue;

                if (NULL == (pAllocAlgInfo = (PENCRYPT_ALG_INFO)
                        PkiNonzeroAlloc(sizeof(ENCRYPT_ALG_INFO))))
                    break;
                AlgInfo.pNext = pRSAEncryptAlgInfoHead;
                memcpy(pAllocAlgInfo, &AlgInfo, sizeof(*pAllocAlgInfo));
                pRSAEncryptAlgInfoHead = pAllocAlgInfo;
            }
        }

        fLoadedRSAEncryptAlgInfo = TRUE;
    }
    LeaveCriticalSection(&DefaultCryptProvCriticalSection);
}

static BOOL IsDefaultRSACryptProvForEncrypt(
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    PENCRYPT_ALG_INFO pInfo;
    if (!fLoadedRSAEncryptAlgInfo)
        LoadRSAEncryptAlgInfo();

    if (0 == dwBitLen && (CALG_RC2 == aiEncrypt || CALG_RC4 == aiEncrypt))
        dwBitLen = 40;

    for (pInfo = pRSAEncryptAlgInfoHead; pInfo; pInfo = pInfo->pNext) {
        if (aiEncrypt == pInfo->aiAlgid) {
            if (0 == dwBitLen || (pInfo->dwMinLen <= dwBitLen &&
                    dwBitLen <= pInfo->dwMaxLen))
                return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;
    LPCSTR pszProvider;

    if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
        dwProvType = PROV_DSS_DH;
        dwDefaultProvIndex = DEFAULT_ENCRYPT_DH_CRYPT_PROV;
        pszProvider = NULL;
    } else {
        dwProvType = PROV_RSA_FULL;

        if (IsDefaultRSACryptProvForEncrypt(
                aiEncrypt,
                dwBitLen
                ))
            // Set to fall through to the default case
            aiEncrypt = 0;

        switch (aiEncrypt) {
            case CALG_DES:
            case CALG_3DES:
            case CALG_3DES_112:
                dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                pszProvider = MS_ENHANCED_PROV_A;
                break;
            case CALG_RC2:
            case CALG_RC4:
                if (40 >= dwBitLen) {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV;
                    pszProvider = MS_DEF_PROV_A;
                } else {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                    pszProvider = MS_ENHANCED_PROV_A;
                }
                break;
            case 0:
            default:
                dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
                pszProvider = NULL;
                break;
        }
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    ))
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
            else
                rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


//+-------------------------------------------------------------------------
//  Cert helper allocation and free functions
//--------------------------------------------------------------------------
static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

static BOOL AllocAndEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &PkiEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );
}

#if 0
//+-------------------------------------------------------------------------
//  For an authority key identifier extension, compare the extension's optional
//  fields with the specified issuer certificate.
//
//  Returns TRUE for no authority key identifier extension or an issuer
//  certificate match.
//--------------------------------------------------------------------------
static BOOL CompareAuthorityKeyIdentifier(
    IN DWORD dwCertEncodingType,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[],
    IN PCERT_INFO pIssuerInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_AUTHORITY_KEY_ID_INFO pKeyIdInfo = NULL;

    pExt = CertFindExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER,
            cExtensions,
            rgExtensions
            );
    if (pExt == NULL)
        return TRUE;
    
    if (NULL == (pKeyIdInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_KEY_ID,
            pExt->Value.pbData,
            pExt->Value.cbData
            ))) goto DecodeError;

    if (pKeyIdInfo->CertIssuer.cbData) {
        // Issuer certificate's issuer name must match
        if (!CertCompareCertificateName(
                dwCertEncodingType,
                &pKeyIdInfo->CertIssuer,
                &pIssuerInfo->Issuer
                )) goto ErrorReturn;
    }

    if (pKeyIdInfo->CertSerialNumber.cbData) {
        // Issuer certificate's serial number must match
        if (!CertCompareIntegerBlob(
                &pKeyIdInfo->CertSerialNumber,
                &pIssuerInfo->SerialNumber))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

DecodeError:
    fResult = TRUE;
    goto CommonReturn;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pKeyIdInfo);
    return fResult;
}
#endif


//+-------------------------------------------------------------------------
//  Compare two multiple byte integer blobs to see if they are identical.
//
//  Before doing the comparison, leading zero bytes are removed from a
//  positive number and leading 0xFF bytes are removed from a negative
//  number.
//
//  The multiple byte integers are treated as Little Endian. pbData[0] is the
//  least significant byte and pbData[cbData - 1] is the most significant
//  byte.
//
//  Returns TRUE if the integer blobs are identical after removing leading
//  0 or 0xFF bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareIntegerBlob(
    IN PCRYPT_INTEGER_BLOB pInt1,
    IN PCRYPT_INTEGER_BLOB pInt2
    )
{
    BYTE *pb1 = pInt1->pbData;
    DWORD cb1 = pInt1->cbData;
    BYTE *pb2 = pInt2->pbData;
    DWORD cb2 = pInt2->cbData;

    // Assumption: normally don't have leading 0 or 0xFF bytes.

    while (cb1 > 1) {
        BYTE bEnd = pb1[cb1 - 1];
        BYTE bPrev = pb1[cb1 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb1--;
        else
            break;
    }

    while (cb2 > 1) {
        BYTE bEnd = pb2[cb2 - 1];
        BYTE bPrev = pb2[cb2 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb2--;
        else
            break;
    }

    if (cb1 == cb2 && (0 == cb1 || 0 == memcmp(pb1, pb2, cb1)))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificates to see if they are identical.
//
//  Since a certificate is uniquely identified by its Issuer and SerialNumber,
//  these are the only fields needing to be compared.
//
//  Returns TRUE if the certificates are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificate(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
    )
{
    if (CertCompareIntegerBlob(&pCertId1->SerialNumber,
            &pCertId2->SerialNumber) &&
        pCertId1->Issuer.cbData == pCertId2->Issuer.cbData &&
        memcmp(pCertId1->Issuer.pbData, pCertId2->Issuer.pbData,
            pCertId1->Issuer.cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificate names to see if they are identical.
//
//  Returns TRUE if the names are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificateName(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pCertName1,
    IN PCERT_NAME_BLOB pCertName2
    )
{
    if (pCertName1->cbData == pCertName2->cbData &&
        memcmp(pCertName1->pbData, pCertName2->pbData,
            pCertName1->cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare the attributes in the certificate name with the specified 
//  Relative Distinguished Name's (CERT_RDN) array of attributes.
//  The comparison iterates through the CERT_RDN attributes and looks for an
//  attribute match in any of the certificate's RDNs. Returns TRUE if all the
//  attributes are found and match. 
//
//  The CERT_RDN_ATTR fields can have the following special values:
//    pszObjId == NULL              - ignore the attribute object identifier
//    dwValueType == CERT_RDN_ANY_TYPE   - ignore the value type
//    Value.pbData == NULL          - match any value
//   
//  CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG should be set to do
//  a case insensitive match. Otherwise, defaults to an exact, case sensitive
//  match.
//
//  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized
//  with unicode strings as for CryptEncodeObject(X509_UNICODE_NAME).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertIsRDNAttrsInCertificateName(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFlags,
    IN PCERT_NAME_BLOB pCertName,
    IN PCERT_RDN pRDN
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;

    DWORD cCmpAttr;
    PCERT_RDN_ATTR pCmpAttr;
    BOOL fMatch;

    if (NULL == (pNameInfo =
        (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags ? X509_UNICODE_NAME :
                X509_NAME,
            pCertName->pbData,
            pCertName->cbData
            ))) goto ErrorReturn;

    cCmpAttr = pRDN->cRDNAttr;
    pCmpAttr = pRDN->rgRDNAttr;
    fMatch = TRUE;
    // Iterate through list of attributes to be compared against
    for ( ; cCmpAttr > 0; cCmpAttr--, pCmpAttr++) {
        fMatch = FALSE;
        DWORD cNameRDN = pNameInfo->cRDN;
        PCERT_RDN pNameRDN = pNameInfo->rgRDN;
        // Iterate through name's list of RDNs
        for ( ; cNameRDN > 0; cNameRDN--, pNameRDN++) {
            DWORD cNameAttr = pNameRDN->cRDNAttr;
            PCERT_RDN_ATTR pNameAttr = pNameRDN->rgRDNAttr;
            // Iterate through name's CERT_RDN's list of attributes
            for ( ; cNameAttr > 0; cNameAttr--, pNameAttr++) {
                if (pCmpAttr->pszObjId && 
                        (pNameAttr->pszObjId == NULL ||
                         strcmp(pCmpAttr->pszObjId, pNameAttr->pszObjId) != 0))
                    continue;
                if (pCmpAttr->dwValueType != CERT_RDN_ANY_TYPE &&
                        pCmpAttr->dwValueType != pNameAttr->dwValueType)
                    continue;

                if (pCmpAttr->Value.pbData == NULL) {
                    fMatch = TRUE;
                    break;
                }

                if (CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG & dwFlags) {
                    DWORD cch;

                    if (CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags) {
                        if (0 == pCmpAttr->Value.cbData)
                            cch = wcslen((LPWSTR) pCmpAttr->Value.pbData);
                        else
                            cch = pCmpAttr->Value.cbData / sizeof(WCHAR);
                        if (cch == (pNameAttr->Value.cbData / sizeof(WCHAR))
                                            &&
                                CSTR_EQUAL == CompareStringU(
                                    LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    (LPWSTR) pCmpAttr->Value.pbData,
                                    cch,
                                    (LPWSTR) pNameAttr->Value.pbData,
                                    cch)) {
                            fMatch = TRUE;
                            break;
                        }
                    } else {
                        cch = pCmpAttr->Value.cbData;
                        if (cch == (pNameAttr->Value.cbData)
                                            &&
                                CSTR_EQUAL == CompareStringA(
                                    LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    (LPSTR) pCmpAttr->Value.pbData,
                                    cch,
                                    (LPSTR) pNameAttr->Value.pbData,
                                    cch)) {
                            fMatch = TRUE;
                            break;
                        }
                    }
                } else {
                    DWORD cbCmpData = pCmpAttr->Value.cbData;

                    if ((CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags) &&
                            0 == cbCmpData)
                        cbCmpData = wcslen((LPWSTR) pCmpAttr->Value.pbData) *
                            sizeof(WCHAR);

                    if (cbCmpData == pNameAttr->Value.cbData &&
                            (cbCmpData == 0 ||
                             memcmp(pCmpAttr->Value.pbData,
                                pNameAttr->Value.pbData,
                                cbCmpData) == 0)) {
                        fMatch = TRUE;
                        break;
                    }
                }
            }
            if (fMatch) break;
        }
        if (!fMatch) break;
    }

    if (!fMatch) {
        SetLastError((DWORD) CRYPT_E_NO_MATCH);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;


ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pNameInfo);
    return fResult;
}

#if 0
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//
//  Note: ignores CAPI's reserved and aiKeyAlg fields in the comparison.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyBitBlob(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_BIT_BLOB pPublicKey1,
    IN PCRYPT_BIT_BLOB pPublicKey2
    )
{
    BYTE *pb1, *pb2;
    PUBLICKEYSTRUC *pPubKeyStruc1, *pPubKeyStruc2;
    RSAPUBKEY *pRsaPubKey1, *pRsaPubKey2;
    BYTE *pbModulus1, *pbModulus2;
    DWORD cbModulus1, cbModulus2;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pb1 = pPublicKey1->pbData;
    pPubKeyStruc1 = (PUBLICKEYSTRUC *) pb1;
    pRsaPubKey1 = (RSAPUBKEY *) (pb1 + sizeof(PUBLICKEYSTRUC));
    pbModulus1 = pb1 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus1 = pRsaPubKey1->bitlen / 8;

    assert(cbModulus1 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus1 <=
        pPublicKey1->cbData);
    assert(pPubKeyStruc1->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc1->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc1->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc1->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey1->magic == RSA1);
    assert(pRsaPubKey1->bitlen % 8 == 0);

    pb2 = pPublicKey2->pbData;
    pPubKeyStruc2 = (PUBLICKEYSTRUC *) pb2;
    pRsaPubKey2 = (RSAPUBKEY *) (pb2 + sizeof(PUBLICKEYSTRUC));
    pbModulus2 = pb2 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus2 = pRsaPubKey2->bitlen / 8;

    assert(cbModulus2 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus2 <=
        pPublicKey2->cbData);
    assert(pPubKeyStruc2->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc2->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc2->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc2->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey2->magic == RSA1);
    assert(pRsaPubKey2->bitlen % 8 == 0);

    if (pRsaPubKey1->pubexp == pRsaPubKey2->pubexp &&
            cbModulus1 == cbModulus2 &&
            memcmp(pbModulus1, pbModulus2, cbModulus1) == 0)
        return TRUE;
    else
        return FALSE;

}
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey1,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey2
    )
{
    DWORD  cbData;
    DWORD  cb1;
    BYTE * pb1;
    DWORD  cb2;
    BYTE * pb2;
    BOOL   fResult = FALSE;
    PUBLICKEYSTRUC * pBlob1 = NULL;
    PUBLICKEYSTRUC * pBlob2 = NULL;

    if (!((cbData = pPublicKey1->PublicKey.cbData) ==
                    pPublicKey2->PublicKey.cbData
                            &&
          (cbData == 0 || memcmp(pPublicKey1->PublicKey.pbData,
                            pPublicKey2->PublicKey.pbData, cbData) == 0)))
    {
        // DSIE: Bug 402662.
        // Encoded compare failed, try decoded compare.
        if (NULL == (pBlob1 = (PUBLICKEYSTRUC *) AllocAndDecodeObject(
                dwCertEncodingType,
                RSA_CSP_PUBLICKEYBLOB,
                pPublicKey1->PublicKey.pbData,
                pPublicKey1->PublicKey.cbData,
                &cb1)))
        {
            goto CLEANUP;
        }

        if (NULL == (pBlob2 = (PUBLICKEYSTRUC *) AllocAndDecodeObject(
                dwCertEncodingType,
                RSA_CSP_PUBLICKEYBLOB,
                pPublicKey2->PublicKey.pbData,
                pPublicKey2->PublicKey.cbData,
                &cb2))) 
        {
            goto CLEANUP;
        }

        if (!((cb1 == cb2) &&
              (cb1 == 0 || memcmp(pBlob1, pBlob2, cb1) == 0)))
        {
            goto CLEANUP;
        }
    }
    
    // Compare algorithm parameters
    cb1 = pPublicKey1->Algorithm.Parameters.cbData;
    pb1 = pPublicKey1->Algorithm.Parameters.pbData;
    cb2 = pPublicKey2->Algorithm.Parameters.cbData;
    pb2 = pPublicKey2->Algorithm.Parameters.pbData;

    if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) 
    {
        // Check if either has NO or NULL parameters
        if (0 == cb1 || *pb1 == NULL_ASN_TAG ||
            0 == cb2 || *pb2 == NULL_ASN_TAG)
        {
            fResult = TRUE;
            goto CLEANUP;
        }
    }

    if (cb1 == cb2) 
    {
        if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
        {
            fResult = TRUE;
        }
    }

CLEANUP:
    if (pBlob1)
        PkiFree(pBlob1);

    if (pBlob2)
        PkiFree(pBlob2);

    return fResult;
}

static BOOL GetSignOIDInfo(
    IN LPCSTR pszObjId,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey,
    OUT DWORD *pdwFlags,
    OUT DWORD *pdwProvType = NULL
    )
{
    BOOL fResult;
    PCCRYPT_OID_INFO pInfo;

    *paiPubKey = 0;
    *pdwFlags = 0;
    if (pdwProvType)
        *pdwProvType = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra) {
            *paiPubKey = pdwExtra[0];
            if (2 <= cExtra) {
                *pdwFlags = pdwExtra[1];
                if (3 <= cExtra && pdwProvType) {
                    *pdwProvType = pdwExtra[2];
                }
            }
        }
        fResult = TRUE;
    } else if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_HASH_ALG_OID_GROUP_ID
            )) {
        *paiHash = pInfo->Algid;
        *paiPubKey = CALG_NO_SIGN;
        fResult = TRUE;
    } else {
        *paiHash = 0;
        fResult = FALSE;
        SetLastError((DWORD) NTE_BAD_ALGID);
    }
    return fResult;
}


#ifndef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    DWORD dwErr;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto ErrorReturn;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pPublicKey,
                &hSignKey
                )) goto ErrorReturn;
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto ErrorReturn;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;
    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Undo the reversal done by CryptDecodeObject(X509_CERT)
        PkiAsn1ReverseBytes(pbSignature, cbSignature);
        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto ErrorReturn;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    }

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    PkiFree(pSignedInfo);

    SetLastError(dwErr);
    return fResult;
}

#endif  // CMS_PKCS7

BOOL
WINAPI
DefaultHashCertificate(
    IN ALG_ID Algid,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    DWORD cbInHash;
    DWORD cbOutHash;

    if (NULL == pbHash)
        cbInHash = 0;
    else
        cbInHash = *pcbHash;

    switch (Algid) {
        case CALG_MD5:
            cbOutHash = MD5DIGESTLEN;
            if (MD5DIGESTLEN <= cbInHash) {
                MD5_CTX md5ctx;

                MD5Init(&md5ctx);
                if (cbEncoded)
                    MD5Update(&md5ctx, pbEncoded, cbEncoded);
                MD5Final(&md5ctx);
                memcpy(pbHash, md5ctx.digest, MD5DIGESTLEN);
            }
            break;

        case CALG_SHA1:
        default:
            assert(CALG_SHA1 == Algid);
            assert(CALG_SHA == Algid);
            cbOutHash = A_SHA_DIGEST_LEN;
            if (A_SHA_DIGEST_LEN <= cbInHash) {
                A_SHA_CTX shactx;

                A_SHAInit(&shactx);
                if (cbEncoded)
                    A_SHAUpdate(&shactx, (BYTE *) pbEncoded, cbEncoded);
                A_SHAFinal(&shactx, pbHash);
            }
            break;
    }

    *pcbHash = cbOutHash;
    if (cbInHash < cbOutHash && pbHash) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        return FALSE;
    } else
        return TRUE;
}

//+-------------------------------------------------------------------------
//  Hash the encoded content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//
//  Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the
//  default hash algorithm (currently SHA1) is used.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashCertificate(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (Algid == 0) {
        Algid = CALG_SHA;
        dwFlags = 0;
    }

    if (0 == hCryptProv) {
        if (CALG_SHA1 == Algid || CALG_MD5 == Algid)
            return DefaultHashCertificate(
                Algid,
                pbEncoded,
                cbEncoded,
                pbComputedHash,
                pcbComputedHash
                );
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                Algid,
                NULL,               // hKey - optional for MAC
                dwFlags,
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pbEncoded,
                cbEncoded,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Compute the hash of the "to be signed" information in the encoded
//  signed content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashToBeSigned(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (CALG_SHA1 == aiHash || CALG_MD5 == aiHash) {
            fResult = DefaultHashCertificate(
                aiHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                pbComputedHash,
                pcbComputedHash
                );
            goto CommonReturn;
        }
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    PkiFree(pSignedInfo);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Sign the "to be signed" information in the encoded signed content.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It needs to use the provider's signature private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncodedToBeSigned,
    IN DWORD cbEncodedToBeSigned,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pcbSignature
    )
{
    BOOL fResult;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (!GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (CALG_NO_SIGN == aiPubKey) {
        fResult = CryptHashCertificate(
            hCryptProv,
            aiHash,
            0,                  // dwFlags
            pbEncodedToBeSigned,
            cbEncodedToBeSigned,
            pbSignature,
            pcbSignature
            );
        if (fResult && pbSignature)
            // A subsequent CryptEncodeObject(X509_CERT) will reverse
            // the signature bytes
            PkiAsn1ReverseBytes(pbSignature, *pcbSignature);
        return fResult;
    }

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        if (NULL == pbSignature) {
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            return TRUE;
        }
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags,
                &hHash
                ))
        goto ErrorReturn;

    if (!CryptHashData(
                hHash,
                pbEncodedToBeSigned,
                cbEncodedToBeSigned,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto ErrorReturn;
        assert(cbData == sizeof(rgbDssSignature));
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        fResult = CryptEncodeObject(
                    dwCertEncodingType,
                    X509_DSS_SIGNATURE,
                    rgbDssSignature,
                    pbSignature,
                    pcbSignature
                    );
        if (fResult)
            // A subsequent CryptEncodeObject(X509_CERT) will reverse
            // the signature bytes
            PkiAsn1ReverseBytes(pbSignature, *pcbSignature);
        else if (0 != *pcbSignature)
            // Since a random number is used in each CryptSignHash invocation,
            // the generated signature will be different. In particular
            // different signatures may have different leading 0x00's or
            // 0xFF's which get removed when converted to the ASN.1 sequence
            // of integers.
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    } else
        fResult = CryptSignHash(
                    hHash,
                    dwKeySpec,
                    NULL,               // sDescription
                    0,                  // dwFlags
                    pbSignature,        // pbData
                    pcbSignature
                    );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbSignature = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

static DWORD AdjustForMaximumEncodedSignatureLength(
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN DWORD cbOrig
    )
{
    DWORD cbAdjust;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;

    cbAdjust = 0;
    if (GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags)) {
        if (CALG_DSS_SIGN == aiPubKey &&
                0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbOrig);
            if (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN > cbOrig)
                // the +1 is for adjusting the number of length octets in
                // the outer SEQUENCE. Note, the number of length octets in
                // the signature's BITSTRING will always be 1, ie,
                // CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN <= 0x7F.
                cbAdjust =
                    (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbOrig) + 1;
        }
    }
    return cbAdjust;
}

//+-------------------------------------------------------------------------
//  Encode the "to be signed" information. Sign the encoded "to be signed".
//  Encode the "to be signed" and the signature.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It uses the specified private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    CERT_SIGNED_CONTENT_INFO SignedInfo;
    memset(&SignedInfo, 0, sizeof(SignedInfo));

    SignedInfo.SignatureAlgorithm = *pSignatureAlgorithm;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            &SignedInfo.ToBeSigned.pbData,
            &SignedInfo.ToBeSigned.cbData
            )) goto ErrorReturn;

    CryptSignCertificate(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            SignedInfo.ToBeSigned.pbData,
            SignedInfo.ToBeSigned.cbData,
            &SignedInfo.SignatureAlgorithm,
            pvHashAuxInfo,
            NULL,                   // pbSignature
            &SignedInfo.Signature.cbData
            );
    if (SignedInfo.Signature.cbData == 0) goto ErrorReturn;
    SignedInfo.Signature.pbData =
        (BYTE *) PkiNonzeroAlloc(SignedInfo.Signature.cbData);
    if (SignedInfo.Signature.pbData == NULL) goto ErrorReturn;
    if (pbEncoded) {
        if (!CryptSignCertificate(
                hCryptProv,
                dwKeySpec,
                dwCertEncodingType,
                SignedInfo.ToBeSigned.pbData,
                SignedInfo.ToBeSigned.cbData,
                &SignedInfo.SignatureAlgorithm,
                pvHashAuxInfo,
                SignedInfo.Signature.pbData,
                &SignedInfo.Signature.cbData
                )) goto ErrorReturn;
    }

    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &SignedInfo,
            pbEncoded,
            pcbEncoded
            );
    if (!fResult && *pcbEncoded) {
        *pcbEncoded += AdjustForMaximumEncodedSignatureLength(
            &SignedInfo.SignatureAlgorithm,
            SignedInfo.Signature.cbData
            );
    }

CommonReturn:
    PkiFree(SignedInfo.ToBeSigned.pbData);
    PkiFree(SignedInfo.Signature.pbData);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Verify the time validity of a certificate.
//
//  Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for
//  a valid certificate
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    if (CompareFileTime(pFileTime, &pCertInfo->NotBefore) < 0)
        return -1;
    else if (CompareFileTime(pFileTime, &pCertInfo->NotAfter) > 0)
        return 1;
    else
        return 0;
}


//+-------------------------------------------------------------------------
//  Verify the time validity of a CRL.
//
//  Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for
//  a valid CRL
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyCRLTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCRL_INFO pCrlInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    // Note, NextUpdate is optional. When not present, set to 0
    if (CompareFileTime(pFileTime, &pCrlInfo->ThisUpdate) < 0)
        return -1;
    else if ((pCrlInfo->NextUpdate.dwLowDateTime ||
                pCrlInfo->NextUpdate.dwHighDateTime) &&
            CompareFileTime(pFileTime, &pCrlInfo->NextUpdate) > 0)
        return 1;
    else
        return 0;
}

//+-------------------------------------------------------------------------
//  Verify that the subject's time validity nests within the issuer's time
//  validity.
//
//  Returns TRUE if it nests. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyValidityNesting(
    IN PCERT_INFO pSubjectInfo,
    IN PCERT_INFO pIssuerInfo
    )
{
    if ((CompareFileTime(&pSubjectInfo->NotBefore,
                &pIssuerInfo->NotBefore) >= 0) &&
            (CompareFileTime(&pSubjectInfo->NotAfter,
                &pIssuerInfo->NotAfter) <= 0))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Verify that the subject certificate isn't on its issuer CRL.
//
//  Returns true if the certificate isn't on the CRL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCRLRevocation(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId,          // Only the Issuer and SerialNumber
                                    // fields are used
    IN DWORD cCrlInfo,
    IN PCRL_INFO rgpCrlInfo[]
    )
{
    DWORD InfoIdx;

    for (InfoIdx = 0; InfoIdx < cCrlInfo; InfoIdx++) {
        DWORD cEntry = rgpCrlInfo[InfoIdx]->cCRLEntry;
        PCRL_ENTRY rgEntry = rgpCrlInfo[InfoIdx]->rgCRLEntry;
        DWORD EntryIdx;

        for (EntryIdx = 0; EntryIdx < cEntry; EntryIdx++) {
            if (CertCompareIntegerBlob(&rgEntry[EntryIdx].SerialNumber,
                    &pCertId->SerialNumber))
                // It has been revoked!!!
                return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Convert the CAPI AlgId to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the AlgId.
//--------------------------------------------------------------------------
LPCSTR
WINAPI
CertAlgIdToOID(
    IN DWORD dwAlgId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                &dwAlgId,
                dwGroupId
                ))
            return pInfo->pszOID;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the CAPI AlgId.
//
//  Returns 0 if there isn't an AlgId corresponding to the ObjId.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertOIDToAlgId(
    IN LPCSTR pszObjId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                (void *) pszObjId,
                dwGroupId
                ))
            return pInfo->Algid;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//  Find an extension identified by its Object Identifier.
//
//  If found, returns pointer to the extension. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_EXTENSION
WINAPI
CertFindExtension(
    IN LPCSTR pszObjId,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[]
    )
{
    for (; cExtensions > 0; cExtensions--, rgExtensions++) {
        if (strcmp(pszObjId, rgExtensions->pszObjId) == 0)
            return rgExtensions;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Object Identifier.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_ATTRIBUTE
WINAPI
CertFindAttribute(
    IN LPCSTR pszObjId,
    IN DWORD cAttr,
    IN CRYPT_ATTRIBUTE rgAttr[]
    )
{
    for (; cAttr > 0; cAttr--, rgAttr++) {
        if (strcmp(pszObjId, rgAttr->pszObjId) == 0)
            return rgAttr;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first CERT_RDN attribute identified by its Object Identifier in
//  the name's list of Relative Distinguished Names.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_RDN_ATTR
WINAPI
CertFindRDNAttr(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    )
{
    DWORD cRDN = pName->cRDN;
    PCERT_RDN pRDN = pName->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cRDNAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pRDNAttr = pRDN->rgRDNAttr;
        for (; cRDNAttr > 0; cRDNAttr--, pRDNAttr++) {
            if (strcmp(pszObjId, pRDNAttr->pszObjId) == 0)
                return pRDNAttr;
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the intended key usage bytes from the certificate.
//
//  If the certificate doesn't have any intended key usage bytes, returns FALSE
//  and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through
//  cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied
//  bytes are zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetIntendedKeyUsage(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertInfo,
    OUT BYTE *pbKeyUsage,
    IN DWORD cbKeyUsage
    )
{
    BOOL fResult;
    DWORD cbData;
    PCERT_EXTENSION pExt;
    PCERT_KEY_ATTRIBUTES_INFO pKeyAttrInfo = NULL;
    PCRYPT_BIT_BLOB pAllocKeyUsage = NULL;
    PCRYPT_BIT_BLOB pKeyUsage = NULL;          // not allocated

    // First see if the certificate has the simple Key Usage Extension
    if (NULL != (pExt = CertFindExtension(
            szOID_KEY_USAGE,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            ))  &&
        NULL != (pAllocKeyUsage =
            (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_USAGE,
                pExt->Value.pbData,
                pExt->Value.cbData
                )))
        pKeyUsage = pAllocKeyUsage;
    else {
        pExt = CertFindExtension(
                szOID_KEY_ATTRIBUTES,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                );
        if (pExt == NULL) goto GetError;
    
        if (NULL == (pKeyAttrInfo =
            (PCERT_KEY_ATTRIBUTES_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_ATTRIBUTES,
                pExt->Value.pbData,
                pExt->Value.cbData
                ))) goto ErrorReturn;
        pKeyUsage = &pKeyAttrInfo->IntendedKeyUsage;
    }

    if (pKeyUsage->cbData == 0 || cbKeyUsage == 0)
        goto GetError;

    cbData = min(pKeyUsage->cbData, cbKeyUsage);
    memcpy(pbKeyUsage, pKeyUsage->pbData, cbData);
    fResult = TRUE;
    goto CommonReturn;

GetError:
    SetLastError(0);
ErrorReturn:
    fResult = FALSE;
    cbData = 0;
CommonReturn:
    PkiFree(pAllocKeyUsage);
    PkiFree(pKeyAttrInfo);
    if (cbData < cbKeyUsage)
        memset(pbKeyUsage + cbData, 0, cbKeyUsage - cbData);
    return fResult;
}

static DWORD GetYPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo
    )
{
    PCRYPT_UINT_BLOB pY = NULL;
    DWORD dwBitLen;

    if (NULL == (pY = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_MULTI_BYTE_UINT,
            pPublicKeyInfo->PublicKey.pbData,
            pPublicKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    dwBitLen = pY->cbData * 8;

CommonReturn:
    PkiFree(pY);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDHPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_X942_DH_PARAMETERS pDhParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDhParametersError;
    if (NULL == (pDhParameters =
                    (PCERT_X942_DH_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X942_DH_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDhParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDhParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDhParametersError)
TRACE_ERROR(DecodeParametersError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDSSPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDssParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDssParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDssParametersError)
TRACE_ERROR(DecodeParametersError)
}

//+-------------------------------------------------------------------------
//  Get the public/private key's bit length.
//
//  Returns 0 if unable to determine the key's length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    DWORD dwErr = 0;
    DWORD dwBitLen;
    ALG_ID aiPubKey;
    PCCRYPT_OID_INFO pOIDInfo;
    HCRYPTPROV hCryptProv;          // don't need to release
    HCRYPTKEY hPubKey = 0;
    DWORD cbData;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPublicKey->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;

    if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM)
        return GetDHPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (aiPubKey == CALG_DSS_SIGN)
        return GetDSSPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
        goto GetDefaultCryptProvError;
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            dwCertEncodingType,
            pPublicKey,
            &hPubKey
            )) goto ImportPublicKeyError;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_KEYLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_BLOCKLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;


    {
        // The CSP should have supported one of the above

        // Export the public key and look at the bitlen field.
        // The CAPI public key representation consists of the following
        //  sequence:
        //  - PUBLICKEYSTRUC
        //  - DSSPUBKEY | RSAPUBKEY (DSSPUBKEY is subset of RSAPUBKEY)
        //  ...

        BYTE *pbPubKey = NULL;
        DWORD cbPubKey;

        dwBitLen = 0;
        dwErr = GetLastError();
        cbPubKey = 0;
        if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    NULL,           // pbData
                    &cbPubKey
                    ) &&
                cbPubKey >= (sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY)) &&
                NULL != (pbPubKey = (BYTE *) PkiNonzeroAlloc(cbPubKey))) {
            if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    pbPubKey,
                    &cbPubKey
                    )) {
                DSSPUBKEY *pPubKey =
                    (DSSPUBKEY *) (pbPubKey + sizeof(PUBLICKEYSTRUC));
                dwBitLen = pPubKey->bitlen;
            }
            PkiFree(pbPubKey);
        }
        if (0 != dwBitLen)
            goto CommonReturn;
        SetLastError(dwErr);
        goto GetKeyParamError;
    }

CommonReturn:
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    SetLastError(dwErr);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    dwErr = GetLastError();
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportPublicKeyError)
TRACE_ERROR(GetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Compute the hash of the encoded public key info.
//
//  The public key info is encoded and then hashed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = CryptHashCertificate(
            hCryptProv,
            Algid ? Algid : CALG_MD5,
            dwFlags,
            pbEncoded,
            cbEncoded,
            pbComputedHash,
            pcbComputedHash
            );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
    
CommonReturn:
    PkiFree(pbEncoded);
    return fResult;
}



//+-------------------------------------------------------------------------
//  Compares the certificate's public key with the provider's public key
//  to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCompareCertAndProviderPublicKey(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pProvPubKeyInfo = NULL;
    DWORD cbProvPubKeyInfo;
    DWORD dwCertEncodingType = pCert->dwCertEncodingType;

    // Get provider's public key
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            NULL,               // pProvPubKeyInfo
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;
    assert(cbProvPubKeyInfo);
    if (NULL == (pProvPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) PkiNonzeroAlloc(
            cbProvPubKeyInfo)))
        goto OutOfMemory;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            pProvPubKeyInfo,
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;

    if (!CertComparePublicKeyInfo(
            dwCertEncodingType,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            pProvPubKeyInfo
            ))
        goto ComparePublicKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pProvPubKeyInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportPublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ComparePublicKeyError, NTE_BAD_PUBLIC_KEY)
}

//+=========================================================================
//  CryptFindCertificateKeyProvInfo Support Functions
//-=========================================================================
static BOOL HasValidKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindKeySetFlags
    )
{
    BOOL fResult;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    HCRYPTPROV hProv = 0;
    DWORD cbData;
    DWORD dwAcquireFlags;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbData
            ))
        return FALSE;
    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbData)))
        goto OutOfMemory;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbData
            ))
        goto GetKeyProvInfoPropertyError;

    if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG))
            goto NotUserContainer;
    } else {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_USER_KEYSET_FLAG))
            goto NotMachineContainer;
    }

    dwAcquireFlags = CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
    if (dwFindKeySetFlags & CRYPT_FIND_SILENT_KEYSET_FLAG)
        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;

    if (!CryptAcquireCertificatePrivateKey(
            pCert,
            dwAcquireFlags,
            NULL,                   // pvReserved
            &hProv,
            NULL,                   // pdwKeySpec
            NULL                    // pfCallerFreeProv
            ))
        goto AcquireCertPrivateKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pKeyProvInfo);
    if (hProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(hProv, 0);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyProvInfoPropertyError)
SET_ERROR(NotUserContainer, NTE_NOT_FOUND)
SET_ERROR(NotMachineContainer, NTE_NOT_FOUND)
TRACE_ERROR(AcquireCertPrivateKeyError)
}


// Default to Algid being supported. Only return FALSE if successfully
// enumerated all the provider algorithms and didn't find a match.
static BOOL IsPublicKeyAlgidSupported(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN ALG_ID aiPubKey
    )
{
    BOOL fResult;
    DWORD dwErr;
    BYTE *pbData = NULL;
    DWORD cbMaxData;
    DWORD cbData;
    DWORD dwFlags;

    if (0 == aiPubKey)
        return TRUE;

    // Get maximum length of provider algorithm parameter data
    cbMaxData = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMALGS,
            NULL,           // pbData
            &cbMaxData,
            CRYPT_FIRST     // dwFlags
            )) {
        dwErr = GetLastError();
        if (ERROR_MORE_DATA != dwErr)
            goto GetProvAlgParamError;
    }
    if (0 == cbMaxData)
        goto NoProvAlgParamError;
    if (NULL == (pbData = (BYTE *) PkiNonzeroAlloc(cbMaxData)))
        goto OutOfMemory;

    dwFlags = CRYPT_FIRST;
    while (TRUE) {
        ALG_ID aiProv;

        cbData = cbMaxData;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                pbData,
                &cbData,
                dwFlags
                )) {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwErr) {
                fResult = FALSE;
                goto PublicKeyAlgidNotSupported;
            } else
                goto GetProvAlgParamError;
        }
        assert(cbData >= sizeof(ALG_ID));
        aiProv = *(ALG_ID *) pbData;
        // Don't distinguish between exchange or signature
        if (GET_ALG_TYPE(aiPubKey) == GET_ALG_TYPE(aiProv))
            break;

        dwFlags = 0;    // CRYPT_NEXT
    }
    fResult = TRUE;

PublicKeyAlgidNotSupported:
CommonReturn:
    PkiFree(pbData);
    return fResult;
ErrorReturn:
    // For an error, assume the public key algorithm is supported.
    fResult = TRUE;
    goto CommonReturn;

SET_ERROR_VAR(GetProvAlgParamError, dwErr)
SET_ERROR(NoProvAlgParamError, NTE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
}

// For success, updates the certificate's KEY_PROV_INFO property
//
// If container isn't found, LastError is set to ERROR_NO_MORE_ITEMS.
//
static BOOL FindContainerAndSetKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN LPWSTR pwszProvName,
    IN DWORD dwProvType,
    IN DWORD dwProvFlags        // CRYPT_MACHINE_KEYSET and/or CRYPT_SILENT
    )
{
    BOOL fResult;
    DWORD dwEnumFlags;
    DWORD dwEnumErr = 0;
    DWORD dwAcquireErr = 0;
    LPSTR pszContainerName = NULL;
    DWORD cchContainerName;
    DWORD cchMaxContainerName;
    LPWSTR pwszContainerName = NULL;

    // Get maximum container name length
    cchMaxContainerName = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMCONTAINERS,
            NULL,           // pbData
            &cchMaxContainerName,
            CRYPT_FIRST
            )) {
        dwEnumErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwEnumErr ||
                ERROR_INVALID_PARAMETER == dwEnumErr)
            goto PublicKeyContainerNotFound;
        else if (ERROR_MORE_DATA != dwEnumErr)
            goto EnumContainersError;
    }
    if (0 == cchMaxContainerName)
        goto PublicKeyContainerNotFound;
    if (NULL == (pszContainerName = (LPSTR) PkiNonzeroAlloc(
            cchMaxContainerName + 1)))
        goto OutOfMemory;

    dwEnumFlags = CRYPT_FIRST;
    while (TRUE) {
        HCRYPTPROV hContainerProv = 0;
        LPWSTR pwszAcquireProvName = pwszProvName;

        cchContainerName = cchMaxContainerName;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMCONTAINERS,
                (BYTE *) pszContainerName,
                &cchContainerName,
                dwEnumFlags
                )) {
            dwEnumErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwEnumErr ||
                    ERROR_FILE_NOT_FOUND == dwEnumErr) {
                if (0 != dwAcquireErr)
                    goto CryptAcquireContextError;
                else
                    goto PublicKeyContainerNotFound;
            } else
                goto EnumContainersError;
        }
        dwEnumFlags = 0;        // CRYPT_NEXT

        if (NULL == (pwszContainerName = MkWStr(pszContainerName)))
            goto OutOfMemory;

        // First try using enhanced providers for the base guys
        if (PROV_RSA_FULL == dwProvType &&
                0 == _wcsicmp(pwszProvName, MS_DEF_PROV_W)) {
            fResult = CryptAcquireContextU(
                    &hContainerProv,
                    pwszContainerName,
                    MS_ENHANCED_PROV_W,
                    PROV_RSA_FULL,
                    dwProvFlags
                    );
            if (fResult)
                pwszAcquireProvName = MS_ENHANCED_PROV_W;
        } else if (PROV_DSS_DH == dwProvType &&
                0 == _wcsicmp(pwszProvName, MS_DEF_DSS_DH_PROV_W)) {
            fResult = CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                MS_ENH_DSS_DH_PROV_W,
                PROV_DSS_DH,
                dwProvFlags
                );
            if (fResult)
                pwszAcquireProvName = MS_ENH_DSS_DH_PROV_W;
        } else
            fResult = FALSE;

        if (!fResult)
            fResult = CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                pwszAcquireProvName,
                dwProvType,
                dwProvFlags
                );

        if (!fResult)
            dwAcquireErr = GetLastError();
        else {
            DWORD dwKeySpec;

            dwKeySpec = AT_KEYEXCHANGE;
            fResult = FALSE;
            while (TRUE) {
                if (I_CertCompareCertAndProviderPublicKey(
                        pCert,
                        hContainerProv,
                        dwKeySpec
                        )) {
                    fResult = TRUE;
                    break;
                } else if (AT_SIGNATURE == dwKeySpec)
                    break;
                else
                    dwKeySpec = AT_SIGNATURE;
            }
            CryptReleaseContext(hContainerProv, 0);

            if (fResult) {
                CRYPT_KEY_PROV_INFO KeyProvInfo;

                memset(&KeyProvInfo, 0, sizeof(KeyProvInfo));
                KeyProvInfo.pwszContainerName = pwszContainerName;
                KeyProvInfo.pwszProvName = pwszAcquireProvName;
                KeyProvInfo.dwProvType = dwProvType;
                KeyProvInfo.dwFlags = dwProvFlags & ~CRYPT_SILENT;
                KeyProvInfo.dwKeySpec = dwKeySpec;

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        0,                              // dwFlags
                        &KeyProvInfo
                        ))
                    goto SetKeyProvInfoPropertyError;
                else
                    goto SuccessReturn;
            }
        }

        FreeWStr(pwszContainerName);
        pwszContainerName = NULL;
    }

    goto UnexpectedError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pszContainerName);
    FreeWStr(pwszContainerName);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(EnumContainersError, dwEnumErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
SET_ERROR(PublicKeyContainerNotFound, ERROR_NO_MORE_ITEMS)
TRACE_ERROR(SetKeyProvInfoPropertyError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Enumerates the cryptographic providers and their containers to find the
//  private key corresponding to the certificate's public key. For a match,
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property is updated.
//
//  If the CERT_KEY_PROV_INFO_PROP_ID is already set, then, its checked to
//  see if it matches the provider's public key. For a match, the above
//  enumeration is skipped.
//
//  By default both the user and machine key containers are searched.
//  The CRYPT_FIND_USER_KEYSET_FLAG or CRYPT_FIND_MACHINE_KEYSET_FLAG
//  can be set in dwFlags to restrict the search to either of the containers.
//
//  The CRYPT_FIND_SILENT_KEYSET_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  If a container isn't found, returns FALSE with LastError set to
//  NTE_NO_KEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFindCertificateKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    DWORD dwFindContainerErr = ERROR_NO_MORE_ITEMS;
    DWORD dwAcquireErr = 0;
    DWORD dwProvIndex;
    PCCRYPT_OID_INFO pOIDInfo;
    ALG_ID aiPubKey;

    if (0 == (dwFlags &
            (CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG)))
        dwFlags |=
            CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG;

    if (HasValidKeyProvInfo(pCert, dwFlags))
        return TRUE;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            ))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;
    

    for (dwProvIndex = 0; TRUE; dwProvIndex++) {
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName) {
            if (0 == dwProvIndex)
                goto EnumProvidersError;
            else if (ERROR_NO_MORE_ITEMS != dwFindContainerErr)
                goto FindContainerError;
            else if (0 != dwAcquireErr)
                goto CryptAcquireContextError;
            else
                goto KeyContainerNotFound;
        }
        if (NULL == (pwszProvName = (LPWSTR) PkiNonzeroAlloc(
                (cbProvName + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            PkiFree(pwszProvName);
            goto EnumProvidersError;
        }

        fResult = FALSE;
        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            dwAcquireErr = GetLastError();
            hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
        } else if (IsPublicKeyAlgidSupported(
                pCert,
                hProv,
                aiPubKey
                )) {
            DWORD dwSetProvFlags;
            if (dwFlags & CRYPT_FIND_SILENT_KEYSET_FLAG)
                dwSetProvFlags = CRYPT_SILENT;
            else
                dwSetProvFlags = 0;

            if (dwFlags & CRYPT_FIND_USER_KEYSET_FLAG) {
                if (FindContainerAndSetKeyProvInfo(
                        pCert,
                        hProv,
                        pwszProvName,
                        dwProvType,
                        dwSetProvFlags
                        ))
                    fResult = TRUE;
                else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                    dwFindContainerErr = GetLastError();
            }

            if (!fResult && (dwFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG)) {
                CryptReleaseContext(hProv, 0);

                if (!CryptAcquireContextU(
                        &hProv,
                        NULL,               // pwszContainerName,
                        pwszProvName,
                        dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET  // dwFlags
                        )) {
                    dwAcquireErr = GetLastError();
                    hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                } else {
                    if (FindContainerAndSetKeyProvInfo(
                            pCert,
                            hProv,
                            pwszProvName,
                            dwProvType,
                            dwSetProvFlags | CRYPT_MACHINE_KEYSET
                            ))
                        fResult = TRUE;
                    else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                        dwFindContainerErr = GetLastError();
                }
            }
        }

        if (hProv)
            CryptReleaseContext(hProv, 0);
        PkiFree(pwszProvName);
        if (fResult)
            goto CommonReturn;
    }

    goto UnexpectedError;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnumProvidersError)
SET_ERROR(KeyContainerNotFound, NTE_NO_KEY)
SET_ERROR_VAR(FindContainerError, dwFindContainerErr)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}



//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

static BOOL EncodePublicKeyInfo(
    IN LPCSTR pszPubKeyOID,
    IN BYTE *pbEncodedPubKey,
    IN DWORD cbEncodedPubKey,
    IN BYTE *pbEncodedParameters,
    IN DWORD cbEncodedParameters,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    BYTE *pbExtra;
    LONG lRemainExtra;
    DWORD cbOID;

    if (pInfo == NULL)
        *pcbInfo = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    cbOID = strlen(pszPubKeyOID) + 1;
    lRemainExtra -= INFO_LEN_ALIGN(cbOID) +
        INFO_LEN_ALIGN(cbEncodedParameters) + cbEncodedPubKey;
    if (lRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_PUBLIC_KEY_INFO));
        pInfo->Algorithm.pszObjId = (LPSTR) pbExtra;
        memcpy(pbExtra, pszPubKeyOID, cbOID);
        pbExtra += INFO_LEN_ALIGN(cbOID);
        if (cbEncodedParameters) {
            pInfo->Algorithm.Parameters.cbData = cbEncodedParameters;
            pInfo->Algorithm.Parameters.pbData = pbExtra;
            memcpy(pbExtra, pbEncodedParameters, cbEncodedParameters);
            pbExtra += INFO_LEN_ALIGN(cbEncodedParameters);
        }

        pInfo->PublicKey.pbData = pbExtra;
        pInfo->PublicKey.cbData = cbEncodedPubKey;
        memcpy(pbExtra, pbEncodedPubKey, cbEncodedPubKey);

        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    } else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }
    fResult = TRUE;

CommonReturn:
    return fResult;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
}

//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    LPCSTR pszEncodePubKeyOID;

    BYTE *pbEncodedPubKey = NULL;
    DWORD cbEncodedPubKey = 0;
    BYTE *pbEncodedParameters = NULL;
    DWORD cbEncodedParameters = 0;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    if (NULL == pszPubKeyOID) {
        PCCRYPT_OID_INFO pInfo;
        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;
    } else
        pszEncodePubKeyOID = pszPubKeyOID;

    if (!CryptGetOIDFunctionAddress(
            hEncodePubKeyFuncSet,
            dwCertEncodingType,
            pszEncodePubKeyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        PCCRYPT_OID_INFO pInfo;

        if (NULL == pszPubKeyOID)
            goto NoEncodePubKeyFunction;

        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;

        if (!CryptGetOIDFunctionAddress(
                hEncodePubKeyFuncSet,
                dwCertEncodingType,
                pszEncodePubKeyOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodePubKeyFunction;
    }

    if (NULL == pszPubKeyOID)
        pszPubKeyOID = pszEncodePubKeyOID;

    fResult = ((PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS) pvFuncAddr)(
        dwCertEncodingType,
        pszPubKeyOID,
        pPubKeyStruc,
        cbPubKeyStruc,
        dwFlags,
        pvReserved,
        &pbEncodedPubKey,
        &cbEncodedPubKey,
        &pbEncodedParameters,
        &cbEncodedParameters
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    if (!fResult)
        goto EncodePubKeyAndParametersError;

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (!EncodePublicKeyInfo(
                pszPubKeyOID,
                pbEncodedPubKey,
                cbEncodedPubKey,
                pbEncodedParameters,
                cbEncodedParameters,
                NULL,                   // pPubKeyInfo
                &cbPubKeyInfo
                ))
            goto EncodePublicKeyInfoError;
        if (NULL == (pPubKeyInfo =
                (PCERT_PUBLIC_KEY_INFO) PkiDefaultCryptAlloc(cbPubKeyInfo)))
            goto OutOfMemory;
        *((PCERT_PUBLIC_KEY_INFO *) pvPubKeyInfo) = pPubKeyInfo;
    } else {
        pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvPubKeyInfo;
        cbPubKeyInfo = *pcbPubKeyInfo;
    }

    fResult = EncodePublicKeyInfo(
        pszPubKeyOID,
        pbEncodedPubKey,
        cbEncodedPubKey,
        pbEncodedParameters,
        cbEncodedParameters,
        pPubKeyInfo,
        &cbPubKeyInfo
        );

    if (!fResult && (dwFlags & CRYPT_ALLOC_FLAG))
        goto ErrorReturn;

CommonReturn:
    PkiDefaultCryptFree(pbEncodedPubKey);
    PkiDefaultCryptFree(pbEncodedParameters);

    *pcbPubKeyInfo = cbPubKeyInfo;
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyInfo);
        *((void **) pvPubKeyInfo) = NULL;
    }
    cbPubKeyInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoPubKeyOIDInfo, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(NoEncodePubKeyFunction)
TRACE_ERROR(EncodePubKeyAndParametersError)
TRACE_ERROR(EncodePublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
}

BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hConvertPubKeyFuncSet,
            dwCertEncodingType,
            pPubKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO) pvFuncAddr)(
            dwCertEncodingType,
            pPubKeyInfo,
            dwFlags,
            pvReserved,
            pvPubKeyStruc,
            pcbPubKeyStruc
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        ALG_ID aiPubKey;
        PCCRYPT_OID_INFO pOIDInfo;

        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pPubKeyInfo->Algorithm.pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                ))
            aiPubKey = pOIDInfo->Algid;
        else
            aiPubKey = 0;

        switch (aiPubKey) {
            case CALG_DSS_SIGN:
                fResult = ConvertDSSPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
            default:
                // Attempt to decode as a PKCS #1 RSA public key
                fResult = ConvertRSAPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
        }
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    *ppbEncodedParameters = NULL;
    *pcbEncodedParameters = 0;

    return CryptEncodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyStruc,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,                       // pEncodePara
        (void *) ppbEncodedPubKey,
        pcbEncodedPubKey
        );
}

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyInfo->PublicKey.pbData,
        pPubKeyInfo->PublicKey.cbData,
        (dwFlags & CRYPT_ALLOC_FLAG) ? CRYPT_DECODE_ALLOC_FLAG : 0,
        NULL,                               // pDecodePara,
        pvPubKeyStruc,
        pcbPubKeyStruc
        );
}

#ifndef DSS1
#define DSS1 ((DWORD)'D'+((DWORD)'S'<<8)+((DWORD)'S'<<16)+((DWORD)'1'<<24))
#endif

#define DSS_Q_LEN   20

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DWORD cbKey;
    BYTE *pbKey;

    CERT_DSS_PARAMETERS DssParameters;
    CRYPT_UINT_BLOB DssPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    assert(cbKey > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED));
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DSS_SIGN);
    assert(pCspPubKey->magic == DSS1);
    assert(pCspPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // Initialize DSS parameters from CSP data structure
    DssParameters.p.cbData = cbKey;
    DssParameters.p.pbData = pbKey;
    pbKey += cbKey;
    DssParameters.q.cbData = DSS_Q_LEN;
    DssParameters.q.pbData = pbKey;
    pbKey += DSS_Q_LEN;
    DssParameters.g.cbData = cbKey;
    DssParameters.g.pbData = pbKey;
    pbKey += cbKey;

    // Initialize DSS public key from CSP data structure
    DssPubKey.cbData = cbKey;
    DssPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            &DssParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            &DssPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    PCRYPT_UINT_BLOB pDssPubKey = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DSSSEED *pCspSeed;
    DWORD cbKey;
    BYTE *pbKey;
    DWORD cb;

    if (0 == pPubKeyInfo->Algorithm.Parameters.cbData ||
            NULL_ASN_TAG == *pPubKeyInfo->Algorithm.Parameters.pbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    if (NULL == (pDssPubKey = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            pPubKeyInfo->PublicKey.pbData,
            pPubKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey)
        goto InvalidDssParametersError;

    cbPubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED);

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (NULL == (pPubKeyStruc =
                (PUBLICKEYSTRUC *) PkiDefaultCryptAlloc(cbPubKeyStruc)))
            goto OutOfMemory;
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = pPubKeyStruc;
    } else
        pPubKeyStruc = (PUBLICKEYSTRUC *) pvPubKeyStruc;

    fResult = TRUE;
    if (pPubKeyStruc) {
        if (0 == (dwFlags & CRYPT_ALLOC_FLAG) &&
                *pcbPubKeyStruc < cbPubKeyStruc) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else {
            pbKeyBlob = (BYTE *) pPubKeyStruc;
            pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
            pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);

            // NOTE, the length of G and Y can be less than the length of P.
            // The CSP requires G and Y to be padded out with 0x00 bytes if it
            // is less and in little endian form
            
            // PUBLICKEYSTRUC
            pPubKeyStruc->bType = PUBLICKEYBLOB;
            pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
            pPubKeyStruc->reserved = 0;
            pPubKeyStruc->aiKeyAlg = CALG_DSS_SIGN;
            // DSSPUBKEY
            pCspPubKey->magic = DSS1;
            pCspPubKey->bitlen = cbKey * 8;

            // rgbP[cbKey]
            memcpy(pbKey, pDssParameters->p.pbData, cbKey);
            pbKey += cbKey;

            // rgbQ[20]
            cb = pDssParameters->q.cbData;
            if (0 == cb || cb > DSS_Q_LEN)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->q.pbData, cb);
            if (DSS_Q_LEN > cb)
                memset(pbKey + cb, 0, DSS_Q_LEN - cb);
            pbKey += DSS_Q_LEN;

            // rgbG[cbKey]
            cb = pDssParameters->g.cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->g.pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // rgbY[cbKey]
            cb = pDssPubKey->cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssPubKeyError;
            memcpy(pbKey, pDssPubKey->pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
            pCspSeed = (DSSSEED *) pbKey;
            memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));
        }
    }

CommonReturn:
    *pcbPubKeyStruc = cbPubKeyStruc;
    PkiFree(pDssParameters);
    PkiFree(pDssPubKey);
    return fResult;
            
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyStruc);
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = NULL;
    }
    cbPubKeyStruc = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeParametersError)
TRACE_ERROR(DecodePubKeyError)
#ifdef CMS_PKCS7
SET_ERROR(NoDssParametersError, CRYPT_E_MISSING_PUBKEY_PARA)
#else
SET_ERROR(NoDssParametersError, E_INVALIDARG)
#endif  // CMS_PKCS7
SET_ERROR(InvalidDssParametersError, E_INVALIDARG)
SET_ERROR(InvalidDssPubKeyError, E_INVALIDARG)
}

#ifndef DH3
#define DH3 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'3'<<24))
#endif

//+-------------------------------------------------------------------------
//  Encode the RSA DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSADHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    BYTE *pbKey;

    CERT_DH_PARAMETERS DhParameters;
    CRYPT_UINT_BLOB DhPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]     -- not used in RSA_DH
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]     -- not used in RSA_DH
    //  - rgbY[cbP]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    cbP = pCspPubKey->bitlenP / 8;
    cbQ = pCspPubKey->bitlenQ / 8;
    cbJ = pCspPubKey->bitlenJ / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3 + cbQ + cbJ)
        goto InvalidArg;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;
    if (pCspPubKey->magic != DH3)
        goto InvalidArg;

    assert(cbP > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP * 3 + cbQ + cbJ);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);

    //assert(pPubKeyStruc->bVersion == 3);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DH_SF ||
        pPubKeyStruc->aiKeyAlg == CALG_DH_EPHEM);
    assert(pCspPubKey->magic == DH3);
    assert(pCspPubKey->bitlenP % 8 == 0);
    assert(pCspPubKey->bitlenQ % 8 == 0);
    assert(pCspPubKey->bitlenJ % 8 == 0);

    // Initialize the RSA DH Parameters from CSP data structure
    DhParameters.p.pbData = pbKey;
    DhParameters.p.cbData = cbP;
    pbKey += cbP;

    // No RSA DH Q parameter
    pbKey += cbQ;

    DhParameters.g.pbData = pbKey;
    DhParameters.g.cbData = cbP;
    pbKey += cbP;

    // No RSA DH J parameter
    pbKey += cbJ;

    // Initialize DH public key from CSP data structure
    DhPubKey.cbData = cbP;
    DhPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PARAMETERS,
            &DhParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PUBLICKEY,
            &DhPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Encode the X942 DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeX942DHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    BYTE *pbKey;

    CERT_X942_DH_PARAMETERS DhParameters;
    CERT_X942_DH_VALIDATION_PARAMS DhValidationParams;
    CRYPT_UINT_BLOB DhPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]
    //  - rgbY[cbP]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    cbP = pCspPubKey->bitlenP / 8;
    cbQ = pCspPubKey->bitlenQ / 8;
    cbJ = pCspPubKey->bitlenJ / 8;

    if (0 == cbQ)
        return EncodeRSADHPublicKeyAndParameters(
            dwCertEncodingType,
            pszPubKeyOID,
            pPubKeyStruc,
            cbPubKeyStruc,
            dwFlags,
            pvReserved,
            ppbEncodedPubKey,
            pcbEncodedPubKey,
            ppbEncodedParameters,
            pcbEncodedParameters
            );

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3 + cbQ + cbJ)
        goto InvalidArg;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;
    if (pCspPubKey->magic != DH3)
        goto InvalidArg;

    assert(cbP > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP * 3 + cbQ + cbJ);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);

    //assert(pPubKeyStruc->bVersion == 3);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DH_SF ||
        pPubKeyStruc->aiKeyAlg == CALG_DH_EPHEM);
    assert(pCspPubKey->magic == DH3);
    assert(pCspPubKey->bitlenP % 8 == 0);
    assert(pCspPubKey->bitlenQ % 8 == 0);
    assert(pCspPubKey->bitlenJ % 8 == 0);

    // Initialize the X942 DH Parameters from CSP data structure
    DhParameters.p.pbData = pbKey;
    DhParameters.p.cbData = cbP;
    pbKey += cbP;

    DhParameters.q.pbData = pbKey;
    DhParameters.q.cbData = cbQ;
    pbKey += cbQ;

    DhParameters.g.pbData = pbKey;
    DhParameters.g.cbData = cbP;
    pbKey += cbP;

    DhParameters.j.pbData = pbKey;
    DhParameters.j.cbData = cbJ;
    pbKey += cbJ;

    if (0xFFFFFFFF == pCspPubKey->DSSSeed.counter ||
            0 == pCspPubKey->DSSSeed.counter)
        DhParameters.pValidationParams = NULL;
    else {
        DhParameters.pValidationParams = &DhValidationParams;
        DhValidationParams.pgenCounter = pCspPubKey->DSSSeed.counter;
        DhValidationParams.seed.pbData = pCspPubKey->DSSSeed.seed;
        DhValidationParams.seed.cbData = sizeof(pCspPubKey->DSSSeed.seed);
        DhValidationParams.seed.cUnusedBits = 0;
    }

    // Initialize DH public key from CSP data structure
    DhPubKey.cbData = cbP;
    DhPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X942_DH_PARAMETERS,
            &DhParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PUBLICKEY,
            &DhPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}


#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

// Convert a DH1 PublicKey Struc, to a DH3 PublicKey Struc by getting
// the P and G parameters from the hPubKey.
static BOOL ConvertDh1ToDh3PublicKeyStruc(
    IN HCRYPTKEY hPubKey,
    IN OUT PUBLICKEYSTRUC **ppPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PUBLICKEYSTRUC *pDh1PubKeyStruc = *ppPubKeyStruc;
    BYTE *pbDh1KeyBlob;
    DHPUBKEY *pDh1CspPubKey;
    BYTE *pbDh1Key;

    PUBLICKEYSTRUC *pDh3PubKeyStruc = NULL;
    DWORD cbDh3PubKeyStruc;
    BYTE *pbDh3KeyBlob;
    DHPUBKEY_VER3 *pDh3CspPubKey;
    BYTE *pbDh3Key;
    DWORD cbP;
    DWORD cbData;

    // The DH1 CAPI public key representation consists of the following
    // sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbP]
    pbDh1KeyBlob = (BYTE *) pDh1PubKeyStruc;
    pDh1CspPubKey = (DHPUBKEY *) (pbDh1KeyBlob + sizeof(PUBLICKEYSTRUC));
    pbDh1Key = pbDh1KeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);

    if (pDh1CspPubKey->magic != DH1)
        return TRUE;
    cbP = pDh1CspPubKey->bitlen / 8;
    if (*pcbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbP)
        goto InvalidArg;

    // The DH3 CAPI public key representation consists of the following
    // sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]     -- will be omitted here
    //  - rgbG[cbP]
    //  - rgbJ[cbJ]     -- will be omitted here
    //  - rgbY[cbP]
    cbDh3PubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
            cbP * 3;
    if (NULL == (pDh3PubKeyStruc = (PUBLICKEYSTRUC *) PkiZeroAlloc(
            cbDh3PubKeyStruc)))
        goto OutOfMemory;

    pbDh3KeyBlob = (BYTE *) pDh3PubKeyStruc;
    pDh3CspPubKey = (DHPUBKEY_VER3 *) (pbDh3KeyBlob + sizeof(PUBLICKEYSTRUC));
    pbDh3Key = pbDh3KeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    pDh3PubKeyStruc->bType = PUBLICKEYBLOB;
    pDh3PubKeyStruc->bVersion = 3;
    pDh3PubKeyStruc->aiKeyAlg = CALG_DH_SF;
    pDh3CspPubKey->magic = DH3;
    pDh3CspPubKey->bitlenP = cbP * 8;
    //pDh3CspPubKey->bitlenQ = 0;
    //pDh3CspPubKey->bitlenJ  = 0;

    // Get the P parameter from the public key
    cbData = cbP;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_P,
            pbDh3Key,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbP)
        goto GetPError;
    pbDh3Key += cbP;

    // No Q parameter

    // Get G parameter from the public key
    cbData = cbP;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_G,
            pbDh3Key,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbP)
        goto GetGError;
    pbDh3Key += cbP;

    // No J parameter

    // Y
    memcpy(pbDh3Key, pbDh1Key, cbP);

    assert(pbDh3Key - pbDh3KeyBlob + cbP == cbDh3PubKeyStruc);

    PkiFree(pDh1PubKeyStruc);
    *ppPubKeyStruc = pDh3PubKeyStruc;
    *pcbPubKeyStruc = cbDh3PubKeyStruc;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    PkiFree(pDh3PubKeyStruc);
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetPError)
TRACE_ERROR(GetGError)
}

//+=========================================================================
//  CryptExportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Use the aiKeyAlg in the public key structure exported by the CSP to
//  determine how to encode the public key.
//
//  The dwFlags and pvAuxInfo aren't used.
//--------------------------------------------------------------------------
static BOOL WINAPI ExportCspPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    DWORD dwErr;
    HCRYPTKEY hPubKey = 0;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (!CryptGetUserKey(
            hCryptProv,
            dwKeySpec,
            &hPubKey
            )) {
        hPubKey = 0;
        goto GetUserKeyError;
    }

    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) PkiNonzeroAlloc(
            cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;

    if (CALG_DH_SF == pPubKeyStruc->aiKeyAlg ||
            CALG_DH_EPHEM == pPubKeyStruc->aiKeyAlg) {
        DWORD cbDh3PubKeyStruc;
        PUBLICKEYSTRUC *pDh3PubKeyStruc;

        // Check if the CSP supports DH3
        cbDh3PubKeyStruc = 0;
        if (!CryptExportKey(
                hPubKey,
                0,              // hPubKey
                PUBLICKEYBLOB,
                CRYPT_BLOB_VER3,
                NULL,           // pbData
                &cbDh3PubKeyStruc
                ) || (cbDh3PubKeyStruc == 0)) {
            // Convert DH1 to DH3 by getting and adding the P and G
            // parameters
            if (!ConvertDh1ToDh3PublicKeyStruc(
                    hPubKey,
                    &pPubKeyStruc,
                    &cbPubKeyStruc
                    ))
                goto ConvertDh1ToDh3PublicKeyStrucError;
        } else {
            if (NULL == (pDh3PubKeyStruc = (PUBLICKEYSTRUC *) PkiNonzeroAlloc(
                    cbDh3PubKeyStruc)))
                goto OutOfMemory;
            if (!CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    CRYPT_BLOB_VER3,
                    (BYTE *) pDh3PubKeyStruc,
                    &cbDh3PubKeyStruc
                    )) {
                PkiFree(pDh3PubKeyStruc);
                goto ExportPublicKeyBlobError;
            }

            PkiFree(pPubKeyStruc);
            pPubKeyStruc = pDh3PubKeyStruc;
            cbPubKeyStruc = cbDh3PubKeyStruc;
        }

        if (NULL == pszPublicKeyObjId) {
            DHPUBKEY_VER3 *pDh3CspPubKey;

            // The CAPI public key representation consists of the
            // following sequence:
            //  - PUBLICKEYSTRUC
            //  - DHPUBKEY_VER3
            //  - rgbP[cbP]
            //  - rgbQ[cbQ]     -- not used in szOID_RSA_DH
            //  - rgbG[cbP]
            //  - rgbJ[cbJ]     -- not used in szOID_RSA_DH
            //  - rgbY[cbP]
            pDh3CspPubKey = (DHPUBKEY_VER3 *)
                ((BYTE*) pPubKeyStruc + sizeof(PUBLICKEYSTRUC));

            if (DH3 == pDh3CspPubKey->magic && 0 == pDh3CspPubKey->bitlenQ)
                // szOID_RSA_DH indicates no Q parameter
                pszPublicKeyObjId = szOID_RSA_DH;
        }
    }

    fResult = CryptCreatePublicKeyInfo(
        dwCertEncodingType,
        pszPublicKeyObjId,
        pPubKeyStruc,
        cbPubKeyStruc,
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        pInfo,
        pcbInfo
        );

CommonReturn:
    dwErr = GetLastError();
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    PkiFree(pPubKeyStruc);
    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetUserKeyError)
TRACE_ERROR(ExportPublicKeyBlobError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ConvertDh1ToDh3PublicKeyStrucError)
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Uses the dwCertEncodingType and pszPublicKeyObjId to call the
//  installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptExportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszPublicKeyObjId,
//  attempts to export via the default export function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (pszPublicKeyObjId && CryptGetOIDFunctionAddress(
            hExportPubKeyFuncSet,
            dwCertEncodingType,
            pszPublicKeyObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_EXPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        // Attempt to export via the default function that looks at the
        // public key algorithm in the public key struc exported by the CSP.
        fResult = ExportCspPublicKeyInfoEx(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
    return fResult;
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Calls CryptExportPublicKeyInfoEx with pszPublicKeyObjId = NULL,
//  dwFlags = 0 and pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    return CryptExportPublicKeyInfoEx(
        hCryptProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,                           // pszPublicKeyObjId
        0,                              // dwFlags
        NULL,                           // pvAuxInfo
        pInfo,
        pcbInfo
        );
}

//+=========================================================================
//  CryptImportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
//  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptImportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszObjId,
//  decodes the PublicKeyInfo into a CSP PublicKey Blob and imports.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (CryptGetOIDFunctionAddress(
            hImportPubKeyFuncSet,
            dwCertEncodingType,
            pInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_IMPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwCertEncodingType,
            pInfo,
            aiKeyAlg,
            dwFlags,
            pvAuxInfo,
            phKey
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        if (!CryptConvertPublicKeyInfo(
                dwCertEncodingType,
                pInfo,
                CRYPT_ALLOC_FLAG,
                NULL,                   // pvReserved
                (void *) &pPubKeyStruc,
                &cbPubKeyStruc
                ))
            goto ConvertPublicKeyInfoError;

        if (aiKeyAlg)
            pPubKeyStruc->aiKeyAlg = aiKeyAlg;

        if (!CryptImportKey(
                hCryptProv,
                (BYTE *) pPubKeyStruc,
                cbPubKeyStruc,
                NULL,           // hImpKey
                0,              // dwFlags
                phKey
                ))
            goto ImportKeyError;
        fResult = TRUE;
    }

CommonReturn:
    PkiDefaultCryptFree(pPubKeyStruc);
    return fResult;
ErrorReturn:
    *phKey = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ConvertPublicKeyInfoError)
TRACE_ERROR(ImportKeyError)
}

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and
//  pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT HCRYPTKEY *phKey
    )
{
    return CryptImportPublicKeyInfoEx(
        hCryptProv,
        dwCertEncodingType,
        pInfo,
        0,                      // aiKeyAlg
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        phKey
        );
}

//+-------------------------------------------------------------------------
//  Create a KeyIdentifier from the CSP Public Key Blob.
//
//  Converts the CSP PUBLICKEYSTRUC into a X.509 CERT_PUBLIC_KEY_INFO and
//  encodes. The encoded CERT_PUBLIC_KEY_INFO is SHA1 hashed to obtain
//  the Key Identifier.
//
//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptCreateKeyIdentifierFromCSP(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    DWORD cbInfo;

    if (!CryptCreatePublicKeyInfo(
            dwCertEncodingType,
            pszPubKeyOID,
            pPubKeyStruc,
            cbPubKeyStruc,
            CRYPT_ALLOC_FLAG,
            NULL,                   // pvReserved
            (void *) &pInfo,
            &cbInfo
            ))
        goto CreatePublicKeyInfoError;

    fResult = CryptHashPublicKeyInfo(
            NULL,                   // hCryptProv
            CALG_SHA1,
            0,                      // dwFlags
            dwCertEncodingType,
            pInfo,
            pbHash,
            pcbHash
            );

CommonReturn:
    PkiDefaultCryptFree(pInfo);
    return fResult;

ErrorReturn:
    *pcbHash = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreatePublicKeyInfoError)
}


//+=========================================================================
//  DefaultContext APIs and Data Structures
//-=========================================================================

static BOOL InstallThreadDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    PDEFAULT_CONTEXT pNext;
    pNext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
    if (pNext) {
        pDefaultContext->pNext = pNext;
        pNext->pPrev = pDefaultContext;
    }

    fHasThreadDefaultContext = TRUE;
    return I_CryptSetTls(hTlsDefaultContext, pDefaultContext);
}

static BOOL InstallProcessDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    EnterCriticalSection(&DefaultContextCriticalSection);

    if (pProcessDefaultContextHead) {
        pDefaultContext->pNext = pProcessDefaultContextHead;
        pProcessDefaultContextHead->pPrev = pDefaultContext;
    }
    pProcessDefaultContextHead = pDefaultContext;

    fHasProcessDefaultContext = TRUE;

    LeaveCriticalSection(&DefaultContextCriticalSection);

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Install a previously CryptAcquiredContext'ed HCRYPTPROV to be used as
//  a default context.
//
//  dwDefaultType and pvDefaultPara specify where the default context is used.
//  For example, install the HCRYPTPROV to be used to verify certificate's
//  having szOID_OIWSEC_md5RSA signatures.
//
//  By default, the installed HCRYPTPROV is only applicable to the current
//  thread. Set CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG to allow the HCRYPTPROV 
//  to be used by all threads in the current process.
//
//  For a successful install, TRUE is returned and *phDefaultContext is
//  updated with the HANDLE to be passed to CryptUninstallDefaultContext.
//
//  The installed HCRYPTPROVs are stack ordered (the last installed
//  HCRYPTPROV is checked first). All thread installed HCRYPTPROVs are
//  checked before any process HCRYPTPROVs.
//
//  The installed HCRYPTPROV remains available for default usage until
//  CryptUninstallDefaultContext is called or the thread or process exits.
//
//  If CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG is set, then, the HCRYPTPROV
//  is CryptReleaseContext'ed at thread or process exit. However,
//  not CryptReleaseContext'ed if CryptUninstallDefaultContext is
//  called.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallDefaultContext(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{
    BOOL fResult;
    CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA MultiOIDPara;
    LPSTR rgpszOID[1];
    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pMultiOIDPara;

    PDEFAULT_CONTEXT pDefaultContext = NULL;
    DWORD cbDefaultContext;
    BYTE *pbExtra;
    DWORD cbExtra;
    
    if (CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID == dwDefaultType) {
        dwDefaultType = CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID;
        if (pvDefaultPara) {
            rgpszOID[0] = (LPSTR) pvDefaultPara;
            MultiOIDPara.cOID = 1;
            MultiOIDPara.rgpszOID = rgpszOID;
            pvDefaultPara = (const void *) &MultiOIDPara;
        }
    }

    if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID != dwDefaultType)
        goto InvalidArg;

    pMultiOIDPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pvDefaultPara;
    if (pMultiOIDPara) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        if (0 == cOID)
            goto InvalidArg;
        cbExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA)) +
            cOID * sizeof(LPSTR);

        for ( ; cOID; cOID--, ppszOID++)
            cbExtra += strlen(*ppszOID) + 1;
    } else {
        if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
            goto InvalidArg;
        cbExtra = 0;
    }

    cbDefaultContext = INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT)) + cbExtra;

    if (NULL == (pDefaultContext = (PDEFAULT_CONTEXT) PkiZeroAlloc(
            cbDefaultContext)))
        goto OutOfMemory;

    pDefaultContext->hCryptProv = hCryptProv;
    pDefaultContext->dwDefaultType = dwDefaultType;
    pDefaultContext->dwFlags = dwFlags;

    pbExtra = ((BYTE *) pDefaultContext) +
        INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT));

    if (cbExtra) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara;
        LPSTR *ppszOIDDefault;

        assert(cOID);

        pOIDDefaultPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pbExtra;
        pDefaultContext->pOIDDefaultPara = pOIDDefaultPara;
        pbExtra += INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA));

        ppszOIDDefault = (LPSTR *) pbExtra;
        pbExtra += cOID * sizeof(LPSTR);
        pOIDDefaultPara->cOID = cOID;
        pOIDDefaultPara->rgpszOID = ppszOIDDefault;

        for ( ; cOID; cOID--, ppszOID++, ppszOIDDefault++) {
            DWORD cch = strlen(*ppszOID) + 1;

            memcpy(pbExtra, *ppszOID, cch);
            *ppszOIDDefault = (LPSTR) pbExtra;
            pbExtra += cch;
        }
    }
    assert(pbExtra == ((BYTE *) pDefaultContext) + cbDefaultContext);

    if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
        fResult = InstallProcessDefaultContext(pDefaultContext);
    else
        fResult = InstallThreadDefaultContext(pDefaultContext);
    if (!fResult)
        goto ErrorReturn;

CommonReturn:
    *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
    return fResult;

ErrorReturn:
    PkiFree(pDefaultContext);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Uninstall a default context previously installed by
//  CryptInstallDefaultContext.
//
//  For a default context installed with CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG
//  set, if any other threads are currently using this context,
//  this function will block until they finish.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUninstallDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;
    PDEFAULT_CONTEXT pDefaultContextHead;
    BOOL fProcess;

    if (NULL == pDefaultContext)
        return TRUE;

    fProcess = (pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    if (fProcess) {
        EnterCriticalSection(&DefaultContextCriticalSection);
        pDefaultContextHead = pProcessDefaultContextHead;
    } else { 
        pDefaultContextHead = (PDEFAULT_CONTEXT) I_CryptGetTls(
            hTlsDefaultContext);
    }

    if (NULL == pDefaultContextHead)
        goto InvalidArg;

    // Remove context from the list
    if (pDefaultContext->pNext)
        pDefaultContext->pNext->pPrev = pDefaultContext->pPrev;
    if (pDefaultContext->pPrev)
        pDefaultContext->pPrev->pNext = pDefaultContext->pNext;
    else if (pDefaultContext == pDefaultContextHead) {
        pDefaultContextHead = pDefaultContext->pNext;
        if (fProcess)
            pProcessDefaultContextHead = pDefaultContextHead;
        else
            I_CryptSetTls(hTlsDefaultContext, pDefaultContextHead);
    } else
        goto InvalidArg;

    if (fProcess) {
        if (pDefaultContext->lRefCnt) {
            // Wait for all uses of the hCryptProv handle to finish
            if (NULL == (pDefaultContext->hWait = CreateEvent(
                    NULL,       // lpsa
                    FALSE,      // fManualReset
                    FALSE,      // fInitialState
                    NULL))) {   // lpszEventName
                assert(pDefaultContext->hWait);
                goto UnexpectedError;
            }
                
            while (pDefaultContext->lRefCnt) {
                LeaveCriticalSection(&DefaultContextCriticalSection);
                WaitForSingleObject(pDefaultContext->hWait, INFINITE);
                EnterCriticalSection(&DefaultContextCriticalSection);
            }
            CloseHandle(pDefaultContext->hWait);
            pDefaultContext->hWait = NULL;
        }
    }

    PkiFree(pDefaultContext);
    fResult = TRUE;

CommonReturn:
    if (fProcess)
        LeaveCriticalSection(&DefaultContextCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}


static PDEFAULT_CONTEXT FindDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    for ( ; pDefaultContext; pDefaultContext = pDefaultContext->pNext) {
        switch (dwDefaultType) {
            case CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID:
                if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID ==
                        pDefaultContext->dwDefaultType) {
                    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara =
                        pDefaultContext->pOIDDefaultPara;
                    DWORD cOID;
                    LPSTR *ppszOID;

                    if (NULL == pOIDDefaultPara)
                        return pDefaultContext;

                    cOID = pOIDDefaultPara->cOID;
                    ppszOID = pOIDDefaultPara->rgpszOID;
                    for ( ; cOID; cOID--, ppszOID++) {
                        if (0 == strcmp(*ppszOID, (LPSTR) pvDefaultPara))
                            return pDefaultContext;
                    }
                }
                break;
            default:
                return NULL;
        }
    }

    return NULL;
}

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{

    if (fHasThreadDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        pDefaultContext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pDefaultContext
                )) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = NULL;
            return TRUE;
        }
    }

    if (fHasProcessDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        EnterCriticalSection(&DefaultContextCriticalSection);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pProcessDefaultContextHead
                ))
            pDefaultContext->lRefCnt++;
        LeaveCriticalSection(&DefaultContextCriticalSection);

        if (pDefaultContext) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
            return TRUE;
        }
    }

    *phCryptProv = NULL;
    *phDefaultContext = NULL;
    return FALSE;
}

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;

    if (NULL == pDefaultContext)
        return;

    assert(pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    assert(0 < pDefaultContext->lRefCnt);

    EnterCriticalSection(&DefaultContextCriticalSection);
    if (0 == --pDefaultContext->lRefCnt && pDefaultContext->hWait)
        SetEvent(pDefaultContext->hWait);
    LeaveCriticalSection(&DefaultContextCriticalSection);
}


#ifdef CMS_PKCS7

WINCRYPT32API
BOOL
WINAPI
CryptVerifyCertificateSignatureEx(
    IN OPTIONAL HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN DWORD dwIssuerType,
    IN void *pvIssuer,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    DWORD cbSignedInfo;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwProvType;
    HCRYPTPROV hAcquiredCryptProv = 0;
    DWORD dwSignFlags;
    DWORD dwErr;

    const BYTE *pbEncoded;  // not allocated
    DWORD cbEncoded;
    PCERT_PUBLIC_KEY_INFO pIssuerPubKeyInfo;
    CERT_PUBLIC_KEY_INFO IssuerPubKeyInfo;
    PCRYPT_OBJID_BLOB pIssuerPara;
    BYTE *pbAllocIssuerPara = NULL;

    switch (dwSubjectType) {
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB:
            {
                PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB) pvSubject;
                pbEncoded = pBlob->pbData;
                cbEncoded = pBlob->cbData;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT:
            {
                PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCertEncoded;
                cbEncoded = pSubject->cbCertEncoded;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL:
            {
                PCCRL_CONTEXT pSubject = (PCCRL_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCrlEncoded;
                cbEncoded = pSubject->cbCrlEncoded;
            }
            break;
        default:
            goto InvalidSubjectType;
    }
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG,
            &PkiDecodePara,
            (void *) &pSignedInfo,
            &cbSignedInfo
            )) goto DecodeCertError;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags, &dwProvType))
        goto GetSignOIDInfoError;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (dwProvType && CryptAcquireContext(
                    &hCryptProv,
                    NULL,               // pszContainer
                    NULL,               // pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    ))
                hAcquiredCryptProv = hCryptProv;
            else if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto GetDefaultCryptProvError;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    switch (dwIssuerType) {
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY:
            pIssuerPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvIssuer;
            break;
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvIssuer;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvIssuer =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwIssuerType = CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT;
            }
            // fall through
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvIssuer;

                pIssuerPubKeyInfo = &pIssuer->pCertInfo->SubjectPublicKeyInfo;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
                if (0 == pIssuerPara->cbData ||
                        NULL_ASN_TAG == *pIssuerPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocIssuerPara = (BYTE *) PkiNonzeroAlloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocIssuerPara,
                            &cbData)) {

                        IssuerPubKeyInfo = *pIssuerPubKeyInfo;
                        IssuerPubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocIssuerPara;
                        IssuerPubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pIssuerPubKeyInfo = &IssuerPubKeyInfo;
                    }
                }
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL:
            if (CALG_NO_SIGN != aiPubKey)
                goto InvalidIssuerType;
            pIssuerPubKeyInfo = NULL;
            break;
        default:
            goto InvalidIssuerType;
    }

    if (CALG_NO_SIGN == aiPubKey) {
        if (dwIssuerType != CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL)
            goto InvalidIssuerType;
    } else {
        if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pIssuerPubKeyInfo,
                &hSignKey
                )) goto ImportPublicKeyInfoError;
    }
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto CreateHashError;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto HashDataError;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;

    if (0 == cbSignature)
        goto NoSignatureError;

    if (CALG_NO_SIGN == aiPubKey) {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = sizeof(rgbHash);

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbHash,
                &cbHash,
                0                   // dwFlags
                ))
            goto GetHashValueError;

        if (cbHash != cbSignature || 0 != memcmp(rgbHash, pbSignature, cbHash))
            goto NoSignHashCompareError;

        goto SuccessReturn;
    }

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeDssSignatureError;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    } else 
        PkiAsn1ReverseBytes(pbSignature, cbSignature);

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto VerifySignatureError;


    // For a certificate context certificate, check if the issuer has public
    // key parameters that can be inherited
    pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
    if (CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT == dwSubjectType &&
            pIssuerPara->cbData && NULL_ASN_TAG != *pIssuerPara->pbData) {
        // If a subject is missing its public key parameters and has
        // the same public key algorithm as its issuer, then, set
        // its CERT_PUBKEY_ALG_PARA_PROP_ID property.

        PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
        PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo =
            &pSubject->pCertInfo->SubjectPublicKeyInfo;
        PCCRYPT_OID_INFO pOIDInfo;
        PCRYPT_OBJID_BLOB pSubjectPara;
        DWORD cbData;

        pSubjectPara = &pSubjectPubKeyInfo->Algorithm.Parameters;
        if (pSubjectPara->cbData && NULL_ASN_TAG != *pSubjectPara->pbData)
            // Subject public key has parameters
            goto SuccessReturn;

        if (CertGetCertificateContextProperty(
                pSubject,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData)
            // Subject already has public key parameters property
            goto SuccessReturn;

        pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pSubjectPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (NULL == pOIDInfo || aiPubKey != pOIDInfo->Algid)
            // Subject and issuer don't have the same public key algorithms
            goto SuccessReturn;

        CertSetCertificateContextProperty(
            pSubject,
            CERT_PUBKEY_ALG_PARA_PROP_ID,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            pIssuerPara
            );
    }
    

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    if (hAcquiredCryptProv)
        CryptReleaseContext(hAcquiredCryptProv, 0);
    PkiFree(pSignedInfo);
    PkiFree(pbAllocIssuerPara);

    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(DecodeCertError)
TRACE_ERROR(GetSignOIDInfoError)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(InvalidIssuerType, E_INVALIDARG)
TRACE_ERROR(ImportPublicKeyInfoError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
SET_ERROR(NoSignatureError, TRUST_E_NOSIGNATURE)
TRACE_ERROR(GetHashValueError)
SET_ERROR(NoSignHashCompareError, NTE_BAD_SIGNATURE)
TRACE_ERROR(DecodeDssSignatureError)
TRACE_ERROR(VerifySignatureError)
}

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    CRYPT_DATA_BLOB Subject;

    Subject.cbData = cbEncoded;
    Subject.pbData = (BYTE *) pbEncoded;
    return CryptVerifyCertificateSignatureEx(
        hCryptProv,
        dwCertEncodingType,
        CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
        (void *) &Subject,
        CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY,
        (void *) pPublicKey,
        0,                                      // dwFlags
        NULL                                    // pvReserved
        );
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\dblog.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dblog.h
//
//  Contents:   Public functions in dblog.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPT32_DBLOG_H__
#define __CRYPT32_DBLOG_H__

//+=========================================================================
//  crypt32 Database Event Logging Functions
//==========================================================================
void
I_DBLogAttach();

void
I_DBLogDetach();

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    );

#endif  // __CRYPT32_DBLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\certstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certstr.cpp
//
//  Contents:   Certificate String and Unicode Helper APIs
//
//  Functions:
//              CertRDNValueToStrA
//              CertRDNValueToStrW
//              UnicodeNameValueEncodeEx
//              UnicodeNameValueDecodeEx
//              UnicodeNameInfoEncodeEx
//              UnicodeNameInfoDecodeEx
//              CertNameToStrW
//              CertNameToStrA
//              CertStrToNameW
//              CertStrToNameA
//              CertGetNameStringW
//              CertGetNameStringA
//
//  Note:
//      Linked into xenroll.dll. xenroll.dll must be able to work with
//      crypt32.dll 3.02 which doesn't export CryptEncodeObjectEx.
//      xenroll.dll only calls CertNameToStrW.
//
//  History:    24-Mar-96   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

// Unicode Surrogate Pairs map to Universal characters as follows:
//     D800 -    DBFF : 0000 0000 0000 0000 1101 10YY YYYY YYYY  (10 Bits)
//     DC00 -    DFFF : 0000 0000 0000 0000 1101 11XX XXXX XXXX  (10 Bits)
//
//     10000 - 10FFFF : 0000 0000 0000 YYYY YYYY YYXX XXXX XXXX  (20 Bits)
//                                      +
//                      0000 0000 0000 0001 0000 0000 0000 0000

// Unicode Surrogate Pair Character ranges
#define UNICODE_HIGH_SURROGATE_START        0xD800
#define UNICODE_HIGH_SURROGATE_END          0xDBFF
#define UNICODE_LOW_SURROGATE_START         0xDC00
#define UNICODE_LOW_SURROGATE_END           0xDFFF

// Any Universal characters > 10FFFF map to the following Unicode character
#define UNICODE_REPLACEMENT_CHAR            0xFFFD

// Universal Surrogate Character ranges
#define UNIVERSAL_SURROGATE_START       0x00010000
#define UNIVERSAL_SURROGATE_END         0x0010FFFF

//+-------------------------------------------------------------------------
//  Maps an ASN.1 8 bit character string to a new wide-character (Unicode).
//
//  If fDisableIE4UTF8 isn't set, the 8 bit character string is initially
//  processed as UTF-8 encoded characters.
//
//  If fDisableIE4UTF8 is set or the UTF-8 conversion fails, converts to
//  wide characters by doing a WCHAR cast.
//--------------------------------------------------------------------------
static int WINAPI Asn1ToWideChar(
    IN LPCSTR lp8BitStr,
    IN int cch8Bit,
    IN BOOL fDisableIE4UTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchOutWideChar;

    if (!fDisableIE4UTF8) {
        int cchUTF8WideChar;

        cchUTF8WideChar = UTF8ToWideChar(
            lp8BitStr,
            cch8Bit,
            lpWideCharStr,
            cchWideChar
            );
        if (0 < cchUTF8WideChar)
            return cchUTF8WideChar;
    }

    if (cch8Bit < 0)
        cch8Bit = strlen(lp8BitStr) + 1;
    cchOutWideChar = cch8Bit;

    if (cchWideChar < 0)
        goto InvalidParameter;
    else if (0 == cchWideChar)
        goto CommonReturn;
    else if (cchOutWideChar > cchWideChar)
        goto InsufficientBuffer;

    while (cch8Bit--)
        *lpWideCharStr++ = (unsigned char) *lp8BitStr++;

CommonReturn:
    return cchOutWideChar;

ErrorReturn:
    cchOutWideChar = 0;
    goto CommonReturn;
SET_ERROR(InvalidParameter, ERROR_INVALID_PARAMETER)
SET_ERROR(InsufficientBuffer, ERROR_INSUFFICIENT_BUFFER)
}

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new ASN.1 8 bit character
//  string.
//--------------------------------------------------------------------------
static inline void WideCharToAsn1(
    IN LPCWSTR lpWideCharStr,
    IN DWORD cchWideChar,
    OUT LPSTR lp8BitStr
    )
{
    while (cchWideChar--)
        *lp8BitStr++ = (unsigned char) (*lpWideCharStr++ & 0xFF);
}

static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    cbStructInfo = 0;
    goto CommonReturn;
}

typedef BOOL (WINAPI *PFN_NESTED_DECODE_INFO_EX_CALLBACK)(
    IN void *pvDecodeInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

static BOOL WINAPI NestedDecodeAndAllocInfoEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_NESTED_DECODE_INFO_EX_CALLBACK pfnDecodeInfoExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;
    void *pvDecodeInfo = NULL;
    DWORD cbDecodeInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvDecodeInfo,
            &cbDecodeInfo
            )) goto DecodeObjectError;

    if (!pfnDecodeInfoExCallback(
            pvDecodeInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeInfoExCallback(
                pvDecodeInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo -= (DWORD) lRemainExtra;
    } else {
        cbStructInfo += (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    PkiFree(pvDecodeInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeObjectError)
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated char string
//
//  Returns the number of bytes converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrA(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (psz == NULL)
        csz = 0;

    cwsz = CertRDNValueToStrW(
        dwValueType,
        pValue,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR))) {
        CertRDNValueToStrW(
            dwValueType,
            pValue,
            pwsz,
            cwsz
            );

        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;

        PkiFree(pwsz);
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}


DWORD
WINAPI
GetSurrogatePairCountFromUniversalString(
    IN DWORD *pdw,
    IN DWORD cdw
    )
{
    DWORD cSP = 0;

    for ( ; cdw > 0; cdw--, pdw++) {
        DWORD dw = *pdw;
        if (dw >= UNIVERSAL_SURROGATE_START &&
                dw <= UNIVERSAL_SURROGATE_END)
            cSP++;
    }

    return cSP;
}

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated WCHAR string
//
//  Returns the number of WCHARs converted including the terminating null
//  WCHAR. If pwsz is NULL or cwsz is 0, returns the required size of the
//  destination string (including the terminating null WCHAR).
//
//  If pwsz != NULL && cwsz != 0, returned pwsz is always NULL terminated.
//
//  Note: cwsz includes the NULL WCHAR.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrW(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    BOOL fDisableIE4UTF8;
    DWORD cwszOut = 0;

    if (pwsz == NULL)
        cwsz = 0;

    fDisableIE4UTF8 = (0 != (dwValueType & CERT_RDN_DISABLE_IE4_UTF8_FLAG));
    dwValueType &= CERT_RDN_TYPE_MASK;

    if (dwValueType == CERT_RDN_UNICODE_STRING ||
            dwValueType == CERT_RDN_UTF8_STRING) {
        cwszOut = pValue->cbData / sizeof(WCHAR);
        if (cwsz > 0) {
            cwszOut = min(cwszOut, cwsz - 1);
            if (cwszOut)
                memcpy((BYTE *) pwsz, pValue->pbData, cwszOut * sizeof(WCHAR));
        }
    } else if (dwValueType == CERT_RDN_UNIVERSAL_STRING) {
        // 4 byte string. Characters < 0x10000 are converted directly to
        // Unicode. Characters within 0x10000 .. 0x10FFFF are mapped
        // to a surrogate pair. Any character > 0x10FFFF is mapped to
        // the replacement character, 0xFFFD.
        DWORD *pdwIn = (DWORD *) pValue->pbData;
        DWORD cdwIn = pValue->cbData / sizeof(DWORD);

        cwszOut = cdwIn +
            GetSurrogatePairCountFromUniversalString(pdwIn, cdwIn);
        if (cwsz > 0) {
            DWORD cOut;
            LPWSTR pwszOut;

            cwszOut = min(cwszOut, cwsz - 1);
            cOut = cwszOut;
            pwszOut = pwsz;
            for ( ; cdwIn > 0 && cOut > 0; cdwIn--, cOut--) {
                DWORD dw = *pdwIn++;
                if (dw < UNIVERSAL_SURROGATE_START)
                    *pwszOut++ = (WCHAR) dw;
                else if (dw <= UNIVERSAL_SURROGATE_END) {
                    if (cOut > 1) {
                        // Surrogate pair contains 20 bits.
                        DWORD dw20Bits;

                        dw20Bits = dw - UNIVERSAL_SURROGATE_START;
                        assert(dw20Bits <= 0xFFFFF);
                        *pwszOut++ = (WCHAR) (UNICODE_HIGH_SURROGATE_START +
                            (dw20Bits >> 10));
                        *pwszOut++ = (WCHAR) (UNICODE_LOW_SURROGATE_START +
                            (dw20Bits & 0x3FF));
                        cOut--;
                    } else
                        *pwszOut++ = UNICODE_REPLACEMENT_CHAR;
                } else
                    *pwszOut++ = UNICODE_REPLACEMENT_CHAR;
            }
        }
    } else {
        // Treat as a 8 bit character string
        if (cwsz != 1) {
            int cchWideChar;

            if (cwsz == 0)
                cchWideChar = 0;
            else
                cchWideChar = cwsz - 1;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pValue->pbData,
                pValue->cbData,
                fDisableIE4UTF8,
                pwsz,
                cchWideChar
                );
            if (cchWideChar <= 0)
                cwszOut = 0;
            else
                cwszOut = (DWORD) cchWideChar;
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *(pwsz + cwszOut) = L'\0';
    }
    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Wide Character functions
//
//  Needed, since we don't link with 'C' runtime
//--------------------------------------------------------------------------
static inline BOOL IsSpaceW(WCHAR wc)
{
    return wc == L' ' || (wc >= 0x09 && wc <= 0x0d);
}
static BOOL IsInStrW(LPCWSTR pwszList, WCHAR wc)
{
    WCHAR wcList;
    while (wcList = *pwszList++)
        if (wc == wcList)
            return TRUE;
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 numeric character
//--------------------------------------------------------------------------
static inline BOOL IsNumericW(WCHAR wc)
{
    return (wc >= L'0' && wc <= L'9') || wc == L' ';
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 printable character
//--------------------------------------------------------------------------
static inline BOOL IsPrintableW(WCHAR wc)
{
    return (wc >= L'A' && wc <= L'Z') || (wc >= L'a' && wc <= L'z') ||
        IsNumericW(wc) || IsInStrW(L"\'()+,-./:=?", wc);
}

//+-------------------------------------------------------------------------
//  Returns 0 if the unicode character string doesn't contain any invalid
//  characters. Otherwise, returns CRYPT_E_INVALID_NUMERIC_STRING,
//  CRYPT_E_INVALID_PRINTABLE_STRING or CRYPT_E_INVALID_IA5_STRING with
//  *pdwErrLocation updated with the index of the first invalid character.
//--------------------------------------------------------------------------
static DWORD CheckUnicodeValueType(
        IN DWORD dwValueType,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD i;
    DWORD dwErr;

    assert(dwValueType & CERT_RDN_TYPE_MASK);
    *pdwErrLocation = 0;

    dwErr = 0;
    for (i = 0; i < cchAttr; i++) {
        WCHAR wc = pwszAttr[i];

        switch (dwValueType & CERT_RDN_TYPE_MASK) {
        case CERT_RDN_NUMERIC_STRING:
            if (!IsNumericW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_NUMERIC_STRING;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            if (!IsPrintableW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING;
            break;
        case CERT_RDN_IA5_STRING:
            if (wc > 0x7F)
                dwErr = (DWORD) CRYPT_E_INVALID_IA5_STRING;
            break;
        default:
            return 0;
        }

        if (0 != dwErr) {
            assert(i <= CERT_UNICODE_VALUE_ERR_INDEX_MASK);
            *pdwErrLocation = i & CERT_UNICODE_VALUE_ERR_INDEX_MASK;
            return dwErr;
        }
    }

    return 0;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value. The values are unicode.
//+-------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN BOOL fDisableCheckType,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        OUT OPTIONAL DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    if (pdwErrLocation)
        *pdwErrLocation = 0;

    dwValueType &= CERT_RDN_TYPE_MASK;

    memset(pDstValue, 0, sizeof(CERT_RDN_VALUE_BLOB));
    if (CERT_RDN_ANY_TYPE == dwValueType)
        goto InvalidArg;
    assert(IS_CERT_RDN_CHAR_STRING(dwValueType));

    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr);

    // Update Destination Value
    if (cchAttr) {
        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
            // Use source. No allocation or copy required
            pDstValue->pbData = (BYTE *) pwszAttr;
            pDstValue->cbData = cchAttr * sizeof(WCHAR);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Update the "low" 16 bits of each 32 bit integer with
            // the UNICODE character. Also handle surrogate pairs.
            {
                DWORD cdw = cchAttr;
                DWORD cbData = cdw * sizeof(DWORD);
                DWORD *pdwDst;
                LPCWSTR pwszSrc = pwszAttr;

                if (NULL == (pdwDst = (DWORD *) PkiNonzeroAlloc(cbData)))
                    goto OutOfMemory;
                pDstValue->pbData = (BYTE *) pdwDst;
                for ( ; cdw > 0; cdw--) {
                    WCHAR wc = *pwszSrc++;
                    WCHAR wc2;

                    if (wc >= UNICODE_HIGH_SURROGATE_START &&
                            wc <= UNICODE_HIGH_SURROGATE_END
                                &&
                            cdw > 1
                                 &&
                            (wc2 = *pwszSrc) >= UNICODE_LOW_SURROGATE_START &&
                            wc2 <= UNICODE_LOW_SURROGATE_END) {
                        pwszSrc++;
                        cdw--;
                        cbData -= sizeof(DWORD);

                        *pdwDst++ =
                            (((DWORD)(wc - UNICODE_HIGH_SURROGATE_START)) << 10)
                                    +
                            ((DWORD)(wc2 - UNICODE_LOW_SURROGATE_START))
                                    +
                            UNIVERSAL_SURROGATE_START;
                    } else
                        *pdwDst++ = ((DWORD) wc) & 0xFFFF;
                }
                pDstValue->cbData = cbData;
            }
            break;
        default:
            // Convert each unicode character to 8 Bit character
            {
                BYTE *pbDst;

                if (pdwErrLocation && !fDisableCheckType) {
                    // Check that the unicode string doesn't contain any
                    // invalid dwValueType characters.
                    if (0 != (dwErr = CheckUnicodeValueType(
                            dwValueType,
                            pwszAttr,
                            cchAttr,
                            pdwErrLocation
                            ))) goto InvalidUnicodeValueType;
                }

                if (NULL == (pbDst = (BYTE *) PkiNonzeroAlloc(cchAttr)))
                    goto OutOfMemory;
                pDstValue->pbData = pbDst;
                pDstValue->cbData = cchAttr;

                WideCharToAsn1(
                    pwszAttr,
                    cchAttr,
                    (LPSTR) pbDst
                    );
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(OutOfMemory)
}

static void FreeUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT PCERT_RDN_VALUE_BLOB pValue
        )
{
    switch (dwValueType & CERT_RDN_TYPE_MASK) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        break;
    default:
        PkiFree(pValue->pbData);
    }
}

static BOOL GetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN DWORD dwFlags,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbData;
    BYTE *pbSrcData;
    BOOL fDisableIE4UTF8;

    // Get Unicode value length
    cbData = pSrcValue->cbData;
    pbSrcData = pSrcValue->pbData;

    fDisableIE4UTF8 =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG));

    assert(0 == (dwValueType & ~CERT_RDN_TYPE_MASK));
    dwValueType &= CERT_RDN_TYPE_MASK;

    switch (dwValueType) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        // The above cbData
        break;
    case CERT_RDN_UNIVERSAL_STRING:
        // 4 byte string. Characters < 0x10000 are converted directly to
        // Unicode. Characters within 0x10000 .. 0x10FFFF are mapped
        // to surrogate pair. Any character > 0x10FFFF is mapped to
        // the replacement character, 0xFFFD.
        cbData = (cbData / 4) * sizeof(WCHAR);
        cbData += GetSurrogatePairCountFromUniversalString(
                (DWORD *) pbSrcData,
                cbData / sizeof(WCHAR)) * sizeof(WCHAR);
        break;
    default:
        // Length of resultant WideChar
        if (cbData) {
            int cchWideChar;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pbSrcData,
                cbData,
                fDisableIE4UTF8,
                NULL,                   // lpWideCharStr
                0                       // cchWideChar
                );
            if (cchWideChar <= 0)
                goto Asn1ToWideCharError;
            cbData = cchWideChar * sizeof(WCHAR);
        }
    }

    // Note, +sizeof(WCHAR) is unicode value's NULL terminator
    lAlignExtra = INFO_LEN_ALIGN(cbData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pDstValue->pbData = pbExtra;
        pDstValue->cbData = cbData;

        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
        case CERT_RDN_ENCODED_BLOB:
        case CERT_RDN_OCTET_STRING:
            if (cbData)
                memcpy(pbExtra, pbSrcData, cbData);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Convert Universal to Unicode. See above comments.
            {
                DWORD cdw = pSrcValue->cbData / sizeof (DWORD);
                DWORD *pdwSrc = (DWORD *) pbSrcData;
                LPWSTR pwszDst = (LPWSTR) pbExtra;
                for ( ; cdw > 0; cdw--) {
                    DWORD dw = *pdwSrc++;

                    if (dw < UNIVERSAL_SURROGATE_START)
                        *pwszDst++ = (WCHAR) dw;
                    else if (dw <= UNIVERSAL_SURROGATE_END) {
                        // Surrogate pair contains 20 bits.
                        DWORD dw20Bits;
    
                        dw20Bits = dw - UNIVERSAL_SURROGATE_START;
                        assert(dw20Bits <= 0xFFFFF);
                        *pwszDst++ = (WCHAR) (UNICODE_HIGH_SURROGATE_START +
                            (dw20Bits >> 10));
                        *pwszDst++ = (WCHAR) (UNICODE_LOW_SURROGATE_START +
                            (dw20Bits & 0x3FF));
                    } else
                        *pwszDst++ = UNICODE_REPLACEMENT_CHAR;
                }

                assert(pbExtra + cbData == (BYTE *) pwszDst);
            }
            break;
        default:
            // Convert UTF8 to unicode
            if (cbData) {
                int cchWideChar;
                cchWideChar = Asn1ToWideChar(
                    (LPSTR) pbSrcData,
                    pSrcValue->cbData,
                    fDisableIE4UTF8,
                    (LPWSTR) pbExtra,
                    cbData / sizeof(WCHAR)
                    );
                if (cchWideChar > 0) {
                    if (((DWORD) cchWideChar * sizeof(WCHAR)) <= cbData) {
                        pDstValue->cbData = cchWideChar * sizeof(WCHAR);
                        *((LPWSTR) pbExtra + cchWideChar) = L'\0';
                    }
                 } else {
                    assert(0);
                    goto Asn1ToWideCharError;
                }
            }
        }
        // Ensure NULL termination
        memset(pbExtra + cbData, 0, sizeof(WCHAR));
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1ToWideCharError)
}

//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;
    CERT_NAME_VALUE DstInfo;
    DWORD dwErrLocation;
    BOOL fDisableCheckType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    if (!IS_CERT_RDN_CHAR_STRING(dwValueType)) {
        *pcbEncoded = 0;
        SetLastError((DWORD) CRYPT_E_NOT_CHAR_STRING);
        return FALSE;
    }

    DstInfo.dwValueType = dwValueType & CERT_RDN_TYPE_MASK;
    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));
    if (!SetUnicodeRDNAttributeValue(dwValueType, &pInfo->Value,
            fDisableCheckType, &DstInfo.Value, &dwErrLocation)) {
        fResult = FALSE;
        *pcbEncoded = dwErrLocation;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        &DstInfo,
        dwFlags & ~CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeRDNAttributeValue(dwValueType, &DstInfo.Value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pNameValue = (PCERT_NAME_VALUE) pvDecodeInfo;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    PCERT_RDN_VALUE_BLOB pValue;

    if (!IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType))
        goto NotCharString;

    lRemainExtra -= sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pValue = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);
        pInfo->dwValueType = pNameValue->dwValueType;
        pValue = &pInfo->Value;
    }

    if (!GetUnicodeRDNAttributeValue(
            pNameValue->dwValueType,
            &pNameValue->Value,
            dwFlags,
            pValue,
            &pbExtra,
            &lRemainExtra
            )) goto DecodeError;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(NotCharString, CRYPT_E_NOT_CHAR_STRING)
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Default ordered list of acceptable RDN attribute value types. Used when
//  OIDInfo's ExtraInfo.cbData == 0. Or when ExtraInfo contains an empty
//  list.
//--------------------------------------------------------------------------
static const DWORD rgdwDefaultValueType[] = {
    CERT_RDN_PRINTABLE_STRING,
    CERT_RDN_UNICODE_STRING,
    0
};

//+-------------------------------------------------------------------------
//  Default X500 OID Information entry
//--------------------------------------------------------------------------
static CCRYPT_OID_INFO DefaultX500Info = {
    sizeof(CCRYPT_OID_INFO),            // cbSize
    "",                                 // pszOID
    L"",                                // pwszName
    0,                                  // dwLength
    0, NULL                             // ExtraInfo
};

// Please update the following if you add a new entry to the RDNAttrTable in
// oidinfo.cpp with a longer pwszName
#define MAX_X500_KEY_LEN    64

//+-------------------------------------------------------------------------
//  Checks if character needs to be quoted
//
//  Defined in RFC1779
//--------------------------------------------------------------------------
static inline BOOL IsQuotedW(WCHAR wc)
{
    return IsInStrW(L",+=\"\n<>#;", wc);
}

//+-------------------------------------------------------------------------
//  Checks if "decoded" unicode RDN value needs to be quoted
//--------------------------------------------------------------------------
static BOOL IsQuotedUnicodeRDNValue(PCERT_RDN_VALUE_BLOB pValue)
{
    LPCWSTR pwszValue = (LPCWSTR) pValue->pbData;
    DWORD cchValue = pValue->cbData / sizeof(WCHAR);
    if (0 == cchValue)
        return TRUE;

    // First or Last character is whitespace
    if (IsSpaceW(pwszValue[0]) || IsSpaceW(pwszValue[cchValue - 1]))
        return TRUE;

    for ( ; cchValue > 0; cchValue--, pwszValue++)
        if (IsQuotedW(*pwszValue))
            return TRUE;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Get the first dwValueType from the attribute's ordered list that is
//  an acceptable type for the input attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the first
//  bad character position using the last type in the list.
//--------------------------------------------------------------------------
static DWORD GetUnicodeValueType(
        IN PCCRYPT_OID_INFO pX500Info,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD dwValueType;
    const DWORD *pdwValueType;
    DWORD cValueType;
    DWORD dwErr = (DWORD) E_UNEXPECTED;
    DWORD i;

    pdwValueType = (DWORD *) pX500Info->ExtraInfo.pbData;
    cValueType = pX500Info->ExtraInfo.cbData / sizeof(DWORD);
    // Need at least two entries: a dwValueType and a 0 terminator. Otherwise,
    // use default value types.
    if (2 > cValueType || 0 == pdwValueType[0]) {
        pdwValueType = rgdwDefaultValueType;
        cValueType = sizeof(rgdwDefaultValueType) / sizeof(DWORD);
    }

    *pdwErrLocation = 0;
    for (i = 0; i < cValueType && 0 != (dwValueType = pdwValueType[i]); i++) {
        if (CERT_RDN_UNICODE_STRING == dwValueType) {
            if (dwUnicodeFlags & CERT_RDN_ENABLE_T61_UNICODE_FLAG) {
                DWORD j;
                BOOL fT61;

                fT61 = TRUE;
                for (j = 0; j < cchAttr; j++) {
                    if (pwszAttr[j] > 0xFF) {
                        fT61 = FALSE;
                        break;
                    }
                }
                if (fT61)
                    return CERT_RDN_T61_STRING;
            }

            if (dwUnicodeFlags & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG)
                return CERT_RDN_UTF8_STRING;
            else
                return CERT_RDN_UNICODE_STRING;
           
        }
        dwErr = CheckUnicodeValueType(
            dwValueType,
            pwszAttr,
            cchAttr,
            pdwErrLocation
            );

        if (0 == dwErr)
            return dwValueType;
    }

    assert(dwErr);
    SetLastError(dwErr);

    return 0;
}


//+-------------------------------------------------------------------------
//  Get an acceptable dwValueType associated with the OID for the input
//  attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the indices
//  of the RDN, RDNAttribute, and character string.
//--------------------------------------------------------------------------
static DWORD GetUnicodeX500OIDValueType(
        IN LPCSTR pszObjId,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    PCCRYPT_OID_INFO pX500Info;
    DWORD dwValueType;

    assert(pszObjId);
    if (NULL == pszObjId)
        pszObjId = "";

    // Attempt to find the OID in the table. If OID isn't found,
    // use default
    if (NULL == (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )))
        pX500Info = &DefaultX500Info;

    if (0 == (dwValueType = GetUnicodeValueType(
            pX500Info,
            pwszAttr,
            cchAttr,
            dwUnicodeFlags,
            pdwErrLocation
            ))) {
        // Include the dwRDNIndex and dwAttrIndex in the error location.
        assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
        assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
        *pdwErrLocation |=
            ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
            ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
    }
    return dwValueType;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN_ATTR. The values are unicode.
//--------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwFlags,
        IN OUT PCERT_RDN_ATTR pDstRDNAttr,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD dwValueType = pSrcRDNAttr->dwValueType;
    PCERT_RDN_VALUE_BLOB pSrcValue;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    DWORD dwUnicodeFlags;
    BOOL fDisableCheckType;

    dwUnicodeFlags = 0;
    if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_T61_UNICODE_FLAG))
        dwUnicodeFlags |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG))
        dwUnicodeFlags |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));

    dwValueType &= CERT_RDN_TYPE_MASK;

    *pdwErrLocation = 0;
    if (CERT_RDN_ENCODED_BLOB == dwValueType ||
            CERT_RDN_OCTET_STRING == dwValueType) {
        // No unicode conversion on this type
        memcpy(pDstRDNAttr, pSrcRDNAttr, sizeof(CERT_RDN_ATTR));
        return TRUE;
    }

    pSrcValue = &pSrcRDNAttr->Value;
    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr);

    if (0 == dwValueType) {
        if (0 == (dwValueType = GetUnicodeX500OIDValueType(
                pSrcRDNAttr->pszObjId,
                pwszAttr,
                cchAttr,
                dwRDNIndex,
                dwAttrIndex,
                dwUnicodeFlags,
                pdwErrLocation
                ))) goto GetValueTypeError;
    } else if (!fDisableCheckType) {
        if (0 != (dwErr = CheckUnicodeValueType(
                dwValueType,
                pwszAttr,
                cchAttr,
                pdwErrLocation
                ))) {
            // Include the dwRDNIndex and dwAttrIndex in the error location.
            assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
            assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
            *pdwErrLocation |=
                ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                    CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
                ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                    CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
            goto InvalidUnicodeValueType;
        }
    }

    pDstRDNAttr->pszObjId = pSrcRDNAttr->pszObjId;
    pDstRDNAttr->dwValueType = dwValueType;

    if (!SetUnicodeRDNAttributeValue(
            dwValueType,
            pSrcValue,
            TRUE,                   // fDisableCheckType
            &pDstRDNAttr->Value,
            NULL                    // OPTIONAL pdwErrLocation
            )) goto SetUnicodeRDNAttributeValueError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetValueTypeError)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(SetUnicodeRDNAttributeValueError)
}

static void FreeUnicodeRDNAttribute(
        IN OUT PCERT_RDN_ATTR pRDNAttr
        )
{
    FreeUnicodeRDNAttributeValue(pRDNAttr->dwValueType, &pRDNAttr->Value);
}

static BOOL GetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pDstRDNAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cbObjId;
    DWORD dwValueType;
    PCERT_RDN_VALUE_BLOB pDstValue;

    // Get Object Identifier length
    if (pSrcRDNAttr->pszObjId)
        cbObjId = strlen(pSrcRDNAttr->pszObjId) + 1;
    else
        cbObjId = 0;

    dwValueType = pSrcRDNAttr->dwValueType;

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        if(cbObjId) {
            pDstRDNAttr->pszObjId = (LPSTR) *ppbExtra;
            memcpy(*ppbExtra, pSrcRDNAttr->pszObjId, cbObjId);
        } else
            pDstRDNAttr->pszObjId = NULL;
        *ppbExtra += lAlignExtra;

        pDstRDNAttr->dwValueType = dwValueType;
        pDstValue = &pDstRDNAttr->Value;
    } else
        pDstValue = NULL;

    return GetUnicodeRDNAttributeValue(
        dwValueType,
        &pSrcRDNAttr->Value,
        dwFlags,
        pDstValue,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Info
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameInfoDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = (PCERT_NAME_INFO) pvDecodeInfo;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pSrcRDN, pDstRDN;
    PCERT_RDN_ATTR pSrcAttr, pDstAttr;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pNameInfo->cRDN;
    pSrcRDN = pNameInfo->rgRDN;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pDstRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pDstRDN;
        pbExtra += lAlignExtra;
    } else
        pDstRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDstRDN->cRDNAttr = cAttr;
            pDstAttr = (PCERT_RDN_ATTR) pbExtra;
            pDstRDN->rgRDNAttr = pDstAttr;
            pbExtra += lAlignExtra;
        } else
            pDstAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pSrcAttr++, pDstAttr++)
            // We're now ready to get the attribute/value stuff
            if (!GetUnicodeRDNAttribute(pSrcAttr, dwFlags,
                    pDstAttr, &pbExtra, &lRemainExtra))
                goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Info
//--------------------------------------------------------------------------
static void FreeUnicodeNameInfo(
        PCERT_NAME_INFO pInfo
        )
{
    PCERT_RDN pRDN = pInfo->rgRDN;
    if (pRDN) {
        DWORD cRDN = pInfo->cRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            if (pAttr) {
                DWORD cAttr = pRDN->cRDNAttr;
                for ( ; cAttr > 0; cAttr--, pAttr++)
                    FreeUnicodeRDNAttribute(pAttr);
                PkiFree(pRDN->rgRDNAttr);
            }
        }
        PkiFree(pInfo->rgRDN);
    }
}

static BOOL SetUnicodeNameInfo(
        IN PCERT_NAME_INFO pSrcInfo,
        IN DWORD dwFlags,
        OUT PCERT_NAME_INFO pDstInfo,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    DWORD i, j;
    PCERT_RDN pSrcRDN;
    PCERT_RDN_ATTR pSrcAttr;
    PCERT_RDN pDstRDN = NULL;
    PCERT_RDN_ATTR pDstAttr = NULL;

    *pdwErrLocation = 0;

    cRDN = pSrcInfo->cRDN;
    pSrcRDN = pSrcInfo->rgRDN;
    pDstInfo->cRDN = cRDN;
    pDstInfo->rgRDN = NULL;
    if (cRDN > 0) {
        if (NULL == (pDstRDN = (PCERT_RDN) PkiZeroAlloc(
                cRDN * sizeof(CERT_RDN))))
            goto OutOfMemory;
        pDstInfo->rgRDN = pDstRDN;
    }

    // Array of RDNs
    for (i = 0; i < cRDN; i++, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        pDstRDN->cRDNAttr = cAttr;

        if (cAttr > 0) {
            if (NULL == (pDstAttr = (PCERT_RDN_ATTR) PkiZeroAlloc(cAttr *
                    sizeof(CERT_RDN_ATTR))))
                goto OutOfMemory;
            pDstRDN->rgRDNAttr = pDstAttr;
        }

        // Array of attribute/values
        for (j = 0; j < cAttr; j++, pSrcAttr++, pDstAttr++) {
            // We're now ready to convert the unicode string
            if (!SetUnicodeRDNAttribute(pSrcAttr, i, j, dwFlags, pDstAttr,
                    pdwErrLocation))
                goto SetUnicodeRDNAttributeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SetUnicodeRDNAttributeError)
}

BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, dwFlags, &DstInfo, &dwErrLocation)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}

static BOOL WINAPI UnicodeNameInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, 0, &DstInfo, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObject(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}


static void PutStrW(LPCWSTR pwszPut, LPWSTR *ppwsz, DWORD *pcwsz,
        DWORD *pcwszOut, BOOL fQuote = FALSE)
{
    WCHAR wc;
    while (wc = *pwszPut++) {
        if (L'\"' == wc && fQuote)
            PutStrW(L"\"", ppwsz, pcwsz, pcwszOut, FALSE);
        if (*pcwsz != 1) {
            if (*pcwsz) {
                **ppwsz = wc;
                *ppwsz += 1;
                *pcwsz -= 1;
            }
            *pcwszOut += 1;
        }
        // else
        //  Always reserve space for the NULL terminator.
    }
}

static void PutOIDStrW(
    IN DWORD dwStrType,
    IN LPCSTR pszObjId,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case CERT_X500_NAME_STR:
            {
                PCCRYPT_OID_INFO pX500Info;
                if (pX500Info = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        (void *) pszObjId,
                        CRYPT_RDN_ATTR_OID_GROUP_ID
                        )) {
                    if (*pX500Info->pwszName) {
                            PutStrW(pX500Info->pwszName, ppwsz, pcwsz,
                                pcwszOut);
                            PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
                            return;
                    }
                }
                PutStrW(L"OID.", ppwsz, pcwsz, pcwszOut);
            }
            // Fall through
        case CERT_OID_NAME_STR:
            {
                int cchWideChar;
                cchWideChar = MultiByteToWideChar(
                    CP_ACP,
                    0,                      // dwFlags
                    pszObjId,
                    -1,                     // null terminated
                    *ppwsz,
                    *pcwsz) - 1;
                if (cchWideChar > 0) {
                    if (*pcwsz) {
                        assert(*pcwsz > (DWORD)cchWideChar);
                        *pcwsz -= cchWideChar;
                        *ppwsz += cchWideChar;
                    }
                    *pcwszOut += cchWideChar;
                }
                PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
            }
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            break;
    }
}

static void PutHexW(
    IN PCERT_RDN_VALUE_BLOB pValue,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    WCHAR wszHex[3];
    BYTE *pb = pValue->pbData;
    DWORD cb = pValue->cbData;

    PutStrW(L"#", ppwsz, pcwsz, pcwszOut);
    wszHex[2] = L'\0';

    for ( ; cb > 0; cb--, pb++) {
        int b;
        b = (*pb >> 4) & 0x0F;
        wszHex[0] = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        wszHex[1] = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        PutStrW(wszHex, ppwsz, pcwsz, pcwszOut);
    }
}

static void ReverseNameInfo(
    IN PCERT_NAME_INFO pInfo
    )
{
    DWORD cRDN;
    PCERT_RDN pLo;
    PCERT_RDN pHi;
    CERT_RDN Tmp;

    cRDN = pInfo->cRDN;
    if (0 == cRDN)
        return;

    pLo = pInfo->rgRDN;
    pHi = pInfo->rgRDN + cRDN - 1;
    for ( ; pLo < pHi; pHi--, pLo++) {
        Tmp = *pHi;
        *pHi = *pLo;
        *pLo = Tmp;
    }
}

//+-------------------------------------------------------------------------
//  Convert the decoded certificate name info to a null terminated WCHAR
//  string.
//
//  Note, if CERT_NAME_STR_REVERSE_FLAG is set, reverses the decoded
//  name info RDNs
//--------------------------------------------------------------------------
static DWORD WINAPI CertNameInfoToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_INFO pInfo,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut = 0;

    LPCWSTR pwszRDNSeparator;
    LPCWSTR pwszMultiValueSeparator;
    BOOL fEnableQuoting;

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        pwszRDNSeparator = L"; ";
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        pwszRDNSeparator = L"\r\n";
    else
        pwszRDNSeparator = L", ";

    if (dwStrType & CERT_NAME_STR_NO_PLUS_FLAG)
        pwszMultiValueSeparator = L" ";
    else
        pwszMultiValueSeparator = L" + ";

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    if (pwsz == NULL)
        cwsz = 0;

    if (pInfo) {
        DWORD cRDN;
        PCERT_RDN pRDN;

        if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
            ReverseNameInfo(pInfo);

        cRDN = pInfo->cRDN;
        pRDN = pInfo->rgRDN;
        if (0 == cRDN)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                BOOL fQuote;
                PutOIDStrW(dwStrType, pAttr->pszObjId, &pwsz, &cwsz, &cwszOut);

                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    PutHexW(&pAttr->Value, &pwsz, &cwsz, &cwszOut);
                else {
                    fQuote = fEnableQuoting && IsQuotedUnicodeRDNValue(
                        &pAttr->Value);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                    PutStrW((LPCWSTR) pAttr->Value.pbData, &pwsz, &cwsz,
                        &cwszOut, fQuote);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                }

                if (cAttr > 1)
                    PutStrW(pwszMultiValueSeparator, &pwsz, &cwsz, &cwszOut);
            }
            if (cRDN > 1)
                PutStrW(pwszRDNSeparator, &pwsz, &cwsz, &cwszOut);
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *pwsz = L'\0';
    }

    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated WCHAR string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut;
    PCERT_NAME_INFO pInfo;
    pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        pName->pbData,
        pName->cbData,
        (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG) ?
            CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
        );

    // Note, decoded name info RDNs may be reversed
    cwszOut = CertNameInfoToStrW(
        dwCertEncodingType,
        pInfo,
        dwStrType,
        pwsz,
        cwsz
        );

    PkiFree(pInfo);
    return cwszOut;
}

//+-------------------------------------------------------------------------
//  Convert the Unicode string to Ascii
//--------------------------------------------------------------------------
static DWORD ConvertUnicodeStringToAscii(
    IN LPWSTR pwsz,
    IN DWORD cwsz,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;

    if (psz == NULL)
        csz = 0;

    if (pwsz) {
        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated char string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        pName,
        dwStrType,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertNameToStrW(
            dwCertEncodingType,
            pName,
            dwStrType,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, psz, csz);

    PkiFree(pwsz);
    return cszOut;
}


//+-------------------------------------------------------------------------
//  Map the attribute key (for example "CN") to its Object Identifier
//  (for example, "2.5.4.3").
//
//  The input pwcKey isn't NULL terminated. cchKey > 0.
//
//  Returns NULL if unable to find a matching attribute key.
//--------------------------------------------------------------------------
static LPCSTR X500KeyToOID(IN LPCWSTR pwcKey, IN DWORD cchKey)
{
    PCCRYPT_OID_INFO pX500Info;
    WCHAR wszKey[MAX_X500_KEY_LEN + 1];

    if (cchKey > MAX_X500_KEY_LEN)
        return NULL;
    assert(cchKey > 0);

    // Null terminate the input Key
    memcpy(wszKey, pwcKey, cchKey * sizeof(WCHAR));
    wszKey[cchKey] = L'\0';

    if (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_NAME_KEY,
            wszKey,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )) {
        if (*pX500Info->pszOID)
            return pX500Info->pszOID;
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//  Checks if a digit
//--------------------------------------------------------------------------
static inline BOOL IsDigitA(char c)
{
    return c >= '0' && c <= '9';
}

#define X500_OID_PREFIX_A       "OID."
#define X500_OID_PREFIX_LEN     strlen(X500_OID_PREFIX_A)

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

//+-------------------------------------------------------------------------
//  Check for the case insensitive leading "OID." If present, skip past
//  it. Check that the remaining string contains only digits or a dot (".").
//  Also, don't allow consecutive dots.
//
//  Returns NULL for an invalid OID.
//--------------------------------------------------------------------------
static LPCSTR GetX500OID(IN LPCSTR pszObjId)
{
    LPCSTR psz;
    char c;
    BOOL fDot;

    if (strlen(pszObjId) > X500_OID_PREFIX_LEN &&
            2 == CompareStringA(NO_LOCALE, NORM_IGNORECASE,
                X500_OID_PREFIX_A, X500_OID_PREFIX_LEN,
                pszObjId, X500_OID_PREFIX_LEN))
        pszObjId += X500_OID_PREFIX_LEN;

    // Verify the OID to have only digits and dots
    psz = pszObjId;
    fDot = FALSE;
    while (c = *psz++) {
        if (c == '.') {
            if (fDot)
                return NULL;
            fDot = TRUE;
        } else {
            if (!IsDigitA(c))
                return NULL;
            fDot = FALSE;
        }
    }
    return pszObjId;
}

//+-------------------------------------------------------------------------
//  Convert the the hex string, for example, #AB01, to binary.
//
//  The input string is assumed to have the leading #. Ignores embedded
//  whitespace.
//
//  The returned binary is allocated in pValue->pbData.
//--------------------------------------------------------------------------
static BOOL GetAndAllocHexW(
    IN LPCWSTR pwszToken,
    IN DWORD cchToken,
    OUT PCERT_RDN_VALUE_BLOB pValue
    )
{
    BOOL fResult;
    BYTE *pb;
    DWORD cb;
    BOOL fUpperNibble;

    pValue->pbData = NULL;
    pValue->cbData = 0;

    // Advance past #
    cchToken--;
    pwszToken++;
    if (0 == cchToken)
        goto NoHex;

    if (NULL == (pb = (BYTE *) PkiNonzeroAlloc(cchToken / 2 + 1)))
        goto OutOfMemory;
    pValue->pbData = pb;

    fUpperNibble = TRUE;
    cb = 0;
    while (cchToken--) {
        BYTE b;
        WCHAR wc = *pwszToken++;
        // only convert ascii hex characters 0..9, a..f, A..F
        // ignore whitespace
        if (wc >= L'0' && wc <= L'9')
            b = (BYTE) (wc - L'0');
        else if (wc >= L'a' && wc <= L'f')
            b = (BYTE) (10 + wc - L'a');
        else if (wc >= L'A' && wc <= L'F')
            b = (BYTE) (10 + wc - L'A');
        else if (IsSpaceW(wc))
            continue;
        else
            goto InvalidHex;

        if (fUpperNibble) {
            *pb = (BYTE)( b << 4 );
            cb++;
            fUpperNibble = FALSE;
        } else {
            *pb = (BYTE)( *pb | b);
            pb++;
            fUpperNibble = TRUE;
        }
    }
    if (cb == 0) {
        PkiFree(pValue->pbData);
        pValue->pbData = NULL;
    }
    pValue->cbData = cb;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pValue->pbData);
    pValue->pbData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoHex, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidHex, CRYPT_E_INVALID_X500_STRING)
}

#define X500_QUOTED_FLAG            0x1
#define X500_EMBEDDED_QUOTE_FLAG    0x2

//+-------------------------------------------------------------------------
//  Get the next key or value token.
//
//  Handles quoted tokens.
//
//  Upon return *ppwsz points at the delimiter or error location
//--------------------------------------------------------------------------
static BOOL GetX500Token(
    IN OUT LPCWSTR *ppwsz,
    IN LPCWSTR pwszDelimiter,
    IN BOOL fEnableQuoting,
    OUT LPCWSTR *ppwszToken,
    OUT DWORD *pcchToken,
    OUT DWORD *pdwFlags
    )
{
    BOOL fResult;
    LPCWSTR pwsz = *ppwsz;
    LPCWSTR pwszStart = NULL;
    LPCWSTR pwszEnd = NULL;
    DWORD dwQuote = 0;          // 1 - after leading ", 2 - after trailing "

    *pdwFlags = 0;
    while (TRUE) {
        WCHAR wc = *pwsz;
        if (0 == dwQuote) {
            // No quotes so far. Or quoting not enabled.
            if (fEnableQuoting && L'\"' == wc) {
                if (NULL == pwszStart) {
                    pwszStart = pwsz + 1;
                    dwQuote = 1;
                    *pdwFlags |= X500_QUOTED_FLAG;
                } else
                    // Quote after non whitespace
                    goto ErrorReturn;
            } else {
                if (L'\0' == wc || IsInStrW(pwszDelimiter, wc)) {
                    // Hit a delimiter (including the null terminator)
                    if (pwszStart)
                        *pcchToken = (DWORD)(pwszEnd - pwszStart) + 1;
                    else
                        *pcchToken = 0;
                    break;
                }

                if (!IsSpaceW(wc)) {
                    pwszEnd = pwsz;
                    if (NULL == pwszStart)
                        pwszStart = pwsz;
                }
            }
        } else if (1 == dwQuote) {
            // After first quote
            if (L'\0' == wc) {
                // Point to first quote
                pwsz = pwszStart - 1;
                goto ErrorReturn;
            } else if (L'\"' == wc) {
                if (L'\"' == *(pwsz + 1)) {
                    *pdwFlags |= X500_EMBEDDED_QUOTE_FLAG;
                    // Skip double quote
                    pwsz++;
                } else {
                    *pcchToken = (DWORD)(pwsz - pwszStart);
                    dwQuote++;
                }
            }
        } else {
            // After second quote
            if (L'\0' == wc || IsInStrW(pwszDelimiter, wc))
                break;
            else if (!IsSpaceW(wc))
                goto ErrorReturn;
        }
        pwsz++;
    }

    fResult = TRUE;
CommonReturn:
    *ppwszToken = pwszStart;
    *ppwsz = pwsz;
    return fResult;

ErrorReturn:
    pwszStart = NULL;
    *pcchToken = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Convert the null terminated X500 WCHAR string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameW(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pwszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppwszError
    )
{

typedef struct _X500_ATTR_AUX {
    LPSTR pszAllocObjId;
    LPCWSTR pwszValue;
    BYTE *pbAllocValue;
    BOOL fNewRDN;
} X500_ATTR_AUX, *PX500_ATTR_AUX;
#define X500_ATTR_ALLOC_COUNT   20

    BOOL fResult;
    CERT_NAME_INFO NameInfo;
    PCERT_RDN pRDN = NULL;
    PCERT_RDN_ATTR pAttr = NULL;
    PX500_ATTR_AUX pAux = NULL;

    DWORD cRDN = 0;
    DWORD cAttr = 0;
    DWORD iRDN;
    DWORD iAttr;
    DWORD cAllocAttr;
    BOOL fNewRDN;
    DWORD dwValueType;

    WCHAR wszSeparators[8];
    BOOL fEnableQuoting;
    LPCWSTR pwszError = NULL;
    LPCWSTR pwszStartX500 = pwszX500;

    dwValueType = 0;
    if (dwStrType & CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG)
        dwValueType |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    if (dwStrType & CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG)
        dwValueType |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

    // Check for an empty Name.
    if (NULL == pwszX500 || L'\0' == *pwszX500) {
        NameInfo.cRDN = 0;
        NameInfo.rgRDN = NULL;

        if (ppwszError)
            *ppwszError = NULL;

        return CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &NameInfo,
            pbEncoded,
            pcbEncoded
            );
    }

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        wcscpy(wszSeparators, L";");
    else if (dwStrType & CERT_NAME_STR_COMMA_FLAG)
        wcscpy(wszSeparators, L",");
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        wcscpy(wszSeparators, L"\r\n");
    else
        wcscpy(wszSeparators, L",;");
    if (!(dwStrType & CERT_NAME_STR_NO_PLUS_FLAG))
        wcscat(wszSeparators, L"+");

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case 0:
        case CERT_OID_NAME_STR:
        case CERT_X500_NAME_STR:
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            goto InvalidArg;
    }

    // Do initial allocations of Attrs, and Auxs
    if (NULL == (pAttr = (PCERT_RDN_ATTR) PkiNonzeroAlloc(
                sizeof(CERT_RDN_ATTR) * X500_ATTR_ALLOC_COUNT)) ||
            NULL == (pAux = (PX500_ATTR_AUX) PkiNonzeroAlloc(
                sizeof(X500_ATTR_AUX) * X500_ATTR_ALLOC_COUNT)))
        goto OutOfMemory;
    cAllocAttr = X500_ATTR_ALLOC_COUNT;
    fNewRDN = TRUE;
    while (TRUE) {
        LPCWSTR pwszToken;
        DWORD cchToken;
        DWORD dwTokenFlags;
        LPCSTR pszObjId;

        // Get the key token
        if (!GetX500Token(
                &pwszX500,
                L"=",           // pwszDelimiter
                FALSE,          // fEnableQuoting
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500KeyTokenError;
        }

        if (0 == cchToken) {
            if (*pwszX500 == L'\0')
                break;
            else {
                pwszError = pwszX500;
                goto EmptyX500KeyError;
            }
        } else if (*pwszX500 == L'\0') {
            pwszError = pwszToken;
            goto NoX500KeyEqualError;
        }

        if (cAttr >= cAllocAttr) {
            PCERT_RDN_ATTR pNewAttr;
            PX500_ATTR_AUX pNewAux;

            assert(cAttr == cAllocAttr);
            if (NULL == (pNewAttr = (PCERT_RDN_ATTR) PkiRealloc(pAttr,
                    sizeof(CERT_RDN_ATTR) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAttr = pNewAttr;

            if (NULL == (pNewAux = (PX500_ATTR_AUX) PkiRealloc(pAux,
                    sizeof(X500_ATTR_AUX) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAux = pNewAux;

            cAllocAttr += X500_ATTR_ALLOC_COUNT;
        }
        iAttr = cAttr;
        cAttr++;
        memset(&pAttr[iAttr], 0, sizeof(CERT_RDN_ATTR));
        memset(&pAux[iAttr], 0, sizeof(X500_ATTR_AUX));
        pAux[iAttr].fNewRDN = fNewRDN;
        if (fNewRDN)
            cRDN++;

        // Convert the Key token to an OID
        pszObjId = X500KeyToOID(pwszToken, cchToken);
        if (NULL == pszObjId) {
            // Convert to ascii and null terminate
            LPSTR pszAllocObjId;
            DWORD i;

            // Convert from unicode to ascii and null terminate
            if (NULL == (pszAllocObjId = (LPSTR) PkiNonzeroAlloc(
                    cchToken + 1)))
                goto OutOfMemory;
            pAux[iAttr].pszAllocObjId = pszAllocObjId;
            for (i = 0; i < cchToken; i++)
                pszAllocObjId[i] = (char) (pwszToken[i] & 0xFF);
            pszAllocObjId[cchToken] = '\0';

            // Skips by leading OID. and validates
            pszObjId = GetX500OID(pszAllocObjId);
            if (NULL == pszObjId) {
                pwszError = pwszToken;
                goto InvalidX500Key;
            }
        }
        pAttr[iAttr].pszObjId = (LPSTR) pszObjId;
        pAttr[iAttr].dwValueType = dwValueType;

        // Advance past the Key's "=" delimiter
        pwszX500++;

        // Get the value token
        if (!GetX500Token(
                &pwszX500,
                wszSeparators,
                fEnableQuoting,
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500ValueTokenError;
        }
        if (cchToken) {
            if (*pwszToken == L'#' && 0 == (dwTokenFlags & X500_QUOTED_FLAG)) {
                // Convert ascii hex to binary
                if (!GetAndAllocHexW(pwszToken, cchToken,
                        &pAttr[iAttr].Value)) {
                    pwszError = pwszToken;
                    goto ConvertHexError;
                }
                pAttr[iAttr].dwValueType = CERT_RDN_OCTET_STRING;
                pAux[iAttr].pbAllocValue = pAttr[iAttr].Value.pbData;
            } else if (dwTokenFlags & X500_EMBEDDED_QUOTE_FLAG) {
                // Realloc and remove the double "'s
                LPWSTR pwszAlloc;
                DWORD cchAlloc;
                DWORD i;
                if (NULL == (pwszAlloc = (LPWSTR) PkiNonzeroAlloc(
                        cchToken * sizeof(WCHAR))))
                    goto OutOfMemory;
                pAux[iAttr].pbAllocValue = (BYTE *) pwszAlloc;
                cchAlloc = 0;
                for (i = 0; i < cchToken; i++) {
                    pwszAlloc[cchAlloc++] = pwszToken[i];
                    if (pwszToken[i] == L'\"')
                        i++;
                }
                assert(cchAlloc < cchToken);
                pAttr[iAttr].Value.pbData = (BYTE *) pwszAlloc;
                pAttr[iAttr].Value.cbData = cchAlloc * sizeof(WCHAR);
            } else {
                pAttr[iAttr].Value.pbData = (BYTE *) pwszToken;
                pAttr[iAttr].Value.cbData = cchToken * sizeof(WCHAR);
            }

            pAux[iAttr].pwszValue = pwszToken;
        }

        fNewRDN = TRUE;
        if (*pwszX500 == L'\0')
            break;
        else if (*pwszX500 == L'+')
            fNewRDN = FALSE;

        // Advance past the value's delimiter
        pwszX500++;
    }

    if (0 == cRDN) {
        pwszError = pwszStartX500;
        goto NoRDNError;
    }

    // Allocate array of RDNs and update
    if (NULL == (pRDN = (PCERT_RDN) PkiNonzeroAlloc(sizeof(CERT_RDN) * cRDN)))
        goto OutOfMemory;
    iRDN = 0;
    for (iAttr = 0; iAttr < cAttr; iAttr++) {
        if (pAux[iAttr].fNewRDN) {
            assert(iRDN < cRDN);
            pRDN[iRDN].cRDNAttr = 1;
            pRDN[iRDN].rgRDNAttr = &pAttr[iAttr];
            iRDN++;
        } else {
            assert(iRDN > 0);
            pRDN[iRDN - 1].cRDNAttr++;

        }
    }
    assert(iRDN == cRDN);
    NameInfo.cRDN = cRDN;
    NameInfo.rgRDN = pRDN;

    if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
        ReverseNameInfo(&NameInfo);

    // Encode the above built name
    fResult = UnicodeNameInfoEncode(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        &NameInfo,
        pbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if ((DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr) {
            // *pcbEncoded contains the location of the error

            PCERT_RDN_ATTR pErrAttr;
            DWORD iValue;

            if (dwStrType & CERT_NAME_STR_REVERSE_FLAG) {
                // Reverse back to get the correct location of the error
                // relative to the input string
                ReverseNameInfo(&NameInfo);
                fResult = UnicodeNameInfoEncode(
                    dwCertEncodingType,
                    X509_UNICODE_NAME,
                    &NameInfo,
                    pbEncoded,
                    pcbEncoded
                    );
                if (fResult)
                    goto UnexpectedReverseEncodeSuccess;
                dwErr = GetLastError();
                if (!( (DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr))
                    goto UnexpectedReverseEncodeError;
            }

            iValue = GET_CERT_UNICODE_VALUE_ERR_INDEX(*pcbEncoded);
            iRDN = GET_CERT_UNICODE_RDN_ERR_INDEX(*pcbEncoded);
            iAttr = GET_CERT_UNICODE_ATTR_ERR_INDEX(*pcbEncoded);
            *pcbEncoded = 0;

            assert(iRDN < cRDN);
            assert(iAttr < pRDN[iRDN].cRDNAttr);
            pErrAttr = &pRDN[iRDN].rgRDNAttr[iAttr];

            assert(pErrAttr->dwValueType != CERT_RDN_OCTET_STRING);

            // Index from beginning of pAttr
            iAttr = (DWORD)(pErrAttr - pAttr);
            assert(iAttr < cAttr);
            assert(iValue < pAttr[iAttr].Value.cbData / sizeof(WCHAR));
            pwszError = pAux[iAttr].pwszValue;
            assert(pwszError);
            if (pAux[iAttr].pbAllocValue) {
                // Adjust for embedded quotes where the the second quote
                // was removed above before encoding
                DWORD i = iValue;
                assert(pAux[iAttr].pbAllocValue == pAttr[iAttr].Value.pbData);
                LPCWSTR pwszValue = (LPCWSTR) pAttr[iAttr].Value.pbData;
                for ( ; i > 0; i--, pwszValue++)
                    if (*pwszValue == L'\"')
                        iValue++;
            }
            pwszError += iValue;
        }
    }
CommonReturn:
    while (cAttr--) {
        PkiFree(pAux[cAttr].pszAllocObjId);
        PkiFree(pAux[cAttr].pbAllocValue);
    }

    PkiFree(pRDN);
    PkiFree(pAttr);
    PkiFree(pAux);
    if (ppwszError)
        *ppwszError = pwszError;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(X500KeyTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(EmptyX500KeyError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoX500KeyEqualError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidX500Key, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(X500ValueTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(ConvertHexError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoRDNError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(UnexpectedReverseEncodeSuccess, E_UNEXPECTED)
TRACE_ERROR(UnexpectedReverseEncodeError)
}

//+-------------------------------------------------------------------------
//  Convert the null terminated X500 char string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameA(
    IN DWORD dwCertEncodingType,
    IN LPCSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCSTR *ppszError
    )
{
    BOOL fResult;
    LPWSTR pwszX500 = NULL;
    LPCWSTR pwszError = NULL;

    assert(pszX500);
    if (NULL == (pwszX500 = MkWStr((LPSTR) pszX500)))
        goto ErrorReturn;
    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszX500,
        dwStrType,
        pvReserved,
        pbEncoded,
        pcbEncoded,
        &pwszError
        );
    if (ppszError) {
        // Update multi byte error location
        if (pwszError) {
            // Default to beginning of string
            *ppszError = pszX500;
            if (pwszError > pwszX500) {
                // After beginning of string. There should be at least 2
                // characters.
                //
                // Need to convert pwszX500 .. pwszError - 1 back to multi byte
                // to get the correct multi byte pointer.
                int cchError = strlen(pszX500) - 1; // exclude error char
                LPSTR pszError;
                assert(cchError);
                if (pszError = (LPSTR) PkiNonzeroAlloc(cchError)) {
                    // Convert up through the previous multibyte character
                    cchError = WideCharToMultiByte(
                        CP_ACP,
                        0,                      // dwFlags
                        pwszX500,
                        (int)(pwszError - pwszX500),
                        pszError,
                        cchError,
                        NULL,                   // lpDefaultChar
                        NULL                    // lpfUsedDefaultChar
                        );
                    if (cchError > 0)
                        *ppszError = pszX500 + cchError;
                    PkiFree(pszError);
                }
            }
        } else
            *ppszError = NULL;
    }

CommonReturn:
    FreeWStr(pwszX500);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    if (ppszError)
        *ppszError = NULL;
    goto CommonReturn;
}

//==========================================================================
//  CertGetNameStrW support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the name blob.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_INFO pInfo;

    assert(pName);
    if (0 == pName->cbData)
        return NULL;

    if (NULL == (pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            (dwFlags & CERT_NAME_DISABLE_IE4_UTF8_FLAG) ?
                CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
            )))
        return NULL;
    if (0 == pInfo->cRDN) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding either the
//  Subject or Issuer field in the certificate. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetCertNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_BLOB pName;

    if (dwFlags & CERT_NAME_ISSUER_FLAG)
        pName = &pCertContext->pCertInfo->Issuer;
    else
        pName = &pCertContext->pCertInfo->Subject;

    return AllocAndGetNameInfo(pCertContext->dwCertEncodingType, pName,
        dwFlags);
}

//+-------------------------------------------------------------------------
//  Table of Subject and Issuer Alternative Name extension OIDs
//--------------------------------------------------------------------------
static const LPCSTR rgpszSubjectAltOID[] = {
    szOID_SUBJECT_ALT_NAME2,
    szOID_SUBJECT_ALT_NAME
};
#define NUM_SUBJECT_ALT_OID (sizeof(rgpszSubjectAltOID) / \
                                         sizeof(rgpszSubjectAltOID[0]))

static const LPCSTR rgpszIssuerAltOID[] = {
    szOID_ISSUER_ALT_NAME2,
    szOID_ISSUER_ALT_NAME
};
#define NUM_ISSUER_ALT_OID (sizeof(rgpszIssuerAltOID) / \
                                         sizeof(rgpszIssuerAltOID[0]))

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_ALT_NAME_INFO by decoding either the
//  Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if extension not found or cAltEntry == 0
//--------------------------------------------------------------------------
static PCERT_ALT_NAME_INFO AllocAndGetAltNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    DWORD cAltOID;
    const LPCSTR *ppszAltOID;

    PCERT_EXTENSION pExt;
    PCERT_ALT_NAME_INFO pInfo;

    if (dwFlags & CERT_NAME_ISSUER_FLAG) {
        cAltOID = NUM_ISSUER_ALT_OID;
        ppszAltOID = rgpszIssuerAltOID;
    } else {
        cAltOID = NUM_SUBJECT_ALT_OID;
        ppszAltOID = rgpszSubjectAltOID;
    }

    // Try to find an alternative name extension
    pExt = NULL;
    for ( ; cAltOID > 0; cAltOID--, ppszAltOID++) {
        if (pExt = CertFindExtension(
                *ppszAltOID,
                pCertContext->pCertInfo->cExtension,
                pCertContext->pCertInfo->rgExtension
                ))
            break;
    }

    if (NULL == pExt)
        return NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) AllocAndDecodeObject(
            pCertContext->dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0                       // dwFlags
            )))
        return NULL;
    if (0 == pInfo->cAltEntry) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the first
//  Directory Name choice (if it exists) in the decoded CERT_ALT_NAME_INFO.
//
//  Returns NULL if no Directory Name choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    IN DWORD dwFlags
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return NULL;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_DIRECTORY_NAME == pEntry->dwAltNameChoice) {
            return AllocAndGetNameInfo(dwCertEncodingType,
                &pEntry->DirectoryName, dwFlags);
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  First, returns pointer to allocated CERT_ALT_NAME_INFO by decoding either
//  the Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer. Returns NULL if extension not found or
//  cAltEntry == 0
//
//  Then, if able to find the extension, returns pointer to allocated
//  CERT_NAME_INFO by decoding the first Directory Name choice (if it exists)
//  in the decoded CERT_ALT_NAME_INFO. Returns NULL if no Directory Name
//  choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT PCERT_ALT_NAME_INFO *ppAltNameInfo
    )
{
    PCERT_ALT_NAME_INFO pAltNameInfo;
    *ppAltNameInfo = pAltNameInfo = AllocAndGetAltNameInfo(pCertContext,
        dwFlags);
    if (NULL == pAltNameInfo)
        return NULL;
    return AllocAndGetAltDirNameInfo(pCertContext->dwCertEncodingType,
        pAltNameInfo, dwFlags);
}

//+-------------------------------------------------------------------------
//  Copy name string. Ensure its NULL terminated.
//--------------------------------------------------------------------------
static void CopyNameStringW(
    IN LPCWSTR pwszSrc,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    PutStrW(pwszSrc, &pwszNameString, &cchNameString, pcwszOut);
    if (cchNameString != 0)
        // Always NULL terminate
        *pwszNameString = L'\0';
    *pcwszOut += 1;
}

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  SIMPLE_DISPLAY_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszSimpleDisplayAttrOID[] = {
    szOID_COMMON_NAME,
    szOID_ORGANIZATIONAL_UNIT_NAME,
    szOID_ORGANIZATION_NAME,
    szOID_RSA_emailAddr,
    NULL                                // any
};
#define NUM_SIMPLE_DISPLAY_ATTR_OID (sizeof(rgpszSimpleDisplayAttrOID) / \
                                        sizeof(rgpszSimpleDisplayAttrOID[0]))

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  EMAIL_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszEmailAttrOID[] = {
    szOID_RSA_emailAddr
};
#define NUM_EMAIL_ATTR_OID (sizeof(rgpszEmailAttrOID) / \
                                     sizeof(rgpszEmailAttrOID[0]))

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  DNS_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszDNSAttrOID[] = {
    szOID_COMMON_NAME
};
#define NUM_DNS_ATTR_OID (sizeof(rgpszDNSAttrOID) / \
                                     sizeof(rgpszDNSAttrOID[0]))


// Largest number from above tables
#define MAX_ATTR_OID            NUM_SIMPLE_DISPLAY_ATTR_OID

// PCERT_NAME_INFO table count and indices
#define NAME_INFO_CNT           2
#define CERT_NAME_INFO_INDEX    0
#define ALT_DIR_NAME_INFO_INDEX 1


//+-------------------------------------------------------------------------
//  Iterate through the list of attributes specified in rgpszAttrOID
//  and iterate through the table of decoded names specified in rgpNameInfo
//  and find the first occurrence of the attribute.
//--------------------------------------------------------------------------
static BOOL GetAttrStringW(
    IN DWORD cAttrOID,
    IN const LPCSTR *rgpszAttrOID,
    IN PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT],
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD iOID;
    PCERT_RDN_ATTR rgpFoundAttr[MAX_ATTR_OID];
    DWORD iInfo;

    assert(cAttrOID > 0 && cAttrOID <= MAX_ATTR_OID);
    for (iOID = 0; iOID < cAttrOID; iOID++)
        rgpFoundAttr[iOID] = NULL;

    for (iInfo = 0; iInfo < NAME_INFO_CNT; iInfo++) {
        PCERT_NAME_INFO pInfo;
        DWORD cRDN;

        if (NULL == (pInfo = rgpNameInfo[iInfo]))
            continue;

        // Search RDNs in reverse order
        for (cRDN = pInfo->cRDN; cRDN > 0; cRDN--) {
            PCERT_RDN pRDN = &pInfo->rgRDN[cRDN - 1];
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    continue;

                for (iOID = 0; iOID < cAttrOID; iOID++) {
                    if (NULL == rgpFoundAttr[iOID] &&
                            (NULL == rgpszAttrOID[iOID] ||
                                0 == strcmp(rgpszAttrOID[iOID],
                                    pAttr->pszObjId))) {
                        rgpFoundAttr[iOID] = pAttr;
                        if (0 == iOID)
                            goto FoundAttr;
                        else
                            break;
                    }
                }
            }
        }
    }


    // iOID == 0 was already found above
    assert(NULL == rgpFoundAttr[0]);
    for (iOID = 1; iOID < cAttrOID; iOID++) {
        if (rgpFoundAttr[iOID])
            break;
    }
    if (iOID >= cAttrOID)
        return FALSE;

FoundAttr:
    assert(iOID < cAttrOID && rgpFoundAttr[iOID]);
    CopyNameStringW((LPCWSTR) rgpFoundAttr[iOID]->Value.pbData, pwszNameString,
        cchNameString, pcwszOut);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified choice in the decoded alternative name
//  extension.
//--------------------------------------------------------------------------
static BOOL GetAltNameUnicodeStringChoiceW(
    IN DWORD dwAltNameChoice,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return FALSE;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (dwAltNameChoice == pEntry->dwAltNameChoice) {
            // pwszRfc822Name union choice is the same as
            // pwszDNSName and pwszURL.
            CopyNameStringW(pEntry->pwszRfc822Name, pwszNameString,
                cchNameString, pcwszOut);
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Attempt to find an OTHER_NAME choice in the decoded alternative name
//  extension whose pszObjId == szOID_NT_PRINCIPAL_NAME.
//
//  The UPN OtherName Value blob is decoded as a X509_UNICODE_ANY_STRING.
//--------------------------------------------------------------------------
static BOOL GetAltNameUPNW(
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return FALSE;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_OTHER_NAME == pEntry->dwAltNameChoice &&
                0 == strcmp(pEntry->pOtherName->pszObjId,
                        szOID_NT_PRINCIPAL_NAME)) {
            PCERT_NAME_VALUE pNameValue;
            if (pNameValue = (PCERT_NAME_VALUE) AllocAndDecodeObject(
                    X509_ASN_ENCODING,
                    X509_UNICODE_ANY_STRING,
                    pEntry->pOtherName->Value.pbData,
                    pEntry->pOtherName->Value.cbData,
                    0                       // dwFlags
                    )) {
                BOOL fIsStr = IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType);

                if (fIsStr)
                    CopyNameStringW((LPWSTR) pNameValue->Value.pbData,
                        pwszNameString, cchNameString, pcwszOut);
                
                PkiFree(pNameValue);

                if (fIsStr)
                    return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  WCHAR string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringW(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cwszOut = 0;
    PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT] = { NULL, NULL };
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;

    DWORD i;
    DWORD dwStrType;
    DWORD dwCertEncodingType;

    if (NULL == pwszNameString)
        cchNameString = 0;

    switch (dwType) {
        case CERT_NAME_EMAIL_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_RFC822_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;

            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            if (!GetAttrStringW(
                    NUM_EMAIL_ATTR_OID,
                    rgpszEmailAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoEmail;
            break;

        case CERT_NAME_DNS_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_DNS_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;

            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            if (!GetAttrStringW(
                    NUM_DNS_ATTR_OID,
                    rgpszDNSAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoDNS;
            break;

        case CERT_NAME_URL_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (!GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_URL,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoURL;
            break;

        case CERT_NAME_UPN_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (!GetAltNameUPNW(
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoUPN;
            break;

        case CERT_NAME_RDN_TYPE:
            dwStrType = pvTypePara ? *((DWORD *) pvTypePara) : 0;

            if (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG)
                dwFlags |= CERT_NAME_DISABLE_IE4_UTF8_FLAG;

            dwCertEncodingType = pCertContext->dwCertEncodingType;
            if (rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                    pCertContext, dwFlags))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[CERT_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else if (rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] =
                    AllocAndGetAltDirNameInfo(pCertContext, dwFlags,
                        &pAltNameInfo))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[ALT_DIR_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else
                goto NoRDN;
            break;

        case CERT_NAME_ATTR_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (!GetAttrStringW(
                    1,                  // cAttrOID
                    (const LPCSTR *) &pvTypePara,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoAttr;
            break;

        case CERT_NAME_FRIENDLY_DISPLAY_TYPE:
            {
                DWORD cbData = 0;

                CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    NULL,                           // pvData
                    &cbData
                    );
                // Need at least one character, plus the null terminator
                if (cbData >= sizeof(WCHAR) * 2) {
                    LPWSTR pwszFriendlyName;

                    // Ensure the Friendly name is null terminated.
                    if (pwszFriendlyName = (LPWSTR) PkiZeroAlloc(
                            cbData + sizeof(WCHAR) * 2)) {
                        BOOL fResult;

                        fResult = CertGetCertificateContextProperty(
                            pCertContext,
                            CERT_FRIENDLY_NAME_PROP_ID,
                            pwszFriendlyName,
                            &cbData
                            );
                        if (fResult)
                            CopyNameStringW(
                                pwszFriendlyName,
                                pwszNameString,
                                cchNameString,
                                &cwszOut
                                );
                        PkiFree(pwszFriendlyName);
                        if (fResult)
                            goto CommonReturn;
                    }
                }
            }
            // Fall through

        case CERT_NAME_SIMPLE_DISPLAY_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (GetAttrStringW(
                    NUM_SIMPLE_DISPLAY_ATTR_OID,
                    rgpszSimpleDisplayAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;
            if (!GetAltNameUnicodeStringChoiceW(
                    CERT_ALT_NAME_RFC822_NAME,
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoSimpleDisplay;
            break;

        default:
            goto InvalidType;
    }

CommonReturn:
    for (i = 0; i < NAME_INFO_CNT; i++)
        PkiFree(rgpNameInfo[i]);
    PkiFree(pAltNameInfo);
    return cwszOut;

ErrorReturn:
    if (0 != cchNameString)
        // Always NULL terminate
        *pwszNameString = L'\0';
    cwszOut = 1;
    goto CommonReturn;

SET_ERROR(NoEmail, CRYPT_E_NOT_FOUND)
SET_ERROR(NoDNS, CRYPT_E_NOT_FOUND)
SET_ERROR(NoURL, CRYPT_E_NOT_FOUND)
SET_ERROR(NoUPN, CRYPT_E_NOT_FOUND)
SET_ERROR(NoRDN, CRYPT_E_NOT_FOUND)
SET_ERROR(NoAttr, CRYPT_E_NOT_FOUND)
SET_ERROR(NoSimpleDisplay, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidType, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  char string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringA(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPSTR pszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertGetNameStringW(
        pCertContext,
        dwType,
        dwFlags,
        pvTypePara,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertGetNameStringW(
            pCertContext,
            dwType,
            dwFlags,
            pvTypePara,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, pszNameString,
        cchNameString);

    PkiFree(pwsz);
    return cszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\crypttls.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       crypttls.cpp
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  Functions:  I_CryptTlsDllMain
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//  Assumption:
//      For PROCESS_ATTACH or THREAD_ATTACH, I_CryptTlsDllMain is called
//      first. For PROCESS_DETACH or THREAD_DETACH, I_CryptTlsDllMain
//      is called last.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include <asn1code.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// CryptTls Entry types
#define FREE_CRYPTTLS       0
#define USER_CRYPTTLS       1
#define OSS_CRYPTTLS        2
#define ASN1_CRYPTTLS       3

typedef struct _ASN1_TLS_ENTRY {
    ASN1encoding_t pEnc;
    ASN1decoding_t pDec;
} ASN1_TLS_ENTRY, *PASN1_TLS_ENTRY;

// The following is reallocated and updated for each I_CryptAllocTls or
// I_CryptInstallOssGlobal. For I_CryptAllocTls, dwType is set to
// USER_CRYPTTLS and dwNext is zeroed.  For I_CryptInstallOssGlobal, dwType
// is set to OSS_CRYPTTLS and pvCtlTbl is updated with pvCtlTbl.
// For I_CryptFreeTls, dwType is set to FREE_CRYPTTLS and dwNext is
// updated with previous dwFreeProcessTlsHead.
//
// The array is indexed via hCryptTls -1 or hOssGlobal -1.
typedef struct _CRYPTTLS_PROCESS_ENTRY {
    DWORD                   dwType;
    union {
        void                    *pvCtlTbl;
        ASN1module_t            pMod;
        // Following is applicable to I_CryptFreeTls'ed entries.
        // Its the array index + 1 of the next free entry. A dwNext
        // of zero terminates.
        DWORD                   dwNext;
    };
} CRYPTTLS_PROCESS_ENTRY, *PCRYPTTLS_PROCESS_ENTRY;
static DWORD cProcessTls;
static PCRYPTTLS_PROCESS_ENTRY pProcessTls;


// The head of the entries freed by I_CryptFreeTls are indexed by the following.
// A 0 index indicates an empty free list.
//
// I_CryptAllocTls first checks this list before reallocating pProcessTls.
static DWORD dwFreeProcessTlsHead;

// The kernel32.dll Thread Local Storage (TLS) slot index
static DWORD iCryptTLS = 0xFFFFFFFF;

// The Thread Local Storage (TLS) referenced by iCryptTLS points to the
// following structure allocated for each thread. Once allocated, not
// reallocated. 
typedef struct _CRYPTTLS_THREAD_HDR CRYPTTLS_THREAD_HDR, *PCRYPTTLS_THREAD_HDR;
struct _CRYPTTLS_THREAD_HDR {
    DWORD                   cTls;
    void                    **ppvTls;   // reallocated
    PCRYPTTLS_THREAD_HDR    pNext;
    PCRYPTTLS_THREAD_HDR    pPrev;
};

// Linked list of all threads having CRYPTTLS
static PCRYPTTLS_THREAD_HDR pThreadTlsHead;


// Minimum number of entries allocated for pProcessTls and the ppvTls
//
// realloc optimization (MIN value is 1)
#define MIN_TLS_ALLOC_COUNT 16

// Used to protect the allocation of TLS and installation of OssGlobals
static CRITICAL_SECTION CryptTlsCriticalSection;


#define OSS_INIT_PROC_IDX                   0
#define OSS_TERM_PROC_IDX                   1
#define OSS_GET_OSS_GLOBAL_SIZE_PROC_IDX    2
#define OSS_SET_ENCODING_RULES_PROC_IDX     3
#define OSS_SET_DECODING_FLAGS_PROC_IDX     4
#define OSS_SET_ENCODING_FLAGS_PROC_IDX     5
#define OSS_PROC_CNT                        6

static LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossinit",                  // 0
    "ossterm",                  // 1
    "ossGetOssGlobalSize",      // 2
    "ossSetEncodingRules",      // 3
    "ossSetDecodingFlags",      // 4
    "ossSetEncodingFlags"       // 5
};

static void *rgpvOssProc[OSS_PROC_CNT];
static HMODULE hmsossDll = NULL;
static BOOL fLoadedOss = FALSE;

static void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

static void OssLoad()
{
    DWORD i;

    if (fLoadedOss)
        return;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (fLoadedOss)
        goto LeaveReturn;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto msossLoadLibraryError;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto msossGetProcAddressError;
    }

LeaveReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
CommonReturn:
    fLoadedOss = TRUE;
    return;

ErrorReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    OssUnload();
    goto CommonReturn;
TRACE_ERROR(msossLoadLibraryError)
TRACE_ERROR(msossGetProcAddressError)
}


// nonstandard extension used : redefined extern to static
#pragma warning (disable: 4211)

typedef int  (DLL_ENTRY* pfnossinit)(struct ossGlobal *world,
							void *ctl_tbl);
static int  DLL_ENTRY ossinit(struct ossGlobal *world,
							void *ctl_tbl)
{
    if (hmsossDll)
        return ((pfnossinit) rgpvOssProc[OSS_INIT_PROC_IDX])(
            world,
            ctl_tbl);
    else
        return API_DLL_NOT_LINKED;
}

typedef void (DLL_ENTRY* pfnossterm)(struct ossGlobal *world);
static void DLL_ENTRY ossterm(struct ossGlobal *world)
{
    if (hmsossDll)
        ((pfnossterm) rgpvOssProc[OSS_TERM_PROC_IDX])(world);
}

typedef int (DLL_ENTRY* pfnossGetOssGlobalSize)(void);
static int DLL_ENTRY ossGetOssGlobalSize(void)
{
    if (hmsossDll)
        return ((pfnossGetOssGlobalSize)
            rgpvOssProc[OSS_GET_OSS_GLOBAL_SIZE_PROC_IDX])();
    else
        return 0;
}

typedef int (DLL_ENTRY* pfnossSetEncodingRules)(struct ossGlobal *world,
						ossEncodingRules rules);
static int DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules)
{
    if (hmsossDll)
        return ((pfnossSetEncodingRules)
            rgpvOssProc[OSS_SET_ENCODING_RULES_PROC_IDX])(
                world,
                rules);
    else
        return API_DLL_NOT_LINKED;
}

#if !DBG

typedef int (DLL_ENTRY* pfnossSetDecodingFlags)(struct ossGlobal *world,
							unsigned long flags);
static int DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetDecodingFlags)
            rgpvOssProc[OSS_SET_DECODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int      (DLL_ENTRY* pfnossSetEncodingFlags)(struct ossGlobal *world,
							unsigned long flags);
static int DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetEncodingFlags)
            rgpvOssProc[OSS_SET_ENCODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

#endif


//+-------------------------------------------------------------------------
//  Free the thread's CRYPT TLS
//
//  Upon entry/exit, in CryptTlsCriticalSection
//--------------------------------------------------------------------------
static void FreeCryptTls(
    IN PCRYPTTLS_THREAD_HDR pTlsHdr
    )
{
    if (pTlsHdr->pNext)
        pTlsHdr->pNext->pPrev = pTlsHdr->pPrev;
    if (pTlsHdr->pPrev)
        pTlsHdr->pPrev->pNext = pTlsHdr->pNext;
    else if (pTlsHdr == pThreadTlsHead)
        pThreadTlsHead = pTlsHdr->pNext;
    else {
        assert(pTlsHdr == pThreadTlsHead);
    }

    if (pTlsHdr->ppvTls)
        free(pTlsHdr->ppvTls);
    free(pTlsHdr);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptTlsDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet;
    PCRYPTTLS_THREAD_HDR pTlsHdr;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (!Pki_InitializeCriticalSection(&CryptTlsCriticalSection))
            goto InitCritSectionError;
        if ((iCryptTLS = TlsAlloc()) == 0xFFFFFFFF) {
            DeleteCriticalSection(&CryptTlsCriticalSection);
            goto TlsAllocError;
        }
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        if (pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS)) {
            DWORD cTls;
            DWORD cDetach = 0;
            DWORD i;

            cTls = pTlsHdr->cTls;

            EnterCriticalSection(&CryptTlsCriticalSection);
            assert(cTls <= cProcessTls);
            for (i = 0; i < cTls; i++) {
                void *pvTls;
                if (pvTls = pTlsHdr->ppvTls[i]) {
                    switch (pProcessTls[i].dwType) {
                        case OSS_CRYPTTLS:
                            // Following API is in delay loaded msoss.dll. 
                            __try {
                                ossterm((POssGlobal) pvTls);
                            } __except(EXCEPTION_EXECUTE_HANDLER) {
                            }
                            free(pvTls);
                            pTlsHdr->ppvTls[i] = NULL;
                            break;
                        case ASN1_CRYPTTLS:
                            {
                                PASN1_TLS_ENTRY pAsn1TlsEntry =
                                    (PASN1_TLS_ENTRY) pvTls;

                                if (pAsn1TlsEntry->pEnc)
                                    ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                                if (pAsn1TlsEntry->pDec)
                                    ASN1_CloseDecoder(pAsn1TlsEntry->pDec);
                                free(pvTls);
                                pTlsHdr->ppvTls[i] = NULL;
                            }
                            break;
                        case USER_CRYPTTLS:
                            cDetach++;
                            break;
                        default:
                            assert(FREE_CRYPTTLS == pProcessTls[i].dwType);
                    }

                }
            }

            FreeCryptTls(pTlsHdr);
            TlsSetValue(iCryptTLS, 0);
            
            LeaveCriticalSection(&CryptTlsCriticalSection);
            assert(cDetach == 0);
        }

        if (ulReason == DLL_PROCESS_DETACH) {
            while(pThreadTlsHead)
                FreeCryptTls(pThreadTlsHead);

            if (pProcessTls) {
                free(pProcessTls);
                pProcessTls = NULL;
            }
            cProcessTls = 0;
            dwFreeProcessTlsHead = 0;

            OssUnload();
            DeleteCriticalSection(&CryptTlsCriticalSection);
            TlsFree(iCryptTLS);
            iCryptTLS = 0xFFFFFFFF;
        }
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(TlsAllocError)
}

//+-------------------------------------------------------------------------
//  Get a pointer to the Crypt TLS entries. Check that the hCryptTls is
//  included in the list of entries. If hCryptTls isn't included and
//  allocation isn't inhibited, alloc/realloc the array of TLS entries.
//
//  Also verifies the hCryptTls handle.
//--------------------------------------------------------------------------
STATIC void **GetCryptTls(
    IN HCRYPTTLS hCryptTls,
    IN BOOL fInhibitAlloc       // TRUE for I_CryptDetachTls
    )
{
    PCRYPTTLS_THREAD_HDR pTlsHdr;
    DWORD cTls;
    void **ppvTls;
    DWORD i;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS);
    cTls = pTlsHdr ? pTlsHdr->cTls : 0;
    if (hCryptTls < cTls)
        return pTlsHdr->ppvTls;

    if (fInhibitAlloc)
        return NULL;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;
    assert(cTls < cProcessTls);

    // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
    // the previous memory pointer can't be NULL.
    if (pTlsHdr) {
        if (cProcessTls > MIN_TLS_ALLOC_COUNT) {
            if (NULL == (ppvTls = (void **) realloc(pTlsHdr->ppvTls,
                    cProcessTls * sizeof(void *))))
                goto OutOfMemory;
        } else {
            ppvTls = pTlsHdr->ppvTls;
            assert(ppvTls);
        }
    } else {
        DWORD cAllocTls = (cProcessTls > MIN_TLS_ALLOC_COUNT) ?
            cProcessTls : MIN_TLS_ALLOC_COUNT;
        if (NULL == (ppvTls = (void **) malloc(cAllocTls * sizeof(void *))))
            goto OutOfMemory;
        if (NULL == (pTlsHdr = (PCRYPTTLS_THREAD_HDR) malloc(
                sizeof(CRYPTTLS_THREAD_HDR)))) {
            free(ppvTls);
            goto OutOfMemory;
        }

        if (!TlsSetValue(iCryptTLS, pTlsHdr)) {
            free(pTlsHdr);
            free(ppvTls);
            goto TlsSetValueError;
        }

        pTlsHdr->pPrev = NULL;
        pTlsHdr->pNext = pThreadTlsHead;
        if (pThreadTlsHead)
            pThreadTlsHead->pPrev = pTlsHdr;
        pThreadTlsHead = pTlsHdr;
    }

    for (i = cTls; i < cProcessTls; i++)
        ppvTls[i] = NULL;
    pTlsHdr->ppvTls = ppvTls;
    pTlsHdr->cTls = cProcessTls;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return ppvTls;

ErrorReturn:
    ppvTls = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(TlsSetValueError)
}

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls()
{
    HCRYPTTLS hCryptTls;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (dwFreeProcessTlsHead) {
        PCRYPTTLS_PROCESS_ENTRY pEntry;

        hCryptTls = (HCRYPTTLS) dwFreeProcessTlsHead;
        assert(hCryptTls <= cProcessTls);
        pEntry = &pProcessTls[dwFreeProcessTlsHead - 1];
        assert(FREE_CRYPTTLS == pEntry->dwType);
        assert(pEntry->dwNext <= cProcessTls);

        pEntry->dwType = USER_CRYPTTLS;
        dwFreeProcessTlsHead = pEntry->dwNext;
        pEntry->dwNext = 0;
    } else {
        PCRYPTTLS_PROCESS_ENTRY pNewProcessTls;

        // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
        // the previous memory pointer can't be NULL.
        if (pProcessTls) {
            if (cProcessTls + 1 > MIN_TLS_ALLOC_COUNT)
                pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) realloc(pProcessTls,
                    (cProcessTls + 1) * sizeof(CRYPTTLS_PROCESS_ENTRY));
            else
                pNewProcessTls = pProcessTls;
        } else
            pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) malloc(
                (MIN_TLS_ALLOC_COUNT) * sizeof(CRYPTTLS_PROCESS_ENTRY));

        if (pNewProcessTls) {
            pNewProcessTls[cProcessTls].dwType = USER_CRYPTTLS;
            pNewProcessTls[cProcessTls].dwNext = 0;
            hCryptTls = (HCRYPTTLS) ++cProcessTls;
            pProcessTls = pNewProcessTls;
        } else {
            SetLastError((DWORD) E_OUTOFMEMORY);
            hCryptTls = 0;
        }
    }

    LeaveCriticalSection(&CryptTlsCriticalSection);
    return hCryptTls;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    )
{
    BOOL fResult;
    DWORD dwType;
    PCRYPTTLS_THREAD_HDR pThreadTls;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;

    dwType = pProcessTls[hCryptTls].dwType;
    if (!(OSS_CRYPTTLS == dwType || USER_CRYPTTLS == dwType ||
            ASN1_CRYPTTLS == dwType))
        goto InvalidArg;

    // Iterate through the threads having CRYPTTLS
    pThreadTls = pThreadTlsHead;
    while (pThreadTls) {
        PCRYPTTLS_THREAD_HDR pThreadTlsNext;

        pThreadTlsNext = pThreadTls->pNext;
        if (pThreadTls->cTls > hCryptTls) {
            void *pvTls = pThreadTls->ppvTls[hCryptTls];
            if (pvTls) {
                pThreadTls->ppvTls[hCryptTls] = NULL;

                if (OSS_CRYPTTLS == dwType) {
                    // Following API is in delay loaded msoss.dll. 
                    __try {
                        ossterm((POssGlobal) pvTls);
                    } __except(EXCEPTION_EXECUTE_HANDLER) {
                    }
                    free(pvTls);
                } else if (ASN1_CRYPTTLS == dwType) {
                    PASN1_TLS_ENTRY pAsn1TlsEntry =
                        (PASN1_TLS_ENTRY) pvTls;

                    if (pAsn1TlsEntry->pEnc)
                        ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                    if (pAsn1TlsEntry->pDec)
                        ASN1_CloseDecoder(pAsn1TlsEntry->pDec);

                    free(pvTls);
                } else if (pfnFree) {
                    // Don't call the callback holding the critical section
                    LeaveCriticalSection(&CryptTlsCriticalSection);
                    pfnFree(pvTls);
                    EnterCriticalSection(&CryptTlsCriticalSection);

                    // In case this thread gets deleted, start over at
                    // the beginning.
                    pThreadTlsNext = pThreadTlsHead;
                }
            }
        }

        pThreadTls = pThreadTlsNext;
    }

    // Insert in beginning of process free list
    pProcessTls[hCryptTls].dwType = FREE_CRYPTTLS;
    pProcessTls[hCryptTls].dwNext = dwFreeProcessTlsHead;
    dwFreeProcessTlsHead = hCryptTls + 1;
    fResult = TRUE;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized or NULL pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        if (NULL == (pvTls = ppvTls[hCryptTls - 1]))
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    )
{
    void **ppvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        ppvTls[hCryptTls - 1] = pvTls;
        return TRUE;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            TRUE)) {        // fInhibitAlloc
        if (pvTls = ppvTls[hCryptTls - 1])
            ppvTls[hCryptTls - 1] = NULL;
        else
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTOSSGLOBAL hOssGlobal;

    if (hOssGlobal = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hOssGlobal - 1].dwType = OSS_CRYPTTLS;
        pProcessTls[hOssGlobal - 1].pvCtlTbl = pvCtlTbl;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hOssGlobal;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hOssGlobal,
        NULL                        // pfnFree
        );
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    POssGlobal pog;
    void **ppvTls;
    DWORD iOssGlobal;
    DWORD dwType;
    void *pvCtlTbl;
    DWORD dwExceptionCode;
    int cbOssGlobalSize; 

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hOssGlobal,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iOssGlobal = (DWORD) hOssGlobal - 1;
    if (pog = (POssGlobal) ppvTls[iOssGlobal])
        return pog;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iOssGlobal].dwType;
    pvCtlTbl = pProcessTls[iOssGlobal].pvCtlTbl;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (OSS_CRYPTTLS != dwType || NULL == pvCtlTbl)
        goto InvalidArg;

    __try {
        // Attempt to do delay, demand loading of msoss.dll
        OssLoad();

        if (0 >= (cbOssGlobalSize = ossGetOssGlobalSize()))
            goto ossGetOssGlobalSizeError;
        if (NULL == (pog = (POssGlobal) malloc(cbOssGlobalSize)))
            goto OutOfMemory;
        if (0 != ossinit(pog, pvCtlTbl))
            goto ossinitError;
        if (0 != ossSetEncodingRules(pog, OSS_DER))
            goto SetEncodingRulesError;
#if DBG
        if (!DbgInitOSS(pog))
            goto DbgInitOSSError;
#else
        if (0 != ossSetEncodingFlags(pog, NOTRAPPING | FRONT_ALIGN))
            goto SetEncodingFlagsError;
        if (0 != ossSetDecodingFlags(pog, NOTRAPPING | RELAXBER))
            goto SetDecodingFlagsError;
#endif
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto msossLoadLibraryException;
    }

    ppvTls[iOssGlobal] = pog;
CommonReturn:
    return pog;

ErrorReturn:
    if (pog) {
        free(pog);
        pog = NULL;
    }
    goto CommonReturn;

SET_ERROR(ossGetOssGlobalSizeError, ERROR_MOD_NOT_FOUND)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ossinitError)
TRACE_ERROR(SetEncodingRulesError)
#if DBG
TRACE_ERROR(DbgInitOSSError)
#else
TRACE_ERROR(SetEncodingFlagsError)
TRACE_ERROR(SetDecodingFlagsError)
#endif
SET_ERROR_VAR(msossLoadLibraryException, dwExceptionCode)
}

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTASN1MODULE hAsn1Module;

    if (hAsn1Module = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hAsn1Module - 1].dwType = ASN1_CRYPTTLS;
        pProcessTls[hAsn1Module - 1].pMod = pMod;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hAsn1Module;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hAsn1Module,
        NULL                        // pfnFree
        );
}


STATIC
PASN1_TLS_ENTRY
WINAPI
I_CryptGetAsn1Tls(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    void **ppvTls;
    DWORD iAsn1Module;

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hAsn1Module,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iAsn1Module = (DWORD) hAsn1Module - 1;
    if (pAsn1TlsEntry = (PASN1_TLS_ENTRY) ppvTls[iAsn1Module])
        return pAsn1TlsEntry;

    if (NULL == (pAsn1TlsEntry = (PASN1_TLS_ENTRY) malloc(
            sizeof(ASN1_TLS_ENTRY))))
        goto OutOfMemory;
    memset(pAsn1TlsEntry, 0, sizeof(ASN1_TLS_ENTRY));

    ppvTls[iAsn1Module] = pAsn1TlsEntry;
CommonReturn:
    return pAsn1TlsEntry;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1encoding_t pEnc;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pEnc = pAsn1TlsEntry->pEnc)
        return pEnc;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateEncoder(
        pMod,
        &pEnc,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateEncoderError;

    pAsn1TlsEntry->pEnc = pEnc;
CommonReturn:
    return pEnc;

ErrorReturn:
    pEnc = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateEncoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1decoding_t pDec;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pDec = pAsn1TlsEntry->pDec)
        return pDec;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateDecoder(
        pMod,
        &pDec,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateDecoderError;

    pAsn1TlsEntry->pDec = pDec;
CommonReturn:
    return pDec;

ErrorReturn:
    pDec = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateDecoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\dblog.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dblog.cpp
//
//  Contents:   Database Log Event APIs
//
//  Functions:  I_DBLogCrypt32Event
//              I_DBLogAttach
//              I_DBLogDetach
//
//  History:    11-Oct-00    philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef ROOT_AUTO_UPDATE_DOGFOOD

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#include "sql.h"
#include "sqlext.h"
#include "sqltypes.h"
#include "odbcss.h"

#define SQL_CALL_SUCCESS(status) (status == SQL_SUCCESS || status == SQL_SUCCESS_WITH_INFO)
				 
#if DBG || DEBUG
#define DebugPrint(a) _DebugPrintW a
void
__cdecl
_DebugPrintW(
    LPCWSTR szFormat,
    ...
    )
{
    WCHAR szBuffer[512];
    va_list ap;

    va_start(ap, szFormat);
    vswprintf(szBuffer, szFormat, ap);
    OutputDebugStringW(szBuffer);
}

int debugLine = __LINE__;
#define DEBUG_MARKER debugLine = __LINE__

#else

#define DebugPrint(a)
#define DEBUG_MARKER

#endif

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)

typedef struct _DBLOG_EVENT_DATA {
    DWORD               dwStatus;
    DWORD               dwCPU64;
    TIMESTAMP_STRUCT    TimeStamp;
    WCHAR               wszOperation[16];
    WCHAR               wszHash[SHA1_HASH_NAME_LEN + 1];
    WCHAR               wszSubject[64];
    WCHAR               wszBuildLab[64];
    WCHAR               wszMachineName[32];
} DBLOG_EVENT_DATA, *PDBLOG_EVENT_DATA;


void
I_DBLogAttach()
{
}

void
I_DBLogDetach()
{
}

DWORD WINAPI I_DBLogCrypt32EventThreadProc(
    LPVOID lpThreadParameter
    )
{
    PDBLOG_EVENT_DATA pEventData = (PDBLOG_EVENT_DATA) lpThreadParameter;

	SQLRETURN RetCode = SQL_SUCCESS;
	HSTMT hStmt = NULL;
	HENV	hEnv = NULL, hDbc = NULL;

    __try {
		__try {
            RetCode = SQLAllocHandle(
                SQL_HANDLE_ENV, 
                SQL_NULL_HANDLE,
                &hEnv
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetEnvAttr(
                hEnv,
                SQL_ATTR_ODBC_VERSION,
                (SQLPOINTER) SQL_OV_ODBC3,	
                SQL_IS_INTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLAllocHandle(
                SQL_HANDLE_DBC,
                hEnv,
                &hDbc
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetConnectAttr(
                hDbc, 
                SQL_ATTR_LOGIN_TIMEOUT, 
                (SQLPOINTER) 120,
                SQL_IS_UINTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

            RetCode = SQLSetConnectAttr(
                hDbc, 
                SQL_COPT_SS_INTEGRATED_SECURITY, 
                (SQLPOINTER) SQL_IS_OFF,
                SQL_IS_INTEGER
                );

            if(!SQL_CALL_SUCCESS(RetCode)) {
                DEBUG_MARKER;
                __leave;
            }

			{
				SQLWCHAR szConnect[1024];
				SQLSMALLINT cbConnect = 0;

				SQLWCHAR szInConnect[] = L"DRIVER=SQL Server;SERVER=kschutz-team2;UID=crypt32;PWD=crypt32;DATABASE=Crypt32";

				RetCode = SQLDriverConnectW(
					hDbc,
					NULL,
					szInConnect,
					SQL_NTS,
					szConnect,
					sizeof(szConnect) / sizeof(szConnect[0]),
					&cbConnect,
					SQL_DRIVER_NOPROMPT
					);

				if(!SQL_CALL_SUCCESS(RetCode)) {
					DEBUG_MARKER;
					__leave;
				}
			}

			RetCode = SQLAllocHandle(
				SQL_HANDLE_STMT,
				hDbc, 
				&hStmt
				);

			if(!SQL_CALL_SUCCESS(RetCode)) {
				DEBUG_MARKER;
				__leave;
			}

			WCHAR szStatement[] = 
				L"INSERT INTO AddRoot2 ("
				L"OPERATION,"
				L"STATUS,"
				L"TIMESTAMP,"
				L"HASH,"
				L"SUBJECT,"
				L"MACHINENAME,"
				L"BUILDLAB,"
				L"CPU64"
				L") VALUES (?,?,?,?,?,?,?,?)";

			RetCode = SQLPrepareW(
				hStmt,
				szStatement, 
				SQL_NTS
				);

			if(!SQL_CALL_SUCCESS(RetCode)) {
				DEBUG_MARKER;
				__leave;
			}

			SQLUSMALLINT iParamNo = 1;

			//
			// OPERATION
			//
			SQLLEN cbOperation = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszOperation) / sizeof(WCHAR),
				0,
				pEventData->wszOperation,
				0,
				&cbOperation
				);

			//
			// STATUS
			//
			SQLLEN cbStatus = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_LONG,
				SQL_INTEGER,
				0,
				0,
				&pEventData->dwStatus,
				0,
				&cbStatus
				);

			//
			// TIMESTAMP
			//

			SQLLEN cbTimeStamp = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_TIMESTAMP, 
				SQL_TIMESTAMP,
				19,
				0,
				&pEventData->TimeStamp,
				0,
				&cbTimeStamp
				);

			//
			// HASH
			//

			SQLLEN cbHash = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszHash) / sizeof(WCHAR),
				0,
				pEventData->wszHash,
				0,
				&cbHash
				);

			//
			// SUBJECT
			//

			SQLLEN cbSubject = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszSubject) / sizeof(WCHAR),
				0,
				pEventData->wszSubject,
				0,
				&cbSubject
				);

			//
			// MACHINENAME
			//

			SQLLEN cbMachineName = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszMachineName) / sizeof(WCHAR),
				0,
				pEventData->wszMachineName,
				0,
				&cbMachineName
				);

			//
			// BUILDLAB
			//

			SQLLEN cbBuildLab = SQL_NTS;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_WCHAR,
				SQL_WCHAR,
				sizeof(pEventData->wszBuildLab) / sizeof(WCHAR),
				0,
				pEventData->wszBuildLab,
				0,
				&cbBuildLab
				);

			//
			// CPU64
			//
			SQLLEN cbCPU64 = 0;
			SQLBindParameter(
				hStmt, 
				iParamNo++, 
				SQL_PARAM_INPUT,
				SQL_C_TINYINT,
				SQL_TINYINT,
				0,
				0,
				&pEventData->dwCPU64,
				0,
				&cbCPU64
				);


			RetCode = SQLExecute(hStmt);
			DEBUG_MARKER;
		}
		__finally {

		}

		if (!SQL_CALL_SUCCESS(RetCode)) {

			SDWORD		swError;
			SQLWCHAR	szErrorMsg[SQL_MAX_MESSAGE_LENGTH];
			SWORD		swErrorMsg;
			SQLWCHAR	szSQLState[50];

			SQLErrorW(
				hEnv, 
				hDbc, 
				hStmt, 
				szSQLState,
				&swError, 
				szErrorMsg, 
				SQL_MAX_MESSAGE_LENGTH - 1, 
				&swErrorMsg
				);

			DebugPrint(
				(L"I_DBLogCrypt32EventThreadProc: Error (%d) - %s (%s)\n", 
				debugLine,
				szErrorMsg,
				szSQLState)
				);
		}

		if (hStmt) {
			SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
		}


        if (hDbc) {
            SQLDisconnect(hDbc);
            SQLFreeHandle(SQL_HANDLE_DBC, hDbc);
        }

        if (hEnv) {
            SQLFreeHandle(SQL_HANDLE_ENV, hEnv);
        }
			
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint(
            (L"I_DBLogCrypt32EventThreadProc: Exception Error (%d)\n", 
            GetExceptionCode())
            );
        RetCode = SQL_ERROR;
    }

    PkiFree(pEventData);


    DebugPrint(
        (L"I_DBLogCrypt32EventThreadProc %s\n", 
        (SQL_CALL_SUCCESS(RetCode) ? L"succeeded" : L"failed"))
        );

	return 0;
}

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
    PDBLOG_EVENT_DATA pEventData = NULL;
    HANDLE hThread = NULL;

    if (NULL == (pEventData = (PDBLOG_EVENT_DATA) PkiZeroAlloc(
            sizeof(DBLOG_EVENT_DATA))))
        goto OutOfMemory;

    switch (dwEventID) {
        case MSG_ROOT_AUTO_UPDATE_INFORMATIONAL:
        case MSG_UNTRUSTED_ROOT_INFORMATIONAL:
        case MSG_PARTIAL_CHAIN_INFORMATIONAL:
            switch (dwEventID) {
                case MSG_ROOT_AUTO_UPDATE_INFORMATIONAL:
                    // Successful auto update of third-party root certificate::
                    // Subject: <%1> Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"AddCert");
                    break;
                case MSG_UNTRUSTED_ROOT_INFORMATIONAL:
                    // Untrusted root certificate:: Subject: <%1>
                    // Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"UntrustedRoot");
                    break;
                case MSG_PARTIAL_CHAIN_INFORMATIONAL:
                    // Partial Chain:: Issuer: <%1>
                    // Subject Sha1 thumbprint: <%2>
                    wcscpy(pEventData->wszOperation, L"PartialChain");
                    break;
            }
            if (2 <= wNumStrings) {
                wcsncpy(pEventData->wszSubject, rgpwszStrings[0],
                    sizeof(pEventData->wszSubject) / sizeof(WCHAR) - 1);
                wcsncpy(pEventData->wszHash, rgpwszStrings[1],
                    sizeof(pEventData->wszHash) / sizeof(WCHAR) - 1);
            }
            break;

        case MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root list cab from: <%1>
        case MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root list cab from: <%1>
            // with error: %2
            wcscpy(pEventData->wszOperation, L"FetchCab");
            break;

        case MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR:
            // Failed extract of third-party root list from auto update
            // cab at: <%1> with error: %2
            wcscpy(pEventData->wszOperation, L"ExtractCtl");
            break;

        case MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root certificate from: <%1>
        case MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root certificate from: <%1>
            //  with error: %2
            wcscpy(pEventData->wszOperation, L"FetchCert");

            // %1 contains
            //  "RootDir" "/" "AsciiHexHash" ".cer"
            //  for example,
            //  "http://www.xyz.com/roots/216B2A29E62A00CE820146D8244141B92511B279.cer"
            {
                LPCWSTR pwszHash = rgpwszStrings[0];
                DWORD cchHash;

                cchHash = wcslen(pwszHash);

                if ((SHA1_HASH_NAME_LEN + 4) <= cchHash)
                    memcpy(pEventData->wszHash,
                        pwszHash + (cchHash - (SHA1_HASH_NAME_LEN + 4)),
                        SHA1_HASH_NAME_LEN * sizeof(WCHAR));
            }
            break;

        case MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING:
            // Reached crypt32 threshold of %1 events and will suspend
            // logging for %2 minutes
            wcscpy(pEventData->wszOperation, L"EventOverflow");
            break;

        case MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL:
            // Successful auto update of third-party root list sequence
            // number from: <%1>
        case MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_ERROR:
            // Failed auto update of third-party root list sequence number
            // from: <%1> with error: %2
            wcscpy(pEventData->wszOperation, L"FetchSeq");
            break;

        default:
            goto SkipDbLogCrypt32Event;
    }

    if (MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING == dwEventID)
        pEventData->dwStatus = (DWORD) ERROR_BUFFER_OVERFLOW;
    else if (EVENTLOG_ERROR_TYPE == wType && 2 <= wNumStrings)
        // The second string should contain the error code string
        pEventData->dwStatus = (DWORD) wcstoul(rgpwszStrings[1], NULL, 0);

    {
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);
        pEventData->TimeStamp.day = SystemTime.wDay;
        pEventData->TimeStamp.month = SystemTime.wMonth;
        pEventData->TimeStamp.year = SystemTime.wYear;
        pEventData->TimeStamp.hour = SystemTime.wHour;
        pEventData->TimeStamp.minute = SystemTime.wMinute;
        pEventData->TimeStamp.second = SystemTime.wSecond;
        // pEventData->TimeStamp.fraction = 0;
    }

    {
        WCHAR wszMachineName[MAX_PATH] = L"";
        DWORD cchMachineName = sizeof(wszMachineName) / sizeof(WCHAR);

        // intentionally ignore any failures
        GetComputerNameExW(
            ComputerNameDnsHostname, 
            wszMachineName,         
            &cchMachineName    
            );

        wcsncpy(pEventData->wszMachineName, wszMachineName,
            sizeof(pEventData->wszMachineName) / sizeof(WCHAR) - 1);
    }

    {
        HKEY hKey;
        WCHAR wszBuildLab[MAX_PATH];
        DWORD dwStatus;

        wcscpy(wszBuildLab, L"<BuildLab Unknown>");

        dwStatus = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hKey
            );

        if (dwStatus == ERROR_SUCCESS) {
            DWORD dwType = REG_SZ;
            DWORD cbBuildLab = sizeof(wszBuildLab);

            dwStatus = RegQueryValueExW(
                hKey,
                L"BuildLab",
                0,
                &dwType,
                (LPBYTE) wszBuildLab,
                &cbBuildLab
                );

            if (dwStatus != ERROR_SUCCESS) {
                dwType = REG_SZ;
                cbBuildLab = sizeof(wszBuildLab);

                dwStatus = RegQueryValueExW(
                    hKey,
                    L"CurrentBuildNumber",
                    0,
                    &dwType,
                    (LPBYTE) wszBuildLab,
                    &cbBuildLab
                    );
            }
            RegCloseKey(hKey);
        }

        wcsncpy(pEventData->wszBuildLab, wszBuildLab,
            sizeof(pEventData->wszBuildLab) / sizeof(WCHAR) - 1);
    }

#if defined(M_IA64) || defined(IA64) || defined(_IA64_)
    pEventData->dwCPU64 = 1;
#endif

    // Create the thread to do the logging to the database
    if (NULL == (hThread = CreateThread(
            NULL,           // lpThreadAttributes
            0,              // dwStackSize
            I_DBLogCrypt32EventThreadProc,
            pEventData,
            0,              // dwCreationFlags
            NULL            // pdwThreadId
            )))
        goto CreateThreadError;

    CloseHandle(hThread);

CommonReturn:
    return;

ErrorReturn:
    PkiFree(pEventData);
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SkipDbLogCrypt32Event)
TRACE_ERROR(CreateThreadError)
}


#else

void
I_DBLogAttach()
{
}

void
I_DBLogDetach()
{
}

void
I_DBLogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\ctlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ctlfunc.cpp
//
//  Contents:   Certificate Verify CTL Usage Dispatch Functions
//
//  Functions:  I_CertCTLUsageFuncDllMain
//              CertVerifyCTLUsage
//
//  History:    29-Apr-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hUsageFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_CTL_USAGE)(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCTLUsageFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hUsageFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static void ZeroUsageStatus(
    IN OUT PCTL_VERIFY_USAGE_STATUS pUsageStatus)
{
    pUsageStatus->dwError = 0;
    pUsageStatus->dwFlags = 0;
    if (pUsageStatus->ppCtl)
        *pUsageStatus->ppCtl = NULL;
    pUsageStatus->dwCtlEntryIndex = 0;
    if (pUsageStatus->ppSigner)
        *pUsageStatus->ppSigner = NULL;
    pUsageStatus->dwSignerIndex = 0;
}

//+-------------------------------------------------------------------------
//  Remember the "most interesting" error
//--------------------------------------------------------------------------
static void UpdateUsageError(
    IN DWORD dwNewError,
    IN OUT DWORD *pdwError
    )
{
    if (0 != dwNewError) {
        DWORD dwError = *pdwError;
        if ((DWORD) CRYPT_E_NOT_IN_CTL == dwNewError ||
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL == dwError
                        ||
            ((DWORD) CRYPT_E_NOT_IN_CTL != dwError &&
                (DWORD) CRYPT_E_NO_TRUSTED_SIGNER != dwError &&
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_CHECK != dwNewError))
            *pdwError = dwNewError;
    }
}

static BOOL VerifyDefaultUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroUsageStatus(pVerifyUsageStatus);
        fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                dwEncodingType,
                dwSubjectType,
                pvSubject,
                pSubjectUsage,
                dwFlags,
                pVerifyUsagePara,
                pVerifyUsageStatus);
        if (fResult) {
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to verify usage for this installed
            // function. However, remember any "interesting"
            // errors.
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
    }

    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                    dwEncodingType,
                    dwSubjectType,
                    pvSubject,
                    pSubjectUsage,
                    dwFlags,
                    pVerifyUsagePara,
                    pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult)
                goto CommonReturn;
            else
                // Unable to verify usage for this registered
                // function. However, remember any "interesting"
                // errors.
                UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pVerifyUsageStatus->dwError = dwError;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

static BOOL VerifyOIDUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PVOID pvFuncAddr;

    if (pSubjectUsage && pSubjectUsage->cUsageIdentifier > 0 && 
            CryptGetOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pSubjectUsage->rgpszUsageIdentifier[0],
                0,                                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                        dwEncodingType,
                        dwSubjectType,
                        pvSubject,
                        pSubjectUsage,
                        dwFlags,
                        pVerifyUsagePara,
                        pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        pVerifyUsageStatus->dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL;
        fResult = FALSE;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify that a subject is trusted for the specified usage by finding a
//  signed and time valid CTL with the usage identifiers and containing the
//  the subject. A subject can be identified by either its certificate context
//  or any identifier such as its SHA1 hash.
//
//  See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject
//  parameters.
//
//  Via pVerifyUsagePara, the caller can specify the stores to be searched
//  to find the CTL. The caller can also specify the stores containing
//  acceptable CTL signers. By setting the ListIdentifier, the caller
//  can also restrict to a particular signer CTL list.
//
//  Via pVerifyUsageStatus, the CTL containing the subject, the subject's
//  index into the CTL's array of entries, and the signer of the CTL
//  are returned. If the caller is interested, ppCtl and ppSigner can be set
//  to NULL. Returned contexts must be freed via the store's free context APIs.
//
//  If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time
//  invalid CTL in one of the CtlStores may be replaced. When replaced, the
//  CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus->dwFlags.
//
//  If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//  SignerStores specified in pVerifyUsageStatus are searched to find
//  the signer. Otherwise, the SignerStores provide additional sources
//  to find the signer's certificate.
//
//  If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked
//  for time validity.
//
//  If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain
//  additional usage identifiers than specified by pSubjectUsage. Otherwise,
//  the found CTL will contain the same usage identifers and no more.
//
//  CertVerifyCTLUsage will be implemented as a dispatcher to OID installable
//  functions. First, it will try to find an OID function matching the first
//  usage object identifier in the pUsage sequence. Next, it will dispatch
//  to the default CertDllVerifyCTLUsage functions.
//
//  If the subject is trusted for the specified usage, then, TRUE is
//  returned. Otherwise, FALSE is returned with dwError set to one of the
//  following:
//      CRYPT_E_NO_VERIFY_USAGE_DLL
//      CRYPT_E_NO_VERIFY_USAGE_CHECK
//      CRYPT_E_VERIFY_USAGE_OFFLINE
//      CRYPT_E_NOT_IN_CTL
//      CRYPT_E_NO_TRUSTED_SIGNER
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCTLUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;

    assert(NULL == pVerifyUsagePara || pVerifyUsagePara->cbSize >=
        sizeof(CTL_VERIFY_USAGE_PARA));
    assert(pVerifyUsageStatus && pVerifyUsageStatus->cbSize >=
        sizeof(CTL_VERIFY_USAGE_STATUS));
    if (pVerifyUsagePara && pVerifyUsagePara->cbSize <
            sizeof(CTL_VERIFY_USAGE_PARA))
        goto InvalidArg;
    if (NULL == pVerifyUsageStatus || pVerifyUsageStatus->cbSize <
            sizeof(CTL_VERIFY_USAGE_STATUS))
        goto InvalidArg;


    fResult = VerifyOIDUsage(
        dwEncodingType,
        dwSubjectType,
        pvSubject,
        pSubjectUsage,
        dwFlags,
        pVerifyUsagePara,
        pVerifyUsageStatus);
    if (!fResult) {
        DWORD dwError = pVerifyUsageStatus->dwError;

        fResult = VerifyDefaultUsage(
            dwEncodingType,
            dwSubjectType,
            pvSubject,
            pSubjectUsage,
            dwFlags,
            pVerifyUsagePara,
            pVerifyUsageStatus);
        if (!fResult) {
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
            ZeroUsageStatus(pVerifyUsageStatus);
            pVerifyUsageStatus->dwError = dwError;
            SetLastError(dwError);
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\ekuhlpr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ekuhlpr.cpp
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    21-May-97    kirtd    Created
//              xx-xxx-xx    reidk    Added CertGetValidUsages
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetEnhancedKeyUsage
//
//  Synopsis:   gets the enhanced key usage extension/property from the
//              certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetEnhancedKeyUsage (
                IN     PCCERT_CONTEXT     pCertContext,
                IN     DWORD              dwFlags,
                OUT    PCERT_ENHKEY_USAGE pUsage,
                IN OUT DWORD*             pcbUsage
                )
{
    HRESULT           hr = S_OK;
    CRYPT_OBJID_BLOB  cob;
    BOOL fExtCertPolicies = FALSE;
    PCRYPT_OBJID_BLOB pExtBlob = NULL;
    PCRYPT_OBJID_BLOB pPropBlob = NULL;

    //
    // If the flags are zero then assume they want everything
    //

    if ( dwFlags == 0 )
    {
        dwFlags = CERT_FIND_ALL_ENHKEY_USAGE_FLAG;
    }

    //
    // Validate the parameters
    //

    if ( ( ( dwFlags & CERT_FIND_ALL_ENHKEY_USAGE_FLAG ) == 0 ) ||
         ( pCertContext == NULL ) || ( pcbUsage == NULL ) )
    {
        SetLastError((DWORD) ERROR_INVALID_PARAMETER);
        return( FALSE );
    }

    //
    // If they want everything, call CertGetValidUsages
    //

    if ( dwFlags == CERT_FIND_ALL_ENHKEY_USAGE_FLAG )
    {
        return( EkuGetIntersectedUsageViaGetValidUsages(
                   pCertContext,
                   pcbUsage,
                   pUsage
                   ) );
    }

    //
    // If they want extensions get the extension blob, if they want
    // properties get the property blob
    //

    if ( dwFlags & CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG )
    {
        pExtBlob = EkuGetExtension(pCertContext, &fExtCertPolicies);
    }

    if ( dwFlags & CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG )
    {
        hr = EkuGetProperty(pCertContext, &cob);
        if ( hr == S_OK )
        {
            pPropBlob = &cob;
        }
    }

    //
    // Make sure that at least something was found and that what has occurred
    // is correctly indicated
    //

    if ( ( pExtBlob == NULL ) && ( pPropBlob == NULL ) )
    {
        if ( hr == S_OK )
        {
            hr = CRYPT_E_NOT_FOUND;
        }
    }
    else
    {
        hr = S_OK;
    }

    //
    // If all they wanted was the size, give it to them, otherwise, we
    // need to decode and give the caller what they requested
    //

    if ( hr == S_OK )
    {
        if ( pUsage == NULL )
        {
            DWORD cbSize = 0;
            DWORD cbExtSize = 0;
            DWORD cbPropSize = 0;

            hr = EkuGetDecodedUsageSizes(
                       fExtCertPolicies,
                       pExtBlob,
                       pPropBlob,
                       &cbSize,
                       &cbExtSize,
                       &cbPropSize
                       );

            if ( hr == S_OK )
            {
                if ( cbSize > 0 )
                {
                    *pcbUsage = cbSize;
                }
                else
                {
                    // Need better last error code
                    hr = E_INVALIDARG;
                }
            }
        }
        else
        {
            hr = EkuGetMergedDecodedUsage(
                             fExtCertPolicies,
                             pExtBlob,
                             pPropBlob,
                             pcbUsage,
                             pUsage
                             );
        }
    }

    //
    // Cleanup and return
    //

    if ( pPropBlob != NULL )
    {
        delete pPropBlob->pbData;
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertSetEnhancedKeyUsage
//
//  Synopsis:   sets the enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertSetEnhancedKeyUsage (
                IN PCCERT_CONTEXT     pCertContext,
                IN PCERT_ENHKEY_USAGE pUsage
                )
{
    HRESULT          hr;
    CRYPT_OBJID_BLOB EkuBlob;

    //
    // if pUsage is NULL, then just set the NULL property
    //
    if (pUsage == NULL)
    {
        hr = EkuSetProperty(pCertContext, NULL);
    }
    else
    {
        //
        // Encode the usage and set the property
        //
        hr = EkuEncodeUsage(pUsage, &EkuBlob);
        if ( hr == S_OK )
        {
            hr = EkuSetProperty(pCertContext, &EkuBlob);
            delete EkuBlob.pbData;
        }
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertAddEnhancedKeyUsageIdentifier
//
//  Synopsis:   adds a key usage identifier to the enhanced key usage property
//              on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertAddEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cbUsage1 = 0;
    DWORD              cbUsage2 = 0;
    DWORD              cbUsageM = 0;
    DWORD              cId;
    PCERT_ENHKEY_USAGE pUsage1 = NULL;
    PCERT_ENHKEY_USAGE pUsage2 = NULL;
    PCERT_ENHKEY_USAGE pUsageM = NULL;

    //
    // Create a one element, properly "encoded" (see EkuMergeUsage) enhanced
    // key usage structure
    //

    cId = strlen(pszUsageIdentifier)+1;
    cbUsage1 = sizeof(CERT_ENHKEY_USAGE)+sizeof(LPSTR)+cId;
    pUsage1 = (PCERT_ENHKEY_USAGE)new BYTE [cbUsage1];
    if ( pUsage1 == NULL )
    {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return( FALSE );
    }

    pUsage1->cUsageIdentifier = 1;
    pUsage1->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage1+sizeof(CERT_ENHKEY_USAGE));
    pUsage1->rgpszUsageIdentifier[0] = (LPSTR)((LPBYTE)pUsage1->rgpszUsageIdentifier+sizeof(LPSTR));
    strcpy(pUsage1->rgpszUsageIdentifier[0], pszUsageIdentifier);

    //
    // Get the current enhanced key usage properties and get an appropriately
    // sized block for the merged data unless there are no current usage
    // properties in which case we just set the one we have now
    //

    hr = EkuGetUsage(
               pCertContext,
               CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
               &cbUsage2,
               &pUsage2
               );

    if ( hr == S_OK )
    {
        cbUsageM = cbUsage1 + cbUsage2;
        pUsageM = (PCERT_ENHKEY_USAGE)new BYTE [cbUsageM];
        if ( pUsageM == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if ( hr == CRYPT_E_NOT_FOUND )
    {
        BOOL fReturn;

        fReturn = CertSetEnhancedKeyUsage(pCertContext, pUsage1);
        delete pUsage1;
        return( fReturn );
    }
    else
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Merge the usage structures and set the properties
    //

    hr = EkuMergeUsage(cbUsage1, pUsage1, cbUsage2, pUsage2, cbUsageM, pUsageM);
    if ( hr == S_OK )
    {
        if ( CertSetEnhancedKeyUsage(pCertContext, pUsageM) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage1;
    delete pUsage2;
    delete pUsageM;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertRemoveEnhancedKeyUsageIdentifier
//
//  Synopsis:   removes a key usage identifier from the enhanced key usage
//              property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertRemoveEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cFound = 0;
    DWORD              cCount;
    PCERT_ENHKEY_USAGE pUsage;
    LPSTR*             apsz;

    //
    // Get the current usage properties
    //

    hr = EkuGetUsage(
            pCertContext,
            CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &pUsage
            );

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Loop through the usage identifiers and remove ones that match
    // the passed in id
    //

    apsz = pUsage->rgpszUsageIdentifier;

    for (cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++)
    {
        if ( strcmp(apsz[cCount], pszUsageIdentifier) == 0 )
        {
            cFound++;
        }
        else if ( cFound > 0 )
        {
            apsz[cCount-cFound] = apsz[cCount];
        }
    }

    //
    // If we removed any, update the usage id count and set the new property
    //

    if ( cFound > 0 )
    {
        pUsage->cUsageIdentifier -= cFound;

        if ( pUsage->cUsageIdentifier == 0 )
        {
            // Delete the property if we are down to zero
            hr = EkuSetProperty(pCertContext, NULL);
        }
        else if ( CertSetEnhancedKeyUsage(pCertContext, pUsage) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetExtension
//
//  Synopsis:   gets the application cert policies or enhanced key usage
//              extension blob from the certificate
//
//              *pfAppCertPolicies is set to TRUE for an
//              szOID_APPLICATION_CERT_POLICIES extension.
//
//----------------------------------------------------------------------------
PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext,
                        BOOL           *pfAppCertPolicies
                        )
{
    PCERT_EXTENSION pExtension;

    //
    // Get the application cert policies or enhanced key usage extension
    // from the certificate and if we couldn't find either
    // extension return NULL otherwise, return
    // the appropriate field of the found extension
    //

    pExtension = CertFindExtension(
                         szOID_APPLICATION_CERT_POLICIES,
                         pCertContext->pCertInfo->cExtension,
                         pCertContext->pCertInfo->rgExtension
                         );
    if ( pExtension )
    {
        *pfAppCertPolicies = TRUE;
    }
    else
    {
        *pfAppCertPolicies = FALSE;

        pExtension = CertFindExtension(
                             szOID_ENHANCED_KEY_USAGE,
                             pCertContext->pCertInfo->cExtension,
                             pCertContext->pCertInfo->rgExtension
                             );

        if ( pExtension == NULL )
        {
            return( NULL );
        }
    }

    return( &pExtension->Value );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetProperty
//
//  Synopsis:   gets the enhanced key usage property from the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    DWORD cb;

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           NULL,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    pEkuBlob->cbData = cb;
    pEkuBlob->pbData = new BYTE [cb];

    if ( pEkuBlob->pbData == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           pEkuBlob->pbData,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuSetProperty
//
//  Synopsis:   sets an enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    if ( CertSetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           0,
                           pEkuBlob
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:   EkuDecodeCertPoliciesAndConvertToUsage
//
//  Synopsis:   decodes an encoded cert policies and converts to enhanced
//              key usage
//
//----------------------------------------------------------------------------
HRESULT EkuDecodeCertPoliciesAndConvertToUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage     // OPTIONAL
              )
{
    HRESULT hr = S_OK;
    DWORD cbCertPolicies = 0;
    PCERT_POLICIES_INFO pCertPolicies = NULL;
    DWORD cbSize = 0;

    if ( !CryptDecodeObject(
              X509_ASN_ENCODING,
              X509_CERT_POLICIES,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              CRYPT_DECODE_NOCOPY_FLAG |
                  CRYPT_DECODE_SHARE_OID_STRING_FLAG |
                  CRYPT_DECODE_ALLOC_FLAG,
              (void *) &pCertPolicies,
              &cbCertPolicies
              ))
    {
        hr = GetLastError();
    }
    else
    {
        // Convert policies OIDs to EKU OIDs
        LONG lRemainExtra;
        DWORD cOID;
        LPSTR *ppszOID;
        LPSTR pszOID;
        PCERT_POLICY_INFO pPolicy;

        cOID = pCertPolicies->cPolicyInfo;
        pPolicy = pCertPolicies->rgPolicyInfo;

        if ( pUsage )
        {
            cbSize = *pcbSize;
        }

        lRemainExtra = cbSize - sizeof(CERT_ENHKEY_USAGE) -
            sizeof(LPSTR) * cOID;
        if ( lRemainExtra < 0 )
        {
            ppszOID = NULL;
            pszOID = NULL;
        }
        else
        {
            ppszOID = (LPSTR *) &pUsage[1];
            pszOID = (LPSTR) &ppszOID[cOID];

            pUsage->cUsageIdentifier = cOID;
            pUsage->rgpszUsageIdentifier = ppszOID;
        }

        for ( ; cOID > 0; cOID--, ppszOID++, pPolicy++ )
        {
            DWORD cchOID;

            cchOID = strlen(pPolicy->pszPolicyIdentifier) + 1;
            lRemainExtra -= cchOID;
            if ( lRemainExtra >= 0 )
            {
                *ppszOID = pszOID;
                memcpy(pszOID, pPolicy->pszPolicyIdentifier, cchOID);
                pszOID += cchOID;
            }
        }

        if ( lRemainExtra >= 0)
        {
            cbSize -= (DWORD) lRemainExtra;
        }
        else
        {
            cbSize += (DWORD) -lRemainExtra;
            if ( pUsage )
            {
                hr = ERROR_MORE_DATA;
            }
        }
            
    }

    if ( pCertPolicies )
    {
        LocalFree( pCertPolicies );
    }

    *pcbSize = cbSize;
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedSize
//
//  Synopsis:   gets the decoded size of the enhanced key usage blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              NULL,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsageSizes
//
//  Synopsis:   gets the decoded sizes for enhanced key usage blobs from the
//              certificate extension and/or the certificate context property
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsageSizes (
              BOOL              fExtCertPolicies,
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              )
{
    HRESULT hr = S_OK;
    DWORD   cbExtSize = 0;
    DWORD   cbPropSize = 0;

    //
    // Get the appropriate decoded size based on what was requested
    //

    if ( pExtBlob != NULL )
    {
        if ( fExtCertPolicies )
        {
            hr = EkuDecodeCertPoliciesAndConvertToUsage(
                pExtBlob, &cbExtSize, NULL);
        }
        else
        {
            hr = EkuGetDecodedSize(pExtBlob, &cbExtSize);
        }
    }

    if ( ( hr == S_OK ) && ( pPropBlob != NULL ) )
    {
        hr = EkuGetDecodedSize(pPropBlob, &cbPropSize);
    }

    //
    // Collect into the out parameters
    //

    if ( hr == S_OK )
    {
        *pcbExtSize = cbExtSize;
        *pcbPropSize = cbPropSize;
        *pcbSize = cbExtSize + cbPropSize;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsage
//
//  Synopsis:   gets the decoded enhanced key usage from the encoded blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              pUsage,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuMergeUsage
//
//  Synopsis:   merges enhanced key usage structures
//
//              NOTE: The structures are assumed to be in single allocated
//                    block form where the string pointers point back into
//                    the bottom part of the allocated block where the
//                    have been placed
//
//----------------------------------------------------------------------------
HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              )
{
    DWORD  cUsage1;
    DWORD  cUsage2;
    DWORD  cUsageM;
    DWORD  cbOids1;
    DWORD  cbOids2;
    DWORD  cbUsage1;
    DWORD  cbUsage2;
    DWORD  cCount;
    DWORD  cbOffset;
    LPSTR* apsz1;
    LPSTR* apsz2;
    LPSTR* apszM;

    //
    // Copy the data from the source to the destination
    //

    cUsage1 = pUsage1->cUsageIdentifier;
    cUsage2 = pUsage2->cUsageIdentifier;
    cUsageM = cUsage1 + cUsage2;

    cbUsage1 = ( cUsage1 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);
    cbUsage2 = ( cUsage2 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);

    apsz1 = pUsage1->rgpszUsageIdentifier;
    apsz2 = pUsage2->rgpszUsageIdentifier;
    apszM = (LPSTR *)((LPBYTE)pUsageM+sizeof(CERT_ENHKEY_USAGE));

    pUsageM->cUsageIdentifier = cUsageM;
    pUsageM->rgpszUsageIdentifier = apszM;

    memcpy(apszM, apsz1, cUsage1*sizeof(LPSTR));
    memcpy(&apszM[cUsage1], apsz2, cUsage2*sizeof(LPSTR));

    cbOids1 = cbSize1 - cbUsage1;
    cbOids2 = cbSize2 - cbUsage2;

    memcpy(&apszM[cUsageM], &apsz1[cUsage1], cbOids1);

    memcpy(
       (LPBYTE)(&apszM[cUsageM])+cbOids1,
       &apsz2[cUsage2],
       cbOids2
       );

    //
    // Fix up the pointers
    //

    for ( cCount = 0; cCount < cUsage1; cCount++)
    {
        cbOffset = (DWORD)((LPBYTE)(apsz1[cCount]) - (LPBYTE)apsz1) + cbUsage2;
        apszM[cCount] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    for ( cCount = 0; cCount < cUsage2; cCount++ )
    {
        cbOffset = (DWORD)((LPBYTE)(apsz2[cCount]) - (LPBYTE)apsz2) + cbUsage1 + cbOids1;
        apszM[cCount+cUsage1] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetMergedDecodedUsage
//
//  Synopsis:   gets merged decoded enhanced key usage from the certificate
//              extension and the certificate properties
//
//----------------------------------------------------------------------------
HRESULT EkuGetMergedDecodedUsage (
              BOOL               fExtCertPolicies,
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    HRESULT            hr;
    DWORD              cbExtSize = 0;
    DWORD              cbPropSize = 0;
    DWORD              cbMergedSize = 0;
    PCERT_ENHKEY_USAGE pExtUsage = NULL;
    PCERT_ENHKEY_USAGE pPropUsage = NULL;

    //
    // If either the extension or the properties are NULL, we just need
    // to get the other one
    //

    if ( pExtBlob == NULL )
    {
        return( EkuGetDecodedUsage(pPropBlob, pcbSize, pUsage) );
    }
    else if ( pPropBlob == NULL )
    {
        if ( fExtCertPolicies )
        {
            return( EkuDecodeCertPoliciesAndConvertToUsage(
                pExtBlob, pcbSize, pUsage) );
        }
        else
        {
            return( EkuGetDecodedUsage(pExtBlob, pcbSize, pUsage) );
        }
    }

    //
    // Get the sizes we will need to allocate for decoding and validate
    // the total against what was passed in
    //

    hr = EkuGetDecodedUsageSizes(
               fExtCertPolicies,
               pExtBlob,
               pPropBlob,
               &cbMergedSize,
               &cbExtSize,
               &cbPropSize
               );

    if ( hr != S_OK )
    {
        return( hr );
    }
    else if ( *pcbSize < cbMergedSize )
    {
        *pcbSize = cbMergedSize;
        return( ERROR_MORE_DATA );
    }

    //
    // Allocate the enhanced key usage structures and decode into them
    //

    pExtUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbExtSize];
    pPropUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbPropSize];

    if ( ( pExtUsage == NULL ) || ( pPropUsage == NULL ) )
    {
        delete pExtUsage;
        delete pPropUsage;
        return( E_OUTOFMEMORY );
    }

    if ( fExtCertPolicies )
    {
        hr = EkuDecodeCertPoliciesAndConvertToUsage(
            pExtBlob, &cbExtSize, pExtUsage);
    }
    else
    {
        hr = EkuGetDecodedUsage(pExtBlob, &cbExtSize, pExtUsage);
    }

    if ( hr == S_OK )
    {
        hr = EkuGetDecodedUsage(pPropBlob, &cbPropSize, pPropUsage);
    }

    //
    // Merge the usage structures
    //

    if ( hr == S_OK )
    {
        hr = EkuMergeUsage(
                     cbExtSize,
                     pExtUsage,
                     cbPropSize,
                     pPropUsage,
                     *pcbSize,
                     pUsage
                     );
    }

    //
    // Cleanup
    //

    delete pExtUsage;
    delete pPropUsage;

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuEncodeUsage
//
//  Synopsis:   encodes the enhanced key usage into a blob useful for setting
//              as a certificate property
//
//----------------------------------------------------------------------------
HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              )
{
    HRESULT hr = S_OK;
    DWORD   cbData = 0;
    LPBYTE  pbData;

    if ( CryptEncodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pUsage,
              NULL,
              &cbData
              ) == FALSE )
    {
        return( GetLastError() );
    }

    pbData = new BYTE [cbData];

    if ( pbData != NULL )
    {
        if ( CryptEncodeObject(
                  X509_ASN_ENCODING,
                  szOID_ENHANCED_KEY_USAGE,
                  pUsage,
                  pbData,
                  &cbData
                  ) == FALSE )
        {
            hr = GetLastError();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr == S_OK )
    {
        pEkuBlob->cbData = cbData;
        pEkuBlob->pbData = pbData;
    }
    else
    {
        delete pbData;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetUsage
//
//  Synopsis:   gets the usage based on the flags with CertGetEnhancedKeyUsage
//
//----------------------------------------------------------------------------
HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              )
{
    DWORD              cbSize;
    PCERT_ENHKEY_USAGE pUsage;

    //
    // Get an appropriately sized block to hold the usage
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                NULL,
                &cbSize
                ) == FALSE )
    {
        return( GetLastError() );
    }

    pUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbSize];
    if ( pUsage == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    //
    // Now get the enhanced key usage data and fill in the out parameters
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                pUsage,
                &cbSize
                ) == FALSE )
    {
        delete pUsage;
        return( GetLastError() );
    }

    if ( pcbSize != NULL )
    {
        *pcbSize = cbSize;
    }

    *ppUsage = pUsage;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<pUsage->cUsageIdentifier; i++)
    {
        if(!strcmp(pUsage->rgpszUsageIdentifier[i], pszOID))
            break;
    }

    return (i < pUsage->cUsageIdentifier);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDExistsInArray(LPSTR *rghPropOIDs, DWORD cPropOIDs, LPSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<cPropOIDs; i++)
    {
        if(!strcmp(rghPropOIDs[i], pszOID))
            break;
    }

    return (i < cPropOIDs);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LPSTR AllocAndCopyStr(LPSTR psz)
{
    LPSTR pszNew;

    pszNew = (LPSTR) new BYTE[strlen(psz)+1];

    if (pszNew == NULL)
    {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return NULL;
    }

    strcpy(pszNew, psz);
    return (pszNew);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void IntersectUsages(DWORD *pcExtOIDs, LPSTR *rghExtOIDs, PCERT_ENHKEY_USAGE pUsageExt)
{
    DWORD i;
    DWORD dwNumOIDs;

    dwNumOIDs = *pcExtOIDs;
    *pcExtOIDs = 0;

    for (i=0; i<dwNumOIDs; i++)
    {
        if (OIDInUsages(pUsageExt, rghExtOIDs[i]))
        {
            if (*pcExtOIDs != i)
            {
                rghExtOIDs[*pcExtOIDs] = rghExtOIDs[i];
                rghExtOIDs[i] = NULL;
            }
            (*pcExtOIDs)++;
        }
        else
        {
            delete(rghExtOIDs[i]);
            rghExtOIDs[i] = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ProcessCertForEKU(
                    PCCERT_CONTEXT  pCert,
                    BOOL            *pfAllProp,
                    DWORD           *pcPropOIDs,
                    LPSTR           *rghPropOIDs,
                    BOOL            *pfAllExt,
                    DWORD           *pcExtOIDs,
                    LPSTR           *rghExtOIDs)
{
    BOOL                fRet        = TRUE;
    PCERT_ENHKEY_USAGE  pExtUsage   = NULL;
    PCERT_ENHKEY_USAGE  pPropUsage  = NULL;
    DWORD               i;

    EkuGetUsage(pCert, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &pExtUsage);
    EkuGetUsage(pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &pPropUsage);

    //
    // if there are EKU extensions then we are limited to that set of EKUs at the maximum
    //
    if (pExtUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllExt == TRUE)
        {
            *pfAllExt = FALSE;
            for (i=0; i<pExtUsage->cUsageIdentifier; i++)
            {
                rghExtOIDs[i] = AllocAndCopyStr(pExtUsage->rgpszUsageIdentifier[i]);
                if (rghExtOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcExtOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcExtOIDs, rghExtOIDs, pExtUsage);
        }
    }

    //
    // if there are EKU propertis then we are limited to that set of EKUs at the maximum
    //
    if (pPropUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllProp == TRUE)
        {
            *pfAllProp = FALSE;
            for (i=0; i<pPropUsage->cUsageIdentifier; i++)
            {
                rghPropOIDs[i] = AllocAndCopyStr(pPropUsage->rgpszUsageIdentifier[i]);
                if (rghPropOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcPropOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcPropOIDs, rghPropOIDs, pPropUsage);
        }
    }

CleanUp:

    if (pExtUsage != NULL)
        delete(pExtUsage);

    if (pPropUsage != NULL)
        delete(pPropUsage);

    return(fRet);

ErrorCleanUp:

    fRet = FALSE;
    goto CleanUp;
}


//+---------------------------------------------------------------------------
//
//  Function:   CertGetValidUsages
//
//  Synopsis:   takes an array of certs and returns an array of usages
//              which consists of the intersection of the the valid usages for each cert.
//              if each cert is good for all possible usages then cNumOIDs is set to -1.
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetValidUsages(
                    IN      DWORD           cCerts,
                    IN      PCCERT_CONTEXT  *rghCerts,
                    OUT     int             *cNumOIDs,
                    OUT     LPSTR           *rghOIDs,
                    IN OUT  DWORD           *pcbOIDs)
{
    BOOL            fAllExt = TRUE;
    BOOL            fAllProp = TRUE;
    DWORD           cPropOIDs = 0;
    LPSTR           rghPropOIDs[100];
    DWORD           cExtOIDs = 0;
    LPSTR           rghExtOIDs[100];
    BOOL            fRet = TRUE;
    BYTE            *pbBufferLocation;
    DWORD           cIntersectOIDs = 0;
    DWORD           i;
    DWORD           cbNeeded = 0;

    for (i=0; i<cCerts; i++)
    {
        if (!ProcessCertForEKU(rghCerts[i], &fAllProp, &cPropOIDs, rghPropOIDs, &fAllExt, &cExtOIDs, rghExtOIDs))
        {
            goto ErrorCleanUp;
        }
    }

    *cNumOIDs = 0;

    if (fAllExt && fAllProp)
    {
        *pcbOIDs = 0;
        *cNumOIDs = -1;
    }
    else if (!fAllExt && fAllProp)
    {
        for (i=0; i<cExtOIDs; i++)
        {
            cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cExtOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghExtOIDs[i]);
            pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
        }
    }
    else if (fAllExt && !fAllProp)
    {
        for (i=0; i<cPropOIDs; i++)
        {
            cbNeeded += strlen(rghPropOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cPropOIDs * sizeof(LPSTR));
        for (i=0; i<cPropOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghPropOIDs[i]);
            pbBufferLocation += strlen(rghPropOIDs[i]) + 1;
        }
    }
    else
    {
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
                (*cNumOIDs)++;
                cIntersectOIDs++;
            }
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cIntersectOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cIntersectOIDs--;
                rghOIDs[cIntersectOIDs] = (LPSTR) pbBufferLocation;
                strcpy(rghOIDs[cIntersectOIDs], rghExtOIDs[i]);
                pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
            }
        }
    }

CleanUp:

    for (i=0; i<cExtOIDs; i++)
    {
        delete(rghExtOIDs[i]);
    }

    for (i=0; i<cPropOIDs; i++)
    {
        delete(rghPropOIDs[i]);
    }

    return (fRet);

ErrorCleanUp:
    fRet = FALSE;
    goto CleanUp;

}
//+---------------------------------------------------------------------------
//
//  Function:   EkuGetIntersectedUsageViaGetValidUsages
//
//  Synopsis:   get the intersected extension and property usages
//
//----------------------------------------------------------------------------
BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   )
{
    BOOL  fResult;
    int   cUsage = 0;
    DWORD cbUsage = 0;
    DWORD cbSize = 0;

    fResult = CertGetValidUsages( 1, &pCertContext, &cUsage, NULL, &cbUsage );

    if ( fResult == TRUE )
    {
        cbSize = cbUsage + sizeof( CERT_ENHKEY_USAGE );

        if ( pUsage == NULL )
        {
            *pcbSize = cbSize;
            return( TRUE );
        }
        else if ( ( pUsage != NULL ) && ( *pcbSize < cbSize ) )
        {
            *pcbSize = cbSize;
            SetLastError( (DWORD) ERROR_MORE_DATA );
            return( FALSE );
        }

        pUsage->cUsageIdentifier = 0;
        pUsage->rgpszUsageIdentifier = (LPSTR *)( (LPBYTE)pUsage + sizeof( CERT_ENHKEY_USAGE ) );
        cbUsage = *pcbSize - sizeof( CERT_ENHKEY_USAGE );

        fResult = CertGetValidUsages(
                      1,
                      &pCertContext,
                      (int *)&pUsage->cUsageIdentifier,
                      pUsage->rgpszUsageIdentifier,
                      &cbUsage
                      );

        if ( fResult == TRUE )
        {
            if ( pUsage->cUsageIdentifier == 0xFFFFFFFF )
            {
                pUsage->cUsageIdentifier = 0;
                SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            }
            else if ( pUsage->cUsageIdentifier == 0 )
            {
                SetLastError( 0 );
            }
        }
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\ekuhlpr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ekuhlpr.h
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    22-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__EKUHLPR_H__)
#define __EKUHLPR_H__

PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext,
                        BOOL           *pfAppCertPolicies
                        );

HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuDecodeCertPoliciesAndConvertToUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage     // OPTIONAL
              );

HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              );

HRESULT EkuGetDecodedUsageSizes (
              BOOL              fExtCertPolicies,
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              );

HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              );

HRESULT EkuGetMergedDecodedUsage (
              BOOL               fExtCertPolicies,
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              );

HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              );

#define CERT_FIND_ALL_ENHKEY_USAGE_FLAG (CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG |\
                                         CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG)

BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\frmtfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       frmtfunc.cpp
//
//  Contents:   OID format functions
//
//  Functions:  CryptFrmtFuncDllMain
//              CryptFormatObject
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//              27 Oct 1999 dsie     add post win2k features.
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"

HMODULE hFrmtFuncInst;

static HCRYPTOIDFUNCSET hFormatFuncSet;


//function type define
typedef BOOL (WINAPI *PFN_FORMAT_FUNC)(
	IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    );

static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL	
WINAPI	
CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcBuffer);


static BOOL	
WINAPI	
CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer);

static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCAVersion(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAnyUnicodeStringExtension(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAnyNameValueStringAttr(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNetscapeCertType(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

//
// DSIE: Post Win2K.
//

static BOOL
WINAPI
FormatCrlNumber (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCrlNextPublish (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatIssuingDistPoint (
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNameConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCertSrvPreviousCertHash (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatPolicyMappings (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatPolicyConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatCertificateTemplate (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat);

static BOOL
WINAPI
FormatXCertDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static const CRYPT_OID_FUNC_ENTRY DefaultFormatTable[] = {
    CRYPT_DEFAULT_OID, FormatBytesToHex};

static const CRYPT_OID_FUNC_ENTRY OIDFormatTable[] = {
				szOID_COMMON_NAME,						CryptDllFormatAttr,	
				szOID_SUR_NAME,                      	CryptDllFormatAttr,
				szOID_DEVICE_SERIAL_NUMBER,          	CryptDllFormatAttr,
				szOID_COUNTRY_NAME,                  	CryptDllFormatAttr,
				szOID_LOCALITY_NAME,                 	CryptDllFormatAttr,
				szOID_STATE_OR_PROVINCE_NAME,        	CryptDllFormatAttr,
				szOID_STREET_ADDRESS,                	CryptDllFormatAttr,
				szOID_ORGANIZATION_NAME,             	CryptDllFormatAttr,
				szOID_ORGANIZATIONAL_UNIT_NAME,      	CryptDllFormatAttr,
				szOID_TITLE,                         	CryptDllFormatAttr,
				szOID_DESCRIPTION,                   	CryptDllFormatAttr,
				szOID_SEARCH_GUIDE,                  	CryptDllFormatAttr,
				szOID_BUSINESS_CATEGORY,             	CryptDllFormatAttr,
				szOID_POSTAL_ADDRESS,                	CryptDllFormatAttr,
				szOID_POSTAL_CODE,                   	CryptDllFormatAttr,
				szOID_POST_OFFICE_BOX,               	CryptDllFormatAttr,
				szOID_PHYSICAL_DELIVERY_OFFICE_NAME, 	CryptDllFormatAttr,
				szOID_TELEPHONE_NUMBER,              	CryptDllFormatAttr,
				szOID_TELEX_NUMBER,                  	CryptDllFormatAttr,
				szOID_TELETEXT_TERMINAL_IDENTIFIER,  	CryptDllFormatAttr,
				szOID_FACSIMILE_TELEPHONE_NUMBER,    	CryptDllFormatAttr,
				szOID_X21_ADDRESS,                   	CryptDllFormatAttr,
				szOID_INTERNATIONAL_ISDN_NUMBER,     	CryptDllFormatAttr,
				szOID_REGISTERED_ADDRESS,            	CryptDllFormatAttr,
				szOID_DESTINATION_INDICATOR,         	CryptDllFormatAttr,
				szOID_PREFERRED_DELIVERY_METHOD,     	CryptDllFormatAttr,
				szOID_PRESENTATION_ADDRESS,          	CryptDllFormatAttr,
				szOID_SUPPORTED_APPLICATION_CONTEXT, 	CryptDllFormatAttr,
				szOID_MEMBER,                        	CryptDllFormatAttr,
				szOID_OWNER,                         	CryptDllFormatAttr,
				szOID_ROLE_OCCUPANT,                 	CryptDllFormatAttr,
				szOID_SEE_ALSO,                      	CryptDllFormatAttr,
				szOID_USER_PASSWORD,                 	CryptDllFormatAttr,
				szOID_USER_CERTIFICATE,              	CryptDllFormatAttr,
				szOID_CA_CERTIFICATE,                	CryptDllFormatAttr,
				szOID_AUTHORITY_REVOCATION_LIST,     	CryptDllFormatAttr,
				szOID_CERTIFICATE_REVOCATION_LIST,   	CryptDllFormatAttr,
				szOID_CROSS_CERTIFICATE_PAIR,        	CryptDllFormatAttr,
				szOID_GIVEN_NAME,                    	CryptDllFormatAttr,
				szOID_INITIALS,                     	CryptDllFormatAttr,
                szOID_DOMAIN_COMPONENT,                 CryptDllFormatAttr,
                szOID_PKCS_12_FRIENDLY_NAME_ATTR,       CryptDllFormatAttr,
                szOID_PKCS_12_LOCAL_KEY_ID,             CryptDllFormatAttr,
				X509_NAME,								CryptDllFormatName,
				X509_UNICODE_NAME,						CryptDllFormatName,
				szOID_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
				X509_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
                szOID_BASIC_CONSTRAINTS,                FormatBasicConstraints,
                X509_BASIC_CONSTRAINTS,                 FormatBasicConstraints,
				szOID_CRL_REASON_CODE,					FormatCRLReasonCode,
				X509_CRL_REASON_CODE,					FormatCRLReasonCode,
				szOID_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
				X509_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
                szOID_SUBJECT_ALT_NAME,                 FormatAltName,
                szOID_ISSUER_ALT_NAME,                  FormatAltName,
                szOID_SUBJECT_ALT_NAME2,                FormatAltName,
                szOID_ISSUER_ALT_NAME2,                 FormatAltName,
                X509_ALTERNATE_NAME,                    FormatAltName,
                szOID_AUTHORITY_KEY_IDENTIFIER,         FormatAuthorityKeyID,
                X509_AUTHORITY_KEY_ID,                  FormatAuthorityKeyID,
                szOID_AUTHORITY_KEY_IDENTIFIER2,        FormatAuthorityKeyID2,
                X509_AUTHORITY_KEY_ID2,                 FormatAuthorityKeyID2,
                szOID_NEXT_UPDATE_LOCATION,             FormatNextUpdateLocation,
                szOID_SUBJECT_KEY_IDENTIFIER,           FormatSubjectKeyID,
                SPC_FINANCIAL_CRITERIA_OBJID,           FormatFinancialCriteria,
                SPC_FINANCIAL_CRITERIA_STRUCT,          FormatFinancialCriteria,
                szOID_RSA_SMIMECapabilities,            FormatSMIMECapabilities,
                PKCS_SMIME_CAPABILITIES,                FormatSMIMECapabilities,
                szOID_KEY_USAGE,                        FormatKeyUsage,
                X509_KEY_USAGE,                         FormatKeyUsage,
                szOID_AUTHORITY_INFO_ACCESS,            FormatAuthortiyInfoAccess,
                X509_AUTHORITY_INFO_ACCESS,             FormatAuthortiyInfoAccess,
                szOID_KEY_ATTRIBUTES,                   FormatKeyAttributes,
                X509_KEY_ATTRIBUTES,                    FormatKeyAttributes,
                szOID_KEY_USAGE_RESTRICTION,            FormatKeyRestriction,
                X509_KEY_USAGE_RESTRICTION,             FormatKeyRestriction,
                szOID_CRL_DIST_POINTS,                  FormatCRLDistPoints,
                X509_CRL_DIST_POINTS,                   FormatCRLDistPoints,
                szOID_FRESHEST_CRL,                     FormatCRLDistPoints,    // Post Win2K
                szOID_CERT_POLICIES,                    FormatCertPolicies,
                X509_CERT_POLICIES,                     FormatCertPolicies,
				szOID_ENROLL_CERTTYPE_EXTENSION,		FormatAnyUnicodeStringExtension,
				szOID_OS_VERSION,						FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CERT_TYPE,				FormatNetscapeCertType,
				szOID_NETSCAPE_BASE_URL,				FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_REVOCATION_URL,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CA_REVOCATION_URL,		FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CERT_RENEWAL_URL,		FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_CA_POLICY_URL,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_SSL_SERVER_NAME,			FormatAnyUnicodeStringExtension,
				szOID_NETSCAPE_COMMENT,					FormatAnyUnicodeStringExtension,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,		FormatAnyNameValueStringAttr,
				szOID_CERTSRV_CA_VERSION,				FormatCAVersion,
				SPC_SP_AGENCY_INFO_OBJID,               FormatSPAgencyInfo,
                SPC_SP_AGENCY_INFO_STRUCT,              FormatSPAgencyInfo,

                // Post Win2K
                szOID_CRL_NUMBER,                       FormatCrlNumber,
                szOID_DELTA_CRL_INDICATOR,              FormatCrlNumber,
				szOID_CRL_VIRTUAL_BASE,					FormatCrlNumber,
                szOID_CRL_NEXT_PUBLISH,                 FormatCrlNextPublish,
                szOID_ISSUING_DIST_POINT,               FormatIssuingDistPoint,
                X509_ISSUING_DIST_POINT,                FormatIssuingDistPoint,
                szOID_NAME_CONSTRAINTS,                 FormatNameConstraints,
                X509_NAME_CONSTRAINTS,                  FormatNameConstraints,
                szOID_CERTSRV_PREVIOUS_CERT_HASH,       FormatCertSrvPreviousCertHash,

                szOID_APPLICATION_CERT_POLICIES,        FormatCertPolicies,
                X509_POLICY_MAPPINGS,                   FormatPolicyMappings,
                szOID_POLICY_MAPPINGS,                  FormatPolicyMappings,
                szOID_APPLICATION_POLICY_MAPPINGS,      FormatPolicyMappings,
                X509_POLICY_CONSTRAINTS,                FormatPolicyConstraints,
                szOID_POLICY_CONSTRAINTS,               FormatPolicyConstraints,
                szOID_APPLICATION_POLICY_CONSTRAINTS,   FormatPolicyConstraints,
                X509_CERTIFICATE_TEMPLATE,              FormatCertificateTemplate,
                szOID_CERTIFICATE_TEMPLATE,             FormatCertificateTemplate,
                szOID_CRL_SELF_CDP,                     FormatCRLDistPoints,
                X509_CROSS_CERT_DIST_POINTS,            FormatXCertDistPoints,
                szOID_CROSS_CERT_DIST_POINTS,           FormatXCertDistPoints,
};

DWORD dwOIDFormatCount = sizeof(OIDFormatTable) / sizeof(OIDFormatTable[0]);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFrmtFuncDllMain(
        HMODULE hModule,
        DWORD  fdwReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

		hFrmtFuncInst = hModule;

        if (NULL == (hFormatFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                0)))                                // dwFlags
            goto CryptInitFrmtFuncError;

		//install the default formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                1,
                DefaultFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;

		//install the OID formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                dwOIDFormatCount,
                OIDFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;


		break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitFrmtFuncError)
TRACE_ERROR(CryptInstallFrmtFuncError)
}


//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//	   Precondition: byte is less than 15
//
//------------------------------------------------------------------------
ULONG ByteToHex(BYTE byte, LPWSTR wszZero, LPWSTR wszA)
{
	ULONG uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}
//--------------------------------------------------------------------------
//
//	 Format the encoded bytes into a hex string in the format of
//   xxxx xxxx xxxx xxxx ...
//
//   DSIE 6/28/2000: change format to xx xx xx xx, per VicH's request.
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	LPWSTR	pwszBuffer=NULL;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;
	WCHAR	wszSpace[CHAR_SIZE];
	WCHAR	wszZero[CHAR_SIZE];
	WCHAR	wszA[CHAR_SIZE];
	WCHAR	wszHex[HEX_SIZE];
	
	//check for input parameters
	if(( pbEncoded!=NULL && cbEncoded==0)
		||(pbEncoded==NULL && cbEncoded!=0)
		|| (pcbFormat==NULL))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return FALSE;
	}

#if (0) // DSIE: Fix bug 128630.
	//check for simple case.  No work needed
	if(pbEncoded==NULL && cbEncoded==0)
	{
		*pcbFormat=0;
		return TRUE;
	}
#endif

	//calculate the memory needed, in bytes
	//we need 3 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbEncoded*3+1);

	//length only calculation
	if(pcbFormat!=NULL && pbFormat==NULL)
	{
		*pcbFormat=dwBufferSize;
		return TRUE;
	}

	//load the string
	if(!LoadStringU(hFrmtFuncInst, IDS_FRMT_SPACE, wszSpace,
		CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_ZERO, wszZero,
	    CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_A, wszA,
	   CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_HEX, wszHex,
	  HEX_SIZE)
	  )
	{
		SetLastError((DWORD) E_UNEXPECTED);
		return FALSE;
	}

	pwszBuffer=(LPWSTR)malloc(dwBufferSize);
	if(!pwszBuffer)
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbEncoded; dwEncodedIndex++)
	{
#if (0) // DSIE:
		//copy the space between every two bytes.  Skip for the 1st byte
        if((0!=dwEncodedIndex) && (0==(dwEncodedIndex % 2)))
#else
		//copy the space between every byte.  Skip for the 1st byte
        if(dwEncodedIndex != 0)
#endif
        {
		    pwszBuffer[dwBufferIndex]=wszSpace[0];
		    dwBufferIndex++;
        }

		//format the higher 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 (BYTE)( (pbEncoded[dwEncodedIndex]&UPPER_BITS)>>4 ),
			 wszZero, wszA);

		dwBufferIndex++;

		//format the lower 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 (BYTE)( pbEncoded[dwEncodedIndex]&LOWER_BITS ),
			 wszZero, wszA);

		dwBufferIndex++;
	}

	//add the NULL terminator to the string
	pwszBuffer[dwBufferIndex]=wszSpace[1];

    //calculate the real size for the buffer
    dwBufferSize=sizeof(WCHAR)*(wcslen(pwszBuffer)+1);

	//copy the buffer
	memcpy(pbFormat, pwszBuffer,
		(*pcbFormat>=dwBufferSize) ? dwBufferSize : *pcbFormat);

	free(pwszBuffer);

	//make sure the user has supplied enough memory
	if(*pcbFormat < dwBufferSize)
	{
		*pcbFormat=dwBufferSize;
		SetLastError((DWORD) ERROR_MORE_DATA);
		return FALSE;
	}
		
	*pcbFormat=dwBufferSize;

	return TRUE;
}

//+-----------------------------------------------------------------------------
//
//  AllocateAnsiToUnicode
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
AllocateAnsiToUnicode(
    LPCSTR pszAnsi, 
    LPWSTR * ppwszUnicode)
{
    BOOL   fResult     = FALSE;
    LPWSTR pwszUnicode = NULL;
    DWORD  dwWideSize  = 0;

    if (!ppwszUnicode)
    {
		goto InvalidArg;
    }

    *ppwszUnicode = NULL;

    if (!pszAnsi)
    {
        return TRUE;
    }

	if (!(dwWideSize = MultiByteToWideChar(CP_ACP,
                                           0,
	                                       pszAnsi,
                                           strlen(pszAnsi),
                                           NULL,
                                           0)))
    {
		goto szTOwszError;
    }

    //
	// Allocate memory, including the NULL terminator.
    //
	if (!(pwszUnicode = (WCHAR *) malloc(sizeof(WCHAR) * (dwWideSize + 1))))
    {
		goto MemoryError;
    }

    memset(pwszUnicode, 0, sizeof(WCHAR) * (dwWideSize + 1));

	if (!MultiByteToWideChar(CP_ACP,
                             0,
	                         pszAnsi,
                             strlen(pszAnsi),
                             pwszUnicode,
                             dwWideSize))
    {
        free(pwszUnicode);
		goto szTOwszError;
    }

    *ppwszUnicode = pwszUnicode;

    fResult = TRUE;

CommonReturn:

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(szTOwszError);
}

//+-----------------------------------------------------------------------------
//
//  FormatObjectId
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatObjectId (
    LPSTR    pszObjId,
    DWORD    dwGroupId,
    BOOL     bMultiLines,
    LPWSTR * ppwszFormat)
{
    BOOL              fResult;
	PCCRYPT_OID_INFO  pOIDInfo    = NULL;
    LPWSTR            pwszObjId   = NULL;

    //
    // Initialize.
    //
    *ppwszFormat = NULL;

    //
    // Convert OID to Unicode.
    //
    if (!AllocateAnsiToUnicode(pszObjId, &pwszObjId))
    {
        goto AnsiToUnicodeError;
    }

    //
    // Find OID info.
    //
    if (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
                                    (void *) pszObjId,
                                    dwGroupId))
	{
        //
        // "%1!s!(%2!s!)%3!s!"
        //
        if (!FormatMessageUnicode(ppwszFormat, 
                                  IDS_GENERIC_OBJECT_ID,
                                  pOIDInfo->pwszName,
                                  pwszObjId,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }
    }
    else
    {
        //
        // "%1!s!%2!s!"
        //
        if (!FormatMessageUnicode(ppwszFormat, 
                                  IDS_STRING,
                                  pwszObjId,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }
    }

    fResult = TRUE;

CommonReturn:

    if (pwszObjId)
    {
        free(pwszObjId);
    }

    return fResult;

ErrorReturn:

	fResult = FALSE;
	goto CommonReturn;

TRACE_ERROR(AnsiToUnicodeError);
TRACE_ERROR(FormatMessageError);
}

//+-----------------------------------------------------------------------------
//
//  FormatIPAddress
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatIPAddress(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void	   *pFormatStruct,
	LPCSTR	    lpszStructType,
    UINT        idsPrefix,
    const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    BOOL   fResult;
    DWORD  cbNeeded    = 0;
    LPWSTR pwszFormat  = NULL;
    WCHAR  wszPrefix[PRE_FIX_SIZE] = wszEMPTY;
    BOOL   bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check for input parameters.
    //
	if ((pbEncoded!=NULL && cbEncoded==0) ||
        (pbEncoded==NULL && cbEncoded!=0) || 
        (pcbFormat==NULL))
	{
		goto InvalidArg;
	}

    if (bMultiLines && idsPrefix)
    {
        if(!LoadStringU(hFrmtFuncInst, 
                        idsPrefix,
                        wszPrefix, 
                        sizeof(wszPrefix) / sizeof(wszPrefix[0])))
        {
            goto LoadStringError;
        }
    }

    switch (cbEncoded)
    {
        case 4:
        {
            //
            // "%1!d!.%2!d!.%3!d!.%4!d!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V4_4,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 8:
        {
            //
            // "%1!d!.%2!d!.%3!d!.%4!d!%5!s!%6!s!Mask=%7!d!.%8!d!.%9!d!.%10!d!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V4_8,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      bMultiLines ? wszCRLF : wszEMPTY,
                                      bMultiLines ? wszPrefix : wszCOMMA,
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 16:
        {
            //
            // "%1!02x!%2!02x!:%3!02x!%4!02x!:%5!02x!%6!02x!:%7!02x!%8!02x!:%9!02x!%10!02x!:%11!02x!%12!02x!:%13!02x!%14!02x!:%15!02x!%16!02x!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V6_16,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7],
                                      (DWORD) pbEncoded[8],
                                      (DWORD) pbEncoded[9],
                                      (DWORD) pbEncoded[10],
                                      (DWORD) pbEncoded[11],
                                      (DWORD) pbEncoded[12],
                                      (DWORD) pbEncoded[13],
                                      (DWORD) pbEncoded[14],
                                      (DWORD) pbEncoded[15]))
            {
                goto FormatMessageError;
            }

            break;
        }

        case 32:
        {
            //
            // "%1!02x!%2!02x!:%3!02x!%4!02x!:%5!02x!%6!02x!:%7!02x!%8!02x!:%9!02x!%10!02x!:%11!02x!%12!02x!:%13!02x!%14!02x!:%15!02x!%16!02x!%17!s!%18!s!
            //  Mask=%19!02x!%20!02x!:%21!02x!%22!02x!:%23!02x!%24!02x!:%25!02x!%26!02x!:%27!02x!%28!02x!:%29!02x!%30!02x!:%31!02x!%32!02x!:%33!02x!%34!02x!"
            //
            if (!FormatMessageUnicode(&pwszFormat,
                                      IDS_IPADDRESS_V6_32,
                                      (DWORD) pbEncoded[0],
                                      (DWORD) pbEncoded[1],
                                      (DWORD) pbEncoded[2],
                                      (DWORD) pbEncoded[3],
                                      (DWORD) pbEncoded[4],
                                      (DWORD) pbEncoded[5],
                                      (DWORD) pbEncoded[6],
                                      (DWORD) pbEncoded[7],
                                      (DWORD) pbEncoded[8],
                                      (DWORD) pbEncoded[9],
                                      (DWORD) pbEncoded[10],
                                      (DWORD) pbEncoded[11],
                                      (DWORD) pbEncoded[12],
                                      (DWORD) pbEncoded[13],
                                      (DWORD) pbEncoded[14],
                                      (DWORD) pbEncoded[15],
                                      bMultiLines ? wszCRLF : wszEMPTY,
                                      bMultiLines ? wszPrefix : wszCOMMA,
                                      (DWORD) pbEncoded[16],
                                      (DWORD) pbEncoded[17],
                                      (DWORD) pbEncoded[18],
                                      (DWORD) pbEncoded[19],
                                      (DWORD) pbEncoded[20],
                                      (DWORD) pbEncoded[21],
                                      (DWORD) pbEncoded[22],
                                      (DWORD) pbEncoded[23],
                                      (DWORD) pbEncoded[24],
                                      (DWORD) pbEncoded[25],
                                      (DWORD) pbEncoded[26],
                                      (DWORD) pbEncoded[27],
                                      (DWORD) pbEncoded[28],
                                      (DWORD) pbEncoded[29],
                                      (DWORD) pbEncoded[30],
                                      (DWORD) pbEncoded[31]))
            {
                goto FormatMessageError;
            }

            break;
        }

        default:
        {
            if (!(fResult = FormatBytesToHex(dwCertEncodingType,
                                             dwFormatType,
                                             dwFormatStrType,
                                             pFormatStruct,
                                             lpszStructType,
                                             pbEncoded,
                                             cbEncoded,
                                             pbFormat,
                                             pcbFormat)))
            {
                goto FormatBytesToHexError;
            }

            goto CommonReturn;
        }
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
TRACE_ERROR(FormatBytesToHexError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);

}

//+-------------------------------------------------------------------------
// format the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFormatObject(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    )
{
    BOOL				fResult=FALSE;
    void				*pvFuncAddr;
    HCRYPTOIDFUNCADDR   hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hFormatFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
	{
        fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
				lpszStructType,
				pbEncoded,
				cbEncoded,
				pbFormat,
				pcbFormat
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    }
	else
	{
        //do not call the default hex dump if CRYPT_FORMAT_STR_NO_HEX is set
        if(0==(dwFormatStrType & CRYPT_FORMAT_STR_NO_HEX))
        {
		    //call the default routine automatically
		    if (CryptGetOIDFunctionAddress(
                hFormatFuncSet,
                dwCertEncodingType,
                CRYPT_DEFAULT_OID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
		    {
			    fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType,
					pFormatStruct,
					lpszStructType,
					pbEncoded,
					cbEncoded,
					pbFormat,
					pcbFormat);

			    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
		    }
            else
            {
			    *pcbFormat = 0;
			    fResult = FALSE;
            }
        }
		else
		{
			*pcbFormat = 0;
			fResult = FALSE;
		}
	}
    return fResult;
}



//-----------------------------------------------------------
//
//  This is the actual format routine for an particular RDN attribute.
//
//	lpszStructType is any OID for CERT_RDN_ATTR.  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is not NULL terminated.
//
//	For example, to ask for an unicode string of common name,
//	pass lpszStructType=szOID_COMMON_NAME,
//	pass dwFormatType==CRYPT_FORMAT_SIMPL,
//  pBuffer will be set the L"xiaohs@microsoft.com".
//
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcbBuffer)
{
		BOOL		fResult=FALSE;
		WCHAR		*pwszSeperator=NULL;
		BOOL		fHeader=FALSE;
		BOOL		flengthOnly=FALSE;
		DWORD		dwBufferCount=0;
		DWORD		dwBufferLimit=0;
		DWORD		dwBufferIncrement=0;
		DWORD		dwSeperator=0;
		DWORD		dwHeader=0;
		DWORD		dwOIDSize=0;
		WCHAR		*pwszBuffer=NULL;
		WCHAR		*pwszHeader=NULL;
		BOOL		fAddSeperator=FALSE;


		DWORD			cbStructInfo=0;
		CERT_NAME_INFO	*pStructInfo=NULL;
		DWORD			dwRDNIndex=0;
		DWORD			dwAttrIndex=0;
		DWORD			dwAttrCount=0;
		CERT_RDN_ATTR	*pCertRDNAttr=NULL;
		PCCRYPT_OID_INFO pOIDInfo=NULL;

        LPWSTR           pwszTemp;
		
		//check input parameters
		if(lpszStructType==NULL ||
			(pbEncoded==NULL && cbEncoded!=0) ||
			pcbBuffer==NULL	
		  )
			goto InvalidArg;

		if(cbEncoded==0)
		{
			*pcbBuffer=0;
			goto InvalidArg;
		}

		//get the seperator of the attributes
		//wszCOMMA is the default seperator
		if(dwFormatType & CRYPT_FORMAT_COMMA)
			pwszSeperator=wszCOMMA;
		else
		{
			if(dwFormatType & CRYPT_FORMAT_SEMICOLON)
				pwszSeperator=wszSEMICOLON;
			else
			{
				if(dwFormatType & CRYPT_FORMAT_CRLF)
					pwszSeperator=wszCRLF;
				else
                {
					pwszSeperator=wszPLUS;
                }
			}
		}

		//calculate the length of the seperator
		dwSeperator=wcslen(pwszSeperator)*sizeof(WCHAR);

		//check the requirement for the header
		if(dwFormatType & CRYPT_FORMAT_X509 ||
			dwFormatType & CRYPT_FORMAT_OID)
		{	
			fHeader=TRUE;
		}


		if(NULL==pBuffer)
			flengthOnly=TRUE;

		//decode the X509_UNICODE_NAME
		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			NULL, &cbStructInfo))
			goto DecodeError;

		//allocate memory
		pStructInfo=(CERT_NAME_INFO *)malloc(cbStructInfo);
		if(!pStructInfo)
			goto MemoryError;	

		//decode the struct
 		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			pStructInfo, &cbStructInfo))
			goto DecodeError;


		 //allocate the buffer for formatting
		if(!flengthOnly)
		{
			pwszBuffer=(WCHAR *)malloc(g_AllocateSize);
			if(!pwszBuffer)
				goto MemoryError;
				
			dwBufferLimit=g_AllocateSize;
		}

	   	//search for the OID requested.  If found one, put it
		//to the buffer.  If no requested attribut is found,
		//return.
		for(dwRDNIndex=0; dwRDNIndex<pStructInfo->cRDN; dwRDNIndex++)
		{
			//the following line is for code optimization
			dwAttrCount=(pStructInfo->rgRDN)[dwRDNIndex].cRDNAttr;

			for(dwAttrIndex=0; dwAttrIndex<dwAttrCount; dwAttrIndex++)
			{
				//look for the specific OIDs in the function
				if(_stricmp(lpszStructType,
				(pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex].pszObjId)==0)
				{
					pCertRDNAttr=&((pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex]);

					//init the dwBufferIncrement
					dwBufferIncrement=0;

					//get the header of the tag
					if(fHeader)
					{
						if(dwFormatType & CRYPT_FORMAT_X509)
						{
							//get the OID's name
							pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
														  (void *)lpszStructType,
														  CRYPT_RDN_ATTR_OID_GROUP_ID);

							if(pOIDInfo)
							{
								//allocate memory, including the NULL terminator
								pwszHeader=(WCHAR *)malloc((wcslen(pOIDInfo->pwszName)+wcslen(wszEQUAL)+1)*
									sizeof(WCHAR));
								if(!pwszHeader)
									goto MemoryError;

								wcscpy(pwszHeader,pOIDInfo->pwszName);

							}
						}

						//use the OID is no mapping is found or
						//OID is requested in the header
						if(pwszHeader==NULL)
						{
							//get the wide character string to the OID
							if(!(dwOIDSize=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),NULL,0)))
								goto szTOwszError;

							//allocate memory, including the NULL terminator
							pwszHeader=(WCHAR *)malloc((dwOIDSize+wcslen(wszEQUAL)+1)*
										sizeof(WCHAR));
							if(!pwszHeader)
								goto MemoryError;

							if(!(dwHeader=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),pwszHeader,dwOIDSize)))
								 goto szTOwszError;

							//NULL terminate the string
							*(pwszHeader+dwHeader)=L'\0';
							
						}

						//add the euqal sign
						wcscat(pwszHeader,	wszEQUAL);

						//get the header size, in bytes, excluding the NULL terminator
						dwHeader=wcslen(pwszHeader)*sizeof(WCHAR);
						dwBufferIncrement+=dwHeader;
					}


					//allocate enough memory.  Including the NULL terminator
					dwBufferIncrement+=pCertRDNAttr->Value.cbData;
					dwBufferIncrement+=dwSeperator;
					dwBufferIncrement+=2;
	

					if(!flengthOnly && ((dwBufferCount+dwBufferIncrement)>dwBufferLimit))
					{
					   //reallocate the memory
                        #if (0) // DSIE: Bug 27436
						pwszBuffer=(WCHAR *)realloc(pwszBuffer,
								max(dwBufferLimit+g_AllocateSize,
								dwBufferLimit+dwBufferIncrement));
						if(!pwszBuffer)
							goto MemoryError;
                        #endif

						pwszTemp=(WCHAR *)realloc(pwszBuffer,
								max(dwBufferLimit+g_AllocateSize,
    							dwBufferLimit+dwBufferIncrement));
						if(!pwszTemp)
							goto MemoryError;
                        pwszBuffer = pwszTemp;

                        dwBufferLimit+=max(g_AllocateSize,dwBufferIncrement);

					}
					
					//add the header if necessary
					if(fHeader)
					{							
						if(!flengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszHeader,dwHeader);
						}

						dwBufferCount+=dwHeader;

						//do not need to do header anymore
						fHeader=FALSE;
					}

					//add the seperator	after the 1st iteration
					if(fAddSeperator)
					{
						
						if(!flengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszSeperator,dwSeperator);
						}

						dwBufferCount+=dwSeperator;
					}
					else
						fAddSeperator=TRUE;

					//add the attr content
					if(!flengthOnly)
					{
						memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
							(pCertRDNAttr->Value.pbData),
							pCertRDNAttr->Value.cbData);
					}

					//increment the buffercount
					dwBufferCount+=pCertRDNAttr->Value.cbData;

				}
			}
		}


		//return the result as requested
		//check if the requested OID is actually in the DN
		if(0==dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto NotFoundError;
		}


		//we need to NULL terminate the string
		if(!flengthOnly)
			*(pwszBuffer+dwBufferCount/sizeof(WCHAR))=L'\0';

		dwBufferCount+=2;

		if(pBuffer==NULL)
		{
			*pcbBuffer=dwBufferCount;
			fResult=TRUE;
			goto CommonReturn;
		}

		if((*pcbBuffer)<dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto MoreDataError;		
		}


		*pcbBuffer=dwBufferCount;
		memcpy(pBuffer, pwszBuffer,dwBufferCount);

		fResult=TRUE;

CommonReturn:
		if(pwszHeader)
			free(pwszHeader);

		if(pwszBuffer)
			free(pwszBuffer);

		if(pStructInfo)
			free(pStructInfo);

		return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;


SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(DecodeError);
TRACE_ERROR(szTOwszError);
SET_ERROR(NotFoundError, E_FAIL);
SET_ERROR(MoreDataError, ERROR_MORE_DATA);
}




//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer)
{
    //makesure lpszStructType is X509_NAME or X509_UNICODE_NAME
	if((X509_NAME != lpszStructType) &&
		    (X509_UNICODE_NAME != lpszStructType))
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

 	//check input parameters
	if((pbEncoded==NULL && cbEncoded!=0) || pcbBuffer==NULL)
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

	if(cbEncoded==0)
    {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    //call CryptDllFormatNameAll with no prefix
    return  CryptDllFormatNameAll(dwEncodingType,	
                                  dwFormatType,
                                  dwFormatStrType,
                                  pStruct,
                                  0,
                                  FALSE,
                                  pbEncoded,
                                  cbEncoded,
                                  &pbBuffer,
                                  pcbBuffer);

}


//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
BOOL	CryptDllFormatNameAll(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer)
{

		BOOL			    fResult=FALSE;
		DWORD			    dwStrType=0;
		CERT_NAME_BLOB	    Cert_Name_Blob;
		DWORD			    dwSize=0;
        LPWSTR              pwszName=NULL;
        LPWSTR              pwszMulti=NULL;

		Cert_Name_Blob.cbData=cbEncoded;
		Cert_Name_Blob.pbData=(BYTE *)pbEncoded;

	
		//calculate the dwStryType to use for CertNameToStrW
        dwStrType=FormatToStr(dwFormatType);

        //overwrite dwStrType to default if we are doing MULTI line format
        //since the options will be ignored
        //We want to use + and , for the seperator
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        {

            dwStrType &=~(CERT_NAME_STR_CRLF_FLAG);
            dwStrType &=~(CERT_NAME_STR_COMMA_FLAG);
            dwStrType &=~(CERT_NAME_STR_SEMICOLON_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_QUOTING_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_PLUS_FLAG);


        }

        //if this function is not called from CryptDllFormatName,
        //make sure that we use the RESERSE Flag
        if(TRUE == fToAllocate)
            dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

		//call the CertNameToStrW to convert
        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        NULL,
                        0);

        if(0==dwSize)
            goto CertNameToStrError;

        pwszName=(LPWSTR)malloc(sizeof(WCHAR)*(dwSize));
        if(NULL==pwszName)
            goto MemoryError;

        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        pwszName,
                        dwSize);
        if(0==dwSize)
            goto CertNameToStrError;

        //we do not need to parse the string for single line format
        if(0==(dwFormatStrType &  CRYPT_FORMAT_STR_MULTI_LINE))
        {
            //calculate the bytes needed
            dwSize=sizeof(WCHAR)*(wcslen(pwszName)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszName, dwSize);
                *pcbBuffer=dwSize;
            }
            else
            {
                *ppbBuffer=malloc(dwSize);
                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszName, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }
        else
        {
            //we need to parse the string to make the multiple format
            if(!GetCertNameMulti(pwszName, idsPreFix, &pwszMulti))
                goto GetCertNameError;

            //calculate the bytes needee
            dwSize=sizeof(WCHAR)*(wcslen(pwszMulti)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszMulti, dwSize);
                *pcbBuffer=dwSize;

            }
            else
            {
                *ppbBuffer=malloc(dwSize);
                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszMulti, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }


        fResult=TRUE;


CommonReturn:

    if(pwszName)
        free(pwszName);

    if(pwszMulti)
        free(pwszMulti);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(CertNameToStrError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints2:   szOID_BASIC_CONSTRAINTS2
//                              X509_BASIC_CONSTRAINTS2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE];
	WCHAR							wszNone[NONE_SIZE];
	PCERT_BASIC_CONSTRAINTS2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for the subjectType
    if (pInfo->fCA)
		idsSub=IDS_SUB_CA;
	else
		idsSub=IDS_SUB_EE;

	if(!LoadStringU(hFrmtFuncInst,idsSub, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		goto LoadStringError;

    if (pInfo->fPathLenConstraint)
	{
        //decide between signle line and multi line display
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPCObject:
//
//   idsPreFix is the pre fix for mulit-line display
//--------------------------------------------------------------------------
BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPreFix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszClassId=NULL;
    WCHAR       wszPreFix[PRE_FIX_SIZE];
    DWORD       cbNeeded=0;

    LPWSTR      pwszClassFormat=NULL;
    LPWSTR      pwszDataFormat=NULL;

    LPWSTR      pwszTemp;

    assert(pInfo);

    *ppwszFormat=NULL;

   //load the pre-dix
   if(0!=idsPreFix)
   {
       if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
        goto LoadStringError;

   }


    cbNeeded=0;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

    pwszClassId=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszClassId)
         goto MemoryError;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        pwszClassId,
	                    &cbNeeded))
        goto FormatBytesToHexError;


    //format
    if(!FormatMessageUnicode(&pwszClassFormat, IDS_SPC_OBJECT_CLASS, pwszClassId))
            goto FormatMsgError;

    //strcat
    *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszClassFormat)+wcslen(wszPreFix)+wcslen(wszCOMMA)+1));
    if(NULL==*ppwszFormat)
        goto MemoryError;

    **ppwszFormat=L'\0';

    if(0!=idsPreFix)
        wcscat(*ppwszFormat, wszPreFix);

    wcscat(*ppwszFormat, pwszClassFormat);

    //format based on the availability of SerializedData
    if(0!=pInfo->SerializedData.cbData)
    {
        //cancatenate the ", " or \n"
        if(NULL != (*ppwszFormat))
        {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
               wcscat(*ppwszFormat, wszCRLF);
            else
               wcscat(*ppwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

          if(!FormatMessageUnicode(&pwszDataFormat, IDS_SPC_OBJECT_DATA,pwszHex))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        *ppwszFormat=(LPWSTR)realloc(*ppwszFormat,
                sizeof(WCHAR)* (wcslen(*ppwszFormat)+wcslen(pwszDataFormat)+wcslen(wszPreFix)+1));
        if(NULL==*ppwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(*ppwszFormat,
                sizeof(WCHAR)* (wcslen(*ppwszFormat)+wcslen(pwszDataFormat)+wcslen(wszPreFix)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        *ppwszFormat = pwszTemp;

        if(0!=idsPreFix)
            wcscat(*ppwszFormat, wszPreFix);

        wcscat(*ppwszFormat, pwszDataFormat);

    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszClassId)
        free(pwszClassId);

    if(pwszClassFormat)
        LocalFree((HLOCAL)pwszClassFormat);

    if(pwszDataFormat)
        LocalFree((HLOCAL)pwszDataFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(LoadStringError);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCLink:
//--------------------------------------------------------------------------
BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwsz)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszObj=NULL;
    UINT        ids=0;
    LPWSTR      pwszFormat=NULL;


    assert(pInfo);

    *ppwsz=NULL;

    switch(pInfo->dwLinkChoice)
    {
        case SPC_URL_LINK_CHOICE:
                if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_URL_LINK,pInfo->pwszUrl))
                    goto FormatMsgError;
            break;

        case SPC_MONIKER_LINK_CHOICE:
                if(!FormatSPCObject(
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            idsPreFix,
                            &(pInfo->Moniker),
                            &pwszObj))
                    goto FormatSPCObjectError;


                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_SPC_MONIKER_LINK_MULTI;
                else
                    ids=IDS_SPC_MONIKER_LINK;

                if(!FormatMessageUnicode(&pwszFormat,ids,pwszObj))
                    goto FormatMsgError;
            break;


        case SPC_FILE_LINK_CHOICE:
               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_FILE_LINK, pInfo->pwszFile))
                    goto FormatMsgError;

            break;

        default:

               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_LINK_UNKNOWN,
                        pInfo->dwLinkChoice))
                    goto FormatMsgError;
    }

    *ppwsz=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormat)+1));
    if(NULL==(*ppwsz))
        goto MemoryError;

    memcpy(*ppwsz, pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat)+1));
	fResult=TRUE;
	

CommonReturn:

    if(pwszObj)
        free(pwszObj);

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwsz)
    {
        free(*ppwsz);
        *ppwsz=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatSPCObjectError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCImage:
//--------------------------------------------------------------------------
BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat)
{
    BOOL        fResult=FALSE;
    LPWSTR       pwszFormat=NULL;
    LPWSTR       pwszLink=NULL;
    LPWSTR       pwszLinkFormat=NULL;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszHexFormat=NULL;
    UINT        ids=0;

    DWORD       cbNeeded=0;

    LPWSTR      pwszTemp;

    assert(pInfo);

    //init
    *ppwszImageFormat=NULL;

	pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwszFormat)
        goto MemoryError;

    *pwszFormat=L'\0';

    if(pInfo->pImageLink)
    {
        if(!FormatSPCLink(dwFormatType,
                          dwFormatStrType,
                          pFormatStruct,
                          idsPreFix,
                          pInfo->pImageLink,
                          &pwszLink))
            goto FormatSPCLinkError;

       //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_LINK_MULTI;
        else
            ids=IDS_IMAGE_LINK;


        if(!FormatMessageUnicode(&pwszLinkFormat, ids,
                            &pwszLink))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
                    sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszLinkFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
                    sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszLinkFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszLinkFormat);
    }

    if(0!=pInfo->Bitmap.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_BITMAP_MULTI;
        else
            ids=IDS_IMAGE_BITMAP;


        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->Metafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->EnhancedMetafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_ENHANCED_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_ENHANCED_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->GifFile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_GIFFILE_MULTI;
        else
            ids=IDS_IMAGE_GIFFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, IDS_IMAGE_GIFFILE,
            pwszHex))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

    if(0==wcslen(pwszFormat))
    {
        //fine if nothing is formatted
        *ppwszImageFormat=NULL;
    }
    else
    {
        *ppwszImageFormat=(LPWSTR)malloc(sizeof(WCHAR)*(wcslen(pwszFormat)+1));  
        #if (0) //  DSIE: Bug 27432 & 27434
        if(NULL == ppwszImageFormat)
        #endif
        if(NULL == *ppwszImageFormat)
            goto MemoryError;

        memcpy(*ppwszImageFormat, pwszFormat, sizeof(WCHAR)*(wcslen(pwszFormat)+1));
    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszHexFormat)
        LocalFree((HLOCAL)pwszHexFormat);

    if(pwszLink)
        free(pwszLink);

    if(pwszLinkFormat)
        LocalFree((HLOCAL)pwszLinkFormat);

    if(pwszFormat)
        free(pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwszImageFormat)
    {
        free(*ppwszImageFormat);
        *ppwszImageFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPAgencyInfo:   SPC_SP_AGENCY_INFO_STRUCT
//                         SPC_SP_AGENCY_INFO_OBJID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
	PSPC_SP_AGENCY_INFO         	pInfo=NULL;

    LPWSTR                          pwszPolicyInfo=NULL;
    LPWSTR                          pwszPolicyInfoFormat=NULL;
    LPWSTR                          pwszLogoLink=NULL;
    LPWSTR                          pwszLogoLinkFormat=NULL;
    LPWSTR                          pwszPolicyDsplyFormat=NULL;
    LPWSTR                          pwszLogoImage=NULL;
    LPWSTR                          pwszLogoImageFormat=NULL;

	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_SP_AGENCY_INFO_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    //format pPolicyInformation
    if(pInfo->pPolicyInformation)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;

        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pPolicyInformation,
                             &pwszPolicyInfo))
            goto FormatSPCLinkError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_INFO_MULTI;
        else
            ids=IDS_AGENCY_POLICY_INFO;

        if(!FormatMessageUnicode(&pwszPolicyInfoFormat, ids, pwszPolicyInfo))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyInfoFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyInfoFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszPolicyInfoFormat);
    }


    //format pwszPolicyDisplayText
    if(pInfo->pwszPolicyDisplayText)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_DSPLY_MULTI;
        else
            ids=IDS_AGENCY_POLICY_DSPLY;

        if(!FormatMessageUnicode(&pwszPolicyDsplyFormat, ids, pInfo->pwszPolicyDisplayText))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyDsplyFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyDsplyFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszPolicyDsplyFormat);
    }

    //pLogoImage
    if(pInfo->pLogoImage)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_THREE_TABS;
        else
            ids=0;


        if(!FormatSPCImage(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoImage,
                             &pwszLogoImage))
            goto FormatSPCImageError;

        //spcImage can include nothing
        if(NULL!=pwszLogoImage)
        {
            //strcat ", "
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AGENCY_LOGO_IMAGE_MULTI;
            else
                ids=IDS_AGENCY_LOGO_IMAGE;


            if(!FormatMessageUnicode(&pwszLogoImageFormat,ids,pwszLogoImage))
                goto FormatMsgError;

            //strcat
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz,
                sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoImageFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz,
                sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoImageFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszLogoImageFormat);
        }

    }

    //format pLogoLink
    if(pInfo->pLogoLink)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;


        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoLink,
                             &pwszLogoLink))
            goto FormatSPCLinkError;


        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_LOGO_LINK_MULTI;
        else
            ids=IDS_AGENCY_LOGO_LINK;

        if(!FormatMessageUnicode(&pwszLogoLinkFormat, ids, pwszLogoLink))
            goto FormatMsgError;

        //strcat
        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoLinkFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoLinkFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszLogoLinkFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc((NO_INFO_SIZE+1)*sizeof(WCHAR));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszPolicyInfo)
        free(pwszPolicyInfo);

    if(pwszPolicyInfoFormat)
        LocalFree((HLOCAL)pwszPolicyInfoFormat);

    if(pwszLogoLink)
        free(pwszLogoLink);

    if(pwszLogoLinkFormat)
        LocalFree((HLOCAL)pwszLogoLinkFormat);

    if(pwszPolicyDsplyFormat)
        LocalFree((HLOCAL)pwszPolicyDsplyFormat);

    if(pwszLogoImage)
        free(pwszLogoImage);

    if(pwszLogoImageFormat)
        LocalFree((HLOCAL)pwszLogoImageFormat);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatSPCImageError);

}

//--------------------------------------------------------------------------
//
//	 GetNoticeNumberString:
//
//	 The memory should be allocated via malloc
//--------------------------------------------------------------------------
BOOL WINAPI	GetNoticeNumberString(	DWORD	cNoticeNumbers,
								int		*rgNoticeNumbers,
								LPWSTR	*ppwszNumber)
{
    BOOL		fResult=FALSE;
	WCHAR		wszNumber[INT_SIZE];
	DWORD		dwIndex=0;
    
    LPWSTR      pwszTemp;

	*ppwszNumber=NULL;

	if(NULL==rgNoticeNumbers || 0==cNoticeNumbers)
		goto InvalidArg;

	*ppwszNumber=(LPWSTR)malloc(sizeof(WCHAR));
	if(NULL==*ppwszNumber)
		goto MemoryError;

	**ppwszNumber=L'\0';

	for(dwIndex=0; dwIndex<cNoticeNumbers; dwIndex++)
	{
		wszNumber[0]='\0';

		_itow(rgNoticeNumbers[dwIndex], wszNumber, 10);

		if(wcslen(wszNumber) > 0)
		{
            #if (0) // DSIE: Bug 27436
			*ppwszNumber=(LPWSTR)realloc(*ppwszNumber,
				sizeof(WCHAR)*(wcslen(*ppwszNumber)+wcslen(wszNumber)+wcslen(wszCOMMA)+1));
			if(NULL==*ppwszNumber)
				goto MemoryError;
            #endif

			pwszTemp=(LPWSTR)realloc(*ppwszNumber,
				sizeof(WCHAR)*(wcslen(*ppwszNumber)+wcslen(wszNumber)+wcslen(wszCOMMA)+1));
			if(NULL==pwszTemp)
				goto MemoryError;
            *ppwszNumber = pwszTemp;

			wcscat(*ppwszNumber, wszNumber);

			if(dwIndex != (cNoticeNumbers-1))
				wcscat(*ppwszNumber, wszCOMMA);
		}
	}

	if(0==wcslen(*ppwszNumber))
		goto InvalidArg;

	fResult=TRUE;
	

CommonReturn:

	return fResult;

ErrorReturn:

	if(*ppwszNumber)
	{
		free(*ppwszNumber);
		*ppwszNumber=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatCertQualifier:
//
//	 The memory should be allocated via malloc
//--------------------------------------------------------------------------
BOOL	FormatPolicyUserNotice(
						DWORD		        dwCertEncodingType,
						DWORD		        dwFormatType,
						DWORD		        dwFormatStrType,
						void		        *pFormatStruct,
						UINT				idsPreFix,
						BYTE				*pbEncoded,	
						DWORD				cbEncoded,
						LPWSTR				*ppwsz)
{
    BOOL							fResult=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	WCHAR							wszPreFix[PREFIX_SIZE];
	WCHAR							wszNextPre[PREFIX_SIZE];
	WCHAR							wszText[SUBJECT_SIZE];
	BOOL							fComma=FALSE;

	CERT_POLICY_QUALIFIER_USER_NOTICE	*pInfo=NULL;
	LPWSTR							pwszOrg=NULL;
	LPWSTR							pwszNumber=NULL;

    LPWSTR                          pwszTemp;

	*ppwsz=NULL;

    if (!DecodeGenericBLOB(dwCertEncodingType,	szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	if(!LoadStringU(hFrmtFuncInst,idsPreFix, wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
		goto LoadStringError;

	if(!LoadStringU(hFrmtFuncInst,idsPreFix+1, wszNextPre, sizeof(wszNextPre)/sizeof(wszNextPre[0])))
		goto LoadStringError;

	if(NULL == pInfo->pNoticeReference && NULL == pInfo->pszDisplayText)
	{

        //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        *ppwsz=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(wszNoInfo) + wcslen(wszPreFix) + POSTFIX_SIZE + 1));
		if(NULL==*ppwsz)
			goto MemoryError;  

		**ppwsz=L'\0';

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
			wcscat(*ppwsz, wszPreFix);

		wcscat(*ppwsz, wszNoInfo);

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
			wcscat(*ppwsz, wszCRLF);
	}
	else
	{
		*ppwsz=(LPWSTR)malloc(sizeof(WCHAR));
		if(NULL==*ppwsz)
			goto MemoryError; 

		**ppwsz=L'\0';

		if(pInfo->pNoticeReference)
		{

			if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF, wszText, sizeof(wszText)/sizeof(wszText[0])))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            *ppwsz=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
			if(NULL==*ppwsz)
				 goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
			if(NULL==pwszTemp)
				 goto MemoryError;
            *ppwsz = pwszTemp;

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszPreFix);

			wcscat(*ppwsz, wszText);

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszCRLF);

			if(pInfo->pNoticeReference->pszOrganization)
			{
				if(S_OK!=SZtoWSZ(pInfo->pNoticeReference->pszOrganization, &pwszOrg))
					goto SZtoWSZError;

				if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF_ORG, wszText, sizeof(wszText)/sizeof(wszText[0])))
					goto LoadStringError;

                #if (0) // DSIE: Bug 27436
			    *ppwsz=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszOrg)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
    			if(NULL==*ppwsz)
					 goto MemoryError;
                #endif

			    pwszTemp=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszOrg)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
    			if(NULL==pwszTemp)
					 goto MemoryError;
                *ppwsz = pwszTemp;

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszNextPre);

				wcscat(*ppwsz, wszText);
				wcscat(*ppwsz, pwszOrg);

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszCRLF);
				else
				{
					wcscat(*ppwsz, wszCOMMA);
					fComma=TRUE;
				}
			}

			if(pInfo->pNoticeReference->cNoticeNumbers)
			{
				if(NULL == pInfo->pNoticeReference->rgNoticeNumbers)
					goto InvalidArg;

				if(!GetNoticeNumberString(pInfo->pNoticeReference->cNoticeNumbers,
										  pInfo->pNoticeReference->rgNoticeNumbers,
										  &pwszNumber))
					goto GetNumberError;

				if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_REF_NUMBER, wszText, sizeof(wszText)/sizeof(wszText[0])))
					goto LoadStringError;

                #if (0) // DSIE: Bug 27436
    		    *ppwsz=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszNumber)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
				if(NULL==*ppwsz)
					 goto MemoryError;
                #endif

    		    pwszTemp=(LPWSTR)realloc(*ppwsz, 
					 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pwszNumber)+wcslen(wszNextPre)+POSTFIX_SIZE+1));
				if(NULL==pwszTemp)
					 goto MemoryError;
                *ppwsz = pwszTemp;

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszNextPre);

				wcscat(*ppwsz, wszText);
				wcscat(*ppwsz, pwszNumber);

				if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
					wcscat(*ppwsz, wszCRLF);
				else
				{
					wcscat(*ppwsz, wszCOMMA);
					fComma=TRUE;
				}
			}
		}

		if(pInfo->pszDisplayText)
		{
			if(!LoadStringU(hFrmtFuncInst,IDS_USER_NOTICE_TEXT, wszText, sizeof(wszText)/sizeof(wszText[0])))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            *ppwsz=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pInfo->pszDisplayText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
		    if(NULL==*ppwsz)
				 goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(*ppwsz, 
                 sizeof(WCHAR) * (wcslen(*ppwsz)+wcslen(wszText)+wcslen(pInfo->pszDisplayText)+wcslen(wszPreFix)+POSTFIX_SIZE+1));
		    if(NULL==pwszTemp)
				 goto MemoryError;
            *ppwsz = pwszTemp;

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszPreFix);

			wcscat(*ppwsz, wszText);
			wcscat(*ppwsz, pInfo->pszDisplayText);

			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				wcscat(*ppwsz, wszCRLF);
			else
			{
				wcscat(*ppwsz, wszCOMMA);
				fComma=TRUE;
			}
		}

		//get rid of the last comma
		if(fComma)
			*(*ppwsz+wcslen(*ppwsz)-wcslen(wszCOMMA))=L'\0';
	}

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszOrg)
		free(pwszOrg);

	if(pwszNumber)
		free(pwszNumber);

	return fResult;

ErrorReturn:

	if(*ppwsz)
	{
		free(*ppwsz);
		*ppwsz=NULL;
	}

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(SZtoWSZError);
TRACE_ERROR(GetNumberError);
SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
}


//--------------------------------------------------------------------------
//
//	 FormatCertQualifier:
//--------------------------------------------------------------------------
BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat)
{
    BOOL				fResult=FALSE;
    DWORD				cbNeeded=0;
    UINT				ids=0;
    PCCRYPT_OID_INFO	pOIDInfo=NULL;

    LPWSTR				pwszName=NULL;
	LPWSTR				pwszElement=NULL;
	LPWSTR				pwszOID=NULL;

    *ppwszFormat=NULL;

	//get the oid name
	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
				pInfo->pszPolicyQualifierId,
				0);

	if(NULL == pOIDInfo)
	{
		if(S_OK!=SZtoWSZ(pInfo->pszPolicyQualifierId, &pwszOID))
			goto SZtoWSZError;
	}

    if(pInfo->Qualifier.cbData)
    {
	   if(0==strcmp(szOID_PKIX_POLICY_QUALIFIER_CPS, pInfo->pszPolicyQualifierId))
	   {
			//this is just a unicode format
			//turn off the multi line here
		   cbNeeded=0;

			if(!FormatAnyUnicodeStringExtension(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
					pFormatStruct,
					pInfo->pszPolicyQualifierId,
					pInfo->Qualifier.pbData,
					pInfo->Qualifier.cbData,
					NULL,		
					&cbNeeded))
				goto FormatUnicodeError;

			pwszName=(LPWSTR)malloc(cbNeeded);
			if(NULL==pwszName)
				goto MemoryError;

			if(!FormatAnyUnicodeStringExtension(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
					pFormatStruct,
					pInfo->pszPolicyQualifierId,
					pInfo->Qualifier.pbData,
					pInfo->Qualifier.cbData,
					pwszName,		
					&cbNeeded))
				goto FormatUnicodeError;

	   }
	   else
	   {
			if(0==strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,pInfo->pszPolicyQualifierId))
			{
				//this is yet another struct to format.  We remember to have
				//a 3 tab prefix
				if(!FormatPolicyUserNotice(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								IDS_THREE_TABS,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								&pwszName))
					goto FormatUserNoticdeError;
			}
			else
			{
			   //get the Hex dump of the Key Usage
			   cbNeeded=0;

			   if(!FormatBytesToHex(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								NULL,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								NULL,
								&cbNeeded))
					goto FormatBytesToHexError;

				pwszName=(LPWSTR)malloc(cbNeeded);
				if(NULL==pwszName)
					goto MemoryError;

				if(!FormatBytesToHex(
								dwCertEncodingType,
								dwFormatType,
								dwFormatStrType,
								pFormatStruct,
								NULL,
								pInfo->Qualifier.pbData,
								pInfo->Qualifier.cbData,
								pwszName,
								&cbNeeded))
					goto FormatBytesToHexError;

			}
	   }

	   //add the desired 3 tab prefix and new line for CSP and the new line
	   //for the multi line case
	   if((dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) &&
		   (0!=strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,pInfo->pszPolicyQualifierId)))
	   {
			if(!FormatMessageUnicode(&pwszElement, IDS_POLICY_QUALIFIER_ELEMENT,
					pwszName))
				goto FormatMsgError;
	   }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_POLICY_QUALIFIER_MULTI;
        else
            ids=IDS_POLICY_QUALIFIER;


        if(!FormatMessageUnicode(ppwszFormat, ids,
            pOIDInfo? pOIDInfo->pwszName : pwszOID, 
			pwszElement? pwszElement : pwszName))
            goto FormatMsgError;
    }
    else
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_POLICY_QUALIFIER_NO_BLOB_MULTI;
        else
            ids=IDS_POLICY_QUALIFIER_NO_BLOB;

        if(!FormatMessageUnicode(ppwszFormat, ids,
           pOIDInfo? pOIDInfo->pwszName : pwszOID))
            goto FormatMsgError;

    }

	fResult=TRUE;
	

CommonReturn:

    if(pwszName)
        free(pwszName);

	if(pwszElement)
		LocalFree((HLOCAL)pwszElement);

	if(pwszOID)
		free(pwszOID);

	return fResult;

ErrorReturn:

    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatUnicodeError);
TRACE_ERROR(FormatUserNoticdeError);
TRACE_ERROR(SZtoWSZError);
}


//--------------------------------------------------------------------------
//
//	 FormatCertPolicies:     X509_CERT_POLICIES
//                           szOID_CERT_POLICIES
//                           szOID_APPLICATION_CERT_POLICIES
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                           pwsz=NULL;
    LPWSTR                           pwszPolicyFormat=NULL;
    LPWSTR                           pwszQualifiers=NULL;
    LPWSTR                           pwszQualifierFormat=NULL;
    LPWSTR                           pwszOneQualifier=NULL;
	LPWSTR							 pwszOID=NULL;

	PCERT_POLICIES_INFO	            pInfo=NULL;

    PCERT_POLICY_INFO               pPolicyInfo=NULL;
    DWORD                           dwIndex=0;
    DWORD                           dwQualifierIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;
    PCCRYPT_OID_INFO                pOIDInfo=NULL;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CERT_POLICIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex < pInfo->cPolicyInfo; dwIndex++)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
               wcscat(pwsz, wszCOMMA);
        }

        pPolicyInfo=&(pInfo->rgPolicyInfo[dwIndex]);


        pwszQualifiers=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwszQualifiers)
            goto MemoryError;

        *pwszQualifiers=L'\0';

         //format the qualifiers
         for(dwQualifierIndex=0;  dwQualifierIndex < pPolicyInfo->cPolicyQualifier;
            dwQualifierIndex++)
         {
            //strcat ", "
            if(0!=wcslen(pwszQualifiers))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwszQualifiers, wszCOMMA);
            }

            if(!FormatCertQualifier(dwCertEncodingType,
                                    dwFormatType,
                                    dwFormatStrType,
                                    pFormatStruct,
                                    &(pPolicyInfo->rgPolicyQualifier[dwQualifierIndex]),
                                    &pwszOneQualifier))
                   goto FormatCertQualifierError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_POLICY_QUALIFIER_INFO_MULTI;
            else
                ids=IDS_POLICY_QUALIFIER_INFO;

             //format
             if(!FormatMessageUnicode(&pwszQualifierFormat,ids,
                    dwIndex+1,
                    dwQualifierIndex+1,
                    pwszOneQualifier))
                    goto FormatMsgError;

             //strcat
             #if (0) // DSIE: Bug 27436
             pwszQualifiers=(LPWSTR)realloc(pwszQualifiers, 
                 sizeof(WCHAR) * (wcslen(pwszQualifiers)+wcslen(wszCOMMA)+wcslen(pwszQualifierFormat)+1));
             if(NULL==pwszQualifiers)
                 goto MemoryError;
             #endif

             pwszTemp=(LPWSTR)realloc(pwszQualifiers, 
                 sizeof(WCHAR) * (wcslen(pwszQualifiers)+wcslen(wszCOMMA)+wcslen(pwszQualifierFormat)+1));
             if(NULL==pwszTemp)
                 goto MemoryError;
             pwszQualifiers = pwszTemp;

             wcscat(pwszQualifiers, pwszQualifierFormat);

             LocalFree((HLOCAL)pwszOneQualifier);
             pwszOneQualifier=NULL;

             LocalFree((HLOCAL)pwszQualifierFormat);
             pwszQualifierFormat=NULL;
         }

         //now, format the certPolicyInfo
		 pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
						pPolicyInfo->pszPolicyIdentifier,
					    0);

		 if(NULL == pOIDInfo)
		 {
			if(S_OK!=SZtoWSZ(pPolicyInfo->pszPolicyIdentifier, &pwszOID))
				goto SZtoWSZError;
		 }

         if(0!=pPolicyInfo->cPolicyQualifier)
         {
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_MULTI;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY;
                else
                    ids=IDS_APPLICATION_CERT_POLICY;

             if(!FormatMessageUnicode(&pwszPolicyFormat,ids,
						dwIndex+1, pOIDInfo? pOIDInfo->pwszName : pwszOID,
                        pwszQualifiers))
                goto FormatMsgError;
         }
         else
         {
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_NO_QUA_MULTI;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_NO_QUA_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_CERT_POLICIES))
                    ids=IDS_CERT_POLICY_NO_QUA;
                else
                    ids=IDS_APPLICATION_CERT_POLICY_NO_QUA;

             if(!FormatMessageUnicode(&pwszPolicyFormat, ids,
                        dwIndex+1, pOIDInfo? pOIDInfo->pwszName : pwszOID))
                goto FormatMsgError;
         }

         //strcat
         #if (0) // DSIE: Bug 27436
         pwsz=(LPWSTR)realloc(pwsz, 
             sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
         if(NULL==pwsz)
             goto MemoryError;
         #endif

         pwszTemp=(LPWSTR)realloc(pwsz, 
             sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
         if(NULL==pwszTemp)
             goto MemoryError;
         pwsz = pwszTemp;

         wcscat(pwsz, pwszPolicyFormat);

         free(pwszQualifiers);
         pwszQualifiers=NULL;

         LocalFree((HLOCAL)pwszPolicyFormat);
         pwszPolicyFormat=NULL;

		 if(pwszOID)
			free(pwszOID);
		 pwszOID=NULL;
    }


    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszOID)
		free(pwszOID);

    if(pwszOneQualifier)
        LocalFree((HLOCAL)pwszOneQualifier);

    if(pwszQualifierFormat)
        LocalFree((HLOCAL)pwszQualifierFormat);

    if(pwszQualifiers)
      free(pwszQualifiers);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatCertQualifierError);
TRACE_ERROR(SZtoWSZError);
}


//--------------------------------------------------------------------------
//
//	 FormatCAVersion:   szOID_CERTSRV_CA_VERSION
//						Decode as X509_INTEGER
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCAVersion(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
	UINT							ids=0;
	DWORD							dwCAVersion=0;
	DWORD							cbCAVersion=sizeof(dwCAVersion);

	LPWSTR							pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

	if(!CryptDecodeObject(dwCertEncodingType,X509_INTEGER,pbEncoded, cbEncoded,
		0,&dwCAVersion,&cbCAVersion))
		goto DecodeGenericError;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_CA_VERSION_MULTI;
    else
        ids=IDS_CA_VERSION;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            CANAMEIDTOICERT(dwCAVersion), CANAMEIDTOIKEY(dwCAVersion)))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatNetscapeCertType:     
//							szOID_NETSCAPE_CERT_TYPE
//							Decode as X509_BITS
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatNetscapeCertType(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
    WCHAR                           wszCertType[CERT_TYPE_SIZE+1];
	FORMAT_CERT_TYPE_INFO			rgCertType[]={
		  NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE,	IDS_NETSCAPE_SSL_CLIENT_AUTH,  //0x80
		  NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE,	IDS_NETSCAPE_SSL_SERVER_AUTH,  //0x40
		  NETSCAPE_SMIME_CERT_TYPE,          	IDS_NETSCAPE_SMIME,			   //0x20
		  NETSCAPE_SIGN_CERT_TYPE,           	IDS_NETSCAPE_SIGN,			   //0x10
		  0x08,									IDS_UNKNOWN_CERT_TYPE,		   //0x08
		  NETSCAPE_SSL_CA_CERT_TYPE,         	IDS_NETSCAPE_SSL_CA,		   //0x04	
		  NETSCAPE_SMIME_CA_CERT_TYPE,       	IDS_NETSCAPE_SMIME_CA,		   //0x02
		  NETSCAPE_SIGN_CA_CERT_TYPE, 			IDS_NETSCAPE_SIGN_CA};		   //0x01
	DWORD							dwCertType=0;
	DWORD							dwIndex=0;

	CRYPT_BIT_BLOB					*pInfo=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszByte=NULL;
	LPWSTR							pwszFormat=NULL;

    LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

   if(!DecodeGenericBLOB(dwCertEncodingType,X509_BITS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;	 

    if(0==pInfo->cbData)
	   goto InvalidArg;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    //the count of bits to consider
	dwCertType=sizeof(rgCertType)/sizeof(rgCertType[0]);

	//we need to consider the unused bits in the last byte
	if((1 == pInfo->cbData) && (8 > pInfo->cUnusedBits))
	{
		dwCertType=8-pInfo->cUnusedBits;
	}

	for(dwIndex=0; dwIndex<dwCertType; dwIndex++)
	{
		if(pInfo->pbData[0] & rgCertType[dwIndex].bCertType)
		{
			if(!LoadStringU(hFrmtFuncInst, rgCertType[dwIndex].idsCertType, wszCertType, CERT_TYPE_SIZE))
				goto LoadStringError;

            #if (0) // DSIE: Bug 27436
			pwsz=(LPWSTR)realloc(pwsz, 
				sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
			if(NULL==pwsz)
				goto MemoryError;
            #endif

			pwszTemp=(LPWSTR)realloc(pwsz, 
				sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
			if(NULL==pwszTemp)
				goto MemoryError;
            pwsz = pwszTemp;

			wcscat(pwsz, wszCertType);
			wcscat(pwsz, wszCOMMA);
		}
	}

	//there is data that we can not interpret if the bit number is more than 8
	if(8 < (8 * pInfo->cbData - pInfo->cUnusedBits))
	{
		if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CERT_TYPE, wszCertType, CERT_TYPE_SIZE))
			goto LoadStringError;

        #if (0) // DSIE: Bug 27436
		pwsz=(LPWSTR)realloc(pwsz, 
			sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
		if(NULL==pwsz)
			goto MemoryError;
        #endif

		pwszTemp=(LPWSTR)realloc(pwsz, 
			sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCertType)+1+wcslen(wszCOMMA)));
		if(NULL==pwszTemp)
			goto MemoryError;
        pwsz = pwszTemp;

		wcscat(pwsz, wszCertType);
		wcscat(pwsz, wszCOMMA);
	}

	
    if(0==wcslen(pwsz))
    {
       #if (0) // DSIE: Bug 27436
       pwsz=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (CERT_TYPE_SIZE+1));
	   if(NULL == pwsz)
		   goto MemoryError;
       #endif

       pwszTemp=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (CERT_TYPE_SIZE+1));
	   if(NULL == pwszTemp)
		   goto MemoryError;
       pwsz = pwszTemp;

       if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CERT_TYPE, pwsz,
           CERT_TYPE_SIZE))
		        goto LoadStringError;
    }
    else
    {
        //get rid of the last comma
        *(pwsz+wcslen(pwsz)-wcslen(wszCOMMA))=L'\0';
    }

    //get the Hex dump of the cert type
   cbNeeded=0;

   if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    NULL,
	                &cbNeeded))
		goto FormatBytesToHexError;

    pwszByte=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszByte)
        goto MemoryError;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    pwszByte,
	                &cbNeeded))
        goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(&pwszFormat, IDS_BIT_BLOB, pwsz,
        pwszByte))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

    if(pwsz)
        free(pwsz);

    if(pwszByte)
        free(pwszByte);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);	
TRACE_ERROR(LoadStringError);
}


//--------------------------------------------------------------------------
//
//	 FormatAnyUnicodeStringExtension:     
//									szOID_ENROLLMENT_NAME_VALUE_PAIR
//									Decode as szOID_ENROLLMENT_NAME_VALUE_PAIR
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAnyNameValueStringAttr(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL								fResult=FALSE;
	DWORD								cbNeeded=0;
	UINT								ids=0;

	CRYPT_ENROLLMENT_NAME_VALUE_PAIR	*pInfo=NULL;
	LPWSTR								pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_ENROLLMENT_NAME_VALUE_PAIR,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	if(NULL == pInfo->pwszName || NULL == pInfo->pwszValue)
		goto InvalidArg;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_NAME_VALUE_MULTI;
    else
        ids=IDS_NAME_VALUE;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            pInfo->pwszName, pInfo->pwszValue))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	 FormatAnyUnicodeStringExtension:     
//									szOID_ENROLL_CERTTYPE_EXTENSION
//									szOID_NETSCAPE_REVOCATION_URL
//									Decode as X509_ANY_UNICODE_STRING
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAnyUnicodeStringExtension(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	BOOL							fResult=FALSE;
	DWORD							cbNeeded=0;
	UINT							ids=0;

	CERT_NAME_VALUE					*pInfo=NULL;
	LPWSTR							pwszFormat=NULL;

	//check for input parameters
	if((NULL==pbEncoded && 0!=cbEncoded) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_UNICODE_ANY_STRING,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//the data can not be the encoded blob or the octect string
	if(!IS_CERT_RDN_CHAR_STRING(pInfo->dwValueType))
		goto DecodeGenericError;

    //decide between single line and mulitple line format
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        ids=IDS_UNICODE_STRING_MULTI;
    else
        ids=IDS_UNICODE_STRING;

	if(!FormatMessageUnicode(&pwszFormat, ids,
            (LPWSTR)(pInfo->Value.pbData)))
		goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pInfo)
		free(pInfo);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	 FormatDistPointName:  Pre-condition: dwDistPointNameChoice!=0
//--------------------------------------------------------------------------
BOOL    FormatDistPointName(DWORD		            dwCertEncodingType,
	                        DWORD		            dwFormatType,
	                        DWORD		            dwFormatStrType,
	                        void		            *pFormatStruct,
                            PCRL_DIST_POINT_NAME    pInfo,
                            LPWSTR                  *ppwszFormat)
{
    BOOL            fResult=FALSE;
    DWORD           cbNeeded=0;
    LPWSTR          pwszCRLIssuer=NULL;
    UINT            ids=0;

    *ppwszFormat=NULL;

    if(CRL_DIST_POINT_FULL_NAME==pInfo->dwDistPointNameChoice)
    {
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_THREE_TABS;

        cbNeeded=0;
        if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

        pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszCRLIssuer)
            goto MemoryError;

         if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 pwszCRLIssuer,
                                 &cbNeeded))
              goto FormatAltNameError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_CRL_DIST_FULL_NAME_MULTI;
        else
              ids=IDS_CRL_DIST_FULL_NAME;


         if(!FormatMessageUnicode(ppwszFormat, ids,pwszCRLIssuer))
             goto FormatMsgError;
    }
    else if(CRL_DIST_POINT_ISSUER_RDN_NAME==pInfo->dwDistPointNameChoice)
    {
        *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(CRL_DIST_NAME_SIZE+1));
        if(NULL==*ppwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst, IDS_CRL_DIST_ISSUER_RDN,
                *ppwszFormat,CRL_DIST_NAME_SIZE))
            goto LoadStringError;

    }
    else
    {
        if(!FormatMessageUnicode(ppwszFormat, IDS_DWORD,
            pInfo->dwDistPointNameChoice))
            goto FormatMsgError;
    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszCRLIssuer)
        free(pwszCRLIssuer);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatAltNameError);

}
//--------------------------------------------------------------------------
//
//	 FormatCRLReason:  Pre-condition: pReason.cbData != 0
//--------------------------------------------------------------------------
BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat)
{
    LPWSTR                          pwszFormat=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszReason[CRL_REASON_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;

	*ppwszFormat=NULL;

    pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwszFormat)
        goto MemoryError;

    *pwszFormat=L'\0';

    //format the 1st byte
    if(pInfo->pbData[0] & CRL_REASON_UNUSED_FLAG)
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_UNSPECIFIED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_KEY_COMPROMISE_FLAG)
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_KEY_COMPROMISE, wszReason,CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CA_COMPROMISE_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CA_COMPROMISE,wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }


    if(pInfo->pbData[0] & CRL_REASON_AFFILIATION_CHANGED_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_AFFILIATION_CHANGED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_SUPERSEDED_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_SUPERSEDED, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
		pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

		pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CESSATION_OF_OPERATION_FLAG )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CESSATION_OF_OPERATION, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(pInfo->pbData[0] & CRL_REASON_CERTIFICATE_HOLD_FLAG  )
    {
        if(!LoadStringU(hFrmtFuncInst, IDS_CERTIFICATE_HOLD, wszReason, CRL_REASON_SIZE))
	        goto LoadStringError;

        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, 
			sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, wszReason);
        wcscat(pwszFormat, wszCOMMA);
    }

    if(0==wcslen(pwszFormat))
    {
        #if (0) // DSIE: Bug 27436
        pwszFormat=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (UNKNOWN_CRL_REASON_SIZE+1));
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (UNKNOWN_CRL_REASON_SIZE+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CRL_REASON, pwszFormat,
            UNKNOWN_CRL_REASON_SIZE))
	            goto LoadStringError;
    }
    else
    {
        //get rid of the last comma
        *(pwszFormat+wcslen(pwszFormat)-wcslen(wszCOMMA))=L'\0';
    }

    //get the Hex dump of the Key Usage
    cbNeeded=0;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    NULL,
	                &cbNeeded))
        goto FormatBytesToHexError;

    pwszByte=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszByte)
        goto MemoryError;

    if(!FormatBytesToHex(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    lpszStructType,
                    pInfo->pbData,
                    pInfo->cbData,
                    pwszByte,
	                &cbNeeded))
        goto FormatBytesToHexError;

    //convert the WSZ
    if(!FormatMessageUnicode(ppwszFormat, IDS_BIT_BLOB, pwszFormat,
        pwszByte))
        goto FormatMsgError;

	fResult=TRUE;
	
CommonReturn:
    if(pwszFormat)
        free(pwszFormat);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatCRLDistPoints:   X509_CRL_DIST_POINTS
//                          szOID_CRL_DIST_POINTS
//                          szOID_FRESHEST_CRL
//                          szOID_CRL_SELF_CDP
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR					pwszFormat=NULL;
    LPWSTR                  pwsz=NULL;
    LPWSTR                  pwszEntryFormat=NULL;
    LPWSTR                  pwszEntryTagFormat=NULL;

    LPWSTR                  pwszPointName=NULL;
    LPWSTR                  pwszNameFormat=NULL;
    LPWSTR                  pwszCRLReason=NULL;
    LPWSTR                  pwszReasonFormat=NULL;
    LPWSTR                  pwszCRLIssuer=NULL;
    LPWSTR                  pwszIssuerFormat=NULL;

	PCRL_DIST_POINTS_INFO	pInfo=NULL;

	DWORD					cbNeeded=0;
    DWORD                   dwIndex=0;
	BOOL					fResult=FALSE;
    UINT                    ids=0;

    LPWSTR                  pwszTemp;
    LPCSTR                  pszOID;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    //DSIE: Cert server encodes szOID_CRL_SEL_CDP using szOID_CRL_DIST_POINTS,
    //      so we need to change the lpszStructType for decoding.
    if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
    {
        pszOID = szOID_CRL_DIST_POINTS;
    }
    else
    {
        pszOID = lpszStructType;
    }
    
    if (!DecodeGenericBLOB(dwCertEncodingType, pszOID, //lpszStructType,
			pbEncoded, cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;
    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cDistPoint; dwIndex++)
    {
        //format distribution name
        if(0!=pInfo->rgDistPoint[dwIndex].DistPointName.dwDistPointNameChoice)
        {
            if(!FormatDistPointName(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    &(pInfo->rgDistPoint[dwIndex].DistPointName),
                    &pwszPointName))
                goto FormatDistPointNameError;

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_NAME_MULTI;
            else
                ids=IDS_CRL_DIST_NAME;


            if(!FormatMessageUnicode(&pwszNameFormat, ids,pwszPointName))
                goto FormatMsgError;
        }

        //format the CRL reason
        if(0!=pInfo->rgDistPoint[dwIndex].ReasonFlags.cbData)
        {
            if(!FormatCRLReason(dwCertEncodingType,
                                dwFormatType,
                                dwFormatStrType,
                                pFormatStruct,
                                lpszStructType,
                                &(pInfo->rgDistPoint[dwIndex].ReasonFlags),
                                &pwszCRLReason))
                goto FormatCRLReasonError;


            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_REASON_MULTI;
            else
                ids=IDS_CRL_DIST_REASON;

            if(!FormatMessageUnicode(&pwszReasonFormat, ids ,pwszCRLReason))
                goto FormatMsgError;

        }

        //format the Issuer
       if(0!=pInfo->rgDistPoint[dwIndex].CRLIssuer.cAltEntry)
       {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;


            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                  dwFormatType,
                                  dwFormatStrType,
                                  pFormatStruct,
                                  ids,
                                  FALSE,
                                  &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                  NULL,
                                  &cbNeeded))
                goto FormatAltNameError;

           pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszCRLIssuer)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                 pwszCRLIssuer,
                                 &cbNeeded))
                goto FormatAltNameError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_ISSUER_MULTI;
            else
                ids=IDS_CRL_DIST_ISSUER;

            if(!FormatMessageUnicode(&pwszIssuerFormat,ids,pwszCRLIssuer))
                goto FormatMsgError;
       }

       cbNeeded=0;

       if(pwszNameFormat)
           cbNeeded+=wcslen(pwszNameFormat);

       if(pwszReasonFormat)
           cbNeeded+=wcslen(pwszReasonFormat);

       if(pwszIssuerFormat)
           cbNeeded+=wcslen(pwszIssuerFormat);

       if(0!=cbNeeded)
       {
            //add ", " between each element for single line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }

            //strcat all the information, including the COMMA
            cbNeeded += wcslen(wszCOMMA)*2;

            pwszEntryFormat=(LPWSTR)malloc(sizeof(WCHAR) * (cbNeeded+1));
            if(NULL==pwszEntryFormat)
                goto MemoryError;

            *pwszEntryFormat=L'\0';

            //strcat all three fields one at a time
            if(pwszNameFormat)
                wcscat(pwszEntryFormat, pwszNameFormat);

            if(pwszReasonFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszReasonFormat);
            }

            if(pwszIssuerFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszIssuerFormat);
            }

            //format the entry
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                //
                // DSIE: Load appropriate format string.
                //
                if (0 == strcmp(lpszStructType, szOID_FRESHEST_CRL))
                    ids=IDS_FRESHEST_CRL_MULTI;
                else if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
                    ids=IDS_CRL_SELF_CDP_MULTI;
                else
                    ids=IDS_CRL_DIST_ENTRY_MULTI;
            else
                if (0 == strcmp(lpszStructType, szOID_FRESHEST_CRL))
                    ids=IDS_FRESHEST_CRL;
                else if (0 == strcmp(lpszStructType, szOID_CRL_SELF_CDP))
                    ids=IDS_CRL_SELF_CDP;
                else
                    ids=IDS_CRL_DIST_ENTRY;

            if(!FormatMessageUnicode(&pwszEntryTagFormat, ids, dwIndex+1,
                pwszEntryFormat))
                goto FormatMsgError;

            //strcat the entry
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszEntryTagFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszEntryTagFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszEntryTagFormat);

            //free memory
            free(pwszEntryFormat);
            pwszEntryFormat=NULL;

            LocalFree(pwszEntryTagFormat);
            pwszEntryTagFormat=NULL;
       }

       //free memory
       if(pwszPointName)
       {
           LocalFree((HLOCAL)pwszPointName);
           pwszPointName=NULL;
       }

       if(pwszCRLReason)
       {
           LocalFree((HLOCAL)(pwszCRLReason));
           pwszCRLReason=NULL;
       }

       if(pwszCRLIssuer)
       {
           free(pwszCRLIssuer);
           pwszCRLIssuer=NULL;
       }

       if(pwszNameFormat)
       {
            LocalFree((HLOCAL)pwszNameFormat);
            pwszNameFormat=NULL;
       }

       if(pwszReasonFormat)
       {
            LocalFree((HLOCAL)pwszReasonFormat);
            pwszReasonFormat=NULL;
       }

       if(pwszIssuerFormat)
       {
            LocalFree((HLOCAL)pwszIssuerFormat);
            pwszIssuerFormat=NULL;
       }
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszEntryFormat)
      free(pwszEntryFormat);

    if(pwszEntryTagFormat)
      LocalFree((HLOCAL)pwszEntryTagFormat);

    //free memory
    if(pwszPointName)
       LocalFree((HLOCAL)pwszPointName);

    if(pwszCRLReason)
       LocalFree((HLOCAL)(pwszCRLReason));

    if(pwszCRLIssuer)
       free(pwszCRLIssuer);

    if(pwszNameFormat)
        LocalFree((HLOCAL)pwszNameFormat);

    if(pwszReasonFormat)
        LocalFree((HLOCAL)pwszReasonFormat);

    if(pwszIssuerFormat)
        LocalFree((HLOCAL)pwszIssuerFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatDistPointNameError);
TRACE_ERROR(FormatCRLReasonError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	FormatCertPolicyID:
//
//      Pre-condition: pCertPolicyID has to include the valid information.that is,
//      cCertPolicyElementId can not be 0.
//--------------------------------------------------------------------------
BOOL FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR  *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPSTR       pszFormat=NULL;
    DWORD       dwIndex=0;
    HRESULT     hr=S_OK;

    LPSTR       pwszTemp;

    *ppwszFormat=NULL;

    if(0==pCertPolicyID->cCertPolicyElementId)
        goto InvalidArg;

    pszFormat=(LPSTR)malloc(sizeof(CHAR));
    if(NULL==pszFormat)
        goto MemoryError;

    *pszFormat='\0';


    for(dwIndex=0; dwIndex<pCertPolicyID->cCertPolicyElementId; dwIndex++)
    {
        #if (0) // DSIE: Bug 27436
        pszFormat=(LPSTR)realloc(pszFormat, strlen(pszFormat)+
                strlen(pCertPolicyID->rgpszCertPolicyElementId[dwIndex])+strlen(strCOMMA)+1);
        if(NULL==pszFormat)
            goto MemoryError;
        #endif

        pwszTemp=(LPSTR)realloc(pszFormat, strlen(pszFormat)+
                strlen(pCertPolicyID->rgpszCertPolicyElementId[dwIndex])+strlen(strCOMMA)+1);
        if(NULL==pwszTemp)
            goto MemoryError;
        pszFormat = pwszTemp;

        strcat(pszFormat,pCertPolicyID->rgpszCertPolicyElementId[dwIndex]);

        strcat(pszFormat, strCOMMA);
    }

    //get rid of the last COMMA
    *(pszFormat+strlen(pszFormat)-strlen(strCOMMA))='\0';

    //convert to WCHAR
    if(S_OK!=(hr=SZtoWSZ(pszFormat, ppwszFormat)))
        goto SZtoWSZError;

	fResult=TRUE;

CommonReturn:

    if(pszFormat)
        free(pszFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
SET_ERROR_VAR(SZtoWSZError,hr);
}

//--------------------------------------------------------------------------
//
//	 FormatKeyRestriction:   X509_KEY_USAGE_RESTRICTION
//                           szOID_KEY_USAGE_RESTRICTION
//
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							    pwszFormat=NULL;
    LPWSTR                              pwsz=NULL;
	PCERT_KEY_USAGE_RESTRICTION_INFO	pInfo=NULL;
    LPWSTR                              pwszPolicy=NULL;
    LPWSTR                              pwszPolicyFormat=NULL;
    LPWSTR                              pwszKeyUsage=NULL;
    LPWSTR                              pwszKeyUsageFormat=NULL;

	DWORD							    cbNeeded=0;
    DWORD                               dwIndex=0;
	BOOL							    fResult=FALSE;
    UINT                                ids=0;

    LPWSTR                              pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE_RESTRICTION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cCertPolicyId; dwIndex++)
    {

       if(0!=((pInfo->rgCertPolicyId)[dwIndex].cCertPolicyElementId))
       {
            //concatecate the comma if not the 1st item
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!FormatCertPolicyID(&((pInfo->rgCertPolicyId)[dwIndex]), &pwszPolicy))
                goto FormatCertPolicyIDError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_ID_MULTI;
            else
                ids=IDS_KEY_RES_ID;

            if(!FormatMessageUnicode(&pwszPolicyFormat, ids,dwIndex+1,pwszPolicy))
                goto FormatMsgError;

            //allocate memory, including the ", "
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszPolicyFormat);

            free(pwszPolicy);
            pwszPolicy=NULL;

            LocalFree((HLOCAL)pwszPolicyFormat);
            pwszPolicyFormat=NULL;
       }
    }

    //format the RestrictedKeyUsage
    if(0!=pInfo->RestrictedKeyUsage.cbData)
    {
       //concatecate the comma if not the 1st item
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;

      //decide between single line and mulitple line format
      if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_USAGE_MULTI;
       else
                ids=IDS_KEY_RES_USAGE;

        //format the element string
        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif
        
        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyUsageFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszPolicy)
        free(pwszPolicy);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatCertPolicyIDError);
TRACE_ERROR(FormatKeyUsageBLOBError);

}

//-----------------------------------------------------------------------
//
//	 FormatFileTime
//
//   Pre-condition: pFileTime points to valid data
//
//------------------------------------------------------------------------
BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR *ppwszFormat)
{
	SYSTEMTIME		SysTime;
	FILETIME		LocalFileTime;
	BOOL			fResult=FALSE;
    WCHAR           wszDay[DAY_SIZE];
    WCHAR           wszMonth[MONTH_SIZE];
    WCHAR           wszAMPM[AMPM_SIZE];
    UINT            idsDay=0;
    UINT            idsMonth=0;
    UINT            idsAMPM=0;

    *ppwszFormat=NULL;

	//now we format FileTime to SysTime as default.
	if(FileTimeToLocalFileTime(pFileTime, &LocalFileTime) && 
       FileTimeToSystemTime(&LocalFileTime,&SysTime))
	{
         if (SysTime.wHour < 12)
        {
            if (SysTime.wHour == 0)
            {
                SysTime.wHour = 12;
            }

            idsAMPM = IDS_AM;
        }
        else
        {
            if (SysTime.wHour > 12)
            {
                SysTime.wHour -= 12;
            }

            idsAMPM = IDS_PM;
        }

        //Sunday is 0
        idsDay=IDS_SUNDAY+SysTime.wDayOfWeek;

        //January is 1
        idsMonth=IDS_JAN+SysTime.wMonth-1;

        //load the string
        if(!LoadStringU(hFrmtFuncInst,idsDay, wszDay, sizeof(wszDay)/sizeof(wszDay[0])))
            goto LoadStringError;

        if(!LoadStringU(hFrmtFuncInst,idsMonth, wszMonth,
                    sizeof(wszMonth)/sizeof(wszMonth[0])))
            goto LoadStringError;

        if(!LoadStringU(hFrmtFuncInst,idsAMPM, wszAMPM,
                    sizeof(wszAMPM)/sizeof(wszAMPM[0])))
            goto LoadStringError;

        //"%s, %s %u, %u %u:%u:%u %s"
		if(!FormatMessageUnicode(ppwszFormat, IDS_FILE_TIME,
			 wszDay, wszMonth, SysTime.wDay, SysTime.wYear,
   			 SysTime.wHour, SysTime.wMinute, SysTime.wSecond, wszAMPM))
             goto FormatMsgError;
	}
	else
	{
	  	//if failed, pFileTime is more than 0x8000000000000000.
		// all we can do is to print out the integer
        //"HighDateTime: %d LowDateTime: %d"
        if(!FormatMessageUnicode(ppwszFormat, IDS_FILE_TIME_DWORD,
			pFileTime->dwHighDateTime, pFileTime->dwLowDateTime))
            goto FormatMsgError;
	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMsgError);
TRACE_ERROR(LoadStringError);

}




//--------------------------------------------------------------------------
//
//	 FormatKeyAttributes:   X509_KEY_ATTRIBUTES
//                          szOID_KEY_ATTRIBUTES
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszKeyID=NULL;

    LPWSTR                          pwszKeyUsageFormat=NULL;
    LPWSTR                          pwszKeyUsage=NULL;

    LPWSTR                          pwszKeyBeforeFormat=NULL;
    LPWSTR                          pwszKeyBefore=NULL;

    LPWSTR                          pwszKeyAfterFormat=NULL;
    LPWSTR                          pwszKeyAfter=NULL;
	PCERT_KEY_ATTRIBUTES_INFO   	pInfo=NULL;


	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_ATTRIBUTES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';


    if(0!=pInfo->KeyId.cbData)
    {
        cbNeeded=0;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        NULL,
	                    &cbNeeded))
             goto FormatBytesToHexError;

        pwszKeyID=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyID)
               goto MemoryError;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        pwszKeyID,
	                    &cbNeeded))
              goto FormatBytesToHexError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_ID_MULTI;
        else
            ids=IDS_KEY_ATTR_ID;

        if(!FormatMessageUnicode(&pwszKeyIDFormat, ids, pwszKeyID))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyIDFormat);
    }


    //check the no data situation
    if(0!=pInfo->IntendedKeyUsage.cbData)
    {
        //strcat a ", " symbol for signle line format
       if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
        {
            if(0!=wcslen(pwsz))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_USAGE_MULTI;
        else
            ids=IDS_KEY_ATTR_USAGE;

        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        #if (0) // DSIE: Bug 27436
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        wcscat(pwsz, pwszKeyUsageFormat);

    }

    if(NULL!=pInfo->pPrivateKeyUsagePeriod)
    {
        //format only if there is some information
        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwLowDateTime)))
        {
            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotBefore),
                            &pwszKeyBefore))
                goto FormatFileTimeError;


            //format the element string

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_BEFORE_MULTI;
            else
                ids=IDS_KEY_ATTR_BEFORE;

            if(!FormatMessageUnicode(&pwszKeyBeforeFormat, ids,
                    pwszKeyBefore))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR)*(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyBeforeFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR)*(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyBeforeFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszKeyBeforeFormat);
        }

        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwLowDateTime)))
        {

            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotAfter),
                            &pwszKeyAfter))
                goto FormatFileTimeError;

            //format the element string

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_AFTER_MULTI;
            else
                ids=IDS_KEY_ATTR_AFTER;

            if(!FormatMessageUnicode(&pwszKeyAfterFormat, ids,
                    pwszKeyAfter))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyAfterFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyAfterFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszKeyAfterFormat);

        }

    }

    if(0==wcslen(pwsz))
    {
       pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
       if(NULL==pwszFormat)
           goto MemoryError;

       if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat,NO_INFO_SIZE))
           goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszKeyID)
        free(pwszKeyID);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyBeforeFormat)
        LocalFree((HLOCAL)pwszKeyBeforeFormat);

    if(pwszKeyBefore)
        LocalFree((HLOCAL)pwszKeyBefore);

    if(pwszKeyAfterFormat)
        LocalFree((HLOCAL)pwszKeyAfterFormat);

    if(pwszKeyAfter)
        LocalFree((HLOCAL)pwszKeyAfter);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
TRACE_ERROR(FormatFileTimeError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthortiyInfoAccess:   X509_AUTHORITY_INFO_ACCESS
//                                szOID_AUTHORITY_INFO_ACCESS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    BOOL                            fMethodAllocated=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownAccess[UNKNOWN_ACCESS_METHOD_SIZE];
    PCCRYPT_OID_INFO                pOIDInfo=NULL;
    CERT_ALT_NAME_INFO              CertAltNameInfo;


	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszMethod=NULL;
    LPWSTR                          pwszAltName=NULL;
    LPWSTR                          pwszEntryFormat=NULL;
	PCERT_AUTHORITY_INFO_ACCESS	    pInfo=NULL;

    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_INFO_ACCESS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


    if(0==pInfo->cAccDescr)
    {
        //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //load the string "Unknown Access Method:
	    if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_ACCESS_METHOD, wszUnknownAccess,
            sizeof(wszUnknownAccess)/sizeof(wszUnknownAccess[0])))
		    goto LoadStringError;

        for(dwIndex=0; dwIndex < pInfo->cAccDescr; dwIndex++)
        {
            fMethodAllocated=FALSE;

            //need a ", " between each element for single line format
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) )
                    wcscat(pwsz, wszCOMMA);
            }

            //get the name of the access method
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgAccDescr[dwIndex].pszAccessMethod),
									  CRYPT_EXT_OR_ATTR_OID_GROUP_ID);

                //get the access method OID
                if(pOIDInfo)
			    {
				    //allocate memory, including the NULL terminator
				    pwszMethod=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
				    					sizeof(WCHAR));
				    if(NULL==pwszMethod)
					    goto MemoryError;

                    fMethodAllocated=TRUE;

				    wcscpy(pwszMethod,pOIDInfo->pwszName);

			    }else
                    pwszMethod=wszUnknownAccess;
            }

            memset(&CertAltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
            CertAltNameInfo.cAltEntry=1;
            CertAltNameInfo.rgAltEntry=&(pInfo->rgAccDescr[dwIndex].AccessLocation);

            //need to tell if it is for multi line format.  We need two \t\t
            //in front of each alt name entry
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;

            //get the alternative name entry
            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

           pwszAltName=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszAltName)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 pwszAltName,
                                 &cbNeeded))
                goto FormatAltNameError;

            //format the entry
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_INFO_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_INFO;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids,
                    dwIndex+1, pwszMethod, pInfo->rgAccDescr[dwIndex].pszAccessMethod,
                    pwszAltName))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids, dwIndex+1, pwszAltName))
                    goto FormatMsgError;

            }

            //reallocat the memory.  Leave space for szComma
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszEntryFormat)+
                                        wcslen(wszCOMMA)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszEntryFormat)+
                                        wcslen(wszCOMMA)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, pwszEntryFormat);

            //free memory
            LocalFree((HLOCAL)pwszEntryFormat);
            pwszEntryFormat=NULL;

            free(pwszAltName);
            pwszAltName=NULL;

            if(TRUE==fMethodAllocated)
                free(pwszMethod);

            pwszMethod=NULL;

        }

        //convert to WCHAR
        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszEntryFormat)
         LocalFree((HLOCAL)pwszEntryFormat);

    if(pwszAltName)
        free(pwszAltName);

    if(fMethodAllocated)
    {
        if(pwszMethod)
             free(pwszMethod);
    }

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatAltNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatKeyUsageBLOB
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat)
{
	LPWSTR							pwszFinal=NULL;
   	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszKeyUsage[KEY_USAGE_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //format the 1st byte
        if(pInfo->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DIG_SIG, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_NON_REPUDIATION, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }


        if(pInfo->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DATA_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_AGREEMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CERT_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

         if(pInfo->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_OFFLINE_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

        if(pInfo->pbData[0] & CERT_ENCIPHER_ONLY_KEY_USAGE  )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_ENCIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        //deal with the second byte
        if(pInfo->cbData>=2)
        {

            if(pInfo->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE  )
            {
                if(!LoadStringU(hFrmtFuncInst, IDS_DECIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		            goto LoadStringError;

                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
                if(NULL==pwsz)
                    goto MemoryError;
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
                if(NULL==pwszTemp)
                    goto MemoryError;
                pwsz = pwszTemp;

                wcscat(pwsz, wszKeyUsage);
                wcscat(pwsz, wszCOMMA);
            }
        }

        if(0==wcslen(pwsz))
        {
            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (UNKNOWN_KEY_USAGE_SIZE+1));
		    // if(NULL==pwszFormat) DSIE: Bug 27348
		    if(NULL==pwsz)
				goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (UNKNOWN_KEY_USAGE_SIZE+1));
		    if(NULL==pwszTemp)
				goto MemoryError;
            pwsz = pwszTemp;

            if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_KEY_USAGE, pwsz,
                UNKNOWN_KEY_USAGE_SIZE))
		            goto LoadStringError;
        }
        else
        {
            //get rid of the last comma
            *(pwsz+wcslen(pwsz)-wcslen(wszCOMMA))=L'\0';
        }

        //get the Hex dump of the Key Usage
       cbNeeded=0;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszByte=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszByte)
            goto MemoryError;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszByte,
	                    &cbNeeded))
            goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(&pwszFormat, IDS_BIT_BLOB, pwsz,
        pwszByte))
        goto FormatMsgError;

	//
	// DSIE: Fix bug 91502, 256396.
	//
    pwszFinal=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormat)+1+wcslen(wszCRLF)));
    if(NULL==pwszFinal)
        goto MemoryError;
	wcscpy(pwszFinal, pwszFormat);
    if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        wcscat(pwszFinal, wszCRLF);

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFinal)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFinal, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

	if (pwszFinal)
		free(pwszFinal);

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

    if(pwsz)
        free(pwsz);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}
//--------------------------------------------------------------------------
//
//	 FormatKeyUsage:  X509_KEY_USAGE
//                    szOID_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCRYPT_BIT_BLOB	                pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

   //load the string "Info Not Available"
	if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		 goto LoadStringError;

    //check the no data situation
    if(0==pInfo->cbData)
        pwszFormat=wszNoInfo;
    else
    {
        if(1==pInfo->cbData)
        {
           if(0==pInfo->pbData[0])
                pwszFormat=wszNoInfo;
        }
        else
        {
            if(2==pInfo->cbData)
            {
                if((0==pInfo->pbData[0])&&(0==pInfo->pbData[1]))
                    pwszFormat=wszNoInfo;
            }
        }
    }

    if(NULL==pwszFormat)
    {
        fResult=FormatKeyUsageBLOB(dwCertEncodingType,
                                   dwFormatType,
                                   dwFormatStrType,
                                   pFormatStruct,
                                   lpszStructType,
                                   pInfo,
                                   pbFormat,
                                   pcbFormat);

        if(FALSE==fResult)
            goto FormatKeyUsageBLOBError;
    }
    else
    {
       	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	    //length only calculation
	    if(NULL==pbFormat)
	    {
		    *pcbFormat=cbNeeded;
		    fResult=TRUE;
		    goto CommonReturn;
    	}


	    if((*pcbFormat)<cbNeeded)
        {
            *pcbFormat=cbNeeded;
		    goto MoreDataError;
        }

	    //copy the data
	    memcpy(pbFormat, pwszFormat, cbNeeded);

	    //copy the size
	    *pcbFormat=cbNeeded;

	    fResult=TRUE;
    }


CommonReturn:
   	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
}


//--------------------------------------------------------------------------
//
//	 FormatSMIMECapabilities:   PKCS_SMIME_CAPABILITIES
//                              szOID_RSA_SMIMECapabilities
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszElementFormat=NULL;
    LPWSTR                          pwszParam=NULL;


	WCHAR							wszNoInfo[NO_INFO_SIZE];
    BOOL                            fParamAllocated=FALSE;
	PCRYPT_SMIME_CAPABILITIES	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    DWORD                           dwIndex =0;
    UINT                            idsSub=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,PKCS_SMIME_CAPABILITIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//check to see if information if available
    if(0==pInfo->cCapability)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        for(dwIndex=0; dwIndex < pInfo->cCapability; dwIndex++)
        {
            fParamAllocated=FALSE;

           //strcat ", " if single line.  No need for multi-line
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                 wcscat(pwsz, wszCOMMA);
            }


            if(0!=(pInfo->rgCapability)[dwIndex].Parameters.cbData)
            {
                cbNeeded=0;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        NULL,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                pwszParam=(LPWSTR)malloc(cbNeeded);
                if(NULL==pwszParam)
                    goto MemoryError;

                fParamAllocated=TRUE;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        pwszParam,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId,
                        pwszParam))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId))
                    goto FormatMsgError;
            }

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszElementFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszElementFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the element
            wcscat(pwsz, pwszElementFormat);

            //free the memory
            LocalFree((HLOCAL)pwszElementFormat);
            pwszElementFormat=NULL;

            if(fParamAllocated)
                free(pwszParam);

            pwszParam=NULL;

        }

        pwszFormat=pwsz;

    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszElementFormat)
        LocalFree((HLOCAL)pwszElementFormat);

    if(fParamAllocated)
    {
        if(pwszParam)
            free(pwszParam);
    }


	if(pInfo)
		free(pInfo);

    if(pwsz)
        free(pwsz);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
}

//--------------------------------------------------------------------------
//
//	 FormatFinancialCriteria: SPC_FINANCIAL_CRITERIA_OBJID
//                            SPC_FINANCIAL_CRITERIA_STRUCT
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszYesNo[YES_NO_SIZE];
	WCHAR							wszAvailable[AVAIL_SIZE];
	PSPC_FINANCIAL_CRITERIA     	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            idsInfo=0;


	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_FINANCIAL_CRITERIA_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for financial info
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        if(TRUE==pInfo->fMeetsCriteria)
            idsInfo=IDS_YES;
        else
            idsInfo=IDS_NO;

        //load the string for "yes" or "no"
        if(!LoadStringU(hFrmtFuncInst,idsInfo, wszYesNo, sizeof(wszYesNo)/sizeof(wszYesNo[0])))
		        goto LoadStringError;

        //mark the avaiblility of the financial info
        idsInfo=IDS_AVAILABLE;
    }
    else
        idsInfo=IDS_NOT_AVAILABLE;

	if(!LoadStringU(hFrmtFuncInst,idsInfo, wszAvailable,
        sizeof(wszAvailable)/sizeof(wszAvailable[0])))
		goto LoadStringError;

    //format the output string
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable, wszYesNo))
            goto FormatMsgError;
    }
    else
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable))
            goto FormatMsgError;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatNextUpdateLocation: szOID_NEXT_UPDATE_LOCATION
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	BOOL							fResult=FALSE;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_NEXT_UPDATE_LOCATION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the alternative name
    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,      //no prefix
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatSubjectKeyID: szOID_SUBJECT_KEY_IDENTIFIER
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCRYPT_DATA_BLOB	            pInfo=NULL;
	BOOL							fResult=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    DWORD                           cbNeeded=0;

	// DSIE: Fix bug 91502
	LPWSTR							pwsz=NULL;
	LPWSTR							pwszFormat=NULL;
  
	LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;

	LPWSTR							pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_SUBJECT_KEY_IDENTIFIER,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the key subject ID
    //handle NULL data case
    if(0==pInfo->cbData)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

		pwszFormat = wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        cbNeeded=0;

        if(!FormatBytesToHex(dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        NULL,
                        NULL,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
                        &cbNeeded))
            goto KeyIDBytesToHexError;

        pwszKeyID=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyID)
            goto MemoryError;

        if(!FormatBytesToHex(dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        NULL,
                        NULL,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszKeyID,
                        &cbNeeded))
            goto KeyIDBytesToHexError;

        if(!FormatMessageUnicode(&pwszKeyIDFormat,IDS_UNICODE_STRING,pwszKeyID))
            goto FormatMsgError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
	        pwszTemp=(LPWSTR)realloc(pwsz, 
		        sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyIDFormat)+wcslen(wszCRLF)+1));
		else
	        pwszTemp=(LPWSTR)realloc(pwsz, 
		        sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwsz = pwszTemp;

        //strcat the KeyID
        wcscat(pwsz,pwszKeyIDFormat);

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            wcscat(pwsz, wszCRLF);

        pwszFormat=pwsz;
	}

    cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
	    *pcbFormat=cbNeeded;
	    fResult=TRUE;
	    goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
	    goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
//TRACE_ERROR(FormatBytestToHexError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID: szOID_AUTHORITY_KEY_IDENTIFIER
//                         X509_AUTHORITY_KEY_ID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID_INFO	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->CertIssuer.cbData)
        &&(0==pInfo->CertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

#if (0) //DSIE: Potential AV. Need two more chars, \r\n, for multi-lines.
            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
#else
			if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
				pwszTemp=(LPWSTR)realloc(pwsz, 
					sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+wcslen(wszCRLF)+1));
			else
				pwszTemp=(LPWSTR)realloc(pwsz, 
					sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
#endif
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the KeyID
            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //format certIssuer
        if(0!=pInfo->CertIssuer.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,             //memory allocation
				pInfo->CertIssuer.pbData,
				pInfo->CertIssuer.cbData,
				(void **)&pwszCertIssuer,
				NULL))
                goto GetCertNameError;

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AUTH_CERT_ISSUER_MULTI;
            else
                ids=IDS_AUTH_CERT_ISSUER;

            if(!FormatMessageUnicode(&pwszCertIssuerFormat, ids,pwszCertIssuer))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertIssuerFormat);

            //no need for \n for CERT_NAME
        }

        //format CertSerialNumber
        if(0!=pInfo->CertSerialNumber.cbData)
        {

            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->CertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->CertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->CertSerialNumber.pbData+
                        pInfo->CertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
             goto CertNumberBytesToHexError;


            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);

        }

        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(GetCertNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID2: szOID_AUTHORITY_KEY_IDENTIFIER2
//                          X509_AUTHORITY_KEY_ID2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            ids=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->AuthorityCertIssuer.cAltEntry)
        &&(0==pInfo->AuthorityCertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+
                                wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+
                                wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);

        }

        //format certIssuer
        if(0!=pInfo->AuthorityCertIssuer.cAltEntry)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }


            cbNeeded=0;

            //need a \t before each entry of the alternative name
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_ONE_TAB;
            else
                ids=0;

            //format the alternative name
            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            NULL,
                            &cbNeeded))
                goto FormatAltNameError;

            pwszCertIssuer=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertIssuer)
                goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            pwszCertIssuer,
                            &cbNeeded))
                goto FormatAltNameError;

            //format the element.  Has to distinguish between the multi line
            //and single line for alternative name:
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER_MULTI,pwszCertIssuer))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER,pwszCertIssuer))
                    goto FormatMsgError;
            }

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                        +wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                        +wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertIssuerFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //format CertSerialNumber
        if(0!=pInfo->AuthorityCertSerialNumber.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->AuthorityCertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->AuthorityCertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->AuthorityCertSerialNumber.pbData+
                        pInfo->AuthorityCertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                    +wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                    +wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
        }

        //convert the WCHAR version
        pwszFormat=pwsz;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(FormatAltNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints:   szOID_BASIC_CONSTRAINTS
//                             X509_BASIC_CONSTRAINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE * 2];
	WCHAR							wszNone[NONE_SIZE];
    LPWSTR                          pwszFormatSub=NULL;
    LPWSTR                          pwszFormatWhole=NULL;
    LPWSTR                          pwszSubtreeName=NULL;
    LPWSTR                          pwszSubtreeFormat=NULL;
    DWORD                           dwIndex=0;
	PCERT_BASIC_CONSTRAINTS_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;

	LPWSTR                          pwszTemp;

	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


	//load the string for the subjectType
    //init to "\0"
    *wszSubject=L'\0';

    if(0!=pInfo->SubjectType.cbData)
    {
        //get the subjectType info
        if ((pInfo->SubjectType.pbData[0]) & CERT_CA_SUBJECT_FLAG)
        {
       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_CA, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		        goto LoadStringError;
        }

        if ((pInfo->SubjectType.pbData[0]) & CERT_END_ENTITY_SUBJECT_FLAG)
        {
            if(wcslen(wszSubject)!=0)
            {
                 wcscat(wszSubject, wszCOMMA);
            }

       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_EE, wszSubject+wcslen(wszSubject),
                        SUBJECT_SIZE))
		          goto LoadStringError;
       }

        //load string "NONE"
        if(0==wcslen(wszSubject))
        {
            if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		    goto LoadStringError;
        }

    }

    //path contraints
    if (pInfo->fPathLenConstraint)
	{
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}

    pwszFormatWhole=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormatSub)+1));
    if(!pwszFormatWhole)
        goto MemoryError;

    wcscpy(pwszFormatWhole, pwszFormatSub);

    //now, format SubTreeContraints one at a time

   for(dwIndex=0; dwIndex<pInfo->cSubtreesConstraint; dwIndex++)
    {
        //get WCHAR version of the name
        if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,                 //memory allocation
				pInfo->rgSubtreesConstraint[dwIndex].pbData,
				pInfo->rgSubtreesConstraint[dwIndex].cbData,
				(void **)&pwszSubtreeName,
				NULL))
                goto GetCertNameError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_SUBTREE_CONSTRAINT_MULTI;
        else
            idsSub=IDS_SUBTREE_CONSTRAINT;

        if(!FormatMessageUnicode(&pwszSubtreeFormat,idsSub,
								dwIndex+1, pwszSubtreeName))
			goto FormatNameError;

        #if (0) // DSIE: Bug 27436
        pwszFormatWhole=(LPWSTR)realloc(pwszFormatWhole, 
            sizeof(WCHAR) * (wcslen(pwszFormatWhole)+1+wcslen(pwszSubtreeFormat)));
        if(NULL == pwszFormatWhole)
            goto MemoryError;
        #endif

        pwszTemp=(LPWSTR)realloc(pwszFormatWhole, 
            sizeof(WCHAR) * (wcslen(pwszFormatWhole)+1+wcslen(pwszSubtreeFormat)));
        if(NULL == pwszTemp)
            goto MemoryError;
        pwszFormatWhole = pwszTemp;

        wcscat(pwszFormatWhole,pwszSubtreeFormat);

        LocalFree((HLOCAL)pwszSubtreeFormat);
        pwszSubtreeFormat=NULL;

        free(pwszSubtreeName);
        pwszSubtreeName=NULL;

    }

    //format to the wide char version
    pwszFormat=pwszFormatWhole;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszFormatSub)
        LocalFree((HLOCAL)pwszFormatSub);

    if(pwszSubtreeFormat)
        LocalFree((HLOCAL)pwszSubtreeFormat);

    if(pwszFormatWhole)
        free(pwszFormatWhole);

    if(pwszSubtreeName)
        free(pwszSubtreeName);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);
}


//--------------------------------------------------------------------------
//
//	 FormatCRLReasonCode:szOID_CRL_REASON_CODE
//                         X509_CRL_REASON_CODE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	WCHAR							wszReason[CRL_REASON_SIZE];
    LPWSTR                          pwszFormat=NULL;
	int								*pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsCRLReason=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CRL_REASON_CODE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//decide which ids to use
	switch(*pInfo)
	{
		case CRL_REASON_UNSPECIFIED:
				idsCRLReason=IDS_UNSPECIFIED;
			break;
		case CRL_REASON_KEY_COMPROMISE:
				idsCRLReason=IDS_KEY_COMPROMISE;
			break;
		case CRL_REASON_CA_COMPROMISE:
				idsCRLReason=IDS_CA_COMPROMISE;
			break;
		case CRL_REASON_AFFILIATION_CHANGED:
				idsCRLReason=IDS_AFFILIATION_CHANGED;
			break;
		case CRL_REASON_SUPERSEDED:
				idsCRLReason=IDS_SUPERSEDED;
			break;
		case CRL_REASON_CESSATION_OF_OPERATION:
				idsCRLReason=IDS_CESSATION_OF_OPERATION;
			break;
		case CRL_REASON_CERTIFICATE_HOLD:
				idsCRLReason=IDS_CERTIFICATE_HOLD;
			break;
		case CRL_REASON_REMOVE_FROM_CRL:
				idsCRLReason=IDS_REMOVE_FROM_CRL;
			break;
		default:
				idsCRLReason=IDS_UNKNOWN_CRL_REASON;
			break;
	}

	//load string
	if(!LoadStringU(hFrmtFuncInst,idsCRLReason, wszReason, sizeof(wszReason)/sizeof(wszReason[0])))
		goto LoadStringError;

    //format
    if(!FormatMessageUnicode(&pwszFormat, IDS_CRL_REASON, wszReason, *pInfo))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatEnhancedKeyUsage: szOID_ENHANCED_KEY_USAGE
//							 X509_ENHANCED_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
    BOOL                            fOIDNameAllocated=FALSE;
	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownOID[UNKNOWN_KEY_USAGE_SIZE];
	PCCRYPT_OID_INFO                pOIDInfo=NULL;

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwszOIDName=NULL;
	PCERT_ENHKEY_USAGE				pInfo=NULL;
	LPWSTR							pwsz=NULL;
    LPWSTR                          pwszOIDFormat=NULL;

	DWORD							dwIndex=0;
    DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ENHANCED_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load string NONE if there is no value available
	if(0==pInfo->cUsageIdentifier)
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
			goto LoadStringError;

	    pwszFormat=wszNoInfo;
	}
	else
	{
        //load the string for "unknown key usage"
        if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_KEY_USAGE, wszUnknownOID,
            sizeof(wszUnknownOID)/sizeof(wszUnknownOID[0])))
			goto LoadStringError;

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

		//build the comma/\n seperated string
		for(dwIndex=0; dwIndex<pInfo->cUsageIdentifier; dwIndex++)
        {
            fOIDNameAllocated=FALSE;

           	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgpszUsageIdentifier[dwIndex]),
									  CRYPT_ENHKEY_USAGE_OID_GROUP_ID);

            if(pOIDInfo)
			{
				//allocate memory, including the NULL terminator
				pwszOIDName=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
									sizeof(WCHAR));
				if(NULL==pwszOIDName)
					goto MemoryError;

                fOIDNameAllocated=TRUE;

				wcscpy(pwszOIDName,pOIDInfo->pwszName);

			}else
                pwszOIDName=wszUnknownOID;

            if(!FormatMessageUnicode(&pwszOIDFormat, IDS_ENHANCED_KEY_USAGE, pwszOIDName,
                          (pInfo->rgpszUsageIdentifier)[dwIndex]))
                   goto FormatMsgError;

            #if (0) // DSIE: Bug 27436
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+
                            wcslen(wszCOMMA)+wcslen(pwszOIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            pwszTemp=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+
                            wcslen(wszCOMMA)+wcslen(pwszOIDFormat)+1));
            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the OID
            wcscat(pwsz, pwszOIDFormat);

            //strcat the , or '\n'
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszCRLF);
            else
            {
                if(dwIndex!=(pInfo->cUsageIdentifier-1))
                    wcscat(pwsz, wszCOMMA);
            }


            LocalFree((HLOCAL)pwszOIDFormat);
            pwszOIDFormat=NULL;

            if(fOIDNameAllocated)
                free(pwszOIDName);

            pwszOIDName=NULL;
        }

        pwszFormat=pwsz;

	}

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pwsz)
		free(pwsz);

    if(pwszOIDFormat)
        LocalFree((HLOCAL)pwszOIDFormat);

    if(fOIDNameAllocated)
    {
        if(pwszOIDName)
            free(pwszOIDName);
    }


	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 GetOtherName:
//
//		The idsPreFix is for multi line formatting only.
//		It should never be 0.
//--------------------------------------------------------------------------
BOOL GetOtherName(	DWORD		            dwCertEncodingType,
					DWORD		            dwFormatType,
					DWORD                   dwFormatStrType,
					void	            	*pFormatStruct,
					CERT_OTHER_NAME			*pOtherName,
					UINT					idsPreFix,
					LPWSTR					*ppwszOtherName)
{

	BOOL				fResult=FALSE;
	PCCRYPT_OID_INFO	pOIDInfo=NULL;
	DWORD				cbSize=0;
	WCHAR				wszPreFix[PREFIX_SIZE];

    LPWSTR              pwszObjId   = NULL;
	LPWSTR				pwszName=NULL;
	LPWSTR				pwszFormat=NULL;

	if(NULL == pOtherName || NULL == ppwszOtherName)
		goto InvalidArg;

	*ppwszOtherName=NULL;

	//get the OID name
	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
							pOtherName->pszObjId,
							0);

	//get the value.  If OID is szOID_NT_PRINCIPAL_NAME, we format it 
	//as the unicode string.  Otherwise, we hex dump
	if(0 == strcmp(szOID_NT_PRINCIPAL_NAME, pOtherName->pszObjId))
	{
		//turn off the multi line here
		if(!FormatAnyUnicodeStringExtension(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
				pFormatStruct,
				pOtherName->pszObjId,
				pOtherName->Value.pbData,
				pOtherName->Value.cbData,
				NULL,		
				&cbSize))
			goto FormatUnicodeError;

		pwszName=(LPWSTR)malloc(cbSize);
		if(NULL==pwszName)
			goto MemoryError;

		if(!FormatAnyUnicodeStringExtension(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
				pFormatStruct,
				pOtherName->pszObjId,
				pOtherName->Value.pbData,
				pOtherName->Value.cbData,
				pwszName,		
				&cbSize))
			goto FormatUnicodeError;
	}
	else
	{
		if(!FormatBytesToHex(dwCertEncodingType,
							dwFormatType,
							dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
							pFormatStruct,
							NULL,
							pOtherName->Value.pbData,
							pOtherName->Value.cbData,
							NULL,
							&cbSize))
			goto FormatByesToHexError;

		pwszName=(LPWSTR)malloc(cbSize);
		if(NULL==pwszName)
			goto MemoryError;

		if(!FormatBytesToHex(dwCertEncodingType,
							dwFormatType,
							dwFormatStrType & (~CRYPT_FORMAT_STR_MULTI_LINE),
							pFormatStruct,
							NULL,
							pOtherName->Value.pbData,
							pOtherName->Value.cbData,
							pwszName,
							&cbSize))
			goto FormatByesToHexError;
	}

	if(pOIDInfo)
	{
		if(!FormatMessageUnicode(&pwszFormat,
                                 IDS_OTHER_NAME_OIDNAME, 
                                 pOIDInfo->pwszName,
			                     pwszName))
			goto FormatMsgError;
	}
	else
	{
        //
        // Convert OID to Unicode.
        //
        if (!AllocateAnsiToUnicode(pOtherName->pszObjId, &pwszObjId))
            goto AnsiToUnicodeError;

		if(!FormatMessageUnicode(&pwszFormat,IDS_OTHER_NAME_OID, pwszObjId,	pwszName))
			goto FormatMsgError;
	}

	//copy the prefix and content
    if(!LoadStringU(hFrmtFuncInst,idsPreFix, wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
		    goto LoadStringError;

	*ppwszOtherName=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(wszPreFix) + wcslen(pwszFormat) + 1));
	if(NULL == *ppwszOtherName)
		goto MemoryError;

	**ppwszOtherName=L'\0';

	if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
		wcscat(*ppwszOtherName, wszPreFix);

	wcscat(*ppwszOtherName, pwszFormat);

	fResult=TRUE;
	

CommonReturn:

    if (pwszObjId)
        free(pwszObjId);

	if(pwszName)
		free(pwszName);

	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(FormatByesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(AnsiToUnicodeError);
TRACE_ERROR(FormatUnicodeError);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAltNameInfo:
//
//--------------------------------------------------------------------------
BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszAltEntryFormat=NULL;
    LPWSTR                          pwszAltEntry=NULL;

	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszAltName[ALT_NAME_SIZE];
    WCHAR                           wszPreFix[PRE_FIX_SIZE];
    BOOL                            fEntryAllocated=FALSE;
    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            idsAltEntryName=0;

    LPWSTR                          pwszTemp;
    
    //load the string "info not available"
    if(!LoadStringU(hFrmtFuncInst,IDS_NO_ALT_NAME, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		goto LoadStringError;

	//build the list of alternative name entries
    //1st, check if any information is available
    if(0==pInfo->cAltEntry)
    {
	    pwszFormat=wszNoInfo;
    }
    else
    {
        //load the pre-dix
        if(0!=idsPreFix)
        {
            if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
                goto LoadStringError;

        }

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        //NULL terminate the string
        *pwsz=L'\0';

        //build the list of alternative name entries
        for(dwIndex=0; dwIndex<pInfo->cAltEntry; dwIndex++)
        {
			// DSIE: Fix bug 128630.
			cbNeeded = 0;

            fEntryAllocated=FALSE;

             switch((pInfo->rgAltEntry)[dwIndex].dwAltNameChoice)
             {
                case CERT_ALT_NAME_OTHER_NAME:
                         if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                            idsAltEntryName=IDS_OTHER_NAME_MULTI;
                         else
                            idsAltEntryName=IDS_OTHER_NAME;

						 if(!GetOtherName(
							 dwCertEncodingType,
                             dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
							 (pInfo->rgAltEntry)[dwIndex].pOtherName,
							 (0!=idsPreFix) ? idsPreFix+1 : IDS_ONE_TAB,
							 &pwszAltEntry))
								goto GetOtherNameError;

						 fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_RFC822_NAME:
                         idsAltEntryName=IDS_RFC822_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszRfc822Name;
                    break;
                case CERT_ALT_NAME_DNS_NAME:
                         idsAltEntryName=IDS_DNS_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszDNSName;
                   break;

                case CERT_ALT_NAME_X400_ADDRESS:
                         idsAltEntryName=IDS_X400_ADDRESS;
                         pwszAltEntry=wszNoInfo;
                   break;

                case CERT_ALT_NAME_DIRECTORY_NAME:
                         if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                            idsAltEntryName=IDS_DIRECTORY_NAME_MULTI;
                         else
                            idsAltEntryName=IDS_DIRECTORY_NAME;

                        if(!CryptDllFormatNameAll(
				            dwCertEncodingType,	
				            dwFormatType,
				            dwFormatStrType,
				            pFormatStruct,
                            (0!=idsPreFix) ? idsPreFix+1 : IDS_ONE_TAB,
                            TRUE,           //memory allocation
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.pbData,
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.cbData,
				            (void **)&pwszAltEntry,
				            NULL))
                            goto GetCertNameError;

                         fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_EDI_PARTY_NAME:
                        idsAltEntryName=IDS_EDI_PARTY_NAME;
                        pwszAltEntry=wszNoInfo;
                    break;

                case CERT_ALT_NAME_URL:
                         idsAltEntryName=IDS_URL;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszURL;
                   break;

                case CERT_ALT_NAME_IP_ADDRESS:
                        idsAltEntryName=IDS_IP_ADDRESS;

#if (0) // DSIE: 7/25/2000
                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            NULL,
                                            &cbNeeded))
                            goto FormatByesToHexError;

                        pwszAltEntry=(LPWSTR)malloc(cbNeeded);
                        if(NULL==pwszAltEntry)
                            goto MemoryError;

                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatByesToHexError;
#else
                        if (!FormatIPAddress(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            idsPreFix,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatIPAddressError;

                        pwszAltEntry=(LPWSTR)malloc(cbNeeded);
                        if(NULL==pwszAltEntry)
                            goto MemoryError;

                        if (!FormatIPAddress(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            idsPreFix,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatIPAddressError;
#endif
                        fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_REGISTERED_ID:
                        idsAltEntryName=IDS_REGISTERED_ID;

                        if(S_OK!=(hr=SZtoWSZ((pInfo->rgAltEntry)[dwIndex].pszRegisteredID,
                                            &pwszAltEntry)))
                            goto SZtoWSZError;

                        fEntryAllocated=TRUE;
                    break;

                default:
                        idsAltEntryName=IDS_UNKNOWN_VALUE;
                        pwszAltEntry=wszNoInfo;
                    break;

             }

             //load the alternative name string
            if(!LoadStringU(hFrmtFuncInst,idsAltEntryName, wszAltName, sizeof(wszAltName)/sizeof(wszAltName[0])))
		            goto LoadStringError;

            //format message
            if(idsAltEntryName!=IDS_UNKNOWN_VALUE)
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY, wszAltName,
                    pwszAltEntry))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY_UNKNOWN, wszAltName,
                    (pInfo->rgAltEntry)[dwIndex].dwAltNameChoice))
                    goto FormatMsgError;
            }

            //concatenate the string, including the postfix and prefix if necessary
            if(0!=idsPreFix)
            {
                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(wszPreFix)+wcslen(pwszAltEntryFormat)+1));
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(wszPreFix)+wcslen(pwszAltEntryFormat)+1));
            }
            else
            {
                #if (0) // DSIE: Bug 27436
                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszAltEntryFormat)+1));
                #endif

                pwszTemp=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszAltEntryFormat)+1));
            }

            #if (0) // DSIE: Bug 27436
            if(NULL==pwsz)
                goto MemoryError;
            #endif

            if(NULL==pwszTemp)
                goto MemoryError;
            pwsz = pwszTemp;

            //strcat the preFix
            if(0!=idsPreFix)
                wcscat(pwsz, wszPreFix);

            //strcat the entry
            wcscat(pwsz, pwszAltEntryFormat);

            //strcat the postFix
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if((TRUE==fNewLine) || (dwIndex != (pInfo->cAltEntry-1)))
                {
                    //no need for \n if the name is directory name (CERT_NAME)
                    //in multi line format
                    if(idsAltEntryName !=IDS_DIRECTORY_NAME_MULTI)
                        wcscat(pwsz, wszCRLF);
                }

            }
            else
            {
                if(dwIndex != (pInfo->cAltEntry-1))
                    wcscat(pwsz, wszCOMMA);
            }

            LocalFree((HLOCAL)pwszAltEntryFormat);
            pwszAltEntryFormat=NULL;

            if(fEntryAllocated)
                free(pwszAltEntry);
            pwszAltEntry=NULL;
        }

        //if the last entry in the alternative name is  IDS_DIRECTORY_NAME_MULTI,
        //we need to get rid of the last \n if fNewLine is FALSE
        if(FALSE==fNewLine)
        {
            if(idsAltEntryName==IDS_DIRECTORY_NAME_MULTI)
            {
                *(pwsz+wcslen(pwsz)-wcslen(wszCRLF))=L'\0';
            }
        }

        //conver to the WCHAR format

        pwszFormat=pwsz;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszAltEntryFormat)
        LocalFree((HLOCAL)pwszAltEntryFormat);

    if(fEntryAllocated)
    {
        if(pwszAltEntry)
            free(pwszAltEntry);
    }


	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR_VAR(SZtoWSZError, hr);
TRACE_ERROR(GetCertNameError);
#if (0) //DSIE
TRACE_ERROR(FormatByesToHexError);
#else
TRACE_ERROR(FormatIPAddressError);
#endif
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetOtherNameError);
}

//--------------------------------------------------------------------------
//
//	 FormatAltName:  X509_ALTERNATE_NAME
//                   szOID_SUBJECT_ALT_NAME
//                   szOID_ISSUER_ALT_NAME
//                   szOID_SUBJECT_ALT_NAME2
//                   szOID_ISSUER_ALT_NAME2
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	BOOL							fResult=FALSE;
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ALTERNATE_NAME,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	  GetCertNameMulti
//
//    Get the multi line display of the certificate name
//--------------------------------------------------------------------------
BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix,
                         LPWSTR          *ppwsz)
{

    BOOL            fResult=FALSE;
    WCHAR           wszPreFix[PRE_FIX_SIZE];
    LPWSTR          pwszStart=NULL;
    LPWSTR          pwszEnd=NULL;
    DWORD           dwCopy=0;
    LPWSTR          pwszNameStart=NULL;
    BOOL            fDone=FALSE;
    BOOL            fInQuote=FALSE;

    LPWSTR          pwszTemp;

    //init
    *ppwsz=NULL;

    //load string for the preFix
    if(0!=idsPreFix && 1!=idsPreFix)
    {
        if(!LoadStringU(hFrmtFuncInst, idsPreFix, wszPreFix, PRE_FIX_SIZE))
            goto LoadStringError;
    }

   *ppwsz=(LPWSTR)malloc(sizeof(WCHAR));
   if(NULL==*ppwsz)
        goto MemoryError;
   **ppwsz=L'\0';

   //now, start the search for the symbol '+' or ','
   pwszStart=pwszNameStr;
   pwszEnd=pwszNameStr;

   //parse the whole string
   for(;FALSE==fDone; pwszEnd++)
   {
       //mark fInQuote to TRUE if we are inside " "
       if(L'\"'==*pwszEnd)
           fInQuote=!fInQuote;

       if((L'+'==*pwszEnd) || (L','==*pwszEnd) ||(L'\0'==*pwszEnd))
       {
           //make sure + and ; are not quoted
           if((L'+'==*pwszEnd) || (L','==*pwszEnd))
           {
                if(TRUE==fInQuote)
                    continue;

           }

           //skip the leading spaces
           for(;*pwszStart != L'\0'; pwszStart++)
           {
                if(*pwszStart != L' ')
                    break;
           }

           //we are done if NULL is reached
           if(L'\0'==*pwszStart)
               break;

           //calculate the length to copy
           dwCopy=(DWORD)(pwszEnd-pwszStart);

           if(0!=idsPreFix && 1!=idsPreFix)
           {
                #if (0) // DSIE: Bug 27436
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszPreFix)+wcslen(wszCRLF)+1)*sizeof(WCHAR));
                #endif

                pwszTemp=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszPreFix)+wcslen(wszCRLF)+1)*sizeof(WCHAR));
           }
           else
           {
                #if (0) // DSIE: Bug 27436
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszCRLF)+1)*sizeof(WCHAR));
                #endif

                pwszTemp=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszCRLF)+1)*sizeof(WCHAR));
           }

           #if (0) // DSIE: Bug 27436
           if(NULL == *ppwsz)
               goto MemoryError;
           #endif

           if(NULL == pwszTemp)
               goto MemoryError;
           *ppwsz = pwszTemp;

           //copy the prefix
           if(0!=idsPreFix && 1!=idsPreFix)
                wcscat(*ppwsz, wszPreFix);

           pwszNameStart=(*ppwsz)+wcslen(*ppwsz);

           //copy the string to *ppwsz
           memcpy(pwszNameStart, pwszStart, dwCopy*sizeof(WCHAR));
           pwszNameStart += dwCopy;

           //NULL terminate the string
           *pwszNameStart=L'\0';

           //copy the "\n"
           wcscat(*ppwsz, wszCRLF);

           //reset pwszStart and pwszEnd.
           pwszStart=pwszEnd+1;

           if(L'\0'==*pwszEnd)
               fDone=TRUE;
       }

   }


    fResult=TRUE;

CommonReturn:

     return fResult;

ErrorReturn:

     if(*ppwsz)
     {
         free(*ppwsz);
         *ppwsz=NULL;
     }

     fResult=FALSE;

     goto CommonReturn;

SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

#if (0) //DSIE: Bug 160605
    if(!LoadStringU(hFrmtFuncInst, ids, wszFormat, sizeof(wszFormat)))
#else
    if(!LoadStringU(hFrmtFuncInst, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
#endif
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
#if (1) // DSIE: Fix bug #128630
		//
		// FormatMessageU() will return 0 byte, if data to be
		// formatted is empty. CertSrv generates extensions
		// with empty data for name constraints, so we need to
		// make sure we return an empty string, "", instead of
		// an error and NULL pointer.
		//
		if (0 == GetLastError())
		{
			if (NULL == (*ppwszFormat = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR))))
				goto MemoryError;
		}
		else
#endif
			goto FormatMessageError;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
/*BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...)
{
    // get format string from resources
    CHAR		szFormat[1000];
	va_list		argList;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(!LoadStringA(hFrmtFuncInst, ids, szFormat, sizeof(szFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    if(0==FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPSTR) ppszFormat,
        0,                  // minimum size to allocate
        &argList))
        goto FormatMessageError;

    va_end(argList);

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);

} */

//--------------------------------------------------------------------------
//
//	  Decode a generic BLOB
//
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo)
{
	DWORD	cbStructInfo=0;

	//decode the object.  No copying
	if(!CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,NULL,	&cbStructInfo))
		return FALSE;

	*ppStructInfo=malloc(cbStructInfo);
	if(!(*ppStructInfo))
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	return CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,*ppStructInfo,&cbStructInfo);
}

////////////////////////////////////////////////////////
//
// Convert STR to WSTR
//
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;
	DWORD	dwError=0;

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return S_OK;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
	{
		dwError=GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	}

	//allocate memory
	*pwsz=(LPWSTR)malloc(dwSize * sizeof(WCHAR));
	if(*pwsz==NULL)
		return E_OUTOFMEMORY;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return S_OK;
	}
	else
	{
		 free(*pwsz);
         *pwsz=NULL;
		 dwError=GetLastError();
		 return HRESULT_FROM_WIN32(dwError);
	}
}

//--------------------------------------------------------------------------
//
//	  Convert dwFormatType to dwStrType
//
//--------------------------------------------------------------------------
DWORD   FormatToStr(DWORD   dwFormatType)
{
    DWORD   dwStrType=0;

    //we default to CERT_X500_NAME_STR
    if(0==dwFormatType)
    {
        return CERT_X500_NAME_STR;
    }

    if(dwFormatType &  CRYPT_FORMAT_SIMPLE)
		dwStrType |= CERT_SIMPLE_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_X509)
		dwStrType |= CERT_X500_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_OID)
		dwStrType |= CERT_OID_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_RDN_SEMICOLON)
		dwStrType |= CERT_NAME_STR_SEMICOLON_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_CRLF)
		dwStrType |= CERT_NAME_STR_CRLF_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_UNQUOTE)
		dwStrType |= CERT_NAME_STR_NO_QUOTING_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_REVERSE)
		dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

    return dwStrType;

}


//+-----------------------------------------------------------------------------
//  Post Win2k.
//------------------------------------------------------------------------------

//+-----------------------------------------------------------------------------
//
//  FormatInteger           X509_INTEGER
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatInteger (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatStrType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat,
    DWORD       ids)
{
	BOOL    fResult;
    DWORD   cbNeeded;
    int    *pInfo = NULL;
    LPWSTR  pwszFormat = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) ||
        (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_INTEGER,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Some extension name=%1!d!%2!s!
    //
    if (!FormatMessageUnicode(&pwszFormat, 
                              ids,
                              *pInfo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCrlNumber           szOID_CRL_NUMBER
//                            szOID_DELTA_CRL_INDICATOR
//                            szOID_CRL_VIRTUAL_BASE
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCrlNumber (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded = 0;
    DWORD   ids = 0;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decide between single line and mulitple line format.
    //
    if (bMultiLines)
    {
        ids = 0 == strcmp(lpszStructType, szOID_CRL_NUMBER) ? IDS_CRL_NUMBER : 
              0 == strcmp(lpszStructType, szOID_DELTA_CRL_INDICATOR) ? IDS_DELTA_CRL_INDICATOR : IDS_CRL_VIRTUAL_BASE;
    }
    else
    {
        ids = IDS_INTEGER;
    }

    //
    // Decode extension to get length.
    //
    //  %1!d!%2!s!
    //  CRL Number=%1!d!%2!s!
    //  Delta CRL Number=%1!d!%2!s!
    //  Virtual Base CRL Number=%1!d!%2!s!
    //
    if (!FormatInteger(dwCertEncodingType, 
                       dwFormatStrType,
			           pbEncoded,
                       cbEncoded, 
                       NULL,
                       &cbNeeded,
                       ids))
    {
        goto FormatIntegerError;
    }

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Decode again to get data.
    //
    if (!FormatInteger(dwCertEncodingType, 
                       dwFormatStrType,
			           pbEncoded,
                       cbEncoded, 
                       pbFormat,
                       &cbNeeded,
                       ids))
    {
        goto FormatIntegerError;
    }

    //
    // Copy size .
    //
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(FormatIntegerError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCrlNextPublish      szOID_CRL_NEXT_PUBLISH
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCrlNextPublish (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL       fResult;
    DWORD      cbNeeded     = 0;
    FILETIME * pInfo        = NULL;
    LPWSTR     pwszFileTime = NULL;
    LPWSTR     pwszFormat   = NULL;
    BOOL       bMultiLines  = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_CHOICE_OF_TIME,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Get formatted date/time.
    //
    if (!FormatFileTime(pInfo, &pwszFileTime))
    {
        goto FormatFileTimeError;
    }

    if (!FormatMessageUnicode(&pwszFormat, 
                              IDS_STRING, 
                              pwszFileTime,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszFileTime)
    {
        LocalFree((HLOCAL) pwszFileTime);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatFileTimeError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatIssuingDistPoint      X509_ISSUING_DIST_POINT
//                              szOID_ISSUING_DIST_POINT
//
//  typedef struct _CRL_ISSUING_DIST_POINT {
//      CRL_DIST_POINT_NAME     DistPointName;              // OPTIONAL
//      BOOL                    fOnlyContainsUserCerts;
//      BOOL                    fOnlyContainsCACerts;
//      CRYPT_BIT_BLOB          OnlySomeReasonFlags;        // OPTIONAL
//      BOOL                    fIndirectCRL;
//  } CRL_ISSUING_DIST_POINT, *PCRL_ISSUING_DIST_POINT;
//
//  typedef struct _CRL_DIST_POINT_NAME {
//      DWORD   dwDistPointNameChoice;
//      union {
//          CERT_ALT_NAME_INFO      FullName;       // 1
//          // Not implemented      IssuerRDN;      // 2
//      };
//  } CRL_DIST_POINT_NAME, *PCRL_DIST_POINT_NAME;
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatIssuingDistPoint (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded = 0;
    DWORD   ids = 0;
    WCHAR   wszYes[YES_NO_SIZE];
    WCHAR   wszNo[YES_NO_SIZE];
    LPWSTR  pwszTemp = NULL;
    LPWSTR  pwszFormat = NULL;
    LPWSTR  pwszPointName = NULL;
    LPWSTR  pwszNameFormat = NULL;
    LPWSTR  pwszOnlyContainsUserCerts = NULL;
    LPWSTR  pwszOnlyContainsCACerts = NULL;
    LPWSTR  pwszIndirectCRL = NULL;
    LPWSTR  pwszCRLReason=NULL;
    LPWSTR  pwszReasonFormat=NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    PCRL_ISSUING_DIST_POINT pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           lpszStructType,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Allocate format buffer.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = L'\0';

    //
    // Format distribution name, if exists.
    //
    if (CRL_DIST_POINT_NO_NAME != pInfo->DistPointName.dwDistPointNameChoice)
    {
        if (!FormatDistPointName(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 &(pInfo->DistPointName),
                                 &pwszPointName))
        {
            goto FormatDistPointNameError;
        }

        //
        // Decide between single line and mulitple line format.
        //
        ids = bMultiLines ? IDS_ONLY_SOME_CRL_DIST_NAME_MULTI: IDS_ONLY_SOME_CRL_DIST_NAME;

        if (!FormatMessageUnicode(&pwszNameFormat, ids, pwszPointName))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszNameFormat) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszNameFormat);

        LocalFree((HLOCAL) pwszPointName);
        pwszPointName = NULL;

        LocalFree((HLOCAL) pwszNameFormat);
        pwszNameFormat = NULL;
    }

    //
    // Format onlyContainsXXX fields.
    //
    if (!LoadStringU(hFrmtFuncInst, 
                     IDS_YES, 
                     wszYes,
                     sizeof(wszYes) / sizeof(wszYes[0])))
    {
        goto LoadStringError;
    }

    if (!LoadStringU(hFrmtFuncInst, 
                     IDS_NO, 
                     wszNo,
                     sizeof(wszNo) / sizeof(wszNo[0])))
    {
        goto LoadStringError;
    }

    //
    // %1!s!Only Contains User Certs=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszOnlyContainsUserCerts,
                              IDS_ONLY_CONTAINS_USER_CERTS,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fOnlyContainsUserCerts ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // %1!s!Only Contains CA Certs=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszOnlyContainsCACerts,
                              IDS_ONLY_CONTAINS_CA_CERTS,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fOnlyContainsCACerts ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // %1!s!Indirect CRL=%2!s!%3!s!
    //
    if (!FormatMessageUnicode(&pwszIndirectCRL,
                              IDS_INDIRECT_CRL,
                              bMultiLines ? wszEMPTY : wszCOMMA,
                              pInfo->fIndirectCRL ? wszYes : wszNo,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;                                  
    }

    //
    // Reallocate and concate to format buffer.
    //
    pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * 
                      (wcslen(pwszFormat) + wcslen(pwszOnlyContainsUserCerts) + 
                       wcslen(pwszOnlyContainsCACerts) + wcslen(pwszIndirectCRL) + 1));
    if (NULL == pwszTemp)
    {
        goto MemoryError;
    }

    pwszFormat = pwszTemp;
    wcscat(pwszFormat, pwszOnlyContainsUserCerts);      
    wcscat(pwszFormat, pwszOnlyContainsCACerts);      
    wcscat(pwszFormat, pwszIndirectCRL);      

    //
    // Format the CRL reason.
    //
    if (0 != pInfo->OnlySomeReasonFlags.cbData)
    {
        if (!FormatCRLReason(dwCertEncodingType,
                             dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             lpszStructType,
                             &(pInfo->OnlySomeReasonFlags),
                             &pwszCRLReason))
        {
            goto FormatCRLReasonError;
        }

        //
        // Format Decide between single line and mulitple line format.
        //
        if (!FormatMessageUnicode(&pwszReasonFormat, 
                                  bMultiLines ? IDS_CRL_DIST_REASON_MULTI : IDS_CRL_DIST_REASON,
                                  pwszCRLReason))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszReasonFormat) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszReasonFormat);

        LocalFree((HLOCAL) pwszCRLReason);
        pwszCRLReason = NULL;

        LocalFree((HLOCAL) pwszReasonFormat);
        pwszReasonFormat = NULL;
    }

    //
    // length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
    if (pwszCRLReason)
    {
        LocalFree((HLOCAL) pwszCRLReason);
    }

    if (pwszReasonFormat)
    {
        LocalFree((HLOCAL) pwszReasonFormat);
    }

    if(pwszIndirectCRL)
    {
        LocalFree((HLOCAL) pwszIndirectCRL);
    }

    if(pwszOnlyContainsCACerts)
    {
        LocalFree((HLOCAL) pwszOnlyContainsCACerts);
    }

    if(pwszOnlyContainsUserCerts)
    {
        LocalFree((HLOCAL) pwszOnlyContainsUserCerts);
    }

    if(pwszPointName)
    {
        LocalFree((HLOCAL) pwszPointName);
    }

    if (pwszNameFormat)
    {
        LocalFree((HLOCAL) pwszNameFormat);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatDistPointNameError);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatCRLReasonError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
// FormatNameConstraintsSubtree.
//
// typedef struct _CERT_GENERAL_SUBTREE {
//      CERT_ALT_NAME_ENTRY     Base;
//      DWORD                   dwMinimum;
//      BOOL                    fMaximum;
//      DWORD                   dwMaximum;
// } CERT_GENERAL_SUBTREE, *PCERT_GENERAL_SUBTREE;
//
//
// Note: Intended to be called only by FormatNameConstrants. So no validity 
//       checks are done on parameters.
//
//------------------------------------------------------------------------------

//static 
BOOL
FormatNameConstraintsSubtree (
	DWORD                   dwCertEncodingType,
	DWORD                   dwFormatType,
	DWORD                   dwFormatStrType,
	void                   *pFormatStruct,
	void                   *pbFormat,
	DWORD                  *pcbFormat,
    DWORD                   idSubtree,
    DWORD                   cSubtree,
    PCERT_GENERAL_SUBTREE   pSubtree)
{
	BOOL        fResult;
    DWORD       dwIndex;
    DWORD       cbNeeded;
    WCHAR       wszOneTab[PRE_FIX_SIZE] = wszEMPTY;
    LPWSTR      pwszType = NULL;
    LPWSTR      pwszSubtree = NULL;
    LPWSTR      pwszAltName = NULL;
    LPWSTR      pwszFormat = NULL;
    BOOL        bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
    // Any subtree?
    //
    if (0 == cSubtree)
    {
        //
        // Permitted=None%1!s!
        // Excluded=None%1!s!
        //
        if (IDS_NAME_CONSTRAINTS_PERMITTED == idSubtree)
        {
            idSubtree = IDS_NAME_CONSTRAINTS_PERMITTED_NONE;
        }
        else // if (IDS_NAME_CONSTRAINTS_EXCLUDED == idSubtree)
        {
            idSubtree = IDS_NAME_CONSTRAINTS_EXCLUDED_NONE;
        }

        if (!FormatMessageUnicode(&pwszType, 
                                  idSubtree,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;                                  
        }
    }
    else
    {
        //
        // "Permitted%1!s!"
        // "Excluded%1!s!"
        //
        if (!FormatMessageUnicode(&pwszType,
                                  idSubtree,
                                  bMultiLines ? wszCRLF : wszCOLON))
        {
            goto FormatMessageError;                                  
        }

        //
        // Load tab strings.
        //
        if (!LoadStringU(hFrmtFuncInst, 
                         IDS_ONE_TAB, 
                         wszOneTab,
                         sizeof(wszOneTab) / sizeof(wszOneTab[0])))
        {
            goto LoadStringError;
        }
    }

    //
    // Allocate format buffer.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR) * (wcslen(pwszType) + 1))))
    {
        goto MemoryError;
    }

    //
    // Initialize formatted string.
    //
    wcscpy(pwszFormat, pwszType);

    //
    // Format each subtree parts.
    //
    for (dwIndex = 0; dwIndex < cSubtree; dwIndex++, pSubtree++) 
    {
        LPWSTR pwszTemp;
        
        //
        // Maximum specified?
        //
        if (pSubtree->fMaximum)
        {
            //
            // "%1!s![%2!d!]Subtrees (%3!d!..%4!d!):%5!s!"
            //
            if (!FormatMessageUnicode(&pwszSubtree,
                    IDS_NAME_CONSTRAINTS_SUBTREE,
                    bMultiLines ? wszOneTab : dwIndex ? wszCOMMA : wszEMPTY,
                    dwIndex + 1,
                    pSubtree->dwMinimum,
                    pSubtree->dwMaximum,
                    bMultiLines ? wszCRLF : wszEMPTY))
            {
                goto FormatMessageError;                                  
            }
        }
        else
        {
            //
            // "%1!s![%2!d!]Subtrees (%3!d!...):%4!s"
            //
            if (!FormatMessageUnicode(&pwszSubtree,
                    IDS_NAME_CONSTRAINTS_SUBTREE_NO_MAX,
                    bMultiLines ? wszOneTab : dwIndex ? wszCOMMA : wszEMPTY,
                    dwIndex + 1,
                    pSubtree->dwMinimum,
                    bMultiLines ? wszCRLF : wszEMPTY))
            {
                goto FormatMessageError;                                  
            }
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + 1 + wcslen(pwszSubtree)));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszSubtree);
        LocalFree((HLOCAL) pwszSubtree);
        pwszSubtree = NULL;

        //
        // Format name.
        //
        CERT_ALT_NAME_INFO  CertAltNameInfo;

        memset(&CertAltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
        CertAltNameInfo.cAltEntry = 1;
        CertAltNameInfo.rgAltEntry = &(pSubtree->Base);

        // Need to tell if it is for multi line format.  We need two \t\t
        // in front of each alt name entry
        DWORD ids = bMultiLines ? IDS_TWO_TABS : 0;

        // Get the alternative name entry
        cbNeeded = 0;
        
		if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               ids,
                               FALSE,
                               &CertAltNameInfo,
                               NULL,
                               &cbNeeded))
        {
            goto FormatAltNameError;
        }

        if (NULL == (pwszAltName = (LPWSTR) malloc(cbNeeded)))
        {
            goto MemoryError;
        }

        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               ids,
                               FALSE,
                               &CertAltNameInfo,
                               pwszAltName,
                               &cbNeeded))
        {
            goto FormatAltNameError;
        }

        //
        // Append "\r\n" if multi-line.
        //
        if (bMultiLines)
        {
			pwszTemp = (LPWSTR) realloc(pwszAltName, sizeof(WCHAR) * (wcslen(pwszAltName) + wcslen(wszCRLF) + 1));
			if (NULL == pwszTemp)
			{
				goto MemoryError;
			}
			pwszAltName = pwszTemp;
            wcscat(pwszAltName, wszCRLF);
        }

        //
        // Reallocate and concate to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + 1 + wcslen(pwszAltName)));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszAltName);
        free(pwszAltName);
        pwszAltName = NULL;
    }

    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
    if (pwszType)
    {
        LocalFree((HLOCAL) pwszType);
    }

    if (pwszSubtree)
    {
        LocalFree((HLOCAL) pwszSubtree);
    }

    if (pwszAltName)
    {
        free((HLOCAL) pwszAltName);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMessageError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatAltNameError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatNameConstrains:   szOID_NAME_CONSTRAINTS
//                          X509_NAME_CONSTRAINTS
//
//  typedef struct _CERT_NAME_CONSTRAINTS_INFO {
//      DWORD                   cPermittedSubtree;
//      PCERT_GENERAL_SUBTREE   rgPermittedSubtree;
//      DWORD                   cExcludedSubtree;
//      PCERT_GENERAL_SUBTREE   rgExcludedSubtree;
//  } CERT_NAME_CONSTRAINTS_INFO, *PCERT_NAME_CONSTRAINTS_INFO;
//
//------------------------------------------------------------------------------

//static 
BOOL
WINAPI
FormatNameConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL  fResult = FALSE;
    DWORD cbPermitNeeded = 0;
    DWORD cbExcludeNeeded = 0;
    DWORD cbTotalNeeded = 0;

    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           lpszStructType,
			               pbEncoded,
                           cbEncoded, 
                           (void **)&pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Find out memory size needed.
    //
    if ((!FormatNameConstraintsSubtree(dwCertEncodingType,
                                       dwFormatType,
                                       dwFormatStrType,
                                       pFormatStruct,
                                       NULL,
                                       &cbPermitNeeded,
                                       IDS_NAME_CONSTRAINTS_PERMITTED,
                                       pInfo->cPermittedSubtree,
                                       pInfo->rgPermittedSubtree)) ||
        (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                       dwFormatType,
                                       dwFormatStrType,
                                       pFormatStruct,
                                       NULL,
                                       &cbExcludeNeeded,
                                       IDS_NAME_CONSTRAINTS_EXCLUDED,
                                       pInfo->cExcludedSubtree,
                                       pInfo->rgExcludedSubtree)))
    {
        goto ErrorReturn;
    }

    //
    // Total length needed.
    //
    cbTotalNeeded = cbPermitNeeded + cbExcludeNeeded;
    if (0 == cbTotalNeeded)
    {
        *pcbFormat = cbTotalNeeded;
        goto SuccessReturn;
    }

    //
    // One char less after we concate both strings.
    //
    if (cbPermitNeeded > 0 && cbExcludeNeeded > 0)
    {
        cbTotalNeeded -= sizeof(WCHAR);

        //
        // If not multi-lines and both strings are present, allow 2 more 
        // chars for ", " to separate the strings.
        //
        if (!(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
        {
            cbTotalNeeded += sizeof(WCHAR) * wcslen(wszCOMMA);
        }
    }

    //
    // length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbTotalNeeded;
        goto SuccessReturn;
    }
   
    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbTotalNeeded)
    {
        *pcbFormat = cbTotalNeeded;
        goto MoreDataError;
    }

    //
    // Now format both subtrees.
    //
    if (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                      dwFormatType,
                                      dwFormatStrType,
                                      pFormatStruct,
                                      pbFormat,
                                      &cbPermitNeeded,
                                      IDS_NAME_CONSTRAINTS_PERMITTED,
                                      pInfo->cPermittedSubtree,
                                      pInfo->rgPermittedSubtree))
    {
       goto ErrorReturn;
    }

    //
    // If not multi-lines and both strings are present, then add ", "
    // to separate them.
    //
    if (!(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) &&
        (cbPermitNeeded > 0) && (cbExcludeNeeded > 0))
    {
        wcscat((LPWSTR) pbFormat, wszCOMMA);
    }

    pbFormat = (void *) ((BYTE *) pbFormat + wcslen((LPWSTR) pbFormat) * sizeof(WCHAR));

    if (!FormatNameConstraintsSubtree(dwCertEncodingType,
                                      dwFormatType,
                                      dwFormatStrType,
                                      pFormatStruct,
                                      pbFormat,
                                      &cbExcludeNeeded,
                                      IDS_NAME_CONSTRAINTS_EXCLUDED,
                                      pInfo->cExcludedSubtree,
                                      pInfo->rgExcludedSubtree))
    {
       goto ErrorReturn;
    }

    //
    // Copy the size needed.
    //
    *pcbFormat = cbTotalNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    //
    // Free resources.
    //
	if (pInfo)
    {
        free(pInfo);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCertSrvPreviousCertHash      szOID_CERTSRV_PREVIOUS_CERT_HASH
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCertSrvPreviousCertHash (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL              fResult;
    DWORD             cbNeeded    = 0;
    CRYPT_DATA_BLOB * pInfo       = NULL;
    WCHAR           * pwszHex     = NULL;
    WCHAR           * pwszFormat  = NULL;
    BOOL              bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_OCTET_STRING,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Get formatted hex string.
    //
    if(!FormatBytesToHex(0,
                         dwFormatType,
                         dwFormatStrType,
                         pFormatStruct,
                         NULL,
                         pInfo->pbData,
                         pInfo->cbData,
                         NULL,
	                     &cbNeeded))
    {
        goto FormatBytesToHexError;
    }

    if (!(pwszHex = (LPWSTR) malloc(cbNeeded)))
    {
        goto MemoryError;
    }

    if(!FormatBytesToHex(0,
                         dwFormatType,
                         dwFormatStrType,
                         pFormatStruct,
                         NULL,
                         pInfo->pbData,
                         pInfo->cbData,
                         pwszHex,
	                     &cbNeeded))
    {
        goto FormatBytesToHexError;
    }

    if (!FormatMessageUnicode(&pwszFormat, 
                              IDS_STRING, 
                              pwszHex,
                              bMultiLines ? wszCRLF : wszEMPTY))
    {
        goto FormatMessageError;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

	if (pInfo)
    {
        free(pInfo);
    }

    if (pwszHex)
    {
        free(pwszHex);
    }

    if (pwszFormat)
    {
        LocalFree((HLOCAL) pwszFormat);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatPolicyMappings               X509_POLICY_MAPPINGS
//                                     szOID_POLICY_MAPPINGS
//                                     szOID_APPLICATION_POLICY_MAPPINGS
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatPolicyMappings (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL   fResult;
    DWORD  dwIndex     = 0;
    DWORD  cbNeeded    = 0;
    char   szEmpty[1]  = {'\0'};
    LPSTR  pszObjectId = NULL;
    LPWSTR pwszFormat  = NULL;
    LPWSTR pwszTemp    = NULL;
    LPWSTR pwszLine    = NULL;
    LPWSTR pwszPolicy  = NULL;
    BOOL   bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_POLICY_MAPPINGS_INFO * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_POLICY_MAPPINGS,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Make sure data is valid.
    //
    if (pInfo->cPolicyMapping && !pInfo->rgPolicyMapping)
    {
        goto BadDataError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

    //
    // Loop thru each mapping.
    //
    for (dwIndex = 0; dwIndex < pInfo->cPolicyMapping; dwIndex++)
    {
        //
        // Format Issuer Domain Policy, if available.
        //
        if (pInfo->rgPolicyMapping[dwIndex].pszIssuerDomainPolicy)
        {
            pszObjectId = pInfo->rgPolicyMapping[dwIndex].pszIssuerDomainPolicy;
        }
        else
        {
            pszObjectId = szEmpty;
        }

        if (!FormatObjectId(pszObjectId,
                            CRYPT_POLICY_OID_GROUP_ID,
                            FALSE,
                            &pwszPolicy))
        {
            goto FormatObjectIdError;
        }

        //
        // "[%1!d!]Issuer Domain=%2!s!%3!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_ISSUER_DOMAIN_POLICY,
                                  dwIndex + 1,
                                  pwszPolicy,
                                  bMultiLines ? wszCRLF : wszCOMMA))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszPolicy);
        pwszPolicy = NULL;

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
 
        //
        // Format Subject Domain Policy, if available.
        //
        if (pInfo->rgPolicyMapping[dwIndex].pszSubjectDomainPolicy)
        {
            pszObjectId = pInfo->rgPolicyMapping[dwIndex].pszSubjectDomainPolicy;
        }
        else
        {
            pszObjectId = szEmpty;
        }

        if (!FormatObjectId(pszObjectId,
                            CRYPT_POLICY_OID_GROUP_ID,
                            FALSE,
                            &pwszPolicy))
        {
            goto FormatObjectIdError;
        }

        //
        // "%1!s!Subject Domain=%2!s!%3!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_SUBJECT_DOMAIN_POLICY,
                                  bMultiLines ? wszTAB : wszEMPTY,
                                  pwszPolicy,
                                  bMultiLines ? wszCRLF : (dwIndex + 1) < pInfo->cPolicyMapping ? wszCOMMA : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszPolicy);
        pwszPolicy = NULL;

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszPolicy)
    {
        LocalFree((HLOCAL) pwszPolicy);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(BadDataError, E_POINTER);
TRACE_ERROR(FormatObjectIdError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatPolicyConstraints            X509_POLICY_CONSTRAINTS
//                                     szOID_POLICY_CONSTRAINTS
//                                     szOID_APPLICATION_POLICY_CONSTRAINTS
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatPolicyConstraints (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded    = 0;
    LPWSTR  pwszFormat  = NULL;
    LPWSTR  pwszTemp    = NULL;
    LPWSTR  pwszLine    = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_POLICY_CONSTRAINTS_INFO * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_POLICY_CONSTRAINTS,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

    //
    // Format Required Explicit Policy Skip Certs, if available.
    //
    if (pInfo->fRequireExplicitPolicy)
    {
        //
        // "Required Explicit Policy Skip Certs=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_REQUIRED_EXPLICIT_POLICY_SKIP_CERTS,
                                  pInfo->dwRequireExplicitPolicySkipCerts,
                                  bMultiLines ? wszCRLF : wszCOMMA))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }

    //
    // Format Inhibit Policy Mapping Skip Certs, if available.
    //
    if (pInfo->fInhibitPolicyMapping)
    {
        //
        // "Inhibit Policy Mapping Skip Certs=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_INHIBIT_POLICY_MAPPING_SKIP_CERTS,
                                  pInfo->dwInhibitPolicyMappingSkipCerts,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}

//+-----------------------------------------------------------------------------
//
//  FormatCertificateTemplate          X509_CERTIFICATE_TEMPLATE
//                                     szOID_CERTIFICATE_TEMPLATE
//
//------------------------------------------------------------------------------

static BOOL
WINAPI
FormatCertificateTemplate (
	DWORD       dwCertEncodingType,
	DWORD       dwFormatType,
	DWORD       dwFormatStrType,
	void       *pFormatStruct,
	LPCSTR      lpszStructType,
	const BYTE *pbEncoded,
	DWORD       cbEncoded,
	void       *pbFormat,
	DWORD      *pcbFormat)
{
	BOOL    fResult;
    DWORD   cbNeeded    = 0;
    LPWSTR  pwszFormat  = NULL;
    LPWSTR  pwszObjId   = NULL;
    LPWSTR  pwszTemp    = NULL;
    LPWSTR  pwszLine    = NULL;
    BOOL    bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
    CERT_TEMPLATE_EXT * pInfo = NULL;

    //
	// Check input parameters.
    //
    if ((NULL == pbEncoded && 0 != cbEncoded) ||
        (NULL == pcbFormat) || (0 == cbEncoded))
	{
		goto InvalidArg;
	}

    //
    // Decode extension.
    //
    if (!DecodeGenericBLOB(dwCertEncodingType, 
                           X509_CERTIFICATE_TEMPLATE,
			               pbEncoded,
                           cbEncoded, 
                           (void **) &pInfo))
    {
        goto DecodeGenericError;
    }

    //
    // Initialize formatted string.
    //
    if (!(pwszFormat = (LPWSTR) malloc(sizeof(WCHAR))))
    {
        goto MemoryError;
    }
    *pwszFormat = NULL;

#if (0) //DSIE: Bug 157853
    //
    // Convert OID to Unicode.
    //
    if (!AllocateAnsiToUnicode(pInfo->pszObjId, &pwszObjId))
    {
        goto AnsiToUnicodeError;
    }
#else
    if (!FormatObjectId(pInfo->pszObjId,
                        CRYPT_TEMPLATE_OID_GROUP_ID,
                        FALSE,
                        &pwszObjId))
    {
        goto FormatObjectIdError;
    }
#endif

    //
    // "Template=%1!s!%2!s!Major Version Number=%3!d!%4!s!"
    //
    if (!FormatMessageUnicode(&pwszLine, 
                              IDS_CERTIFICATE_TEMPLATE_MAJOR_VERSION,
                              pwszObjId,
                              bMultiLines ? wszCRLF : wszCOMMA,
                              pInfo->dwMajorVersion,
                              bMultiLines ? wszCRLF : wszCOMMA))
    {
        goto FormatMessageError;
    }

    //
    // Reallocate and concate line to format buffer.
    //
    pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
    if (NULL == pwszTemp)
    {
        goto MemoryError;
    }

    pwszFormat = pwszTemp;
    wcscat(pwszFormat, pwszLine);

    LocalFree((HLOCAL) pwszLine);
    pwszLine = NULL;

    //
    // Format Minor Version, if available.
    //
    if (pInfo->fMinorVersion)
    {
        //
        // "Minor Version Number=%1!d!%2!s!"
        //
        if (!FormatMessageUnicode(&pwszLine, 
                                  IDS_CERTIFICATE_TEMPLATE_MINOR_VERSION,
                                  pInfo->dwMinorVersion,
                                  bMultiLines ? wszCRLF : wszEMPTY))
        {
            goto FormatMessageError;
        }

        //
        // Reallocate and concate line to format buffer.
        //
        pwszTemp = (LPWSTR) realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat) + wcslen(pwszLine) + 1));
        if (NULL == pwszTemp)
        {
            goto MemoryError;
        }

        pwszFormat = pwszTemp;
        wcscat(pwszFormat, pwszLine);

        LocalFree((HLOCAL) pwszLine);
        pwszLine = NULL;
    }
    
    //
    // Total length needed.
    //
    cbNeeded = sizeof(WCHAR) * (wcslen(pwszFormat) + 1);

    //
    // Length only calculation?
    //
    if (NULL == pbFormat)
    {
        *pcbFormat = cbNeeded;
        goto SuccessReturn;
    }

    //
    // Caller provided us with enough memory?
    //
    if (*pcbFormat < cbNeeded)
    {
        *pcbFormat = cbNeeded;
        goto MoreDataError;
    }

    //
    // Copy size and data.
    //
    memcpy(pbFormat, pwszFormat, cbNeeded);
    *pcbFormat = cbNeeded;

SuccessReturn:

    fResult = TRUE;

CommonReturn:

    if (pwszObjId)
    {
#if (0) //DSIE: Bug 157853
        free(pwszObjId);
#else
        LocalFree((HLOCAL) pwszObjId);
#endif
    }

    if (pwszLine)
    {
        LocalFree((HLOCAL) pwszLine);
    }

    if (pwszFormat)
    {
        free(pwszFormat);
    }

	if (pInfo)
    {
        free(pInfo);
    }

    return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg,E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
#if (0) //DSIE: Bug 157853
TRACE_ERROR(AnsiToUnicodeError);
#else
TRACE_ERROR(FormatObjectIdError);
#endif
TRACE_ERROR(FormatMessageError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
}



//--------------------------------------------------------------------------
//
//	 FormatXCertDistPoints:   X509_CROSS_CERT_DIST_POINTS
//                            szOID_CROSS_CERT_DIST_POINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatXCertDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR					        pwszFormat=NULL;
    LPWSTR                          pwszDeltaTime=NULL;
    LPWSTR                          pwszEntryLine=NULL;
    LPWSTR                          pwszDistPoint=NULL;

	PCROSS_CERT_DIST_POINTS_INFO    pInfo=NULL;

	DWORD					        cbNeeded=0;
    DWORD                           dwIndex=0;
	BOOL					        fResult=FALSE;
    BOOL                            bMultiLines = dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE;
                                    
    LPWSTR                          pwszTemp;
    
	//check for input parameters
	if ((NULL==pbEncoded && cbEncoded!=0) || (NULL==pcbFormat))
		goto InvalidArg;

	if (cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}
  
    if (!DecodeGenericBLOB(dwCertEncodingType, lpszStructType,
			pbEncoded, cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //
    // "Delta Sync Time=%1!d! seconds%2!s!"
    //
    if (!FormatMessageUnicode(&pwszDeltaTime, 
                              IDS_XCERT_DELTA_SYNC_TIME,
                              pInfo->dwSyncDeltaTime,
                              bMultiLines ? wszCRLF : wszCOMMA))
    {
        goto FormatMessageError;
    }

    pwszFormat=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszDeltaTime)+1));
    if(NULL==pwszFormat)
        goto MemoryError;

    wcscpy(pwszFormat, pwszDeltaTime);

    //format the xcert dist point entries.
    for (dwIndex=0; dwIndex<pInfo->cDistPoint; dwIndex++)
    {
        cbNeeded=0;
        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               bMultiLines ? IDS_ONE_TAB : 0,
                               FALSE,
                               &pInfo->rgDistPoint[dwIndex],
                               NULL,
                               &cbNeeded))
            goto FormatAltNameError;

        pwszEntryLine=(LPWSTR)malloc(cbNeeded);
        if (NULL==pwszEntryLine)
            goto MemoryError;

        if (!FormatAltNameInfo(dwCertEncodingType,
                               dwFormatType,
                               dwFormatStrType,
                               pFormatStruct,
                               bMultiLines ? IDS_ONE_TAB : 0,
                               FALSE,
                               &pInfo->rgDistPoint[dwIndex],
                               pwszEntryLine,
                               &cbNeeded))
            goto FormatAltNameError;

        //"[%1!d!]Cross-Certificate Distribution Point: %2!s!%3!s!%4!s!"
        if(!FormatMessageUnicode(&pwszDistPoint,
                                 IDS_XCERT_DIST_POINT,
                                 dwIndex + 1,
                                 bMultiLines ? wszCRLF : wszEMPTY,
                                 pwszEntryLine,
                                 bMultiLines || (dwIndex == pInfo->cDistPoint - 1) ? wszCRLF : wszCOMMA))
            goto FormatMessageError;

        pwszTemp=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(pwszDistPoint)+1));
        if(NULL==pwszTemp)
            goto MemoryError;
        pwszFormat = pwszTemp;

        wcscat(pwszFormat, pwszDistPoint);

        //free memory
        free(pwszEntryLine);
        pwszEntryLine=NULL;

        LocalFree((HLOCAL) pwszDistPoint);
        pwszDistPoint=NULL;
    }

    if(0==wcslen(pwszFormat))
    {
        //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}

	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;	

CommonReturn:
    if(pwszDeltaTime)
        LocalFree((HLOCAL) pwszDeltaTime);

    if(pwszDistPoint)
        LocalFree((HLOCAL) pwszDistPoint);

    if(pwszEntryLine)
        free(pwszEntryLine);

    if (pwszFormat)
        free(pwszFormat);

    if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:


	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatAltNameError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\frmtfunc.h ===
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:     frmtfunc.h
//
//  Contents:   The header for frmtfunc.cpp
//
//  History:    Sept. 1st, 1997
//              
//--------------------------------------------------------------------------

#ifndef __FRMTFUNC_H__
#define __FRMTFUNC_H__

#include <wchar.h> 
        
#include "wintrust.h"
#include "mssip.h"
#include "sipbase.h"
#include "pfx.h"


#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//	 constants
//--------------------------------------------------------------------------
#define	    UPPER_BITS			                        0xF0
#define	    LOWER_BITS			                        0x0F
#define	    CHAR_SIZE			                        2
#define	    HEX_SIZE			                        3    

//for other name in the subject alt name
#define		PREFIX_SIZE									50
#define		POSTFIX_SIZE								10
#define		INT_SIZE									20

//for szOID_BASIC_CONSTRAINTS2
#define		SUBJECT_SIZE								256
#define		NONE_SIZE									256
   
//for szOID_CRL_REASON_CODE
#define		CRL_REASON_SIZE								256

//for szOID_ENHANCED_KEY_USAGE
#define     NO_INFO_SIZE                                256

//for szOID_ALT_NAME
#define     UNKNOWN_VALUE_SIZE                          256
#define     ALT_NAME_SIZE                               256

//for SPC_FINANCIAL_CRIERIA
#define     AVAIL_SIZE                                  256
#define     YES_NO_SIZE                                 256

//for netscape cert type
#define		CERT_TYPE_SIZE								100

//
// Post Win2K
//

// for szOID_NAME_CONSTRAINTS
#define     NAME_CONSTRAINTS_SIZE                       256

//for Key Usage                                         
#define     KEY_USAGE_SIZE                              256
#define     UNKNOWN_ACCESS_METHOD_SIZE                  256
#define     UNKNOWN_KEY_USAGE_SIZE                      256
#define     DAY_SIZE                                    256
#define     MONTH_SIZE                                  256
#define     AMPM_SIZE                                   256
#define     CRL_DIST_NAME_SIZE                          256
#define     UNKNOWN_CRL_REASON_SIZE                     256
#define     PRE_FIX_SIZE                                256
#define     UNKNOWN_OID_SIZE                            256

//----------------------------------------------------------------------------
//	 WCHAR string contants
//--------------------------------------------------------------------------

//used for formatting
#define	wszPLUS			L" + "
#define	wszCOMMA		L", "
#define	wszSEMICOLON	L"; "
#define	wszCRLF			L"\r\n"
#define	wszEQUAL		L"="
#define	strCOMMA		", "

//
// Post Win2K
//
#define wszSPACE        L" "
#define wszTAB          L"     "
#define wszCOLON        L": "
#define wszEMPTY        L""

//certificate
#define BEGINCERT_W                 L"-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_W               (sizeof(BEGINCERT_W)/sizeof(WCHAR) - 1)

#define BEGINCERT_A                 "-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_A               (sizeof(BEGINCERT_A)/sizeof(CHAR) - 1)


//CRL
#define BEGINCRL_W					L"-----BEGIN X509 CRL-----"
#define	CBBEGINCRL_W				(sizeof(BEGINCRL_W)/sizeof(WCHAR) - 1)

#define BEGINCRL_A					"-----BEGIN X509 CRL-----"
#define	CBBEGINCRL_A				(sizeof(BEGINCRL_A)/sizeof(CHAR) - 1)


//certificate request
#define BEGINREQUEST_W				L"-----BEGIN NEW CERTIFICATE REQUEST-----"
#define CBBEGINREQUEST_W			(sizeof(BEGINREQUEST_W)/sizeof(WCHAR) - 1)

#define BEGINREQUEST_A				"-----BEGIN NEW CERTIFICATE REQUEST-----"
#define CBBEGINREQUEST_A			(sizeof(BEGINREQUEST_A)/sizeof(CHAR) - 1)


//---------------------------------------------------------
//	The following is used by this dll
//
//-----------------------------------------------------------  

const DWORD	g_AllocateSize=128*sizeof(WCHAR);


//macro needed to format the CA
#define _16BITMASK              ((1 << 16) - 1)
#define CANAMEIDTOIKEY(NameId)	((NameId) >> 16)
#define CANAMEIDTOICERT(NameId)	(_16BITMASK & (NameId))

typedef struct _FORMAT_CERT_TYPE_INFO {
	BYTE			bCertType;
	UINT			idsCertType;
} FORMAT_CERT_TYPE_INFO;

//---------------------------------------------------------------------------
//
//	Unitlity functions used by the dll
//---------------------------------------------------------------------------								
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo); 
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz);
DWORD   FormatToStr(DWORD   dwFormatType);
//BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...);

BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix, 
                         LPWSTR          *ppwsz);

BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR   *ppwszFormat);

BOOL    FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR    *ppwszFormat);

BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat);



static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat);

static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat);

BOOL    FormatDistPointName(
    DWORD		            dwCertEncodingType,                         
	DWORD		            dwFormatType,                               
	DWORD		            dwFormatStrType,                            
	void		            *pFormatStruct,                             
    PCRL_DIST_POINT_NAME    pInfo,                                      
    LPWSTR                  *ppwszFormat);    

BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat);

BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPrefix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat);

BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwszFormat);

BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat);


BOOL	CryptDllFormatNameAll(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer);

                          


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __FRMTFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\fndchain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fndchain.cpp
//
//  Contents:   Find Certificate Chain in Store API
//
//  Functions:  CertFindChainInStore
//              IFC_IsEndCertValidForUsage
//
//  History:    28-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


BOOL IFC_IsEndCertValidForUsages(
    IN PCCERT_CONTEXT pCert,
    IN PCERT_ENHKEY_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    BOOL fResult;
    int cNumOIDs;
    LPSTR *ppOIDs = NULL;
    DWORD cbOIDs;

    if (0 == pUsage->cUsageIdentifier)
        goto SuccessReturn;

    cbOIDs = 0;
    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          NULL,             // rghOIDs
          &cbOIDs
          )) goto CertGetValidUsagesError;

    if (-1 == cNumOIDs)
        // Cert doesn't have any EKU
        goto SuccessReturn;
    else if (0 == cNumOIDs)
        // Intersection of usages in properties and extensions is NONE
        goto NoMatch;

    assert(cbOIDs);

    if (NULL == (ppOIDs = (LPSTR *) PkiNonzeroAlloc(cbOIDs)))
        goto OutOfMemory;

    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          ppOIDs,
          &cbOIDs
          )) goto CertGetValidUsagesError;

    if (0 >= cNumOIDs)
        // We had a change from the first call
        goto NoMatch;


    {
        DWORD cId1 = pUsage->cUsageIdentifier;
        LPSTR *ppszId1 = pUsage->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD cId2 = cNumOIDs;
            LPSTR *ppszId2 = ppOIDs;
            for ( ; cId2 > 0; cId2--, ppszId2++) {
                if (0 == strcmp(*ppszId1, *ppszId2)) {
                    if (fOrUsage)
                        goto SuccessReturn;
                    else
                        break;
                }
            }
            if (!fOrUsage && 0 == cId2)
                goto NoMatch;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            goto NoMatch;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(ppOIDs);
    return fResult;

NoMatch:
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CertGetValidUsagesError)
TRACE_ERROR(OutOfMemory)
}

BOOL IFC_IsEndCertValidForUsage(
    IN PCCERT_CONTEXT pCert,
    IN LPCSTR pszUsageIdentifier
    )
{
    CERT_ENHKEY_USAGE Usage = { 1, (LPSTR *) &pszUsageIdentifier};

    return IFC_IsEndCertValidForUsages(
        pCert,
        &Usage,
        TRUE        // fOrUsage
        );
}

BOOL CompareChainIssuerNameBlobs(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_BY_ISSUER_PARA pPara,
    IN OUT PCCERT_CHAIN_CONTEXT *ppChainContext
    )
{
    DWORD i;
    DWORD cIssuer = pPara->cIssuer;
    PCERT_NAME_BLOB pIssuer = pPara->rgIssuer;
    PCCERT_CHAIN_CONTEXT pChainContext = *ppChainContext;

    if (0 == cIssuer)
        return TRUE;

    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain;

        if (0 < i && 0 == (dwFindFlags &
                CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG))
            break;

        pChain = pChainContext->rgpChain[i];
        for (j = 0; j < pChain->cElement; j++) {
            DWORD k;
            PCCERT_CONTEXT pCert = pChain->rgpElement[j]->pCertContext;
            PCERT_NAME_BLOB pChainIssuer = &pCert->pCertInfo->Issuer;

            for (k = 0; k < cIssuer; k++) {
                if (CertCompareCertificateName(
                        dwCertEncodingType,
                        pChainIssuer,
                        &pIssuer[k]
                        )) {
                    if (STRUCT_CBSIZE(CERT_CHAIN_FIND_BY_ISSUER_PARA,
                            pdwIssuerElementIndex) <= pPara->cbSize) {
                        if (pPara->pdwIssuerChainIndex)
                            *pPara->pdwIssuerChainIndex = i;
                        if (pPara->pdwIssuerElementIndex)
                            *pPara->pdwIssuerElementIndex = j + 1;
                    }
                    return TRUE;
                }
            }
        }
    }

    // See if we have a match in any of the lower quality chains

    for (i = 0; i < pChainContext->cLowerQualityChainContext; i++) {
        PCCERT_CHAIN_CONTEXT pLowerQualityChainContext =
            pChainContext->rgpLowerQualityChainContext[i];

        if (pLowerQualityChainContext->TrustStatus.dwErrorStatus &
                CERT_TRUST_IS_NOT_SIGNATURE_VALID)
            // Lower quality chains must at least have valid signatures
            continue;
        
        CertDuplicateCertificateChain(pLowerQualityChainContext);

        if (CompareChainIssuerNameBlobs(
                dwCertEncodingType,
                dwFindFlags,
                pPara,
                &pLowerQualityChainContext
                )) {
            // Replace the input chain context with the lower quality
            // chain context
            CertFreeCertificateChain(pChainContext);
            *ppChainContext = pLowerQualityChainContext;

            return TRUE;
        } else {
            assert(pLowerQualityChainContext ==
                pChainContext->rgpLowerQualityChainContext[i]);
            CertFreeCertificateChain(pLowerQualityChainContext);
        }
    }

    return FALSE;
}

static DWORD GetChainKeyIdentifierPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return 0;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (!CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            )) {
        // Try again, searching LocalMachine
        if (!CryptGetKeyIdentifierProperty(
                &KeyIdentifier,
                CERT_KEY_PROV_INFO_PROP_ID,
                CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
                NULL,                           // pwszComputerName
                NULL,                           // pvReserved
                (void *) &pKeyProvInfo,
                &cbKeyProvInfo
                ))
            return 0;
    }

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        dwPropId = 0;
    else
        dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

    PkiDefaultCryptFree(pKeyProvInfo);
    return dwPropId;
}

DWORD GetChainPrivateKeyPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    CERT_KEY_CONTEXT KeyContext;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbProp;

    cbProp = sizeof(KeyContext);
    if (CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbProp
            )) {
        assert(sizeof(KeyContext) <= cbProp);
        if (dwKeySpec && dwKeySpec != KeyContext.dwKeySpec)
            return 0;
        else
            return CERT_KEY_CONTEXT_PROP_ID;
    }

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbProp
            ))
        return 0;

    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbProp)))
        goto OutOfMemory;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbProp
            )) goto CertGetCertificateContextPropertyError;

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        goto NoMatch;

    dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

CommonReturn:
    PkiFree(pKeyProvInfo);
    return dwPropId;

NoMatch:
ErrorReturn:
    dwPropId = 0;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CertGetCertificateContextPropertyError)
}

BOOL FindChainByIssuer(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_BY_ISSUER_PARA pPara,
    IN PCCERT_CONTEXT pCert,
    OUT PCCERT_CHAIN_CONTEXT *ppChainContext
    )
{
    BOOL fResult = TRUE;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwPrivateKeyPropId;
    CERT_CHAIN_PARA ChainPara;
    DWORD dwCreateChainFlags;

    if (NULL == pPara ||
            offsetof(CERT_CHAIN_FIND_BY_ISSUER_PARA, pvFindArg) >
                pPara->cbSize) {
        fResult = FALSE;
        goto InvalidArg;
    }

    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG)
        dwPrivateKeyPropId = CERT_KEY_CONTEXT_PROP_ID;
    else if (0 == (dwPrivateKeyPropId = GetChainPrivateKeyPropId(
            pCert,
            pPara->dwKeySpec
            ))) {
        if (0 == (dwPrivateKeyPropId = GetChainKeyIdentifierPropId(
                pCert,
                pPara->dwKeySpec
                )))
            goto NoMatch;
    }

    if (pPara->pszUsageIdentifier) {
        if (!IFC_IsEndCertValidForUsage(
                pCert,
                pPara->pszUsageIdentifier
                )) goto NoMatch;
    }

    if (pPara->pfnFindCallback) {
        if (!pPara->pfnFindCallback(
                pCert,
                pPara->pvFindArg
                )) goto NoMatch;
    }

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (pPara->pszUsageIdentifier) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
            (LPSTR *) &pPara->pszUsageIdentifier;
    }

    // For cross certs, might need to look at the lower quality chains
    dwCreateChainFlags = CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING |
        CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS;
    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL;
    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertGetCertificateChain(
            NULL,                   // hChainEngine
            pCert,
            NULL,                   // pTime
            dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG ?
                0 : pCert->hCertStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                   // pvReserved
            &pChainContext
            )) goto CertGetCertificateChainError;

    if (!CompareChainIssuerNameBlobs(
            dwCertEncodingType,
            dwFindFlags,
            pPara,
            &pChainContext
            )) goto NoMatch;


    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG) {
        if (CERT_KEY_CONTEXT_PROP_ID != dwPrivateKeyPropId) {
            DWORD dwAcquireFlags = pPara->dwAcquirePrivateKeyFlags |
                CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
            HCRYPTPROV hProv;
            BOOL fCallerFreeProv;

            if (!CryptAcquireCertificatePrivateKey(
                    pCert,
                    dwAcquireFlags,
                    NULL,               // pvReserved
                    &hProv,
                    NULL,               // pdwKeySpec
                    &fCallerFreeProv
                    )) goto CryptAcquireCertificatePrivateKeyError;

            if (fCallerFreeProv)
                CryptReleaseContext(hProv, 0);
        }
    }


CommonReturn:
    *ppChainContext = pChainContext;
    return fResult;

NoMatch:
ErrorReturn:
    if (pChainContext) {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CryptAcquireCertificatePrivateKeyError)
}
    

PCCERT_CHAIN_CONTEXT
WINAPI
CertFindChainInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
    )
{
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    if (0 == dwCertEncodingType)
        dwCertEncodingType = X509_ASN_ENCODING;

    if (pPrevChainContext) {
        if (pPrevChainContext->cChain) {
            PCERT_SIMPLE_CHAIN pChain = pPrevChainContext->rgpChain[0];
            if (pChain->cElement)
                pCert = CertDuplicateCertificateContext(
                    pChain->rgpElement[0]->pCertContext);
        }
        CertFreeCertificateChain(pPrevChainContext);
    }

    while (pCert = CertEnumCertificatesInStore(hCertStore, pCert)) {
        switch (dwFindType) {
            case CERT_CHAIN_FIND_BY_ISSUER:
                if (!FindChainByIssuer(
                        dwCertEncodingType,
                        dwFindFlags,
                        (PCERT_CHAIN_FIND_BY_ISSUER_PARA) pvFindPara,
                        pCert,
                        &pChainContext
                        )) goto FindChainByIssuerError;
                if (pChainContext)
                    goto CommonReturn;
                break;
            default:
                goto InvalidArg;
        }
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    return pChainContext;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(FindChainByIssuerError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\logstor.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       logstor.h
//
//  Contents:   Public functions in logstor.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __LOGSTOR_H__
#define __LOGSTOR_H__

//+-------------------------------------------------------------------------
//  Register wait for callback functions
//--------------------------------------------------------------------------
typedef VOID (NTAPI * ILS_WAITORTIMERCALLBACK) (PVOID, BOOLEAN );

BOOL
WINAPI
ILS_RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

BOOL
WINAPI
ILS_UnregisterWait(
    HANDLE WaitHandle
    );

BOOL
WINAPI
ILS_ExitWait(
    HANDLE WaitHandle,
    HMODULE hLibModule
    );

//+-------------------------------------------------------------------------
//  Registry support functions
//--------------------------------------------------------------------------

void
ILS_EnableBackupRestorePrivileges();

void
ILS_CloseRegistryKey(
    IN HKEY hKey
    );

BOOL
ILS_ReadDWORDValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD *pdwValue
    );

BOOL
ILS_ReadBINARYValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue
    );

//+-------------------------------------------------------------------------
//  Get and allocate the REG_SZ value
//--------------------------------------------------------------------------
LPWSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName
    );
LPSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCSTR pszValueName
    );

//+-------------------------------------------------------------------------
//  Key Identifier registry and roaming file support functions
//--------------------------------------------------------------------------
BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );
BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );
BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    );

typedef BOOL (*PFN_ILS_OPEN_KEYID_ELEMENT)(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    );

//+-------------------------------------------------------------------------
//  Misc alloc and copy functions
//--------------------------------------------------------------------------
LPWSTR ILS_AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc = -1
    );

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void ILS_BytesToWStr(DWORD cb, void* pv, LPWSTR wsz);

#endif  // __LOGSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\logstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       logstor.cpp
//
//  Contents:   Registry Certificate Store Provider APIs
//
//  Functions:  I_RegStoreDllMain
//              I_CertDllOpenRegStoreProv
//              CertRegisterSystemStore
//              CertRegisterPhysicalStore
//              CertUnregisterSystemStore
//              CertUnregisterPhysicalStore
//              CertEnumSystemStoreLocation
//              CertEnumSystemStore
//              CertEnumPhysicalStore
//              I_CertDllOpenSystemRegistryStoreProvW
//              I_CertDllOpenSystemRegistryStoreProvA
//              I_CertDllOpenSystemStoreProvW
//              I_CertDllOpenSystemStoreProvA
//              I_CertDllOpenPhysicalStoreProvW
//
//  History:    28-Dec-96    philh   created
//              13-Aug-96    philh   added change notify and resync support
//              24-Aug-96    philh   added logical store support
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>


#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Note, this flag must not collide with CertControlStore dwFlags
#define REG_STORE_CTRL_CANCEL_NOTIFY_FLAG 0x80000000


// Pointer to an allocated LONG containing thread's enum recursion depth
static HCRYPTTLS hTlsEnumPhysicalStoreDepth;
#define MAX_ENUM_PHYSICAL_STORE_DEPTH       20

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PHYSICAL_STORES_SUBKEY_NAME L"PhysicalStores"
#define CONST_OID_STR_PREFIX_CHAR   '#'
#define SERVICES_REGPATH            L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_CERTIFICATES_SUBKEY_NAME L"SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH    L"Software\\Microsoft\\EnterpriseCertificates"

#define ROAMING_MY_STORE_SUBDIR     L"Microsoft\\SystemCertificates\\My"
#define ROAMING_REQUEST_STORE_SUBDIR L"Microsoft\\SystemCertificates\\Request"

#define REGISTER_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_CREATE_NEW_FLAG)
#define UNREGISTER_FLAGS_MASK       (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG)
#define ENUM_FLAGS_MASK             (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG)

#define OPEN_REG_FLAGS_MASK         (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_REGISTRY_STORE_REMOTE_FLAG | \
                                        CERT_REGISTRY_STORE_SERIALIZED_FLAG | \
                                        CERT_REGISTRY_STORE_ROAMING_FLAG | \
                                        CERT_REGISTRY_STORE_CLIENT_GPT_FLAG | \
                                        CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG | \
                                        CERT_REGISTRY_STORE_LM_GPT_FLAG)
#define OPEN_SYS_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
#define OPEN_PHY_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
//+-------------------------------------------------------------------------
//  Common, global logical store critical section. Used by:
//      GptStore, Win95Store, RoamingStore.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ILS_CriticalSection;


//+-------------------------------------------------------------------------
//  Registry Store Context SubKeys
//--------------------------------------------------------------------------
#define CONTEXT_COUNT       3
static const LPCWSTR rgpwszContextSubKeyName[CONTEXT_COUNT] = {
    L"Certificates",
    L"CRLs",
    L"CTLs"
};

#define KEYID_CONTEXT_NAME          L"Keys"

static DWORD rgdwContextTypeFlags[CONTEXT_COUNT] = {
    CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
    CERT_STORE_CRL_CONTEXT_FLAG,
    CERT_STORE_CTL_CONTEXT_FLAG
};

#define MY_SYSTEM_INDEX         0
#define ROOT_SYSTEM_INDEX       1
#define TRUST_SYSTEM_INDEX      2
#define CA_SYSTEM_INDEX         3
#define USER_DS_SYSTEM_INDEX    4
#define TRUST_PUB_SYSTEM_INDEX  5
#define DISALLOWED_SYSTEM_INDEX 6
#define AUTH_ROOT_SYSTEM_INDEX  7
#define TRUST_PEOPLE_SYSTEM_INDEX 8

#define MY_SYSTEM_FLAG          (1 << MY_SYSTEM_INDEX)
#define ROOT_SYSTEM_FLAG        (1 << ROOT_SYSTEM_INDEX)
#define TRUST_SYSTEM_FLAG       (1 << TRUST_SYSTEM_INDEX)
#define CA_SYSTEM_FLAG          (1 << CA_SYSTEM_INDEX)
#define USER_DS_SYSTEM_FLAG     (1 << USER_DS_SYSTEM_INDEX)
#define TRUST_PUB_SYSTEM_FLAG   (1 << TRUST_PUB_SYSTEM_INDEX)
#define DISALLOWED_SYSTEM_FLAG  (1 << DISALLOWED_SYSTEM_INDEX)
#define AUTH_ROOT_SYSTEM_FLAG   (1 << AUTH_ROOT_SYSTEM_INDEX)
#define TRUST_PEOPLE_SYSTEM_FLAG (1 << TRUST_PEOPLE_SYSTEM_INDEX)

#define COMMON_SYSTEM_FLAGS     ( \
    MY_SYSTEM_FLAG | \
    ROOT_SYSTEM_FLAG | \
    TRUST_SYSTEM_FLAG | \
    CA_SYSTEM_FLAG | \
    TRUST_PUB_SYSTEM_FLAG | \
    DISALLOWED_SYSTEM_FLAG | \
    AUTH_ROOT_SYSTEM_FLAG | \
    TRUST_PEOPLE_SYSTEM_FLAG \
    )

#define wsz_MY_STORE            L"My"
#define wsz_ROOT_STORE          L"Root"
#define wsz_TRUST_STORE         L"Trust"
#define wsz_CA_STORE            L"CA"
#define wsz_USER_DS_STORE       L"UserDS"
#define wsz_TRUST_PUB_STORE     L"TrustedPublisher"
#define wsz_DISALLOWED_STORE    L"Disallowed"
#define wsz_AUTH_ROOT_STORE     L"AuthRoot"
#define wsz_TRUST_PEOPLE_STORE  L"TrustedPeople"
static LPCWSTR rgpwszPredefinedSystemStore[] = {
    wsz_MY_STORE,
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_USER_DS_STORE,
    wsz_TRUST_PUB_STORE,
    wsz_DISALLOWED_STORE,
    wsz_AUTH_ROOT_STORE,
    wsz_TRUST_PEOPLE_STORE
};
#define NUM_PREDEFINED_SYSTEM_STORE (sizeof(rgpwszPredefinedSystemStore) / \
                                        sizeof(rgpwszPredefinedSystemStore[0]))


#define wsz_REQUEST_STORE     L"Request"

#define DEFAULT_PHYSICAL_INDEX          0
#define AUTH_ROOT_PHYSICAL_INDEX        1
#define GROUP_POLICY_PHYSICAL_INDEX     2
#define LOCAL_MACHINE_PHYSICAL_INDEX    3
#define DS_USER_CERT_PHYSICAL_INDEX     4
#define LMGP_PHYSICAL_INDEX             5
#define ENTERPRISE_PHYSICAL_INDEX       6
#define NUM_PREDEFINED_PHYSICAL         7

#define DEFAULT_PHYSICAL_FLAG           (1 << DEFAULT_PHYSICAL_INDEX)
#define AUTH_ROOT_PHYSICAL_FLAG         (1 << AUTH_ROOT_PHYSICAL_INDEX)
#define GROUP_POLICY_PHYSICAL_FLAG      (1 << GROUP_POLICY_PHYSICAL_INDEX)
#define LOCAL_MACHINE_PHYSICAL_FLAG     (1 << LOCAL_MACHINE_PHYSICAL_INDEX)
#define DS_USER_CERT_PHYSICAL_FLAG      (1 << DS_USER_CERT_PHYSICAL_INDEX)
#define LMGP_PHYSICAL_FLAG              (1 << LMGP_PHYSICAL_INDEX)
#define ENTERPRISE_PHYSICAL_FLAG        (1 << ENTERPRISE_PHYSICAL_INDEX)

static LPCWSTR rgpwszPredefinedPhysical[NUM_PREDEFINED_PHYSICAL] = {
    CERT_PHYSICAL_STORE_DEFAULT_NAME,
    CERT_PHYSICAL_STORE_AUTH_ROOT_NAME,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,
};

#define NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG  0x1
#define REMOTABLE_SYSTEM_STORE_LOCATION_FLAG        0x2
#define SERIALIZED_SYSTEM_STORE_LOCATION_FLAG       0x4

typedef struct _SYSTEM_STORE_LOCATION_INFO {
    DWORD       dwFlags;
    DWORD       dwPredefinedSystemFlags;
    DWORD       dwPredefinedPhysicalFlags;
} SYSTEM_STORE_LOCATION_INFO, *PSYSTEM_STORE_LOCATION_INFO;


static const SYSTEM_STORE_LOCATION_INFO rgSystemStoreLocationInfo[] = {
    //  Not Defined                                     0
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    //  CERT_SYSTEM_STORE_CURRENT_USER_ID               1
    0,
    COMMON_SYSTEM_FLAGS | USER_DS_SYSTEM_FLAG,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ID               2
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        ENTERPRISE_PHYSICAL_FLAG,

    //  Not Defined                                     3
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
        REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG
};

#define NUM_SYSTEM_STORE_LOCATION   (sizeof(rgSystemStoreLocationInfo) / \
                                        sizeof(rgSystemStoreLocationInfo[0]))

#define CURRENT_USER_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    AUTH_ROOT_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG | \
    ENTERPRISE_PHYSICAL_FLAG \
    )

#define USERS_ROOT_PHYSICAL_FLAGS ( \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define MY_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG \
    )

#define USER_DS_PHYSICAL_FLAGS ( \
    DS_USER_CERT_PHYSICAL_FLAG \
    )

#define CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG \
    )

#define LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    GROUP_POLICY_PHYSICAL_FLAG | \
    ENTERPRISE_PHYSICAL_FLAG \
    )


#define sz_CRYPTNET_DLL             "cryptnet.dll"
#define sz_GetUserDsStoreUrl        "I_CryptNetGetUserDsStoreUrl"
typedef BOOL (WINAPI *PFN_GET_USER_DS_STORE_URL)(
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

#define wsz_USER_CERTIFICATE_ATTR   L"userCertificate"


#define PHYSICAL_NAME_INDEX     0
#define SYSTEM_NAME_INDEX       1
#define SERVICE_NAME_INDEX      2
#define USER_NAME_INDEX         2
#define COMPUTER_NAME_INDEX     3
#define SYSTEM_NAME_PATH_COUNT  4

#define DEFAULT_USER_NAME       L".Default"

typedef struct _SYSTEM_NAME_INFO {
    LPWSTR      rgpwszName[SYSTEM_NAME_PATH_COUNT];
    // non-NULL for relocated store. Note hKeyBase isn't opened and
    // doesn't need to be closed
    HKEY        hKeyBase;
} SYSTEM_NAME_INFO, *PSYSTEM_NAME_INFO;


typedef struct _REG_STORE REG_STORE, *PREG_STORE;

typedef struct _ILS_RESYNC_ENTRY {
    HANDLE              hOrigEvent;

    // hDupEvent is NULL for CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG
    HANDLE              hDupEvent;
    PREG_STORE          pRegStore;
} ILS_RESYNC_ENTRY, *PILS_RESYNC_ENTRY;

#define REG_CHANGE_INFO_TYPE    1
#define CU_GPT_CHANGE_INFO_TYPE 2
#define LM_GPT_CHANGE_INFO_TYPE 3

typedef struct _REGISTRY_STORE_CHANGE_INFO {
    // REG_CHANGE_INFO_TYPE
    DWORD               dwType;
    HANDLE              hChange;
    HANDLE              hRegWaitFor;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} REGISTRY_STORE_CHANGE_INFO, *PREGISTRY_STORE_CHANGE_INFO;

typedef struct _GPT_STORE_CHANGE_INFO {
    // CU_GPT_CHANGE_INFO_TYPE or LM_GPT_CHANGE_INFO_TYPE
    DWORD               dwType;
    HKEY                hKeyBase;       // not duplicated
    PREG_STORE          pRegStore;      // NULL for LM_GPT_CHANGE_INFO_TYPE

    HKEY                hPoliciesKey;
    HANDLE              hPoliciesEvent;
    HANDLE              hRegWaitFor;
    HANDLE              hGPNotificationEvent;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} GPT_STORE_CHANGE_INFO, *PGPT_STORE_CHANGE_INFO;

//+-------------------------------------------------------------------------
//  Registry Store Provider handle information
//
//  hMyNotifyChange is our internal NotifyChange event handle.
//--------------------------------------------------------------------------
struct _REG_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hMyNotifyChange;
    BOOL                fResync;            // when set, ignore callback deletes
    HKEY                hKey;
    DWORD               dwFlags;

    // Following field is applicable to the CurrentUser "Root" store
    BOOL                fProtected;

    // Following field is applicable when
    // CERT_REGISTRY_STORE_SERIALIZED_FLAG is set in dwFlags
    BOOL                fTouched;      // set for write, delete or set property

    union {
        // Following field is applicable when
        // CERT_REGISTRY_STORE_CLIENT_GPT_FLAG is set in dwFlags
        CERT_REGISTRY_STORE_CLIENT_GPT_PARA GptPara;

        // Following field is applicable when
        // CERT_REGISTRY_STORE_ROAMING_FLAG is set in dwFlags
        LPWSTR              pwszStoreDirectory;
    };

    union {
        // Following field is applicable for change notify of registry or
        // roaming file store
        PREGISTRY_STORE_CHANGE_INFO pRegistryStoreChangeInfo;

        // Following field is applicable for change notify of CU GPT store
        PGPT_STORE_CHANGE_INFO      pGptStoreChangeInfo;
    };
};


typedef struct _ENUM_SYSTEM_STORE_LOCATION_INFO {
    DWORD               dwFlags;
    LPCWSTR             pwszLocation;
} ENUM_SYSTEM_STORE_LOCATION_INFO, *PENUM_SYSTEM_STORE_LOCATION_INFO;

// Predefined crypt32.dll locations. MUST NOT BE REGISTERED!!!
static const ENUM_SYSTEM_STORE_LOCATION_INFO rgEnumSystemStoreLocationInfo[] = {
    CERT_SYSTEM_STORE_CURRENT_USER, L"CurrentUser",
    CERT_SYSTEM_STORE_LOCAL_MACHINE, L"LocalMachine",
    CERT_SYSTEM_STORE_CURRENT_SERVICE, L"CurrentService",
    CERT_SYSTEM_STORE_SERVICES, L"Services",
    CERT_SYSTEM_STORE_USERS, L"Users",
    CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, L"CurrentUserGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, L"LocalMachineGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, L"LocalMachineEnterprise"
};
#define ENUM_SYSTEM_STORE_LOCATION_CNT \
        (sizeof(rgEnumSystemStoreLocationInfo) / \
            sizeof(rgEnumSystemStoreLocationInfo[0]))

#define OPEN_SYSTEM_STORE_PROV_FUNC_SET     0
#define REGISTER_SYSTEM_STORE_FUNC_SET      1
#define UNREGISTER_SYSTEM_STORE_FUNC_SET    2
#define ENUM_SYSTEM_STORE_FUNC_SET          3
#define REGISTER_PHYSICAL_STORE_FUNC_SET    4
#define UNREGISTER_PHYSICAL_STORE_FUNC_SET  5
#define ENUM_PHYSICAL_STORE_FUNC_SET        6
#define FUNC_SET_COUNT                      7

static HCRYPTOIDFUNCSET rghFuncSet[FUNC_SET_COUNT];
static const LPCSTR rgpszFuncName[FUNC_SET_COUNT] = {
    CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC,
    CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
    CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC
};

typedef BOOL (WINAPI *PFN_REGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFN_ENUM_SYSTEM_STORE)(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    );

typedef BOOL (WINAPI *PFN_REGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    );
typedef BOOL (WINAPI *PFN_ENUM_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    );


//+-------------------------------------------------------------------------
//  Registry Store Provider Functions.
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static void * const rgpvRegStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RegStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RegStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
};
#define REG_STORE_PROV_FUNC_COUNT (sizeof(rgpvRegStoreProvFunc) / \
                                    sizeof(rgpvRegStoreProvFunc[0]))

STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

static void * const rgpvRootStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RootStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RootStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
};
#define ROOT_STORE_PROV_FUNC_COUNT (sizeof(rgpvRootStoreProvFunc) / \
                                    sizeof(rgpvRootStoreProvFunc[0]))

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        );

LPWSTR ILS_AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc
    )
{
    LPWSTR pwszDst;

    if (cchSrc < 0)
        cchSrc = wcslen(pwszSrc);
    if (NULL == (pwszDst = (LPWSTR) PkiNonzeroAlloc(
            (cchSrc + 1) * sizeof(WCHAR))))
        return NULL;
    if (0 < cchSrc)
        memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cchSrc * sizeof(WCHAR));
    pwszDst[cchSrc] = L'\0';
    return pwszDst;
}

extern
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+=========================================================================
//  Register WaitFor Forward Function References
//==========================================================================
STATIC void RegWaitForProcessAttach();
STATIC void RegWaitForProcessDetach();

//+=========================================================================
//  Client "GPT" Store Forward Function References
//==========================================================================
STATIC void GptStoreProcessAttach();
STATIC void GptStoreProcessDetach();

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    );

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    );

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC void FreeGptStoreChangeInfo(
    IN OUT PGPT_STORE_CHANGE_INFO *ppInfo
    );

STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

static inline BOOL IsClientGptStore(
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (!(CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY == dwStoreLocation ||
          CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+=========================================================================
//  Win95 Notify Store Forward Function References
//==========================================================================

// Following is created at ProcessAttach for Win95 clients
static HANDLE hWin95NotifyEvent = NULL;

STATIC void Win95StoreProcessAttach();
STATIC void Win95StoreProcessDetach();

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

//+=========================================================================
// Roaming Store Forward Function References
//==========================================================================
STATIC void RoamingStoreProcessAttach();
STATIC void RoamingStoreProcessDetach();

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    );

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG or
                            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    );

typedef BOOL (*PFN_ILS_OPEN_ELEMENT)(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    );

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================
STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    );

STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;
    DWORD   i;

    if (!I_ProtectedRootDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        for (i = 0; i < FUNC_SET_COUNT; i++) {
            if (NULL == (rghFuncSet[i] = CryptInitOIDFunctionSet(
                rgpszFuncName[i], 0)))
            goto CryptInitOIDFunctionSetError;
        }

        if (!Pki_InitializeCriticalSection(&ILS_CriticalSection))
            goto InitCritSectionError;

        if (NULL == (hTlsEnumPhysicalStoreDepth = I_CryptAllocTls())) {
            DeleteCriticalSection(&ILS_CriticalSection);
            goto CryptAllocTlsError;
        }

        RegWaitForProcessAttach();
        GptStoreProcessAttach();
        Win95StoreProcessAttach();
        RoamingStoreProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        RoamingStoreProcessDetach();
        Win95StoreProcessDetach();
        GptStoreProcessDetach();
        RegWaitForProcessDetach();
        DeleteCriticalSection(&ILS_CriticalSection);
        I_CryptFreeTls(hTlsEnumPhysicalStoreDepth, PkiFree);
        break;

    case DLL_THREAD_DETACH:
        PkiFree(I_CryptDetachTls(hTlsEnumPhysicalStoreDepth));
        break;
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    I_ProtectedRootDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptAllocTlsError)
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void ILS_BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the UNICODE ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
STATIC void WStrToBytes(
    IN const WCHAR wsz[MAX_HASH_NAME_LEN],
    OUT BYTE rgb[MAX_HASH_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    LPCWSTR pwsz = wsz;
    WCHAR wch;

    while (cb < MAX_HASH_LEN && (wch = *pwsz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (wch >= L'0' && wch <= L'9')
            b = (BYTE) (wch - L'0');
        else if (wch >= L'a' && wch <= L'f')
            b = (BYTE) (10 + wch - L'a');
        else if (wch >= L'A' && wch <= L'F')
            b = (BYTE) (10 + wch - L'A');
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = (BYTE)( b << 4);
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = (BYTE)( rgb[cb] | b);
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}

//+-------------------------------------------------------------------------
//  Lock and unlock registry functions
//--------------------------------------------------------------------------
static inline void LockRegStore(IN PREG_STORE pRegStore)
{
    EnterCriticalSection(&pRegStore->CriticalSection);
}
static inline void UnlockRegStore(IN PREG_STORE pRegStore)
{
    LeaveCriticalSection(&pRegStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Checks if current thread is doing a Resync. Other threads block until
//  the resync completes
//--------------------------------------------------------------------------
STATIC BOOL IsInResync(IN PREG_STORE pRegStore)
{
    BOOL fResync;

    LockRegStore(pRegStore);
    fResync = pRegStore->fResync;
    UnlockRegStore(pRegStore);
    return fResync;
}

//+=========================================================================
//  Low level context support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the certificate's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCertRegValueName(
        IN PCCERT_CONTEXT pCertContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get the CRL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCrlRegValueName(
        IN PCCRL_CONTEXT pCrlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCRLContextProperty(
            pCrlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get the CTL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCtlRegValueName(
        IN PCCTL_CONTEXT pCtlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCTLContextProperty(
            pCtlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    ILS_BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Convert's the context's SHA1 hash to UNICODE hex. Returns TRUE if the
//  same as the specified Uniocde reg name.
//--------------------------------------------------------------------------
STATIC BOOL IsValidRegValueNameForContext(
        IN DWORD dwContextType,
        IN const void *pvContext,
        IN const WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BOOL fResult;
    WCHAR wszContextHash[MAX_CERT_REG_VALUE_NAME_LEN];

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            fResult = GetCertRegValueName(
                (PCCERT_CONTEXT) pvContext, wszContextHash);
            break;
        case CERT_STORE_CRL_CONTEXT:
            fResult = GetCrlRegValueName(
                (PCCRL_CONTEXT) pvContext, wszContextHash);
            break;
        case CERT_STORE_CTL_CONTEXT:
            fResult = GetCtlRegValueName(
                (PCCTL_CONTEXT) pvContext, wszContextHash);
            break;
        default:
            goto InvalidContext;
    }

    if (!fResult)
        goto GetContextHashError;

    if (0 != _wcsicmp(wszRegName, wszContextHash))
        goto InvalidRegValueNameForContext;

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidContext, E_UNEXPECTED)
TRACE_ERROR(GetContextHashError)
SET_ERROR(InvalidRegValueNameForContext, ERROR_BAD_PATHNAME)
}

//+-------------------------------------------------------------------------
//  Deletes the context from the store.
//--------------------------------------------------------------------------
STATIC void DeleteContextFromStore(
        IN DWORD dwContextType,
        IN const void *pvContext
        )
{
    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            CertDeleteCertificateFromStore((PCCERT_CONTEXT) pvContext);
            break;
        case CERT_STORE_CRL_CONTEXT:
            CertDeleteCRLFromStore((PCCRL_CONTEXT) pvContext);
            break;
        case CERT_STORE_CTL_CONTEXT:
            CertDeleteCTLFromStore((PCCTL_CONTEXT) pvContext);
            break;
        default:
            break;
    }
}

//+-------------------------------------------------------------------------
//  Frees the context.
//--------------------------------------------------------------------------
STATIC void FreeContext(
        IN DWORD dwContextType,
        IN const void *pvContext
        )
{
    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            CertFreeCertificateContext((PCCERT_CONTEXT) pvContext);
            break;
        case CERT_STORE_CRL_CONTEXT:
            CertFreeCRLContext((PCCRL_CONTEXT) pvContext);
            break;
        case CERT_STORE_CTL_CONTEXT:
            CertFreeCTLContext((PCCTL_CONTEXT) pvContext);
            break;
        default:
            break;
    }
}

//+=========================================================================
//  Low level registry support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  For CERT_STORE_BACKUP_RESTORE_FLAG, enable backup and restore
//  privileges.
//--------------------------------------------------------------------------
void ILS_EnableBackupRestorePrivileges()
{
    IPR_EnableSecurityPrivilege(SE_BACKUP_NAME);
    IPR_EnableSecurityPrivilege(SE_RESTORE_NAME);
}

// LastError can get globbered when doing remote registry access
void
ILS_CloseRegistryKey(
    IN HKEY hKey
    )
{
    if (hKey) {
        DWORD dwErr = GetLastError();
        LONG RegCloseKeyStatus;
        RegCloseKeyStatus = RegCloseKey(hKey);
        assert(ERROR_SUCCESS == RegCloseKeyStatus);
        SetLastError(dwErr);
    }
}

// Ensure LastError is preserved
void
ILS_CloseHandle(
    IN HANDLE h
    )
{
    if (h) {
        DWORD dwErr = GetLastError();

        CloseHandle(h);

        SetLastError(dwErr);
    }
}

STATIC BOOL WriteDWORDValueToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValue
    )
{
    LONG err;
    if (ERROR_SUCCESS == (err = RegSetValueExU(
            hKey,
            pwszValueName,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD))))
        return TRUE;
    else {
        SetLastError((DWORD) err);
        return FALSE;
    }
}

BOOL
ILS_ReadDWORDValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD *pdwValue
    )
{
    BOOL fResult;
    LONG err;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(DWORD);

    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue))) goto RegQueryValueError;
    if (dwType != REG_DWORD || cbValue != sizeof(DWORD))
        goto InvalidRegistryValue;
    fResult = TRUE;
CommonReturn:
    *pdwValue = dwValue;
    return fResult;
ErrorReturn:
    dwValue = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
}

// Ensure a binary value that may contain a LPCWSTR is NULL terminated.
// Always adds a NULL terminator not included in the returned cbValue.
//
// May return an allocated pbValue with a cbValue = 0.
BOOL
ILS_ReadBINARYValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue
    )
{
    BOOL fResult;
    LONG err;
    DWORD dwType;
    BYTE *pbValue = NULL;
    DWORD cbValue = 0;
    DWORD cbAllocValue;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_BINARY)
        goto InvalidRegistryValue;
    cbAllocValue = cbValue + 3;
    if (NULL == (pbValue = (BYTE *) PkiNonzeroAlloc(cbAllocValue)))
        goto OutOfMemory;
    if (0 < cbValue) {
        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hKey,
                pwszValueName,
                NULL,       // pdwReserved
                &dwType,
                pbValue,
                &cbValue))) goto RegQueryValueError;
    }
    assert(cbAllocValue >= cbValue + 3);

    // Ensure an LPWSTR is null terminated
    memset(pbValue + cbValue, 0, 3);

    fResult = TRUE;
CommonReturn:
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbValue);
    pbValue = NULL;
    cbValue = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get and allocate the REG_SZ value
//--------------------------------------------------------------------------
LPWSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName
    )
{
    LONG err;
    DWORD dwType;
    LPWSTR pwszValue = NULL;
    DWORD cbValue = 0;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue < sizeof(WCHAR))
        goto InvalidRegistryValue;
    if (NULL == (pwszValue = (LPWSTR) PkiNonzeroAlloc(cbValue)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pwszValue,
            &cbValue))) goto RegQueryValueError;
CommonReturn:
    return pwszValue;
ErrorReturn:
    PkiFree(pwszValue);
    pwszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

LPSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCSTR pszValueName
    )
{
    LONG err;
    DWORD dwType;
    LPSTR pszValue = NULL;
    DWORD cbValue = 0;

    err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue == 0)
        goto InvalidRegistryValue;
    if (NULL == (pszValue = (LPSTR) PkiNonzeroAlloc(cbValue)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pszValue,
            &cbValue))) goto RegQueryValueError;
CommonReturn:
    return pszValue;
ErrorReturn:
    PkiFree(pszValue);
    pszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

STATIC BOOL GetSubKeyInfo(
    IN HKEY hKey,
    OUT OPTIONAL DWORD *pcSubKeys,
    OUT OPTIONAL DWORD *pcchMaxSubKey = NULL
    )
{
    BOOL fResult;
    LONG err;
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            pcSubKeys,
            pcchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            ))) goto RegQueryInfoKeyError;
    fResult = TRUE;

CommonReturn:
    // For Win95 Remote Registry Access:: returns half of the cch
    if (pcchMaxSubKey && *pcchMaxSubKey)
        *pcchMaxSubKey = (*pcchMaxSubKey + 1) * 2 + 2;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pcSubKeys)
        *pcSubKeys = 0;
    if (pcchMaxSubKey)
        *pcchMaxSubKey = 0;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
}

//+-------------------------------------------------------------------------
//  Open the SubKey with support for backup/restore
//--------------------------------------------------------------------------
STATIC LONG WINAPI OpenHKCUKeyExU (
    HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG err;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
        DWORD dwDisposition;

        err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                NULL,
                NULL,
                REG_OPTION_BACKUP_RESTORE,
                samDesired,
                NULL,
                phkResult,
                &dwDisposition
                );
    } else {
        err = RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                samDesired,
                phkResult
                );
    }

    return err;
}

//+-------------------------------------------------------------------------
//  Open the SubKey.
//
//  dwFlags:
//      CERT_STORE_READONLY_FLAG
//      CERT_STORE_OPEN_EXISTING_FLAG
//      CERT_STORE_CREATE_NEW_FLAG
//      CERT_STORE_BACKUP_RESTORE_FLAG
//--------------------------------------------------------------------------
STATIC HKEY OpenSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
    LONG err;
    HKEY hSubKey;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
        DWORD dwDisposition;
        REGSAM samDesired;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (NULL == pwszSubKeyName)
            pwszSubKeyName = L"";

        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_BACKUP_RESTORE,
                samDesired,
                NULL,                   // lpSecurityAttributes
                &hSubKey,
                &dwDisposition))) {
            if (dwFlags &
                    (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG))
                err = ERROR_FILE_NOT_FOUND;
            goto RegCreateBackupRestoreKeyError;
        }

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
            if (REG_CREATED_NEW_KEY != dwDisposition) {
                RegCloseKey(hSubKey);
                goto ExistingSubKey;
            }
        }

        goto CommonReturn;
    }

    if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
        // First check if SubKey already exists
        if (hSubKey = OpenSubKey(
                hKey,
                pwszSubKeyName,
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG |
                    CERT_STORE_READONLY_FLAG
                )) {
            RegCloseKey(hSubKey);
            goto ExistingSubKey;
        } else if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenNewSubKeyError;
    }

    if (dwFlags & (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG)) {
        REGSAM samDesired;
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                samDesired,
                &hSubKey)))
            goto RegOpenKeyError;
    } else {
        DWORD dwDisposition;
        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                   // lpSecurityAttributes
                &hSubKey,
                &dwDisposition)))
            goto RegCreateKeyError;
    }

CommonReturn:
    return hSubKey;
ErrorReturn:
    hSubKey = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateBackupRestoreKeyError, err)
SET_ERROR(ExistingSubKey, ERROR_FILE_EXISTS)
TRACE_ERROR(OpenNewSubKeyError)
SET_ERROR_VAR(RegOpenKeyError, err)
SET_ERROR_VAR(RegCreateKeyError, err)
}


STATIC BOOL RecursiveDeleteSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BOOL fResult;
    LONG err;

    while (TRUE) {
        HKEY hSubKey;
        DWORD cSubKeys;
        DWORD cchMaxSubKey;
        BOOL fDidDelete;

        if (ERROR_SUCCESS != OpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                dwFlags,
                KEY_ALL_ACCESS,
                &hSubKey))
            break;

        GetSubKeyInfo(
            hSubKey,
            &cSubKeys,
            &cchMaxSubKey
            );

        fDidDelete = FALSE;
        if (cSubKeys && cchMaxSubKey) {
            LPWSTR pwszEnumSubKeyName;
            cchMaxSubKey++;

            if (pwszEnumSubKeyName = (LPWSTR) PkiNonzeroAlloc(
                    cchMaxSubKey * sizeof(WCHAR))) {
                if (ERROR_SUCCESS == RegEnumKeyExU(
                        hSubKey,
                        0,
                        pwszEnumSubKeyName,
                        &cchMaxSubKey,
                        NULL,               // lpdwReserved
                        NULL,               // lpszClass
                        NULL,               // lpcchClass
                        NULL                // lpftLastWriteTime
                        ))
                    fDidDelete = RecursiveDeleteSubKey(
                        hSubKey, pwszEnumSubKeyName, dwFlags);
                PkiFree(pwszEnumSubKeyName);
            }
        }
        RegCloseKey(hSubKey);
        if (!fDidDelete)
            break;
    }

    if (ERROR_SUCCESS != (err = RegDeleteKeyU(hKey, pwszSubKeyName)))
        goto RegDeleteKeyError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegDeleteKeyError, err)
}

//+=========================================================================
//  Trusted Publisher Registry Functions
//==========================================================================

STATIC BOOL OpenKeyAndReadDWORDValueFromRegistry(
    IN BOOL fMachine,
    IN LPCWSTR pwszRegPath,
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    LONG err;

    if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
            fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
            pwszRegPath,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            )))
        goto OpenKeyForDWORDValueError;

    if (!ILS_ReadDWORDValueFromRegistry(
            hKey,
            pwszValueName,
            pdwValue
            )) goto ReadDWORDValueError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    *pdwValue = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(OpenKeyForDWORDValueError, err)
TRACE_ERROR(ReadDWORDValueError)
}


//+-------------------------------------------------------------------------
//  On the Nth iteration these Safer Grade School programmers decided that the
//  value should be the 'OR' of the 3 different locations: HKLM\GPO, HKCU\GPO,
//  HKLM\Registry.
//--------------------------------------------------------------------------
BOOL
I_CryptReadTrustedPublisherDWORDValueFromRegistry(
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    )
{
    BOOL fResult = FALSE;
    DWORD dwValue = 0;
    DWORD dwRegValue = 0;

    if (OpenKeyAndReadDWORDValueFromRegistry(
            TRUE,                                       // fMachine
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    if (OpenKeyAndReadDWORDValueFromRegistry(
            FALSE,                                      // fMachine
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    if (OpenKeyAndReadDWORDValueFromRegistry(
            TRUE,                                       // fMachine
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    *pdwValue = dwValue;
    return fResult;
}

//+=========================================================================
//  Win95 Registry Functions
//
//  Note, as of 10/17/97 the following is also done on NT to allow
//  registry hive roaming from NT to Win95 systems.
//
//  Certs, CRLs and CTLs are stored in SubKeys instead of as Key values.
//
//  Note: Win95 has the following registry limitations:
//   - Max single key value is 16K
//   - Max total values per key is 64K
//
//  For WIN95, write each cert, CRL, CTL to its own key when the
//  above limitations are exceeded. If encoded blob exceeds 12K, partition
//  and write to multiple SubKeys. Blobs are written to values named
//  "Blob". Partitioned blobs, have "BlobCount" and "BlobLength" values and
//  SubKeys named "Blob0", "Blob1", "Blob2" ... .
//
//  The IE4.0 version of crypt32 wrote the blob to a "File" if the blob
//  exceeded 12K. For backwards compatibility, continue to read "File" based
//  blobs. On write enabled, non-remote opens, "File" blobs are moved to
//  "Blob0", ... SubKeys and the file is deleted.
//
//  If CERT_REGISTRY_STORE_SERIALIZED_FLAG is set when the registry store
//  is opened, then, the entire store resides in a partitioned blob under the
//  "Serialized" subkey.
//==========================================================================
#define KEY_BLOB_VALUE_NAME             L"Blob"
#define KEY_FILE_VALUE_NAME             L"File"
#define KEY_BLOB_COUNT_VALUE_NAME       L"BlobCount"
#define KEY_BLOB_LENGTH_VALUE_NAME      L"BlobLength"
#define KEY_BLOB_N_SUBKEY_PREFIX        "Blob"
#define KEY_BLOB_N_SUBKEY_PREFIX_LENGTH 4
#define SYSTEM_STORE_SUBDIR             L"SystemCertificates"
#define FILETIME_ASCII_HEX_LEN          (2 * sizeof(FILETIME) + 1)
#define MAX_KEY_BLOB_VALUE_LEN          0x3000
#define MAX_NEW_FILE_CREATE_ATTEMPTS    100

#define SERIALIZED_SUBKEY_NAME          L"Serialized"


//+-------------------------------------------------------------------------
//  Read and allocate the element bytes by reading the file pointed to
//  by the SubKey's "File" value
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyFileElementFromRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    LPWSTR pwszFilename = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (NULL == (pwszFilename = ILS_ReadSZValueFromRegistry(
            hSubKey, KEY_FILE_VALUE_NAME)))
        goto GetKeyFilenameError;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
              NULL                    // hTemplateFile
              )))
        goto CreateFileError;

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(GetKeyFilenameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Read as multiple SubKeys containing the element bytes. The SubKeys
//  are named Blob0, Blob1, Blob2, ... BlobN.
//  Each BlobN SubKey has a value named "Blob" containing the bytes to be read.
//
//  The passed in SubKey is expected to have 2 values:
//      BlobCount - # of BlobN SubKeys
//      BlobLength - total length of all the concatenated Blob Subkey bytes
//
//  A single allocated element byte array is returned.
//--------------------------------------------------------------------------
STATIC BOOL ReadMultipleKeyBlobsFromRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD BlobCount;
    DWORD BlobLength;
    DWORD i;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            &BlobCount
            );
    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            &BlobLength
            );

    if (0 == BlobCount || 0 == BlobLength)
        goto NoMultipleKeyBlobs;

    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(BlobLength)))
        goto OutOfMemory;

    cbElement = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwType;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);

        if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
            DWORD dwDisposition;

            if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                    hSubKey,
                    szBlobN,
                    0,                      // dwReserved
                    NULL,                   // lpClass
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_READ,
                    NULL,                   // lpSecurityAttributes
                    &hBlobKey,
                    &dwDisposition)))
                goto OpenBackupRestoreBlobNError;
        } else {
            if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                    hSubKey,
                    szBlobN,
                    0,                  // dwReserved
                    KEY_READ,
                    &hBlobKey)))
                goto OpenBlobNError;
        }

        cbData = BlobLength - cbElement;
        if (0 == cbData)
            goto ExtraMultipleKeyBlobs;

        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,       // pdwReserved
                &dwType,
                pbElement + cbElement,
                &cbData)))
            goto RegQueryValueError;
        if (dwType != REG_BINARY)
            goto InvalidRegistryValue;

        cbElement += cbData;
        if (cbElement > BlobLength)
            goto UnexpectedError;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    if (cbElement != BlobLength)
        goto MissingMultipleKeyBlobsBytes;

    assert(NULL == hBlobKey);

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    ILS_CloseRegistryKey(hBlobKey);
    fResult = FALSE;
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR(NoMultipleKeyBlobs, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(OpenBlobNError, err)
SET_ERROR_VAR(OpenBackupRestoreBlobNError, err)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
SET_ERROR(ExtraMultipleKeyBlobs, CRYPT_E_FILE_ERROR)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(MissingMultipleKeyBlobsBytes, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Write as multiple BlobN SubKeys containing the element bytes.
//
//  See ReadMultipleKeyBlobsFromRegistry() for details.
//--------------------------------------------------------------------------
STATIC BOOL WriteMultipleKeyBlobsToRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    DWORD BlobCount = 0;
    DWORD BlobLength;
    DWORD i;
    DWORD dwErr;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    if (0 == cbElement)
        goto UnexpectedError;
    BlobCount = cbElement / MAX_KEY_BLOB_VALUE_LEN;
    if (cbElement % MAX_KEY_BLOB_VALUE_LEN)
        BlobCount++;

    BlobLength = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwDisposition;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                hSubKey,
                szBlobN,
                0,                      // dwReserved
                NULL,                   // lpClass
                (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,                   // lpSecurityAttributes
                &hBlobKey,
                &dwDisposition))) goto RegCreateKeyError;

        assert(cbElement > BlobLength);
        cbData = cbElement - BlobLength;
        if (cbData > MAX_KEY_BLOB_VALUE_LEN)
            cbData = MAX_KEY_BLOB_VALUE_LEN;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement + BlobLength,
                cbData))) goto RegSetValueError;

        BlobLength += cbData;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    assert(BlobLength == cbElement);

    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            BlobCount))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            BlobLength))
        goto WriteDWORDError;

    assert(NULL == hBlobKey);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    dwErr = GetLastError();

    ILS_CloseRegistryKey(hBlobKey);
    for (i = 0; i < BlobCount; i++) {
        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        RegDeleteKeyA(hSubKey, szBlobN);
    }
    RegDeleteValueU(hSubKey, KEY_BLOB_COUNT_VALUE_NAME);
    RegDeleteValueU(hSubKey, KEY_BLOB_LENGTH_VALUE_NAME);

    fResult = FALSE;
    SetLastError(dwErr);
    goto CommonReturn;

SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteDWORDError)
}

//+-------------------------------------------------------------------------
//  If the SubKey has a "File" value, delete the file.
//
//  This is only applicable to obscure IE 4.0 cases.
//--------------------------------------------------------------------------
STATIC void DeleteKeyFile(
    IN HKEY hKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    HKEY hSubKey = NULL;

    if (ERROR_SUCCESS == OpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            dwFlags,
            KEY_ALL_ACCESS,
            &hSubKey
            )) {
        LPWSTR pwszFilename;
        if (pwszFilename = ILS_ReadSZValueFromRegistry(hSubKey,
                KEY_FILE_VALUE_NAME)) {
            SetFileAttributesU(pwszFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFileU(pwszFilename);
            PkiFree(pwszFilename);
        }
        RegDeleteValueU(hSubKey, KEY_FILE_VALUE_NAME);
        RegCloseKey(hSubKey);
    }
}

//+-------------------------------------------------------------------------
//  Get the context by either getting the SubKey's "Blob" value or getting
//  the SubKey's "BlobCount" and "BlobLength" values and then
//  reading and concatenating multiple Blob<N> SubKeys containing the bytes or
//  reading the file pointed to by the SubKey's "File" value.
//
//  If the "File" value is found and used, then, migrate to being stored
//  in the registry using multiple Blob<N> SubKeys.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyElementFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN DWORD dwFlags,
        OUT BYTE **ppbElement,
        OUT DWORD *pcbElement
        )
{
    LONG err;
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    HKEY hSubKey = NULL;

    if (ERROR_SUCCESS != (err = OpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            dwFlags,
            KEY_READ,
            &hSubKey)))
        goto OpenHKCUKeyError;

    fResult = ILS_ReadBINARYValueFromRegistry(hSubKey, KEY_BLOB_VALUE_NAME,
         &pbElement, &cbElement);
    if (!fResult || 0 == cbElement) {
        PkiFree(pbElement);

        fResult = ReadMultipleKeyBlobsFromRegistry(hSubKey, dwFlags, &pbElement,
            &cbElement);
        if (!fResult && 0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For backwards compatibility with IE4.0. See if it exists
            // in a file
            fResult = ReadKeyFileElementFromRegistry(hSubKey, dwFlags,
                &pbElement, &cbElement);
            if (fResult && 0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
                // Move from the file back to the registry.
                if (WriteMultipleKeyBlobsToRegistry(hSubKey, dwFlags, pbElement,
                        cbElement))
                    DeleteKeyFile(hKey, wszSubKeyName, dwFlags);
            }
        }

        if (!fResult)
            goto ReadKeyElementError;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;

    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR_VAR(OpenHKCUKeyError, err)
TRACE_ERROR(ReadKeyElementError)
}

STATIC BOOL ReadKeyFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN HCERTSTORE hCertStore,
        IN DWORD dwContextTypeFlags,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD dwContextType = 0;
    const void *pvContext = NULL;

    if (!ReadKeyElementFromRegistry(
            hKey,
            wszSubKeyName,
            dwFlags,
            &pbElement,
            &cbElement
            ))
        goto ErrorReturn;

    if (!CertAddSerializedElementToStore(
            hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            dwContextTypeFlags,
            &dwContextType,
            &pvContext
            ))
        goto AddSerializedElementError;

    if (IsValidRegValueNameForContext(
            dwContextType,
            pvContext,
            wszSubKeyName
            ))
        FreeContext(dwContextType, pvContext);
    else {
        DeleteContextFromStore(dwContextType, pvContext);
        goto InvalidRegValueNameForContext;
    }

    CertPerfIncrementRegElementReadCount();

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AddSerializedElementError)
TRACE_ERROR(InvalidRegValueNameForContext)
}


//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry by reading as
//  SubKeys and not Key values as done by OpenFromRegistry.
//
//  If CERT_STORE_DELETE_FLAG is set, delete the file, if stored there.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL OpenKeysFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKey,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;
        err = RegEnumKeyExU(
            hKey,
            i,
            wszSubKeyName,
            &cchSubKeyName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err)
            continue;
        else if (dwFlags & CERT_STORE_DELETE_FLAG) {
            if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
                DeleteKeyFile(hKey, wszSubKeyName, dwFlags);
        } else
            // Ignore any read errors
            ReadKeyFromRegistry(
                hKey,
                wszSubKeyName,
                hCertStore,
                CERT_STORE_ALL_CONTEXT_FLAG,
                dwFlags
                );
    }
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSubKeyInfoError)
}

#if 0
//
// The following was done in IE4.0 on Win95
//

//+-------------------------------------------------------------------------
//  Create the filename to contain the encoded element. The filename will
//  be something like:
//      C:\Windows\SystemCertificates\
//          00112233445566778899AABBCCDDEEFF00112233.0011223344556677
//  Where:
//      C:\Windows              - obtained via GetWindowsDirectory
//      SystemCertificates      - subdirectory containing all file elements
//      00112233445566778899AABBCCDDEEFF00112233
//                              - wszSubKeyName (ascii hex sha1)
//      0011223344556677        - ascii hex of current filetime
//
//
//  In addition to creating the filename, also creates the
//  "SystemCertificates" directory under C:\Windows.
//--------------------------------------------------------------------------
STATIC LPWSTR CreateKeyFilename(
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN LPFILETIME pft
    )
{
    LPWSTR pwszWindowsDir = NULL;
    DWORD cchWindowsDir;
    WCHAR rgwc[1];

    BYTE rgbft[sizeof(FILETIME)];
    WCHAR wszft[FILETIME_ASCII_HEX_LEN];

    LPWSTR pwszFilename = NULL;
    DWORD cchFilename;

    if (0 == (cchWindowsDir = GetWindowsDirectoryU(rgwc, 1)))
        goto GetWindowsDirError;
    cchWindowsDir++;    // bump to include null terminator
    if (NULL == (pwszWindowsDir = (LPWSTR) PkiNonzeroAlloc(
            cchWindowsDir * sizeof(WCHAR))))
        goto OutOfMemory;
    if (0 == GetWindowsDirectoryU(pwszWindowsDir, cchWindowsDir))
        goto GetWindowsDirError;

    // Convert filetime to ascii hex. First reverse the filetime bytes.
    memcpy(rgbft, pft, sizeof(rgbft));
    PkiAsn1ReverseBytes(rgbft, sizeof(rgbft));
    ILS_BytesToWStr(sizeof(rgbft), rgbft, wszft);

    // Get total length of filename and allocate
    cchFilename = cchWindowsDir + 1 +
        wcslen(SYSTEM_STORE_SUBDIR) + 1 +
        MAX_CERT_REG_VALUE_NAME_LEN + 1 +
        FILETIME_ASCII_HEX_LEN + 1;
    if (NULL == (pwszFilename = (LPWSTR) PkiNonzeroAlloc(
            cchFilename * sizeof(WCHAR))))
        goto OutOfMemory;

    // Create C:\Windows\SystemCertificates directory if it doesn't already
    // exist
    wcscpy(pwszFilename, pwszWindowsDir);
    cchWindowsDir = wcslen(pwszWindowsDir);
    if (cchWindowsDir && L'\\' != pwszWindowsDir[cchWindowsDir - 1])
        wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, SYSTEM_STORE_SUBDIR);
    if (0xFFFFFFFF == GetFileAttributesU(pwszFilename)) {
        if (!CreateDirectoryU(
            pwszFilename,
            NULL            // lpsa
            )) goto CreateDirError;
    }

    // Append \<AsciiHexSubKeyName>.<AsciiHexFileTime> to the above directory
    // name to complete the filename string
    wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, wszSubKeyName);
    wcscat(pwszFilename, L".");
    wcscat(pwszFilename, wszft);

CommonReturn:
    PkiFree(pwszWindowsDir);
    return pwszFilename;
ErrorReturn:
    PkiFree(pwszFilename);
    pwszFilename = NULL;
    goto CommonReturn;
TRACE_ERROR(GetWindowsDirError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateDirError)
}

//+-------------------------------------------------------------------------
//  Write the bytes to a a file and update the SubKey's "File" value to
//  point to.
//
//  This code is here to show what was done in IE4.0.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyFileElementToRegistry(
    IN HKEY hSubKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszFilename = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD i;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    for (i = 0; i < MAX_NEW_FILE_CREATE_ATTEMPTS; i++) {
        DWORD cbBytesWritten;

        if (NULL == (pwszFilename = CreateKeyFilename(wszSubKeyName, &ft)))
            goto CreateKeyFilenameError;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFilename,
                  GENERIC_WRITE,
                  0,                        // fdwShareMode
                  NULL,                     // lpsa
                  CREATE_NEW,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                      // hTemplateFile
                  ))) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto CreateFileError;
            else {
                PkiFree(pwszFilename);
                pwszFilename = NULL;
                *((_int64 *) &ft) += 1;
                continue;
            }
        }

        if (!WriteFile(
                hFile,
                pbElement,
                cbElement,
                &cbBytesWritten,
                NULL            // lpOverlapped
                )) goto WriteFileError;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        if (!SetFileAttributesU(pwszFilename,
                FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ))
            goto SetFileAttributesError;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_FILE_VALUE_NAME,
                NULL,
                REG_SZ,
                (BYTE *) pwszFilename,
                (wcslen(pwszFilename) + 1) * sizeof(WCHAR))))
            goto RegSetValueError;
        else
            goto SuccessReturn;
    }

    goto ExceededMaxFileCreateAttemptsError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    PkiFree(pwszFilename);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(CreateKeyFilenameError)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
TRACE_ERROR(SetFileAttributesError)
SET_ERROR(ExceededMaxFileCreateAttemptsError, CRYPT_E_FILE_ERROR)

}

#endif  // end of IE4.0 "File" support

//+-------------------------------------------------------------------------
//  If the length of the element is <= MAX_KEY_BLOB_VALUE_LEN, then,
//  write it as the SubKey's "Blob" value. Otherwise, write it as multiple
//  SubKeys each containing a "Blob" value no larger than
//  MAX_KEY_BLOB_VALUE_LEN.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyToRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN DWORD dwFlags,       //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
            hKey,
            wszSubKeyName,
            NULL,
            NULL,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hSubKey,
            &dwDisposition))) goto RegCreateKeyError;

    if (MAX_KEY_BLOB_VALUE_LEN >= cbElement) {
        // Write as a single "Blob" value
        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement,
                cbElement))) goto RegSetValueError;
    } else {
        // Write as a multiple Blob<N> SubKeys
        if (!WriteMultipleKeyBlobsToRegistry(
                hSubKey, dwFlags, pbElement, cbElement))
            goto WriteMultipleKeyBlobsError;
//        if (!WriteKeyFileElementToRegistry(wszSubKeyName, hSubKey, dwFlags, pbElement, cbElement))
//            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteMultipleKeyBlobsError)
}

//+=========================================================================
//  Registry Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  First attempt to read as Key's value. If that fails for Win95, then,
//  read as a value in one or more SubKeys or as a
//  file with a SubKey pointing to it.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
BOOL
ILS_ReadElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    LONG err;
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD dwType;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (pwszContextName) {
        if (NULL == (hSubKey = OpenSubKey(
                hKey,
                pwszContextName,
                dwFlags | CERT_STORE_READONLY_FLAG
                )))
            goto OpenSubKeyError;
    } else
        hSubKey = hKey;

    err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbElement);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err)) {
        fResult = ReadKeyElementFromRegistry(
            hSubKey,
            wszHashName,
            dwFlags,
            &pbElement,
            &cbElement
            );
        goto CommonReturn;
    }
    if (dwType != REG_BINARY || cbElement == 0)
        goto InvalidRegistryValue;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            pbElement,
            &cbElement))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pwszContextName)
        ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  First delete as the Key's value. Then, for Win95 also delete as the
//  Key's SubKey and possibly file.
//--------------------------------------------------------------------------
BOOL
ILS_DeleteElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSubKeyError;

    RegDeleteValueU(hSubKey, wszHashName);
    if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        DeleteKeyFile(hSubKey, wszHashName, dwFlags);
    fResult = RecursiveDeleteSubKey(hSubKey, wszHashName, dwFlags);

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  If the length of the element is less than the maximum allowed Win95 value
//  length, then, attempt to set the wszRegName SubKey's "Blob" value as
//  a single registry API call. Versus, first doing registry deletes.
//--------------------------------------------------------------------------
STATIC BOOL AtomicUpdateRegistry(
        IN HKEY hKey,
        IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
        IN DWORD dwFlags,       // CERT_STORE_BACKUP_RESTORE_FLAG may be set
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;
    DWORD dwDisposition = 0;

    if (MAX_KEY_BLOB_VALUE_LEN < cbElement)
        return FALSE;

    // In case the element still exists as a wszHashName value instead of as a
    // wszHashName subkey
    RegDeleteValueU(hKey, wszHashName);

    if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
            hKey,
            wszHashName,
            NULL,
            NULL,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hSubKey,
            &dwDisposition))) goto AtomicRegCreateKeyError;

    if (REG_OPENED_EXISTING_KEY == dwDisposition) {
        DWORD dwType;
        DWORD cbData;

        assert(hSubKey);
        err = RegQueryValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbData);
        if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
            // Most likely persisted as partioned "Blob0", "Blob1" values.
            // These can't be updated in a single atomic set value.
            goto AtomicQueryValueError;

        // "Blob" value exists. We can do an atomic update.
    }
    // else
    //  REG_CREATED_NEW_KEY

    assert(hSubKey);
    // Either update or create the "Blob" value
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) goto AtomicRegSetValueError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(AtomicRegCreateKeyError, err)
SET_ERROR_VAR(AtomicQueryValueError, err)
SET_ERROR_VAR(AtomicRegSetValueError, err)
}

//+-------------------------------------------------------------------------
//  First attempt as an atomic registry update of the wszRegName's "Blob"
//  value. If that fails, then, delete everything and write as either a
//  single or partitioned blob value under the wszRegName's subkey.
//--------------------------------------------------------------------------
BOOL
ILS_WriteElementToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       //  CERT_REGISTRY_STORE_REMOTE_FLAG or
                            //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // See if we can do the update as a single, atomic, set registry value API
    // call.
    if (AtomicUpdateRegistry(
            hSubKey,
            wszHashName,
            dwFlags,
            pbElement,
            cbElement
            )) {
        fResult = TRUE;
        goto CommonReturn;
    }

    // If any version exists for this guy, get rid of it.
    ILS_DeleteElementFromRegistry(hKey, pwszContextName, wszHashName,
        dwFlags);

#if 1
    fResult = WriteKeyToRegistry(hSubKey, wszHashName, dwFlags,
        pbElement, cbElement);
#else
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            wszHashName,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) {
        // Win95 returns:
        //  ERROR_INVALID_PARAMETER if exceeded single SubKey value byte
        //      limitation
        //  ERROR_OUTOFMEMORY if exceeded total SubKey values byte
        //      limitation
        if (ERROR_INVALID_PARAMETER == err ||
                ERROR_OUTOFMEMORY == err ||
                MAX_KEY_BLOB_VALUE_LEN < cbElement)
            return WriteKeyToRegistry(hSubKey, wszHashName, dwFlags,
                pbElement, cbElement);

         goto RegSetValueError;
    }
    fResult = TRUE;
#endif

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
#if 1
#else
SET_ERROR_VAR(RegSetValueError, err)
#endif
}

BOOL
ILS_OpenAllElementsFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    dwFlags |= CERT_STORE_READONLY_FLAG;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hSubKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszHashName[MAX_HASH_NAME_LEN];
        DWORD cchHashName = MAX_HASH_NAME_LEN;
        BYTE *pbElement;
        DWORD cbElement;

        err = RegEnumKeyExU(
            hSubKey,
            i,
            wszHashName,
            &cchHashName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err)
            continue;

        if (ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,                   // pwszContextName
                wszHashName,
                dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG,
                &pbElement,
                &cbElement
                )) {
            fResult = pfnOpenElement(
                wszHashName,
                pbElement,
                cbElement,
                pvArg
                );

            PkiFree(pbElement);
            if (!fResult)
                goto CommonReturn;
        }
    }
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//
//  If any contexts are persisted as values instead of as subkeys, then,
//  if not READONLY, migrate from values to subkeys.
//--------------------------------------------------------------------------
STATIC BOOL OpenFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKeyT,
    IN DWORD dwFlags
    )
{
    BOOL    fOK = TRUE;
    LONG    err;
    DWORD   cValues, cchValuesNameMax, cbValuesMax;
    WCHAR * wszValueName = NULL;
    DWORD   i, dwType, cchHash;
    BYTE  * pbElement = NULL;
    DWORD   cbElement;

    // see how many and how big the registry is
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKeyT,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValues,
            &cchValuesNameMax,
            &cbValuesMax,
            NULL,
            NULL))) goto RegQueryInfoKeyError;


    if (cValues && cbValuesMax) {
        // allocate the memory needed to read the reg
        // Remote Registry calls on Win95 includes the NULL terminator, that's
        // why we add +2 and not just +1
        if (NULL == (wszValueName = (WCHAR *) PkiNonzeroAlloc(
                (cchValuesNameMax+2) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbValuesMax)))
            goto OutOfMemory;

        // enum the registry getting certs, CRLs or CTLs
        for (i=0; i<cValues; i++ ) {
            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            err = RegEnumValueU( hKeyT,
                                i,
                                wszValueName,
                                &cchHash,
                                NULL,
                                &dwType,
                                pbElement,
                                &cbElement);
            // any error get it set
            // but we want to continue to get all good certs
            if( err != ERROR_SUCCESS )
                continue;
            else {
                fOK &= CertAddSerializedElementToStore(
                    hCertStore,
                    pbElement,
                    cbElement,
                    CERT_STORE_ADD_ALWAYS,
                    0,                              // dwFlags
                    CERT_STORE_ALL_CONTEXT_FLAG,
                    NULL,                           // pdwContextType
                    NULL);                          // ppvContext

                CertPerfIncrementRegElementReadCount();
            }
        }

    }

    fOK &= OpenKeysFromRegistry(hCertStore, hKeyT, dwFlags);

    if (cValues && cbValuesMax && fOK &&
            0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Migrate from values to subkeys. This allows registry roaming
        // from NT to Win95 without exceeding the Win95 registry
        // limitations

        HKEY hSubKey = NULL;
        while (TRUE) {
            if (NULL == (hSubKey = OpenSubKey(
                    hKeyT,
                    NULL,       // pwszSubKey
                    CERT_STORE_OPEN_EXISTING_FLAG |
                        (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
                    )))
                break;

            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            if (ERROR_SUCCESS != RegEnumValueU(
                    hSubKey,
                    0,                  // iValue
                    wszValueName,
                    &cchHash,
                    NULL,
                    &dwType,
                    pbElement,
                    &cbElement))
                break;

            if (!WriteKeyToRegistry(hSubKey, wszValueName, dwFlags,
                    pbElement, cbElement))
                break;
            if (ERROR_SUCCESS != RegDeleteValueU(hSubKey, wszValueName))
                break;
            RegCloseKey(hSubKey);
        }

        if (hSubKey)
            RegCloseKey(hSubKey);
    }

CommonReturn:
    // done with our memory
    PkiFree(wszValueName);
    PkiFree(pbElement);

    return fOK;
ErrorReturn:
    fOK = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
TRACE_ERROR(OutOfMemory)
}


STATIC BOOL MoveFromRegistryToRoamingFiles(
    IN HKEY hSubKey,
    IN LPCWSTR pwszStoreDirectory,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BYTE *pbElement = NULL;
    DWORD cbElement;

    while (TRUE) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;

        if (ERROR_SUCCESS != RegEnumKeyExU(
                hSubKey,
                0,
                wszSubKeyName,
                &cchSubKeyName,
                NULL,               // lpdwReserved
                NULL,               // lpszClass
                NULL,               // lpcchClass
                NULL                // lpftLastWriteTime
                ))
            break;

        if (!ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,               // pwszContextName
                wszSubKeyName,
                CERT_STORE_READONLY_FLAG |
                    (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG),
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromRegistryError;

        if (!ILS_WriteElementToFile(
                pwszStoreDirectory,
                pwszContextName,
                wszSubKeyName,
                CERT_STORE_CREATE_NEW_FLAG |
                    (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG),
                pbElement,
                cbElement
                )) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto WriteElementToFileError;
        }

        PkiFree(pbElement);
        pbElement = NULL;

        if (!RecursiveDeleteSubKey(
                hSubKey,
                wszSubKeyName,
                dwFlags
                ))
            goto DeleteSubKeyError;
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    PkiFree(pbElement);
    goto CommonReturn;

TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(DeleteSubKeyError)
}


typedef struct _READ_CONTEXT_CALLBACK_ARG {
    BOOL                        fOK;
    HCERTSTORE                  hCertStore;
} READ_CONTEXT_CALLBACK_ARG, *PREAD_CONTEXT_CALLBACK_ARG;

STATIC BOOL ReadContextCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    BOOL fResult;
    PREAD_CONTEXT_CALLBACK_ARG pReadContextArg =
        (PREAD_CONTEXT_CALLBACK_ARG) pvArg;
    DWORD dwContextType = 0;
    const void *pvContext = NULL;

    fResult = CertAddSerializedElementToStore(
            pReadContextArg->hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            CERT_STORE_ALL_CONTEXT_FLAG,
            &dwContextType,
            &pvContext
            );

    if (fResult) {
        if (IsValidRegValueNameForContext(
                dwContextType,
                pvContext,
                wszHashName
                ))
            FreeContext(dwContextType, pvContext);
        else {
            DeleteContextFromStore(dwContextType, pvContext);
            pReadContextArg->fOK = FALSE;
        }
    } else
        pReadContextArg->fOK = FALSE;


    CertPerfIncrementRegElementReadCount();

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from the registry
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pRegStore->hKey) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenSubKeyError;
            } else {
                // Ignore any registry errors
                OpenFromRegistry(hCertStore, hSubKey, pRegStore->dwFlags);
            }
        }

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            READ_CONTEXT_CALLBACK_ARG ReadContextArg;

            ReadContextArg.fOK = TRUE;
            ReadContextArg.hCertStore = hCertStore;

            if (!ILS_OpenAllElementsFromDirectory(
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags,
                    (void *) &ReadContextArg,
                    ReadContextCallback
                    )) {
                DWORD dwErr = GetLastError();
                if (!(ERROR_PATH_NOT_FOUND == dwErr ||
                        ERROR_FILE_NOT_FOUND == dwErr))
                    goto OpenRoamingFilesError;
            }
            // Ignore any read context errors

            if (hSubKey &&
                    0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
                MoveFromRegistryToRoamingFiles(
                    hSubKey,
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags
                    );
            }
        }

        if (hSubKey) {
            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    if ((pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) &&
            pRegStore->hKey &&
            0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Move the Key Identifiers from the registry to roaming files
        if (hSubKey = OpenSubKey(
                pRegStore->hKey,
                KEYID_CONTEXT_NAME,
                pRegStore->dwFlags
                )) {
            MoveFromRegistryToRoamingFiles(
                hSubKey,
                pRegStore->pwszStoreDirectory,
                KEYID_CONTEXT_NAME,
                pRegStore->dwFlags
                );

            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hSubKey);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenRoamingFilesError)
}

//+-------------------------------------------------------------------------
//  Delete all the Certificates, CRLs and CTLs context subkeys. For Win95
//  also delete context files.
//
//  Also, if it exists, delete the "Serialized" subkey.
//--------------------------------------------------------------------------
STATIC BOOL DeleteAllFromRegistry(
    IN HKEY hKey,
    IN DWORD dwFlags        //  CERT_REGISTRY_STORE_REMOTE_FLAG or
                            //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BOOL fResult;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        LPCWSTR pwszSubKeyName = rgpwszContextSubKeyName[i];
        if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For WIN95, if a context is stored in a file, delete the
            // file
            HKEY hSubKey;
            if (NULL == (hSubKey = OpenSubKey(
                    hKey,
                    pwszSubKeyName,
                    CERT_STORE_OPEN_EXISTING_FLAG |
                        (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenContextSubKeyError;
                continue;
            }
            fResult = OpenKeysFromRegistry(
                NULL,       // hCertStore
                hSubKey,
                dwFlags
                );
            ILS_CloseRegistryKey(hSubKey);
            if (!fResult)
                goto DeleteKeysError;
        }

        if (!RecursiveDeleteSubKey(hKey, pwszSubKeyName, dwFlags)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto DeleteSubKeyError;
        }
    }

    if (!RecursiveDeleteSubKey(hKey, SERIALIZED_SUBKEY_NAME, dwFlags)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto DeleteSubKeyError;
    }


    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenContextSubKeyError)
TRACE_ERROR(DeleteKeysError)
TRACE_ERROR(DeleteSubKeyError)
}



//+=========================================================================
//  Serialized Registry Functions
//==========================================================================

static inline BOOL IsReadSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    return (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);
}

static inline BOOL IsWriteSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG))
        return FALSE;

    pRegStore->fTouched = TRUE;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from a single serialized
//  partitioned "blob" stored in the registry. The "blob" is stored under
//  the "Serialized" subkey.
//
//  Either called during initial open or with RegStore locked.
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    BYTE *pbStore = NULL;
    DWORD cbStore;

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (NULL == (hSubKey = OpenSubKey(
            pRegStore->hKey,
            SERIALIZED_SUBKEY_NAME,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    if (!ReadMultipleKeyBlobsFromRegistry(
            hSubKey,
            pRegStore->dwFlags,
            &pbStore,
            &cbStore
            ))
        goto ReadError;

    if (!I_CertAddSerializedStore(
            hCertStore,
            pbStore,
            cbStore
            ))
        goto AddError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(pbStore);
    return fResult;
ErrorReturn:
    if (ERROR_FILE_NOT_FOUND == GetLastError())
        fResult = TRUE;
    else
        fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(ReadError)
TRACE_ERROR(AddError)
}


//+=========================================================================
//  Serialized Control Functions
//==========================================================================

STATIC BOOL IsEmptyStore(
    IN HCERTSTORE hCertStore
    )
{
    PCCERT_CONTEXT pCert;
    PCCRL_CONTEXT pCrl;
    PCCTL_CONTEXT pCtl;

    if (pCert = CertEnumCertificatesInStore(hCertStore, NULL)) {
        CertFreeCertificateContext(pCert);
        return FALSE;
    }

    if (pCrl = CertEnumCRLsInStore(hCertStore, NULL)) {
        CertFreeCRLContext(pCrl);
        return FALSE;
    }

    if (pCtl = CertEnumCTLsInStore(hCertStore, NULL)) {
        CertFreeCTLContext(pCtl);
        return FALSE;
    }

    return TRUE;

}

STATIC BOOL CommitAllToSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;
    CRYPT_DATA_BLOB SerializedData = {0, NULL};
    HKEY hSubKey = NULL;

    LockRegStore(pRegStore);

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        BOOL fEmpty;

        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;

        fEmpty = IsEmptyStore(pRegStore->hCertStore);
        if (!fEmpty) {
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
            assert(SerializedData.cbData);
            if (NULL == (SerializedData.pbData = (BYTE *) PkiNonzeroAlloc(
                    SerializedData.cbData)))
                goto OutOfMemory;
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
        }

        if (!RecursiveDeleteSubKey(
                pRegStore->hKey, SERIALIZED_SUBKEY_NAME, pRegStore->dwFlags)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto DeleteSubKeyError;
        }

        if (!fEmpty) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    SERIALIZED_SUBKEY_NAME,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;

            if (!WriteMultipleKeyBlobsToRegistry(
                    hSubKey,
                    pRegStore->dwFlags,
                    SerializedData.pbData,
                    SerializedData.cbData
                    ))
                goto WriteStoreError;
        }
    }
    pRegStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(SerializedData.pbData);
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DeleteSubKeyError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(WriteStoreError)
}


//+-------------------------------------------------------------------------
//  Open the registry's store by reading its serialized certificates,
//  CRLs and CTLs and adding to the specified certificate store.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//
//  Only return HKEY for success. For a CertOpenStore error the caller
//  will close the HKEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HKEY hKey = (HKEY) pvPara;
    PREG_STORE pRegStore = NULL;
    DWORD dwErr;

    assert(hKey);

    if (dwFlags & ~OPEN_REG_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (DeleteAllFromRegistry(hKey, dwFlags)) {
            pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
            return TRUE;
        } else
            return FALSE;
    }


    if (NULL == (pRegStore = (PREG_STORE) PkiZeroAlloc(sizeof(REG_STORE))))
        goto OutOfMemory;
    if (!Pki_InitializeCriticalSection(&pRegStore->CriticalSection)) {
        PkiFree(pRegStore);
        pRegStore = NULL;
        goto OutOfMemory;
    }
    pRegStore->hCertStore = hCertStore;
    pRegStore->dwFlags = dwFlags;

    CertPerfIncrementStoreRegTotalCount();
    CertPerfIncrementStoreRegCurrentCount();

    if (dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        PCERT_REGISTRY_STORE_CLIENT_GPT_PARA pGptPara =
            (PCERT_REGISTRY_STORE_CLIENT_GPT_PARA) pvPara;
        DWORD cbRegPath = (wcslen(pGptPara->pwszRegPath) + 1) * sizeof(WCHAR);

        if (NULL == (pRegStore->GptPara.pwszRegPath =
                (LPWSTR) PkiNonzeroAlloc(cbRegPath)))
            goto OutOfMemory;
        memcpy(pRegStore->GptPara.pwszRegPath, pGptPara->pwszRegPath,
            cbRegPath);

        // Make a copy of the base hKey
        // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
        // a NULL pwszSubKey
        if (HKEY_LOCAL_MACHINE == pGptPara->hKeyBase)
            pRegStore->GptPara.hKeyBase = HKEY_LOCAL_MACHINE;
        else if (NULL == (pRegStore->GptPara.hKeyBase = OpenSubKey(
                pGptPara->hKeyBase,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        fResult = OpenAllFromGptRegistry(pRegStore,
            pRegStore->hCertStore);

#if 1
        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
#else

        // For subsequent opens, allow subkey create if it doesn't already
        // exist. However, preserve open existing.
        pRegStore->dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
#endif

    } else if (dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        PCERT_REGISTRY_STORE_ROAMING_PARA pRoamingPara =
            (PCERT_REGISTRY_STORE_ROAMING_PARA) pvPara;
        DWORD cbDir = (wcslen(pRoamingPara->pwszStoreDirectory) + 1) *
            sizeof(WCHAR);

        if (NULL == (pRegStore->pwszStoreDirectory = (LPWSTR) PkiNonzeroAlloc(
                cbDir)))
            goto OutOfMemory;
        memcpy(pRegStore->pwszStoreDirectory, pRoamingPara->pwszStoreDirectory,
            cbDir);

        dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG;
        pRegStore->dwFlags = dwFlags;
        if (pRoamingPara->hKey) {
            // Make a copy of the input hKey
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRoamingPara->hKey,
                    NULL,       // pwszSubKey
                    dwFlags
                    )))
                goto OpenSubKeyError;
        }

        fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);
    } else {
        // Make a copy of the input hKey
        if (NULL == (pRegStore->hKey = OpenSubKey(
                hKey,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        if (dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
            fResult = OpenAllFromSerializedRegistry(pRegStore,
                pRegStore->hCertStore);
        else
            fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);

        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
    }
    if (!fResult)
        goto OpenAllError;


    pStoreProvInfo->cStoreProvFunc = REG_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRegStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pRegStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    dwErr = GetLastError();
    RegStoreProvClose((HCERTSTOREPROV) pRegStore, 0);
    SetLastError(dwErr);

    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenAllError)
}


//+-------------------------------------------------------------------------
//  Close the registry's store by closing its opened registry subkeys
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    if (pRegStore) {
        CertPerfDecrementStoreRegCurrentCount();

        FreeRegistryStoreChange(pRegStore);

        if (hWin95NotifyEvent)
            Win95StoreSignalAndFreeRegStoreResyncEntries(pRegStore);

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToGptRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
            FreeGptStoreChangeInfo(&pRegStore->pGptStoreChangeInfo);
            GptStoreSignalAndFreeRegStoreResyncEntries(pRegStore);
            PkiFree(pRegStore->GptPara.pwszRegPath);
            // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
            // a NULL pwszSubKey
            if (pRegStore->GptPara.hKeyBase &&
                    HKEY_LOCAL_MACHINE != pRegStore->GptPara.hKeyBase)
                RegCloseKey(pRegStore->GptPara.hKeyBase);
        } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            PkiFree(pRegStore->pwszStoreDirectory);
        } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToSerializedRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
        }

        if (pRegStore->hKey)
            RegCloseKey(pRegStore->hKey);
        if (pRegStore->hMyNotifyChange)
            CloseHandle(pRegStore->hMyNotifyChange);
        DeleteCriticalSection(&pRegStore->CriticalSection);
        PkiFree(pRegStore);
    }
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the context from either the registry or
//  a roaming file and create a new context.
//--------------------------------------------------------------------------
STATIC BOOL ReadContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    OUT const void **ppvContext
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        if (!ILS_ReadElementFromFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromFileError;
    } else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;
        }

        fResult = ILS_ReadElementFromRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                );

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    if (!CertAddSerializedElementToStore(
            NULL,                           // hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            rgdwContextTypeFlags[dwContextType],
            NULL,                           // pdwContextType
            ppvContext))
        goto AddSerializedElementError;

    CertPerfIncrementRegElementReadCount();

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(AddSerializedElementError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Write the serialized context and its properties to
//  the registry or a roaming file.
//
//  Called before the context is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WriteSerializedContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;

    CertPerfIncrementRegElementWriteCount();

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_WriteElementToFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
    else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        }

        fResult = ILS_WriteElementToRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Delete the context and its properties from the
//  the registry or a roaming file.
//
//  Called before the context is deleted from the store.
//--------------------------------------------------------------------------
STATIC BOOL DeleteContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN]
    )
{
    BOOL fResult;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_DeleteElementFromDirectory(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );
    else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        }

        fResult = ILS_DeleteElementFromRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }

    CertPerfIncrementRegElementDeleteCount();

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
            fResult = TRUE;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the certificate and its properties from
//  the registry and create a new certificate context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCertRegValueName(pStoreCertContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        (const void **) ppProvCertContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCertContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

STATIC void SetMyIEDirtyFlag()
{
    LONG err;
    DWORD dwDisposition;
    HKEY hSubKey;

    // Don't worry about BACKUP_RESTORE
    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_IE_DIRTY_FLAGS_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hSubKey,
            &dwDisposition))) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "RegCreateKeyEx(%S) returned error: %d 0x%x\n",
            CERT_IE_DIRTY_FLAGS_REGPATH, err, err);
#endif
    } else {
        WriteDWORDValueToRegistry(hSubKey, L"My", 0x1);
        RegCloseKey(hSubKey);
    }
}

//+-------------------------------------------------------------------------
//  Serialize the encoded certificate and its properties and write to
//  the registry.
//
//  Called before the certificate is written to the store.
//
//  Note, don't set the IEDirtyFlag if setting a property.
//--------------------------------------------------------------------------

STATIC BOOL WINAPI RegStoreProvWriteCertEx(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags,
        IN BOOL fSetProperty
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

    if (fResult && !fSetProperty &&
            0 != (pRegStore->dwFlags & CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG))
        SetMyIEDirtyFlag();

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}

STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    return RegStoreProvWriteCertEx(
        hStoreProv,
        pCertContext,
        dwFlags,
        FALSE                       // fSetProperty
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the registry.
//
//  Called before the certificate is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // delete this cert
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified certificate from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the certificate to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the certificate in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCert(
            hStoreProv,
            pCertContext,
            0,              // dwFlags
            &pProvCertContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCertificateContextProperty(
            pProvCertContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCertEx(
            hStoreProv,
            pProvCertContext,
            0,                  // dwFlags
            TRUE                // fSetProperty
            ))
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CRL and its properties from
//  the registry and create a new CRL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCrlRegValueName(pStoreCrlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCrlContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CRL and its properties and write to
//  the registry.
//
//  Called before the CRL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CRL from the registry.
//
//  Called before the CRL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // delete this CRL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CRL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CRL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CRL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCRL_CONTEXT pProvCrlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCrl(
            hStoreProv,
            pCrlContext,
            0,              // dwFlags
            &pProvCrlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCRLContextProperty(
            pProvCrlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCrl(
            hStoreProv,
            pProvCrlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCRLContext(pProvCrlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CTL and its properties from
//  the registry and create a new CTL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCtlRegValueName(pStoreCtlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCtlContext
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCtlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CTL and its properties and write to
//  the registry.
//
//  Called before the CTL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CTL from the registry.
//
//  Called before the CTL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // delete this CTL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CTL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CTL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CTL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCTL_CONTEXT pProvCtlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a CTL context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCtl(
            hStoreProv,
            pCtlContext,
            0,              // dwFlags
            &pProvCtlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCTLContextProperty(
            pProvCtlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCtl(
            hStoreProv,
            pProvCtlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCTLContext(pProvCtlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+=========================================================================
//  Control functions
//==========================================================================

STATIC BOOL RegNotifyChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        return RegRegistryStoreChange(pRegStore, hEvent, dwFlags);
    else if (hWin95NotifyEvent)
        return RegWin95StoreChange(pRegStore, hEvent, dwFlags);
    else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
        return RegGptStoreChange(pRegStore, hEvent, dwFlags);
    else
        return RegRegistryStoreChange(pRegStore, hEvent, dwFlags);
}

STATIC BOOL ResyncFromRegistry(
    IN PREG_STORE pRegStore,
    IN OPTIONAL HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HCERTSTORE hNewStore = NULL;
    HANDLE hMyNotifyChange;

    // Serialize resyncs
    LockRegStore(pRegStore);

    if (hEvent) {
        // Re-arm the specified event
        if (!RegNotifyChange(pRegStore, hEvent, dwFlags))
            goto NotifyChangeError;
    }

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (hMyNotifyChange) {
        // Check if any changes since last resync
        if (WAIT_TIMEOUT == WaitForSingleObjectEx(
                hMyNotifyChange,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                )) {
            // No change
            fResult = TRUE;
            goto CommonReturn;
        } else {
            // Re-arm our event handle
            if (!RegNotifyChange(pRegStore, hMyNotifyChange,
                    CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG))
                goto NotifyChangeError;
        }
    }

    if (NULL == (hNewStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            CERT_STORE_SHARE_CONTEXT_FLAG,           
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        fResult = OpenAllFromGptRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
        fResult = OpenAllFromSerializedRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else
        fResult = OpenAllFromRegistry(pRegStore, hNewStore);

    if (!fResult) {
        if (ERROR_KEY_DELETED == GetLastError())
            fResult = TRUE;
    }

    if (fResult) {
        if (pRegStore->fProtected) {
            BOOL fProtected;

            // For the "Root" delete any roots that aren't in the protected root
            // list.
            if (!IPR_DeleteUnprotectedRootsFromStore(
                    hNewStore,
                    &fProtected
                    )) goto DeleteUnprotectedRootsError;
        }

        // Set fResync to inhibit the sync from writing back to the registry.
        pRegStore->fResync = TRUE;
        I_CertSyncStore(pRegStore->hCertStore, hNewStore);
        pRegStore->fResync = FALSE;
    }

CommonReturn:
    UnlockRegStore(pRegStore);
    if (hNewStore)
        CertCloseStore(hNewStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NotifyChangeError)
TRACE_ERROR(OpenMemoryStoreError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}


STATIC BOOL RegistryNotifyChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HANDLE hMyNotifyChange;
    BOOL fFirstNotify;

    LockRegStore(pRegStore);

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (NULL == hMyNotifyChange) {
        // Create "my" event and register it to be signaled for any changes
        if (NULL == (hMyNotifyChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;

        // For the first notification, want to ensure the store is in sync.
        // Also does a RegNotifyChange
        if (!ResyncFromRegistry(pRegStore, hMyNotifyChange,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG)) {
            DWORD dwErr = GetLastError();
            CloseHandle(hMyNotifyChange);
            SetLastError(dwErr);
            goto ResyncFromRegistryError;
        }

        // Note, must update after making the above Resync call to
        // force the store to be resync'ed
        pRegStore->hMyNotifyChange = hMyNotifyChange;
        fFirstNotify = TRUE;
    } else
        fFirstNotify = FALSE;

    if (hEvent) {
        if (fFirstNotify ||
                0 != (dwFlags & REG_STORE_CTRL_CANCEL_NOTIFY_FLAG)) {
            if (!RegNotifyChange(pRegStore, hEvent, dwFlags))
                goto NotifyChangeError;
        } else {
            // For subsequent notification, want to ensure the store
            // is in sync. Also does a RegNotifyChange.
            if (!ResyncFromRegistry(pRegStore, hEvent, dwFlags))
                goto ResyncFromRegistryError;
        }
    }

    fResult = TRUE;
CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateEventError)
TRACE_ERROR(ResyncFromRegistryError)
TRACE_ERROR(NotifyChangeError)
}


STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_RESYNC:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = ResyncFromRegistry(pRegStore, hEvent, dwFlags);
            }
            break;
        case CERT_STORE_CTRL_NOTIFY_CHANGE:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = RegistryNotifyChange(pRegStore, hEvent, dwFlags);
            }
            break;
        case CERT_STORE_CTRL_COMMIT:
            if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
                fResult = CommitAllToGptRegistry(pRegStore, dwFlags);
            else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
                fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
            else
                fResult = TRUE;
            break;
        case CERT_STORE_CTRL_CANCEL_NOTIFY:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                if (hEvent)
                    fResult = RegistryNotifyChange(pRegStore, hEvent,
                        REG_STORE_CTRL_CANCEL_NOTIFY_FLAG);
                else
                    fResult = TRUE;
            }
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}


//+=========================================================================
//  System and physical store support functions
//==========================================================================

STATIC BOOL HasBackslash(
    IN LPCWSTR pwsz
    )
{
    WCHAR wch;

    if (NULL == pwsz)
        return FALSE;

    while (L'\0' != (wch = *pwsz++)) {
        if (L'\\' == wch)
            return TRUE;
    }
    return FALSE;
}

static inline LPCSTR GetSystemStoreLocationOID(
    IN DWORD dwFlags
    )
{
    return (LPCSTR)(DWORD_PTR) ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline DWORD GetSystemStoreLocationID(
    IN DWORD dwFlags
    )
{
    return ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline BOOL IsSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 == (rgSystemStoreLocationInfo[dwID].dwFlags &
                NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG));
}

static inline BOOL IsRemotableSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                REMOTABLE_SYSTEM_STORE_LOCATION_FLAG));
}


static inline BOOL IsSerializedSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                SERIALIZED_SYSTEM_STORE_LOCATION_FLAG));
}

STATIC BOOL IsPredefinedSystemStore(
    IN LPCWSTR pwszSystemName,
    IN DWORD dwFlags
    )
{
    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    dwLocID = GetSystemStoreLocationID(dwFlags);
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;

    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if ((dwCheckFlag & dwPredefinedSystemFlags) &&
                0 == _wcsicmp(rgpwszPredefinedSystemStore[i], pwszSystemName))
            return TRUE;
    }
    return FALSE;
}

#define UNICODE_SYSTEM_PROVIDER_FLAG    0x1
#define ASCII_SYSTEM_PROVIDER_FLAG      0x2
#define PHYSICAL_PROVIDER_FLAG          0x4

STATIC DWORD GetSystemProviderFlags(
    IN LPCSTR pszStoreProvider
    )
{
    DWORD dwFlags;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    dwFlags = 0;
    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    else if (0xFFFF < (DWORD_PTR) pszStoreProvider) {
        if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W, pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_PHYSICAL_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    }

    return dwFlags;
}

STATIC LPCSTR ChangeAsciiToUnicodeProvider(
    IN LPCSTR pszStoreProvider
    )
{
    LPCSTR pszUnicodeProvider = NULL;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_W;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_REGISTRY_W;

    assert(pszUnicodeProvider);
    return pszUnicodeProvider;
}


STATIC void FreeSystemNameInfo(
    IN PSYSTEM_NAME_INFO pInfo
    )
{
    DWORD i;
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        if (pInfo->rgpwszName[i]) {
            PkiFree(pInfo->rgpwszName[i]);
            pInfo->rgpwszName[i] = NULL;
        }
    }
}

//+-------------------------------------------------------------------------
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, then, treat the
//  parameter as a pointer to a relocate data structure consisting of
//  the relocate HKEY base and the pointer to the system name path.
//  Otherwise, treat the parameter as a pointer to the system name path.
//
//  Parses and validates the system name path according to the system store
//  location and the number of required System and Physical name components.
//  All name components are separated by the backslash, "\", character.
//
//  Depending on the system store location and the number of required System
//  and Physical name components, the system name path can have the following
//  name components:
//
//  CERT_SYSTEM_STORE_CURRENT_USER or
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_LOCAL_MACHINE or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//      []
//      [[\\]ComputerName]
//      [[\\]ComputerName\]SystemName
//      [[\\]ComputerName\]SystemName\PhysicalName
//  CERT_SYSTEM_STORE_CURRENT_SERVICE
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_SERVICES
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [ServiceName]
//      [[\\]ComputerName\ServiceName]
//      [[\\]ComputerName\]ServiceName\SystemName
//      [[\\]ComputerName\]ServiceName\SystemName\PhysicalName
//  CERT_SYSTEM_STORE_USERS
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [UserName]
//      [[\\]ComputerName\UserName]
//      [[\\]ComputerName\]UserName\SystemName
//      [[\\]ComputerName\]UserName\SystemName\PhysicalName
//
//  For enumeration, where cReqName = 0, all store locations allow the no name
//  components option. CERT_SYSTEM_STORE_CURRENT_USER,
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
//  CERT_SYSTEM_CURRENT_SERVICE only allow the no name component option.
//
//  The leading \\ before the ComputerName is optional.
//
//  A PhysicalName always requires a preceding SystemName.
//
//  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
//  for enumeration, if only a single
//  name component, then, interpretted as a ServiceName or UserName unless it
//  contains a leading \\ or a trailing \, in which case its interpretted as a
//  ComputerName. Otherwise, when not enumeration, the ServiceName or UserName
//  is required.
//--------------------------------------------------------------------------
STATIC BOOL ParseSystemStorePara(
    IN const void *pvPara,
    IN DWORD dwFlags,
    IN DWORD cReqName,      // 0 for enum, 1 for OpenSystem, 2 for OpenPhysical
    OUT PSYSTEM_NAME_INFO pInfo
    )
{
    LPCWSTR pwszPath;       // not allocated
    BOOL fResult;
    DWORD cMaxOptName;
    DWORD cMaxTotalName;
    DWORD cOptName;
    DWORD cTotalName;
    BOOL fHasComputerNameBackslashes;
    DWORD i;

    LPCWSTR pwszEnd;
    LPCWSTR pwsz;
    LPCWSTR rgpwszStart[SYSTEM_NAME_PATH_COUNT];
    DWORD cchName[SYSTEM_NAME_PATH_COUNT];

    memset(pInfo, 0, sizeof(*pInfo));
    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;

        if (NULL == pRelocatePara)
            goto NullRelocateParaError;

        if (NULL == pRelocatePara->hKeyBase)
            goto NullRelocateHKEYError;
        pInfo->hKeyBase = pRelocatePara->hKeyBase;
        pwszPath = pRelocatePara->pwszSystemStore;
    } else
        pwszPath = (LPCWSTR) pvPara;

    if (NULL == pwszPath || L'\0' == *pwszPath) {
        if (0 == cReqName)
            goto SuccessReturn;
        else
            goto MissingSystemName;
    }

    dwFlags &= CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwFlags) {
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            cMaxOptName = 0;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            cMaxOptName = 1;        // Allow ComputerName
            break;
        case CERT_SYSTEM_STORE_SERVICES:
        case CERT_SYSTEM_STORE_USERS:
            // Allow ComputerName and/or ServiceOrUserName
            cMaxOptName = 2;
            break;
        default:
            goto InvalidStoreLocation;
    }

    cMaxTotalName = cReqName + cMaxOptName;
    assert(cReqName <= SERVICE_NAME_INDEX);
    assert(cMaxTotalName <= SYSTEM_NAME_PATH_COUNT);
    if (0 == cMaxTotalName)
        goto MachineOrServiceNameNotAllowed;

    if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1]) {
        pwszPath += 2;
        fHasComputerNameBackslashes = TRUE;
    } else
        fHasComputerNameBackslashes = FALSE;

    // Starting at the end, get up through cMaxTotalName strings separated
    // by backslashes. Note, don't parse the left-most name component. This
    // allows a ComputerName to contain embedded backslashes.
    pwszEnd = pwszPath + wcslen(pwszPath);
    pwsz = pwszEnd;

    cTotalName = 0;
    while (cTotalName < cMaxTotalName - 1) {
        while (pwsz > pwszPath && L'\\' != *pwsz)
            pwsz--;
        if (L'\\' != *pwsz) {
            // Left-most name component.
            assert(pwsz == pwszPath);
            break;
        }
        assert(L'\\' == *pwsz);
        cchName[cTotalName] = (DWORD)(pwszEnd - pwsz) - 1; // exclude "\"
        rgpwszStart[cTotalName] = pwsz + 1;         // exclude "\"
        cTotalName++;

        pwszEnd = pwsz;         // remember pointer to "\"
        if (pwsz == pwszPath)
            // Left-most name component is empty
            break;
        pwsz--;                 // skip before the "\"
    }
    // Left-most name component. Note, it may have embedded backslashes
    cchName[cTotalName] = (DWORD)(pwszEnd - pwszPath);
    rgpwszStart[cTotalName] = pwszPath;
    cTotalName++;

    if (cTotalName < cReqName)
        goto MissingSystemOrPhysicalName;

    // Allocate and copy the required name components
    for (i = 0; i < cReqName; i++) {
        if (0 == cchName[i])
            goto EmptySystemOrPhysicalName;
        if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX - cReqName + i] =
                ILS_AllocAndCopyString(rgpwszStart[i], cchName[i])))
            goto OutOfMemory;
    }

    cOptName = cTotalName - cReqName;
    assert(cOptName || cReqName);
    if (0 == cOptName) {
        assert(cReqName);
        // No ComputerName and/or ServiceName prefix

        // Check if left-most name component (SystemName) has any backslashes
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        if (fHasComputerNameBackslashes || HasBackslash(
                pInfo->rgpwszName[SYSTEM_NAME_INDEX]))
            goto InvalidBackslashInSystemName;
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags)
            // For non-enumeration, require the ServiceName
            goto MissingServiceOrUserName;
    } else {
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags) {
            // ServiceName or UserName prefix

            if (0 == cchName[cReqName] ||
                    (1 == cOptName && fHasComputerNameBackslashes)) {
                if (0 != cReqName)
                    goto MissingServiceOrUserName;
                // else
                //  ComputerName only Enumeration with either:
                //      ComputerName\       <- trailing backslash
                //      \\ComputerName      <- leading backslashes
                //      \\ComputerName\     <- both
            } else {
                if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX] =
                        ILS_AllocAndCopyString(rgpwszStart[cReqName],
                            cchName[cReqName])))
                    goto OutOfMemory;
            }
        }

        if (CERT_SYSTEM_STORE_LOCAL_MACHINE == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE == dwFlags ||
                2 == cOptName || fHasComputerNameBackslashes) {
            // ComputerName prefix
            DWORD cchComputer = cchName[cTotalName - 1];
            if (0 == cchComputer)
                goto EmptyComputerName;

            if (pInfo->hKeyBase)
                goto BothRemoteAndRelocateNotAllowed;

            if (NULL == (pInfo->rgpwszName[COMPUTER_NAME_INDEX] =
                    (LPWSTR) PkiNonzeroAlloc(
                    (2 + cchComputer + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            wcscpy(pInfo->rgpwszName[COMPUTER_NAME_INDEX], L"\\\\");
            memcpy((BYTE *) (pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2),
                (BYTE *) rgpwszStart[cTotalName -1],
                cchComputer * sizeof(WCHAR));
            *(pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2 + cchComputer) = L'\0';
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    FreeSystemNameInfo(pInfo);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(MissingSystemName, E_INVALIDARG)
SET_ERROR(NullRelocateParaError, E_INVALIDARG)
SET_ERROR(NullRelocateHKEYError, E_INVALIDARG)
SET_ERROR(MissingSystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidStoreLocation, E_INVALIDARG)
SET_ERROR(MachineOrServiceNameNotAllowed, E_INVALIDARG)
SET_ERROR(EmptySystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidBackslashInSystemName, E_INVALIDARG)
SET_ERROR(MissingServiceOrUserName, E_INVALIDARG)
SET_ERROR(EmptyComputerName, E_INVALIDARG)
SET_ERROR(BothRemoteAndRelocateNotAllowed, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

typedef struct _SYSTEM_NAME_GROUP {
    DWORD cName;
    LPCWSTR *rgpwszName;
} SYSTEM_NAME_GROUP, *PSYSTEM_NAME_GROUP;

//+-------------------------------------------------------------------------
//  Formats a System Name Path by concatenating together the name components
//  with an intervening "\" separator.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemNamePath(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[]
    )
{
    DWORD cchPath;
    LPWSTR pwszPath;
    BOOL fFirst;
    DWORD iGroup;

    // First, get total length of formatted path
    cchPath = 0;
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst)
                    fFirst = FALSE;
                else
                    cchPath++;          // "\" separator
                cchPath += wcslen(pwszName);
            }
        }
    }
    cchPath++;          // "\0" terminator

    if (NULL == (pwszPath = (LPWSTR) PkiNonzeroAlloc(cchPath * sizeof(WCHAR))))
        return NULL;

    // Now do concatenated copies with intervening '\'
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst) {
                    wcscpy(pwszPath, pwszName);
                    fFirst = FALSE;
                } else {
                    wcscat(pwszPath, L"\\");
                    wcscat(pwszPath, pwszName);
                }
            }
        }
    }
    if (fFirst)
        // Empty string
        *pwszPath = L'\0';
    return pwszPath;
}

//+-------------------------------------------------------------------------
//  If the SystemNameInfo has a non-NULL hKeyBase, then, the returned
//  pvPara is a pointer to a CERT_SYSTEM_STORE_RELOCATE_PARA containing both
//  the hKeyBase and the formatted system name path. Otherwise, returns
//  pointer to only the formatted system name path.
//
//  Calls the above FormatSystemNamePath() to do the actual formatting.
//--------------------------------------------------------------------------
STATIC void * FormatSystemNamePara(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[],
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (NULL == pSystemNameInfo->hKeyBase)
        return FormatSystemNamePath(cNameGroup, rgNameGroup);
    else {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara;

        if (NULL == (pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) PkiNonzeroAlloc(
                    sizeof(CERT_SYSTEM_STORE_RELOCATE_PARA))))
            return NULL;

        pRelocatePara->hKeyBase = pSystemNameInfo->hKeyBase;

        if (NULL == (pRelocatePara->pwszSystemStore = FormatSystemNamePath(
                cNameGroup, rgNameGroup))) {
            PkiFree(pRelocatePara);
            return NULL;
        } else
            return pRelocatePara;
    }
}

STATIC void FreeSystemNamePara(
    IN void *pvSystemNamePara,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (pvSystemNamePara) {
        if (pSystemNameInfo->hKeyBase) {
            PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemNamePara;
            PkiFree((LPWSTR) pRelocatePara->pwszSystemStore);
        }
        PkiFree(pvSystemNamePara);
    }
}


//+-------------------------------------------------------------------------
//  Localizes the physical, system and service name components. If unable
//  to find a localized name string, uses the unlocalized name component.
//
//  Re-formats the system name path with intervening backslashes and
//  sets the store's CERT_STORE_LOCALIZED_NAME_PROP_ID property.
//--------------------------------------------------------------------------
STATIC void SetLocalizedNameStoreProperty(
    IN HCERTSTORE hCertStore,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    LPWSTR pwszLocalizedPath = NULL;
    LPCWSTR rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT];
    SYSTEM_NAME_GROUP NameGroup;
    CRYPT_DATA_BLOB Property;
    DWORD i;

    // Except for the computer name, try to get localized name components.
    // If unable to find a localized name, use the original name component.
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        LPCWSTR pwszName;
        LPCWSTR pwszLocalizedName;

        pwszName = pSystemNameInfo->rgpwszName[i];
        if (NULL == pwszName || COMPUTER_NAME_INDEX == i)
            pwszLocalizedName = pwszName;
        else {
            // Returned pwszLocalizedName isn't allocated
            if (NULL == (pwszLocalizedName = CryptFindLocalizedName(
                    pwszName)) || L'\0' == *pwszLocalizedName)
                pwszLocalizedName = pwszName;
        }

        // Before formatting, need to reverse.
        rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT - 1 - i] =
            pwszLocalizedName;
    }

    NameGroup.cName = SYSTEM_NAME_PATH_COUNT;
    NameGroup.rgpwszName = rgpwszLocalizedName;
    if (NULL == (pwszLocalizedPath = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    Property.pbData = (BYTE *) pwszLocalizedPath;
    Property.cbData = (wcslen(pwszLocalizedPath) + 1) * sizeof(WCHAR);
    if (!CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            ))
        goto SetStorePropertyError;

CommonReturn:
    PkiFree(pwszLocalizedPath);
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(SetStorePropertyError)
}


//+-------------------------------------------------------------------------
//  For NT, get the formatted SID. For Win95, get the current user name.
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentServiceOrUserName()
{
    LPWSTR pwszCurrentService = NULL;

    if (!FIsWinNT()) {
        DWORD cch = _MAX_PATH;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserNameU(pwszCurrentService, &cch))
            goto GetUserNameError;
    } else {
        DWORD cch = 256;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserTextualSidHKCU(pwszCurrentService, &cch)) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                goto GetUserTextualSidHKUCError;
            PkiFree(pwszCurrentService);
            if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                    (cch + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            if (!GetUserTextualSidHKCU(pwszCurrentService, &cch))
                goto GetUserTextualSidHKUCError;
        }
    }

CommonReturn:
    return pwszCurrentService;

ErrorReturn:
    if (pwszCurrentService)
        wcscpy(pwszCurrentService, DEFAULT_USER_NAME);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetUserNameError)
TRACE_ERROR(GetUserTextualSidHKUCError)
}

//+-------------------------------------------------------------------------
//  For NT and Win95, get the computer name
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentComputerName()
{
    LPWSTR pwszCurrentComputer = NULL;
    DWORD cch = _MAX_PATH;
    if (NULL == (pwszCurrentComputer = (LPWSTR) PkiNonzeroAlloc(
            (cch + 1) * sizeof(WCHAR))))
        goto OutOfMemory;
    if (!GetComputerNameU(pwszCurrentComputer, &cch))
        goto GetComputerNameError;

CommonReturn:
    return pwszCurrentComputer;

ErrorReturn:
    PkiFree(pwszCurrentComputer);
    pwszCurrentComputer = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetComputerNameError)
}

//+-------------------------------------------------------------------------
//  Uses the store location in the upper word of dwFlags, the parsed
//  System Name components consisting of: computer, service/user, system and
//  physical names, and the optional SubKey name to open the appropriate
//  registry key. If the Computer name is non-NULL, does a RegConnectRegistry
//  to connect a registry key on a remote computer. If the hKeyBase is
//  non-NULL, does a relocated open instead of using HKCU or HKLM.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemRegPath(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags,
    OUT HKEY *phKey
    )
{
    LONG err;
    HKEY hKey = NULL;
    LPWSTR pwszRegPath = NULL;
    LPWSTR pwszCurrentService = NULL;
    DWORD dwStoreLocation;

    SYSTEM_NAME_GROUP rgNameGroup[3];
    DWORD cNameGroup;
    LPCWSTR rgpwszService[3];
    LPCWSTR rgpwszUser[2];
    LPCWSTR rgpwszStore[3];

    if (pwszSubKeyName) {
        cNameGroup = 3;
        rgNameGroup[2].cName = 1;
        rgNameGroup[2].rgpwszName = &pwszSubKeyName;
    } else
        cNameGroup = 2;

    dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwStoreLocation) {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            rgNameGroup[0].cName = 3;
            rgNameGroup[0].rgpwszName = rgpwszService;
            rgpwszService[0] = SERVICES_REGPATH;
            rgpwszService[2] = SYSTEM_CERTIFICATES_SUBKEY_NAME;

            if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwStoreLocation) {
                assert(NULL == pInfo->rgpwszName[COMPUTER_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]);
                if (NULL == (pwszCurrentService =
                        GetCurrentServiceOrUserName()))
                    goto GetCurrentServiceNameError;
                rgpwszService[1] = pwszCurrentService;
            } else {
                if (NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]) {
                    // May be NULL for CertEnumSystemStore
                    assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                    assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                    rgNameGroup[0].cName = 1;
                } else
                    rgpwszService[1] = pInfo->rgpwszName[SERVICE_NAME_INDEX];
            }
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            rgpwszUser[0] = SYSTEM_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            rgpwszUser[0] = GROUP_POLICY_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            rgpwszUser[0] = ENTERPRISE_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_USERS:
            if (NULL == pInfo->rgpwszName[USER_NAME_INDEX]) {
                // May be NULL for CertEnumSystemStore
                assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                rgNameGroup[0].cName = 0;
            } else {
                rgpwszUser[0] = pInfo->rgpwszName[USER_NAME_INDEX];
                rgpwszUser[1] = SYSTEM_STORE_REGPATH;
                rgNameGroup[0].cName = 2;
                rgNameGroup[0].rgpwszName = rgpwszUser;
            }
            break;
        default:
            goto InvalidArg;
    }

    rgNameGroup[1].rgpwszName = rgpwszStore;
    rgpwszStore[0] = pInfo->rgpwszName[SYSTEM_NAME_INDEX];
    if (pInfo->rgpwszName[PHYSICAL_NAME_INDEX]) {
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        rgNameGroup[1].cName = 3;
        rgpwszStore[1] = PHYSICAL_STORES_SUBKEY_NAME;
        rgpwszStore[2] = pInfo->rgpwszName[PHYSICAL_NAME_INDEX];
    } else
        rgNameGroup[1].cName = 1;

    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
        assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
        assert(NULL == pInfo->hKeyBase);
        if (ERROR_SUCCESS != (err = RegConnectRegistryU(
                pInfo->rgpwszName[COMPUTER_NAME_INDEX],
                (CERT_SYSTEM_STORE_USERS == dwStoreLocation) ?
                    HKEY_USERS : HKEY_LOCAL_MACHINE,
                &hKey)))
            goto RegConnectRegistryError;
    } else if (pInfo->hKeyBase) {
        assert(dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG);
        hKey = pInfo->hKeyBase;
    } else {
        switch (dwStoreLocation) {
            case CERT_SYSTEM_STORE_CURRENT_USER:
            case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
                hKey = HKEY_CURRENT_USER;
                break;
            case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            case CERT_SYSTEM_STORE_SERVICES:
                hKey = HKEY_LOCAL_MACHINE;
                break;
            case CERT_SYSTEM_STORE_USERS:
                hKey = HKEY_USERS;
                break;
            default:
                goto InvalidArg;
        }
    }

    if (NULL == (pwszRegPath = FormatSystemNamePath(
            cNameGroup,
            rgNameGroup
            )))
        goto FormatSystemNamePathError;

CommonReturn:
    PkiFree(pwszCurrentService);
    *phKey = hKey;
    return pwszRegPath;
ErrorReturn:
    pwszRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(GetCurrentServiceNameError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(RegConnectRegistryError, err)
TRACE_ERROR(FormatSystemNamePathError)
}

STATIC HKEY OpenSystemRegPathKey(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
    LPWSTR pwszRegPath;
    HKEY hKey = NULL;
    HKEY hKeyRegPath;

    if (NULL == (pwszRegPath = FormatSystemRegPath(
            pInfo,
            pwszSubKeyName,
            dwFlags,
            &hKey
            )))
        goto FormatSystemRegPathError;

    hKeyRegPath = OpenSubKey(
        hKey,
        pwszRegPath,
        dwFlags
        );

CommonReturn:
    PkiFree(pwszRegPath);
    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX] && hKey)
        ILS_CloseRegistryKey(hKey);
    return hKeyRegPath;
ErrorReturn:
    hKeyRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(FormatSystemRegPathError)
}


STATIC HKEY OpenSystemStore(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}

STATIC HKEY OpenPhysicalStores(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        PHYSICAL_STORES_SUBKEY_NAME,
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}

//+-------------------------------------------------------------------------
//  Register a system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the system store
//  already exists in the store location.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HKEY hKey;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == (hKey = OpenSystemStore(pvSystemStore, dwFlags)))
        goto OpenSystemStoreError;
    RegCloseKey(hKey);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemStoreError)
}

//+-------------------------------------------------------------------------
//  Register a physical store for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the physical store
//  already exists in the system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;

    SYSTEM_NAME_INFO SystemNameInfo;

    char szOID[34];
    LPCSTR pszOID;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (NULL == pwszStoreName || L'\0' == *pwszStoreName ||
            HasBackslash(pwszStoreName))
        goto InvalidArg;
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = (LPWSTR) pwszStoreName;

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == pStoreInfo ||
            sizeof(CERT_PHYSICAL_STORE_INFO) > pStoreInfo->cbSize)
        goto InvalidArg;

    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags
            )))
        goto OpenSystemRegPathKeyError;

    pszOID = pStoreInfo->pszOpenStoreProvider;
    if (0xFFFF >= (DWORD_PTR) pszOID) {
        // Convert to "#<number>" string
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR) pszOID), szOID + 1, 10);
        pszOID = szOID;
    }
    if (ERROR_SUCCESS != (err = RegSetValueExA(
            hKey,
            "OpenStoreProvider",
            0,          // dwReserved
            REG_SZ,
            (BYTE *) pszOID,
            strlen(pszOID) + 1)))
        goto RegSetOpenStoreProviderError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenEncodingType",
            pStoreInfo->dwOpenEncodingType))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenFlags",
            pStoreInfo->dwOpenFlags))
        goto WriteDWORDError;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            L"OpenParameters",
            0,          // dwReserved
            REG_BINARY,
            pStoreInfo->OpenParameters.pbData,
            pStoreInfo->OpenParameters.cbData)))
        goto RegSetOpenParametersError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Flags",
            pStoreInfo->dwFlags))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Priority",
            pStoreInfo->dwPriority))
        goto WriteDWORDError;

    fResult = TRUE;

CommonReturn:
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;   // not allocated
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(OpenSystemRegPathKeyError)
SET_ERROR_VAR(RegSetOpenStoreProviderError, err)
SET_ERROR_VAR(RegSetOpenParametersError, err)
TRACE_ERROR(WriteDWORDError)
}

//+-------------------------------------------------------------------------
//  Unregister the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    LPWSTR pwszStore;       // not allocated

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Delete the SystemRegistry components
    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSystemRegPathKeyError;
    if (!DeleteAllFromRegistry(
            hKey,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) |
                (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] ?
                    CERT_REGISTRY_STORE_REMOTE_FLAG : 0)
            ))
        goto DeleteAllError;

    RegCloseKey(hKey);
    hKey = NULL;

    // Open SystemCertificates SubKey preceding the store. In order to do this
    // the SYSTEM_NAME component must be NULL.
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    pwszStore = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = NULL;
    hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            );
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = pwszStore;
    if (NULL == hKey)
        goto OpenSystemRegPathKeyError;

    // Delete the remaining System components (such as PhysicalStores) and
    // the System store itself
    if (!RecursiveDeleteSubKey(hKey, pwszStore, dwFlags))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteAllError)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(DeleteSubKeyError)
}

//+-------------------------------------------------------------------------
//  Unregister the physical store from the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    )
{
    BOOL fResult;
    HKEY hKey = NULL;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == (hKey = OpenPhysicalStores(
            pvSystemStore,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenPhysicalStoresError;
    if (!RecursiveDeleteSubKey(hKey, pwszStoreName, dwFlags))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(DeleteSubKeyError)
}

typedef struct _ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO {
    DWORD                               dwLastError;
    void                                *pvArg;
    PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum;
} ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO,
    *PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO;

STATIC BOOL WINAPI EnumRegisteredSystemStoreLocationCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO pEnumRegisteredInfo =
        (PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO) pvArg;

    LPCWSTR pwszLocation = L"";
    DWORD dwFlags;

    if (0 != pEnumRegisteredInfo->dwLastError)
        return FALSE;

    if (CONST_OID_STR_PREFIX_CHAR != *pszOID)
        return TRUE;
    dwFlags =
        (((DWORD) atol(pszOID + 1)) << CERT_SYSTEM_STORE_LOCATION_SHIFT) &
            CERT_SYSTEM_STORE_LOCATION_MASK;
    if (0 == dwFlags)
        return TRUE;

    // Try to find the SystemStoreLocation value
    while (cValue--) {
        if (0 == _wcsicmp(rgpwszValueName[cValue],
                    CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME) &&
                REG_SZ == rgdwValueType[cValue]) {
            pwszLocation = (LPCWSTR) rgpbValueData[cValue];
            break;
        }
    }

    if (!pEnumRegisteredInfo->pfnEnum(
            pwszLocation,
            dwFlags,
            NULL,                                       // pvReserved
            pEnumRegisteredInfo->pvArg
            )) {
        if (0 == (pEnumRegisteredInfo->dwLastError = GetLastError()))
            pEnumRegisteredInfo->dwLastError = (DWORD) E_UNEXPECTED;
        return FALSE;
    } else
        return TRUE;
}

//+-------------------------------------------------------------------------
//  Enumerate the system store locations.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStoreLocation(
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum
    )
{
    DWORD i;
    ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO EnumRegisteredInfo;

    if (dwFlags & ~ENUM_FLAGS_MASK) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Enumerate through the predefined, crypt32.dll system store locations
    for (i = 0; i < ENUM_SYSTEM_STORE_LOCATION_CNT; i++) {
        if (!pfnEnum(
                rgEnumSystemStoreLocationInfo[i].pwszLocation,
                rgEnumSystemStoreLocationInfo[i].dwFlags,
                NULL,                                       // pvReserved
                pvArg
                ))
            return FALSE;
    }

    // Enumerate through the registered system store locations
    EnumRegisteredInfo.dwLastError = 0;
    EnumRegisteredInfo.pvArg = pvArg;
    EnumRegisteredInfo.pfnEnum = pfnEnum;
    CryptEnumOIDFunction(
            0,                              // dwEncodingType
            CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            (void *) &EnumRegisteredInfo,   // pvArg
            EnumRegisteredSystemStoreLocationCallback
            );

    if (0 != EnumRegisteredInfo.dwLastError) {
        SetLastError(EnumRegisteredInfo.dwLastError);
        return FALSE;
    } else
        return TRUE;
}

STATIC BOOL EnumServicesOrUsersSystemStore(
    IN OUT PSYSTEM_NAME_INFO pLocationNameInfo,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    LPWSTR pwszEnumServiceName = NULL;
    void *pvEnumServicePara = NULL;
    BOOL fDidEnum;

    assert(NULL == pLocationNameInfo->rgpwszName[SERVICE_NAME_INDEX]);

    // Opens ..\Cryptography\Services SubKey or HKEY_USERS SubKey
    if (NULL == (hKey = OpenSystemRegPathKey(
            pLocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            )))
        goto OpenSystemRegPathKeyError;

    if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Enumerates the ServiceOrUserNames
    fDidEnum = FALSE;
    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        LPCWSTR rgpwszEnumName[2];
        SYSTEM_NAME_GROUP EnumNameGroup;
        EnumNameGroup.cName = 2;
        EnumNameGroup.rgpwszName = rgpwszEnumName;

        cchMaxSubKey++;
        if (NULL == (pwszEnumServiceName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[0] = pLocationNameInfo->rgpwszName[COMPUTER_NAME_INDEX];
        rgpwszEnumName[1] = pwszEnumServiceName;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumServiceName = cchMaxSubKey;
            LONG err;
            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumServiceName,
                    &cchEnumServiceName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchEnumServiceName ||
                            L'\0' == *pwszEnumServiceName)
                continue;
            if (NULL == (pvEnumServicePara = FormatSystemNamePara(
                        1, &EnumNameGroup, pLocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!CertEnumSystemStore(
                    dwFlags,
                    pvEnumServicePara,
                    pvArg,
                    pfnEnum
                    )) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto EnumSystemStoreError;
            } else
                fDidEnum = TRUE;
            FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
            pvEnumServicePara = NULL;
        }
    }

    if (!fDidEnum)
        goto NoSystemStores;
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumServiceName);
    FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
    FreeSystemNameInfo(pLocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumSystemStoreError)
SET_ERROR(NoSystemStores, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Enumerate the system stores.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  All registry based system store locations have the predefined stores
//  of: My, Root, Trust and CA.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStore(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey = 0;
    SYSTEM_NAME_INFO LocationNameInfo;
    LPWSTR pwszEnumSystemStore = NULL;
    void *pvEnumSystemPara = NULL;

    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    CERT_SYSTEM_STORE_INFO NullSystemStoreInfo;
    LPCWSTR rgpwszEnumName[3];
    SYSTEM_NAME_GROUP EnumNameGroup;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_SYSTEM_STORE) pvFuncAddr)(
            dwFlags,
            pvSystemStoreLocationPara,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStoreLocationPara,
            dwFlags,
            0,                  // cReqName, none for enumeration
            &LocationNameInfo   // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    dwLocID = GetSystemStoreLocationID(dwFlags);
    if ((CERT_SYSTEM_STORE_SERVICES_ID == dwLocID ||
             CERT_SYSTEM_STORE_USERS_ID == dwLocID)
                                &&
            NULL == LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX])
        // Following frees rgpwszLocationName entries
        return EnumServicesOrUsersSystemStore(
            &LocationNameInfo,
            dwFlags,
            pvArg,
            pfnEnum
            );

    // Opens SystemCertificates subkey
    if (NULL == (hKey = OpenSystemRegPathKey(
            &LocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenSystemRegPathKeyError;

        // Note, a registry entry isn't needed for the predefined stores
        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    memset(&NullSystemStoreInfo, 0, sizeof(NullSystemStoreInfo));
    NullSystemStoreInfo.cbSize = sizeof(NullSystemStoreInfo);
    EnumNameGroup.cName = 3;
    EnumNameGroup.rgpwszName = rgpwszEnumName;
    rgpwszEnumName[0] = LocationNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
    rgpwszEnumName[1] = LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX];

    // Enumerate the predefined system stores.
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;
    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if (0 == (dwCheckFlag & dwPredefinedSystemFlags))
            continue;
        rgpwszEnumName[2] = rgpwszPredefinedSystemStore[i];
        if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                1, &EnumNameGroup, &LocationNameInfo)))
            goto FormatSystemNameParaError;
        if (!pfnEnum(
                pvEnumSystemPara,
                dwFlags & CERT_SYSTEM_STORE_MASK,
                &NullSystemStoreInfo,
                NULL,               // pvReserved
                pvArg
                ))
            goto EnumCallbackError;
        FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
        pvEnumSystemPara = NULL;
    }

    // Enumerate the registered systems stores. Skip past any of the above
    // predefined stores
    if (cSubKeys && cchMaxSubKey) {
        cchMaxSubKey++;
        if (NULL == (pwszEnumSystemStore = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[2] = pwszEnumSystemStore;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumSystemStore = cchMaxSubKey;
            if (ERROR_SUCCESS != RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumSystemStore,
                    &cchEnumSystemStore,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    ) || 0 == cchEnumSystemStore)
                continue;
            if (IsPredefinedSystemStore(pwszEnumSystemStore, dwFlags))
                // Already enumerated above
                continue;
            if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                        1, &EnumNameGroup, &LocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!pfnEnum(
                    pvEnumSystemPara,
                    dwFlags & CERT_SYSTEM_STORE_MASK,
                    &NullSystemStoreInfo,
                    NULL,               // pvReserved
                    pvArg
                    ))
                goto EnumCallbackError;
            FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
            pvEnumSystemPara = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumSystemStore);
    FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
    FreeSystemNameInfo(&LocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumCallbackError)
}

typedef struct _ENUM_PHYSICAL_STORE_INFO ENUM_PHYSICAL_STORE_INFO,
    *PENUM_PHYSICAL_STORE_INFO;
struct _ENUM_PHYSICAL_STORE_INFO {
    CERT_PHYSICAL_STORE_INFO    RegistryInfo;
    LPWSTR                      pwszStoreName;
    PENUM_PHYSICAL_STORE_INFO   pNext;
};

STATIC void FreeEnumPhysicalStoreInfo(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfo
    )
{
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
    PkiFree(pRegistryInfo->OpenParameters.pbData);
    PkiFree(pRegistryInfo->pszOpenStoreProvider);
    PkiFree(pStoreInfo->pwszStoreName);
    PkiFree(pStoreInfo);
}


STATIC PENUM_PHYSICAL_STORE_INFO GetEnumPhysicalStoreInfo(
    IN HKEY hKey,
    IN LPCWSTR pwszStoreName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    LONG err;
    HKEY hSubKey = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo;        // not allocated

    if (NULL == (pStoreInfo = (PENUM_PHYSICAL_STORE_INFO) PkiZeroAlloc(
            sizeof(ENUM_PHYSICAL_STORE_INFO))))
        return NULL;
    pRegistryInfo = &pStoreInfo->RegistryInfo;
    pRegistryInfo->cbSize = sizeof(*pRegistryInfo);

    if (NULL == (pStoreInfo->pwszStoreName =
            ILS_AllocAndCopyString(pwszStoreName)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = OpenHKCUKeyExU(
            hKey,
            pwszStoreName,
            dwFlags,
            KEY_READ,
            &hSubKey)))
        goto OpenHKCUKeyError;

    if (!ILS_ReadBINARYValueFromRegistry(
            hSubKey,
            L"OpenParameters",
            &pRegistryInfo->OpenParameters.pbData,
            &pRegistryInfo->OpenParameters.cbData
            )) {
        LPWSTR pwszParameters;
        if (pwszParameters = ILS_ReadSZValueFromRegistry(
                hSubKey,
                L"OpenParameters"
                )) {
            pRegistryInfo->OpenParameters.pbData = (BYTE *) pwszParameters;
            pRegistryInfo->OpenParameters.cbData =
                (wcslen(pwszParameters) + 1) * sizeof(WCHAR);
        } else {
            // Default to empty string
            if (NULL == (pRegistryInfo->OpenParameters.pbData =
                    (BYTE *) ILS_AllocAndCopyString(L"")))
                goto OutOfMemory;
            pRegistryInfo->OpenParameters.cbData = 0;
        }
    }

    if (NULL == (pRegistryInfo->pszOpenStoreProvider = ILS_ReadSZValueFromRegistry(
            hSubKey,
            "OpenStoreProvider"
            )))
        goto NoOpenStoreProviderError;

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenFlags",
        &pRegistryInfo->dwOpenFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenEncodingType",
        &pRegistryInfo->dwOpenEncodingType
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Flags",
        &pRegistryInfo->dwFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Priority",
        &pRegistryInfo->dwPriority
        );

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return pStoreInfo;
ErrorReturn:
    FreeEnumPhysicalStoreInfo(pStoreInfo);
    pStoreInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(OpenHKCUKeyError, err)
TRACE_ERROR(NoOpenStoreProviderError)
}


STATIC BOOL IsSelfPhysicalStoreInfo(
    IN PSYSTEM_NAME_INFO pSystemNameInfo,
    IN DWORD dwFlags,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    OUT DWORD *pdwSystemProviderFlags
    )
{
    BOOL fResult;
    DWORD dwSystemProviderFlags;
    LPWSTR pwszStoreName = (LPWSTR) pStoreInfo->OpenParameters.pbData;
    SYSTEM_NAME_INFO StoreNameInfo;

    LPWSTR pwszCurrentServiceName = NULL;
    LPWSTR pwszCurrentComputerName = NULL;

    DWORD dwSystemLocation;
    DWORD dwInfoLocation;
    BOOL fSameLocation;

    *pdwSystemProviderFlags = 0;

    dwSystemLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    // Note, if the RELOCATE_FLAG is incorrectly set in the dwOpenFlags
    // then, never match
    dwInfoLocation = pStoreInfo->dwOpenFlags &
        (CERT_SYSTEM_STORE_LOCATION_MASK | CERT_SYSTEM_STORE_RELOCATE_FLAG);


    // Check if in same system store location
    fSameLocation = (dwSystemLocation == dwInfoLocation);
    if (!fSameLocation) {
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_USERS;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_USERS;

        if (dwSystemLocation != dwInfoLocation)
            return FALSE;
    }

    // Check if SYSTEM or SYSTEM_REGISTRY store.
    dwSystemProviderFlags = GetSystemProviderFlags(
        pStoreInfo->pszOpenStoreProvider);
    if (0 == dwSystemProviderFlags ||
            (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG))
        return FALSE;

    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
        if (NULL == (pwszStoreName = MkWStr((LPSTR) pwszStoreName)))
            return FALSE;
    }

    if (!ParseSystemStorePara(
            pwszStoreName,
            pStoreInfo->dwOpenFlags,
            1,                  // cReq, 1 for OpenSystemStore
            &StoreNameInfo      // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    // Default to not self
    fResult = FALSE;

    if (StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
            LPCWSTR pwszStoreComputerName;

            if (NULL == (pwszCurrentComputerName = GetCurrentComputerName()))
                goto GetCurrentComputerNameError;

            pwszStoreComputerName =
                StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
            assert(L'\\' == pwszStoreComputerName[0] &&
                L'\\' == pwszStoreComputerName[1]);
            if (!('\\' == pwszCurrentComputerName[0] &&
                    L'\\' == pwszCurrentComputerName[1]))
                pwszStoreComputerName += 2;
            if (0 != _wcsicmp(pwszStoreComputerName, pwszCurrentComputerName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX],
                pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same computer name

    if (StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]) {
            if (NULL == (pwszCurrentServiceName =
                    GetCurrentServiceOrUserName()))
                goto GetCurrentServiceOrUserNameError;
            if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                    pwszCurrentServiceName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same service/user name

    assert(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX] &&
         pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]);
    if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]))
        goto CommonReturn;

    // We have a match !!!
    fResult = TRUE;
    *pdwSystemProviderFlags = dwSystemProviderFlags;

CommonReturn:
    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
        FreeWStr(pwszStoreName);
    FreeSystemNameInfo(&StoreNameInfo);
    PkiFree(pwszCurrentServiceName);
    PkiFree(pwszCurrentComputerName);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetCurrentComputerNameError)
TRACE_ERROR(GetCurrentServiceOrUserNameError)
TRACE_ERROR(ParseSystemStoreParaError)
}

// List is sorted according to physical store priority
STATIC void AddToEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO *ppStoreInfoHead,
    IN PENUM_PHYSICAL_STORE_INFO pAddInfo
    )
{

    if (NULL == *ppStoreInfoHead)
        *ppStoreInfoHead = pAddInfo;
    else {
        PENUM_PHYSICAL_STORE_INFO pListInfo;
        DWORD dwPriority = pAddInfo->RegistryInfo.dwPriority;

        pListInfo = *ppStoreInfoHead;
        if (dwPriority > pListInfo->RegistryInfo.dwPriority) {
            // Insert at beginning before first entry
            pAddInfo->pNext = pListInfo;
            *ppStoreInfoHead = pAddInfo;
        } else {
            // Insert after the entry whose next entry has
            // lower priority or insert after the last entry
            while (pListInfo->pNext &&
                    dwPriority <= pListInfo->pNext->RegistryInfo.dwPriority)
                pListInfo = pListInfo->pNext;

            pAddInfo->pNext = pListInfo->pNext;
            pListInfo->pNext = pAddInfo;
        }
    }
}


STATIC void FreeEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfoHead
    )
{
    while (pStoreInfoHead) {
        PENUM_PHYSICAL_STORE_INFO pStoreInfo = pStoreInfoHead;
        pStoreInfoHead = pStoreInfo->pNext;
        FreeEnumPhysicalStoreInfo(pStoreInfo);
    }

}

// Returns NULL if unable to successfully get the Url. Returned string
// must be freed by calling CryptMemFree
STATIC LPWSTR GetUserDsUserCertificateUrl()
{
    DWORD dwErr;
    LPWSTR pwszUrl = NULL;
    HMODULE hDll = NULL;
    PFN_GET_USER_DS_STORE_URL pfnGetUserDsStoreUrl;

    if (NULL == (hDll = LoadLibraryA(sz_CRYPTNET_DLL)))
        goto LoadCryptNetDllError;

    if (NULL == (pfnGetUserDsStoreUrl =
            (PFN_GET_USER_DS_STORE_URL) GetProcAddress(hDll,
                sz_GetUserDsStoreUrl)))
        goto GetUserDsStoreUrlProcAddressError;

    if (!pfnGetUserDsStoreUrl(wsz_USER_CERTIFICATE_ATTR, &pwszUrl)) {
        dwErr = GetLastError();
        goto GetUserDsStoreUrlError;
    }

CommonReturn:
    if (hDll) {
        dwErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return pwszUrl;
ErrorReturn:
    pwszUrl = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadCryptNetDllError)
TRACE_ERROR(GetUserDsStoreUrlProcAddressError)
SET_ERROR_VAR(GetUserDsStoreUrlError, dwErr)
}

STATIC BOOL IsCurrentUserTrustedPublishersAllowed()
{
    DWORD dwFlags = 0;

    I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &dwFlags
        );

    return 0 == (dwFlags &
        (CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST |
            CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST));
}

STATIC BOOL IsLocalMachineTrustedPublishersAllowed()
{
    DWORD dwFlags = 0;

    I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &dwFlags
        );

    return 0 == (dwFlags & CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST);
}


//+-------------------------------------------------------------------------
//  Unless, CERT_STORE_OPEN_EXISTING_FLAG or CERT_STORE_READONLY_FLAG is
//  set, the pvSystemStore will be created if it doesn't already exist.
//
//  Note, depending on the store location and possibly the store name, there
//  are predefined physical stores of .Default, .LocalMachine, .GroupPolicy,
//  .Enterprise
//--------------------------------------------------------------------------
STATIC BOOL EnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    BOOL fResult;
    LONG *plDepth = NULL;    // allocated per thread, don't free here
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey = 0;
    LPWSTR pwszStoreName = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfoHead = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;       // not allocated
    SYSTEM_NAME_INFO SystemNameInfo;

    DWORD dwStoreLocationID;
    DWORD dwPredefinedPhysicalFlags;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Check for cross store recursion by checking the thread's enum
    // depth
    if (NULL == (plDepth = (LONG *) I_CryptGetTls(
            hTlsEnumPhysicalStoreDepth))) {
        if (NULL == (plDepth = (LONG *) PkiNonzeroAlloc(sizeof(*plDepth))))
            goto OutOfMemory;
        *plDepth = 1;
        I_CryptSetTls(hTlsEnumPhysicalStoreDepth, plDepth);
    } else {
        *plDepth += 1;
        if (MAX_ENUM_PHYSICAL_STORE_DEPTH < *plDepth)
            goto ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        cSubKeys = 0;
    } else if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            PHYSICAL_STORES_SUBKEY_NAME,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenPhysicalStoresError;

        // Check if we have a system store without the "PhysicalStores" subkey
        if (NULL == (hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags
                ))) {
            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG)
                hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags | CERT_STORE_OPEN_EXISTING_FLAG |
                        CERT_STORE_READONLY_FLAG
                    );
        }

        if (NULL == hKey) {
            // Note, the predefined stores don't need to exist in the
            // registry
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto OpenSystemStoreError;
        } else {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Get flags containing list of predefined physical stores according to
    // store name and/or store location
    dwStoreLocationID = GetSystemStoreLocationID(dwFlags);
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                wsz_MY_STORE) ||
            0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                wsz_REQUEST_STORE))
        // Only .Default is predefined for "My" or "Request" store
        dwPredefinedPhysicalFlags = MY_PHYSICAL_FLAGS;
    else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_ROOT_STORE)) {
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwStoreLocationID) {
            if (IPR_IsCurrentUserRootsAllowed()) {
                // .Default and .LocalMachine physical stores are predefined
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS;
            } else {
                // Don't read the CurrentUser's SystemRegistry
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS &
                    ~DEFAULT_PHYSICAL_FLAG;
                // Since we won't be reading the SystemRegistry, ensure
                // the protected list of roots is initialized.
                IPR_InitProtectedRootInfo();
            }
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwStoreLocationID) {
            if (IPR_IsAuthRootsAllowed()) {
                // .Default, .AuthRoot, .GroupPolicy and .Enterprise
                // physical stores are predefined
                dwPredefinedPhysicalFlags = LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS;
            } else {
                // Don't read the AuthRoot's SystemRegistry
                dwPredefinedPhysicalFlags = LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS &
                    ~AUTH_ROOT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_USERS_ID == dwStoreLocationID) {
            // Only .LocalMachine physical stores is predefined

            dwPredefinedPhysicalFlags = USERS_ROOT_PHYSICAL_FLAGS;
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else {
            // According to store location.
            dwPredefinedPhysicalFlags =
                rgSystemStoreLocationInfo[
                    dwStoreLocationID].dwPredefinedPhysicalFlags;
        }
    } else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                         wsz_TRUST_PUB_STORE) ||
               0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                         wsz_DISALLOWED_STORE)) {
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwStoreLocationID) {
            if (IsCurrentUserTrustedPublishersAllowed()) {
                // .Default, .GroupPolicy and .LocalMachine physical stores
                // are predefined
                dwPredefinedPhysicalFlags =
                    CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS;
            } else {
                // Don't read the CurrentUser's SystemRegistry
                dwPredefinedPhysicalFlags =
                    CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS &
                        ~DEFAULT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for
            // HKCU TrustedPublisher
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwStoreLocationID) {
            if (IsLocalMachineTrustedPublishersAllowed()) {
                // .Default, .GroupPolicy and .Enterprise
                // physical stores are predefined
                dwPredefinedPhysicalFlags =
                    LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS;
            } else {
                // Don't read the LocalMachine's SystemRegistry
                dwPredefinedPhysicalFlags =
                    LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS &
                    ~DEFAULT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for
            // HKLM TrustedPublisher
            cSubKeys = 0;
        } else {
            // According to store location.
            dwPredefinedPhysicalFlags =
                rgSystemStoreLocationInfo[
                    dwStoreLocationID].dwPredefinedPhysicalFlags;
        }
    } else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_USER_DS_STORE)) {
        // Only .UserCertificate is predefined for "UserDS"
        dwPredefinedPhysicalFlags = USER_DS_PHYSICAL_FLAGS;
    } else
        // According to store location
        dwPredefinedPhysicalFlags =
            rgSystemStoreLocationInfo[
                dwStoreLocationID].dwPredefinedPhysicalFlags;


    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        cchMaxSubKey++;
        if (NULL == (pwszStoreName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchStoreName = cchMaxSubKey;

            if (ERROR_SUCCESS != RegEnumKeyExU(
                    hKey,
                    i,
                    pwszStoreName,
                    &cchStoreName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    ) || 0 == cchStoreName)
                continue;

            if (NULL == (pStoreInfo = GetEnumPhysicalStoreInfo(
                    hKey,
                    pwszStoreName,
                    dwFlags
                    )))
                continue;
            AddToEnumPhysicalStoreList(&pStoreInfoHead, pStoreInfo);
        }
    }

    for (pStoreInfo = pStoreInfoHead; pStoreInfo;
                                            pStoreInfo = pStoreInfo->pNext) {
        PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
        BOOL fSelfPhysicalStoreInfo;
        DWORD dwSystemProviderFlags;
        char szOID[34];

        if (IsSelfPhysicalStoreInfo(
                &SystemNameInfo,
                dwFlags,
                pRegistryInfo,
                &dwSystemProviderFlags)) {
            assert((dwSystemProviderFlags & UNICODE_SYSTEM_PROVIDER_FLAG) ||
                (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG));
            // Force to use SYSTEM_REGISTRY provider to inhibit recursion.
            PkiFree(pRegistryInfo->pszOpenStoreProvider);
            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                // Convert to "#<number>" string
                szOID[0] = CONST_OID_STR_PREFIX_CHAR;
                _ltoa((long) ((DWORD_PTR)CERT_STORE_PROV_SYSTEM_REGISTRY_A), szOID + 1, 10);
                pRegistryInfo->pszOpenStoreProvider = szOID;
            } else
                pRegistryInfo->pszOpenStoreProvider =
                    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;

            dwPredefinedPhysicalFlags &= ~DEFAULT_PHYSICAL_FLAG;
            fSelfPhysicalStoreInfo = TRUE;
        } else {
            if (0 != dwPredefinedPhysicalFlags) {
                // Check if matches one of the predefined physical stores

                DWORD i;
                DWORD dwCheckFlag;
                for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
                    if ((dwCheckFlag & dwPredefinedPhysicalFlags) &&
                            0 == _wcsicmp(pStoreInfo->pwszStoreName,
                                rgpwszPredefinedPhysical[i])) {
                        dwPredefinedPhysicalFlags &= ~dwCheckFlag;
                        break;
                    }
                }
            }
            fSelfPhysicalStoreInfo = FALSE;
        }

        if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
            pRegistryInfo->dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
            pRegistryInfo->dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
        }
        if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
            pRegistryInfo->dwOpenFlags |= CERT_STORE_BACKUP_RESTORE_FLAG;
        }
        fResult = pfnEnum(
            pvSystemStore,
            dwFlags & CERT_SYSTEM_STORE_MASK,
            pStoreInfo->pwszStoreName,
            &pStoreInfo->RegistryInfo,
            NULL,                           // pvReserved
            pvArg
            );

        if (fSelfPhysicalStoreInfo) {
            // Not allocated. Set to NULL to inhibit subsequent free.
            pRegistryInfo->pszOpenStoreProvider = NULL;
        }

        if (!fResult)
            goto EnumCallbackError;
    }


    if (0 != dwPredefinedPhysicalFlags) {
        CERT_PHYSICAL_STORE_INFO SelfInfo;
        LPWSTR pwszLocalStore;
        DWORD cbLocalStore;
        DWORD i;
        DWORD dwCheckFlag;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
            // Format local store name without the ComputerName
            LPCWSTR rgpwszGroupName[2];
            SYSTEM_NAME_GROUP NameGroup;
            NameGroup.cName = 2;
            NameGroup.rgpwszName = rgpwszGroupName;

            assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
            rgpwszGroupName[0] = SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
            rgpwszGroupName[1] = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            if (NULL == (pwszLocalStore = FormatSystemNamePath(1, &NameGroup)))
                goto FormatSystemNamePathError;
        } else {
            if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
                PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                    (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemStore;
                pwszLocalStore = (LPWSTR) pRelocatePara->pwszSystemStore;
            } else
                pwszLocalStore = (LPWSTR) pvSystemStore;
        }
        cbLocalStore = (wcslen(pwszLocalStore) + 1) * sizeof(WCHAR);

        memset(&SelfInfo, 0, sizeof(SelfInfo));
        SelfInfo.cbSize = sizeof(SelfInfo);

        fResult = TRUE;
        for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
            LPWSTR pwszUserDsUserCertificateUrl;
            if (0 == (dwCheckFlag & dwPredefinedPhysicalFlags))
                continue;

            SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_SYSTEM_W;
            SelfInfo.OpenParameters.pbData =
                (BYTE *) SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            SelfInfo.OpenParameters.cbData =
                (wcslen(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) + 1) *
                    sizeof(WCHAR);
            SelfInfo.dwFlags = 0;
            pwszUserDsUserCertificateUrl = NULL;
            switch (i) {
                case DEFAULT_PHYSICAL_INDEX:
                    SelfInfo.pszOpenStoreProvider =
                        sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
                    SelfInfo.dwOpenFlags = dwFlags &
                        CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (0 == _wcsicmp(
                        SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                            wsz_MY_STORE))
                        SelfInfo.dwOpenFlags |= CERT_STORE_UPDATE_KEYID_FLAG;
                    SelfInfo.OpenParameters.pbData = (BYTE *) pwszLocalStore;
                    SelfInfo.OpenParameters.cbData = cbLocalStore;
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case AUTH_ROOT_PHYSICAL_INDEX:
                    SelfInfo.pszOpenStoreProvider =
                        sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
                    SelfInfo.dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                    SelfInfo.OpenParameters.pbData =
                        (BYTE *) wsz_AUTH_ROOT_STORE;
                    SelfInfo.OpenParameters.cbData =
                        (wcslen(wsz_AUTH_ROOT_STORE) + 1) * sizeof(WCHAR);
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case GROUP_POLICY_PHYSICAL_INDEX:
                    if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID ==
                            dwStoreLocationID)
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    else
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    break;
                case LOCAL_MACHINE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE |
                        CERT_STORE_READONLY_FLAG;
                    break;
                case DS_USER_CERT_PHYSICAL_INDEX:
                    if (NULL == (pwszUserDsUserCertificateUrl =
                            GetUserDsUserCertificateUrl()))
                        continue;
                    SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_LDAP_W;
                    SelfInfo.dwOpenFlags = 0;
                    SelfInfo.OpenParameters.pbData =
                        (BYTE *) pwszUserDsUserCertificateUrl;
                    SelfInfo.OpenParameters.cbData = (wcslen(
                        pwszUserDsUserCertificateUrl) + 1) * sizeof(WCHAR);
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case LMGP_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                            CERT_STORE_READONLY_FLAG;
                    break;
                case ENTERPRISE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                            CERT_STORE_READONLY_FLAG;
                    break;
                default:
                    assert(i < NUM_PREDEFINED_PHYSICAL);
                    continue;

            }

            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
                SelfInfo.dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                SelfInfo.dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
            }
            if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
                SelfInfo.dwOpenFlags |= CERT_STORE_BACKUP_RESTORE_FLAG;
            }

            fResult = pfnEnum(
                    pvSystemStore,
                    (dwFlags & CERT_SYSTEM_STORE_MASK) |
                        CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG,
                    rgpwszPredefinedPhysical[i],        // pwszStoreName
                    &SelfInfo,
                    NULL,                               // pvReserved
                    pvArg
                    );
            if (pwszUserDsUserCertificateUrl)
                CryptMemFree(pwszUserDsUserCertificateUrl);
            if (!fResult)
                break;
        }

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            PkiFree(pwszLocalStore);
        if (!fResult)
            goto EnumCallbackError;
    }

    fResult = TRUE;
CommonReturn:
    if (plDepth)
        *plDepth -= 1;
    ILS_CloseRegistryKey(hKey);
    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszStoreName);
    FreeEnumPhysicalStoreList(pStoreInfoHead);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(EnumCallbackError)
}

//+-------------------------------------------------------------------------
//  Enumerate the physical stores for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If the system store location only supports system stores and doesn't
//  support physical stores, LastError is set to ERROR_CALL_NOT_IMPLEMENTED.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    return EnumPhysicalStore(
        pvSystemStore,
        dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG,
        pvArg,
        pfnEnum
        );
}

STATIC BOOL IsHKCUStore(
    IN LPCWSTR pwszStoreName,
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (CERT_SYSTEM_STORE_CURRENT_USER != dwStoreLocation ||
            0 != _wcsicmp(pInfo->rgpwszName[SYSTEM_NAME_INDEX], pwszStoreName))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (unicode version)
//
//  Open the system registry store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system registry store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    BOOL fUserRoot;
    HKEY hHKCURoot = NULL;
    DWORD dwOpenRegFlags;
    const void *pvOpenRegPara;
    LPWSTR pwszRoamingDirectory = NULL;
    CERT_REGISTRY_STORE_ROAMING_PARA RoamingStorePara;

    CERT_REGISTRY_STORE_CLIENT_GPT_PARA ClientGptStorePara;
    memset(&ClientGptStorePara, 0, sizeof(ClientGptStorePara));

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Check for the CurrentUser "Root" store.
    fUserRoot = FALSE;
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            wsz_ROOT_STORE) &&
                0 == (dwFlags & CERT_SYSTEM_STORE_UNPROTECTED_FLAG)) {
        DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

        // Note, LOCAL_MACHINE check is needed to prevent use of relocation
        // to access the current user's root store
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwStoreLocation) {
            fUserRoot = TRUE;
            if (NULL == SystemNameInfo.hKeyBase) {
                if (ERROR_SUCCESS != (err = RegOpenHKCUEx(
                        &hHKCURoot,
                        REG_HKCU_DISABLE_DEFAULT_FLAG
                        )))
                    goto RegOpenHKCUExRootError;

                SystemNameInfo.hKeyBase = hHKCURoot;
                dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
            }
        } else if (CERT_SYSTEM_STORE_USERS == dwStoreLocation ||
                ((dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) &&
                    CERT_SYSTEM_STORE_LOCAL_MACHINE == dwStoreLocation))
            goto RootAccessDenied;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        DWORD dwStoreLocation;

        assert(!fUserRoot);
        if (NULL == (ClientGptStorePara.pwszRegPath = FormatSystemRegPath(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags,
                &ClientGptStorePara.hKeyBase)))
            goto FormatSystemRegPathError;
        pvOpenRegPara = (const void *) &ClientGptStorePara;

        dwOpenRegFlags =
            dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                CERT_STORE_SET_LOCALIZED_NAME_FLAG);
        dwOpenRegFlags |= CERT_REGISTRY_STORE_CLIENT_GPT_FLAG;
            // | CERT_REGISTRY_STORE_SERIALIZED_FLAG;

        dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
        if (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation)
            dwOpenRegFlags |= CERT_REGISTRY_STORE_LM_GPT_FLAG;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
    } else {
        BOOL fIsHKCUMyStore;

        fIsHKCUMyStore = IsHKCUStore(wsz_MY_STORE, &SystemNameInfo, dwFlags);

        if (fIsHKCUMyStore) {
            pwszRoamingDirectory =
                ILS_GetRoamingStoreDirectory(ROAMING_MY_STORE_SUBDIR);
        } else if (IsHKCUStore(wsz_REQUEST_STORE, &SystemNameInfo, dwFlags)) {
            pwszRoamingDirectory =
                ILS_GetRoamingStoreDirectory(ROAMING_REQUEST_STORE_SUBDIR);
        }

        if (NULL != pwszRoamingDirectory) {
            // OK for this to fail. After the first open, all contexts should
            // be persisted in files and not the registry.
            hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                );

            RoamingStorePara.hKey = hKey;
            RoamingStorePara.pwszStoreDirectory = pwszRoamingDirectory;
            pvOpenRegPara = (const void *) &RoamingStorePara;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            dwOpenRegFlags |= CERT_REGISTRY_STORE_ROAMING_FLAG;
        } else {
            if (NULL == (hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags)))
                goto OpenSystemStoreError;
            pvOpenRegPara = (const void *) hKey;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
                dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
            if (IsSerializedSystemStoreLocationInRegistry(dwFlags)) {
                assert(!fUserRoot);
                dwOpenRegFlags |= CERT_REGISTRY_STORE_SERIALIZED_FLAG;
            }
        }

        if (fIsHKCUMyStore)
            dwOpenRegFlags |= CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG;
    }

    if (fUserRoot)
        IPR_InitProtectedRootInfo();

    if (!I_CertDllOpenRegStoreProv(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwOpenRegFlags,
            pvOpenRegPara,
            hCertStore,
            pStoreProvInfo))
        goto OpenRegStoreProvError;

    if (fUserRoot) {
        PREG_STORE pRegStore = (PREG_STORE) pStoreProvInfo->hStoreProv;

        // Set count to 0 to inhibit any callbacks from being called.
        pStoreProvInfo->cStoreProvFunc = 0;

        // For the "Root" delete any roots that aren't in the protected root
        // list.
        if (!IPR_DeleteUnprotectedRootsFromStore(
                hCertStore,
                &pRegStore->fProtected
                )) goto DeleteUnprotectedRootsError;

        // For the "Root" replace some of the provider callback functions
        // that first prompt the user directly (if not protected) or
        // prompt the user via the system service (if protected).
        pStoreProvInfo->cStoreProvFunc = ROOT_STORE_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRootStoreProvFunc;
    }

    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
        SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    fResult = TRUE;
CommonReturn:
    if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] &&
            ClientGptStorePara.hKeyBase)
        ILS_CloseRegistryKey(ClientGptStorePara.hKeyBase);
    PkiFree(ClientGptStorePara.pwszRegPath);

    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszRoamingDirectory);
    ILS_CloseRegistryKey(hKey);
    if (hHKCURoot) {
        DWORD dwErr = GetLastError();
        RegCloseHKCU(hHKCURoot);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(RootAccessDenied, E_ACCESSDENIED)
SET_ERROR_VAR(RegOpenHKCUExRootError, err)
TRACE_ERROR(FormatSystemRegPathError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(OpenRegStoreProvError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (ascii version)
//
//  Open the system registry store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemRegistryStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}

typedef struct _OPEN_PHYSICAL_STORE_INFO {
    HCERTSTORE      hCollectionStore;
    LPCWSTR         pwszComputerName;       // NULL implies local
    LPCWSTR         pwszServiceName;        // NULL implies current
    LPCWSTR         pwszPhysicalName;       // NULL implies any
    HKEY            hKeyBase;               // non-NULL, relocatable
    DWORD           dwFlags;
    BOOL            fDidOpen;
} OPEN_PHYSICAL_STORE_INFO, *POPEN_PHYSICAL_STORE_INFO;


STATIC BOOL WINAPI OpenPhysicalStoreCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    BOOL fResult;
    HCERTSTORE hPhysicalStore = NULL;
    POPEN_PHYSICAL_STORE_INFO pOpenInfo =
        (POPEN_PHYSICAL_STORE_INFO) pvArg;
    void *pvOpenParameters;
    LPWSTR pwszRemoteOpenParameters = NULL;
    LPCSTR pszOpenStoreProvider;
    DWORD dwOpenFlags;
    DWORD dwAddFlags;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocateOpenParameters;

    if ((pStoreInfo->dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG)
                        ||
            (pOpenInfo->pwszPhysicalName &&
                0 != _wcsicmp(pOpenInfo->pwszPhysicalName, pwszStoreName))
                        ||
            (pOpenInfo->pwszComputerName &&
                (pStoreInfo->dwFlags &
                    CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)))
        return TRUE;

    pvOpenParameters = pStoreInfo->OpenParameters.pbData;
    assert(pvOpenParameters);
    dwOpenFlags = pStoreInfo->dwOpenFlags;
    pszOpenStoreProvider = pStoreInfo->pszOpenStoreProvider;

    if (pOpenInfo->pwszComputerName || pOpenInfo->pwszServiceName) {
        // Possibly insert the \\ComputerName\ServiceName before the
        // OpenParameters

        LPCWSTR pwszComputerName = NULL;
        LPCWSTR pwszServiceName = NULL;
        LPWSTR pwszSystemStore = (LPWSTR) pvOpenParameters;
        DWORD dwSystemProviderFlags =
            GetSystemProviderFlags(pszOpenStoreProvider);

        if (0 != dwSystemProviderFlags) {
            SYSTEM_NAME_INFO ProviderNameInfo;
            DWORD cReqName;

            if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
                goto RelocateFlagSetInPhysicalStoreInfoError;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                if (NULL == (pwszSystemStore =
                        MkWStr((LPSTR) pvOpenParameters)))
                    goto OutOfMemory;
            }

            if (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG)
                cReqName = 2;
            else
                cReqName = 1;

            ParseSystemStorePara(
                    pwszSystemStore,
                    dwOpenFlags,
                    cReqName,
                    &ProviderNameInfo      // zero'ed on error
                    );
            if (ProviderNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
                // Already has \\ComputerName\ prefix. For Services or
                // Users, already has ServiceName\ prefix.
                ;
            } else if (ProviderNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) {
                // Needed above check if ParseSystemStorePara failed.
                pwszComputerName = pOpenInfo->pwszComputerName;

                if (pOpenInfo->pwszServiceName) {
                    // If the provider store is located in CURRENT_SERVICE or
                    // CURRENT_USER use outer store's SERVICE_NAME and change
                    // store location accordingly

                    DWORD dwOpenLocation =
                        dwOpenFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_SERVICES;
                    } else if (CERT_SYSTEM_STORE_CURRENT_USER ==
                            dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_USERS;
                    }

                }
            }
            FreeSystemNameInfo(&ProviderNameInfo);
        } else if (pStoreInfo->dwFlags &
                CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG)
            pwszComputerName = pOpenInfo->pwszComputerName;

        if (pwszComputerName || pwszServiceName) {
            // Insert \\ComputerName\ServiceName before and re-format
            // open parameters
            LPCWSTR rgpwszName[3];
            SYSTEM_NAME_GROUP NameGroup;

            assert(pwszSystemStore);

            NameGroup.cName = 3;
            NameGroup.rgpwszName = rgpwszName;
            rgpwszName[0] = pwszComputerName;
            rgpwszName[1] = pwszServiceName;
            rgpwszName[2] = pwszSystemStore;
            pwszRemoteOpenParameters = FormatSystemNamePath(1, &NameGroup);
            pvOpenParameters = pwszRemoteOpenParameters;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
                pszOpenStoreProvider = ChangeAsciiToUnicodeProvider(
                    pszOpenStoreProvider);
        }

        if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
            FreeWStr(pwszSystemStore);
            if (NULL == pszOpenStoreProvider)
                goto UnableToChangeToUnicodeProvider;
        }
        if (NULL == pvOpenParameters)
            goto FormatSystemNamePathError;
    }

    if (NULL != pOpenInfo->hKeyBase &&
            0 != GetSystemProviderFlags(pszOpenStoreProvider)) {
        if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
            goto RelocateFlagSetInPhysicalStoreInfoError;

        // Inherit outer store's hKeyBase and convert to a relocated
        // physical store
        RelocateOpenParameters.hKeyBase = pOpenInfo->hKeyBase;
        RelocateOpenParameters.pvSystemStore = pvOpenParameters;
        pvOpenParameters = &RelocateOpenParameters;
        dwOpenFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
    }

    if (NULL == (hPhysicalStore = CertOpenStore(
            pszOpenStoreProvider,
            pStoreInfo->dwOpenEncodingType,
            0,                                  // hCryptProv
            dwOpenFlags | (pOpenInfo->dwFlags &
                                 (CERT_STORE_READONLY_FLAG |
                                  CERT_STORE_OPEN_EXISTING_FLAG |
                                  CERT_STORE_MANIFOLD_FLAG |
                                  CERT_STORE_SHARE_CONTEXT_FLAG |
                                  CERT_STORE_SHARE_STORE_FLAG |
                                  CERT_STORE_BACKUP_RESTORE_FLAG |
                                  CERT_STORE_UPDATE_KEYID_FLAG |
                                  CERT_STORE_ENUM_ARCHIVED_FLAG)),
            pvOpenParameters))) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr || ERROR_PROC_NOT_FOUND == dwErr ||
                ERROR_GEN_FAILURE == dwErr) {
            if (pOpenInfo->pwszPhysicalName &&
                    (dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG)) {
                // For a predefined physical convert to an empty collection
                CertAddStoreToCollection(
                    pOpenInfo->hCollectionStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
                goto OpenReturn;
            } else
                goto SuccessReturn;
        } else
            goto OpenPhysicalStoreError;
    }

    dwAddFlags = pStoreInfo->dwFlags;
    if ((dwOpenFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) &&
            0 == (dwAddFlags & CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG) &&
            pOpenInfo->pwszPhysicalName) {
        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        if (CertGetStoreProperty(
                hPhysicalStore,
                CERT_ACCESS_STATE_PROP_ID,
                &dwAccessStateFlags,
                &cbData
                )) {
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                dwAddFlags |= CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
        }
    }

    if (!CertAddStoreToCollection(
            pOpenInfo->hCollectionStore,
            hPhysicalStore,
            dwAddFlags,
            pStoreInfo->dwPriority))
        goto AddStoreToCollectionError;

OpenReturn:
    pOpenInfo->fDidOpen = TRUE;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pwszRemoteOpenParameters);
    if (hPhysicalStore)
        CertCloseStore(hPhysicalStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnableToChangeToUnicodeProvider, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoreError)
TRACE_ERROR(AddStoreToCollectionError)
TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR(RelocateFlagSetInPhysicalStoreInfoError, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (unicode version)
//
//  Open the system store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    SYSTEM_NAME_INFO SystemNameInfo;

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;

        assert(NULL == pStoreProvInfo->hStoreProvFuncAddr2);
        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[OPEN_SYSTEM_STORE_PROV_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &pStoreProvInfo->hStoreProvFuncAddr2))
            return FALSE;

        fResult = ((PFN_CERT_DLL_OPEN_STORE_PROV_FUNC) pvFuncAddr)(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara,
            hCertStore,
            pStoreProvInfo
            );
        // Note, hStoreProvFuncAddr2 is CryptFreeOIDFunctionAddress'ed by
        // CertCloseStore()
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterSystemStore(
                pvPara,
                dwFlags & UNREGISTER_FLAGS_MASK
                ))
            goto UnregisterSystemStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
            HKEY hKey;
            if (NULL == (hKey = OpenSystemStore(pvPara, dwFlags)))
                goto OpenSystemStoreError;
            RegCloseKey(hKey);
            dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        }

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = NULL;       // NULL implies any
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!EnumPhysicalStore(
                pvPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                ))
            goto EnumPhysicalStoreError;

        if (!OpenInfo.fDidOpen) {
            if (IsPredefinedSystemStore(
                    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX], dwFlags))
                // Convert to a collection store
                CertAddStoreToCollection(
                    hCertStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
            else
                goto PhysicalStoreNotFound;
        }

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
    }

    fResult = TRUE;
CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterSystemStoreError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (ascii version)
//
//  Open the system store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Open the physical store provider (unicode version)
//
//  Open the physical store in the specified system store. For example,
//  L"My\.Default".
//
//  pvPara contains the LPCWSTR pwszSystemAndPhysicalName which is the
//  concatenation of the system and physical store names with an
//  intervening "\".
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCWSTR pwszBoth;           // not allocated
    LPWSTR pwszSystem = NULL;   // allocated
    DWORD cchSystem;
    LPCWSTR pwszPhysical;       // not allocated

    void *pvSystemPara;         // not allocated
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & ~OPEN_PHY_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        if (NULL == pvPara)
            goto InvalidArg;
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        pwszBoth = pInPara->pwszSystemStore;
    } else
        pwszBoth = (LPCWSTR) pvPara;

    // Extract the system and physical name components by starting at
    // the end and searching backwards for the first "\"
    if (NULL == pwszBoth)
        goto InvalidArg;
    pwszPhysical = pwszBoth + wcslen(pwszBoth);
    while (pwszPhysical > pwszBoth && L'\\' != *pwszPhysical)
        pwszPhysical--;

    cchSystem = (DWORD)(pwszPhysical - pwszBoth);
    pwszPhysical++;     // advance past "\"
    if (0 < cchSystem && L'\0' != *pwszPhysical) {
        if (NULL == (pwszSystem = ILS_AllocAndCopyString(pwszBoth, cchSystem)))
            goto OutOfMemory;
    } else
        // Missing "\" or empty System or Physical Name.
        goto InvalidArg;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        RelocatePara.pwszSystemStore = pwszSystem;
        pvSystemPara = &RelocatePara;
    } else
        pvSystemPara = pwszSystem;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterPhysicalStore(
                pvSystemPara,
                dwFlags & UNREGISTER_FLAGS_MASK,
                pwszPhysical
                ))
            goto UnregisterPhysicalStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        SYSTEM_NAME_INFO SystemNameInfo;
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        // Note, already removed PhysicalName above. That's why
        // cReqName is 1 and not 2.
        if (!ParseSystemStorePara(
                pvSystemPara,
                dwFlags,
                1,                      // cReqName
                &SystemNameInfo))       // zero'ed on error
            goto ParseSystemStoreParaError;

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = pwszPhysical;
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // For .Default physical store, allow the store to be created.
        // Otherwise, the store must already exist.
        if (0 != _wcsicmp(CERT_PHYSICAL_STORE_DEFAULT_NAME, pwszPhysical))
            dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG |
                CERT_STORE_READONLY_FLAG;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        fResult = EnumPhysicalStore(
                pvSystemPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                );

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
            assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] =
                (LPWSTR) pwszPhysical;
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;
        }

        FreeSystemNameInfo(&SystemNameInfo);
        if (!fResult)
            goto EnumPhysicalStoreError;
        if (!OpenInfo.fDidOpen)
            goto PhysicalStoreNotFound;

    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    fResult = TRUE;
CommonReturn:
    PkiFree(pwszSystem);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterPhysicalStoreError)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}



//+=========================================================================
//  "ROOT" STORE
//==========================================================================

//+-------------------------------------------------------------------------
//  For "Root": prompt before adding a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;
    BYTE *pbSerializedElement = NULL;
    DWORD cbSerializedElement;

    assert(pRegStore);
    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;

    if (pRegStore->fProtected) {
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                NULL,           // pbElement
                &cbSerializedElement
                )) goto SerializeCertError;
        if (NULL == (pbSerializedElement = (BYTE *) PkiNonzeroAlloc(
                cbSerializedElement)))
            goto OutOfMemory;
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                pbSerializedElement,
                &cbSerializedElement
                )) goto SerializeCertError;

        fResult = I_CertProtectFunction(
            CERT_PROT_ADD_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            pbSerializedElement,
            cbSerializedElement,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else {
        // If the certificate doesn't already exist, then, prompt the user
        if (!RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
            if (IDYES != IPR_ProtectedRootMessageBox(
                    NULL,                               // hRpc
                    pCertContext,
                    IDS_ROOT_MSG_BOX_ADD_ACTION,
                    0))
                goto Cancelled;
        }

        fResult = RegStoreProvWriteCert(
            hStoreProv,
            pCertContext,
            dwFlags
            );
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    PkiFree(pbSerializedElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(SerializeCertError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  For "Root": prompt before deleting a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;

    if (pRegStore->fProtected) {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the thumbprint
        if(!CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash
                )) goto GetCertHashPropError;
        fResult = I_CertProtectFunction(
            CERT_PROT_DELETE_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            rgbHash,
            cbHash,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else {
        // Prompt the user before deleting
        if (RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
            if (IDYES != IPR_ProtectedRootMessageBox(
                    NULL,                               // hRpc
                    pCertContext,
                    IDS_ROOT_MSG_BOX_DELETE_ACTION,
                    0))
                goto Cancelled;

            fResult = RegStoreProvDeleteCert(
                hStoreProv,
                pCertContext,
                dwFlags
                );
        } else
            fResult = TRUE;
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(GetCertHashPropError)
}

//+=========================================================================
// Change Notify Support Functions
//==========================================================================

#if 0
typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;


WINBASEAPI
BOOL
WINAPI
RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

WINBASEAPI
BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    );

WINBASEAPI
BOOL
WINAPI
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );
#endif


typedef BOOL (WINAPI *PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT)(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

typedef BOOL (WINAPI *PFN_ILS_UNREGISTER_WAIT_EX)(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );

#define sz_KERNEL32_DLL                 "kernel32.dll"
#define sz_RegisterWaitForSingleObject  "RegisterWaitForSingleObject"
#define sz_UnregisterWaitEx             "UnregisterWaitEx"

static HMODULE hKernel32Dll = NULL;
PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT pfnILS_RegisterWaitForSingleObject;
PFN_ILS_UNREGISTER_WAIT_EX pfnILS_UnregisterWaitEx;

#define ILS_REG_WAIT_EXIT_HANDLE_INDEX      0
#define ILS_REG_WAIT_OBJECT_HANDLE_INDEX    1
#define ILS_REG_WAIT_HANDLE_COUNT           2

typedef struct _ILS_REG_WAIT_INFO {
    HANDLE                  hThread;
    DWORD                   dwThreadId;
    HANDLE                  rghWait[ILS_REG_WAIT_HANDLE_COUNT];
    ILS_WAITORTIMERCALLBACK Callback;
    PVOID                   Context;
    ULONG                   dwMilliseconds;
    HANDLE                  hDoneEvent;
} ILS_REG_WAIT_INFO, *PILS_REG_WAIT_INFO;


DWORD WINAPI ILS_WaitForThreadProc(
    LPVOID lpThreadParameter
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) lpThreadParameter;
    DWORD cWait;

    if (pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX])
        cWait = ILS_REG_WAIT_HANDLE_COUNT;
    else
        cWait = ILS_REG_WAIT_HANDLE_COUNT - 1;

    while (TRUE) {
        DWORD dwWaitObject;

        dwWaitObject = WaitForMultipleObjectsEx(
            cWait,
            pWaitInfo->rghWait,
            FALSE,      // bWaitAll
            pWaitInfo->dwMilliseconds,
            FALSE       // bAlertable
            );

        switch (dwWaitObject) {
            case WAIT_OBJECT_0 + ILS_REG_WAIT_OBJECT_HANDLE_INDEX:
                pWaitInfo->Callback(pWaitInfo->Context, TRUE);
                break;
            case WAIT_TIMEOUT:
                pWaitInfo->Callback(pWaitInfo->Context, FALSE);
                break;
            case WAIT_OBJECT_0 + ILS_REG_WAIT_EXIT_HANDLE_INDEX:
                if (pWaitInfo->hDoneEvent) {
                    SetEvent(pWaitInfo->hDoneEvent);
                }
                goto CommonReturn;
                break;
            default:
                goto InvalidWaitForObject;
        }
    }

CommonReturn:
    return 0;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(InvalidWaitForObject)
}


BOOL
WINAPI
ILS_RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
{
    BOOL fResult;
    PILS_REG_WAIT_INFO pWaitInfo = NULL;
    HANDLE hDupObject = NULL;

    if ( dwMilliseconds == 0 )
    {
        dwMilliseconds = INFINITE ;
    }

    if (NULL == (pWaitInfo = (PILS_REG_WAIT_INFO) PkiZeroAlloc(
            sizeof(ILS_REG_WAIT_INFO))))
        goto OutOfMemory;

    if (hObject) {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                hObject,
                GetCurrentProcess(),
                &hDupObject,
                0,                      // dwDesiredAccess
                FALSE,                  // bInheritHandle
                DUPLICATE_SAME_ACCESS
                ) || NULL == hDupObject)
            goto DuplicateEventError;
        pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX] = hDupObject;
    }
    pWaitInfo->Callback = Callback;
    pWaitInfo->Context = Context;
    pWaitInfo->dwMilliseconds = dwMilliseconds;

    // Create event to be signaled to terminate the thread
    if (NULL == (pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX] =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
        goto CreateThreadExitEventError;

    // Create the thread to do the wait for
    if (NULL == (pWaitInfo->hThread = CreateThread(
            NULL,           // lpThreadAttributes
            0,              // dwStackSize
            ILS_WaitForThreadProc,
            pWaitInfo,
            0,              // dwCreationFlags
            &pWaitInfo->dwThreadId
            )))
        goto CreateThreadError;

    fResult = TRUE;

CommonReturn:
    *hNewWaitObject = (HANDLE) pWaitInfo;
    return fResult;

ErrorReturn:
    if (pWaitInfo) {
        DWORD dwErr = GetLastError();

        for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
            if (pWaitInfo->rghWait[i])
                CloseHandle(pWaitInfo->rghWait[i]);
        }
        PkiFree(pWaitInfo);
        pWaitInfo = NULL;

        SetLastError(dwErr);
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(CreateThreadExitEventError)
TRACE_ERROR(CreateThreadError)
}


BOOL
WINAPI
ILS_UnregisterWait(
    HANDLE WaitHandle
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) WaitHandle;

    if (pWaitInfo->dwThreadId != GetCurrentThreadId()) {
        DWORD cWait;
        HANDLE rghWait[2];

        // On Win98 at ProcessDetach it might switch to one of the
        // threads we created.
        //
        // Alternatively, we may be called from the callback itself via
        // ILS_ExitWait()

        // Create event to be signaled by thread when its done executing
        pWaitInfo->hDoneEvent = CreateEvent(
            NULL,
            FALSE,
            FALSE,
            NULL
            );

        // Wake up the wait for thread.
        SetEvent(pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX]);

        // Wait for either the thread to exit or the thread to signal us.
        // We can't just wait on the thread handle because the
        // loader lock might already be held if we are being called
        // from a PROCESS_DETACH (in WinINet's DllMain for example).
        rghWait[0] = pWaitInfo->hThread;
        if (pWaitInfo->hDoneEvent) {
            rghWait[1] = pWaitInfo->hDoneEvent;
            cWait = 2;
        } else {
            cWait = 1;
        }

        WaitForMultipleObjectsEx(
            cWait,
            rghWait,
            FALSE,      // bWaitAll
            INFINITE,
            FALSE       // bAlertable
            );

        if (pWaitInfo->hDoneEvent)
            CloseHandle(pWaitInfo->hDoneEvent);
    }

    CloseHandle(pWaitInfo->hThread);
    for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
        if (pWaitInfo->rghWait[i])
            CloseHandle(pWaitInfo->rghWait[i]);
    }
    PkiFree(pWaitInfo);

    return TRUE;
}

BOOL
WINAPI
ILS_UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    )
{
    assert(CompletionEvent == INVALID_HANDLE_VALUE);
    return ILS_UnregisterWait(WaitHandle);
}

// Called from the callback function
BOOL
WINAPI
ILS_ExitWait(
    HANDLE WaitHandle,
    HMODULE hLibModule
    )
{
    ILS_UnregisterWait(WaitHandle);
    if (hLibModule)
        FreeLibraryAndExitThread(hLibModule, 0);
    else
        ExitThread(0);
}

STATIC void RegWaitForProcessAttach()
{
    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;

    if (NULL == (pfnILS_RegisterWaitForSingleObject =
            (PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT) GetProcAddress(
                hKernel32Dll, sz_RegisterWaitForSingleObject)))
        goto GetRegisterWaitForSingleObjectProcAddressError;
    if (NULL == (pfnILS_UnregisterWaitEx =
            (PFN_ILS_UNREGISTER_WAIT_EX) GetProcAddress(
                hKernel32Dll, sz_UnregisterWaitEx)))
        goto GetUnregisterWaitExProcAddressError;

CommonReturn:
    return;
ErrorReturn:
    pfnILS_RegisterWaitForSingleObject = ILS_RegisterWaitForSingleObject;
    pfnILS_UnregisterWaitEx = ILS_UnregisterWaitEx;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetRegisterWaitForSingleObjectProcAddressError)
TRACE_ERROR(GetUnregisterWaitExProcAddressError)
}

STATIC void RegWaitForProcessDetach()
{
    if (hKernel32Dll) {
        FreeLibrary(hKernel32Dll);
        hKernel32Dll = NULL;
    }
}


// Upon entry/exit, the resync list is locked by the caller
void ILS_RemoveEventFromResyncList(
    IN HANDLE hEvent,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cOrigEntry = *pcEntry;
    DWORD cNewEntry = 0;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;
    DWORD i;

    for (i = 0; i < cOrigEntry; i++) {
        if (pEntry[i].hOrigEvent == hEvent) {
            HANDLE hDupEvent;

            hDupEvent = pEntry[i].hDupEvent;
            if (hDupEvent)
                CloseHandle(hDupEvent);
        } else {
            if (i != cNewEntry)
                pEntry[cNewEntry] = pEntry[i];
            cNewEntry++;
        }
    }

    *pcEntry = cNewEntry;
}

// Upon entry/exit, the resync list is locked by the caller
BOOL ILS_AddRemoveEventToFromResyncList(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    BOOL fResult;
    HANDLE hDupEvent = NULL;
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;
    DWORD i;

    assert(hEvent);

    if (dwFlags & REG_STORE_CTRL_CANCEL_NOTIFY_FLAG) {
        ILS_RemoveEventFromResyncList(
            hEvent,
            pcEntry,
            ppEntry
            );
        return TRUE;
    }

    cEntry = *pcEntry;
    pEntry = *ppEntry;

    // First check if the hEvent is already in the list
    for (i = 0; i < cEntry; i++) {
        if (hEvent == pEntry[i].hOrigEvent)
            return TRUE;
    }

    if (0 == (dwFlags & CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG)) {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                hEvent,
                GetCurrentProcess(),
                &hDupEvent,
                0,                      // dwDesiredAccess
                FALSE,                  // bInheritHandle
                DUPLICATE_SAME_ACCESS
                ) || NULL == hDupEvent)
            goto DuplicateEventError;
    }

    if (NULL == (pEntry = (PILS_RESYNC_ENTRY) PkiRealloc(pEntry,
            (cEntry + 1) * sizeof(ILS_RESYNC_ENTRY))))
        goto OutOfMemory;
    pEntry[cEntry].hOrigEvent = hEvent;
    pEntry[cEntry].pRegStore = pRegStore;
    pEntry[cEntry].hDupEvent = hDupEvent;
    *pcEntry = cEntry + 1;
    *ppEntry = pEntry;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (hDupEvent)
        ILS_CloseHandle(hDupEvent);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(OutOfMemory)
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalEventsOnResyncList(
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cEntry = *pcEntry;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;

    while (cEntry--) {
        HANDLE hDupEvent;

        hDupEvent = pEntry[cEntry].hDupEvent;
        if (hDupEvent) {
            SetEvent(hDupEvent);
            CloseHandle(hDupEvent);
        } else
            SetEvent(pEntry[cEntry].hOrigEvent);
    }

    PkiFree(pEntry);

    *pcEntry = 0;
    *ppEntry = NULL;
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cOrigEntry = *pcEntry;
    DWORD cNewEntry = 0;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;
    DWORD i;

    for (i = 0; i < cOrigEntry; i++) {
        if (pEntry[i].pRegStore == pRegStore) {
            HANDLE hDupEvent;

            hDupEvent = pEntry[i].hDupEvent;
            if (hDupEvent) {
                SetEvent(hDupEvent);
                CloseHandle(hDupEvent);
            } else
                SetEvent(pEntry[i].hOrigEvent);
        } else {
            if (i != cNewEntry)
                pEntry[cNewEntry] = pEntry[i];
            cNewEntry++;
        }
    }

    *pcEntry = cNewEntry;
}

STATIC BOOL ILS_RegNotifyChangeKeyValue(
    IN HKEY hKey,
    IN HANDLE hEvent
    )
{
    BOOL fResult;
    LONG err;

    err = RegNotifyChangeKeyValue(
        hKey,
        TRUE,                       // bWatchSubtree
        REG_NOTIFY_CHANGE_NAME |
        REG_NOTIFY_CHANGE_LAST_SET,
        hEvent,
        TRUE                        // fAsynchronus
        );
    if (!(ERROR_SUCCESS == err || ERROR_KEY_DELETED == err))
        goto RegNotifyChangeKeyValueError;

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegNotifyChangeKeyValueError, err)
}


//+=========================================================================
//  Client "GPT" Store Data Structures and Functions
//==========================================================================

static PGPT_STORE_CHANGE_INFO pLMGptStoreChangeInfo;

typedef HANDLE (WINAPI *PFN_ENTER_CRITICAL_POLICY_SECTION)(
    IN BOOL bMachine
    );
typedef BOOL (WINAPI *PFN_LEAVE_CRITICAL_POLICY_SECTION)(
    IN HANDLE hSection
    );

typedef BOOL (WINAPI *PFN_REGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent,
    IN BOOL bMachine
    );

typedef BOOL (WINAPI *PFN_UNREGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent
    );

#define sz_USERENV_DLL                  "userenv.dll"
#define sz_EnterCriticalPolicySection   "EnterCriticalPolicySection"
#define sz_LeaveCriticalPolicySection   "LeaveCriticalPolicySection"
#define sz_RegisterGPNotification       "RegisterGPNotification"
#define sz_UnregisterGPNotification     "UnregisterGPNotification"

static fLoadedUserEnvDll = FALSE;
static HMODULE hUserEnvDll = NULL;
static PFN_ENTER_CRITICAL_POLICY_SECTION pfnEnterCriticalPolicySection = NULL;
static PFN_LEAVE_CRITICAL_POLICY_SECTION pfnLeaveCriticalPolicySection = NULL;
static PFN_REGISTER_GP_NOTIFICATION pfnRegisterGPNotification = NULL;
static PFN_UNREGISTER_GP_NOTIFICATION pfnUnregisterGPNotification = NULL;


//+-------------------------------------------------------------------------
//  Lock and unlock GPT_STORE functions
//--------------------------------------------------------------------------
static inline void GptStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void GptStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void GptLoadUserEnvDll()
{
    HMODULE hDll;
    if (fLoadedUserEnvDll)
        return;

    // Do load library without holding a lock
    hDll = LoadLibraryA(sz_USERENV_DLL);

    GptStoreLock();
    if (fLoadedUserEnvDll) {
        if (hDll)
            FreeLibrary(hDll);
        goto CommonReturn;
    }

    if (NULL == hDll)
        goto LoadUserEnvDllError;

    if (pfnEnterCriticalPolicySection =
            (PFN_ENTER_CRITICAL_POLICY_SECTION) GetProcAddress(
                hDll, sz_EnterCriticalPolicySection)) {
        if (NULL == (pfnLeaveCriticalPolicySection =
                (PFN_LEAVE_CRITICAL_POLICY_SECTION) GetProcAddress(
                    hDll, sz_LeaveCriticalPolicySection))) {
            pfnEnterCriticalPolicySection = NULL;
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_LeaveCriticalPolicySection, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_EnterCriticalPolicySection, dwErr, dwErr);
#endif
    }

    if (pfnRegisterGPNotification = 
        (PFN_REGISTER_GP_NOTIFICATION) GetProcAddress(
                hDll, sz_RegisterGPNotification)) {
        if (NULL == (pfnUnregisterGPNotification =
                (PFN_UNREGISTER_GP_NOTIFICATION) GetProcAddress(
                    hDll, sz_UnregisterGPNotification))) {
            pfnRegisterGPNotification = NULL; 
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_UnregisterGPNotification, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_RegisterGPNotification, dwErr, dwErr);
#endif
    }

    if (pfnEnterCriticalPolicySection || pfnRegisterGPNotification)
        hUserEnvDll = hDll;
    else
        FreeLibrary(hDll);

CommonReturn:
    fLoadedUserEnvDll = TRUE;
    GptStoreUnlock();

    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(LoadUserEnvDllError)
}

STATIC HANDLE GptStoreEnterCriticalPolicySection(
    IN BOOL bMachine
    )
{
#if 1
    // ATTENTION:: entering this critical section is causing numerous hanging,
    // deadlock problems
    return NULL;
#else
    HANDLE hSection;

    GptLoadUserEnvDll();
    if (NULL == pfnEnterCriticalPolicySection)
        return NULL;

    assert(hUserEnvDll);
    assert(pfnLeaveCriticalPolicySection);
    if (NULL == (hSection = pfnEnterCriticalPolicySection(bMachine)))
        goto EnterCriticalPolicySectionError;

CommonReturn:
    return hSection;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(EnterCriticalPolicySectionError)
#endif
}

STATIC void GptStoreLeaveCriticalPolicySection(
    IN HANDLE hSection
    )
{
    if (hSection) {
        assert(hUserEnvDll);
        assert(pfnLeaveCriticalPolicySection);
        if (!pfnLeaveCriticalPolicySection(hSection))
            goto LeaveCriticalPolicySectionError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(LeaveCriticalPolicySectionError)
}

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    GptStoreLock();
    if (pLMGptStoreChangeInfo)
        ILS_SignalAndFreeRegStoreResyncEntries(
            pRegStore,
            &pLMGptStoreChangeInfo->cNotifyEntry,
            &pLMGptStoreChangeInfo->rgNotifyEntry
            );
    GptStoreUnlock();
}

STATIC void GptStoreProcessAttach()
{
}

STATIC void GptStoreProcessDetach()
{
    FreeGptStoreChangeInfo(&pLMGptStoreChangeInfo);

    if (hUserEnvDll) {
        FreeLibrary(hUserEnvDll);
        hUserEnvDll = NULL;
    }
}

STATIC VOID NTAPI GptWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = (PGPT_STORE_CHANGE_INFO) Context;
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    assert(pInfo);
    assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
        CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

    if (NULL == pInfo)
        return;
    if (!(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
            CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType))
        return;

    if (pInfo->hGPNotificationEvent) {
        // We are called for all GPNotification events.
        // Check that we also have a registry change notify.

        if (pInfo->hPoliciesKey) {
            assert(pInfo->hPoliciesEvent);
            if (WAIT_OBJECT_0 != WaitForSingleObjectEx(
                    pInfo->hPoliciesEvent,
                    0,                          // dwMilliseconds
                    FALSE                       // bAlertable
                    ))
                return;
            // When policy is applied, the registry key is deleted before
            // reapplying policy.
            ILS_CloseRegistryKey(pInfo->hPoliciesKey);
        }

        // Re-Open the Software\Policies\Microsoft\SystemCertificates registry
        // key
        //
        // Ignore BACKUP_RESTORE case, in a different thread
        pInfo->hPoliciesKey = OpenSubKey(
            pInfo->hKeyBase,
            GROUP_POLICY_STORE_REGPATH,
            CERT_STORE_READONLY_FLAG
            );
    }

    if (pInfo->hPoliciesKey) {
        assert(pInfo->hPoliciesEvent);
        // Re-arm the registry notify
        ILS_RegNotifyChangeKeyValue(
            pInfo->hPoliciesKey,
            pInfo->hPoliciesEvent
            );
    }

    // Minimize window of potential deadlock by only getting the values
    // while holding the lock.
    if (pInfo->pRegStore) {
        assert(CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

        CertPerfIncrementChangeNotifyCuGpCount();

        LockRegStore(pInfo->pRegStore);
    } else {
        assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

        CertPerfIncrementChangeNotifyLmGpCount();

        GptStoreLock();
    }

            cEntry = pInfo->cNotifyEntry;
            pEntry = pInfo->rgNotifyEntry;

            pInfo->cNotifyEntry = 0;
            pInfo->rgNotifyEntry = NULL;

    if (pInfo->pRegStore)
        UnlockRegStore(pInfo->pRegStore);
    else
        GptStoreUnlock();

    ILS_SignalEventsOnResyncList(&cEntry, &pEntry);

    CertPerfIncrementChangeNotifyCount();
}

STATIC void FreeGptStoreChangeInfo(
    IN OUT PGPT_STORE_CHANGE_INFO *ppInfo
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = *ppInfo;

    if (NULL == pInfo)
        return;
    if (!(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
            CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType))
        return;

    // Unregister the wait for callback
    if (pInfo->hRegWaitFor)
        pfnILS_UnregisterWaitEx(pInfo->hRegWaitFor, INVALID_HANDLE_VALUE);

    if (pInfo->hGPNotificationEvent) {
        assert(hUserEnvDll && pfnUnregisterGPNotification);
        pfnUnregisterGPNotification(
            pInfo->hGPNotificationEvent);
        CloseHandle(pInfo->hGPNotificationEvent);
    }

    ILS_CloseRegistryKey(pInfo->hPoliciesKey);

    if (pInfo->hPoliciesEvent)
        CloseHandle(pInfo->hPoliciesEvent);

    // To inhibit any potential deadlock, do following without entering
    // the critical section
    ILS_SignalEventsOnResyncList(
        &pInfo->cNotifyEntry,
        &pInfo->rgNotifyEntry
        );

    PkiFree(pInfo);
    *ppInfo = NULL;
}

STATIC PGPT_STORE_CHANGE_INFO CreateGptStoreChangeInfo(
    IN PREG_STORE pRegStore,
    IN BOOL fMachine
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = NULL;
    DWORD dwErr;
    BOOL fGPNotify = FALSE;

    GptLoadUserEnvDll();

    if (NULL == (pInfo = (PGPT_STORE_CHANGE_INFO) PkiZeroAlloc(
            sizeof(GPT_STORE_CHANGE_INFO))))
        goto OutOfMemory;

    if (fMachine) {
        pInfo->dwType = LM_GPT_CHANGE_INFO_TYPE;
        // pInfo->pRegStore = NULL;
    } else {
        pInfo->dwType = CU_GPT_CHANGE_INFO_TYPE;
        pInfo->pRegStore = pRegStore;
    }

    pInfo->hKeyBase = pRegStore->GptPara.hKeyBase;

    // Create our own event to be notified on a change
    if (NULL == (pInfo->hPoliciesEvent = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL)))     // lpszEventName
        goto CreateEventError;

    // If the RegisterGPNotification API exists in userenv.dll, use it.
    if (pfnRegisterGPNotification) {
        if (NULL == (pInfo->hGPNotificationEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;
        if (pfnRegisterGPNotification(
                pInfo->hGPNotificationEvent,
                fMachine
                ))
            fGPNotify = TRUE;
        else {
#if DBG
            dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "RegisterGPNotification returned error: %d 0x%x\n",
                    dwErr, dwErr);
#endif
            CloseHandle(pInfo->hGPNotificationEvent);
            pInfo->hGPNotificationEvent = NULL;
        }
    }

    // Open the Software\Policies\Microsoft\SystemCertificates registry key
    //
    // Ignore BACKUP_RESTORE case
    if (NULL == (pInfo->hPoliciesKey = OpenSubKey(
            pInfo->hKeyBase,
            GROUP_POLICY_STORE_REGPATH,
            CERT_STORE_READONLY_FLAG
            ))) {
        if (!fGPNotify) {
            // Ignore error if subkey doesn't exist.
            if (ERROR_FILE_NOT_FOUND == GetLastError())
                goto SuccessReturn;
            goto OpenSubKeyError;
        }
    } else {
        // Arm the registry notify
        if (!ILS_RegNotifyChangeKeyValue(
                pInfo->hPoliciesKey,
                pInfo->hPoliciesEvent
                ))
            goto RegNotifyChangeKeyValueError;
    }

    if (!pfnILS_RegisterWaitForSingleObject(
            &pInfo->hRegWaitFor,
            fGPNotify ? pInfo->hGPNotificationEvent : pInfo->hPoliciesEvent,
            GptWaitForCallback,
            (PVOID) pInfo,
            INFINITE,  // no timeout
            WT_EXECUTEINWAITTHREAD
            )) {
        pInfo->hRegWaitFor = NULL;
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

SuccessReturn:
CommonReturn:
    return pInfo;
ErrorReturn:
    dwErr = GetLastError();

    FreeGptStoreChangeInfo(&pInfo);

    SetLastError(dwErr);
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateEventError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

// For LocalMachine: a single store change info data structure for all LMGP
// stores.
//
// For CurrentUser: each CUCP store has its own store change info.
STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PGPT_STORE_CHANGE_INFO pInfo;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG) {
        if (NULL == (pInfo = pLMGptStoreChangeInfo)) {
            if (NULL == (pInfo = CreateGptStoreChangeInfo(
                    pRegStore,
                    TRUE        // fMachine
                    )))
                goto CreateChangeInfoError;

            GptStoreLock();
            if (pLMGptStoreChangeInfo) {
                GptStoreUnlock();
                FreeGptStoreChangeInfo(&pInfo);
                pInfo = pLMGptStoreChangeInfo;
            } else {
                pLMGptStoreChangeInfo = pInfo;
                GptStoreUnlock();
            }
        }

        assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType);
        GptStoreLock();
        fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            );
        GptStoreUnlock();
    } else {
        if (NULL == (pInfo = pRegStore->pGptStoreChangeInfo)) {
            if (NULL == (pInfo = CreateGptStoreChangeInfo(
                    pRegStore,
                    FALSE       // fMachine
                    )))
                goto CreateChangeInfoError;

            LockRegStore(pRegStore);
            if (pRegStore->pGptStoreChangeInfo) {
                UnlockRegStore(pRegStore);
                FreeGptStoreChangeInfo(&pInfo);
                pInfo = pRegStore->pGptStoreChangeInfo;
            } else {
                pRegStore->pGptStoreChangeInfo = pInfo;
                UnlockRegStore(pRegStore);
            }
        }

        assert(CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);
        LockRegStore(pRegStore);
        fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            );
        UnlockRegStore(pRegStore);
    }

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateChangeInfoError)
}

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HANDLE hSection = NULL;

    LockRegStore(pRegStore);

    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        hSection = GptStoreEnterCriticalPolicySection(
            pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG
            );

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError() ||
                (pRegStore->dwFlags & CERT_STORE_OPEN_EXISTING_FLAG))
            goto OpenSubKeyError;
        fResult = TRUE;
        goto CommonReturn;
    }

//    fResult = OpenAllFromSerializedRegistry(pRegStore, hCertStore);

    // Ignore any errors
    OpenAllFromRegistry(pRegStore, hCertStore);
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    GptStoreLeaveCriticalPolicySection(hSection);
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
}

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
#if 1
    return TRUE;
#else
    BOOL fResult;
    BOOL fTouched;
    DWORD dwSaveFlags;

    LockRegStore(pRegStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;
    } else {
        pRegStore->fTouched = FALSE;
        fResult = TRUE;
        goto CommonReturn;
    }

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    dwSaveFlags = pRegStore->dwFlags;
    pRegStore->dwFlags &= ~CERT_STORE_OPEN_EXISTING_FLAG;
    fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
    pRegStore->dwFlags = dwSaveFlags;
CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenSubKeyError)
#endif
}


//+=========================================================================
//  Win95 Notify Store Data Structures and Functions
//
//  Win95/Win98 don't support registry change notification.
//
//  On Win95 we pulse an event each time a store context element is written
//  or deleted.
//==========================================================================
static BOOL fWin95StoreInitialized;
static HANDLE hWin95RegWaitFor;

static DWORD cWin95StoreResyncEntry;
static ILS_RESYNC_ENTRY *pWin95StoreResyncEntry;


//+-------------------------------------------------------------------------
//  Lock and unlock WIN95_STORE functions
//--------------------------------------------------------------------------
static inline void Win95StoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void Win95StoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    if (NULL == hWin95NotifyEvent)
        return;

    Win95StoreLock();

    ILS_SignalAndFreeRegStoreResyncEntries(
        pRegStore,
        &cWin95StoreResyncEntry,
        &pWin95StoreResyncEntry
        );

    Win95StoreUnlock();
}

STATIC void Win95StoreProcessAttach()
{
    if (FIsWinNT())
        return;

    hWin95NotifyEvent = CreateEventA(
            NULL,           // lpsa
            TRUE,           // fManualReset
            FALSE,          // fInitialState
            "Win95CertStoreNotifyEvent"
            );
    if (NULL == hWin95NotifyEvent)
        goto CreateWin95NotifyEventError;

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CreateWin95NotifyEventError)
}

STATIC void Win95StoreProcessDetach()
{
    if (NULL == hWin95NotifyEvent)
        return;

    if (fWin95StoreInitialized) {
        // Unregister the wait for callback
        assert(hWin95RegWaitFor);
        pfnILS_UnregisterWaitEx(hWin95RegWaitFor, INVALID_HANDLE_VALUE);

        // To inhibit any potential deadlock, do following without entering
        // the critical section
        ILS_SignalEventsOnResyncList(
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );

        fWin95StoreInitialized = FALSE;
    }

    CloseHandle(hWin95NotifyEvent);
}

STATIC VOID NTAPI Win95WaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    Win95StoreLock();
        cEntry = cWin95StoreResyncEntry;
        pEntry = pWin95StoreResyncEntry;

        cWin95StoreResyncEntry = 0;
        pWin95StoreResyncEntry = NULL;
    Win95StoreUnlock();

    ILS_SignalEventsOnResyncList(
        &cEntry,
        &pEntry
        );
}

STATIC BOOL Win95StoreChangeInit()
{
    BOOL fResult;
    DWORD dwErr;
    HANDLE hRegWaitFor;

    if (fWin95StoreInitialized)
        return TRUE;

    Win95StoreLock();

    if (fWin95StoreInitialized)
        goto SuccessReturn;

    assert(hWin95NotifyEvent);
    if (!pfnILS_RegisterWaitForSingleObject(
            &hRegWaitFor,
            hWin95NotifyEvent,
            Win95WaitForCallback,
            NULL,                   // Context
            INFINITE,               // no timeout
            0                       // no flags (normal)
            )) {
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    hWin95RegWaitFor = hRegWaitFor;

SuccessReturn:
    fResult = TRUE;
    fWin95StoreInitialized = TRUE;

CommonReturn:
    Win95StoreUnlock();
    return fResult;;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    assert(hWin95NotifyEvent);

    if (!Win95StoreChangeInit())
        return FALSE;

    Win95StoreLock();
    fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );
    Win95StoreUnlock();
    return fResult;
}



//+=========================================================================
// Roaming Store Functions
//==========================================================================

#if 0
SHSTDAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR lpszPath);
#endif

typedef HRESULT (STDAPICALLTYPE *PFN_GET_FOLDER_PATH) (
    HWND hwnd,
    int csidl,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR lpszPath
    );

#define sz_SHELL32_DLL              "shell32.dll"
#define sz_GetFolderPath            "SHGetFolderPathW"

static fLoadedShell32Dll = FALSE;
static HMODULE hShell32Dll = NULL;
static PFN_GET_FOLDER_PATH pfnGetFolderPath = NULL;

#if 0
// from \nt\public\internal\ds\inc\userenvp.h
USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathW(
    IN HANDLE hToken, 
    OUT LPWSTR lpFolderPath
    );
#endif

typedef DWORD (WINAPI *PFN_GET_USER_APP_DATA_PATH) (
    IN HANDLE hToken, 
    OUT LPWSTR lpFolderPath
    );

#define sz_ROAMING_USERENV_DLL      "userenv.dll"
#define wsz_ROAMING_USERENV_DLL     L"userenv.dll"
// From \nt\ds\security\gina\userenv\main\userenv.def
//  GetUserAppDataPathW          @149    NONAME ;Internal
#define ORDINAL_GetUserAppDataPath  149
// First version to support GetUserAppDataPath
#define ROAMING_USERENV_DLL_VER_MS  ((    5 << 16) |   1 )
#define ROAMING_USERENV_DLL_VER_LS  (( 2465 << 16) |   0 )

static fLoadedRoamingUserenvDll = FALSE;
static HMODULE hRoamingUserenvDll = NULL;
static PFN_GET_USER_APP_DATA_PATH pfnGetUserAppDataPath = NULL;

static inline void RoamingStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void RoamingStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void RoamingStoreProcessAttach()
{
}

STATIC void RoamingStoreProcessDetach()
{
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
    }

    if (hRoamingUserenvDll) {
        FreeLibrary(hRoamingUserenvDll);
        hRoamingUserenvDll = NULL;
    }
}

STATIC void RoamingStoreLoadShell32Dll()
{
    if (fLoadedShell32Dll)
        return;

    RoamingStoreLock();
    if (fLoadedShell32Dll)
        goto CommonReturn;

    if (NULL == (hShell32Dll = LoadLibraryA(sz_SHELL32_DLL)))
        goto LoadShell32DllError;

    if (NULL == (pfnGetFolderPath =
            (PFN_GET_FOLDER_PATH) GetProcAddress(hShell32Dll,
                sz_GetFolderPath)))
        goto GetFolderPathProcAddressError;

CommonReturn:
    fLoadedShell32Dll = TRUE;
    RoamingStoreUnlock();
    return;

ErrorReturn:
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
        pfnGetFolderPath = NULL;
    }
    goto CommonReturn;
TRACE_ERROR(LoadShell32DllError)
TRACE_ERROR(GetFolderPathProcAddressError)
}

STATIC void RoamingStoreLoadUserenvDll()
{
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;

    if (fLoadedRoamingUserenvDll)
        return;

    RoamingStoreLock();
    if (fLoadedRoamingUserenvDll)
        goto CommonReturn;

    // GetUserAppDataPath() not supported until later versions of userenv.dll
    // in WXP
    if (!I_CryptGetFileVersion(
            wsz_ROAMING_USERENV_DLL,
            &dwFileVersionMS,
            &dwFileVersionLS
            ))
        goto GetUserenvFileVersionError;
    if (ROAMING_USERENV_DLL_VER_MS < dwFileVersionMS)
        ;
    else if (ROAMING_USERENV_DLL_VER_MS == dwFileVersionMS &&
                ROAMING_USERENV_DLL_VER_LS <= dwFileVersionLS)
        ;
    else
        goto Userenv_GetUserAppDataPathNotSupported;

    if (NULL == (hRoamingUserenvDll = LoadLibraryA(sz_ROAMING_USERENV_DLL)))
        goto LoadUserenvDllError;

    if (NULL == (pfnGetUserAppDataPath =
            (PFN_GET_USER_APP_DATA_PATH) GetProcAddress(hRoamingUserenvDll,
                (LPCSTR) ORDINAL_GetUserAppDataPath)))
        goto GetUserAppDataPathProcAddressError;

CommonReturn:
    fLoadedRoamingUserenvDll = TRUE;
    RoamingStoreUnlock();
    return;

ErrorReturn:
    if (hRoamingUserenvDll) {
        FreeLibrary(hRoamingUserenvDll);
        hRoamingUserenvDll = NULL;
        pfnGetUserAppDataPath = NULL;
    }
    goto CommonReturn;
TRACE_ERROR(GetUserenvFileVersionError)
SET_ERROR_VAR(Userenv_GetUserAppDataPathNotSupported, ERROR_NOT_SUPPORTED)
TRACE_ERROR(LoadUserenvDllError)
TRACE_ERROR(GetUserAppDataPathProcAddressError)
}

STATIC HANDLE GetRoamingToken()
{
    HANDLE hToken = NULL;
    DWORD dwErr;

    if (!FIsWinNT()) {
        return NULL;
    }

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        dwErr = GetLastError();
        if (ERROR_NO_TOKEN != dwErr)
            goto OpenThreadTokenError;

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &hToken)) {
            dwErr = GetLastError();
            goto OpenProcessTokenError;
        }
    }

CommonReturn:
    return hToken;
ErrorReturn:
    hToken = NULL;
    goto CommonReturn;
SET_ERROR_VAR(OpenThreadTokenError, dwErr)
SET_ERROR_VAR(OpenProcessTokenError, dwErr)
}

STATIC
DWORD 
FastGetUserAppDataPath(
    IN HANDLE hToken, 
    OUT WCHAR wszFolderPath[MAX_PATH]
    )
{
    DWORD dwErr;

    RoamingStoreLoadUserenvDll();
    if (NULL == hRoamingUserenvDll)
        goto ErrorReturn;
    assert(pfnGetUserAppDataPath);

    wszFolderPath[0] = L'\0';
    __try {
        dwErr = pfnGetUserAppDataPath(
                hToken,
                wszFolderPath
                );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
        goto GetUserAppDataPathException;
    }

    if (ERROR_SUCCESS != dwErr || L'\0' == wszFolderPath[0])
        goto GetUserAppDataPathError;

#if DBG
        DbgPrintf(DBG_SS_CRYPT32, "userenv!GetUserAppDataPath:: %S\n",
            wszFolderPath);
#endif

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
ErrorReturn:
    dwErr = ERROR_FILE_NOT_FOUND;
    goto CommonReturn;

SET_ERROR_VAR(GetUserAppDataPathException, dwErr)
SET_ERROR_VAR(GetUserAppDataPathError, dwErr)
}

STATIC
DWORD 
SlowGetUserAppDataPath(
    IN HANDLE hToken, 
    OUT WCHAR wszFolderPath[MAX_PATH]
    )
{
    DWORD dwErr;
    HRESULT hr;

    RoamingStoreLoadShell32Dll();
    if (NULL == hShell32Dll)
        goto ErrorReturn;
    assert(pfnGetFolderPath);

    wszFolderPath[0] = L'\0';
    hr = pfnGetFolderPath(
            NULL,                   // hwndOwner
            CSIDL_APPDATA | CSIDL_FLAG_CREATE,
            hToken,
            0,                      // dwFlags
            wszFolderPath
            );
    if (S_OK != hr || L'\0' == wszFolderPath[0])
        goto GetFolderPathError;

#if DBG
        DbgPrintf(DBG_SS_CRYPT32, "SHFolderPath(CSIDL_APPDATA):: %S\n",
            wszFolderPath);
#endif

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
ErrorReturn:
    dwErr = ERROR_FILE_NOT_FOUND;
    goto CommonReturn;

SET_ERROR_VAR(GetFolderPathError, hr)
}

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    )
{
    DWORD dwErr;
    HANDLE hToken = NULL;
    LPWSTR pwszDir = NULL;
    WCHAR wszFolderPath[MAX_PATH];
    LPCWSTR rgpwszName[] = { wszFolderPath, pwszStoreName };
    SYSTEM_NAME_GROUP NameGroup;

    hToken = GetRoamingToken();

    dwErr = FastGetUserAppDataPath(hToken, wszFolderPath);
    if (ERROR_SUCCESS != dwErr)
        dwErr = SlowGetUserAppDataPath(hToken, wszFolderPath);
    if (ERROR_SUCCESS != dwErr)
        goto GetUserAppDataPathError;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

CommonReturn:
    if (hToken)
        ILS_CloseHandle(hToken);
    return pwszDir;
ErrorReturn:
    pwszDir = NULL;
    goto CommonReturn;

SET_ERROR_VAR(GetUserAppDataPathError, dwErr)
TRACE_ERROR(FormatSystemNamePathError)
}

static DWORD rgdwCreateFileRetryMilliseconds[] =
    { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) / \
                sizeof(rgdwCreateFileRetryMilliseconds[0]))

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
              NULL                    // hTemplateFile
              ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else {
            if (ERROR_PATH_NOT_FOUND == dwErr)
                dwErr = ERROR_FILE_NOT_FOUND;
            goto CreateFileError;
        }
    }

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileSizeError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto FileError;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateFileError, dwErr)
TRACE_ERROR(FileSizeError)
SET_ERROR_VAR(FileError, dwErr)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
}

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG or
                            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesWritten;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;
    NameGroup.cName--;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (!I_RecursiveCreateDirectory(pwszDir, NULL))
        goto CreateDirError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
            pwszFilename,
            GENERIC_WRITE,
            0,                        // fdwShareMode
            NULL,                     // lpsa
            (dwFlags & CERT_STORE_CREATE_NEW_FLAG) ?
                CREATE_NEW : CREATE_ALWAYS,
            FILE_ATTRIBUTE_SYSTEM |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
            NULL                      // hTemplateFile
            ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto CreateFileError;
    }

    if (!WriteFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto WriteFileError;
    }

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    PkiFree(pwszFilename);
    PkiFree(pwszDir);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(CreateFileError, dwErr)
SET_ERROR_VAR(WriteFileError, dwErr)
}

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (!DeleteFileU(pwszFilename)) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto DeleteFileError;
    }

    fResult = TRUE;

CommonReturn:
    PkiFree(pwszFilename);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(DeleteFileError, dwErr)
}


BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, L"*" };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindFileData;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileU(
            pwszDir,
            &FindFileData
            ))) {
        dwErr = GetLastError();
        if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
            goto FindFirstFileError;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto FindFirstFileError;

        // Attempt to create the directory. Need to remove trailing L"*".
        PkiFree(pwszDir);
        NameGroup.cName--;
        if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
            goto FormatSystemNamePathError;
        if (!I_RecursiveCreateDirectory(pwszDir, NULL))
            goto CreateDirError;

        goto SuccessReturn;
    }

    while (TRUE) {
        if (0 == (FILE_ATTRIBUTE_DIRECTORY & FindFileData.dwFileAttributes) &&
                0 == FindFileData.nFileSizeHigh &&
                0 != FindFileData.nFileSizeLow &&
                L'\0' != FindFileData.cFileName[0]) {
            BYTE *pbElement;
            DWORD cbElement;

            if (ILS_ReadElementFromFile(
                    pwszStoreDir,
                    pwszContextName,
                    FindFileData.cFileName,
                    dwFlags,
                    &pbElement,
                    &cbElement
                    )) {
                fResult = pfnOpenElement(
                    FindFileData.cFileName,
                    pbElement,
                    cbElement,
                    pvArg
                    );

                PkiFree(pbElement);
                if (!fResult)
                    goto CommonReturn;
            }
        }


        if (!FindNextFileU(hFindFile, &FindFileData)) {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_FILES == dwErr)
                goto SuccessReturn;
            else
                goto FindNextFileError;
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    PkiFree(pwszDir);
    if (INVALID_HANDLE_VALUE != hFindFile) {
        dwErr = GetLastError();
        FindClose(hFindFile);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(FindFirstFileError, dwErr)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(FindNextFileError, dwErr)
}

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================

STATIC VOID NTAPI RegistryStoreChangeCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    BOOL fRearm;
    DWORD dwErr = 0;
    PREG_STORE pRegStore = (PREG_STORE) Context;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    pInfo = pRegStore->pRegistryStoreChangeInfo;
    assert(pInfo);
    if (NULL == pInfo)
        return;

    CertPerfIncrementChangeNotifyCount();

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        fRearm = FindNextChangeNotification(pInfo->hChange);

        CertPerfIncrementChangeNotifyCuMyCount();

    } else {
        fRearm = ILS_RegNotifyChangeKeyValue(pRegStore->hKey, pInfo->hChange);

        CertPerfIncrementChangeNotifyRegCount();

    }
    if (!fRearm)
        dwErr = GetLastError();

    // Minimize window of potential deadlock by only getting the values
    // while holding the lock.
    LockRegStore(pRegStore);
    cEntry = pInfo->cNotifyEntry;
    pEntry = pInfo->rgNotifyEntry;

    pInfo->cNotifyEntry = 0;
    pInfo->rgNotifyEntry = NULL;
    UnlockRegStore(pRegStore);

    ILS_SignalEventsOnResyncList(&cEntry, &pEntry);


    if (!fRearm)
        goto RegistryStoreChangeRearmError;
CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
SET_ERROR_VAR(RegistryStoreChangeRearmError, dwErr)
}

// Upon entry/exit the pRegStore is locked
STATIC BOOL InitRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    BOOL fResult;
    DWORD dwErr;
    BOOL fRoaming;
    PREGISTRY_STORE_CHANGE_INFO pInfo = NULL;
    HANDLE hChange = INVALID_HANDLE_VALUE;
    HANDLE hRegWaitFor;

    fRoaming = (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG);

    assert(NULL == pRegStore->pRegistryStoreChangeInfo);
    if (NULL == (pInfo = (PREGISTRY_STORE_CHANGE_INFO) PkiZeroAlloc(
            sizeof(REGISTRY_STORE_CHANGE_INFO))))
        goto OutOfMemory;
    pInfo->dwType = REG_CHANGE_INFO_TYPE;

    if (fRoaming) {
        if (INVALID_HANDLE_VALUE == (hChange = FindFirstChangeNotificationU(
                pRegStore->pwszStoreDirectory,
                TRUE,                           // bWatchSubtree
                FILE_NOTIFY_CHANGE_FILE_NAME |
                    FILE_NOTIFY_CHANGE_DIR_NAME |
                    FILE_NOTIFY_CHANGE_SIZE |
                    FILE_NOTIFY_CHANGE_LAST_WRITE
                ))) {
            dwErr = GetLastError();
            goto FindFirstChangeNotificationError;
        }
    } else {
        if (NULL == (hChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;
        assert(pRegStore->hKey);
        if (!ILS_RegNotifyChangeKeyValue(pRegStore->hKey, hChange))
            goto RegNotifyChangeKeyValueError;
    }
    pInfo->hChange = hChange;

    // The following must be set before the following register.
    // The thread may be scheduled to run before the function returns.
    pRegStore->pRegistryStoreChangeInfo = pInfo;

    if (!pfnILS_RegisterWaitForSingleObject(
            &hRegWaitFor,
            hChange,
            RegistryStoreChangeCallback,
            (PVOID) pRegStore,
            INFINITE,                                      // no timeout
            WT_EXECUTEINWAITTHREAD
            )) {
        pRegStore->pRegistryStoreChangeInfo = NULL;
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    pInfo->hRegWaitFor = hRegWaitFor;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (INVALID_HANDLE_VALUE != hChange && hChange) {
        dwErr = GetLastError();

        if (fRoaming)
            FindCloseChangeNotification(hChange);
        else
            CloseHandle(hChange);

        SetLastError(dwErr);
    }
    PkiFree(pInfo);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(FindFirstChangeNotificationError, dwErr)
TRACE_ERROR(CreateEventError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    LockRegStore(pRegStore);

    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo)) {
        if (!InitRegistryStoreChange(pRegStore))
            goto ChangeInitError;
        pInfo = pRegStore->pRegistryStoreChangeInfo;
        assert(pInfo);
        assert(REG_CHANGE_INFO_TYPE == pInfo->dwType);
    }

    if (!ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            ))
        goto AddRemoveEventError;

    fResult = TRUE;

CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ChangeInitError)
TRACE_ERROR(AddRemoveEventError)
}


STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    PREGISTRY_STORE_CHANGE_INFO pInfo;
    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo))
        return;
    if (REG_CHANGE_INFO_TYPE != pInfo->dwType)
        return;

    assert(pInfo->hRegWaitFor);
    pfnILS_UnregisterWaitEx(pInfo->hRegWaitFor, INVALID_HANDLE_VALUE);

    assert(pInfo->hChange);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        FindCloseChangeNotification(pInfo->hChange);
    else
        CloseHandle(pInfo->hChange);

    ILS_SignalEventsOnResyncList(
        &pInfo->cNotifyEntry,
        &pInfo->rgNotifyEntry
        );

    PkiFree(pInfo);
    pRegStore->pRegistryStoreChangeInfo = NULL;
}


//+=========================================================================
// Key Identifier Functions
//==========================================================================

STATIC HKEY OpenKeyIdStoreSubKey(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    SYSTEM_NAME_INFO SystemNameInfo;
    memset(&SystemNameInfo, 0, sizeof(SystemNameInfo));
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = wsz_MY_STORE;
    SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] = (LPWSTR) pwszComputerName;

    return OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );
}

BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_ReadElementFromFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                &pbElement,
                &cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto ReadElementFromFileError;
            } else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_ReadElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            &pbElement,
            &cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;

ErrorReturn:
    assert(NULL == pbElement && 0 == cbElement);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(ReadElementFromRegistryError)
}

BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_WriteElementToFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                pbElement,
                cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto WriteElementToFileError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_WriteElementToRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            pbElement,
            cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto WriteElementToRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(WriteElementToRegistryError)
}


BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_DeleteElementFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0                           // dwFlags
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto DeleteElementFromDirectoryError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_DeleteElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0                           // dwFlags
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto DeleteElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteElementFromDirectoryError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(DeleteElementFromRegistryError)
}

typedef struct _OPEN_KEYID_CALLBACK_ARG {
    void                        *pvArg;
    PFN_ILS_OPEN_KEYID_ELEMENT  pfnOpenKeyId;
} OPEN_KEYID_CALLBACK_ARG, *POPEN_KEYID_CALLBACK_ARG;

STATIC BOOL OpenKeyIdElementCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    POPEN_KEYID_CALLBACK_ARG pKeyIdArg = (POPEN_KEYID_CALLBACK_ARG) pvArg;

    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB KeyIdentifier;

    WStrToBytes(wszHashName, rgbHash, &cbHash);
    KeyIdentifier.cbData = cbHash;
    KeyIdentifier.pbData = rgbHash;

    return pKeyIdArg->pfnOpenKeyId(
        &KeyIdentifier,
        pbElement,
        cbElement,
        pKeyIdArg->pvArg
        );
}

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    )
{
    BOOL fResult;
    BOOL fOpenFile = FALSE;

    OPEN_KEYID_CALLBACK_ARG KeyIdArg = { pvArg, pfnOpenKeyId };

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_OpenAllElementsFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                0,                          // dwFlags
                (void *) &KeyIdArg,
                OpenKeyIdElementCallback
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto ErrorReturn;
            else
                fOpenFile = TRUE;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_OpenAllElementsFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            0,                          // dwFlags
            (void *) &KeyIdArg,
            OpenKeyIdElementCallback
            );

        ILS_CloseRegistryKey(hKey);
    }

CommonReturn:
    if (fOpenFile)
        // Ignore any registry errors
        return TRUE;
    else
        return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenKeyIdStoreSubKeyError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\memory.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       memory.cpp
//
//  Contents:   Crypt32 Memory Management Routines
//
//  History:    22-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   CryptMemAlloc
//
//  Synopsis:   Allocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemAlloc (
                   IN ULONG cbSize
                   )
{
    return( malloc( cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemRealloc
//
//  Synopsis:   reallocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemRealloc (
                   IN LPVOID pv,
                   IN ULONG cbSize
                   )
{
    return( realloc( pv, cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemFree
//
//  Synopsis:   free memory
//
//----------------------------------------------------------------------------
VOID WINAPI CryptMemFree (
                 IN LPVOID pv
                 )
{
    free( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\oidconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidconv.cpp
//
//  Contents:   Object ID (OID) Conv Functions
//
//  Functions:  I_CryptOIDConvDllMain
//              I_CryptSetEncodedOID
//              I_CryptGetEncodedOID
//
//  Comments:
//
//  History:    08_Feb-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

typedef struct _OID_HASH_BUCKET_ENTRY
    OID_HASH_BUCKET_ENTRY, *POID_HASH_BUCKET_ENTRY;

// pbEncodedOID immediately follows the data structure. pszDotOID
// is at pbEncodedOID + cbEncodedOID. pszDotOID is null terminated.
// cchDotOID doesn't include the null terminator.
struct _OID_HASH_BUCKET_ENTRY {
    DWORD                   cbEncodedOID;
    DWORD                   cchDotOID;
    POID_HASH_BUCKET_ENTRY  pEncodedNext;
    POID_HASH_BUCKET_ENTRY  pDotNext;
};

static inline BYTE * GetEncodedOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return ((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY);
}
static inline LPSTR GetDotOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return (LPSTR) (((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY) +
        pEntry->cbEncodedOID);
}

// Some prime numbers: 11, 13, 19, 23, 29, 31, 47, 53, 61, 73, 97,
//                     101, 127, 251, 509

#define ENCODED_OID_HASH_BUCKET_COUNT   47
#define DOT_OID_HASH_BUCKET_COUNT       31

static POID_HASH_BUCKET_ENTRY
            rgpEncodedOIDHashBucket[ENCODED_OID_HASH_BUCKET_COUNT];
static POID_HASH_BUCKET_ENTRY rgpDotOIDHashBucket[DOT_OID_HASH_BUCKET_COUNT];

static CRITICAL_SECTION OIDHashBucketCriticalSection;

static BOOL OIDHashBucketProcessAttach()
{
    return Pki_InitializeCriticalSection(&OIDHashBucketCriticalSection);
}

static void OIDHashBucketProcessDetach()
{
    DWORD i;
    for (i = 0; i < DOT_OID_HASH_BUCKET_COUNT; i++) {
        POID_HASH_BUCKET_ENTRY pEntry = rgpDotOIDHashBucket[i];
        while (pEntry) {
            POID_HASH_BUCKET_ENTRY pFreeEntry = pEntry;
            pEntry = pEntry->pDotNext;
            PkiFree(pFreeEntry);
        }
    }

    DeleteCriticalSection(&OIDHashBucketCriticalSection);
}

BOOL
WINAPI
I_CryptOIDConvDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = OIDHashBucketProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        OIDHashBucketProcessDetach();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

extern HCRYPTASN1MODULE hX509Asn1Module;  // From wincert.cpp
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

static DWORD GetOIDHashBucketIndex(
    IN DWORD cHashBucket,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    DWORD dwIndex;

    dwIndex = 0;
    while (cb--) {
        if (dwIndex & 0x80000000)
            dwIndex = (dwIndex << 1) | 1;
        else
            dwIndex = dwIndex << 1;
        dwIndex += *pb++;
    }
    return dwIndex % cHashBucket;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    BYTE *pbEncodedOID = pEncodedOid->value;
    DWORD cbEncodedOID = pEncodedOid->length;
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        ENCODED_OID_HASH_BUCKET_COUNT,
        pbEncodedOID,
        cbEncodedOID
        );

    for (pEntry = rgpEncodedOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pEncodedNext) {
        if (cbEncodedOID == pEntry->cbEncodedOID &&
                0 == memcmp(pbEncodedOID, GetEncodedOIDPointer(pEntry),
                        cbEncodedOID))
            return pEntry;
    }

    return NULL;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cchDotOID = strlen(pszDotOID);
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        DOT_OID_HASH_BUCKET_COUNT,
        (const BYTE *) pszDotOID,
        cchDotOID
        );

    for (pEntry = rgpDotOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pDotNext) {
        if (cchDotOID == pEntry->cchDotOID &&
                0 == memcmp(pszDotOID, GetDotOIDPointer(pEntry), cchDotOID))
            return pEntry;
    }

    return NULL;
}


// If after entering the critical section, the entry already exists, then,
// return it and free the input entry. Otherwise, add the input entry and
// return it.
static POID_HASH_BUCKET_ENTRY AddOIDHashBucketEntry(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    POID_HASH_BUCKET_ENTRY pFindEntry;
    ASN1encodedOID_t EncodedOid;

    EnterCriticalSection(&OIDHashBucketCriticalSection);

    EncodedOid.value = GetEncodedOIDPointer(pEntry);
    EncodedOid.length = (ASN1uint16_t) pEntry->cbEncodedOID;
    if (pFindEntry = FindOIDHashBucketEntryFromEncodedOID(&EncodedOid)) {
        PkiFree(pEntry);
        pEntry = pFindEntry;
    } else {
        DWORD dwIndex;

        dwIndex = GetOIDHashBucketIndex(
            ENCODED_OID_HASH_BUCKET_COUNT,
            GetEncodedOIDPointer(pEntry),
            pEntry->cbEncodedOID
            );
        pEntry->pEncodedNext = rgpEncodedOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpEncodedOIDHashBucket[dwIndex] = pEntry;

        dwIndex = GetOIDHashBucketIndex(
            DOT_OID_HASH_BUCKET_COUNT,
            (const BYTE *) GetDotOIDPointer(pEntry),
            pEntry->cchDotOID
            );
        pEntry->pDotNext = rgpDotOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpDotOIDHashBucket[dwIndex] = pEntry;
    }

    LeaveCriticalSection(&OIDHashBucketCriticalSection);

    return pEntry;
}


static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntry(
    IN const BYTE *pbEncodedOID,
    IN DWORD cbEncodedOID,
    IN LPSTR pszDotOID,
    IN DWORD cchDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cbEntry;

    cbEntry = sizeof(OID_HASH_BUCKET_ENTRY) + cbEncodedOID + cchDotOID + 1;
    if (NULL == (pEntry = (POID_HASH_BUCKET_ENTRY) PkiZeroAlloc(cbEntry)))
        return NULL;

    pEntry->cbEncodedOID = cbEncodedOID;
    pEntry->cchDotOID = cchDotOID;
    memcpy(GetEncodedOIDPointer(pEntry), pbEncodedOID, cbEncodedOID);
    memcpy(GetDotOIDPointer(pEntry), pszDotOID, cchDotOID + 1);

    return pEntry;
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1decoding_t pDec = GetDecoder();
    const BYTE *pbEncodedOID;       // not allocated
    DWORD cbEncodedOID;
    LPSTR pszDotOID = NULL; 
    DWORD cchDotOID;

    if (NULL == (pszDotOID = PkiAsn1EncodedOidToDotVal(pDec, pEncodedOid)))
        goto EncodedOidToDotValError;
    cchDotOID = (DWORD) strlen(pszDotOID);

    pbEncodedOID = pEncodedOid->value;
    cbEncodedOID = pEncodedOid->length;
    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        cchDotOID
        );

CommonReturn:
    PkiAsn1FreeDotVal(pDec, pszDotOID);
    return pEntry;

ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

TRACE_ERROR(EncodedOidToDotValError)
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1encoding_t pEnc = GetEncoder();
    ASN1encodedOID_t EncodedOid;
    memset(&EncodedOid, 0, sizeof(EncodedOid));

    const BYTE *pbEncodedOID;
    DWORD cbEncodedOID;

    if (NULL == pszDotOID || '\0' == *pszDotOID)
        goto EmptyDotOIDError;
    if (!PkiAsn1DotValToEncodedOid(pEnc, pszDotOID, &EncodedOid))
        goto DotValToEncodedOidError;
    pbEncodedOID = EncodedOid.value;
    cbEncodedOID = EncodedOid.length;

    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        strlen(pszDotOID)
        );

CommonReturn:
    PkiAsn1FreeEncodedOid(pEnc, &EncodedOid);
    return pEntry;
ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

SET_ERROR(EmptyDotOIDError, E_INVALIDARG)
SET_ERROR_VAR(DotValToEncodedOidError, PkiAsn1ErrToHr(ASN1_ERR_BADARGS))
}



//+-------------------------------------------------------------------------
//  Set/Get Encoded OID
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetEncodedOID(
        IN LPSTR pszObjId,
        OUT ASN1encodedOID_t *pEncodedOid
        )
{
    BOOL fResult;
    POID_HASH_BUCKET_ENTRY pEntry;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromDotOID(pszObjId))) {
        if (NULL == (pEntry = CreateOIDHashBucketEntryFromDotOID(pszObjId)))
            goto CreateOIDHashBucketEntryError;
        pEntry = AddOIDHashBucketEntry(pEntry);
    }

    pEncodedOid->length = (ASN1uint16_t) pEntry->cbEncodedOID;
    pEncodedOid->value = GetEncodedOIDPointer(pEntry);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    pEncodedOid->length = 0;
    pEncodedOid->value = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateOIDHashBucketEntryError)    
}


static const LPCSTR pszInvalidOID = "";

void
WINAPI
I_CryptGetEncodedOID(
        IN ASN1encodedOID_t *pEncodedOid,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    LONG lRemainExtra = *plRemainExtra;
    LPSTR pszDotOID;
    DWORD cchDotOID;

    if ((dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) &&
            lRemainExtra < 0)
        // Length only calculation. Don't need any extra bytes.
        return;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromEncodedOID(pEncodedOid))) {
        if (pEntry = CreateOIDHashBucketEntryFromEncodedOID(pEncodedOid))
            pEntry = AddOIDHashBucketEntry(pEntry);
    }

    if (pEntry) {
        pszDotOID = GetDotOIDPointer(pEntry);
        cchDotOID = pEntry->cchDotOID + 1;
    } else {
        pszDotOID = (LPSTR) pszInvalidOID;
        cchDotOID = strlen(pszInvalidOID) + 1;
    }

    if (dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) {
        assert(lRemainExtra >= 0);
        *ppszObjId = pszDotOID;
    } else {
        LONG lAlignExtra = INFO_LEN_ALIGN(cchDotOID);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(*ppbExtra, pszDotOID, cchDotOID);
            *ppszObjId = (LPSTR) *ppbExtra;
            *ppbExtra += lAlignExtra;
        }

        *plRemainExtra = lRemainExtra;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\newstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       newstor.cpp
//
//  Contents:   Certificate, CRL and CTL Store APIs
//
//  Functions:  CertStoreDllMain
//              CertOpenStore
//              CertDuplicateStore
//              CertCloseStore
//              CertSaveStore
//              CertControlStore
//              CertAddStoreToCollection
//              CertRemoveStoreFromCollection
//              CertSetStoreProperty
//              CertGetStoreProperty
//              CertGetSubjectCertificateFromStore
//              CertEnumCertificatesInStore
//              CertFindCertificateInStore
//              CertGetIssuerCertificateFromStore
//              CertVerifySubjectCertificateContext
//              CertDuplicateCertificateContext
//              CertCreateCertificateContext
//              CertFreeCertificateContext
//              CertSetCertificateContextProperty
//              CertGetCertificateContextProperty
//              CertEnumCertificateContextProperties
//              CertCreateCTLEntryFromCertificateContextProperties
//              CertSetCertificateContextPropertiesFromCTLEntry
//              CertGetCRLFromStore
//              CertEnumCRLsInStore
//              CertFindCRLInStore
//              CertDuplicateCRLContext
//              CertCreateCRLContext
//              CertFreeCRLContext
//              CertSetCRLContextProperty
//              CertGetCRLContextProperty
//              CertEnumCRLContextProperties
//              CertFindCertificateInCRL
//              CertAddEncodedCertificateToStore
//              CertAddCertificateContextToStore
//              CertSerializeCertificateStoreElement
//              CertDeleteCertificateFromStore
//              CertAddEncodedCRLToStore
//              CertAddCRLContextToStore
//              CertSerializeCRLStoreElement
//              CertDeleteCRLFromStore
//              CertAddSerializedElementToStore
//
//              CertDuplicateCTLContext
//              CertCreateCTLContext
//              CertFreeCTLContext
//              CertSetCTLContextProperty
//              CertGetCTLContextProperty
//              CertEnumCTLContextProperties
//              CertEnumCTLsInStore
//              CertFindSubjectInCTL
//              CertFindCTLInStore
//              CertAddEncodedCTLToStore
//              CertAddCTLContextToStore
//              CertSerializeCTLStoreElement
//              CertDeleteCTLFromStore
//
//              CertAddCertificateLinkToStore
//              CertAddCRLLinkToStore
//              CertAddCTLLinkToStore
//
//              CertCreateContext
//
//              I_CertAddSerializedStore
//              CryptAcquireCertificatePrivateKey
//              I_CertSyncStore
//              I_CertSyncStoreEx
//              I_CertUpdateStore
//
//              CryptGetKeyIdentifierProperty
//              CryptSetKeyIdentifierProperty
//              CryptEnumKeyIdentifierProperties
//
//  History:    17-Feb-96    philh   created
//              29-Dec-96    philh   redo using provider functions
//              01-May-97    philh   added CTL functions
//              01-Aug-97    philh   NT 5.0 Changes. Support context links,
//                                   collections and external stores.
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

HMODULE hCertStoreInst;

// Maximum # of verified CRLs allowed per issuer.
// This array of CRLs is passed to CertHelperVerifyRevocation
#define MAX_CRL_LIST    64

//+-------------------------------------------------------------------------
//  Store data structure definitions
//--------------------------------------------------------------------------

// Assumes
//  0 - Certificates
//  1 - CRLs
//  2 - CTLs
#define CONTEXT_COUNT       3

typedef struct _CONTEXT_ELEMENT CONTEXT_ELEMENT, *PCONTEXT_ELEMENT;
typedef struct _PROP_ELEMENT PROP_ELEMENT, *PPROP_ELEMENT;

typedef struct _CERT_STORE CERT_STORE, *PCERT_STORE;
typedef struct _SHARE_STORE SHARE_STORE, *PSHARE_STORE;
typedef struct _CERT_STORE_LINK CERT_STORE_LINK, *PCERT_STORE_LINK;

typedef struct _COLLECTION_STACK_ENTRY COLLECTION_STACK_ENTRY,
    *PCOLLECTION_STACK_ENTRY;

// Used to maintain collection state across context find next calls.
//
// Ref count on pStoreLink. No ref count on pCollection.
// pStoreLink may be NULL.
struct _COLLECTION_STACK_ENTRY {
    PCERT_STORE                 pCollection;
    PCERT_STORE_LINK            pStoreLink;
    PCOLLECTION_STACK_ENTRY     pPrev;
};

typedef struct _CONTEXT_CACHE_INFO {
    PPROP_ELEMENT               pPropHead;
} CONTEXT_CACHE_INFO;

typedef struct _CONTEXT_EXTERNAL_INFO {
    // For ELEMENT_FIND_NEXT_FLAG
    void                        *pvProvInfo;
} CONTEXT_EXTERNAL_INFO;

typedef struct _CONTEXT_COLLECTION_INFO {
    // For Find
    PCOLLECTION_STACK_ENTRY     pCollectionStack;
} CONTEXT_COLLECTION_INFO;

#define ELEMENT_DELETED_FLAG                    0x00010000

// Only set for external elements
#define ELEMENT_FIND_NEXT_FLAG                  0x00020000

// Set during CertCloseStore if ELEMENT_FIND_NEXT_FLAG was set.
#define ELEMENT_CLOSE_FIND_NEXT_FLAG            0x00040000

// Set if the element has a CERT_ARCHIVED_PROP_ID
#define ELEMENT_ARCHIVED_FLAG                   0x00080000

// A cache element is the actual context element. Its the only element,
// where pEle points to itself. All other elements will eventually
// point to a cache element. Cache elements may only reside in a cache
// store. The pProvStore is the same as the pStore. Note, during a
// context add, a cache element may temporarily be in a collection store
// during the call to the provider's add callback.
//
// A link context element is a link to another element, including a link
// to another link context element. Link context elements may only reside
// in a cache store. The pProvStore is the same as the linked to element's
// pProvStore.
//
// An external element is a link to the element returned by a provider
// that stores elements externally. External elements may only reside in
// an external store. The pProvStore is the external store's
// provider. The store doesn't hold a reference on an external element,
// its ELEMENT_DELETED_FLAG is always set.
//
// A collection element is a link to an element in a cache or external store.
// Its returned when finding in or adding to a collection store. The store
// doesn't hold a reference on a collection element, its
// ELEMENT_DELETED_FLAG is always set.
//
#define ELEMENT_TYPE_CACHE                      1
#define ELEMENT_TYPE_LINK_CONTEXT               2
#define ELEMENT_TYPE_EXTERNAL                   3
#define ELEMENT_TYPE_COLLECTION                 4


#define MAX_LINK_DEPTH  100

typedef struct _CONTEXT_NOCOPY_INFO {
    PFN_CRYPT_FREE      pfnFree;
    void                *pvFree;
} CONTEXT_NOCOPY_INFO, *PCONTEXT_NOCOPY_INFO;


// Identical contexts (having the same SHA1 hash) can share the same encoded
// byte array and decoded info data structure.
//
// CreateShareElement() creates with dwRefCnt of 1. FindShareElement() finds
// an existing and increments dwRefCnt. ReleaseShareElement() decrements
// dwRefCnt and frees when 0.
typedef struct _SHARE_ELEMENT SHARE_ELEMENT, *PSHARE_ELEMENT;
struct _SHARE_ELEMENT {
    BYTE                rgbSha1Hash[SHA1_HASH_LEN];
    DWORD               dwContextType;
    BYTE                *pbEncoded;         // allocated
    DWORD               cbEncoded;
    void                *pvInfo;            // allocated

    DWORD               dwRefCnt;
    PSHARE_ELEMENT      pNext;
    PSHARE_ELEMENT      pPrev;
};

// The CONTEXT_ELEMENT is inserted before the CERT_CONTEXT, CRL_CONTEXT or
// CTL_CONTEXT. The dwContextType used is 0 based and not 1 based. For
// example, dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1.
struct _CONTEXT_ELEMENT {
    DWORD               dwElementType;
    DWORD               dwContextType;
    DWORD               dwFlags;
    LONG                lRefCnt;

    // For ELEMENT_TYPE_CACHE, pEle points to itself. Otherwise, pEle points
    // to the element being linked to and the pEle is addRef'ed. The
    // cached element is found by iterating through the pEle's until pEle
    // points to itself.
    PCONTEXT_ELEMENT    pEle;
    PCERT_STORE         pStore;
    PCONTEXT_ELEMENT    pNext;
    PCONTEXT_ELEMENT    pPrev;
    PCERT_STORE         pProvStore;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // When nonNULL, the context's pbEncoded and pInfo aren't allocated.
    // Instead, use the shared element's pbEncoded and pInfo. When
    // context element is freed, the pSharedEle is ReleaseShareElement()'ed.
    PSHARE_ELEMENT      pShareEle;          // RefCnt'ed

    union {
        CONTEXT_CACHE_INFO      Cache;      // ELEMENT_TYPE_CACHE
        CONTEXT_EXTERNAL_INFO   External;   // ELEMENT_TYPE_EXTERNAL
        CONTEXT_COLLECTION_INFO Collection; // ELEMENT_TYPE_COLLECTION
    };
};

// For CRL, follows the above CONTEXT_ELEMENT
typedef struct _CRL_CONTEXT_SUFFIX {
    PCRL_ENTRY          *ppSortedEntry;
} CRL_CONTEXT_SUFFIX, *PCRL_CONTEXT_SUFFIX;


typedef struct _HASH_BUCKET_ENTRY HASH_BUCKET_ENTRY, *PHASH_BUCKET_ENTRY;
struct _HASH_BUCKET_ENTRY {
    union {
        DWORD               dwEntryIndex;
        DWORD               dwEntryOffset;
        const BYTE          *pbEntry;
    };
    union {
        PHASH_BUCKET_ENTRY  pNext;
        DWORD               iNext;
    };
};

typedef struct _SORTED_CTL_FIND_INFO {
    DWORD                   cHashBucket;
    BOOL                    fHashedIdentifier;

    // Encoded sequence of TrustedSubjects
    const BYTE              *pbEncodedSubjects;         // not allocated
    DWORD                   cbEncodedSubjects;

    // Following is NON-NULL for a szOID_SORTED_CTL extension
    const BYTE              *pbEncodedHashBucket;       // not allocated

    // Following are NON-NULL when there isn't a szOID_SORTED_CTL extension
    DWORD                   *pdwHashBucketHead;         // allocated
    PHASH_BUCKET_ENTRY      pHashBucketEntry;           // allocated
} SORTED_CTL_FIND_INFO, *PSORTED_CTL_FIND_INFO;

// For CTL, follows the above CONTEXT_ELEMENT
typedef struct _CTL_CONTEXT_SUFFIX {
    PCTL_ENTRY              *ppSortedEntry;             // allocated

    BOOL                    fFastCreate;
    // Following only applicable for a FastCreateCtlElement
    PCTL_ENTRY              pCTLEntry;                  // allocated
    PCERT_EXTENSIONS        pExtInfo;                   // allocated
    PSORTED_CTL_FIND_INFO   pSortedCtlFindInfo;         // not allocated
} CTL_CONTEXT_SUFFIX, *PCTL_CONTEXT_SUFFIX;

struct _PROP_ELEMENT {
    DWORD               dwPropId;
    DWORD               dwFlags;
    BYTE                *pbData;
    DWORD               cbData;
    PPROP_ELEMENT       pNext;
    PPROP_ELEMENT       pPrev;
};


#define STORE_LINK_DELETED_FLAG        0x00010000
struct _CERT_STORE_LINK {
    DWORD               dwFlags;
    LONG                lRefCnt;

    // Whatever is passed to CertAddStoreToCollection
    DWORD               dwUpdateFlags;
    DWORD               dwPriority;

    PCERT_STORE         pCollection;
    PCERT_STORE         pSibling;       // CertStoreDuplicate'd.
    PCERT_STORE_LINK    pNext;
    PCERT_STORE_LINK    pPrev;
};


// Store types
#define STORE_TYPE_CACHE            1
#define STORE_TYPE_EXTERNAL         2
#define STORE_TYPE_COLLECTION       3

// CACHE store may have CACHE or LINK_CONTEXT elements. Until deleted,
// the store has a reference count to.

// EXTERNAL store only has EXTERNAL elements. These elements are always
// deleted, wherein, the store doesn't hold a refCnt.

// COLLECTION store has COLLECTION elements. These elements
// are always deleted, wherein, the store doesn't hold a refCnt.


struct _CERT_STORE {
    DWORD               dwStoreType;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;
    DWORD               dwFlags;
    DWORD               dwState;
    CRITICAL_SECTION    CriticalSection;
    PCONTEXT_ELEMENT    rgpContextListHead[CONTEXT_COUNT];
    PCERT_STORE_LINK    pStoreListHead;                     // COLLECTION
    PPROP_ELEMENT       pPropHead;      // properties for entire store

    // For CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
    // Incremented for each context duplicated
    LONG                lDeferCloseRefCnt;

    // Event handle set by CertControlStore(CERT_STORE_CTRL_AUTO_RESYNC)
    HANDLE              hAutoResyncEvent;

    // The following is set for a shared store
    PSHARE_STORE        pShareStore;

    // Store provider info
    LONG                lStoreProvRefCnt;
    HANDLE              hStoreProvWait;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr;
    CERT_STORE_PROV_INFO StoreProvInfo;
};

    

//+-------------------------------------------------------------------------
//  Store states
//--------------------------------------------------------------------------
#define STORE_STATE_DELETED         0
#define STORE_STATE_NULL            1
#define STORE_STATE_OPENING         2
#define STORE_STATE_OPEN            3
#define STORE_STATE_DEFER_CLOSING   4
#define STORE_STATE_CLOSING         5
#define STORE_STATE_CLOSED          6

// LocalMachine System stores opened for SHARE and MAXIMUM_ALLOWED can
// be shared. 
struct _SHARE_STORE {
    LPWSTR              pwszStore;  // not a separate allocation, string
                                    // follows struct
    PCERT_STORE         pStore;     // store holds lRefCnt
    PSHARE_STORE        pNext;
    PSHARE_STORE        pPrev;
};

//+-------------------------------------------------------------------------
//  Share stores.
//
//  A shared stored is identified by its UNICODE name. Simply maintain a
//  linked list of share stores.
//
//  Shared stores are restricted to LocalMachine System Stores opened
//  with CERT_STORE_SHARE_STORE_FLAG, CERT_STORE_SHARE_CONTEXT_FLAG and
//  CERT_STORE_MAXIMUM_ALLOWED_FLAG.
//--------------------------------------------------------------------------
STATIC PSHARE_STORE pShareStoreHead;
STATIC CRITICAL_SECTION ShareStoreCriticalSection;


//+-------------------------------------------------------------------------
//  Key Identifier Element
//--------------------------------------------------------------------------
typedef struct _KEYID_ELEMENT {
    CRYPT_HASH_BLOB     KeyIdentifier;
    PPROP_ELEMENT       pPropHead;
} KEYID_ELEMENT, *PKEYID_ELEMENT;


//+-------------------------------------------------------------------------
//  The "Find ANY" INFO data structure.
//
//  0 is the ANY dwFindType for all context types.
//--------------------------------------------------------------------------
static CCERT_STORE_PROV_FIND_INFO FindAnyInfo = {
    sizeof(CCERT_STORE_PROV_FIND_INFO),         // cbSize
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,    // dwMsgAndCertEncodingType
    0,                                          // dwFindFlags
    0,                                          // dwFindType
    NULL                                        // pvFindPara
};

//+-------------------------------------------------------------------------
//  NULL Store.
//
//  HANDLE of all CONTEXTs created by CertCreateCertificateContext or
//  CertCreateCRLContext. Created CONTEXTs are immediately added to the
//  NULL store's free list. (ie, the store doesn't have a RefCnt on the
//  CONTEXT.)
//--------------------------------------------------------------------------
static CERT_STORE NullCertStore;

//+-------------------------------------------------------------------------
//  Bug in rsabase.dll. Its not thread safe across multiple crypt prov
//  handles.
//--------------------------------------------------------------------------
static CRITICAL_SECTION     CryptProvCriticalSection;

//+-------------------------------------------------------------------------
//  Store file definitions
//
//  The file consist of the FILE_HDR followed by 1 or more FILE_ELEMENTs.
//  Each FILE_ELEMENT has a FILE_ELEMENT_HDR + its value.
//
//  First the CERT elements are written. If a CERT has any properties, then,
//  the PROP elements immediately precede the CERT's element. Next the CRL
//  elements are written. If a CRL has any properties, then, the PROP elements
//  immediately precede the CRL's element. Likewise for CTL elements and its
//  properties. Finally, the END element is written.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwVersion;
    DWORD               dwMagic;
} FILE_HDR, *PFILE_HDR;

#define CERT_FILE_VERSION_0             0
#define CERT_MAGIC ((DWORD)'C'+((DWORD)'E'<<8)+((DWORD)'R'<<16)+((DWORD)'T'<<24))

// The element's data follows the HDR
typedef struct _FILE_ELEMENT_HDR {
    DWORD               dwEleType;
    DWORD               dwEncodingType;
    DWORD               dwLen;
} FILE_ELEMENT_HDR, *PFILE_ELEMENT_HDR;

#define FILE_ELEMENT_END_TYPE           0
// FILE_ELEMENT_PROP_TYPEs              !(0 | CERT | CRL | CTL | KEYID)
// Note CERT_KEY_CONTEXT_PROP_ID (and CERT_KEY_PROV_HANDLE_PROP_ID)
// isn't written
#define FILE_ELEMENT_CERT_TYPE          32
#define FILE_ELEMENT_CRL_TYPE           33
#define FILE_ELEMENT_CTL_TYPE           34
#define FILE_ELEMENT_KEYID_TYPE         35

//#define MAX_FILE_ELEMENT_DATA_LEN       (4096 * 16)
#define MAX_FILE_ELEMENT_DATA_LEN       0xFFFFFFFF

//+-------------------------------------------------------------------------
//  Used when reading an element
//--------------------------------------------------------------------------
#define CSError     0
#define CSContinue  1
#define CSEnd       2

//+-------------------------------------------------------------------------
//  Share elements.
//
//  A share element is identifed by its sha1 hash. It contains the context's
//  encoded bytes and decoded info. Multiple contexts can point to the
//  same refcounted share element. The share elements are stored in a
//  hash bucket array of linked lists. The first byte of the element's sha1
//  hash is used as the index into the array.
//
//  Note, the actual index is the first byte modulus BUCKET_COUNT.
//--------------------------------------------------------------------------
#define SHARE_ELEMENT_HASH_BUCKET_COUNT  64
static PSHARE_ELEMENT rgpShareElementHashBucket[SHARE_ELEMENT_HASH_BUCKET_COUNT];
static CRITICAL_SECTION  ShareElementCriticalSection;

//+-------------------------------------------------------------------------
//  Read, Write & Skip to memory/file function definitions
//--------------------------------------------------------------------------
typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNSKIP)(HANDLE h, DWORD cb);


//+-------------------------------------------------------------------------
//  Store Provider Functions
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenMemoryStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    return TRUE;
}

STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenCollectionStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    pStore->dwStoreType = STORE_TYPE_COLLECTION;
    return TRUE;
}

// from regstor.cpp
extern BOOL WINAPI I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

static HCRYPTOIDFUNCSET hOpenStoreProvFuncSet;
static const CRYPT_OID_FUNC_ENTRY OpenStoreProvFuncTable[] = {
    CERT_STORE_PROV_MSG, OpenMsgStoreProv,
    CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
    CERT_STORE_PROV_FILE, OpenFileStoreProv,
    CERT_STORE_PROV_REG, I_CertDllOpenRegStoreProv,

    CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
    CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
    CERT_STORE_PROV_FILENAME_A, OpenFilenameStoreProvA,
    CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
    CERT_STORE_PROV_SYSTEM_A, I_CertDllOpenSystemStoreProvA,
    CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
    CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    CERT_STORE_PROV_SYSTEM_REGISTRY_A, I_CertDllOpenSystemRegistryStoreProvA,
    CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
    CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore,

    sz_CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
    sz_CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
    sz_CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
    sz_CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
    sz_CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    sz_CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
    sz_CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore
};
#define OPEN_STORE_PROV_FUNC_COUNT (sizeof(OpenStoreProvFuncTable) / \
                                    sizeof(OpenStoreProvFuncTable[0]))


//+-------------------------------------------------------------------------
//  NULL Store: initialization and free
//--------------------------------------------------------------------------
STATIC BOOL InitNullCertStore()
{
    BOOL fRet;

    memset(&NullCertStore, 0, sizeof(NullCertStore));
    NullCertStore.dwStoreType = STORE_TYPE_CACHE;
    NullCertStore.lRefCnt = 1;
    NullCertStore.dwState = STORE_STATE_NULL;
    fRet = Pki_InitializeCriticalSection(&NullCertStore.CriticalSection);
    NullCertStore.StoreProvInfo.dwStoreProvFlags =
        CERT_STORE_PROV_NO_PERSIST_FLAG;

    return fRet;
}
STATIC void FreeNullCertStore()
{
    DeleteCriticalSection(&NullCertStore.CriticalSection);
}

//+-------------------------------------------------------------------------
//  CryptProv: initialization and free
//--------------------------------------------------------------------------
STATIC BOOL InitCryptProv()
{
    return Pki_InitializeCriticalSection(&CryptProvCriticalSection);
}
STATIC void FreeCryptProv()
{
    DeleteCriticalSection(&CryptProvCriticalSection);
}

extern
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    if (!I_RegStoreDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        // Used for "root" system store's message box
        hCertStoreInst = hInst;

        if (NULL == (hOpenStoreProvFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_OPEN_STORE_PROV_FUNC, 0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                OPEN_STORE_PROV_FUNC_COUNT,
                OpenStoreProvFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!Pki_InitializeCriticalSection(&ShareElementCriticalSection))
            goto InitShareElementCritSectionError;
        if (!Pki_InitializeCriticalSection(&ShareStoreCriticalSection))
            goto InitShareStoreCritSectionError;
        if (!InitNullCertStore())
            goto InitNullCertStoreError;
        if (!InitCryptProv())
            goto InitCryptProvError;

        break;

    case DLL_PROCESS_DETACH:
        FreeCryptProv();
        FreeNullCertStore();
        DeleteCriticalSection(&ShareElementCriticalSection);
        DeleteCriticalSection(&ShareStoreCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

InitCryptProvError:
    FreeNullCertStore();
InitNullCertStoreError:
    DeleteCriticalSection(&ShareStoreCriticalSection);
InitShareStoreCritSectionError:
    DeleteCriticalSection(&ShareElementCriticalSection);
InitShareElementCritSectionError:
ErrorReturn:
    I_RegStoreDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+=========================================================================
//  Context Type Tables
//==========================================================================

//+-------------------------------------------------------------------------
//  Provider callback function indices
//--------------------------------------------------------------------------
static const DWORD rgdwStoreProvFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FIND_CERT_FUNC,
    CERT_STORE_PROV_FIND_CRL_FUNC,
    CERT_STORE_PROV_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvWriteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_WRITE_CERT_FUNC,
    CERT_STORE_PROV_WRITE_CRL_FUNC,
    CERT_STORE_PROV_WRITE_CTL_FUNC
};

static const DWORD rgdwStoreProvDeleteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_DELETE_CERT_FUNC,
    CERT_STORE_PROV_DELETE_CRL_FUNC,
    CERT_STORE_PROV_DELETE_CTL_FUNC
};

static const DWORD rgdwStoreProvFreeFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FREE_FIND_CERT_FUNC,
    CERT_STORE_PROV_FREE_FIND_CRL_FUNC,
    CERT_STORE_PROV_FREE_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvGetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC
};

static const DWORD rgdwStoreProvSetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC
};

//+-------------------------------------------------------------------------
//  Context data structure length and field offsets
//--------------------------------------------------------------------------
static const DWORD rgcbContext[CONTEXT_COUNT] = {
    sizeof(CERT_CONTEXT),
    sizeof(CRL_CONTEXT),
    sizeof(CTL_CONTEXT)
};

static const DWORD rgOffsetofStoreHandle[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, hCertStore),
    offsetof(CRL_CONTEXT, hCertStore),
    offsetof(CTL_CONTEXT, hCertStore)
};

static const DWORD rgOffsetofEncodingType[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, dwCertEncodingType),
    offsetof(CRL_CONTEXT, dwCertEncodingType),
    offsetof(CTL_CONTEXT, dwMsgAndCertEncodingType)
};

static const DWORD rgOffsetofEncodedPointer[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, pbCertEncoded),
    offsetof(CRL_CONTEXT, pbCrlEncoded),
    offsetof(CTL_CONTEXT, pbCtlEncoded)
};

static const DWORD rgOffsetofEncodedCount[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, cbCertEncoded),
    offsetof(CRL_CONTEXT, cbCrlEncoded),
    offsetof(CTL_CONTEXT, cbCtlEncoded)
};

//+-------------------------------------------------------------------------
//  Find Types
//--------------------------------------------------------------------------
static const DWORD rgdwFindTypeToFindExisting[CONTEXT_COUNT] = {
    CERT_FIND_EXISTING,
    CRL_FIND_EXISTING,
    CTL_FIND_EXISTING
};

//+-------------------------------------------------------------------------
//  File Element Types
//--------------------------------------------------------------------------
static const DWORD rgdwFileElementType[CONTEXT_COUNT] = {
    FILE_ELEMENT_CERT_TYPE,
    FILE_ELEMENT_CRL_TYPE,
    FILE_ELEMENT_CTL_TYPE
};

//+-------------------------------------------------------------------------
//  Share Element Decode Struct Types
//--------------------------------------------------------------------------
static const LPCSTR rgpszShareElementStructType[CONTEXT_COUNT] = {
    X509_CERT_TO_BE_SIGNED,
    X509_CERT_CRL_TO_BE_SIGNED,
    0
};

//+=========================================================================
//  Context Type Specific Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  CERT_CONTEXT Element
//--------------------------------------------------------------------------

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle);

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    );

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCertContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCERT_CONTEXT ToCertContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCERT_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//  CRL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCrlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCRL_CONTEXT ToCrlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCRL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCRL_CONTEXT_SUFFIX ToCrlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCRL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CRL_CONTEXT));
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//  CTL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCtlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCTL_CONTEXT ToCtlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCTL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCTL_CONTEXT_SUFFIX ToCtlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCTL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT));
    else
        return NULL;
}

//+=========================================================================
//  Context Type Function Tables
//==========================================================================
typedef PCONTEXT_ELEMENT (*PFN_CREATE_ELEMENT)(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );

static PFN_CREATE_ELEMENT const rgpfnCreateElement[CONTEXT_COUNT] = {
    CreateCertElement,
    CreateCrlElement,
    CreateCtlElement
};

typedef void (*PFN_FREE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle
    );

static PFN_FREE_ELEMENT const rgpfnFreeElement[CONTEXT_COUNT] = {
    FreeCertElement,
    FreeCrlElement,
    FreeCtlElement
};

typedef BOOL (*PFN_COMPARE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

static PFN_COMPARE_ELEMENT const rgpfnCompareElement[CONTEXT_COUNT] = {
    CompareCertElement,
    CompareCrlElement,
    CompareCtlElement
};

typedef BOOL (*PFN_IS_NEWER_ELEMENT)(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static PFN_IS_NEWER_ELEMENT const rgpfnIsNewerElement[CONTEXT_COUNT] = {
    IsNewerCertElement,
    IsNewerCrlElement,
    IsNewerCtlElement
};

//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    );
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

static inline void AddRefStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    InterlockedIncrement(&pStoreLink->lRefCnt);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    );

STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

// Returns TRUE if both elements have identical SHA1 hash.
STATIC BOOL IsIdenticalContextElement(
    IN PCONTEXT_ELEMENT pEle1,
    IN PCONTEXT_ELEMENT pEle2
    );

STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    );

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    );

static inline void FreeLinkElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    PkiFree(pLinkEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    );

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================
// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    );
STATIC void FreePropElement(IN PPROP_ELEMENT pEle);

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    );
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

//+=========================================================================
//  Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet = FALSE
    );

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    );
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

#define COPY_PROPERTY_USE_EXISTING_FLAG     0x1
#define COPY_PROPERTY_INHIBIT_PROV_SET_FLAG 0x2
#define COPY_PROPERTY_SYNC_FLAG             0x4
STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    );

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------
#define ENCODE_LEN_ALIGN(Len)  ((Len + 7) & ~7)

typedef struct _SERIALIZED_KEY_PROV_PARAM {
    DWORD           dwParam;
    DWORD           offbData;
    DWORD           cbData;
    DWORD           dwFlags;
} SERIALIZED_KEY_PROV_PARAM, *PSERIALIZED_KEY_PROV_PARAM;

typedef struct _SERIALIZED_KEY_PROV_INFO {
    DWORD           offwszContainerName;
    DWORD           offwszProvName;
    DWORD           dwProvType;
    DWORD           dwFlags;
    DWORD           cProvParam;
    DWORD           offrgProvParam;
    DWORD           dwKeySpec;
} SERIALIZED_KEY_PROV_INFO, *PSERIALIZED_KEY_PROV_INFO;

#define MAX_PROV_PARAM          0x00000100
#define MAX_PROV_PARAM_CBDATA   0x00010000

STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

STATIC BOOL DecodeKeyProvInfo(
    IN PSERIALIZED_KEY_PROV_INFO pSerializedInfo,
    IN DWORD cbSerialized,
    OUT PCRYPT_KEY_PROV_INFO pInfo,
    OUT DWORD *pcbInfo
    );

//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================
// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    );
STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle);

//+=========================================================================
// Key Identifier Property Functions
//
// If dwPropId == 0, check if the element has a KEY_PROV_INFO property
//==========================================================================
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId = 0,
    IN const void *pvData = NULL
    );

STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Alloc and NOCOPY Decode
//--------------------------------------------------------------------------
STATIC void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags = CRYPT_DECODE_NOCOPY_FLAG
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
STATIC void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = PkiNonzeroAlloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        PkiFree(pvData);
        goto GetParamError;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetCertEncodingType(
    IN DWORD dwEncodingType
    )
{
    if (0 == dwEncodingType)
        return X509_ASN_ENCODING;
    else
        return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
            (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
            ((dwEncodingType >> 16) & CERT_ENCODING_TYPE_MASK);
}

STATIC DWORD AdjustEncodedLength(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType))
        return Asn1UtilAdjustEncodedLength(pbDER, cbDER);
    else
        return cbDER;
}


//+-------------------------------------------------------------------------
//  Read, Write and Skip file functions
//--------------------------------------------------------------------------
BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}
BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL));
}

BOOL SkipInFile(
    IN HANDLE h,
    IN DWORD cb
    )
{
    DWORD dwLoFilePointer;
    LONG lHiFilePointer;
    LONG lDistanceToMove;

    lDistanceToMove = (LONG) cb;
    lHiFilePointer = 0;
    dwLoFilePointer = SetFilePointer(
        h,
        lDistanceToMove,
        &lHiFilePointer,
        FILE_CURRENT
        );
    if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
        return FALSE;
    else
        return TRUE;
}


//+-------------------------------------------------------------------------
//  Read, Write and Skip memory fucntions
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pByte;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

BOOL WriteToMemory(HANDLE h, void * p, DWORD cb)
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
      // Handle MappedFile Exceptions
      __try {

        // copy the bytes
        memcpy(&pMemInfo->pByte[pMemInfo->cbSeek], p, cb);

      } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return FALSE;
      }
    }

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;
    BOOL fResult;

    fResult = !((pMemInfo->cb - pMemInfo->cbSeek) < cb);
    cb = min((pMemInfo->cb - pMemInfo->cbSeek), cb);

  // Handle MappedFile Exceptions
  __try {

    // copy the bytes
    memcpy(p, &pMemInfo->pByte[pMemInfo->cbSeek], cb);

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    SetLastError(GetExceptionCode());
    return FALSE;
  }

    pMemInfo->cbSeek += cb;

    if(!fResult)
        SetLastError(ERROR_END_OF_MEDIA);

    return(fResult);
}

BOOL SkipInMemory(
    IN HANDLE h,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;
    BOOL fResult;

    fResult = !((pMemInfo->cb - pMemInfo->cbSeek) < cb);
    cb = min((pMemInfo->cb - pMemInfo->cbSeek), cb);

    pMemInfo->cbSeek += cb;

    if(!fResult)
        SetLastError(ERROR_END_OF_MEDIA);

    return(fResult);
}


//+-------------------------------------------------------------------------
//  Lock and unlock functions
//--------------------------------------------------------------------------
STATIC void LockStore(IN PCERT_STORE pStore)
{
    EnterCriticalSection(&pStore->CriticalSection);
}
STATIC void UnlockStore(IN PCERT_STORE pStore)
{
    LeaveCriticalSection(&pStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Reference count calls to provider functions. This is necessary since
//  the store provider functions are called without a lock on the
//  store. CertCloseStore waits until the provider reference count
//  is decremented to zero before completing the close.
//
//  Also used to reference count use of the store's CryptProv handle when
//  used without a store lock.
//--------------------------------------------------------------------------

// Upon entry/exit the store is locked
static inline void AddRefStoreProv(IN PCERT_STORE pStore)
{
    pStore->lStoreProvRefCnt++;
}

// Upon entry/exit the store is locked
static inline void ReleaseStoreProv(IN PCERT_STORE pStore)
{
    if (0 == --pStore->lStoreProvRefCnt && pStore->hStoreProvWait)
        SetEvent(pStore->hStoreProvWait);
}

//+-------------------------------------------------------------------------
//  Try to get the store's CryptProv handle.
//  If we get the store's CryptProv handle,
//  then, increment the provider reference count to force another
//  thread's CertCloseStore to wait until we make a call to ReleaseCryptProv.
//
//  Leave while still in the CryptProvCriticalSection.
//
//  ReleaseCryptProv() must always be called.
//
//  Note, if returned hCryptProv is NULL, the called CertHelper functions
//  will acquire and use the appropriate default provider.
//--------------------------------------------------------------------------
#define RELEASE_STORE_CRYPT_PROV_FLAG   0x1

STATIC HCRYPTPROV GetCryptProv(
    IN PCERT_STORE pStore,
    OUT DWORD *pdwFlags
    )
{
    HCRYPTPROV hCryptProv;

    LockStore(pStore);
    hCryptProv = pStore->hCryptProv;
    if (hCryptProv) {
        AddRefStoreProv(pStore);
        *pdwFlags = RELEASE_STORE_CRYPT_PROV_FLAG;
    } else
        *pdwFlags = 0;
    UnlockStore(pStore);

    EnterCriticalSection(&CryptProvCriticalSection);
    return hCryptProv;
}

STATIC void ReleaseCryptProv(
    IN PCERT_STORE pStore,
    IN DWORD dwFlags
    )
{
    LeaveCriticalSection(&CryptProvCriticalSection);

    if (dwFlags & RELEASE_STORE_CRYPT_PROV_FLAG) {
        LockStore(pStore);
        ReleaseStoreProv(pStore);
        UnlockStore(pStore);
    }
}

//+-------------------------------------------------------------------------
//  Forward references
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    );
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    );

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    );

//+-------------------------------------------------------------------------
//  Share Store Functions
//--------------------------------------------------------------------------

// If the sharable LocalMachine store is already open, its returned with its
// RefCnt bumped
STATIC PCERT_STORE FindShareStore(
    IN LPCWSTR pwszStore
    )
{
    PCERT_STORE pStore = NULL;
    PSHARE_STORE pShare;

    EnterCriticalSection(&ShareStoreCriticalSection);

    for (pShare = pShareStoreHead; pShare; pShare = pShare->pNext) {
        if (0 == _wcsicmp(pShare->pwszStore, pwszStore)) {
            pStore = pShare->pStore;
            InterlockedIncrement(&pStore->lRefCnt);
            break;
        }
    }

    LeaveCriticalSection(&ShareStoreCriticalSection);

    return pStore;
}

// The LocalMachine store is added to the linked list of opened, sharable
// stores.
STATIC void CreateShareStore(
    IN LPCWSTR pwszStore,
    IN PCERT_STORE pStore
    )
{
    PSHARE_STORE pShare;
    DWORD cbwszStore;

    cbwszStore = (wcslen(pwszStore) + 1) * sizeof(WCHAR);

    if (NULL == (pShare = (PSHARE_STORE) PkiZeroAlloc(
            sizeof(SHARE_STORE) + cbwszStore)))
        return;

    pShare->pwszStore = (LPWSTR) &pShare[1];
    memcpy(pShare->pwszStore, pwszStore, cbwszStore);
    pShare->pStore = pStore;
    pStore->pShareStore = pShare;

    EnterCriticalSection(&ShareStoreCriticalSection);

    if (pShareStoreHead) {
        pShare->pNext = pShareStoreHead;
        assert(NULL == pShareStoreHead->pPrev);
        pShareStoreHead->pPrev = pShare;
    }
    pShareStoreHead = pShare;

    LeaveCriticalSection(&ShareStoreCriticalSection);
}

// Upon input/exit, Store is locked.
// Returns TRUE if share store was closed and freed
STATIC BOOL CloseShareStore(
    IN PCERT_STORE pStore
    )
{
    BOOL fClose;

    EnterCriticalSection(&ShareStoreCriticalSection);

    // Check if we had a FindShareStore after the store's lRefCnt
    // was decremented to 0.
    InterlockedIncrement(&pStore->lRefCnt);
    if (0 == InterlockedDecrement(&pStore->lRefCnt)) {
        PSHARE_STORE pShare;

        pShare = pStore->pShareStore;
        assert(pShare);
        if (pShare) {
            if (pShare->pNext)
                pShare->pNext->pPrev = pShare->pPrev;

            if (pShare->pPrev)
                pShare->pPrev->pNext = pShare->pNext;
            else {
                assert(pShareStoreHead == pShare);
                pShareStoreHead = pShare->pNext;
            }

            PkiFree(pShare);
        }

        pStore->pShareStore = NULL;
        fClose = TRUE;
    } else
        fClose = FALSE;

    LeaveCriticalSection(&ShareStoreCriticalSection);

    return fClose;
}

//+-------------------------------------------------------------------------
//  Open the cert store using the specified store provider.
//
//  hCryptProv specifies the crypto provider to use to create the hash
//  properties or verify the signature of a subject certificate or CRL.
//  The store doesn't need to use a private
//  key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is
//  CryptReleaseContext'ed on the final CertCloseStore.
//
//  Note, if the open fails, hCryptProv is released if it would have been
//  released when the store was closed.
//
//  If hCryptProv is zero, then, the default provider and container for the
//  PROV_RSA_FULL provider type is CryptAcquireContext'ed with
//  CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until
//  the first create hash or verify signature. In addition, once acquired,
//  the default provider isn't released until process exit when crypt32.dll
//  is unloaded. The acquired default provider is shared across all stores
//  and threads.
//
//  Use of the dwEncodingType parameter is provider dependent. The type
//  definition for pvPara also depends on the provider.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
    PCERT_STORE pStore;
    PFN_CERT_DLL_OPEN_STORE_PROV_FUNC pfnOpenStoreProv;
    BOOL fShareStore = FALSE;

    // LocalMachine System stores opened for SHARE and MAXIMUM_ALLOWED can
    // be shared. 
    if ((CERT_SYSTEM_STORE_LOCAL_MACHINE |
            CERT_STORE_SHARE_STORE_FLAG |
            CERT_STORE_SHARE_CONTEXT_FLAG |
            CERT_STORE_MAXIMUM_ALLOWED_FLAG
            ) == dwFlags
                    &&
            0 == hCryptProv
            ) {
        if (0xFFFF < (DWORD_PTR) lpszStoreProvider) {
            if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W,
                    lpszStoreProvider))
                fShareStore = TRUE;
        } else {
            if (CERT_STORE_PROV_SYSTEM_W == lpszStoreProvider)
                fShareStore = TRUE;
        }

        if (fShareStore) {
            if (pStore = FindShareStore((LPCWSTR) pvPara))
                return (HCERTSTORE) pStore;
        }
                
    }

    pStore = (PCERT_STORE) PkiZeroAlloc(sizeof(*pStore));
    if (pStore) {
        if (!Pki_InitializeCriticalSection(&pStore->CriticalSection)) {
            PkiFree(pStore);
            pStore = NULL;
        }
    }
    if (pStore == NULL) {
        if (hCryptProv && (dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0)
            CryptReleaseContext(hCryptProv, 0);
        return NULL;
    }

    CertPerfIncrementStoreTotalCount();
    CertPerfIncrementStoreCurrentCount();

    pStore->StoreProvInfo.cbSize = sizeof(CERT_STORE_PROV_INFO);
    pStore->dwStoreType = STORE_TYPE_CACHE;
    pStore->lRefCnt = 1;
    pStore->dwState = STORE_STATE_OPENING;
    pStore->hCryptProv = hCryptProv;
    pStore->dwFlags = dwFlags;

    if (CERT_STORE_PROV_MEMORY == lpszStoreProvider)
        pStore->StoreProvInfo.dwStoreProvFlags |=
            CERT_STORE_PROV_NO_PERSIST_FLAG;
    else {
        if (!CryptGetOIDFunctionAddress(
                hOpenStoreProvFuncSet,
                0,                      // dwEncodingType,
                lpszStoreProvider,
                0,                      // dwFlags
                (void **) &pfnOpenStoreProv,
                &pStore->hStoreProvFuncAddr))
            goto GetOIDFuncAddrError;
        if (!pfnOpenStoreProv(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                dwFlags & ~CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                pvPara,
                (HCERTSTORE) pStore,
                &pStore->StoreProvInfo)) {
            if (0 == (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG))
                goto OpenStoreProvError;

            pStore->hCryptProv = NULL;
            CertCloseStore((HCERTSTORE) pStore, 0);

            return CertOpenStore(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                (dwFlags & ~CERT_STORE_MAXIMUM_ALLOWED_FLAG) |
                    CERT_STORE_READONLY_FLAG,
                pvPara
                );
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_EXTERNAL_FLAG) {
            assert(STORE_TYPE_CACHE == pStore->dwStoreType &&
                IsEmptyStore(pStore));
            pStore->dwStoreType = STORE_TYPE_EXTERNAL;
        }

        if ((dwFlags & CERT_STORE_MANIFOLD_FLAG) &&
                STORE_TYPE_CACHE == pStore->dwStoreType)
            ArchiveManifoldCertificatesInStore(pStore);
    }

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_DELETED_FLAG))
            goto DeleteNotSupported;
        CertCloseStore((HCERTSTORE) pStore, 0);
        pStore = NULL;
        SetLastError(0);
    } else {
        pStore->dwState = STORE_STATE_OPEN;

        if (fShareStore)
            CreateShareStore((LPCWSTR) pvPara, pStore);

    }

CommonReturn:
    return (HCERTSTORE) pStore;

ErrorReturn:
    CertCloseStore((HCERTSTORE) pStore, 0);
    pStore = NULL;
    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == GetLastError())
            SetLastError((DWORD) E_UNEXPECTED);
    }
    goto CommonReturn;

TRACE_ERROR(GetOIDFuncAddrError)
TRACE_ERROR(OpenStoreProvError)
SET_ERROR(DeleteNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

//+-------------------------------------------------------------------------
//  Duplicate a cert store handle
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertDuplicateStore(
    IN HCERTSTORE hCertStore
    )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);
    InterlockedIncrement(&pStore->lRefCnt);
    return hCertStore;
}

//+-------------------------------------------------------------------------
//  Checks if the store has any Certs, CRLs, CTLs, collection stores or
//  links
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    )
{
    DWORD i;

    // Check that all the context lists are empty
    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pStore->rgpContextListHead[i])
            return FALSE;
    }

    // For collection, check that all stores have been removed
    if (pStore->pStoreListHead)
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the store if empty
//
//  Store is locked upon input and unlocked or freed upon returning
//--------------------------------------------------------------------------
STATIC void FreeStore(
    IN PCERT_STORE pStore)
{
    if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
        // Check if duplicated context reference count is zero.
        InterlockedIncrement(&pStore->lDeferCloseRefCnt);
        if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) == 0)
            CloseStore(pStore, 0);
        else
            UnlockStore(pStore);
    } else if (STORE_STATE_CLOSED == pStore->dwState && IsEmptyStore(pStore)) {
        UnlockStore(pStore);
        pStore->dwState = STORE_STATE_DELETED;
        assert(NULL == pStore->pShareStore);
        if (pStore->hAutoResyncEvent)
            CloseHandle(pStore->hAutoResyncEvent);
        DeleteCriticalSection(&pStore->CriticalSection);
        PkiFree(pStore);
    } else
        UnlockStore(pStore);
}

//  Store is locked upon input and unlocked or freed upon returning
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    )
{
    DWORD dwFailFlags = 0;
    DWORD i;
    PCONTEXT_ELEMENT pFreeLinkEleHead;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pFreeStoreLinkHead;
    PPROP_ELEMENT pPropEle;
    DWORD cStoreProvFunc;
    BOOL fFreeFindNext;

    PFN_CERT_STORE_PROV_CLOSE pfnStoreProvClose;
    HCRYPTPROV hCryptProv;

    assert(pStore);
    assert(NULL == pStore->pShareStore);

    CertPerfDecrementStoreCurrentCount();

    // Assert that another thread isn't already waiting for a provider
    // function to complete.
    assert(NULL == pStore->hStoreProvWait);
    // Assert that another thread isn't already waiting for a provider
    // to return from its close callback.
    assert(pStore->dwState != STORE_STATE_CLOSING &&
         pStore->dwState != STORE_STATE_CLOSED);
    if (pStore->hStoreProvWait || pStore->dwState == STORE_STATE_CLOSING ||
            pStore->dwState == STORE_STATE_CLOSED)
        goto UnexpectedError;

    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING);
    pStore->dwState = STORE_STATE_CLOSING;

    cStoreProvFunc = pStore->StoreProvInfo.cStoreProvFunc;
    // By setting the following to 0 inhibits anyone else from calling
    // the provider's functions.
    pStore->StoreProvInfo.cStoreProvFunc = 0;
    if (cStoreProvFunc > CERT_STORE_PROV_CLOSE_FUNC)
        pfnStoreProvClose = (PFN_CERT_STORE_PROV_CLOSE)
                pStore->StoreProvInfo.rgpvStoreProvFunc[
                    CERT_STORE_PROV_CLOSE_FUNC];
    else
        pfnStoreProvClose = NULL;

    hCryptProv = pStore->hCryptProv;
    // By setting the following to 0 inhibits anyone else from using
    // the store's CryptProv handle
    pStore->hCryptProv = 0;

    fFreeFindNext = FALSE;
    if (STORE_TYPE_EXTERNAL == pStore->dwStoreType) {
        // Check if any FIND_NEXT external elements are remaining to be freed
        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            for ( ; pEle; pEle = pEle->pNext) {
                if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
                    pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
                    pEle->dwFlags |= ELEMENT_CLOSE_FIND_NEXT_FLAG;
                    AddRefContextElement(pEle);
                    fFreeFindNext = TRUE;
                }
            }
        }
    }

    if (pStore->lStoreProvRefCnt) {
        // Wait for all the provider functions to complete and all
        // uses of the hCryptProv handle to finish
        if (NULL == (pStore->hStoreProvWait = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))) {   // lpszEventName
            assert(pStore->hStoreProvWait);
            goto UnexpectedError;
        }

        while (pStore->lStoreProvRefCnt) {
            UnlockStore(pStore);
            WaitForSingleObject(pStore->hStoreProvWait, INFINITE);
            LockStore(pStore);
        }
        CloseHandle(pStore->hStoreProvWait);
        pStore->hStoreProvWait = NULL;
    }

    if (fFreeFindNext) {
        // Call the provider to free the FIND_NEXT element. Must call
        // without holding a store lock.
        for (i = 0; i < CONTEXT_COUNT; i++) {
            const DWORD dwStoreProvFreeFindIndex =
                rgdwStoreProvFreeFindIndex[i];
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            while (pEle) {
                if (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG) {
                    PCONTEXT_ELEMENT pEleFree = pEle;
                    PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

                    pEle = pEle->pNext;
                    while (pEle && 0 ==
                            (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG))
                        pEle = pEle->pNext;

                    UnlockStore(pStore);
                    if (dwStoreProvFreeFindIndex < cStoreProvFunc &&
                            NULL != (pfnStoreProvFreeFindCert =
                                (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                            pStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvFreeFindIndex]))
                        pfnStoreProvFreeFindCert(
                            pStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEleFree->pEle),
                            pEleFree->External.pvProvInfo,
                            0                       // dwFlags
                            );
                    ReleaseContextElement(pEleFree);
                    LockStore(pStore);
                } else
                    pEle = pEle->pNext;
            }
        }
    }

    if (pfnStoreProvClose) {
        // To prevent any type of deadlock, call the provider functions
        // without a lock on the store.
        //
        // Note our state is CLOSING, not CLOSED. This prevents any other
        // calls to FreeStore() from prematurely deleting the store.
        UnlockStore(pStore);
        pfnStoreProvClose(pStore->StoreProvInfo.hStoreProv, dwFlags);
        LockStore(pStore);
    }

    if (pStore->hStoreProvFuncAddr)
        CryptFreeOIDFunctionAddress(pStore->hStoreProvFuncAddr, 0);
    if (pStore->StoreProvInfo.hStoreProvFuncAddr2)
        CryptFreeOIDFunctionAddress(
            pStore->StoreProvInfo.hStoreProvFuncAddr2, 0);

    // Since hCryptProv was passed to the provider it must be released
    // last!!!
    if (hCryptProv &&
            0 == (pStore->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG))
        CryptReleaseContext(hCryptProv, 0);

    // Iterate through the elements. If the element hasn't already been
    // deleted, remove the store's reference on the element. Remove and
    // free if no other references.
    pFreeLinkEleHead = NULL;
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
        while (pEle) {
            PCONTEXT_ELEMENT pEleNext = pEle->pNext;
            if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
                if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
                    if (ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType) {
                        // The LINK_CONTEXT can't be freed while holding
                        // the store lock. Will free later after unlocking.
                        RemoveContextElement(pEle);
                        pEle->pNext = pFreeLinkEleHead;
                        pFreeLinkEleHead = pEle;
                    } else {
                        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType);
                        RemoveAndFreeContextElement(pEle);
                    }
                } else
                    //  Still a reference on the element
                    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
            }
            // else
            //  A previous delete has already removed the store's reference

            pEle = pEleNext;
        }
    }

    // Iterate through the store links. If the store link hasn't already been
    // deleted, remove the store's reference on the link. Remove and free
    // if no other references.
    pFreeStoreLinkHead = NULL;
    pStoreLink = pStore->pStoreListHead;
    while (pStoreLink) {
        PCERT_STORE_LINK pStoreLinkNext = pStoreLink->pNext;

        if (0 == (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
                // The STORE_LINK can't be freed while holding
                // the store lock. Will free later after unlocking.
                RemoveStoreLink(pStoreLink);
                pStoreLink->pNext = pFreeStoreLinkHead;
                pFreeStoreLinkHead = pStoreLink;
            } else
                //  Still a reference on the store link
                pStoreLink->dwFlags |= STORE_LINK_DELETED_FLAG;
        }
        // else
        //  A previous delete has already removed the store's reference

        pStoreLink = pStoreLinkNext;
    }

    if (pFreeLinkEleHead || pFreeStoreLinkHead) {
        // Unlock the store before freeing links
        UnlockStore(pStore);
        while (pFreeLinkEleHead) {
            PCONTEXT_ELEMENT pEle = pFreeLinkEleHead;
            pFreeLinkEleHead = pFreeLinkEleHead->pNext;
            FreeLinkContextElement(pEle);
        }

        while (pFreeStoreLinkHead) {
            pStoreLink = pFreeStoreLinkHead;
            pFreeStoreLinkHead = pFreeStoreLinkHead->pNext;
            FreeStoreLink(pStoreLink);
        }

        LockStore(pStore);
    }

    // Free the store's property elements
    while (pPropEle = pStore->pPropHead) {
        RemovePropElement(&pStore->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }

    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        if (!IsEmptyStore(pStore))
            dwFailFlags = CERT_CLOSE_STORE_CHECK_FLAG;
    }

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        UnlockStore(pStore);

        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle;
            while (pEle = pStore->rgpContextListHead[i]) {
                if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
                    RemoveAndFreeContextElement(pEle);
                else
                    RemoveAndFreeLinkElement(pEle);
            }
        }

        while (pStoreLink = pStore->pStoreListHead)
            RemoveAndFreeStoreLink(pStoreLink);

        LockStore(pStore);
        assert(IsEmptyStore(pStore));
    }

    pStore->dwState = STORE_STATE_CLOSED;
    // Either frees or unlocks the store
    FreeStore(pStore);

    if (dwFlags & dwFailFlags) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        return FALSE;
    } else
        return TRUE;

UnexpectedError:
    UnlockStore(pStore);
    SetLastError((DWORD) E_UNEXPECTED);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Close a cert store handle.
//
//  There needs to be a corresponding close for each open and duplicate.
//
//  Even on the final close, the cert store isn't freed until all of its
//  certificate, CRL and CTL contexts have also been freed.
//
//  On the final close, the hCryptProv passed to CertOpenStore is
//  CryptReleaseContext'ed.
//
//  LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE
//  is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fClose;
    BOOL fPendingError = FALSE;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    DWORD dwErr = GetLastError();   // For success, don't globber LastError

    if (pStore == NULL)
        return TRUE;

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        LockStore(pStore);
        if (pStore->lRefCnt != 1) {
            if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG)
                fPendingError = TRUE;
        }
        pStore->lRefCnt = 0;
    } else if (InterlockedDecrement(&pStore->lRefCnt) == 0) {
        LockStore(pStore);
        if (pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
            // Check if duplicated context reference count is zero.
            InterlockedIncrement(&pStore->lDeferCloseRefCnt);
            if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) != 0) {
                assert(pStore->dwState == STORE_STATE_OPEN ||
                    pStore->dwState == STORE_STATE_OPENING ||
                    pStore->dwState == STORE_STATE_DEFER_CLOSING);
                pStore->dwState = STORE_STATE_DEFER_CLOSING;
                UnlockStore(pStore);
                goto PendingCloseReturn;
            }
        }
    } else
        // Still holding a reference count on the store
        goto PendingCloseReturn;

    if (pStore->pShareStore) {
        assert(0 == (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG));
        // There's a window where the shared store's RefCnt can be incremented
        // before being removed from the linked list of share stores.
        fClose = CloseShareStore(pStore);
    } else
        fClose = TRUE;


    // Don't allow the NULL store to be closed
    assert(pStore->dwState != STORE_STATE_NULL);
    if (pStore->dwState == STORE_STATE_NULL) {
        pStore->lRefCnt = 1;
        UnlockStore(pStore);
        SetLastError((DWORD) E_UNEXPECTED);
        return FALSE;
    }

    // CloseStore() unlocks or frees store
    if (fClose)
        fResult = CloseStore(pStore, dwFlags);
    else {
        fResult = TRUE;
        UnlockStore(pStore);
    }

    if (fResult) {
        if (fPendingError) {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        } else
            SetLastError(dwErr);
    }
    return fResult;

PendingCloseReturn:
    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        fResult = FALSE;
    } else
        fResult = TRUE;
    return fResult;
}

//+=========================================================================
//  ArchiveManifoldCertificatesInStore
//==========================================================================

#define SORTED_MANIFOLD_ALLOC_COUNT     25

typedef struct _SORTED_MANIFOLD_ENTRY {
    PCCERT_CONTEXT      pCert;
    CRYPT_OBJID_BLOB    Value;
} SORTED_MANIFOLD_ENTRY, *PSORTED_MANIFOLD_ENTRY;

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  The Manifold entries are sorted according to manifold value and
//  the certificate's NotAfter and NotBefore times.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareManifoldEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PSORTED_MANIFOLD_ENTRY p1 = (PSORTED_MANIFOLD_ENTRY) pelem1;
    PSORTED_MANIFOLD_ENTRY p2 = (PSORTED_MANIFOLD_ENTRY) pelem2;

    DWORD cb1 = p1->Value.cbData;
    DWORD cb2 = p2->Value.cbData;

    if (cb1 == cb2) {
        int iCmp;

        if (0 == cb1)
            iCmp = 0;
        else
            iCmp = memcmp(p1->Value.pbData, p2->Value.pbData, cb1);

        if (0 != iCmp)
            return iCmp;

        // Same manifold value. Compare the certificate NotAfter and
        // NotBefore times.
        iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotAfter,
            &p2->pCert->pCertInfo->NotAfter);
        if (0 == iCmp)
            iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotBefore,
                &p2->pCert->pCertInfo->NotBefore);
        return iCmp;
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    )
{
    PCONTEXT_ELEMENT pEle;
    DWORD cAlloc = 0;
    DWORD cManifold = 0;
    PSORTED_MANIFOLD_ENTRY pManifold = NULL;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    // Create an array of non-archived certificates having the Manifold
    // extension
    pEle = pStore->rgpContextListHead[CERT_STORE_CERTIFICATE_CONTEXT - 1];
    for ( ; pEle; pEle = pEle->pNext) {
        PCCERT_CONTEXT pCert;
        PCERT_INFO pCertInfo;
        PCERT_EXTENSION pExt;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted or archived elements
        if (pEle->dwFlags & (ELEMENT_DELETED_FLAG | ELEMENT_ARCHIVED_FLAG))
            continue;

        pCert = ToCertContext(pEle);
        pCertInfo = pCert->pCertInfo;

        if (pExt = CertFindExtension(
                szOID_CERT_MANIFOLD,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                )) {
            if (cManifold >= cAlloc) {
                PSORTED_MANIFOLD_ENTRY pNewManifold;

                if (NULL == (pNewManifold = (PSORTED_MANIFOLD_ENTRY) PkiRealloc(
                        pManifold, (cAlloc + SORTED_MANIFOLD_ALLOC_COUNT) *
                            sizeof(SORTED_MANIFOLD_ENTRY))))
                    continue;
                pManifold = pNewManifold;
                cAlloc += SORTED_MANIFOLD_ALLOC_COUNT;
            }
            pManifold[cManifold].pCert =
                CertDuplicateCertificateContext(pCert);
            pManifold[cManifold].Value = pExt->Value;
            cManifold++;
        }
    }

    UnlockStore(pStore);

    if (cManifold) {
        const CRYPT_DATA_BLOB ManifoldBlob = { 0, NULL };

        // Sort the Manifold entries according to manifold value and
        // the certificate's NotAfter and NotBefore times.
        qsort(pManifold, cManifold, sizeof(SORTED_MANIFOLD_ENTRY),
            CompareManifoldEntry);

        // Set the Archive property for previous entries having the same
        // manifold value.
        for (DWORD i = 0; i < cManifold - 1; i++) {
            if (pManifold[i].Value.cbData == pManifold[i+1].Value.cbData &&
                    (0 == pManifold[i].Value.cbData ||
                        0 == memcmp(pManifold[i].Value.pbData,
                            pManifold[i+1].Value.pbData,
                            pManifold[i].Value.cbData)))
                CertSetCertificateContextProperty(
                    pManifold[i].pCert,
                    CERT_ARCHIVED_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    (const void *) &ManifoldBlob
                    );
        }

        while (cManifold--)
            CertFreeCertificateContext(pManifold[cManifold].pCert);

        PkiFree(pManifold);
    }
}

//+-------------------------------------------------------------------------
//  Write the CERT, CRL, CTL, PROP or END element to the file or memory
//
//  Upon entry/exit the store is locked.
//--------------------------------------------------------------------------
STATIC BOOL WriteStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN DWORD dwEncodingType,
    IN DWORD dwEleType,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    FILE_ELEMENT_HDR EleHdr;
    BOOL fResult;

    EleHdr.dwEleType = dwEleType;
    EleHdr.dwEncodingType = dwEncodingType;
    EleHdr.dwLen = cbData;
    assert(cbData <= MAX_FILE_ELEMENT_DATA_LEN);
    fResult = pfnWrite(
        h,
        &EleHdr,
        sizeof(EleHdr)
        );
    if (fResult && cbData > 0)
        fResult = pfnWrite(
                h,
                pbData,
                cbData
                );

    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certs, CRLs, CTLs and properties in the store. Prepend with a
//  file header and append with an end element.
//--------------------------------------------------------------------------
STATIC BOOL SerializeStore(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;

    DWORD i;
    FILE_HDR FileHdr;

    FileHdr.dwVersion = CERT_FILE_VERSION_0;
    FileHdr.dwMagic = CERT_MAGIC;
    if (!pfnWrite(h, &FileHdr, sizeof(FileHdr))) goto WriteError;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = NULL;
        while (pEle = FindElementInStore(pStore, i, &FindAnyInfo, pEle)) {
            if (!SerializeStoreElement(h, pfnWrite, pEle)) {
                ReleaseContextElement(pEle);
                goto SerializeError;
            }
        }
    }

    if (!WriteStoreElement(
            h,
            pfnWrite,
            0,                      // dwEncodingType
            FILE_ELEMENT_END_TYPE,
            NULL,                   // pbData
            0                       // cbData
            )) goto WriteError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteError)
TRACE_ERROR(SerializeError)
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_STORE
//--------------------------------------------------------------------------
STATIC BOOL SaveAsStore(
    IN PCERT_STORE pStore,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            fResult = SerializeStore(
                (HANDLE) pvSaveToPara,
                WriteToFile,
                pStore);
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                MEMINFO MemInfo;

                MemInfo.pByte = pData->pbData;
                if (NULL == pData->pbData)
                    MemInfo.cb = 0;
                else
                    MemInfo.cb = pData->cbData;
                MemInfo.cbSeek = 0;

                if (fResult = SerializeStore(
                        (HANDLE) &MemInfo,
                        WriteToMemory,
                        pStore)) {
                    if (MemInfo.cbSeek > MemInfo.cb && pData->pbData) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                    pData->cbData = MemInfo.cbSeek;
                } else
                    pData->cbData = 0;
            }
            break;
        default:
            SetLastError((DWORD) E_UNEXPECTED);
            fResult = FALSE;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Following routines support the SaveAsPKCS7 function
//--------------------------------------------------------------------------

STATIC void FreeSaveAsPKCS7Info(
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    IN PCCERT_CONTEXT *ppCert,
    IN PCCRL_CONTEXT *ppCrl
    )
{
    DWORD dwIndex;

    dwIndex = pInfo->cCertEncoded;
    while (dwIndex--)
        CertFreeCertificateContext(ppCert[dwIndex]);
    PkiFree(ppCert);
    PkiFree(pInfo->rgCertEncoded);
    pInfo->cCertEncoded = 0;
    pInfo->rgCertEncoded = NULL;

    dwIndex = pInfo->cCrlEncoded;
    while (dwIndex--)
        CertFreeCRLContext(ppCrl[dwIndex]);
    PkiFree(ppCrl);
    PkiFree(pInfo->rgCrlEncoded);
    pInfo->cCrlEncoded = 0;
    pInfo->rgCrlEncoded = NULL;
}

#define SAVE_AS_PKCS7_ALLOC_COUNT    50

// Upon entry: store is unlocked
STATIC BOOL InitSaveAsPKCS7Info(
    IN PCERT_STORE pStore,
    IN OUT PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT PCCERT_CONTEXT **pppCert,
    OUT PCCRL_CONTEXT **pppCrl
    )
{
    BOOL fResult;
    DWORD cAlloc;
    DWORD dwIndex;
    PCRYPT_DATA_BLOB pBlob;

    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT *ppCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    PCCRL_CONTEXT *ppCrl = NULL;

    memset(pInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    pInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCert = CertEnumCertificatesInStore((HCERTSTORE) pStore, pCert)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCERT_CONTEXT *ppNewCert;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCertEncoded = pBlob;

            if (NULL == (ppNewCert = (PCCERT_CONTEXT *) PkiRealloc(
                    ppCert, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCERT_CONTEXT))))
                goto OutOfMemory;
            ppCert = ppNewCert;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCert[dwIndex] = CertDuplicateCertificateContext(pCert);
        pBlob[dwIndex].pbData = pCert->pbCertEncoded;
        pBlob[dwIndex].cbData = pCert->cbCertEncoded;
        pInfo->cCertEncoded = ++dwIndex;
    }

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCrl = CertEnumCRLsInStore((HCERTSTORE) pStore, pCrl)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCRL_CONTEXT *ppNewCrl;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCrlEncoded = pBlob;

            if (NULL == (ppNewCrl = (PCCRL_CONTEXT *) PkiRealloc(
                    ppCrl, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCRL_CONTEXT))))
                goto OutOfMemory;
            ppCrl = ppNewCrl;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCrl[dwIndex] = CertDuplicateCRLContext(pCrl);
        pBlob[dwIndex].pbData = pCrl->pbCrlEncoded;
        pBlob[dwIndex].cbData = pCrl->cbCrlEncoded;
        pInfo->cCrlEncoded = ++dwIndex;
    }

    fResult = TRUE;
CommonReturn:
    *pppCert = ppCert;
    *pppCrl = ppCrl;
    return fResult;
ErrorReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCrl)
        CertFreeCRLContext(pCrl);
    FreeSaveAsPKCS7Info(pInfo, ppCert, ppCrl);
    ppCert = NULL;
    ppCrl = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}

STATIC BOOL EncodePKCS7(
    IN DWORD dwEncodingType,
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult = TRUE;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded)
        cbEncoded = CryptMsgCalculateEncodedLength(
            dwEncodingType,
            0,                      // dwFlags
            CMSG_SIGNED,
            pInfo,
            NULL,                   // pszInnerContentObjID
            0                       // cbData
            );
    else {
        HCRYPTMSG hMsg;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwEncodingType,
                0,                  // dwFlags
                CMSG_SIGNED,
                pInfo,
                NULL,               // pszInnerContentObjID
                NULL                // pStreamInfo
                )))
            cbEncoded = 0;
        else {
            if (CryptMsgUpdate(
                    hMsg,
                    NULL,       // pbData
                    0,          // cbData
                    TRUE        // fFinal
                    ))
                fResult = CryptMsgGetParam(
                    hMsg,
                    CMSG_CONTENT_PARAM,
                    0,              // dwIndex
                    pbEncoded,
                    &cbEncoded);
            else
                cbEncoded = 0;
            CryptMsgClose(hMsg);
        }

    }

    if (fResult) {
        if (0 == cbEncoded)
            fResult = FALSE;
        else if (pbEncoded && cbEncoded > *pcbEncoded) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }
    *pcbEncoded = cbEncoded;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_PKCS7
//--------------------------------------------------------------------------
STATIC BOOL SaveAsPKCS7(
    IN PCERT_STORE pStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedEncodeInfo;
    PCCERT_CONTEXT *ppCert;
    PCCRL_CONTEXT *ppCrl;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType) ||
            0 == GET_CMSG_ENCODING_TYPE(dwEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (!InitSaveAsPKCS7Info(
            pStore,
            &SignedEncodeInfo,
            &ppCert,
            &ppCrl)) goto InitInfoError;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    NULL,               // pbEncoded
                    &cbEncoded)) goto EncodePKCS7Error;
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    pbEncoded,
                    &cbEncoded))
                goto EncodePKCS7Error;
             else {
                DWORD cbBytesWritten;
                if (!WriteFile(
                        (HANDLE) pvSaveToPara,
                        pbEncoded,
                        cbEncoded,
                        &cbBytesWritten,
                        NULL            // lpOverlapped
                        )) goto WriteError;
            }
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                if (!EncodePKCS7(
                        dwEncodingType,
                        &SignedEncodeInfo,
                        pData->pbData,
                        &pData->cbData)) goto EncodePKCS7Error;
            }
            break;
        default:
            goto UnexpectedError;
    }

    fResult = TRUE;
CommonReturn:
    FreeSaveAsPKCS7Info(&SignedEncodeInfo, ppCert, ppCrl);
    PkiFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitInfoError)
TRACE_ERROR(EncodePKCS7Error)
TRACE_ERROR(WriteError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Save the cert store. Enhanced version with lots of options.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSaveStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    assert(pvSaveToPara);
    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILENAME_A:
            {
                BOOL fResult;
                LPWSTR pwszFilename;
                if (NULL == (pwszFilename = MkWStr((LPSTR) pvSaveToPara)))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILENAME_W,
                    (void *) pwszFilename,
                    dwFlags);
                FreeWStr(pwszFilename);
                return fResult;
            }
            break;
        case CERT_STORE_SAVE_TO_FILENAME_W:
            {
                BOOL fResult;
                HANDLE hFile;
                if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                          (LPWSTR) pvSaveToPara,
                          GENERIC_WRITE,
                          0,                        // fdwShareMode
                          NULL,                     // lpsa
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL                      // hTemplateFile
                          )))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILE,
                    (void *) hFile,
                    dwFlags);
                CloseHandle(hFile);
                return fResult;
            }
            break;
        case CERT_STORE_SAVE_TO_FILE:
        case CERT_STORE_SAVE_TO_MEMORY:
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }

    switch (dwSaveAs) {
        case CERT_STORE_SAVE_AS_STORE:
            return SaveAsStore(
                (PCERT_STORE) hCertStore,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
        case CERT_STORE_SAVE_AS_PKCS7:
            return SaveAsPKCS7(
                (PCERT_STORE) hCertStore,
                dwEncodingType,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }
}

//+=========================================================================
//  Share Element Find, Create and Release functions
//==========================================================================

static inline DWORD GetShareElementHashBucketIndex(
    IN BYTE *pbSha1Hash
    )
{
    return pbSha1Hash[0] % SHARE_ELEMENT_HASH_BUCKET_COUNT;
}


// Find existing share element identified by its sha1 hash.
// For a match, the returned share element is AddRef'ed.
//
// The dwContextType is a sanity check. Different context types should never
// match.
STATIC PSHARE_ELEMENT FindShareElement(
    IN BYTE *pbSha1Hash,
    IN DWORD dwContextType
    )
{
    PSHARE_ELEMENT pShareEle;
    DWORD dwBucketIndex = GetShareElementHashBucketIndex(pbSha1Hash);

    EnterCriticalSection(&ShareElementCriticalSection);

    for (pShareEle = rgpShareElementHashBucket[dwBucketIndex];
                NULL != pShareEle;
                pShareEle = pShareEle->pNext)
    {
        if (0 == memcmp(pbSha1Hash, pShareEle->rgbSha1Hash, SHA1_HASH_LEN) &&
                dwContextType == pShareEle->dwContextType) {
            pShareEle->dwRefCnt++;
            break;
        }
    }

    LeaveCriticalSection(&ShareElementCriticalSection);

    return pShareEle;
}

// Upon input pbEncoded has been allocated. Not freed on a NULL error
// return.
//
// The returned share element has been AddRef'ed
STATIC PSHARE_ELEMENT CreateShareElement(
    IN BYTE *pbSha1Hash,
    IN DWORD dwContextType,
    IN DWORD dwEncodingType,
    IN BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    PSHARE_ELEMENT pShareEle = NULL;
    DWORD dwBucketIndex = GetShareElementHashBucketIndex(pbSha1Hash);
    LPCSTR pszStructType;

    if (NULL == (pShareEle = (PSHARE_ELEMENT) PkiZeroAlloc(
            sizeof(SHARE_ELEMENT))))
        goto OutOfMemory;
    memcpy(pShareEle->rgbSha1Hash, pbSha1Hash, SHA1_HASH_LEN);
    pShareEle->dwContextType = dwContextType;
    pShareEle->pbEncoded = pbEncoded;
    pShareEle->cbEncoded = cbEncoded;

    // Decode according to the context type. Note, a CTL share element
    // doesn't have a decoded CTL.
    pszStructType = rgpszShareElementStructType[dwContextType];
    if (pszStructType) {
        if (NULL == (pShareEle->pvInfo =  AllocAndDecodeObject(
                dwEncodingType,
                pszStructType,
                pbEncoded,
                cbEncoded
                )))
            goto DecodeError;
    }

    pShareEle->dwRefCnt = 1;

    // Insert at beginning of share element's hash bucket list
    EnterCriticalSection(&ShareElementCriticalSection);
    if (rgpShareElementHashBucket[dwBucketIndex]) {
        assert(NULL == rgpShareElementHashBucket[dwBucketIndex]->pPrev);
        rgpShareElementHashBucket[dwBucketIndex]->pPrev = pShareEle;

        pShareEle->pNext = rgpShareElementHashBucket[dwBucketIndex];
    }

    rgpShareElementHashBucket[dwBucketIndex] = pShareEle;
    LeaveCriticalSection(&ShareElementCriticalSection);

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT - 1:
            CertPerfIncrementCertElementCurrentCount();
            CertPerfIncrementCertElementTotalCount();
            break;
        case CERT_STORE_CRL_CONTEXT - 1:
            CertPerfIncrementCrlElementCurrentCount();
            CertPerfIncrementCrlElementTotalCount();
            break;
        case CERT_STORE_CTL_CONTEXT - 1:
            CertPerfIncrementCtlElementCurrentCount();
            CertPerfIncrementCtlElementTotalCount();
            break;
    }

CommonReturn:
    return pShareEle;
ErrorReturn:
    if (pShareEle) {
        PkiFree(pShareEle->pvInfo);
        PkiFree(pShareEle);
        pShareEle = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeError)
}

STATIC void ReleaseShareElement(
    IN PSHARE_ELEMENT pShareEle
    )
{
    EnterCriticalSection(&ShareElementCriticalSection);

    if (0 == --pShareEle->dwRefCnt) {
        if (pShareEle->pNext)
            pShareEle->pNext->pPrev = pShareEle->pPrev;
        if (pShareEle->pPrev)
            pShareEle->pPrev->pNext = pShareEle->pNext;
        else {
            DWORD dwBucketIndex =
                GetShareElementHashBucketIndex(pShareEle->rgbSha1Hash);
            assert(rgpShareElementHashBucket[dwBucketIndex] == pShareEle);
            if (rgpShareElementHashBucket[dwBucketIndex] == pShareEle)
                rgpShareElementHashBucket[dwBucketIndex] = pShareEle->pNext;

        }

        switch (pShareEle->dwContextType) {
            case CERT_STORE_CERTIFICATE_CONTEXT - 1:
                CertPerfDecrementCertElementCurrentCount();
                break;
            case CERT_STORE_CRL_CONTEXT - 1:
                CertPerfDecrementCrlElementCurrentCount();
                break;
            case CERT_STORE_CTL_CONTEXT - 1:
                CertPerfDecrementCtlElementCurrentCount();
                break;
        }

        PkiFree(pShareEle->pbEncoded);
        PkiFree(pShareEle->pvInfo);
        PkiFree(pShareEle);
    }

    LeaveCriticalSection(&ShareElementCriticalSection);
}

//+-------------------------------------------------------------------------
//  Read and allocate the store element. Possibly adjust the cbEncoded to
//  excluded trailing bytes.
//--------------------------------------------------------------------------
STATIC ReadStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN DWORD dwEncodingType,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = *pcbEncoded;

    if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;
    if (!pfnRead(
            h,
            pbEncoded,
            cbEncoded))
        goto ReadError;
    cbEncoded = AdjustEncodedLength(dwEncodingType, pbEncoded, cbEncoded);

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
ErrorReturn:
    PkiFree(pbEncoded);
    pbEncoded = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadError)
}

//+-------------------------------------------------------------------------
//  Create the store element.
//
//  If CERT_STORE_SHARE_CONTEXT_FLAG is set, a share element is either found
//  or created.
//
//  Normally, the sha1 hash will have been read as a serialized property
//  and passed in and won't need to be calculated here. Also, for a
//  found share element, the encoded element bytes can be skipped instead
//  of being allocated and read.
//
//  In all cases, the context specific CreateElement function is called.
//--------------------------------------------------------------------------
STATIC PCONTEXT_ELEMENT CreateStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN PCERT_STORE pStore,
    IN DWORD dwEncodingType,
    IN DWORD dwContextType,
    IN DWORD cbEncoded,
    IN OPTIONAL BYTE *pbSha1Hash
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PSHARE_ELEMENT pShareEle = NULL;
    BYTE *pbEncoded = NULL;

    assert(pStore);
    if (pStore->dwFlags & CERT_STORE_SHARE_CONTEXT_FLAG) {
        BYTE rgbSha1Hash[SHA1_HASH_LEN];

        if (NULL == pbSha1Hash) {
            DWORD cbData;

            if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                    &pbEncoded, &cbEncoded))
                goto ReadError;

            cbData = SHA1_HASH_LEN;
            if (!CryptHashCertificate(
                    0,                  // hCryptProv
                    CALG_SHA1,
                    0,                  // dwFlags
                    pbEncoded,
                    cbEncoded,
                    rgbSha1Hash,
                    &cbData) || SHA1_HASH_LEN != cbData)
                goto HashError;
            pbSha1Hash = rgbSha1Hash;
        }

        pShareEle = FindShareElement(pbSha1Hash, dwContextType);

        if (pShareEle) {
            if (NULL == pbEncoded) {
                if (!pfnSkip(
                        h,
                        cbEncoded))
                    goto SkipError;
            } else
                PkiFree(pbEncoded);
            pbEncoded = pShareEle->pbEncoded;
            cbEncoded = pShareEle->cbEncoded;
        } else {
            if (NULL == pbEncoded) {
                if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                        &pbEncoded, &cbEncoded))
                    goto ReadError;
            }
            if (NULL == (pShareEle = CreateShareElement(
                    pbSha1Hash,
                    dwContextType,
                    dwEncodingType,
                    pbEncoded,
                    cbEncoded
                    )))
                goto CreateShareElementError;
            assert(pbEncoded == pShareEle->pbEncoded);
            assert(cbEncoded == pShareEle->cbEncoded);
        }
    } else {
        if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                &pbEncoded, &cbEncoded))
            goto ReadError;
    }

    if (NULL == (pEle = rgpfnCreateElement[dwContextType](
            pStore,
            dwEncodingType,
            pbEncoded,
            cbEncoded,
            pShareEle
            )))
        goto CreateElementError;
CommonReturn:
    return pEle;

ErrorReturn:
    if (pShareEle) {
        if (pbEncoded != pShareEle->pbEncoded)
            PkiFree(pbEncoded);
        ReleaseShareElement(pShareEle);
    } else {
        PkiFree(pbEncoded);
    }

    assert(NULL == pEle);
    goto CommonReturn;

TRACE_ERROR(ReadError)
TRACE_ERROR(HashError)
TRACE_ERROR(SkipError)
TRACE_ERROR(CreateShareElementError)
TRACE_ERROR(CreateElementError)
}

//+-------------------------------------------------------------------------
//  Loads a serialized certificate, CRL or CTL with properties into a store.
//
//  Also supports decoding of KeyIdentifier properties.
//--------------------------------------------------------------------------
STATIC DWORD LoadStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN DWORD cbReadSize,
    IN OPTIONAL PCERT_STORE pStore,         // NULL for fKeyIdAllowed
    IN DWORD dwAddDisposition,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext,
    IN BOOL fKeyIdAllowed = FALSE
    )
{
    BYTE *pbEncoded = NULL;
    PCONTEXT_ELEMENT pContextEle = NULL;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    PPROP_ELEMENT pPropHead = NULL;
    BYTE *pbSha1Hash = NULL;                // not allocated
    FILE_ELEMENT_HDR EleHdr;
    BOOL fIsProp;
    DWORD csStatus;
    DWORD dwContextType;

    do {
        fIsProp = FALSE;

        if (!pfnRead(
                h,
                &EleHdr,
                sizeof(EleHdr))) goto ReadError;

        if (EleHdr.dwEleType == FILE_ELEMENT_END_TYPE) {
            if (pPropHead != NULL)
                goto PrematureEndError;

            csStatus = CSEnd;
            goto ZeroOutParameterReturn;
        }

        if (EleHdr.dwLen > cbReadSize)
            goto ExceedReadSizeError;

        switch (EleHdr.dwEleType) {
            case FILE_ELEMENT_CERT_TYPE:
                dwContextType = CERT_STORE_CERTIFICATE_CONTEXT;
                break;
            case FILE_ELEMENT_CRL_TYPE:
                dwContextType = CERT_STORE_CRL_CONTEXT;
                break;
            case FILE_ELEMENT_CTL_TYPE:
                dwContextType = CERT_STORE_CTL_CONTEXT;
                break;
            default:
                dwContextType = 0;
        }

        if (0 != dwContextType) {
            if (0 == (dwContextTypeFlags & (1 << dwContextType)))
                goto ContextNotAllowedError;
            if (NULL == (pContextEle = CreateStoreElement(
                    h,
                    pfnRead,
                    pfnSkip,
                    pStore,
                    EleHdr.dwEncodingType,
                    dwContextType - 1,
                    EleHdr.dwLen,
                    pbSha1Hash
                    )))
                goto CreateStoreElementError;

            pbEncoded = NULL;
            pContextEle->Cache.pPropHead = pPropHead;
            pPropHead = NULL;
            if (!AddElementToStore(pStore, pContextEle, dwAddDisposition,
                    ppvContext ? &pStoreEle : NULL))
                goto AddStoreElementError;
            else
                pContextEle = NULL;

            if (pdwContextType)
                *pdwContextType = dwContextType;
            if (ppvContext)
                *((PCCERT_CONTEXT *) ppvContext) = ToCertContext(pStoreEle);
        } else {
            // EleHdr.dwLen may be 0 for a property
            if (EleHdr.dwLen > 0) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(
                        EleHdr.dwLen)))
                    goto OutOfMemory;
                if (!pfnRead(
                        h,
                        pbEncoded,
                        EleHdr.dwLen)) goto ReadError;
            }

            if (EleHdr.dwEleType == FILE_ELEMENT_KEYID_TYPE) {
                PKEYID_ELEMENT pKeyIdEle;

                if (!fKeyIdAllowed)
                    goto KeyIdNotAllowedError;
                if (NULL == (pKeyIdEle = CreateKeyIdElement(
                        pbEncoded,
                        EleHdr.dwLen
                        )))
                    goto CreateKeyIdElementError;
                pbEncoded = NULL;
                pKeyIdEle->pPropHead = pPropHead;
                pPropHead = NULL;
                assert(ppvContext);
                if (ppvContext)
                    *((PKEYID_ELEMENT *) ppvContext) = pKeyIdEle;

            } else if (EleHdr.dwEleType > CERT_LAST_USER_PROP_ID) {
                // Silently discard any IDs exceeding 0xFFFF. The
                // FIRST_USER_PROP_ID used to start at 0x10000.
                fIsProp = TRUE;
                PkiFree(pbEncoded);
                pbEncoded = NULL;
            } else if (EleHdr.dwEleType == CERT_KEY_CONTEXT_PROP_ID) {
                goto InvalidPropId;
            } else {
                PPROP_ELEMENT pPropEle;

                fIsProp = TRUE;
                if (NULL == (pPropEle = CreatePropElement(
                        EleHdr.dwEleType,
                        0,                  // dwFlags
                        pbEncoded,
                        EleHdr.dwLen
                        ))) goto CreatePropElementError;

                if (CERT_SHA1_HASH_PROP_ID == EleHdr.dwEleType &&
                        SHA1_HASH_LEN == EleHdr.dwLen)
                    pbSha1Hash = pbEncoded;

                pbEncoded = NULL;
                AddPropElement(&pPropHead, pPropEle);
            }
        }
    } while (fIsProp);

    assert(pPropHead == NULL);
    assert(pbEncoded == NULL);
    assert(pContextEle == NULL);

    csStatus = CSContinue;
CommonReturn:
    return csStatus;
ErrorReturn:
    PkiFree(pbEncoded);
    if (pContextEle)
        FreeContextElement(pContextEle);
    while (pPropHead) {
        PPROP_ELEMENT pEle = pPropHead;
        pPropHead = pPropHead->pNext;
        FreePropElement(pEle);
    }
    csStatus = CSError;
ZeroOutParameterReturn:
    if (pdwContextType)
        *pdwContextType = 0;
    if (ppvContext)
        *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadError)
SET_ERROR(PrematureEndError, CRYPT_E_FILE_ERROR)
SET_ERROR(ExceedReadSizeError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ContextNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateStoreElementError)
TRACE_ERROR(AddStoreElementError)
TRACE_ERROR(CreatePropElementError)
SET_ERROR(KeyIdNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateKeyIdElementError)
SET_ERROR(InvalidPropId, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Add the serialized certificate, CRL or CTL element to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertAddSerializedElementToStore(
    IN HCERTSTORE hCertStore,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN DWORD dwAddDisposition,
    IN DWORD dwFlags,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext
    )
{
    MEMINFO MemInfo;
    DWORD csStatus;
    PCERT_STORE pStore =
        hCertStore ? (PCERT_STORE) hCertStore : &NullCertStore;

    MemInfo.pByte = (BYTE*) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbElement,
        pStore,
        dwAddDisposition,
        dwContextTypeFlags,
        pdwContextType,
        ppvContext);
    if (CSContinue == csStatus)
        return TRUE;
    else {
        if (CSEnd == csStatus)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        return FALSE;
    }
}


//+=========================================================================
//  Store Control APIs
//==========================================================================

STATIC BOOL EnableAutoResync(
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;
    HANDLE hEvent;

    fResult = TRUE;
    hEvent = NULL;
    LockStore(pStore);
    if (NULL == pStore->hAutoResyncEvent) {
        // Create event to be notified
        if (hEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))      // lpszEventName
            pStore->hAutoResyncEvent = hEvent;
        else
            fResult = FALSE;
    }
    UnlockStore(pStore);
    if (!fResult)
        goto CreateEventError;

    if (hEvent) {
        if (!CertControlStore(
                (HCERTSTORE) pStore,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent
                )) {
            DWORD dwErr = GetLastError();

            LockStore(pStore);
            pStore->hAutoResyncEvent = NULL;
            UnlockStore(pStore);
            CloseHandle(hEvent);
            SetLastError(dwErr);
            goto CtrlNotifyChangeError;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEventError)
TRACE_ERROR(CtrlNotifyChangeError)
}

// For a collection, iterates through all the sibling stores. For an error,
// continues on to the remaining stores. LastError is updated with the
// LastError of the first failing store.
STATIC BOOL ControlCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult = TRUE;
    BOOL fOneSiblingSuccess = FALSE;
    DWORD dwError = ERROR_CALL_NOT_IMPLEMENTED;

    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;

    // Iterate through all the siblings and call the control function
    LockStore(pCollection);
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store link
        if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (CertControlStore(
                (HCERTSTORE) pStoreLink->pSibling,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                )) {
            fOneSiblingSuccess = TRUE;
            if (ERROR_CALL_NOT_IMPLEMENTED == dwError)
                fResult = TRUE;
        } else if (ERROR_CALL_NOT_IMPLEMENTED == dwError) {
            dwError = GetLastError();
            if (!fOneSiblingSuccess || ERROR_CALL_NOT_IMPLEMENTED != dwError)
                fResult = FALSE;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);

    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    if (!fResult)
        SetLastError(dwError);
    return fResult;
}

BOOL
WINAPI
CertControlStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    PFN_CERT_STORE_PROV_CONTROL pfnStoreProvControl;

    if (CERT_STORE_CTRL_AUTO_RESYNC == dwCtrlType)
        return EnableAutoResync(pStore);

    if (STORE_TYPE_COLLECTION == pStore->dwStoreType)
        return ControlCollectionStore(
            pStore,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            );

    // Check if the store supports the control callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            CERT_STORE_PROV_CONTROL_FUNC  ||
        NULL == (pfnStoreProvControl = (PFN_CERT_STORE_PROV_CONTROL)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                CERT_STORE_PROV_CONTROL_FUNC]))
        goto ProvControlNotSupported;

    // The caller is holding a reference count on the store.
    if (!pfnStoreProvControl(
            pStore->StoreProvInfo.hStoreProv,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            ))
        goto StoreProvControlError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ProvControlNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(StoreProvControlError)
}

//+=========================================================================
//  Store Collection APIs
//==========================================================================

BOOL
WINAPI
CertAddStoreToCollection(
    IN HCERTSTORE hCollectionStore,
    IN OPTIONAL HCERTSTORE hSiblingStore,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    BOOL fResult;
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;

    PCERT_STORE_LINK pAddLink = NULL;

    LockStore(pCollection);
    if (STORE_TYPE_COLLECTION == pCollection->dwStoreType)
        fResult = TRUE;
    else if (STORE_TYPE_CACHE == pCollection->dwStoreType &&
            STORE_STATE_OPENING == pCollection->dwState &&
            IsEmptyStore(pCollection)) {
        pCollection->dwStoreType = STORE_TYPE_COLLECTION;
        fResult = TRUE;
    } else
        fResult = FALSE;
    UnlockStore(pCollection);
    if (!fResult)
        goto InvalidCollectionStore;
    if (NULL == hSiblingStore)
        goto CommonReturn;

    // Create a link to the store to be added. It duplicates pSibling.
    if (NULL == (pAddLink = CreateStoreLink(
            pCollection,
            pSibling,
            dwUpdateFlags,
            dwPriority)))
        goto CreateStoreLinkError;

    LockStore(pCollection);

    if (NULL == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pAddLink;
    else {
        PCERT_STORE_LINK pLink;

        pLink = pCollection->pStoreListHead;
        if (dwPriority > pLink->dwPriority) {
            // Insert at beginning before first link
            pAddLink->pNext = pLink;
            pLink->pPrev = pAddLink;
            pCollection->pStoreListHead = pAddLink;
        } else {
            // Insert after the link whose next link has
            // lower priority or insert after the last link
            while (pLink->pNext && dwPriority <= pLink->pNext->dwPriority)
                pLink = pLink->pNext;

            pAddLink->pPrev = pLink;
            pAddLink->pNext = pLink->pNext;
            if (pLink->pNext)
                pLink->pNext->pPrev = pAddLink;
            pLink->pNext = pAddLink;
        }
    }

    UnlockStore(pCollection);
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCollectionStore, E_INVALIDARG)
TRACE_ERROR(CreateStoreLinkError)
}

void
WINAPI
CertRemoveStoreFromCollection(
    IN HCERTSTORE hCollectionStore,
    IN HCERTSTORE hSiblingStore
    )
{
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;
    PCERT_STORE_LINK pLink;

    LockStore(pCollection);
    assert(STORE_TYPE_COLLECTION == pCollection->dwStoreType);
    pLink = pCollection->pStoreListHead;
    for (; pLink; pLink = pLink->pNext) {
        if (pSibling == pLink->pSibling &&
                0 == (pLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            // Remove the collection's reference
            pLink->dwFlags |= STORE_LINK_DELETED_FLAG;

            UnlockStore(pCollection);
            ReleaseStoreLink(pLink);
            return;
        }
    }

    UnlockStore(pCollection);
}

//+=========================================================================
//  Cert Store Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    LockStore(pStore);

    fResult = SetCallerProperty(
        &pStore->pPropHead,
        dwPropId,
        dwFlags,
        pvData
        );

    UnlockStore(pStore);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;
        DWORD cbIn;

        dwAccessStateFlags = 0;
        if (0 == (pStore->dwFlags & CERT_STORE_READONLY_FLAG) &&
                0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
        {
            if (STORE_TYPE_COLLECTION == pStore->dwStoreType) {
                // If all its children are READONLY, then NO WRITE_PERSIST

                PCERT_STORE_LINK pStoreLink;
                PCERT_STORE_LINK pPrevStoreLink = NULL;
                LockStore(pStore);
                for (pStoreLink = pStore->pStoreListHead;
                                pStoreLink; pStoreLink = pStoreLink->pNext) {

                    DWORD dwSiblingAccessStateFlags;
                    DWORD cbSiblingData;

                    // Advance past deleted store link
                    if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
                        continue;

                    AddRefStoreLink(pStoreLink);
                    UnlockStore(pStore);
                    if (pPrevStoreLink)
                        ReleaseStoreLink(pPrevStoreLink);
                    pPrevStoreLink = pStoreLink;

                    dwSiblingAccessStateFlags = 0;
                    cbSiblingData = sizeof(dwSiblingAccessStateFlags);
                    CertGetStoreProperty(
                        (HCERTSTORE) pStoreLink->pSibling,
                        CERT_ACCESS_STATE_PROP_ID,
                        &dwSiblingAccessStateFlags,
                        &cbSiblingData
                        );
                    LockStore(pStore);

                    if (dwSiblingAccessStateFlags &
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG) {
                        dwAccessStateFlags =
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
                        break;
                    }
                }
                UnlockStore(pStore);
                if (pPrevStoreLink)
                    ReleaseStoreLink(pPrevStoreLink);
            } else
                dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG)
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        fResult = TRUE;
        if (pvData == NULL)
            cbIn = 0;
        else
            cbIn = *pcbData;
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        *pcbData = sizeof(DWORD);
        return fResult;
    }

    LockStore(pStore);

    fResult = GetCallerProperty(
        pStore->pPropHead,
        dwPropId,
        FALSE,                  // fAlloc
        pvData,
        pcbData
        );

    UnlockStore(pStore);
    return fResult;
}

//+=========================================================================
//  Certificate APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCertificateToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        dwAddDisposition,
        ppCertContext ? &pStoreEle : NULL
        );
    if (ppCertContext)
        *ppCertContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        pCertContext->dwCertEncodingType,
        pCertContext->pbCertEncoded,
        pCertContext->cbCertEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certificate context's encoded certificate and its
//  properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCertificateStoreElement(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCertContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified certificate from the store.
//
//  All subsequent gets or finds for the certificate will fail. However,
//  memory allocated for the certificate isn't freed until all of its contexts
//  have also been freed.
//
//  The pCertContext is obtained from a get, find or duplicate.
//
//  Some store provider implementations might also delete the issuer's CRLs
//  if this is the last certificate for the issuer in the store.
//
//  NOTE: the pCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCertificateFromStore(
    IN PCCERT_CONTEXT pCertContext
    )
{
    assert(NULL == pCertContext || (CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
        ToContextElement(pCertContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCertContext));
}

//+-------------------------------------------------------------------------
//  Get the subject certificate context uniquely identified by its Issuer and
//  SerialNumber from the store.
//
//  If the certificate isn't found, NULL is returned. Otherwise, a pointer to
//  a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling
//  CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a
//  duplicate.
//
//  The returned certificate might not be valid. Normally, it would be
//  verified when getting its issuer certificate (CertGetIssuerCertificateFromStore).
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetSubjectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    if (pCertId == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType,
    FindInfo.dwFindFlags = 0;
    FindInfo.dwFindType = CERT_FIND_SUBJECT_CERT;
    FindInfo.pvFindPara = pCertId;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        NULL                                // pPrevEle
        ));
}

//+-------------------------------------------------------------------------
//  Enumerate the certificate contexts in the store.
//
//  If a certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL to enumerate the first
//  certificate in the store. Successive certificates are enumerated by setting
//  pPrevCertContext to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCertContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next certificate context in the store.
//
//  The certificate is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR or
//  CERT_FIND_ISSUER_ATTR. Otherwise, must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL on the first
//  call to find the certificate. To find the next certificate, the
//  pPrevCertContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCertContext)
        ));
}

//+-------------------------------------------------------------------------
//  Perform the revocation check on the subject certificate
//  using the issuer certificate and store
//--------------------------------------------------------------------------
STATIC void VerifySubjectCertRevocation(
    IN PCCERT_CONTEXT pSubject,
    IN PCCERT_CONTEXT pIssuer,
    IN HCERTSTORE hIssuerStore,
    IN OUT DWORD *pdwFlags
    )
{

    PCCRL_CONTEXT rgpCrlContext[MAX_CRL_LIST];
    PCRL_INFO rgpCrlInfo[MAX_CRL_LIST];
    PCCRL_CONTEXT pCrlContext = NULL;
    DWORD cCrl = 0;

    assert(pIssuer && hIssuerStore);
    assert(*pdwFlags & CERT_STORE_REVOCATION_FLAG);

    while (TRUE) {
        DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCrlContext = CertGetCRLFromStore(
            hIssuerStore,
            pIssuer,
            pCrlContext,
            &dwFlags
            );

        if (pCrlContext == NULL) break;
        if (cCrl == MAX_CRL_LIST) {
            assert(cCrl > MAX_CRL_LIST);
            CertFreeCRLContext(pCrlContext);
            break;
        }

        if (dwFlags == 0) {
            rgpCrlContext[cCrl] = CertDuplicateCRLContext(pCrlContext);
            rgpCrlInfo[cCrl] = pCrlContext->pCrlInfo;
            cCrl++;
        } else {
            // Need to log or remove a bad CRL from the store
            ;
        }
    }
    if (cCrl == 0)
        *pdwFlags |= CERT_STORE_NO_CRL_FLAG;
    else {
        if (CertVerifyCRLRevocation(
                pSubject->dwCertEncodingType,
                pSubject->pCertInfo,
                cCrl,
                rgpCrlInfo
                ))
            *pdwFlags &= ~CERT_STORE_REVOCATION_FLAG;

        while (cCrl--)
            CertFreeCRLContext(rgpCrlContext[cCrl]);
    }
}

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify certificate signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    );
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer
//--------------------------------------------------------------------------
STATIC void VerifySubjectCert(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyTimeValidity(NULL,
                pSubject->pCertInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG |
                         CERT_STORE_REVOCATION_FLAG))
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#if 0
        // Slow down the provider while holding the provider reference
        // count
        Sleep(1700);
#endif

#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pSubject->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubject,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pSubject->dwCertEncodingType,
                pSubject->pbCertEncoded,
                pSubject->cbCertEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;

        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }

    if (*pdwFlags & CERT_STORE_REVOCATION_FLAG) {
        *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;

        VerifySubjectCertRevocation(
            pSubject,
            pIssuer,
            pIssuer->hCertStore,
            pdwFlags
            );

        if (*pdwFlags & CERT_STORE_NO_CRL_FLAG) {
            PCONTEXT_ELEMENT pIssuerEle = ToContextElement(pIssuer);

            if (ELEMENT_TYPE_LINK_CONTEXT == pIssuerEle->dwElementType) {
                // Skip past the link elements. A store containing a link
                // may not have any CRLs. Try the store containing the
                // real issuer element.

                DWORD dwInnerDepth = 0;
                for ( ; ELEMENT_TYPE_LINK_CONTEXT ==
                             pIssuerEle->dwElementType;
                                            pIssuerEle = pIssuerEle->pEle) {
                    dwInnerDepth++;
                    assert(dwInnerDepth <= MAX_LINK_DEPTH);
                    assert(pIssuerEle != pIssuerEle->pEle);
                    if (dwInnerDepth > MAX_LINK_DEPTH)
                        break;
                }
                if ((HCERTSTORE) pIssuerEle->pStore != pIssuer->hCertStore) {
                    *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;
                    VerifySubjectCertRevocation(
                        pSubject,
                        pIssuer,
                        (HCERTSTORE) pIssuerEle->pStore,
                        pdwFlags
                        );
                }
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Get the certificate context from the store for the first or next issuer
//  of the specified subject certificate. Perform the enabled
//  verification checks on the subject. (Note, the checks are on the subject
//  using the returned issuer certificate.)
//
//  If the first or next issuer certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  The pSubjectContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  An issuer may have multiple certificates. This may occur when the validity
//  period is about to change. pPrevIssuerContext MUST BE NULL on the first
//  call to get the issuer. To get the next certificate for the issuer, the
//  pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the subject certificate context:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the returned
//                                      issuer certificate to verify the
//                                      signature on the subject certificate.
//                                      Note, if pSubjectContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the subject certificate's
//                                      validity period
//      CERT_STORE_REVOCATION_FLAG    - check if the subject certificate is on
//                                      the issuer's revocation list
//
//  If an enabled verification check fails, then, its flag is set upon return.
//  If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a
//  CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to
//  the CERT_STORE_REVOCATION_FLAG.
//
//  If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then,
//  CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate
//  in the store.
//
//  For a verification check failure, a pointer to the issuer's CERT_CONTEXT
//  is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    )
{
    PCCERT_CONTEXT pIssuerContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG))
        goto InvalidArg;

    // Check if self signed certificate, issuer == subject
    if (CertCompareCertificateName(
            pSubjectContext->dwCertEncodingType,
            &pSubjectContext->pCertInfo->Subject,
            &pSubjectContext->pCertInfo->Issuer
            )) {
        VerifySubjectCert(
            pSubjectContext,
            pSubjectContext,
            pdwFlags
            );
        SetLastError((DWORD) CRYPT_E_SELF_SIGNED);
        goto ErrorReturn;
    } else {
        CERT_STORE_PROV_FIND_INFO FindInfo;
        FindInfo.cbSize = sizeof(FindInfo);
        FindInfo.dwMsgAndCertEncodingType = pSubjectContext->dwCertEncodingType;
        FindInfo.dwFindFlags = 0;
        FindInfo.dwFindType = CERT_FIND_ISSUER_OF;
        FindInfo.pvFindPara = pSubjectContext;

        if (pIssuerContext = ToCertContext(CheckAutoResyncAndFindElementInStore(
                (PCERT_STORE) hCertStore,
                CERT_STORE_CERTIFICATE_CONTEXT - 1,
                &FindInfo,
                ToContextElement(pPrevIssuerContext)
                )))
            VerifySubjectCert(
                pSubjectContext,
                pIssuerContext,
                pdwFlags
                );
    }

CommonReturn:
    return pIssuerContext;

ErrorReturn:
    if (pPrevIssuerContext)
        CertFreeCertificateContext(pPrevIssuerContext);
    pIssuerContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer. Same checks and flags definitions as for the above
//  CertGetIssuerCertificateFromStore.
//
//  For a verification check failure, SUCCESS is still returned.
//
//  pIssuer must come from a store that is still open.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }
    if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG | CERT_STORE_REVOCATION_FLAG)) {
        if (pIssuer == NULL) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
    }

    VerifySubjectCert(
        pSubject,
        pIssuer,
        pdwFlags
        );
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Duplicate a certificate context
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        AddRefContextElement(ToContextElement(pCertContext));
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Create a certificate context from the encoded certificate. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded certificate in the created context.
//
//  If unable to decode and create the certificate context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned.
//  CERT_CONTEXT must be freed by calling CertFreeCertificateContext.
//  CertDuplicateCertificateContext can be called to make a duplicate.
//
//  CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called
//  to store properties for the certificate.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    PCCERT_CONTEXT pCertContext;

    CertAddEncodedCertificateToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCertContext
        );
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Free a certificate context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, find, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    ReleaseContextElement(ToContextElement(pCertContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified certificate context.
//
//  If the certificate context was obtained from a store, then, the property
//  is added to the store.
//
//  The type definition for pvData depends on the dwPropId value. There are
//  three predefined types:
//      CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's
//      private key is passed in pvData. If the
//      CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly
//      released when either the property is set to NULL or on the final
//      free of the CertContext.
//
//      CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's
//      private key is passed in pvData.
//
//      CERT_SHA1_HASH_PROP_ID       -
//      CERT_MD5_HASH_PROP_ID        -
//      CERT_SIGNATURE_HASH_PROP_ID  - normally, a hash property is implicitly
//      set by doing a CertGetCertificateContextProperty. pvData points to a
//      CRYPT_HASH_BLOB.
//
//  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
//
//  If the property already exists, then, the old value is deleted and silently
//  replaced. Setting, pvData to NULL, deletes the property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCertContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified certificate context.
//
//  For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV.
//
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure.
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashCertificate()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//  MD5.
//
//  For CERT_SIGNATURE_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashToBeSigned()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//
//  For all other PROP_IDs, pvData points to an encoded array of bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCertContext),
            dwPropId,
            pvData,
            pcbData
            );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified certificate context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCertificateContextProperties(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCertContext),
        dwPropId
        );
}


//+=========================================================================
//  CRL APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCRLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppCrlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        dwAddDisposition,
        ppCrlContext ? &pStoreEle : NULL
        );
    if (ppCrlContext)
        *ppCrlContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        pCrlContext->dwCertEncodingType,
        pCrlContext->pbCrlEncoded,
        pCrlContext->cbCrlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CRL context's encoded CRL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCRLStoreElement(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCrlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CRL from the store.
//
//  All subsequent gets for the CRL will fail. However,
//  memory allocated for the CRL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCrlContext is obtained from a get or duplicate.
//
//  NOTE: the pCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCRLFromStore(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    assert(NULL == pCrlContext || (CERT_STORE_CRL_CONTEXT - 1) ==
        ToContextElement(pCrlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCrlContext));
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the CRL using the issuer
//--------------------------------------------------------------------------
STATIC void VerifyCrl(
    IN PCCRL_CONTEXT pCrl,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyCRLTimeValidity(NULL,
                pCrl->pCrlInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (*pdwFlags & (CERT_STORE_BASE_CRL_FLAG | CERT_STORE_DELTA_CRL_FLAG)) {
        PCERT_EXTENSION pDeltaExt;

        pDeltaExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );

        if (*pdwFlags & CERT_STORE_DELTA_CRL_FLAG) {
            if (NULL != pDeltaExt)
                *pdwFlags &= ~CERT_STORE_DELTA_CRL_FLAG;
        }

        if (*pdwFlags & CERT_STORE_BASE_CRL_FLAG) {
            if (NULL == pDeltaExt)
                *pdwFlags &= ~CERT_STORE_BASE_CRL_FLAG;
        }
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG)
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pCrl->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL,
                (void *) pCrl,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pCrl->dwCertEncodingType,
                pCrl->pbCrlEncoded,
                pCrl->cbCrlEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;
        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }
}

//+-------------------------------------------------------------------------
//  Get the first or next CRL context from the store for the specified
//  issuer certificate. Perform the enabled verification checks on the CRL.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  The pIssuerContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  If pIssuerContext == NULL, finds all the CRLs in the store.
//
//  An issuer may have multiple CRLs. For example, it generates delta CRLs
//  using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first
//  call to get the CRL. To get the next CRL for the issuer, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the returned CRL:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the
//                                      issuer's certificate to verify the
//                                      signature on the returned CRL.
//                                      Note, if pIssuerContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the CRL's ThisUpdate and
//                                      NextUpdate validity period.
//      CERT_STORE_BASE_CRL_FLAG      - get base CRL. 
//      CERT_STORE_DELTA_CRL_FLAG     - get delta CRL.
//
//  If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is
//  set, then, only returns either a base or delta CRL. In any case, the
//  appropriate base or delta flag will be cleared upon returned. If both
//  flags are set, then, only one of flags will be cleared.
//
//  If an enabled verification check fails, then, its flag is set upon return.
//
//  If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG
//  always fails and the CERT_STORE_NO_ISSUER_FLAG is also set.
//
//  For a verification check failure, a pointer to the first or next
//  CRL_CONTEXT is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertGetCRLFromStore(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL PCCERT_CONTEXT pIssuerContext,
    IN PCCRL_CONTEXT pPrevCrlContext,
    IN OUT DWORD *pdwFlags
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;
    DWORD dwMsgAndCertEncodingType;
    PCCRL_CONTEXT pCrlContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG     |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_BASE_CRL_FLAG      |
                      CERT_STORE_DELTA_CRL_FLAG))
        goto InvalidArg;

    if (NULL == pIssuerContext)
        dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    else
        dwMsgAndCertEncodingType = pIssuerContext->dwCertEncodingType;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwMsgAndCertEncodingType;

    FindInfo.dwFindFlags = 0;
    if (*pdwFlags & CERT_STORE_BASE_CRL_FLAG)
        FindInfo.dwFindFlags |= CRL_FIND_ISSUED_BY_BASE_FLAG;
    if (*pdwFlags & CERT_STORE_DELTA_CRL_FLAG)
        FindInfo.dwFindFlags |= CRL_FIND_ISSUED_BY_DELTA_FLAG;

    FindInfo.dwFindType = CRL_FIND_ISSUED_BY;
    FindInfo.pvFindPara = pIssuerContext;

    if (pCrlContext = ToCrlContext(CheckAutoResyncAndFindElementInStore(
            (PCERT_STORE) hCertStore,
            CERT_STORE_CRL_CONTEXT - 1,
            &FindInfo,
            ToContextElement(pPrevCrlContext)
            )))
        VerifyCrl(
            pCrlContext,
            pIssuerContext,
            pdwFlags
            );

CommonReturn:
    return pCrlContext;

ErrorReturn:
    if (pPrevCrlContext)
        CertFreeCRLContext(pPrevCrlContext);
    pCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Enumerate the CRL contexts in the store.
//
//  If a CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL to enumerate the first
//  CRL in the store. Successive CRLs are enumerated by setting
//  pPrevCrlContext to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertEnumCRLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next CRL context in the store.
//
//  The CRL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL on the first
//  call to find the CRL. To find the next CRL, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertFindCRLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Duplicate a CRL context
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertDuplicateCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        AddRefContextElement(ToContextElement(pCrlContext));
    return pCrlContext;
}

//+-------------------------------------------------------------------------
//  Create a CRL context from the encoded CRL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CRL in the created context.
//
//  If unable to decode and create the CRL context, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned.
//  CRL_CONTEXT must be freed by calling CertFreeCRLContext.
//  CertDuplicateCRLContext can be called to make a duplicate.
//
//  CertSetCRLContextProperty and CertGetCRLContextProperty can be called
//  to store properties for the CRL.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertCreateCRLContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded
    )
{
    PCCRL_CONTEXT pCrlContext;

    CertAddEncodedCRLToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCrlContext
        );
    return pCrlContext;
}


//+-------------------------------------------------------------------------
//  Free a CRL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    ReleaseContextElement(ToContextElement(pCrlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID, CERT_MD5_HASH_PROP_ID or
//  CERT_SIGNATURE_HASH_PROP_ID is the predefined property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CRL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCRLContextProperties(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCrlContext),
        dwPropId
        );
}

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  Compare's the CRL entry's serial numbers. Note, since we won't be adding
//  any entries, don't need to worry about leading 0's or ff's. Also, ASN.1
//  decoding should have removed them.
//
//  The elements being sorted are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCRL_ENTRY p1 = *((PCRL_ENTRY *) pelem1);
    PCRL_ENTRY p2 = *((PCRL_ENTRY *) pelem2);

    DWORD cb1 = p1->SerialNumber.cbData;
    DWORD cb2 = p2->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SerialNumber.pbData, p2->SerialNumber.pbData,
                cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch.
//
//  Compare's the key's serial number with the CRL entry's serial number
//
//  The elements being searched are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntrySerialNumber(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_INTEGER_BLOB pSerialNumber = (PCRYPT_INTEGER_BLOB) pkey;
    PCRL_ENTRY pCrlEntry = *((PCRL_ENTRY *) pvalue);

    DWORD cb1 = pSerialNumber->cbData;
    DWORD cb2 = pCrlEntry->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSerialNumber->pbData,
                pCrlEntry->SerialNumber.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Search the CRL's list of entries for the specified certificate.
//
//  TRUE is returned if we were able to search the list. Otherwise, FALSE is
//  returned,
//
//  For success, if the certificate was found in the list, *ppCrlEntry is
//  updated with a pointer to the entry. Otherwise, *ppCrlEntry is set to NULL.
//  The returned entry isn't allocated and must not be freed.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 or NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindCertificateInCRL(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT PCRL_ENTRY *ppCrlEntry
    )
{
    BOOL fResult;
    PCRL_INFO pInfo = pCrlContext->pCrlInfo;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCRL_ENTRY *ppSortedEntry;
    DWORD cEntry;
    PCRL_ENTRY *ppFoundEntry;

    *ppCrlEntry = NULL;

    // Get qsorted pointers to the CRL Entries
    if (0 == (cEntry = pInfo->cCRLEntry))
        goto SuccessReturn;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCrlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCrlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCRL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCRL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCRL_ENTRY p = pInfo->rgCRLEntry;
            PCRL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the CRL entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCRL_ENTRY), CompareCrlEntry);

            ToCrlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (ppFoundEntry = (PCRL_ENTRY *) bsearch(&pCert->pCertInfo->SerialNumber,
            ppSortedEntry, cEntry, sizeof(PCRL_ENTRY),
                CompareCrlEntrySerialNumber))
        *ppCrlEntry = *ppFoundEntry;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppCrlEntry = (PCRL_ENTRY) 1;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(OutOfMemory)
}


//+=========================================================================
//  CTL APIs
//==========================================================================
BOOL
WINAPI
CertAddEncodedCTLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppCtlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        dwAddDisposition,
        ppCtlContext ? &pStoreEle : NULL
        );
    if (ppCtlContext)
        *ppCtlContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        pCtlContext->dwMsgAndCertEncodingType,
        pCtlContext->pbCtlEncoded,
        pCtlContext->cbCtlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CTL context's encoded CTL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCTLStoreElement(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCtlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CTL from the store.
//
//  All subsequent gets for the CTL will fail. However,
//  memory allocated for the CTL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCtlContext is obtained from a get or duplicate.
//
//  NOTE: the pCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCTLFromStore(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    assert(NULL == pCtlContext || (CERT_STORE_CTL_CONTEXT - 1) ==
        ToContextElement(pCtlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCtlContext));
}

//+-------------------------------------------------------------------------
//  Duplicate a CTL context
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        AddRefContextElement(ToContextElement(pCtlContext));
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Create a CTL context from the encoded CTL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CTL in the created context.
//
//  If unable to decode and create the CTL context, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned.
//  CTL_CONTEXT must be freed by calling CertFreeCTLContext.
//  CertDuplicateCTLContext can be called to make a duplicate.
//
//  CertSetCTLContextProperty and CertGetCTLContextProperty can be called
//  to store properties for the CTL.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    PCCTL_CONTEXT pCtlContext;

    CertAddEncodedCTLToStore(
        NULL,                   // hCertStore
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCtlContext
        );
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Free a CTL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    ReleaseContextElement(ToContextElement(pCtlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID is the predefined
//  property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CTL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCTLContextProperties(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCtlContext),
        dwPropId
        );
}


//+-------------------------------------------------------------------------
//  Enumerate the CTL contexts in the store.
//
//  If a CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL to enumerate the first
//  CTL in the store. Successive CTLs are enumerated by setting
//  pPrevCtlContext to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertEnumCTLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCtlContext)
        ));
}

STATIC BOOL CompareAlgorithmIdentifier(
    IN DWORD dwEncodingType,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg1,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg2
    )
{
    BOOL fResult = FALSE;
    if (NULL == pAlg1->pszObjId) {
        if (NULL == pAlg2->pszObjId)
            // Both are NULL
            fResult = TRUE;
        // else
        //  One of the OIDs is NULL
    } else if (pAlg2->pszObjId) {
        if (0 == strcmp(pAlg1->pszObjId, pAlg2->pszObjId)) {
            DWORD cb1 = pAlg1->Parameters.cbData;
            BYTE *pb1 = pAlg1->Parameters.pbData;
            DWORD cb2 = pAlg2->Parameters.cbData;
            BYTE *pb2 = pAlg2->Parameters.pbData;

            if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwEncodingType)) {
                // Check for NULL parameters: {0x05, 0x00}
                if (2 == cb1 && 0x05 == pb1[0] && 0x00 == pb1[1])
                    cb1 = 0;
                if (2 == cb2 && 0x05 == pb2[0] && 0x00 == pb2[1])
                    cb2 = 0;
            }
            if (cb1 == cb2) {
                if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
                    fResult = TRUE;
            }
        }
    }
    // else
    //  One of the OIDs is NULL
    return fResult;
}

//+-------------------------------------------------------------------------
//  Called by qsort. Compare's the CTL entry's SubjectIdentifier.
//
//  The elements being sorted are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCTL_ENTRY p1 = *((PCTL_ENTRY *) pelem1);
    PCTL_ENTRY p2 = *((PCTL_ENTRY *) pelem2);

    DWORD cb1 = p1->SubjectIdentifier.cbData;
    DWORD cb2 = p2->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SubjectIdentifier.pbData,
                p2->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch. Compare's the key's SubjectIdentifier with the CTL
//  entry's SubjectIdentifier.
//
//  The elements being searched are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntrySubjectIdentifier(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_DATA_BLOB pSubjectIdentifier = (PCRYPT_DATA_BLOB) pkey;
    PCTL_ENTRY pCtlEntry = *((PCTL_ENTRY *) pvalue);

    DWORD cb1 = pSubjectIdentifier->cbData;
    DWORD cb2 = pCtlEntry->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSubjectIdentifier->pbData,
                pCtlEntry->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified subject in the CTL.
//
//  For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's
//  SubjectAlgorithm is examined to determine the representation of the
//  subject's identity. Initially, only SHA1 or MD5 hash will be supported.
//  The appropriate hash property is obtained from the CERT_CONTEXT.
//
//  For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO
//  structure which contains the SubjectAlgorithm to be matched in the CTL
//  and the SubjectIdentifer to be matched in one of the CTL entries.
//
//  The cetificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier
//  is used as the key in searching the subject entries. A binary
//  memory comparison is done between the key and the entry's SubjectIdentifer.
//
//  dwEncodingType isn't used for either of the above SubjectTypes.
//--------------------------------------------------------------------------
PCTL_ENTRY
WINAPI
CertFindSubjectInCTL(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags
    )
{
    PCTL_ENTRY *ppSubjectEntry;
    PCTL_ENTRY pSubjectEntry;
    PCTL_INFO pInfo = pCtlContext->pCtlInfo;

    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB Key;
    PCTL_ENTRY *ppSortedEntry;
    DWORD cEntry;

    // Get Key to be used in bsearch
    switch (dwSubjectType) {
        case CTL_CERT_SUBJECT_TYPE:
            {
                DWORD Algid;
                DWORD dwPropId;

                if (NULL == pInfo->SubjectAlgorithm.pszObjId)
                    goto NoSubjectAlgorithm;
                Algid = CertOIDToAlgId(pInfo->SubjectAlgorithm.pszObjId);
                switch (Algid) {
                    case CALG_SHA1:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CALG_MD5:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                        break;
                    default:
                        goto UnknownAlgid;
                }

                Key.cbData = MAX_HASH_LEN;
                if (!CertGetCertificateContextProperty(
                        (PCCERT_CONTEXT) pvSubject,
                        dwPropId,
                        rgbHash,
                        &Key.cbData) || 0 == Key.cbData)
                    goto GetHashError;
                Key.pbData = rgbHash;
            }
            break;
        case CTL_ANY_SUBJECT_TYPE:
            {
                PCTL_ANY_SUBJECT_INFO pAnyInfo =
                    (PCTL_ANY_SUBJECT_INFO) pvSubject;
                if (pAnyInfo->SubjectAlgorithm.pszObjId &&
                        !CompareAlgorithmIdentifier(
                            (pCtlContext->dwMsgAndCertEncodingType >> 16) &
                                CERT_ENCODING_TYPE_MASK,
                            &pAnyInfo->SubjectAlgorithm,
                            &pInfo->SubjectAlgorithm))
                    goto NotFoundError;

                Key = pAnyInfo->SubjectIdentifier;
            }
            break;
        default:
            goto InvalidSubjectType;
    }


    // Get qsorted pointers to the Subject Entries
    if (0 == (cEntry = pInfo->cCTLEntry))
        goto NoEntryError;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCtlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCTL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCTL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCTL_ENTRY p = pInfo->rgCTLEntry;
            PCTL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the subject entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCTL_ENTRY), CompareCtlEntry);

            ToCtlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (NULL == (ppSubjectEntry = (PCTL_ENTRY *) bsearch(&Key,
            ppSortedEntry, cEntry, sizeof(PCTL_ENTRY),
            CompareCtlEntrySubjectIdentifier)))
        goto NotFoundError;
    pSubjectEntry = *ppSubjectEntry;

CommonReturn:
    return pSubjectEntry;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    pSubjectEntry = NULL;
    goto CommonReturn;

SET_ERROR(NoSubjectAlgorithm, CRYPT_E_NOT_FOUND)
SET_ERROR(UnknownAlgid, NTE_BAD_ALGID)
SET_ERROR(NoEntryError, CRYPT_E_NOT_FOUND)
TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(GetHashError)
SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Find the first or next CTL context in the store.
//
//  The CTL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwMsgAndCertEncodingType depends on the dwFindType.
//
//  If the first or next CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL on the first
//  call to find the CTL. To find the next CTL, the
//  pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwMsgAndCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCtlContext)
        ));
}




//+=========================================================================
//  CERT_CONTEXT Functions
//==========================================================================

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCERT_CONTEXT pCert;
    PCERT_INFO pInfo = NULL;


    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == pShareEle) {
        cbCertEncoded = AdjustEncodedLength(
            dwCertEncodingType, pbCertEncoded, cbCertEncoded);

        if (NULL == (pInfo = (PCERT_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_CERT_TO_BE_SIGNED,
                pbCertEncoded,
                cbCertEncoded))) goto ErrorReturn;
    }

    // Allocate and initialize the cert element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CERT_CONTEXT));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCert = (PCERT_CONTEXT) ToCertContext(pEle);
    pCert->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCert->pbCertEncoded = pbCertEncoded;
    pCert->cbCertEncoded = cbCertEncoded;
    if (pShareEle) {
        pEle->pShareEle = pShareEle;
        assert(pShareEle->pvInfo);
        pCert->pCertInfo = (PCERT_INFO) pShareEle->pvInfo;
        assert(pbCertEncoded == pShareEle->pbEncoded);
        assert(cbCertEncoded == pShareEle->cbEncoded);
    } else {
        pCert->pCertInfo = pInfo;

        CertPerfIncrementCertElementCurrentCount();
        CertPerfIncrementCertElementTotalCount();
    }
    pCert->hCertStore = (HCERTSTORE) pStore;

CommonReturn:
    return pEle;
ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCert->pbCertEncoded);
        PkiFree(pCert->pCertInfo);

        CertPerfDecrementCertElementCurrentCount();
    }
    PkiFree(pEle);
}

STATIC BOOL CompareCertHash(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCertificateContextProperty(
        pCert,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareNameStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCWSTR pwszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cwszFind;
    LPWSTR pwszName = NULL;
    DWORD cwszName;

    if (pwszFind == NULL || *pwszFind == L'\0')
        return TRUE;

    cwszName = CertNameToStrW(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwszName = (LPWSTR) PkiNonzeroAlloc(cwszName * sizeof(WCHAR))) {
        cwszName = CertNameToStrW(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pwszName,
            cwszName) - 1;
        cwszFind = wcslen(pwszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cwszName >= cwszFind; cwszName--) {
            pwszName[cwszName] = L'\0';
            if (CSTR_EQUAL == CompareStringU(
                    LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE,
                    pwszFind,
                    -1,
                    &pwszName[cwszName - cwszFind],
                    -1
                    )) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pwszName);
    }
    return fResult;
}

STATIC BOOL CompareNameStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCSTR pszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cszFind;
    LPSTR pszName = NULL;
    DWORD cszName;

    if (pszFind == NULL || *pszFind == '\0')
        return TRUE;

    cszName = CertNameToStrA(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // psz
        0                       // csz
        );
    if (pszName = (LPSTR) PkiNonzeroAlloc(cszName)) {
        cszName = CertNameToStrA(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pszName,
            cszName) - 1;
        cszFind = strlen(pszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cszName >= cszFind; cszName--) {
            pszName[cszName] = '\0';
            if (CSTR_EQUAL == CompareStringA(
                    LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE,
                    pszFind,
                    -1,
                    &pszName[cszName - cszFind],
                    -1
                    )) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pszName);
    }
    return fResult;
}

STATIC BOOL CompareCtlUsageIdentifiers(
    IN PCTL_USAGE pPara,
    IN DWORD cUsage,
    IN PCTL_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    if (pPara && pPara->cUsageIdentifier) {
        DWORD cId1 = pPara->cUsageIdentifier;
        LPSTR *ppszId1 = pPara->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD i;
            for (i = 0; i < cUsage; i++) {
                DWORD cId2 = pUsage[i].cUsageIdentifier;
                LPSTR *ppszId2 = pUsage[i].rgpszUsageIdentifier;
                for ( ; cId2 > 0; cId2--, ppszId2++) {
                    if (0 == strcmp(*ppszId1, *ppszId2)) {
                        if (fOrUsage)
                            return TRUE;
                        break;
                    }
                }
                if (cId2 > 0)
                    break;
            }
            if (i == cUsage && !fOrUsage)
                return FALSE;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            return FALSE;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }
    return TRUE;
}

STATIC BOOL CompareCertUsage(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindFlags,
    IN PCTL_USAGE pPara
    )
{
    BOOL fResult;
    PCERT_INFO pInfo = pCert->pCertInfo;
    PCERT_EXTENSION pExt;       // not allocated
    DWORD cbData;

    PCTL_USAGE pExtUsage = NULL;
    PCTL_USAGE pPropUsage = NULL;
    BYTE *pbPropData = NULL;

    CTL_USAGE rgUsage[2];   // Ext and/or Prop
    DWORD cUsage = 0;

    if (CERT_FIND_VALID_CTL_USAGE_FLAG & dwFindFlags)
        return IFC_IsEndCertValidForUsages(
            pCert,
            pPara,
            0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));

    if (0 == (CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage Extension ??
        if (pExt = CertFindExtension(
                szOID_ENHANCED_KEY_USAGE,
                pInfo->cExtension,
                pInfo->rgExtension
                )) {
            if (pExtUsage = (PCTL_USAGE) AllocAndDecodeObject(
                    pCert->dwCertEncodingType,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData))
                rgUsage[cUsage++] = *pExtUsage;
        }
    }

    if (0 == (CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage (CTL Usage) property ??
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_CTL_USAGE_PROP_ID,
                NULL,                       // pvData
                &cbData) && cbData) {
            if (pbPropData = (BYTE *) PkiNonzeroAlloc(cbData)) {
                if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_CTL_USAGE_PROP_ID,
                        pbPropData,
                        &cbData)) {
                    if (pPropUsage = (PCTL_USAGE) AllocAndDecodeObject(
                            pCert->dwCertEncodingType,
                            X509_ENHANCED_KEY_USAGE,
                            pbPropData,
                            cbData))
                        rgUsage[cUsage++] = *pPropUsage;
                }
            }
        }
    }

    if (cUsage > 0) {
        if (dwFindFlags & CERT_FIND_NO_CTL_USAGE_FLAG)
            fResult = FALSE;
        else
            fResult = CompareCtlUsageIdentifiers(pPara, cUsage, rgUsage,
                0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));
    } else if (dwFindFlags & (CERT_FIND_OPTIONAL_CTL_USAGE_FLAG |
            CERT_FIND_NO_CTL_USAGE_FLAG))
        fResult = TRUE;
    else
        fResult = FALSE;

    PkiFree(pExtUsage);
    PkiFree(pPropUsage);
    PkiFree(pbPropData);

    return fResult;
}

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    )
{
    BYTE rgbCertHash[SHA1_HASH_LEN];
    DWORD cbCertHash = SHA1_HASH_LEN;
    BYTE rgbNewHash[SHA1_HASH_LEN];
    DWORD cbNewHash = SHA1_HASH_LEN;

    CertGetCertificateContextProperty(
        pCert,
        CERT_SHA1_HASH_PROP_ID,
        rgbCertHash,
        &cbCertHash
        );

    CertGetCertificateContextProperty(
        pNew,
        CERT_SHA1_HASH_PROP_ID,
        rgbNewHash,
        &cbNewHash
        );

    if (SHA1_HASH_LEN == cbCertHash && SHA1_HASH_LEN == cbNewHash &&
            0 == memcmp(rgbCertHash, rgbNewHash, SHA1_HASH_LEN))
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    DWORD dwCmp = (pFindInfo->dwFindType >> CERT_COMPARE_SHIFT) &
        CERT_COMPARE_MASK;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwCmp) {
            case CERT_COMPARE_SHA1_HASH:
            case CERT_COMPARE_MD5_HASH:
            case CERT_COMPARE_SIGNATURE_HASH:
            case CERT_COMPARE_SUBJECT_CERT:
#ifdef CMS_PKCS7
            case CERT_COMPARE_CERT_ID:
#endif  // CMS_PKCS7
            case CERT_COMPARE_PUBKEY_MD5_HASH:
                break;
            default:
                return FALSE;
        }
    }

    switch (dwCmp) {
        case CERT_COMPARE_ANY:
            return TRUE;
            break;

        case CERT_COMPARE_SHA1_HASH:
        case CERT_COMPARE_MD5_HASH:
        case CERT_COMPARE_SIGNATURE_HASH:
        case CERT_COMPARE_KEY_IDENTIFIER:
        case CERT_COMPARE_PUBKEY_MD5_HASH:
            {
                DWORD dwPropId;
                switch (dwCmp) {
                    case CERT_COMPARE_SHA1_HASH:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_SIGNATURE_HASH:
                        dwPropId = CERT_SIGNATURE_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_KEY_IDENTIFIER:
                        dwPropId = CERT_KEY_IDENTIFIER_PROP_ID;
                        break;
                    case CERT_COMPARE_PUBKEY_MD5_HASH:
                        dwPropId = CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_MD5_HASH:
                    default:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                }
                return CompareCertHash(pCert, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertCompareCertificateName(dwCertEncodingType,
                            pName, (PCERT_NAME_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_ATTR:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertIsRDNAttrsInCertificateName(dwCertEncodingType,
                            pFindInfo->dwFindFlags, pName,
                        (PCERT_RDN) pvFindPara);
            }
            break;

        case CERT_COMPARE_PROPERTY:
            {
                DWORD dwPropId = *((DWORD *) pvFindPara);
                DWORD cbData = 0;
                return CertGetCertificateContextProperty(
                        pCert,
                        dwPropId,
                        NULL,       //pvData
                        &cbData);
            }
            break;

        case CERT_COMPARE_PUBLIC_KEY:
            {
                return CertComparePublicKeyInfo(
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->SubjectPublicKeyInfo,
                        (PCERT_PUBLIC_KEY_INFO) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME_STR_A:
        case CERT_COMPARE_NAME_STR_W:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                if (dwCertEncodingType == pCert->dwCertEncodingType) {
                    if (dwCmp == CERT_COMPARE_NAME_STR_W)
                        return CompareNameStrW(dwCertEncodingType,
                                pName, (LPCWSTR) pvFindPara);
                    else
                        return CompareNameStrA(dwCertEncodingType,
                                pName, (LPCSTR) pvFindPara);
                } else
                    return FALSE;
            }
            break;

        case CERT_COMPARE_KEY_SPEC:
            {
                DWORD dwKeySpec;
                DWORD cbData = sizeof(dwKeySpec);

                return CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_SPEC_PROP_ID,
                            &dwKeySpec,
                            &cbData) &&
                        dwKeySpec == *((DWORD *) pvFindPara);
            }
            break;

        case CERT_COMPARE_CTL_USAGE:
            return CompareCertUsage(pCert, pFindInfo->dwFindFlags,
                (PCTL_USAGE) pvFindPara);
            break;

        case CERT_COMPARE_SUBJECT_CERT:
            {
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;
                PCERT_INFO pCertId = (PCERT_INFO) pvFindPara;
                CRYPT_HASH_BLOB KeyId;

                if (dwCertEncodingType != pCert->dwCertEncodingType)
                    return FALSE;
                if (Asn1UtilExtractKeyIdFromCertInfo(
                        pCertId,
                        &KeyId
                        ))
                    return CompareCertHash(pCert,
                        CERT_KEY_IDENTIFIER_PROP_ID,
                        &KeyId
                        );
                else
                    return CertCompareCertificate(
                        dwCertEncodingType,
                        pCertId,
                        pCert->pCertInfo);
            }
            break;

        case CERT_COMPARE_ISSUER_OF:
            {
                PCCERT_CONTEXT pSubject =
                    (PCCERT_CONTEXT) pvFindPara;
                return pSubject->dwCertEncodingType ==
                        pCert->dwCertEncodingType &&
                    CertCompareCertificateName(
                        pSubject->dwCertEncodingType,
                        &pSubject->pCertInfo->Issuer,
                        &pCert->pCertInfo->Subject);
            }
            break;

        case CERT_COMPARE_EXISTING:
            return IsSameCert((PCCERT_CONTEXT) pvFindPara, pCert);
            break;

#ifdef CMS_PKCS7
        case CERT_COMPARE_CERT_ID:
            {
                PCERT_ID pCertId = (PCERT_ID) pvFindPara;
                switch (pCertId->dwIdChoice) {
                    case CERT_ID_ISSUER_SERIAL_NUMBER:
                        {
                            PCRYPT_INTEGER_BLOB pCertSerialNumber =
                                &pCert->pCertInfo->SerialNumber;
                            PCERT_NAME_BLOB pCertIssuer =
                                &pCert->pCertInfo->Issuer;

                            PCRYPT_INTEGER_BLOB pParaSerialNumber =
                                &pCertId->IssuerSerialNumber.SerialNumber;
                            PCERT_NAME_BLOB pParaIssuer =
                                &pCertId->IssuerSerialNumber.Issuer;

                            if (CertCompareIntegerBlob(pCertSerialNumber,
                                    pParaSerialNumber)
                                        &&
                                pCertIssuer->cbData == pParaIssuer->cbData
                                        &&
                                memcmp(pCertIssuer->pbData,
                                    pParaIssuer->pbData,
                                        pCertIssuer->cbData) == 0)
                                return TRUE;
                            else
                                return FALSE;
                        }
                        break;
                    case CERT_ID_KEY_IDENTIFIER:
                        return CompareCertHash(pCert,
                            CERT_KEY_IDENTIFIER_PROP_ID,
                            &pCertId->KeyId
                            );
                        break;
                    case CERT_ID_SHA1_HASH:
                        return CompareCertHash(pCert,
                            CERT_SHA1_HASH_PROP_ID,
                            &pCertId->HashId
                            );
                        break;
                    default:
                        goto BadParameter;
                }
            }
            break;
#endif  // CMS_PKCS7

        case CERT_COMPARE_CROSS_CERT_DIST_POINTS:
            {
                DWORD cbData = 0;
                if (CertFindExtension(
                            szOID_CROSS_CERT_DIST_POINTS,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension) ||
                    CertGetCertificateContextProperty(
                            pCert,
                            CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                            NULL,       // pvData
                            &cbData))
                    return TRUE;
                else
                    return FALSE;
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCERT_CONTEXT pNewCert = ToCertContext(pNewEle);
    PCCERT_CONTEXT pExistingCert = ToCertContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCert->pCertInfo->NotBefore,
        &pExistingCert->pCertInfo->NotBefore
        ));
}

//+=========================================================================
//  CRL_CONTEXT Functions
//==========================================================================

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCRL_CONTEXT pCrl;
    PCRL_CONTEXT_SUFFIX pCrlSuffix;
    PCRL_INFO pInfo = NULL;

    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == pShareEle) {
        cbCrlEncoded = AdjustEncodedLength(
            dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);

        if (NULL == (pInfo = (PCRL_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_CERT_CRL_TO_BE_SIGNED,
                pbCrlEncoded,
                cbCrlEncoded))) goto ErrorReturn;
    }

    // Allocate and initialize the CRL element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CRL_CONTEXT) + sizeof(CRL_CONTEXT_SUFFIX));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CRL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCrl = (PCRL_CONTEXT) ToCrlContext(pEle);
    pCrl->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCrl->pbCrlEncoded = pbCrlEncoded;
    pCrl->cbCrlEncoded = cbCrlEncoded;
    if (pShareEle) {
        pEle->pShareEle = pShareEle;
        assert(pShareEle->pvInfo);
        pCrl->pCrlInfo = (PCRL_INFO) pShareEle->pvInfo;
        assert(pbCrlEncoded == pShareEle->pbEncoded);
        assert(cbCrlEncoded == pShareEle->cbEncoded);
    } else {
        pCrl->pCrlInfo = pInfo;

        CertPerfIncrementCrlElementCurrentCount();
        CertPerfIncrementCrlElementTotalCount();
    }
    pCrl->hCertStore = (HCERTSTORE) pStore;

    pCrlSuffix = ToCrlContextSuffix(pEle);
    pCrlSuffix->ppSortedEntry = NULL;

CommonReturn:
    return pEle;

ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    PCRL_CONTEXT_SUFFIX pCrlSuffix = ToCrlContextSuffix(pEle);
    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCrl->pbCrlEncoded);
        PkiFree(pCrl->pCrlInfo);

        CertPerfDecrementCrlElementCurrentCount();
    }
    PkiFree(pCrlSuffix->ppSortedEntry);
    PkiFree(pEle);
}

STATIC BOOL IsSameEncodedCrlExtension(
    IN LPCSTR pszObjId,
    IN PCCRL_CONTEXT pCrl,
    IN PCCRL_CONTEXT pNew
    )
{
    PCERT_EXTENSION pCrlExt;
    PCERT_EXTENSION pNewExt;

    // If they exist, compare the encoded extensions.
    pNewExt = CertFindExtension(
        pszObjId,
        pNew->pCrlInfo->cExtension,
        pNew->pCrlInfo->rgExtension
        );
    pCrlExt = CertFindExtension(
        pszObjId,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );

    if (pNewExt) {
        if (pCrlExt) {
            DWORD dwCertEncodingType = pCrl->dwCertEncodingType;
            DWORD cbNewExt = pNewExt->Value.cbData;
            BYTE *pbNewExt = pNewExt->Value.pbData;
            DWORD cbCrlExt = pCrlExt->Value.cbData;
            BYTE *pbCrlExt = pCrlExt->Value.pbData;

            // Before comparing, adjust lengths to only include the
            // encoded bytes
            cbNewExt = AdjustEncodedLength(dwCertEncodingType,
                pbNewExt, cbNewExt);
            cbCrlExt = AdjustEncodedLength(dwCertEncodingType,
                pbCrlExt, cbCrlExt);

            if (cbNewExt != cbCrlExt ||
                    0 != memcmp(pbNewExt, pbCrlExt, cbNewExt))
                return FALSE;
        } else
            // Only one has the extension
            return FALSE;
    } else if (pCrlExt)
        // Only one has the extension
        return FALSE;
    // else
        // Neither has the extension

    return TRUE;
}

STATIC BOOL IsSameCrl(
    IN PCCRL_CONTEXT pCrl,
    IN PCCRL_CONTEXT pNew
    )
{
    DWORD dwCertEncodingType;
    PCERT_EXTENSION pCrlDeltaExt;
    PCERT_EXTENSION pNewDeltaExt;

    // Check: encoding type and issuer name
    dwCertEncodingType = pNew->dwCertEncodingType;
    if (dwCertEncodingType != pCrl->dwCertEncodingType ||
            !CertCompareCertificateName(
                dwCertEncodingType,
                &pCrl->pCrlInfo->Issuer,
                &pNew->pCrlInfo->Issuer))
        return FALSE;

    // Check that both are either base or delta CRLs
    pNewDeltaExt = CertFindExtension(
        szOID_DELTA_CRL_INDICATOR,
        pNew->pCrlInfo->cExtension,
        pNew->pCrlInfo->rgExtension
        );
    pCrlDeltaExt = CertFindExtension(
        szOID_DELTA_CRL_INDICATOR,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );
    if (pNewDeltaExt) {
        if (NULL == pCrlDeltaExt)
            // Only one has a Delta extension
            return FALSE;
        // else
            // Both have a Delta extension
    } else if (pCrlDeltaExt)
        // Only one has a Delta extension
        return FALSE;
    // else
        // Neither has a Delta extension
    

    // If they exist, compare encoded AuthorityKeyIdentifier and
    // IssuingDistributionPoint extensions.
    if (!IsSameEncodedCrlExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER2,
            pCrl,
            pNew
            ))
        return FALSE;

    if (!IsSameEncodedCrlExtension(
            szOID_ISSUING_DIST_POINT,
            pCrl,
            pNew
            ))
        return FALSE;

    return TRUE;
}

STATIC BOOL IsIssuedByCrl(
    IN PCCRL_CONTEXT pCrl,
    IN PCCERT_CONTEXT pIssuer,
    IN PCERT_NAME_BLOB pIssuerName,
    IN DWORD dwFindFlags
    )
{
    DWORD dwCertEncodingType;

    if (dwFindFlags &
            (CRL_FIND_ISSUED_BY_DELTA_FLAG | CRL_FIND_ISSUED_BY_BASE_FLAG)) {
        PCERT_EXTENSION pDeltaExt;

        pDeltaExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );

        if (pDeltaExt) {
            if (0 == (dwFindFlags & CRL_FIND_ISSUED_BY_DELTA_FLAG))
                return FALSE;
        } else {
            if (0 == (dwFindFlags & CRL_FIND_ISSUED_BY_BASE_FLAG))
                return FALSE;
        }
    }

    if (NULL == pIssuer)
        return TRUE;

    dwCertEncodingType = pIssuer->dwCertEncodingType;
    if (dwCertEncodingType != pCrl->dwCertEncodingType ||
            !CertCompareCertificateName(
                dwCertEncodingType,
                &pCrl->pCrlInfo->Issuer,
                pIssuerName))
        return FALSE;

    if (dwFindFlags & CRL_FIND_ISSUED_BY_AKI_FLAG) {
        PCERT_EXTENSION pCrlAKIExt;

        pCrlAKIExt = CertFindExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER2,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );
        if (pCrlAKIExt) {
            PCERT_AUTHORITY_KEY_ID2_INFO pInfo;
            BOOL fResult;
    
            if (NULL == (pInfo =
                (PCERT_AUTHORITY_KEY_ID2_INFO) AllocAndDecodeObject(
                    dwCertEncodingType,
                    X509_AUTHORITY_KEY_ID2,
                    pCrlAKIExt->Value.pbData,
                    pCrlAKIExt->Value.cbData
                    )))
                return FALSE;

            if (pInfo->KeyId.cbData)
                fResult = CompareCertHash(
                    pIssuer,
                    CERT_KEY_IDENTIFIER_PROP_ID,
                    &pInfo->KeyId
                    );
            else
                fResult = TRUE;

            PkiFree(pInfo);
            if (!fResult)
                return FALSE;
        }
    }

    if (dwFindFlags & CRL_FIND_ISSUED_BY_SIGNATURE_FLAG) {
        DWORD dwFlags;

        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        VerifyCrl(pCrl, pIssuer, &dwFlags);
        if (0 != dwFlags)
            return FALSE;
    }

    return TRUE;
}

STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived)
        return FALSE;

    switch (dwFindType) {
        case CRL_FIND_ANY:
            return TRUE;
            break;

        case CRL_FIND_ISSUED_BY:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvFindPara;

                return IsIssuedByCrl(
                    pCrl,
                    pIssuer,
                    (NULL != pIssuer) ? &pIssuer->pCertInfo->Subject : NULL,
                    pFindInfo->dwFindFlags
                    );
            }
            break;

        case CRL_FIND_ISSUED_FOR:
            {
                PCRL_FIND_ISSUED_FOR_PARA pPara =
                    (PCRL_FIND_ISSUED_FOR_PARA) pvFindPara;

                return IsIssuedByCrl(
                    pCrl,
                    pPara->pIssuerCert,
                    &pPara->pSubjectCert->pCertInfo->Issuer,
                    pFindInfo->dwFindFlags
                    );
            }
            break;

        case CRL_FIND_EXISTING:
            return IsSameCrl(pCrl, (PCCRL_CONTEXT) pvFindPara);
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCRL_CONTEXT pNewCrl = ToCrlContext(pNewEle);
    PCCRL_CONTEXT pExistingCrl = ToCrlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCrl->pCrlInfo->ThisUpdate,
        &pExistingCrl->pCrlInfo->ThisUpdate
        ));
}

STATIC BOOL IsSameAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pE1,
    IN PCERT_ALT_NAME_ENTRY pE2
    )
{
    DWORD dwAltNameChoice;

    dwAltNameChoice = pE1->dwAltNameChoice;
    if (dwAltNameChoice != pE2->dwAltNameChoice)
        return FALSE;

    switch (dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            if (0 == strcmp(pE1->pOtherName->pszObjId,
                    pE2->pOtherName->pszObjId)
                            &&
                    pE1->pOtherName->Value.cbData ==
                        pE2->pOtherName->Value.cbData
                                &&
                    0 == memcmp(pE1->pOtherName->Value.pbData,
                        pE2->pOtherName->Value.pbData,
                        pE1->pOtherName->Value.cbData))
                return TRUE;
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
        case CERT_ALT_NAME_URL:
            if (0 == _wcsicmp(pE1->pwszRfc822Name, pE2->pwszRfc822Name))
                return TRUE;
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
            // Not implemented
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
            if (pE1->DirectoryName.cbData == pE2->DirectoryName.cbData &&
                    0 == memcmp(pE1->DirectoryName.pbData,
                             pE2->DirectoryName.pbData,
                             pE1->DirectoryName.cbData))
                return TRUE;
            break;
        case CERT_ALT_NAME_REGISTERED_ID:
            if (0 == strcmp(pE1->pszRegisteredID, pE2->pszRegisteredID))
                return TRUE;
            break;
        default:
            break;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Is the specified CRL valid for the certificate.
//
//  Returns TRUE if the CRL's list of entries would contain the certificate
//  if it was revoked. Note, doesn't check that the certificate is in the
//  list of entries.
//
//  If the CRL has an Issuing Distribution Point (IDP) extension, checks
//  that it's valid for the subject certificate.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 and NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertIsValidCRLForCertificate(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    PCERT_EXTENSION pIDPExt;                        // not allocated
    PCERT_EXTENSION pCDPExt;                        // not allocated
    PCERT_EXTENSION pBasicConstraintsExt;           // not allocated
    PCRL_ISSUING_DIST_POINT pIDPInfo = NULL;
    PCRL_DIST_POINTS_INFO pCDPInfo = NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO pBasicConstraintsInfo = NULL;

    DWORD cIDPAltEntry;
    PCERT_ALT_NAME_ENTRY pIDPAltEntry;              // not allocated

    pIDPExt = CertFindExtension(
        szOID_ISSUING_DIST_POINT,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );
    if (NULL == pIDPExt)
        return TRUE;

    if (NULL == (pIDPInfo = (PCRL_ISSUING_DIST_POINT) AllocAndDecodeObject(
            pCrl->dwCertEncodingType,
            X509_ISSUING_DIST_POINT,
            pIDPExt->Value.pbData,
            pIDPExt->Value.cbData
            )))
        goto IDPDecodeError;

    // Ignore IDPs having OnlySomeReasonFlags or an indirect CRL
    if (0 != pIDPInfo->OnlySomeReasonFlags.cbData ||
            pIDPInfo->fIndirectCRL)
        goto UnsupportedIDPError;

    if (!(CRL_DIST_POINT_NO_NAME ==
                pIDPInfo->DistPointName.dwDistPointNameChoice ||
            CRL_DIST_POINT_FULL_NAME ==
                pIDPInfo->DistPointName.dwDistPointNameChoice))
        goto UnsupportedIDPError;

    if (pIDPInfo->fOnlyContainsUserCerts ||
            pIDPInfo->fOnlyContainsCACerts) {
        // Determine if the cert is an end entity or a CA.

        // Default to an end entity
        BOOL fCA = FALSE;

        pBasicConstraintsExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS2,
            pCert->pCertInfo->cExtension,
            pCert->pCertInfo->rgExtension
            );

        if (pBasicConstraintsExt) {
            if (NULL == (pBasicConstraintsInfo =
                    (PCERT_BASIC_CONSTRAINTS2_INFO) AllocAndDecodeObject(
                        pCert->dwCertEncodingType,
                        X509_BASIC_CONSTRAINTS2,
                        pBasicConstraintsExt->Value.pbData,
                        pBasicConstraintsExt->Value.cbData
                        )))
                goto BasicConstraintsDecodeError;
            fCA = pBasicConstraintsInfo->fCA;
        }

        if (pIDPInfo->fOnlyContainsUserCerts && fCA)
            goto OnlyContainsUserCertsError;
        if (pIDPInfo->fOnlyContainsCACerts && !fCA)
            goto OnlyContainsCACertsError;
    }

    if (CRL_DIST_POINT_FULL_NAME !=
            pIDPInfo->DistPointName.dwDistPointNameChoice)
        // The IDP doesn't have any name choice to check
        goto SuccessReturn;

    cIDPAltEntry = pIDPInfo->DistPointName.FullName.cAltEntry;

    if (0 == cIDPAltEntry)
        // The IDP doesn't have any DistPoint entries to check
        goto SuccessReturn;

    pIDPAltEntry = pIDPInfo->DistPointName.FullName.rgAltEntry;

    pCDPExt = CertFindExtension(
        szOID_CRL_DIST_POINTS,
        pCert->pCertInfo->cExtension,
        pCert->pCertInfo->rgExtension
        );
    if (NULL == pCDPExt)
        goto NoCDPError;

    if (NULL == (pCDPInfo = (PCRL_DIST_POINTS_INFO) AllocAndDecodeObject(
            pCert->dwCertEncodingType,
            X509_CRL_DIST_POINTS,
            pCDPExt->Value.pbData,
            pCDPExt->Value.cbData
            )))
        goto CDPDecodeError;

    for ( ; 0 < cIDPAltEntry; pIDPAltEntry++, cIDPAltEntry--) {
        DWORD cCDPDistPoint;
        PCRL_DIST_POINT pCDPDistPoint;

        cCDPDistPoint = pCDPInfo->cDistPoint;
        pCDPDistPoint = pCDPInfo->rgDistPoint;
        for ( ; 0 < cCDPDistPoint; pCDPDistPoint++, cCDPDistPoint--) {
            DWORD cCDPAltEntry;
            PCERT_ALT_NAME_ENTRY pCDPAltEntry;

            if (0 != pCDPDistPoint->ReasonFlags.cbData)
                continue;
            if (0 != pCDPDistPoint->CRLIssuer.cAltEntry)
                continue;
            if (CRL_DIST_POINT_FULL_NAME !=
                    pCDPDistPoint->DistPointName.dwDistPointNameChoice)
                continue;

            cCDPAltEntry = pCDPDistPoint->DistPointName.FullName.cAltEntry;
            pCDPAltEntry = pCDPDistPoint->DistPointName.FullName.rgAltEntry;
            for ( ; 0 < cCDPAltEntry; pCDPAltEntry++, cCDPAltEntry--) {
                if (IsSameAltNameEntry(pIDPAltEntry, pCDPAltEntry))
                    goto SuccessReturn;
            }
        }
    }

    goto NoAltNameMatchError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pIDPInfo);
    PkiFree(pCDPInfo);
    PkiFree(pBasicConstraintsInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoCDPError, CRYPT_E_NO_MATCH)
TRACE_ERROR(IDPDecodeError)
SET_ERROR(UnsupportedIDPError, E_NOTIMPL)
TRACE_ERROR(BasicConstraintsDecodeError)
SET_ERROR(OnlyContainsUserCertsError, CRYPT_E_NO_MATCH)
SET_ERROR(OnlyContainsCACertsError, CRYPT_E_NO_MATCH)
TRACE_ERROR(CDPDecodeError)
SET_ERROR(NoAltNameMatchError, CRYPT_E_NO_MATCH)
}


//+=========================================================================
//  CTL_CONTEXT Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  If both msg and cert encoding types are present, or neither are present,
//  return without any changes. Otherwise, set the missing encoding type
//  with the encoding type that is present.
//--------------------------------------------------------------------------
STATIC DWORD GetCtlEncodingType(IN DWORD dwMsgAndCertEncodingType)
{
    if (0 == dwMsgAndCertEncodingType)
        return 0;
    else if (0 == (dwMsgAndCertEncodingType & CMSG_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType << 16) & CMSG_ENCODING_TYPE_MASK);
    else if (0 == (dwMsgAndCertEncodingType & CERT_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK);
    else
        // Both specified
        return dwMsgAndCertEncodingType;
}

#if 0

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT SlowCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    DWORD dwEncodingType;
    HCRYPTPROV hProv = 0;
    DWORD dwProvFlags = 0;
    HCRYPTMSG hMsg = NULL;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;

    // Attempt to get the store's crypt provider. Serialize crypto
    // operations.
    hProv = GetCryptProv(pStore, &dwProvFlags);

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    // Assumption:: only definite length encoded PKCS #7
    cbCtlEncoded = AdjustEncodedLength(
        dwEncodingType, pbCtlEncoded, cbCtlEncoded);

    // First decode as a PKCS#7 SignedData message
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgAndCertEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pbCtlEncoded,
            cbCtlEncoded,
            TRUE                    // fFinal
            )) goto MsgUpdateError;
    else {
        // Verify that the outer ContentType is SignedData and the inner
        // ContentType is a CertificateTrustList
        DWORD dwMsgType = 0;
        DWORD cbData;
        char szInnerContentType[64];
        assert(sizeof(szInnerContentType) > strlen(szOID_CTL));

        cbData = sizeof(dwMsgType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_TYPE_PARAM,
                0,                  // dwIndex
                &dwMsgType,
                &cbData
                )) goto GetTypeError;
        if (CMSG_SIGNED != dwMsgType)
            goto UnexpectedMsgTypeError;

        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        if (0 != strcmp(szInnerContentType, szOID_CTL))
            goto UnexpectedInnerContentTypeError;

    }

    // Get the inner content.
    if (NULL == (pbContent = (BYTE *) AllocAndGetMsgParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            &cbContent))) goto GetContentError;

    // Decode inner content
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbContent,
                cbContent))) goto DecodeError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT) +
            sizeof(CTL_CONTEXT_SUFFIX))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    pCtl->hCryptMsg = hMsg;
    pCtl->pbCtlContent = pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->pSortedCtlFindInfo = NULL;

CommonReturn:
    // For the store's crypt provider, release reference count. Leave
    // crypto operations critical section.
    //
    // Also, any subsequent CryptMsg cryptographic operations will
    // be done outside of critical section. This critical section is needed
    // because CAPI 1.0 isn't thread safe. This should be fixed!!!! ?????
    ReleaseCryptProv(pStore, dwProvFlags);
    return pEle;

ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pbContent);
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedInnerContentTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetContentError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeError)
}

void
StoreMessageBox(
    IN LPSTR pszText
    )
{
    MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "Check FastCreateCtlElement",
        MB_TOPMOST | MB_OK | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
}
#endif

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle,
    IN DWORD dwFlags
    );

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
#if 1
    return FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        pShareEle,
        0                                   // dwFlags
        );
#else
    PCONTEXT_ELEMENT pSlowEle;
    PCONTEXT_ELEMENT pFastEle;

    pFastEle = FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        pShareEle,
        0                   // dwFlags
        );

    pSlowEle = NULL;
    if (cbCtlEncoded) {
        BYTE *pbSlowCtlEncoded = NULL;

        pbSlowCtlEncoded = (BYTE *) PkiNonzeroAlloc(cbCtlEncoded);
        if (pbSlowCtlEncoded) {
            memcpy(pbSlowCtlEncoded, pbCtlEncoded, cbCtlEncoded);
            pSlowEle = SlowCreateCtlElement(
                &NullCertStore,
                dwMsgAndCertEncodingType,
                pbSlowCtlEncoded,
                cbCtlEncoded
                );
            if (NULL == pSlowEle)
                PkiFree(pbSlowCtlEncoded);
        }
    }

    if (NULL == pFastEle) {
        if (pSlowEle)
            StoreMessageBox("fast failed, slow succeeded");
    } else if (NULL == pSlowEle) {
        StoreMessageBox("fast succeeded, slow failed");
    } else {
        PCTL_INFO pFastInfo = ToCtlContext(pFastEle)->pCtlInfo;
        PCTL_INFO pSlowInfo = ToCtlContext(pSlowEle)->pCtlInfo;

        // Check that headers match
        if (pFastInfo->dwVersion != pSlowInfo->dwVersion ||
                pFastInfo->SubjectUsage.cUsageIdentifier !=
                    pSlowInfo->SubjectUsage.cUsageIdentifier ||
                0 != CompareFileTime(&pFastInfo->ThisUpdate,
                    &pSlowInfo->ThisUpdate) ||
                0 != CompareFileTime(&pFastInfo->NextUpdate,
                    &pSlowInfo->NextUpdate) ||
                0 != strcmp(pFastInfo->SubjectAlgorithm.pszObjId,
                        pSlowInfo->SubjectAlgorithm.pszObjId) ||
                pFastInfo->SubjectAlgorithm.Parameters.cbData !=
                        pSlowInfo->SubjectAlgorithm.Parameters.cbData)
            StoreMessageBox("fast and slow info doesn't match\n");
        else {
            // Check that the extensions match
            DWORD cFastExt = pFastInfo->cExtension;
            PCERT_EXTENSION pFastExt = pFastInfo->rgExtension;
            DWORD cSlowExt = pSlowInfo->cExtension;
            PCERT_EXTENSION pSlowExt = pSlowInfo->rgExtension;

            if (cFastExt != cSlowExt)
                StoreMessageBox("fast and slow extension count doesn't match");
            else {
                for ( ; cFastExt; cFastExt--, pFastExt++, pSlowExt++) {
                    if (0 != strcmp(pFastExt->pszObjId, pSlowExt->pszObjId) ||
                                pFastExt->fCritical != pSlowExt->fCritical ||
                            pFastExt->Value.cbData != pSlowExt->Value.cbData) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                    if (pFastExt->Value.cbData && 0 != memcmp(
                            pFastExt->Value.pbData, pSlowExt->Value.pbData,
                                pFastExt->Value.cbData)) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                }
            }
        }

        if (pFastInfo->cCTLEntry != pSlowInfo->cCTLEntry)
            StoreMessageBox("fast and slow entry count doesn't match");
        else {
            DWORD cEntry = pFastInfo->cCTLEntry;
            PCTL_ENTRY pFastEntry = pFastInfo->rgCTLEntry;
            PCTL_ENTRY pSlowEntry = pSlowInfo->rgCTLEntry;

            for ( ; cEntry; cEntry--, pFastEntry++, pSlowEntry++) {
                if (pFastEntry->SubjectIdentifier.cbData !=
                        pSlowEntry->SubjectIdentifier.cbData ||
                    0 != memcmp(pFastEntry->SubjectIdentifier.pbData,
                            pSlowEntry->SubjectIdentifier.pbData,
                            pFastEntry->SubjectIdentifier.cbData)) {
                    StoreMessageBox(
                        "fast and slow SubjectIdentifier doesn't match");
                    goto Done;
                }

                if (pFastEntry->cAttribute != pSlowEntry->cAttribute) {
                    StoreMessageBox(
                        "fast and slow Attribute Count doesn't match");
                    goto Done;
                } else if (0 < pFastEntry->cAttribute) {
                    DWORD cAttr = pFastEntry->cAttribute;
                    PCRYPT_ATTRIBUTE pFastAttr = pFastEntry->rgAttribute;
                    PCRYPT_ATTRIBUTE pSlowAttr = pSlowEntry->rgAttribute;

                    for ( ; cAttr; cAttr--, pFastAttr++, pSlowAttr++) {
                        if (0 != strcmp(pFastAttr->pszObjId,
                                    pSlowAttr->pszObjId)) {
                            StoreMessageBox(
                                "fast and slow Attribute OID doesn't match");
                            goto Done;
                        }

                        if (pFastAttr->cValue != pSlowAttr->cValue) {
                            StoreMessageBox(
                                "fast and slow Value Count doesn't match");
                            goto Done;
                        }

                        if (0 < pFastAttr->cValue) {
                            DWORD cValue = pFastAttr->cValue;
                            PCRYPT_ATTR_BLOB pFastValue = pFastAttr->rgValue;
                            PCRYPT_ATTR_BLOB pSlowValue = pSlowAttr->rgValue;

                            for ( ; cValue;
                                        cValue--, pFastValue++, pSlowValue++) {
                                if (pFastValue->cbData !=
                                        pSlowValue->cbData ||
                                    0 != memcmp(pFastValue->pbData,
                                            pSlowValue->pbData,
                                            pFastValue->cbData)) {
                                    StoreMessageBox(
                                        "fast and slow Value doesn't match");
                                    goto Done;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    

Done:
    if (pSlowEle)
        FreeContextElement(pSlowEle);

    return pFastEle;
        
#endif
}

STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    PCTL_CONTEXT_SUFFIX pCtlSuffix = ToCtlContextSuffix(pEle);

    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCtl->pbCtlEncoded);

        CertPerfDecrementCtlElementCurrentCount();
    }

    PkiFree(pCtl->pCtlInfo);
    PkiFree(pCtlSuffix->ppSortedEntry);
    CryptMsgClose(pCtl->hCryptMsg);

    if (pCtlSuffix->fFastCreate) {
        PSORTED_CTL_FIND_INFO pSortedCtlFindInfo =
            pCtlSuffix->pSortedCtlFindInfo;

        PkiFree(pCtlSuffix->pCTLEntry);
        PkiFree(pCtlSuffix->pExtInfo);

        if (pSortedCtlFindInfo) {
            PkiFree(pSortedCtlFindInfo->pdwHashBucketHead);
            PkiFree(pSortedCtlFindInfo->pHashBucketEntry);
        }
    } else
        PkiFree(pCtl->pbCtlContent);

    PkiFree(pEle);
}

STATIC BOOL CompareCtlHash(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCTLContextProperty(
        pCtl,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCtlUsage(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_USAGE_PARA pPara
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_USAGE_PARA, SubjectUsage) +
                sizeof(pPara->SubjectUsage)))
        return TRUE;
    if ((CTL_FIND_SAME_USAGE_FLAG & dwFindFlags) &&
            pPara->SubjectUsage.cUsageIdentifier !=
                pInfo->SubjectUsage.cUsageIdentifier)
        return FALSE;
    if (!CompareCtlUsageIdentifiers(&pPara->SubjectUsage,
            1, &pInfo->SubjectUsage, FALSE))
        return FALSE;

    assert(offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) >
        offsetof(CTL_FIND_USAGE_PARA, SubjectUsage));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) +
            sizeof(pPara->ListIdentifier))
        return TRUE;
    if (pPara->ListIdentifier.cbData) {
        DWORD cb = pPara->ListIdentifier.cbData;
        if (CTL_FIND_NO_LIST_ID_CBDATA == cb)
            cb = 0;
        if (cb != pInfo->ListIdentifier.cbData)
            return FALSE;
        if (0 != cb && 0 != memcmp(pPara->ListIdentifier.pbData,
                pInfo->ListIdentifier.pbData, cb))
            return FALSE;
    }

    assert(offsetof(CTL_FIND_USAGE_PARA, pSigner) >
        offsetof(CTL_FIND_USAGE_PARA, ListIdentifier));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, pSigner) +
            sizeof(pPara->pSigner))
        return TRUE;
    if (CTL_FIND_NO_SIGNER_PTR == pPara->pSigner) {
        DWORD cbData;
        DWORD dwSignerCount;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 != dwSignerCount)
            return FALSE;
    } else if (pPara->pSigner) {
        DWORD dwCertEncodingType;
        PCERT_INFO pCertId1 = pPara->pSigner;
        HCRYPTMSG hMsg = pCtl->hCryptMsg;
        DWORD cbData;
        DWORD dwSignerCount;
        DWORD i;

        dwCertEncodingType = GetCertEncodingType(dwMsgAndCertEncodingType);
        if (dwCertEncodingType != GET_CERT_ENCODING_TYPE(
                pCtl->dwMsgAndCertEncodingType))
            return FALSE;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            return FALSE;
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pCertId2;
            if (NULL == (pCertId2 = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            fResult = CertCompareCertificate(
                dwCertEncodingType,
                pCertId1,
                pCertId2);
            PkiFree(pCertId2);
            if (fResult)
                break;
        }
        if (i == dwSignerCount)
            return FALSE;
    }

    return TRUE;
}

STATIC BOOL CompareCtlSubject(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_SUBJECT_PARA pPara
    )
{
    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara) +
                sizeof(pPara->pUsagePara)))
        return TRUE;
    if (pPara->pUsagePara && !CompareCtlUsage(pCtl,
            dwMsgAndCertEncodingType, dwFindFlags, pPara->pUsagePara))
        return FALSE;

    assert(offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) >
        offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara));
    if (pPara->cbSize < offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) +
            sizeof(pPara->pvSubject))
        return TRUE;
    if (pPara->pvSubject && NULL == CertFindSubjectInCTL(
            dwMsgAndCertEncodingType,
            pPara->dwSubjectType,
            pPara->pvSubject,
            pCtl,
            0))                     // dwFlags
        return FALSE;

    return TRUE;
}

STATIC BOOL IsSameCtl(
    IN PCCTL_CONTEXT pCtl,
    IN PCCTL_CONTEXT pNew
    )
{
    PCTL_INFO pInfo = pNew->pCtlInfo;
    HCRYPTMSG hMsg = pNew->hCryptMsg;
    CTL_FIND_USAGE_PARA FindPara;
    DWORD dwFindFlags;

    DWORD cbData;
    DWORD dwSignerCount;
    DWORD i;

    cbData = sizeof(dwSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &dwSignerCount,
            &cbData))
        return FALSE;

    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.SubjectUsage = pInfo->SubjectUsage;
    FindPara.ListIdentifier = pInfo->ListIdentifier;
    if (0 == FindPara.ListIdentifier.cbData)
        FindPara.ListIdentifier.cbData = CTL_FIND_NO_LIST_ID_CBDATA;
    dwFindFlags = CTL_FIND_SAME_USAGE_FLAG;

    if (0 == dwSignerCount) {
        FindPara.pSigner = CTL_FIND_NO_SIGNER_PTR;
        return CompareCtlUsage(
            pCtl,
            pNew->dwMsgAndCertEncodingType,
            dwFindFlags,
            &FindPara
            );
    } else {
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pSigner;

            if (NULL == (pSigner = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            FindPara.pSigner = pSigner;
            fResult = CompareCtlUsage(
                    pCtl,
                    pNew->dwMsgAndCertEncodingType,
                    dwFindFlags,
                    &FindPara
                    );
            PkiFree(pSigner);
            if (fResult)
                return TRUE;
        }
    }
    return FALSE;
}

STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwFindType) {
            case CTL_FIND_SHA1_HASH:
            case CTL_FIND_MD5_HASH:
                break;
            default:
                return FALSE;
        }
    }

    switch (dwFindType) {
        case CTL_FIND_ANY:
            return TRUE;
            break;
        case CTL_FIND_SHA1_HASH:
        case CTL_FIND_MD5_HASH:
            {
                DWORD dwPropId;
                if (dwFindType == CTL_FIND_SHA1_HASH)
                    dwPropId = CERT_SHA1_HASH_PROP_ID;
                else
                    dwPropId = CERT_MD5_HASH_PROP_ID;
                return CompareCtlHash(pCtl, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;
        case CTL_FIND_USAGE:
            return CompareCtlUsage(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_USAGE_PARA) pvFindPara);
            break;
        case CTL_FIND_SUBJECT:
            return CompareCtlSubject(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_SUBJECT_PARA) pvFindPara);
            break;

        case CTL_FIND_EXISTING:
            {
                PCCTL_CONTEXT pNew = (PCCTL_CONTEXT) pFindInfo->pvFindPara;
                return IsSameCtl(pCtl, pNew);
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCTL_CONTEXT pNewCtl = ToCtlContext(pNewEle);
    PCCTL_CONTEXT pExistingCtl = ToCtlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCtl->pCtlInfo->ThisUpdate,
        &pExistingCtl->pCtlInfo->ThisUpdate
        ));
}


//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    PCERT_STORE_LINK pLink;
    if (NULL == (pLink = (PCERT_STORE_LINK) PkiZeroAlloc(
            sizeof(CERT_STORE_LINK))))
        return NULL;

    pLink->lRefCnt = 1;
    pLink->dwUpdateFlags = dwUpdateFlags;
    pLink->dwPriority = dwPriority;
    pLink->pCollection = pCollection;
    pLink->pSibling = (PCERT_STORE) CertDuplicateStore((HCERTSTORE) pSibling);

    return pLink;
}

// Not locked upon entry
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    CertCloseStore((HCERTSTORE) pStoreLink->pSibling, 0);
    PkiFree(pStoreLink);
}


STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    PCERT_STORE pCollection = pStoreLink->pCollection;


    LockStore(pCollection);

    // Remove store link from the store's collection
    if (pStoreLink->pNext)
        pStoreLink->pNext->pPrev = pStoreLink->pPrev;
    if (pStoreLink->pPrev)
        pStoreLink->pPrev->pNext = pStoreLink->pNext;
    else if (pStoreLink == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pStoreLink->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last link in a closed store
    FreeStore(pCollection);
}

STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    RemoveStoreLink(pStoreLink);
    FreeStoreLink(pStoreLink);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
        assert(pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG);
        assert(pStoreLink->pSibling);
        RemoveAndFreeStoreLink(pStoreLink);
    }
}


//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwContextType = pEle->dwContextType;
    DWORD *pdwEncodingType;

    pdwEncodingType = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodingType[dwContextType]);
    return *pdwEncodingType;
}

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    DWORD dwContextType = pEle->dwContextType;
    BYTE **ppbSrcEncoded;
    DWORD *pcbSrcEncoded;

    ppbSrcEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedPointer[dwContextType]);
    *ppbEncoded = *ppbSrcEncoded;

    pcbSrcEncoded = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedCount[dwContextType]);
    *pcbEncoded = *pcbSrcEncoded;
}



STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    DWORD dwInnerDepth;

    // Skip past any links to get to the cache element
    dwInnerDepth = 0;
    for ( ; pCacheEle != pCacheEle->pEle; pCacheEle = pCacheEle->pEle) {
        dwInnerDepth++;
        assert(dwInnerDepth <= MAX_LINK_DEPTH);
        assert(ELEMENT_TYPE_CACHE != pCacheEle->dwElementType);
        if (dwInnerDepth > MAX_LINK_DEPTH)
            goto ExceededMaxLinkDepth;
    }

    assert(pCacheEle);
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);

CommonReturn:
    return pCacheEle;
ErrorReturn:
    pCacheEle = NULL;
    goto CommonReturn;
SET_ERROR(ExceededMaxLinkDepth, E_UNEXPECTED)
}


STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    pEle->pNext = pStore->rgpContextListHead[dwContextType];
    pEle->pPrev = NULL;
    if (pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType]->pPrev = pEle;
    pStore->rgpContextListHead[dwContextType] = pEle;

    UnlockStore(pStore);
}


STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    // Remove context from the store's list
    if (pEle->pNext)
        pEle->pNext->pPrev = pEle->pPrev;
    if (pEle->pPrev)
        pEle->pPrev->pNext = pEle->pNext;
    else if (pEle == pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType] = pEle->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last context in a closed store
    FreeStore(pStore);
}

STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // Free its property elements
    while ((pPropEle = pEle->Cache.pPropHead) != NULL) {
        RemovePropElement(pEle, pPropEle);
        FreePropElement(pPropEle);
    }

    // For NOCOPY of the pbEncoded, call the NOCOPY pfnFree callback
    if (pNoCopyInfo = pEle->pNoCopyInfo) {
        PFN_CRYPT_FREE pfnFree;
        BYTE **ppbEncoded;

        if (pfnFree = pNoCopyInfo->pfnFree) {
            assert(pNoCopyInfo->pvFree);
            pfnFree(pNoCopyInfo->pvFree);
        }

        // Inhibit following rgpfnFreeElement[] from freeing pbEncoded
        ppbEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
            rgOffsetofEncodedPointer[pEle->dwContextType]);
        *ppbEncoded = NULL;
        PkiFree(pNoCopyInfo);
    }

    rgpfnFreeElement[pEle->dwContextType](pEle);
}

STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    RemoveContextElement(pEle);
    FreeContextElement(pEle);
}

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    InterlockedIncrement(&pEle->lRefCnt);
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwErr;
    PCERT_STORE pStore;
    DWORD dwStoreFlags;

    if (pEle == NULL)
        return;

    pStore = pEle->pStore;
    dwStoreFlags = pStore->dwFlags;

    if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
        // Check that the store still doesn't hold a reference
        assert(pEle->dwFlags & ELEMENT_DELETED_FLAG);

        if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
            InterlockedDecrement(&pStore->lDeferCloseRefCnt);

        dwErr = GetLastError();
        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            RemoveAndFreeContextElement(pEle);
        else
            RemoveAndFreeLinkElement(pEle);
        SetLastError(dwErr);
    } else if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
        LockStore(pStore);
        if (0 == InterlockedDecrement(&pStore->lDeferCloseRefCnt)) {
            if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
                dwErr = GetLastError();
                CloseStore(pStore, 0);
                SetLastError(dwErr);
                return;
            }
        }
        UnlockStore(pStore);
    }
}

STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;

    if (NULL == pEle) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pEle->dwElementType) {
        case ELEMENT_TYPE_LINK_CONTEXT:
            // Only delete the link itself
            break;

        case ELEMENT_TYPE_COLLECTION:
            // Delete element pointed to
            assert(pEle != pEle->pEle);
            if (pEle != pEle->pEle) {
                // Since delete releases refCnt, need to do an extra
                // addRef here.
                AddRefContextElement(pEle->pEle);
                if (!DeleteContextElement(pEle->pEle))
                    goto DeleteCacheCollectionError;
            } else
                goto InvalidElement;
            break;

        case ELEMENT_TYPE_CACHE:
        case ELEMENT_TYPE_EXTERNAL:
            {
                PCERT_STORE pProvStore = pEle->pProvStore;
                const DWORD dwStoreProvDeleteIndex =
                    rgdwStoreProvDeleteIndex[pEle->dwContextType];
                PFN_CERT_STORE_PROV_DELETE_CERT pfnStoreProvDeleteCert;

                assert(STORE_TYPE_CACHE == pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

                fResult = TRUE;
                LockStore(pProvStore);
                // Check if we need to call the store provider's writethru
                // function.
                if (dwStoreProvDeleteIndex <
                        pProvStore->StoreProvInfo.cStoreProvFunc &&
                            NULL != (pfnStoreProvDeleteCert =
                                (PFN_CERT_STORE_PROV_DELETE_CERT)
                            pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvDeleteIndex])) {

                    // Since we can't hold a lock while calling the provider
                    // function, bump the store's provider reference count
                    // to inhibit the closing of the store and freeing of
                    // the provider functions.
                    //
                    // When the store is closed,
                    // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                    AddRefStoreProv(pProvStore);
                    UnlockStore(pProvStore);

                    // Check if its OK to delete from the store.
                    fResult = pfnStoreProvDeleteCert(
                            pProvStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEle->pEle),
                            0                       // dwFlags
                            );
                    LockStore(pProvStore);
                    ReleaseStoreProv(pProvStore);
                }
                UnlockStore(pProvStore);
                if (!fResult)
                    goto StoreProvDeleteError;
            }
            break;
        default:
            goto InvalidElementType;
    }

    LockStore(pEle->pStore);
    if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
        // On the store's list. There should be at least two reference
        // counts on the context, the store's and the caller's.
        assert(pEle->pStore->dwState == STORE_STATE_OPEN ||
            pEle->pStore->dwState == STORE_STATE_OPENING ||
            pEle->pStore->dwState == STORE_STATE_DEFER_CLOSING ||
            pEle->pStore->dwState == STORE_STATE_CLOSING);

        // Remove the store's reference
        if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
            assert(pEle->lRefCnt > 0);
            // Put back the reference to allow the ReleaseContextElement
            // to do the context remove and free
            pEle->lRefCnt = 1;
        }
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    }
    UnlockStore(pEle->pStore);

    fResult = TRUE;
CommonReturn:
    // Release the caller's reference on the context
    ReleaseContextElement(pEle);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DeleteCacheCollectionError)
SET_ERROR(InvalidElement, E_INVALIDARG)
TRACE_ERROR(StoreProvDeleteError)
SET_ERROR(InvalidElementType, E_INVALIDARG)
}


// Returns TRUE if both elements have identical SHA1 hash.
STATIC BOOL IsIdenticalContextElement(
    IN PCONTEXT_ELEMENT pEle1,
    IN PCONTEXT_ELEMENT pEle2
    )
{
    BYTE rgbHash1[SHA1_HASH_LEN];
    BYTE rgbHash2[SHA1_HASH_LEN];
    DWORD cbHash;

    cbHash = SHA1_HASH_LEN;
    if (!GetProperty(
            pEle1,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash1,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    if (!GetProperty(
            pEle2,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash2,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    if (0 == memcmp(rgbHash1, rgbHash2, SHA1_HASH_LEN))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Serialize a store element and its properties
//--------------------------------------------------------------------------
STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!SerializeProperty(
            h,
            pfn,
            pEle
            ))
        goto SerializePropertyError;

    GetContextEncodedInfo(pEle, &pbEncoded, &cbEncoded);
    if (!WriteStoreElement(
            h,
            pfn,
            GetContextEncodingType(pEle),
            rgdwFileElementType[pEle->dwContextType],
            pbEncoded,
            cbEncoded
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SerializePropertyError);
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Serialize the context's encoded data and its properties.
//--------------------------------------------------------------------------
STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pByte = pbElement;
    if (pbElement == NULL)
        MemInfo.cb = 0;
    else
        MemInfo.cb = *pcbElement;
    MemInfo.cbSeek = 0;

    if (fResult = SerializeStoreElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle)) {
        if (MemInfo.cbSeek > MemInfo.cb && pbElement) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
        *pcbElement = MemInfo.cbSeek;
    } else
        *pcbElement = 0;

    return fResult;
}

//+=========================================================================
//  Collection Stack Functions
//==========================================================================

// No locks upon entry
STATIC BOOL PushCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack,
    IN PCERT_STORE pCollection
    )
{
    PCOLLECTION_STACK_ENTRY pNew;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == (pNew = (PCOLLECTION_STACK_ENTRY) PkiZeroAlloc(
            sizeof(COLLECTION_STACK_ENTRY))))
        return FALSE;

    LockStore(pCollection);

    pStoreLink = pCollection->pStoreListHead;
    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pCollection);

    pNew->pCollection = pCollection;
    pNew->pStoreLink = pStoreLink;
    pNew->pPrev = *ppStack;
    *ppStack = pNew;
    return TRUE;
};


// No locks upon entry
STATIC void AdvanceToNextStackStoreLink(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    PCERT_STORE pStackCollectionStore;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == pStack)
        return;
    pStoreLink = pStack->pStoreLink;
    if (NULL == pStoreLink)
        return;

    pStackCollectionStore = pStack->pCollection;
    assert(pStackCollectionStore);
    LockStore(pStackCollectionStore);
    pStoreLink = pStoreLink->pNext;

    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pStackCollectionStore);

    ReleaseStoreLink(pStack->pStoreLink);
    pStack->pStoreLink = pStoreLink;
}

// No locks upon entry
STATIC void PopCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack
    )
{
    PCOLLECTION_STACK_ENTRY pStack = *ppStack;
    if (pStack) {
        PCOLLECTION_STACK_ENTRY pPrevStack;
        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pPrevStack = pStack->pPrev;
        *ppStack = pPrevStack;
        PkiFree(pStack);

        if (pPrevStack)
            AdvanceToNextStackStoreLink(pPrevStack);
    }
}

// No locks upon entry
STATIC void ClearCollectionStack(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    while (pStack) {
        PCOLLECTION_STACK_ENTRY pFreeStack;

        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pFreeStack = pStack;
        pStack = pStack->pPrev;
        PkiFree(pFreeStack);
    }
}

//+=========================================================================
//  Link Element Functions
//==========================================================================

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    )
{
    PCONTEXT_ELEMENT pLinkEle;
    const DWORD cbContext = rgcbContext[dwContextType];

    if (NULL == (pLinkEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + cbContext)))
        return NULL;
    pLinkEle->dwContextType = dwContextType;
    return pLinkEle;
}

static inline void SetStoreHandle(
    IN PCONTEXT_ELEMENT pEle
    )
{
    HCERTSTORE *phStore;
    phStore = (HCERTSTORE *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofStoreHandle[pEle->dwContextType]);
    *phStore = (HCERTSTORE) pEle->pStore;
}

// The store doesn't hold a reference on the external element.
// Therefore, its lRefCnt is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddExternalElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,          // EXTERNAL
    IN PCONTEXT_ELEMENT pProvEle,   // already AddRef'ed
    IN DWORD dwFlags,
    IN OPTIONAL void *pvProvInfo
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_EXTERNAL;
    pLinkEle->dwFlags = dwFlags | ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pProvEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pStore;
    pLinkEle->External.pvProvInfo = pvProvInfo;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pProvEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store doesn't hold a reference on the collection element.
// Therefore, its RefCount is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddCollectionElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // COLLECTION
    IN PCONTEXT_ELEMENT pSiblingEle,    // already AddRef'ed
    IN OPTIONAL PCOLLECTION_STACK_ENTRY pCollectionStack
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_COLLECTION == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_COLLECTION;
    pLinkEle->dwFlags = ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pSiblingEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pSiblingEle->pProvStore;
    pLinkEle->Collection.pCollectionStack = pCollectionStack;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pSiblingEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store holds a reference on the link context element.
// Therefore, the ELEMENT_DELETED_FLAG is clear.
STATIC void InitAndAddLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // CACHE
    IN PCONTEXT_ELEMENT pContextEle     // already AddRef'ed
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_LINK_CONTEXT;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pContextEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pContextEle->pProvStore;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pContextEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
}

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (ELEMENT_TYPE_EXTERNAL == pEle->dwElementType) {
        PCERT_STORE pProvStore = pEle->pProvStore;
        const DWORD dwStoreProvFreeFindIndex =
            rgdwStoreProvFreeFindIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

        assert(pEle->pStore == pEle->pProvStore);
        assert(STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

        LockStore(pProvStore);
        // Check if we need to call the store provider's free find cert
        // function.
        if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
            pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;

            if (dwStoreProvFreeFindIndex <
                    pProvStore->StoreProvInfo.cStoreProvFunc &&
                        NULL != (pfnStoreProvFreeFindCert =
                            (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                        pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                            dwStoreProvFreeFindIndex])) {

                // Since we can't hold a lock while calling the provider
                // function, bump the store's provider reference count
                // to inhibit the closing of the store and freeing of
                // the provider functions.
                //
                // When the store is closed,
                // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                AddRefStoreProv(pProvStore);
                UnlockStore(pProvStore);

                pfnStoreProvFreeFindCert(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    pEle->External.pvProvInfo,
                    0                       // dwFlags
                    );
                LockStore(pProvStore);
                ReleaseStoreProv(pProvStore);
            }
        }
        UnlockStore(pProvStore);
    } else if (ELEMENT_TYPE_COLLECTION == pEle->dwElementType) {
        if (pEle->Collection.pCollectionStack)
            ClearCollectionStack(pEle->Collection.pCollectionStack);
    }

    ReleaseContextElement(pEle->pEle);

    // Remove from store
    RemoveContextElement(pEle);
    FreeLinkElement(pEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    ReleaseContextElement(pLinkEle->pEle);
    FreeLinkElement(pLinkEle);
}

//+=========================================================================
//  Find Element Functions
//==========================================================================

// For Add, called with store already locked and store remains locked. The
// find type for the Add is FIND_EXISTING.
// CacheStore may contain either cache or context link elements
STATIC PCONTEXT_ELEMENT FindElementInCacheStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fForceEnumArchived = FALSE
    )
{
    PCONTEXT_ELEMENT pEle;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    if (pPrevEle) {
        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType) {
            UnlockStore(pStore);
            goto InvalidPreviousContext;
        }
        pEle = pPrevEle->pNext;
    } else if (STORE_STATE_NULL == pStore->dwState)
        // For NULL store, all elements are already deleted
        pEle = NULL;
    else
        pEle = pStore->rgpContextListHead[dwContextType];

    for ( ; pEle; pEle = pEle->pNext) {
        PCONTEXT_ELEMENT pCacheEle;
        BOOL fArchived;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted elements
        if (pEle->dwFlags & ELEMENT_DELETED_FLAG)
            continue;

        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            pCacheEle = pEle;
        else {
            pCacheEle = GetCacheElement(pEle);
            if (NULL == pCacheEle)
                pCacheEle = pEle;
        }
        fArchived = ((pCacheEle->dwFlags & ELEMENT_ARCHIVED_FLAG) &&
            0 == (pStore->dwFlags & CERT_STORE_ENUM_ARCHIVED_FLAG) &&
            !fForceEnumArchived);

        AddRefContextElement(pEle);
        UnlockStore(pStore);

      // Handle MappedFile Exceptions
      __try {

        if (rgpfnCompareElement[dwContextType](pEle, pFindInfo, fArchived))
            goto CommonReturn;

      } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
      }

        if (pPrevEle)
            ReleaseContextElement(pPrevEle);
        pPrevEle = pEle;

        LockStore(pStore);
    }

    UnlockStore(pStore);
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInExternalStore(
    IN PCERT_STORE pStore,      //  EXTERNAL
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    const DWORD dwStoreProvFindIndex = rgdwStoreProvFindIndex[dwContextType];

    // All the context types have the same find callback signature.
    PFN_CERT_STORE_PROV_FIND_CERT pfnStoreProvFind;

    void *pvProvInfo;
    PCONTEXT_ELEMENT pPrevProvEle = NULL;
    PCCERT_CONTEXT pProvCertContext;

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    if (NULL == (pEle = CreateLinkElement(dwContextType)))
        goto CreateLinkElementError;

    if (pPrevEle) {
        BOOL fResult;

        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType);

        LockStore(pStore);
        fResult = pPrevEle->dwFlags & ELEMENT_FIND_NEXT_FLAG;
        if (fResult) {
            assert(dwStoreProvFindIndex <
                pStore->StoreProvInfo.cStoreProvFunc &&
                pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]);
            pvProvInfo = pPrevEle->External.pvProvInfo;
            pPrevEle->External.pvProvInfo = NULL;
            pPrevEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
            pPrevProvEle = pPrevEle->pEle;
            assert(pPrevProvEle);
        }
        UnlockStore(pStore);
        if (!fResult)
            goto InvalidExternalFindNext;
    } else {
        pvProvInfo = NULL;
        pPrevProvEle = NULL;
    }


    // Check if external store supports the context type
    if (dwStoreProvFindIndex >= pStore->StoreProvInfo.cStoreProvFunc ||
        NULL == (pfnStoreProvFind = (PFN_CERT_STORE_PROV_FIND_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]))
        goto ProvFindNotSupported;

    pProvCertContext = NULL;
    if (!pfnStoreProvFind(
            pStore->StoreProvInfo.hStoreProv,
            pFindInfo,
            ToCertContext(pPrevProvEle),
            0,                      // dwFlags
            &pvProvInfo,
            &pProvCertContext) || NULL == pProvCertContext)
        goto ErrorReturn;

    InitAndAddExternalElement(
        pEle,
        pStore,
        ToContextElement(pProvCertContext),
        ELEMENT_FIND_NEXT_FLAG,
        pvProvInfo
        );

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    if (pEle) {
        FreeLinkElement(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidExternalFindNext, E_INVALIDARG)
SET_ERROR(ProvFindNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(CreateLinkElementError)
}

STATIC PCONTEXT_ELEMENT FindElementInCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fFindForAdd = FALSE
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCOLLECTION_STACK_ENTRY pStack = NULL;

    if (pPrevEle) {
        // Get previous element's collection stack

        if (pPrevEle->pStore != pCollection ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;

        LockStore(pCollection);
        pStack = pPrevEle->Collection.pCollectionStack;
        pPrevEle->Collection.pCollectionStack = NULL;
        UnlockStore(pCollection);

        if (NULL == pStack)
            goto InvalidCollectionFindNext;

        // Note, pStack->pCollection is only equal to pCollection
        // for a single level collection.
        assert(pStack->pStoreLink);
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType ||
            ELEMENT_TYPE_COLLECTION == pPrevEle->dwElementType);
    } else {
        // Initialize collection stack with the collection store's
        // first link
        if (!PushCollectionStack(&pStack, pCollection))
            goto PushStackError;
    }

    while (pStack) {
        PCERT_STORE pStackCollectionStore;
        PCERT_STORE_LINK pStoreLink;
        PCERT_STORE pFindStore;

        pStackCollectionStore = pStack->pCollection;
        pStoreLink = pStack->pStoreLink;    // may be NULL
        if (NULL == pPrevEle) {
            LockStore(pStackCollectionStore);

            // Advance past any deleted store links
            //
            // Also if doing a find before doing an add to a collection,
            // check that the store link allows an ADD
            while (pStoreLink &&
                ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                    (fFindForAdd && 0 == (pStoreLink->dwUpdateFlags &
                        CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))))
                pStoreLink = pStoreLink->pNext;
            if (pStoreLink && pStoreLink != pStack->pStoreLink)
                AddRefStoreLink(pStoreLink);

            UnlockStore(pStackCollectionStore);

            if (NULL == pStoreLink) {
                // Reached end of collection's store links
                PopCollectionStack(&pStack);
                continue;
            } else if (pStoreLink != pStack->pStoreLink) {
                ReleaseStoreLink(pStack->pStoreLink);
                pStack->pStoreLink = pStoreLink;
            }
        }

        assert(pStoreLink);
        pFindStore = pStoreLink->pSibling;
        if (STORE_TYPE_COLLECTION == pFindStore->dwStoreType) {
            assert(NULL == pPrevEle);
            // Add inner collection store to stack
            if (!PushCollectionStack(&pStack, pFindStore))
                goto PushStackError;
        } else if (STORE_TYPE_CACHE == pFindStore->dwStoreType ||
                STORE_TYPE_EXTERNAL == pFindStore->dwStoreType) {
            PCONTEXT_ELEMENT pPrevSiblingEle;
            PCONTEXT_ELEMENT pSiblingEle;

            if (pPrevEle) {
                assert(ELEMENT_TYPE_COLLECTION ==
                    pPrevEle->dwElementType);
                pPrevSiblingEle = pPrevEle->pEle;
                // FindElementInCacheStore or FindElementInExternalStore
                // does an implicit Free
                AddRefContextElement(pPrevSiblingEle);
            } else
                pPrevSiblingEle = NULL;

            if (pSiblingEle = FindElementInStore(
                    pFindStore,
                    dwContextType,
                    pFindInfo,
                    pPrevSiblingEle
                    )) {
                if (NULL == (pEle =
                        CreateLinkElement(dwContextType))) {
                    ReleaseContextElement(pSiblingEle);
                    goto CreateLinkElementError;
                }

                InitAndAddCollectionElement(
                    pEle,
                    pCollection,
                    pSiblingEle,
                    pStack
                    );
                goto CommonReturn;
            }

            if (pPrevEle) {
                ReleaseContextElement(pPrevEle);
                pPrevEle = NULL;
            }

            // Advance to the next store link in the collection
            AdvanceToNextStackStoreLink(pStack);
        } else
            goto InvalidStoreType;
    }
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;
ErrorReturn:
    ClearCollectionStack(pStack);
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidCollectionFindNext, E_INVALIDARG)
TRACE_ERROR(PushStackError)
TRACE_ERROR(CreateLinkElementError)
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return FindElementInCacheStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return FindElementInExternalStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return FindElementInCollectionStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}


STATIC void AutoResyncStore(
    IN PCERT_STORE pStore
    )
{
    if (pStore->hAutoResyncEvent) {
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx(
                pStore->hAutoResyncEvent,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                ))
            CertControlStore(
                (HCERTSTORE) pStore,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
                CERT_STORE_CTRL_RESYNC,
                &pStore->hAutoResyncEvent
                );

    } else if (STORE_TYPE_COLLECTION == pStore->dwStoreType) {
        // Iterate through all the siblings and attempt to AutoResync

        PCERT_STORE_LINK pStoreLink;
        PCERT_STORE_LINK pPrevStoreLink = NULL;

        LockStore(pStore);
        pStoreLink = pStore->pStoreListHead;
        for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
            // Advance past deleted store link
            if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
                continue;

            AddRefStoreLink(pStoreLink);
            UnlockStore(pStore);

            if (pPrevStoreLink)
                ReleaseStoreLink(pPrevStoreLink);
            pPrevStoreLink = pStoreLink;

            AutoResyncStore(pStoreLink->pSibling);

            LockStore(pStore);
        }
        UnlockStore(pStore);

        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
    }
}

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    if (NULL == pPrevEle)
        AutoResyncStore(pStore);

    return FindElementInStore(
        pStore,
        dwContextType,
        pFindInfo,
        pPrevEle
        );
}

//+=========================================================================
//  Add Element Functions
//==========================================================================

STATIC void SetFindInfoToFindExisting(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT PCERT_STORE_PROV_FIND_INFO pFindInfo
    )
{
    memset(pFindInfo, 0, sizeof(*pFindInfo));
    pFindInfo->cbSize = sizeof(*pFindInfo);
    pFindInfo->dwFindType = rgdwFindTypeToFindExisting[pEle->dwContextType];
    pFindInfo->pvFindPara = ToCertContext(pEle);
}


STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pLinkEle = NULL;
    PCONTEXT_ELEMENT pGetEle = NULL;

    if (STORE_TYPE_CACHE != pStore->dwStoreType)
        goto InvalidStoreType;

    // Note, CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES or
    // CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
    // isn't allowed for adding links
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition))
        goto InvalidAddDisposition;

    LockStore(pStore);
    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);
            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_NEWER:
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
                // fall through
            case CERT_STORE_ADD_REPLACE_EXISTING:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddLinkContextToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_USE_EXISTING:
                if (ppStoreEle)
                    *ppStoreEle = pGetEle;
                else
                    ReleaseContextElement(pGetEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
        }
    }

    if (NULL == (pLinkEle = CreateLinkElement(pEle->dwContextType))) {
        UnlockStore(pStore);
        goto CreateLinkElementError;
    }

    AddRefContextElement(pEle);

    InitAndAddLinkContextElement(
        pLinkEle,
        pStore,
        pEle
        );
    if (ppStoreEle) {
        AddRefContextElement(pLinkEle);
        *ppStoreEle = pLinkEle;
    }
    UnlockStore(pStore);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidStoreType, E_INVALIDARG)
SET_ERROR(InvalidAddDisposition, E_INVALIDARG)
SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CreateLinkElementError)
}

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the cache store.
STATIC BOOL AddElementToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle;
    PCERT_STORE pCollectionStore = NULL;
    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;

    BOOL fUpdateKeyId;

    LockStore(pStore);
    assert(STORE_STATE_DELETED != pStore->dwState &&
        STORE_STATE_CLOSED != pStore->dwState);
    if (STORE_STATE_NULL == pStore->dwState) {
        // CertCreate*Context, CertAddSerializedElementToStore
        // or CertAddEncoded*ToStore with hCertStore == NULL.
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
        dwAddDisposition = CERT_STORE_ADD_ALWAYS;
    }
    assert(CERT_STORE_ADD_NEW == dwAddDisposition ||
        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
            dwAddDisposition ||
        CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
        CERT_STORE_ADD_NEWER == dwAddDisposition ||
        CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition);

    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }

            if (CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
                        dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                // If element in the store isn't identical to the one being
                // added, then, inherit properties from and delete the
                // element in the store.
                if (!IsIdenticalContextElement(pEle, pGetEle)) {
                    if (!CopyProperties(
                            pGetEle,
                            pEle,
                            COPY_PROPERTY_USE_EXISTING_FLAG |
                                COPY_PROPERTY_INHIBIT_PROV_SET_FLAG
                            ))
                        goto CopyPropertiesError;
                    dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                }
            }


            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_NEWER:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddElementToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
                // For USE_EXISTING, copy any new non-existing properties.
                // Otherwise, copy all properties, replacing existing
                // properties.
                if (!CopyProperties(
                        pEle,
                        pGetEle,
                        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ?
                            COPY_PROPERTY_USE_EXISTING_FLAG : 0
                        ))
                    goto CopyPropertiesError;
                if (ppStoreEle) {
                    if (pStore != pEle->pStore) {
                        assert(STORE_TYPE_COLLECTION ==
                            pEle->pStore->dwStoreType);
                        if (NULL == (*ppStoreEle = CreateLinkElement(
                                pEle->dwContextType)))
                            goto CreateLinkElementError;
                        InitAndAddCollectionElement(
                            *ppStoreEle,
                            pEle->pStore,
                            pGetEle,
                            NULL                // pCollectionStack
                            );
                    } else
                        *ppStoreEle = pGetEle;
                } else
                    ReleaseContextElement(pGetEle);
                FreeContextElement(pEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
        }
    }


    // The element doesn't exist in the store.
    // Check if we need to write through to the provider.
    if (pStore->StoreProvInfo.cStoreProvFunc >
            dwStoreProvWriteIndex  &&
        NULL != (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex])) {
        // Don't ever call the provider holding a lock!!
        // Also, the caller is holding a reference count on the store.
        UnlockStore(pStore);
        if (!pfnStoreProvWriteCert(
                pStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle),
                (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG))
            goto StoreProvWriteError;
        LockStore(pStore);
        if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
            // Check if the certificate was added while the store was unlocked
            CERT_STORE_PROV_FIND_INFO FindInfo;

            // Check if the context element is already in the store
            SetFindInfoToFindExisting(pEle, &FindInfo);
            if (pGetEle = FindElementInCacheStore(
                    pStore,
                    pEle->dwContextType,
                    &FindInfo,
                    NULL                // pPrevEle
                    )) {
                // Try again
                UnlockStore(pStore);
                ReleaseContextElement(pGetEle);
                return AddElementToCacheStore(pStore, pEle, dwAddDisposition,
                    ppStoreEle);
            }
        }
    }

    pCollectionEle = NULL;
    fUpdateKeyId = (pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) &&
        STORE_STATE_OPENING != pStore->dwState;
    if (pStore != pEle->pStore) {
        assert(STORE_TYPE_COLLECTION == pEle->pStore->dwStoreType);
        if (ppStoreEle) {
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType))) {
                UnlockStore(pStore);
                goto CreateLinkElementError;
            }
            pCollectionStore = pEle->pStore;
        }

        // Update the element's store. This is needed when adding to a store in
        // a collection
        pEle->pProvStore = pStore;
        pEle->pStore = pStore;
        SetStoreHandle(pEle);
    }

    if (FindPropElement(pEle, CERT_ARCHIVED_PROP_ID))
        pEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    // Finally, add the element to the store.
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (pCollectionEle) {
        assert(pCollectionStore && ppStoreEle);
        AddRefContextElement(pEle);
        UnlockStore(pStore);
        InitAndAddCollectionElement(
            pCollectionEle,
            pCollectionStore,
            pEle,
            NULL                // pCollectionStack
            );
        *ppStoreEle = pCollectionEle;
    } else {
        if (STORE_STATE_NULL == pStore->dwState) {
            if (ppStoreEle)
                // Since the NULL store doesn't hold a reference, use it.
                *ppStoreEle = pEle;
            else
                ReleaseContextElement(pEle);
        } else if (ppStoreEle) {
            AddRefContextElement(pEle);
            *ppStoreEle = pEle;
        }
        UnlockStore(pStore);
    }
    fResult = TRUE;

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

CommonReturn:
    return fResult;

ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CopyPropertiesError)
TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
}


// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// The caller is holding a reference count on the store
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the external store.
STATIC BOOL AddElementToExternalStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;

    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;
    PCONTEXT_ELEMENT pExternalEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle = NULL;
    PCERT_STORE pEleStore;
    BOOL fUpdateKeyId;

    // Check if the store supports the write callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            dwStoreProvWriteIndex  ||
        NULL == (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex]))
        goto ProvWriteNotSupported;

    // Remember the Element's store.
    pEleStore = pEle->pStore;
    fUpdateKeyId = pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG;
    if (ppStoreEle) {
        if (NULL == (pExternalEle = CreateLinkElement(pEle->dwContextType)))
            goto CreateLinkElementError;
        if (pStore != pEleStore) {
            assert(STORE_TYPE_COLLECTION == pEleStore->dwStoreType);
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType)))
                goto CreateLinkElementError;
        }
    }

    // Update the Element to use the NULL store.
    pEle->pProvStore = &NullCertStore;
    pEle->pStore = &NullCertStore;
    SetStoreHandle(pEle);

    // Also, the caller is holding a reference count on the store.
    if (!pfnStoreProvWriteCert(
            pStore->StoreProvInfo.hStoreProv,
            ToCertContext(pEle),
            (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG)) {
        // Restore the Element's store
        pEle->pProvStore = pEleStore;
        pEle->pStore = pEleStore;
        SetStoreHandle(pEle);
        goto StoreProvWriteError;
    }

    // Add to the NULL store
    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (ppStoreEle) {
        InitAndAddExternalElement(
            pExternalEle,
            pStore,                 // pProvStore
            pEle,
            0,                      // dwFlags
            NULL                    // pvProvInfo
            );
        if (pStore != pEleStore) {
            InitAndAddCollectionElement(
                pCollectionEle,
                pEleStore,
                pExternalEle,
                NULL                // pCollectionStack
                );
            *ppStoreEle = pCollectionEle;
        } else
            *ppStoreEle = pExternalEle;
    } else
        ReleaseContextElement(pEle);

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pExternalEle)
        FreeLinkElement(pExternalEle);
    if (pCollectionEle)
        FreeLinkElement(pCollectionEle);
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
SET_ERROR(ProvWriteNotSupported, E_NOTIMPL)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToCollectionStore(
    IN PCERT_STORE pCollection,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCERT_STORE pOuterCollection;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;
    DWORD dwAddErr;

    pOuterCollection = pEle->pStore;

    // Only need to do the find once for the outer most collection
    if (pOuterCollection == pCollection &&
            CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in any of the collection's
        // stores
        SetFindInfoToFindExisting(pEle, &FindInfo);

        if (pGetEle = FindElementInCollectionStore(
                pCollection,
                pEle->dwContextType,
                &FindInfo,
                NULL,               // pPrevEle
                FALSE               // fFindForAdd
                )) {

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }

            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
            case CERT_STORE_ADD_NEWER:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
                // For success pEle will be used or freed by the called function
                // Add to either the cache or external store

                assert(STORE_TYPE_CACHE == pGetEle->pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pGetEle->pProvStore->dwStoreType);
                fResult = AddElementToStore(
                    pGetEle->pProvStore,
                    pEle,
                    dwAddDisposition,
                    ppStoreEle
                    );
                goto CommonReturn;
            default:
                goto InvalidArg;
                break;
            }
        }
    }

    // The element doesn't exist in any of the collection's stores.

    // Iterate and try to add to first where adding is allowed

    LockStore(pCollection);
    dwAddErr = (DWORD) E_ACCESSDENIED;
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store links and links not enabling adds
        if ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                0 == (pStoreLink->dwUpdateFlags &
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (AddElementToStore(
                pStoreLink->pSibling,
                pEle,
                dwAddDisposition,
                ppStoreEle
                )) {
            fResult = TRUE;
            goto CommonReturn;
        } else if (E_ACCESSDENIED == dwAddErr) {
            DWORD dwErr = GetLastError();
            if (0 != dwErr)
                dwAddErr = dwErr;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);
    goto NoAddEnabledStore;

CommonReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);
    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(NoAddEnabledStore, dwAddErr)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the inner store
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    // Check for valid disposition values
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
                dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition ||
            CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition)) {
        *ppStoreEle = NULL;
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return AddElementToCacheStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return AddElementToExternalStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return AddElementToCollectionStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pStore)
        pStore = &NullCertStore;

    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;

    // If pbEncoded is a MappedFile, the following copy may raise
    // an exception
    memcpy(pbAllocEncoded, pbEncoded, cbEncoded);

    if (NULL == (pEle = rgpfnCreateElement[dwContextType](
            pStore,
            dwCertEncodingType,
            pbAllocEncoded,
            cbEncoded,
            NULL                    // pShareEle
            )))
        goto CreateElementError;

    if (!AddElementToStore(
            pStore,
            pEle,
            dwAddDisposition,
            ppStoreEle
            ))
        goto AddElementError;

    fResult = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    return fResult;

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else
        PkiFree(pbAllocEncoded);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pStore)
        pStore = &NullCertStore;

    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;

    // If pbEncoded is a MappedFile, the following copy may raise
    // an exception
    memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
    if (NULL == (pEle = rgpfnCreateElement[pSrcEle->dwContextType](
                pStore,
                dwCertEncodingType,
                pbAllocEncoded,
                cbEncoded,
                NULL                    // pShareEle
                )))
        goto CreateElementError;

    if (!CopyProperties(
                pSrcEle,
                pEle,
                COPY_PROPERTY_INHIBIT_PROV_SET_FLAG
                ))
        goto CopyPropertiesError;

    if (!AddElementToStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                ))
        goto AddElementError;

    fResult = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    return fResult;

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else
        PkiFree(pbAllocEncoded);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(CopyPropertiesError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================

// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    PPROP_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PPROP_ELEMENT) PkiZeroAlloc(sizeof(PROP_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->dwPropId = dwPropId;
    pEle->dwFlags = dwFlags;
    pEle->pbData = pbData;
    pEle->cbData = cbData;
    pEle->pNext = NULL;
    pEle->pPrev = NULL;

    return pEle;
}

STATIC void FreePropElement(IN PPROP_ELEMENT pEle)
{
    if (pEle->dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        HCRYPTPROV hProv = ((PCERT_KEY_CONTEXT) pEle->pbData)->hCryptProv;
        if (hProv && (pEle->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0) {
            DWORD dwErr = GetLastError();
            CryptReleaseContext(hProv, 0);
            SetLastError(dwErr);
        }
    }
    PkiFree(pEle->pbData);
    PkiFree(pEle);
}

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    )
{
    while (pPropEle) {
        if (pPropEle->dwPropId == dwPropId)
            return pPropEle;
        pPropEle = pPropEle->pNext;
    }

    return NULL;
}
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    return FindPropElement(pCacheEle->Cache.pPropHead, dwPropId);
}

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    // Insert property in the certificate/CRL/CTL's list of properties
    pPropEle->pNext = *ppPropHead;
    pPropEle->pPrev = NULL;
    if (*ppPropHead)
        (*ppPropHead)->pPrev = pPropEle;
    *ppPropHead = pPropEle;
}
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    AddPropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    if (pPropEle->pNext)
        pPropEle->pNext->pPrev = pPropEle->pPrev;
    if (pPropEle->pPrev)
        pPropEle->pPrev->pNext = pPropEle->pNext;
    else if (pPropEle == *ppPropHead)
        *ppPropHead = pPropEle->pNext;
    // else
    //  Not on any list
}
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    RemovePropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


//+=========================================================================
//  Property Functions
//==========================================================================

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;

    // Delete the property
    pPropEle = FindPropElement(*ppPropHead, dwPropId);
    if (pPropEle) {
        RemovePropElement(ppPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
}
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    DeleteProperty(&pCacheEle->Cache.pPropHead, dwPropId);
}

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_CONTEXT KeyContext;

    if (dwPropId == 0 || dwPropId > CERT_LAST_USER_PROP_ID) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (dwFlags & CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG)
        fInhibitProvSet = TRUE;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // Map to the CERT_KEY_CONTEXT_PROP_ID and update its
        // hCryptProv and/or dwKeySpec field(s).
        DWORD cbData = sizeof(KeyContext);
        if ((fResult = GetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                &KeyContext,
                &cbData))) {
            if (dwPropId == CERT_KEY_SPEC_PROP_ID) {
                // Inhibit hCryptProv from being closed by the subsequent
                // DeleteProperty. Also, use the existing dwFlags.
                pPropEle = FindPropElement(pCacheEle,
                    CERT_KEY_CONTEXT_PROP_ID);
                assert(pPropEle);
                if (pPropEle) {
                    dwFlags = pPropEle->dwFlags;
                    pPropEle->dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
                }
            }
        } else {
            memset(&KeyContext, 0, sizeof(KeyContext));
            KeyContext.cbSize = sizeof(KeyContext);
            if (pvData && dwPropId != CERT_KEY_SPEC_PROP_ID) {
                // Try to get the KeySpec from a CERT_KEY_PROV_INFO_PROP_ID.
                // Need to do without any locks.
                UnlockStore(pCacheStore);
                cbData = sizeof(DWORD);
                GetProperty(
                    pEle,
                    CERT_KEY_SPEC_PROP_ID,
                    &KeyContext.dwKeySpec,
                    &cbData);
                LockStore(pCacheStore);

                // Check if CERT_KEY_CONTEXT_PROP_ID was added while store
                // was unlocked.
                if (FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
                    // We now have a CERT_KEY_CONTEXT_PROP_ID property.
                    // Try again
                    UnlockStore(pCacheStore);
                    return SetProperty(
                        pEle,
                        dwPropId,
                        dwFlags,
                        pvData,
                        fInhibitProvSet
                        );
                }
            }
        }
        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            KeyContext.hCryptProv = (HCRYPTPROV) pvData;
        } else {
            if (pvData)
                KeyContext.dwKeySpec = *((DWORD *) pvData);
            else
                KeyContext.dwKeySpec = 0;
        }
        if (fResult || pvData)
            // CERT_KEY_CONTEXT_PROP_ID exists or we are creating a
            // new CERT_KEY_CONTEXT_PROP_ID
            pvData = &KeyContext;
        dwPropId = CERT_KEY_CONTEXT_PROP_ID;
    } else if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        if (pvData) {
            PCERT_KEY_CONTEXT pKeyContext = (PCERT_KEY_CONTEXT) pvData;
            if (pKeyContext->cbSize != sizeof(CERT_KEY_CONTEXT))
                goto InvalidArg;
        }
    } else if (!fInhibitProvSet) {
        // Check if we need to call the store provider's writethru function.
        // Note, since the above properties aren't persisted they don't
        // need to be checked.

        const DWORD dwStoreProvSetPropertyIndex =
            rgdwStoreProvSetPropertyIndex[pEle->dwContextType];
        PCERT_STORE pProvStore = pEle->pProvStore;
        PFN_CERT_STORE_PROV_SET_CERT_PROPERTY pfnStoreProvSetProperty;

        // Use provider store. May be in a collection.
        UnlockStore(pCacheStore);
        LockStore(pProvStore);

        if (dwStoreProvSetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
            NULL != (pfnStoreProvSetProperty =
                (PFN_CERT_STORE_PROV_SET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvSetPropertyIndex])) {
            // Since we can't hold a lock while calling the provider function,
            // bump the store's provider reference count to inhibit the closing
            // of the store and freeing of the provider functions.
            //
            // When the store is closed, pStore->StoreProvInfo.cStoreProvFunc
            // is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);
#if 0
            // Slow down the provider while holding the provider reference
            // count.
            Sleep(1500);
#endif

            // Note: PFN_CERT_STORE_PROV_SET_CRL_PROPERTY has the same signature
            // except, PCCRL_CONTEXT replaces the PCCERT_CONTEXT parameter.
            fResult = pfnStoreProvSetProperty(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    dwPropId,
                    dwFlags,
                    pvData);
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
            if (!fResult && !IS_CERT_HASH_PROP_ID(dwPropId) &&
                    !IS_CHAIN_HASH_PROP_ID(dwPropId) &&
                    0 == (dwFlags & CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG))
                goto StoreProvSetCertPropertyError;
            // else
            //  Silently ignore any complaints about setting the
            //  property.
        } else {
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
        }
    }

    if (pvData != NULL) {
        // First, delete the property
        DeleteProperty(pCacheEle, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
            cbEncoded = sizeof(CERT_KEY_CONTEXT);
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            memcpy(pbEncoded, (BYTE *) pvData, cbEncoded);
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) goto CreatePropElementError;
        AddPropElement(pCacheEle, pPropEle);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    } else {
        // Delete the property
        DeleteProperty(pCacheEle, dwPropId);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags &= ~ELEMENT_ARCHIVED_FLAG;
    }

    fResult = TRUE;
CommonReturn:
    UnlockStore(pCacheStore);

    if (fResult && pvData && !fInhibitProvSet &&
            ((pCacheStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) ||
                (pEle->pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG)))
        SetCryptKeyIdentifierKeyProvInfoProperty(
            pEle,
            dwPropId,
            pvData
            );
    return fResult;

ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(StoreProvSetCertPropertyError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(CreatePropElementError)
}

STATIC BOOL AllocAndGetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void **ppvData,
    OUT DWORD *pcbData
    )
{
    BOOL fResult;
    void *pvData = NULL;
    DWORD cbData;
    if (!GetProperty(
            pEle,
            dwPropId,
            NULL,               // pvData
            &cbData)) goto GetPropertyError;
    if (cbData) {
        if (NULL == (pvData = PkiNonzeroAlloc(cbData))) goto OutOfMemory;
        if (!GetProperty(
                pEle,
                dwPropId,
                pvData,
                &cbData)) goto GetPropertyError;
    }
    fResult = TRUE;
CommonReturn:
    *ppvData = pvData;
    *pcbData = cbData;
    return fResult;

ErrorReturn:
    PkiFree(pvData);
    pvData = NULL;
    cbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetPropertyError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//
//  Note the pEle's cache store may be locked on entry by the above
//  SetProperty for a CERT_KEY_CONTEXT_PROP_ID.
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCERT_STORE pProvStore;
    DWORD cbIn;

    if (pvData == NULL)
        cbIn = 0;
    else
        cbIn = *pcbData;
    *pcbData = 0;

    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // These two properties are fields within CERT_KEY_CONTEXT_PROP_ID.

        BOOL fResult;
        CERT_KEY_CONTEXT KeyContext;
        DWORD cbData;
        BYTE *pbData;

        cbData = sizeof(KeyContext);
        fResult = GetProperty(
            pEle,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbData
            );
        if (fResult && sizeof(KeyContext) != cbData) {
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
            fResult = FALSE;
        }

        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            cbData = sizeof(HCRYPTPROV);
            pbData = (BYTE *) &KeyContext.hCryptProv;
        } else {
            if (!fResult) {
                // Try to get the dwKeySpec from the CERT_KEY_PROV_INFO_PROP_ID
                PCRYPT_KEY_PROV_INFO pInfo;
                if (fResult = AllocAndGetProperty(
                        pEle,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        (void **) &pInfo,
                        &cbData)) {
                    KeyContext.dwKeySpec = pInfo->dwKeySpec;
                    PkiFree(pInfo);
                }
            }
            cbData = sizeof(DWORD);
            pbData = (BYTE *) &KeyContext.dwKeySpec;
        }

        if (fResult) {
            *pcbData = cbData;
            if (cbIn < cbData) {
                if (pvData) {
                    SetLastError((DWORD) ERROR_MORE_DATA);
                    fResult = FALSE;
                }
            } else if (cbData)
                memcpy((BYTE *) pvData, pbData, cbData);
        }
        return fResult;
    } else if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;

        pProvStore = pEle->pProvStore;
        if ((pProvStore->dwFlags & CERT_STORE_READONLY_FLAG) ||
                (pProvStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
            dwAccessStateFlags = 0;
        else
            dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;

        if ((pEle->pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG) ||
            (pProvStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG))
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        *pcbData = sizeof(DWORD);
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                return FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        return TRUE;
    }

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    PPROP_ELEMENT pPropEle = FindPropElement(pCacheEle, dwPropId);
    if (pPropEle) {
        BOOL fResult;
        DWORD cbData = pPropEle->cbData;

        if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            *pcbData = cbIn;
            fResult = DecodeKeyProvInfo(
                (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
                cbData,
                (PCRYPT_KEY_PROV_INFO) pvData,
                pcbData
                );
        } else {
            fResult = TRUE;
            if (cbIn < cbData) {
                if (pvData) {
                    SetLastError((DWORD) ERROR_MORE_DATA);
                    fResult = FALSE;
                }
            } else if (cbData)
                memcpy((BYTE *) pvData, pPropEle->pbData, cbData);
            *pcbData = cbData;
        }
        UnlockStore(pCacheStore);
        return fResult;
    } else
        UnlockStore(pCacheStore);

    // We're here with property not found and store unlocked.

    // For CERT_*_HASH_PROP_ID: compute its hash and do a SetProperty
    // Also, compute the MD5 hash of the public key bits.
    if (IS_CERT_HASH_PROP_ID(dwPropId)
                    ||
            ((CERT_STORE_CERTIFICATE_CONTEXT - 1) == pEle->dwContextType
                                &&
                (CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID == dwPropId ||
                    CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID == dwPropId ||
                    CERT_SUBJECT_NAME_MD5_HASH_PROP_ID == dwPropId))) {
        BOOL fResult;
        PCERT_STORE pEleStore;

        BYTE *pbEncoded;
        DWORD cbEncoded;
        BYTE Hash[MAX_HASH_LEN];
        CRYPT_DATA_BLOB HashBlob;

        BYTE *pbAlloc = NULL;


        switch (dwPropId) {
        case CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID:
            {
                PCRYPT_BIT_BLOB pPublicKey;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pPublicKey =
                    &(ToCertContext(pEle)->pCertInfo->SubjectPublicKeyInfo.PublicKey);
                pbEncoded = pPublicKey->pbData;
                cbEncoded = pPublicKey->cbData;
            }
            break;
        case CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID:
            {
                PCERT_NAME_BLOB pIssuer;
                PCRYPT_INTEGER_BLOB pSerialNumber;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pIssuer = &(ToCertContext(pEle)->pCertInfo->Issuer);
                pSerialNumber = &(ToCertContext(pEle)->pCertInfo->SerialNumber);

                cbEncoded = pIssuer->cbData + pSerialNumber->cbData;
                if (0 == cbEncoded)
                    pbAlloc = NULL;
                else {
                    if (NULL == (pbAlloc = (BYTE *) PkiNonzeroAlloc(
                            cbEncoded)))
                        return FALSE;

                    if (pIssuer->cbData)
                        memcpy(pbAlloc, pIssuer->pbData, pIssuer->cbData);
                    if (pSerialNumber->cbData)
                        memcpy(pbAlloc + pIssuer->cbData,
                            pSerialNumber->pbData, pSerialNumber->cbData);
                }

                pbEncoded = pbAlloc;
            }
            break;
        case CERT_SUBJECT_NAME_MD5_HASH_PROP_ID:
            {
                PCERT_NAME_BLOB pSubject;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pSubject = &(ToCertContext(pEle)->pCertInfo->Subject);
                pbEncoded = pSubject->pbData;
                cbEncoded = pSubject->cbData;
            }
            break;
        default:
            GetContextEncodedInfo(
                pEle,
                &pbEncoded,
                &cbEncoded
                );
        }

        pEleStore = pEle->pStore;

        HashBlob.pbData = Hash;
        HashBlob.cbData = sizeof(Hash);
        if (CERT_SIGNATURE_HASH_PROP_ID == dwPropId)
            fResult = CryptHashToBeSigned(
                0,                              // hCryptProv
                GetContextEncodingType(pEle),
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);
        else
            fResult = CryptHashCertificate(
                0,                              // hCryptProv
                dwPropId == CERT_SHA1_HASH_PROP_ID ? CALG_SHA1 : CALG_MD5,
                0,                  //dwFlags
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);

        if (pbAlloc)
            PkiFree(pbAlloc);

        if (!fResult) {
            assert(HashBlob.cbData <= MAX_HASH_LEN);
            return FALSE;
        }
        assert(HashBlob.cbData);
        if (HashBlob.cbData == 0)
            return FALSE;
        if (!SetProperty(
                pEle,
                dwPropId,
                0,                      // dwFlags
                &HashBlob
                )) return FALSE;

        *pcbData = cbIn;
        return GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    } else if (CERT_KEY_IDENTIFIER_PROP_ID == dwPropId) {
        *pcbData = cbIn;
        return GetKeyIdProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    }

    // We're here with property not found and not a hash or KeyId property

    // Since the cache store may be locked when called from SetProperty for
    // a CERT_KEY_CONTEXT_PROP_ID and since this property isn't persisted,
    // don't look in the external store for this property.
    pProvStore = pEle->pProvStore;
    if (STORE_TYPE_EXTERNAL == pProvStore->dwStoreType &&
            CERT_KEY_CONTEXT_PROP_ID != dwPropId) {
        // Check if provider supports getting a non-cached property
        const DWORD dwStoreProvGetPropertyIndex =
            rgdwStoreProvGetPropertyIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_GET_CERT_PROPERTY pfnStoreProvGetProperty;

        LockStore(pProvStore);
        if (dwStoreProvGetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
                    NULL != (pfnStoreProvGetProperty =
                        (PFN_CERT_STORE_PROV_GET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvGetPropertyIndex])) {
            BOOL fResult;

            // Since we can't hold a lock while calling the provider
            // function, bump the store's provider reference count
            // to inhibit the closing of the store and freeing of
            // the provider functions.
            //
            // When the store is closed,
            // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);

            *pcbData = cbIn;
            fResult = pfnStoreProvGetProperty(
                pProvStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle->pEle),
                dwPropId,
                0,                  // dwFlags
                pvData,
                pcbData
                );
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            return fResult;
        }
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    fResult = TRUE;
    for (pPropEle = pCacheEle->Cache.pPropHead; pPropEle;
                                            pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if(!WriteStoreElement(
                    h,
                    pfn,
                    GetContextEncodingType(pCacheEle),
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    )) {
                fResult = FALSE;
                break;
            }
        }
    }
    UnlockStore(pCacheStore);
    return(fResult);
}

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element.
//
//  Only enumerates cached properties. Doesn't try to enumerate any external
//  properties.
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return 0;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (0 == dwPropId)
        pPropEle = pCacheEle->Cache.pPropHead;
    else {
        pPropEle = FindPropElement(pCacheEle, dwPropId);
        if (pPropEle)
            pPropEle = pPropEle->pNext;
    }

    if (pPropEle)
        dwPropId = pPropEle->dwPropId;
    else
        dwPropId = 0;
    UnlockStore(pCacheStore);
    return dwPropId;
}

STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwPropId;

    if (dwFlags & COPY_PROPERTY_SYNC_FLAG) {
        // Delete any properties from the Dst element that don't exist
        // in the Src element.

        DWORD dwNextPropId;
        dwNextPropId = EnumProperties(pDstEle, 0);
        while (dwNextPropId) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pSrcCacheEle;
            PCERT_STORE pSrcCacheStore;
            PCONTEXT_ELEMENT pDstCacheEle;
            PCERT_STORE pDstCacheStore;

            dwPropId = dwNextPropId;
            dwNextPropId = EnumProperties(pDstEle, dwNextPropId);

            // Don't delete hCryptProv or KeySpec or hash properties
            if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                    IS_CERT_HASH_PROP_ID(dwPropId) ||
                    IS_CHAIN_HASH_PROP_ID(dwPropId))
                continue;
#ifdef CMS_PKCS7
            if (CERT_PUBKEY_ALG_PARA_PROP_ID == dwPropId)
                continue;
#endif  // CMS_PKCS7

            if (NULL == (pSrcCacheEle = GetCacheElement(pSrcEle)))
                continue;
            pSrcCacheStore = pSrcCacheEle->pStore;

            // Don't delete if the src also has the property
            LockStore(pSrcCacheStore);
            pPropEle = FindPropElement(pSrcCacheEle, dwPropId);
            UnlockStore(pSrcCacheStore);
            if (pPropEle)
                continue;

            // Don't delete any non persisted properties
            if (NULL == (pDstCacheEle = GetCacheElement(pDstEle)))
                continue;
            pDstCacheStore = pDstCacheEle->pStore;

            LockStore(pDstCacheStore);
            pPropEle = FindPropElement(pDstCacheEle, dwPropId);
            UnlockStore(pDstCacheStore);
            if (NULL == pPropEle || 0 != (pPropEle->dwFlags &
                    CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG))
                continue;

            SetProperty(
                pDstEle,
                dwPropId,
                0,                              // dwFlags
                NULL,                           // NULL deletes
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
        }
    }

    fResult = TRUE;
    dwPropId = 0;
    while (dwPropId = EnumProperties(pSrcEle, dwPropId)) {
        void *pvData;
        DWORD cbData;

        // Don't copy hCryptProv or KeySpec
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId)
            continue;
        if (dwFlags & COPY_PROPERTY_USE_EXISTING_FLAG) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pDstCacheEle;
            PCERT_STORE pDstCacheStore;

            // For existing, don't copy any hash properties
            if (IS_CERT_HASH_PROP_ID(dwPropId) ||
                    IS_CHAIN_HASH_PROP_ID(dwPropId))
                continue;

            if (NULL == (pDstCacheEle = GetCacheElement(pDstEle)))
                continue;
            pDstCacheStore = pDstCacheEle->pStore;

            // Don't copy if the destination already has the property
            LockStore(pDstCacheStore);
            pPropEle = FindPropElement(pDstCacheEle, dwPropId);
            UnlockStore(pDstCacheStore);
            if (pPropEle)
                continue;
        }

        if (!AllocAndGetProperty(
                pSrcEle,
                dwPropId,
                &pvData,
                &cbData)) {
            if (CRYPT_E_NOT_FOUND == GetLastError()) {
                // Its been deleted after we did the Enum. Start over
                // from the beginning.
                dwPropId = 0;
                continue;
            } else {
                fResult = FALSE;
                break;
            }
        } else {
            CRYPT_DATA_BLOB DataBlob;
            void *pvSetData;

            if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId)
                pvSetData = pvData;
            else {
                DataBlob.pbData = (BYTE *) pvData;
                DataBlob.cbData = cbData;
                pvSetData = &DataBlob;
            }
            fResult = SetProperty(
                pDstEle,
                dwPropId,
                0,                                              // dwFlags
                pvSetData,
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
            if (pvData)
                PkiFree(pvData);
            if (!fResult)
                break;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//
//  Upon entry/exit, properties are locked by caller.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;
    DWORD cbData;
    void *pvDstData = NULL;
    DWORD cbDstData;

    if (NULL == (pPropEle = FindPropElement(pPropHead, dwPropId)))
        goto PropertyNotFound;

    if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
            dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID)
        goto InvalidPropId;

    cbData = pPropEle->cbData;
    if (fAlloc) {
        if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
                    cbData,
                    NULL,               // pInfo
                    &cbDstData
                    ))
                goto DecodeKeyProvInfoError;
        } else
            cbDstData = cbData;
        if (cbDstData) {
            if (NULL == (pvDstData = PkiDefaultCryptAlloc(cbDstData)))
                goto OutOfMemory;
        }
        *((void **) pvData) = pvDstData;
    } else {
        pvDstData = pvData;
        if (NULL == pvData)
            cbDstData = 0;
        else
            cbDstData = *pcbData;
    }

    if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
        fResult = DecodeKeyProvInfo(
            (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
            cbData,
            (PCRYPT_KEY_PROV_INFO) pvDstData,
            &cbDstData
            );
    } else {
        fResult = TRUE;
        if (pvDstData) {
            if (cbDstData < cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            } else if (cbData) {
                memcpy((BYTE *) pvDstData, pPropEle->pbData, cbData);
            }
        }
        cbDstData = cbData;
    }

    if (!fResult && fAlloc)
        goto UnexpectedError;

CommonReturn:
    *pcbData = cbDstData;
    return fResult;

ErrorReturn:
    if (fAlloc) {
        *((void **) pvData) = NULL;
        PkiDefaultCryptFree(pvDstData);
    }
    cbDstData = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(PropertyNotFound, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeKeyProvInfoError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;

    if (pvData != NULL) {
        DWORD cbEncoded = 0;
        BYTE *pbEncoded = NULL;
        PPROP_ELEMENT pPropEle;

        // First, delete the property
        DeleteProperty(ppPropHead, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
                dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            goto InvalidPropId;
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) {
            PkiFree(pbEncoded);
            goto CreatePropElementError;
        }
        AddPropElement(ppPropHead, pPropEle);
    } else
        // Delete the property
        DeleteProperty(ppPropHead, dwPropId);

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreatePropElementError)
}

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------
STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cbContainerName;
    DWORD cbProvName;

    PCRYPT_KEY_PROV_PARAM pParam;
    PSERIALIZED_KEY_PROV_INFO pDstInfo;
    DWORD Off;
    DWORD cParam;

    // Get overall length
    cbEncoded = sizeof(SERIALIZED_KEY_PROV_INFO) +
        pKeyProvInfo->cProvParam * sizeof(SERIALIZED_KEY_PROV_PARAM);

    for (cParam = pKeyProvInfo->cProvParam, pParam = pKeyProvInfo->rgProvParam;
                                            cParam > 0; cParam--, pParam++) {
        if (pParam->cbData)
            cbEncoded += ENCODE_LEN_ALIGN(pParam->cbData);
    }

    if (pKeyProvInfo->pwszContainerName) {
        cbContainerName = (wcslen(pKeyProvInfo->pwszContainerName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbContainerName);
    } else
        cbContainerName = 0;

    if (pKeyProvInfo->pwszProvName) {
        cbProvName = (wcslen(pKeyProvInfo->pwszProvName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbProvName);
    } else
        cbProvName = 0;

    assert(cbEncoded <= MAX_FILE_ELEMENT_DATA_LEN);

    // Allocate
    pbEncoded = (BYTE *) PkiZeroAlloc(cbEncoded);
    if (pbEncoded == NULL) {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    Off = sizeof(SERIALIZED_KEY_PROV_INFO);

    pDstInfo = (PSERIALIZED_KEY_PROV_INFO) pbEncoded;
    // pDstInfo->offwszContainerName
    // pDstInfo->offwszProvName;
    pDstInfo->dwProvType            = pKeyProvInfo->dwProvType;
    pDstInfo->dwFlags               = pKeyProvInfo->dwFlags;
    pDstInfo->cProvParam            = pKeyProvInfo->cProvParam;
    // pDstInfo->offrgProvParam;
    pDstInfo->dwKeySpec             = pKeyProvInfo->dwKeySpec;

    if (pKeyProvInfo->cProvParam) {
        PSERIALIZED_KEY_PROV_PARAM pDstParam;

        pDstParam = (PSERIALIZED_KEY_PROV_PARAM) (pbEncoded + Off);
        pDstInfo->offrgProvParam = Off;
        Off += pKeyProvInfo->cProvParam * sizeof(SERIALIZED_KEY_PROV_PARAM);

        for (cParam = pKeyProvInfo->cProvParam,
             pParam = pKeyProvInfo->rgProvParam;
                                        cParam > 0;
                                            cParam--, pParam++, pDstParam++) {
            pDstParam->dwParam = pParam->dwParam;
            // pDstParam->offbData
            pDstParam->cbData = pParam->cbData;
            pDstParam->dwFlags = pParam->dwFlags;
            if (pParam->cbData) {
                memcpy(pbEncoded + Off, pParam->pbData,  pParam->cbData);
                pDstParam->offbData = Off;
                Off += ENCODE_LEN_ALIGN(pParam->cbData);
            }
        }
    }

    if (cbContainerName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszContainerName,
            cbContainerName);
        pDstInfo->offwszContainerName = Off;
        Off += ENCODE_LEN_ALIGN(cbContainerName);
    }
    if (cbProvName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszProvName,
            cbProvName);
        pDstInfo->offwszProvName = Off;
        Off += ENCODE_LEN_ALIGN(cbProvName);
    }

    assert(Off == cbEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return TRUE;
}

STATIC BOOL DecodeKeyProvInfoString(
    IN BYTE *pbSerialized,
    IN DWORD cbSerialized,
    IN DWORD off,
    OUT LPWSTR *ppwsz,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemain
    )
{
    BOOL fResult;
    LONG lRemain = *plRemain;
    LPWSTR pwszDst = (LPWSTR) *ppbExtra;

    if (0 != off) {
        LPWSTR pwszSrc = (LPWSTR) (pbSerialized + off);
        LPWSTR pwszEnd = (LPWSTR) (pbSerialized + cbSerialized);

        if (0 <= lRemain)
            *ppwsz = pwszDst;

        while (TRUE) {
            if (pwszSrc + 1 > pwszEnd)
                goto InvalidData;
            lRemain -= sizeof(WCHAR);
            if (0 <= lRemain)
                *pwszDst++ = *pwszSrc;
            if (L'\0' == *pwszSrc++)
                break;
        }
    } else if (0 <= lRemain)
        *ppwsz = NULL;

    fResult = TRUE;
CommonReturn:
    *ppbExtra = (BYTE *) pwszDst;
    *plRemain = lRemain;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
SET_ERROR(InvalidData, ERROR_INVALID_DATA)
}


STATIC BOOL DecodeKeyProvInfo(
    IN PSERIALIZED_KEY_PROV_INFO pSerializedInfo,
    IN DWORD cbSerialized,
    OUT PCRYPT_KEY_PROV_INFO pInfo,
    OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    DWORD cParam;
    DWORD cbInfo;
    BYTE *pbSerialized;
    LONG lRemain;
    BYTE *pbExtra;
    DWORD dwExceptionCode;

    __try {

        if (sizeof(SERIALIZED_KEY_PROV_INFO) > cbSerialized)
            goto InvalidData;

        if (NULL == pInfo)
            cbInfo = 0;
        else
            cbInfo = *pcbInfo;
        lRemain = cbInfo;
        cParam = pSerializedInfo->cProvParam;
        pbSerialized = (BYTE *) pSerializedInfo;

        lRemain -= sizeof(CRYPT_KEY_PROV_INFO);
        if (0 <= lRemain) {
            pbExtra = (BYTE *) pInfo + sizeof(CRYPT_KEY_PROV_INFO);
            memset(pInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

            // pInfo->pwszContainerName
            // pInfo->pwszProvName
            pInfo->dwProvType = pSerializedInfo->dwProvType;
            pInfo->dwFlags = pSerializedInfo->dwFlags;
            pInfo->cProvParam = cParam;
            // pInfo->rgProvParam
            pInfo->dwKeySpec = pSerializedInfo->dwKeySpec;
        } else
            pbExtra = NULL;

        if (0 < cParam) {
            DWORD off;
            PCRYPT_KEY_PROV_PARAM pParam;
            PSERIALIZED_KEY_PROV_PARAM pSerializedParam;

            off = pSerializedInfo->offrgProvParam;
            if (MAX_PROV_PARAM < cParam ||
                    off > cbSerialized ||
                    (off + cParam * sizeof(SERIALIZED_KEY_PROV_PARAM)) >
                            cbSerialized)
                goto InvalidData;

            lRemain -= cParam * sizeof(CRYPT_KEY_PROV_PARAM);
            if (0 <= lRemain) {
                pParam = (PCRYPT_KEY_PROV_PARAM) pbExtra;
                pInfo->rgProvParam = pParam;
                pbExtra += cParam * sizeof(CRYPT_KEY_PROV_PARAM);
            } else
                pParam = NULL;

            pSerializedParam =
                (PSERIALIZED_KEY_PROV_PARAM) (pbSerialized + off);
            for (; 0 < cParam; cParam--, pParam++, pSerializedParam++) {
                DWORD cbParamData = pSerializedParam->cbData;
                if (0 <= lRemain) {
                    pParam->dwParam = pSerializedParam->dwParam;
                    pParam->pbData = NULL;
                    pParam->cbData = cbParamData;
                    pParam->dwFlags = pSerializedParam->dwFlags;
                }

                if (0 < cbParamData) {
                    LONG lAlignExtra;

                    off = pSerializedParam->offbData;
                    if (MAX_PROV_PARAM_CBDATA < cbParamData ||
                        off > cbSerialized ||
                        (off + cbParamData) > cbSerialized)
                        goto InvalidData;

                    lAlignExtra = ENCODE_LEN_ALIGN(cbParamData);
                    lRemain -= lAlignExtra;
                    if (0 <= lRemain) {
                        pParam->pbData = pbExtra;
                        memcpy(pbExtra, pbSerialized + off, cbParamData);
                        pbExtra += lAlignExtra;
                    }
                }
            }

        }

        if (!DecodeKeyProvInfoString(
                pbSerialized,
                cbSerialized,
                pSerializedInfo->offwszContainerName,
                &pInfo->pwszContainerName,
                &pbExtra,
                &lRemain
                ))
            goto InvalidData;
        if (!DecodeKeyProvInfoString(
                pbSerialized,
                cbSerialized,
                pSerializedInfo->offwszProvName,
                &pInfo->pwszProvName,
                &pbExtra,
                &lRemain
                ))
            goto InvalidData;

        if (0 > lRemain && pInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else
            fResult = TRUE;

        cbInfo = (DWORD) ((LONG) cbInfo - lRemain);

   } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
   }

CommonReturn:
    *pcbInfo = cbInfo;
    return fResult;

ErrorReturn:
    cbInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidData, ERROR_INVALID_DATA)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+-------------------------------------------------------------------------
//  Creates a CTL entry whose attributes are the certificate context's
//  properties.
//
//  The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
//
//  The certificate properties are added as attributes. The property attribute 
//  OID is the decimal PROP_ID preceded by szOID_CERT_PROP_ID_PREFIX. Each
//  property value is copied as a single attribute value.
//
//  Any additional attributes to be included in the CTL entry can be passed
//  in via the cOptAttr and pOptAttr parameters.
//
//  CTL_ENTRY_FROM_PROP_CHAIN_FLAG can be set in dwFlags, to force the
//  inclusion of the chain building hash properties as attributes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCreateCTLEntryFromCertificateContextProperties(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD cOptAttr,
    IN OPTIONAL PCRYPT_ATTRIBUTE rgOptAttr,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT OPTIONAL PCTL_ENTRY pCtlEntry,
    IN OUT DWORD *pcbCtlEntry
    )
{
    BOOL fResult;
    DWORD cbCtlEntry;
    LONG lRemainExtra;
    BYTE *pbExtra;
    DWORD cbData;
    DWORD dwPropId;
    DWORD cProp;
    DWORD cAttr;
    DWORD cValue;
    DWORD cOptValue;
    DWORD iAttr;
    PCRYPT_ATTRIBUTE pAttr;
    PCRYPT_ATTR_BLOB pValue;

    DWORD rgdwChainHashPropId[] = {
        CERT_KEY_IDENTIFIER_PROP_ID,
//        CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
//        CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID,
        CERT_SUBJECT_NAME_MD5_HASH_PROP_ID,
    };
#define CHAIN_HASH_PROP_CNT     (sizeof(rgdwChainHashPropId) / \
                                    sizeof(rgdwChainHashPropId[0]))

    if (NULL == pCtlEntry) {
        cbCtlEntry = 0;
        lRemainExtra = 0;
    } else {
        cbCtlEntry = *pcbCtlEntry;
        lRemainExtra = (LONG) cbCtlEntry;
    }

    // Ensure the certificate has the SHA1 hash property
    if (!CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            NULL,                       // pvData
            &cbData
            ) || SHA1_HASH_LEN != cbData)
        goto GetSha1HashPropError;

    if (dwFlags & CTL_ENTRY_FROM_PROP_CHAIN_FLAG) {
        DWORD i;

        // Ensure the certificate has all of the properties needed for
        // chain building
        for (i = 0; i < CHAIN_HASH_PROP_CNT; i++) {
            if (!CertGetCertificateContextProperty(
                    pCertContext,
                    rgdwChainHashPropId[i],
                    NULL,                       // pvData
                    &cbData
                    ))
                goto GetChainHashPropError;
        }
    }

    
    // Get the property count
    cProp = 0;
    dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(
            pCertContext, dwPropId)) {
        // We won't copy the hCryptProv, KeySpec or SHA1 hash properties to
        // the attributes
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                CERT_SHA1_HASH_PROP_ID == dwPropId)
            continue;

        cProp++;
    }

    // Get the optional value count
    cOptValue = 0;
    for (iAttr = 0; iAttr < cOptAttr; iAttr++) {
        PCRYPT_ATTRIBUTE pOptAttr = &rgOptAttr[iAttr];

        cOptValue += pOptAttr->cValue;
    }

    // Calculate total attribute count. One attribute per property. Include
    // optional attributes passed in.
    cAttr = cOptAttr + cProp;

    // Calculate total value count. One value per property. Include optional
    // attribute values passed in.
    cValue = cOptValue + cProp;


    // Allocate memory for the CTL_ENTRY. array of attributes, all of the
    // attribute value blobs and the SubjectIdentifier hash.
    lRemainExtra -= sizeof(CTL_ENTRY) +
        cAttr * sizeof(CRYPT_ATTRIBUTE) +
        cValue * sizeof(CRYPT_ATTR_BLOB) +
        SHA1_HASH_LEN;

    if (0 <= lRemainExtra) {
        // Initialize the attribute, value and byte pointers
        pAttr = (PCRYPT_ATTRIBUTE) &pCtlEntry[1];
        pValue = (PCRYPT_ATTR_BLOB) &pAttr[cAttr];
        pbExtra = (BYTE *) &pValue[cValue];
        
        // Update the CTL_ENTRY fields
        pCtlEntry->SubjectIdentifier.cbData = SHA1_HASH_LEN;
        pCtlEntry->SubjectIdentifier.pbData = pbExtra;
        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                pCtlEntry->SubjectIdentifier.pbData,
                &pCtlEntry->SubjectIdentifier.cbData
                ) || SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
            goto GetSha1HashPropError;
        pbExtra += SHA1_HASH_LEN;

        pCtlEntry->cAttribute = cAttr;
        pCtlEntry->rgAttribute = pAttr;
    } else {
        pAttr = NULL;
        pValue = NULL;
        pbExtra = NULL;
    }

    // Copy over the optional attributes and attribute values
    for (iAttr = 0; iAttr < cOptAttr; iAttr++, pAttr++) {
        PCRYPT_ATTRIBUTE pOptAttr = &rgOptAttr[iAttr];
        DWORD cbOID = strlen(pOptAttr->pszObjId) + 1;
        DWORD iValue;

        lRemainExtra -= cbOID;
        if (0 <= lRemainExtra) {
            memcpy(pbExtra, pOptAttr->pszObjId, cbOID);
            pAttr->pszObjId = (LPSTR) pbExtra;
            pbExtra += cbOID;

            pAttr->cValue = pOptAttr->cValue;
            pAttr->rgValue = pValue;
        }

        for (iValue = 0; iValue < pOptAttr->cValue; iValue++, pValue++) {
            PCRYPT_ATTR_BLOB pOptValue = &pOptAttr->rgValue[iValue];

            assert(0 < cOptValue);
            if (0 == cOptValue)
                goto UnexpectedError;
            cOptValue--;
            
            lRemainExtra -= pOptValue->cbData;
            if (0 <= lRemainExtra) {
                pValue->cbData = pOptValue->cbData;
                pValue->pbData = pbExtra;
                if (0 < pValue->cbData)
                    memcpy(pValue->pbData, pOptValue->pbData, pValue->cbData);
                pbExtra += pValue->cbData;
            }
        }
    }

    assert(0 == cOptValue);
    if (0 != cOptValue)
        goto UnexpectedError;


    // Iterate through the properties and create an attribute and attribute
    // value for each
    dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(
            pCertContext, dwPropId)) {
        CRYPT_DATA_BLOB OctetBlob;
        BYTE *pbEncoded = NULL;
        DWORD cbEncoded;
        char szPropId[33];
        DWORD cbPrefixOID;
        DWORD cbPropOID;
        DWORD cbOID;

        // We won't copy the hCryptProv, KeySpec or SHA1 hash properties to
        // the attributes
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                CERT_SHA1_HASH_PROP_ID == dwPropId)
            continue;

        assert(0 < cProp);
        if (0 == cProp)
            goto UnexpectedError;
        cProp--;

        OctetBlob.cbData = 0;
        OctetBlob.pbData = NULL;
        if (!CertGetCertificateContextProperty(
                pCertContext,
                dwPropId,
                NULL,                       // pvData
                &OctetBlob.cbData
                ))
            goto GetPropError;
        if (OctetBlob.cbData) {
            if (NULL == (OctetBlob.pbData =
                    (BYTE *) PkiNonzeroAlloc(OctetBlob.cbData)))
                 goto OutOfMemory;

            if (!CertGetCertificateContextProperty(
                    pCertContext,
                    dwPropId,
                    OctetBlob.pbData,
                    &OctetBlob.cbData
                    )) {
                PkiFree(OctetBlob.pbData);
                goto GetPropError;
            }

            if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
                // Need to serialize the KeyProvInfo data structure
                BYTE *pbEncodedKeyProvInfo;
                DWORD cbEncodedKeyProvInfo;

                fResult = AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) OctetBlob.pbData,
                    &pbEncodedKeyProvInfo,
                    &cbEncodedKeyProvInfo
                    );
                PkiFree(OctetBlob.pbData);
                if (!fResult)
                    goto SerializeKeyProvInfoError;

                OctetBlob.pbData = pbEncodedKeyProvInfo;
                OctetBlob.cbData = cbEncodedKeyProvInfo;
            }
        }

        // Encode the property as an octet string
        fResult = CryptEncodeObjectEx(
            pCertContext->dwCertEncodingType,
            X509_OCTET_STRING,
            &OctetBlob,
            CRYPT_ENCODE_ALLOC_FLAG,
            &PkiEncodePara,
            (void *) &pbEncoded,
            &cbEncoded
            );

        PkiFree(OctetBlob.pbData);
        if (!fResult)
            goto EncodeError;

        // Convert PropId to OID
        _ltoa(dwPropId, szPropId, 10);
        cbPropOID = strlen(szPropId) + 1;
        cbPrefixOID = strlen(szOID_CERT_PROP_ID_PREFIX);

        // Total length of attribute OID
        cbOID = cbPrefixOID + cbPropOID;

        lRemainExtra -= cbOID + cbEncoded;
        if (0 <= lRemainExtra) {
            // Update the attribute and value

            pAttr->pszObjId = (LPSTR) pbExtra;
            memcpy(pbExtra, szOID_CERT_PROP_ID_PREFIX, cbPrefixOID);
            memcpy(pbExtra + cbPrefixOID, szPropId, cbPropOID);
            pbExtra += cbOID;

            assert(0 != cbEncoded);

            pAttr->cValue = 1;
            pAttr->rgValue = pValue;
            pValue->cbData = cbEncoded;
            pValue->pbData = pbExtra;
            memcpy(pbExtra, pbEncoded, cbEncoded);
            pbExtra += cbEncoded;

            pAttr++;
            pValue++;
        }

        PkiFree(pbEncoded);
    }

    assert(0 == cProp);
    if (0 != cProp)
        goto UnexpectedError;

    if (0 <= lRemainExtra) {
        cbCtlEntry = cbCtlEntry - (DWORD) lRemainExtra;
    } else {
        cbCtlEntry = cbCtlEntry + (DWORD) -lRemainExtra;
        if (pCtlEntry) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbCtlEntry = cbCtlEntry;
    return fResult;
ErrorReturn:
    cbCtlEntry = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSha1HashPropError)
TRACE_ERROR(GetChainHashPropError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(GetPropError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeKeyProvInfoError)
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Sets properties on the certificate context using the attributes in
//  the CTL entry.
//
//  The property attribute OID is the decimal PROP_ID preceded by
//  szOID_CERT_PROP_ID_PREFIX. Only attributes containing such an OID are
//  copied.
//
//  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG may be set in dwFlags.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCertificateContextPropertiesFromCTLEntry(
    IN PCCERT_CONTEXT pCertContext,
    IN PCTL_ENTRY pCtlEntry,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fValidPropData;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    size_t cchPropPrefix;

    if (SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
        goto InvalidCtlEntry;

    if (!CertSetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            dwFlags,
            &pCtlEntry->SubjectIdentifier
            ))
        goto SetSha1HashPropError;

    cchPropPrefix = strlen(szOID_CERT_PROP_ID_PREFIX);

    fValidPropData = TRUE;
    // Loop through the attributes. 
    for (cAttr = pCtlEntry->cAttribute,
            pAttr = pCtlEntry->rgAttribute; cAttr > 0; cAttr--, pAttr++) {
        DWORD dwPropId;
        PCRYPT_ATTR_BLOB pValue;

        CRYPT_DATA_BLOB PropBlob;
        PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
        void *pvData;

        // Skip any non-property attributes
        if (0 != strncmp(pAttr->pszObjId, szOID_CERT_PROP_ID_PREFIX,
                cchPropPrefix))
            continue;

        dwPropId = (DWORD) strtoul(pAttr->pszObjId + cchPropPrefix, NULL, 10);
        if (0 == dwPropId)
            continue;

        // Check that we have a single valued attribute encoded as an
        // OCTET STRING
        if (1 != pAttr->cValue) {
            fValidPropData = FALSE;
            continue;
        }
        pValue = pAttr->rgValue;
        if (2 > pValue->cbData ||
                ASN1UTIL_TAG_OCTETSTRING != pValue->pbData[0]) {
            fValidPropData = FALSE;
            continue;
        }

        // Extract the property bytes from the encoded OCTET STRING
        if (0 >= Asn1UtilExtractContent(
                pValue->pbData,
                pValue->cbData,
                &PropBlob.cbData,
                (const BYTE **) &PropBlob.pbData
                ) || CMSG_INDEFINITE_LENGTH == PropBlob.cbData) {
            fValidPropData = FALSE;
            continue;
        }

        if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
            BYTE *pbAlignedData = NULL;
            DWORD cbData;
            DWORD cbInfo;

            cbData = PropBlob.cbData;
            if (0 == cbData) {
                fValidPropData = FALSE;
                continue;
            }

            if (NULL == (pbAlignedData = (BYTE *) PkiNonzeroAlloc(cbData)))
                goto OutOfMemory;
            memcpy(pbAlignedData, PropBlob.pbData, cbData);

            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pbAlignedData,
                    cbData,
                    NULL,               // pInfo
                    &cbInfo
                    )) {
                PkiFree(pbAlignedData);
                fValidPropData = FALSE;
                continue;
            }

            if (NULL == (pKeyProvInfo =
                    (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(cbInfo))) {
                PkiFree(pbAlignedData);
                goto OutOfMemory;
            }

            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pbAlignedData,
                    cbData,
                    pKeyProvInfo,
                    &cbInfo
                    )) {
                PkiFree(pbAlignedData);
                PkiFree(pKeyProvInfo);
                fValidPropData = FALSE;
                continue;
            }

            PkiFree(pbAlignedData);
            pvData = (void *) pKeyProvInfo;
        } else
            pvData = (void *) &PropBlob;


        fResult = CertSetCertificateContextProperty(
                pCertContext,
                dwPropId,
                dwFlags,
                pvData
                );

        if (pKeyProvInfo)
            PkiFree(pKeyProvInfo);
        if (!fResult)
            goto SetPropError;
        
    }

    if (!fValidPropData)
        goto InvalidPropData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCtlEntry, E_INVALIDARG)
TRACE_ERROR(SetSha1HashPropError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SetPropError)
SET_ERROR(InvalidPropData, ERROR_INVALID_DATA)
}

//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================

// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    )
{
    PKEYID_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PKEYID_ELEMENT) PkiZeroAlloc(sizeof(KEYID_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->KeyIdentifier.pbData = pbKeyIdEncoded;
    pEle->KeyIdentifier.cbData = cbKeyIdEncoded;

    return pEle;
}

STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle)
{
    PPROP_ELEMENT pPropEle;

    if (NULL == pEle)
        return;

    PkiFree(pEle->KeyIdentifier.pbData);

    // Free the Key Identifier's property elements
    while (pPropEle = pEle->pPropHead) {
        RemovePropElement(&pEle->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
    PkiFree(pEle);
}


//+-------------------------------------------------------------------------
//  Open Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara contains the HCRYPTMSG
//  to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    HCRYPTMSG hCryptMsg = (HCRYPTMSG) pvPara;

    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cCert;
    DWORD cCrl;
    DWORD cbData;
    DWORD dwIndex;

    PCONTEXT_ELEMENT pCertEle;
    PCONTEXT_ELEMENT pCrlEle;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;

    // Get count of certificates and CRLs in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    cCrl = 0;
    cbData = sizeof(cCrl);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CRL_COUNT_PARAM,
        0,                      // dwIndex
        &cCrl,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CERT_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCertEle = CreateCertElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData,
            NULL                    // pShareEle
            );
        if (pCertEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCertEle);
        }
    }

    for (dwIndex = 0; dwIndex < cCrl; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CRL_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCrlEle = CreateCrlElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData,
            NULL                    // pShareEle
            );
        if (pCrlEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCrlEle);
        }
    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Open PKCS #7 Signed Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara points to a CRYPT_DATA_BLOB
//  containing the signed message.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    PCRYPT_DATA_BLOB pMsg = (PCRYPT_DATA_BLOB) pvPara;
    HCRYPTMSG hMsg = NULL;
    DWORD dwMsgType;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (Asn1UtilIsPKCS7WithoutContentType(pMsg->pbData, pMsg->cbData))
        dwMsgType = CMSG_SIGNED;
    else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwEncodingType,
            0,                          // dwFlags
            dwMsgType,
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pMsg->pbData,
            pMsg->cbData,
            TRUE                    // fFinal
            )) goto MsgUpdateError;

    fResult = OpenMsgStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hMsg,
            hCertStore,
            pStoreProvInfo
            );
    // Set in above call
    //  pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;


CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
}

STATIC BOOL LoadSerializedStore(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN DWORD cbReadSize,
    IN PCERT_STORE pStore
    )
{

    FILE_HDR FileHdr;
    DWORD   csStatus;

    if (!pfnRead(
            h,
            &FileHdr,
            sizeof(FileHdr)))
        return FALSE;

    if (FileHdr.dwVersion != CERT_FILE_VERSION_0 ||
        FileHdr.dwMagic != CERT_MAGIC) {
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);
        return(FALSE);
    }

    while (CSContinue == (csStatus = LoadStoreElement(
            h,
            pfnRead,
            pfnSkip,
            cbReadSize,
            pStore,
            CERT_STORE_ADD_ALWAYS,
            CERT_STORE_ALL_CONTEXT_FLAG,
            NULL,                           // pdwContextType
            NULL)))                         // ppvContext
        ;
    if(csStatus == CSError)
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  Called from logstor.cpp for serialized registry stores
//--------------------------------------------------------------------------
BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        )
{
    MEMINFO MemInfo;

    MemInfo.pByte = pbStore;
    MemInfo.cb = cbStore;
    MemInfo.cbSeek = 0;

    return LoadSerializedStore(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbStore,
        (PCERT_STORE) hCertStore
        );
}


//+-------------------------------------------------------------------------
//  Open Serialized Store Provider
//
//  pvPara points to a CRYPT_DATA_BLOB containing an in memory serialized
//  Store.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvPara;

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

    assert(pData);
    return I_CertAddSerializedStore(
        hCertStore,
        pData->pbData,
        pData->cbData
        );
}

//+=========================================================================
//  File Store Provider Functions
//==========================================================================

#define OPEN_FILE_FLAGS_MASK        (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_FILE_STORE_COMMIT_ENABLE_FLAG)


//+-------------------------------------------------------------------------
//  File Store Provider handle information. Only applicable when the store
//  was opened with CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//--------------------------------------------------------------------------
typedef struct _FILE_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hFile;
    DWORD               dwLoFilePointer;
    LONG                lHiFilePointer;
    DWORD               dwEncodingType;
    DWORD               dwSaveAs;
    BOOL                fTouched;      // set for write, delete or set property
} FILE_STORE, *PFILE_STORE;

//+-------------------------------------------------------------------------
//  Lock and unlock file functions
//--------------------------------------------------------------------------
static inline void LockFileStore(IN PFILE_STORE pFileStore)
{
    EnterCriticalSection(&pFileStore->CriticalSection);
}
static inline void UnlockFileStore(IN PFILE_STORE pFileStore)
{
    LeaveCriticalSection(&pFileStore->CriticalSection);
}

STATIC BOOL CommitFile(
    IN PFILE_STORE pFileStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;

    assert(pFileStore);
    LockFileStore(pFileStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pFileStore->fTouched;

    if (fTouched) {
        HANDLE hFile = pFileStore->hFile;
        DWORD dwLoFilePointer;
        LONG lHiFilePointer = pFileStore->lHiFilePointer;

        // Start the file overwrite at the same location as we started
        // the store read from the file.
        assert(hFile);
        dwLoFilePointer = SetFilePointer(
            hFile,
            (LONG) pFileStore->dwLoFilePointer,
            &lHiFilePointer,
            FILE_BEGIN
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;

        if (!CertSaveStore(
                pFileStore->hCertStore,
                pFileStore->dwEncodingType,
                pFileStore->dwSaveAs,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0))                     // dwFlags
            goto SaveStoreError;

        if (!SetEndOfFile(hFile))
            goto SetEndOfFileError;
    }
    pFileStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    UnlockFileStore(pFileStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(SetEndOfFileError)
}

//+-------------------------------------------------------------------------
//  File Store Provider Functions for stores opened with
//  CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//
//  Note, since the CRL and CTL callbacks have the same signature as the
//  certificate callbacks and since we don't need to access the context
//  information, we can also use the certificate callbacks for CRLs and
//  CTLs.
//--------------------------------------------------------------------------
STATIC void WINAPI FileStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    if (pFileStore) {
        if (pFileStore->fTouched)
            CommitFile(
                pFileStore,
                0               // dwFlags
                );
        if (pFileStore->hFile)
            CloseHandle(pFileStore->hFile);
        DeleteCriticalSection(&pFileStore->CriticalSection);
        PkiFree(pFileStore);
    }
}

STATIC BOOL WINAPI FileStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}


STATIC BOOL WINAPI FileStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_COMMIT:
            fResult = CommitFile(pFileStore, dwFlags);
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

static void * const rgpvFileStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    FileStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    FileStoreProvControl
};
#define FILE_STORE_PROV_FUNC_COUNT (sizeof(rgpvFileStoreProvFunc) / \
                                    sizeof(rgpvFileStoreProvFunc[0]))


STATIC BOOL OpenFileForCommit(
    IN HANDLE hFile,
    IN DWORD dwLoFilePointer,
    IN LONG lHiFilePointer,
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
    )
{
    BOOL fResult;

    PFILE_STORE pFileStore;

    if (NULL == (pFileStore = (PFILE_STORE) PkiZeroAlloc(sizeof(FILE_STORE))))
        return FALSE;
    if (!Pki_InitializeCriticalSection(&pFileStore->CriticalSection)) {
        PkiFree(pFileStore);
        return FALSE;
    }

    // Duplicate the file HANDLE
    if (!DuplicateHandle(
            GetCurrentProcess(),
            hFile,
            GetCurrentProcess(),
            &pFileStore->hFile,
            GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
            FALSE,                          // bInheritHandle
            0                               // dwOptions
            ) || NULL == pFileStore->hFile)
        goto DuplicateFileError;

    pFileStore->hCertStore = hCertStore;

    pFileStore->dwLoFilePointer = dwLoFilePointer;
    pFileStore->lHiFilePointer = lHiFilePointer;
    pFileStore->dwEncodingType = dwEncodingType;
    pFileStore->dwSaveAs = dwSaveAs;

    pStoreProvInfo->cStoreProvFunc = FILE_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvFileStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pFileStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    PkiFree(pFileStore);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DuplicateFileError)
}


//+-------------------------------------------------------------------------
//  Open File Store Provider
//
//  Get Certs and CRLs from the opened file. pvPara contains the opened
//  HANDLE of the file to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HANDLE hFile = (HANDLE) pvPara;
    DWORD dwLoFilePointer = 0;
    LONG lHiFilePointer = 0;
    DWORD cbReadSize;

    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;
        // Get current file location. This is where we will start the
        // commits.
        lHiFilePointer = 0;
        dwLoFilePointer = SetFilePointer(
            hFile,
            0,                  // lDistanceToMove
            &lHiFilePointer,
            FILE_CURRENT
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;
    }

    cbReadSize = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbReadSize) goto FileError;
    fResult = LoadSerializedStore(
        hFile,
        ReadFromFile,
        SkipInFile,
        cbReadSize,
        (PCERT_STORE) hCertStore
        );

    if (!fResult) {
        if (0 == GetFileSize(hFile, NULL))
            // Empty file
            fResult = TRUE;
    }

    if (fResult && (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG))
        fResult = OpenFileForCommit(
            hFile,
            dwLoFilePointer,
            lHiFilePointer,
            hCertStore,
            dwEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            pStoreProvInfo
            );
    else
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(FileError)
}

//+-------------------------------------------------------------------------
//  Open Filename Store Provider (Unicode version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFile = (LPWSTR) pvPara;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CRYPT_DATA_BLOB FileData;
    memset(&FileData, 0, sizeof(FileData));
    DWORD cbBytesRead;
    DWORD dwSaveAs = 0;
    HCERTSTORE hSpecialCertStore = NULL;

    assert(pwszFile);
    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        DWORD dwCreate;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG)
            dwCreate = CREATE_NEW;
        else if (dwFlags & CERT_STORE_OPEN_EXISTING_FLAG)
            dwCreate = OPEN_EXISTING;
        else
            dwCreate = OPEN_ALWAYS;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  dwCreate,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;

        // Default to saving as a serialized store
        dwSaveAs = CERT_STORE_SAVE_AS_STORE;

        if (0 == GetFileSize(hFile, NULL)) {
            // Use file extension to determine dwSaveAs
            LPWSTR pwszExt;
            pwszExt = pwszFile + wcslen(pwszFile);
            while (pwszExt-- > pwszFile) {
                if (L'.' == *pwszExt) {
                    pwszExt++;
                    if (0 == _wcsicmp(pwszExt, L"p7c") ||
                            0 == _wcsicmp(pwszExt, L"spc"))
                        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
                    break;
                }
            }
            goto CommitReturn;
        }
    } else {
        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;
    }

    if (OpenFileStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hFile,
            hCertStore,
            pStoreProvInfo)) {
        // For commit, we have already called OpenFileForCommit
        fResult = TRUE;
        goto OpenReturn;
    }

    // Read the entire file. Will attempt to process as either a
    // PKCS #7 or as a single cert.
    //
    // Will first try as binary. If that fails will try as base64 encoded.
    if (0 != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        goto FileError;
    FileData.cbData = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == FileData.cbData) goto FileError;
    if (0 == FileData.cbData)
        // Empty file
        goto CommitReturn;
    if (NULL == (FileData.pbData = (BYTE *) PkiNonzeroAlloc(FileData.cbData)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            FileData.pbData,
            FileData.cbData,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    if (OpenPKCS7StoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) &FileData,
            hCertStore,
            pStoreProvInfo)) {
        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
        goto CommitReturn;
    }

    // Try to process as a single encoded certificate
    if (CertAddEncodedCertificateToStore(
            hCertStore,
            dwEncodingType,
            FileData.pbData,
            FileData.cbData,
            CERT_STORE_ADD_USE_EXISTING,
            NULL)) {
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitX509CertFileError;
        else
            goto CommitReturn;
    }

    // Try to process as an encoded PKCS7, X509 or CERT_PAIR in any
    // format
    if (CryptQueryObject(
            CERT_QUERY_OBJECT_BLOB,
            &FileData,
            CERT_QUERY_CONTENT_FLAG_CERT |
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,                                  // dwFlags
            NULL,                               // pdwMsgAndCertEncodingType
            NULL,                               // pdwContentType
            NULL,                               // pdwFormatType
            &hSpecialCertStore,
            NULL,                               // phMsg
            NULL                                // ppvContext
            )) {
        fResult = I_CertUpdateStore(hCertStore, hSpecialCertStore, 0, NULL);
        CertCloseStore(hSpecialCertStore, 0);
        if (!fResult)
            goto UpdateStoreError;
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitSpecialFileError;
        else
            goto CommitReturn;
    }

    goto NoStoreOrPKCS7OrCertFileError;

CommitReturn:
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
        fResult = OpenFileForCommit(
            hFile,
            0,                          // dwLoFilePointer
            0,                          // lHiFilePointer
            hCertStore,
            dwEncodingType,
            dwSaveAs,
            pStoreProvInfo
            );
    else {
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
        fResult = TRUE;
    }
OpenReturn:
    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
        CRYPT_DATA_BLOB Property;
        Property.pbData = (BYTE *) pwszFile;
        Property.cbData = (wcslen(pwszFile) + 1) * sizeof(WCHAR);
        CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            );
    }

CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (FileData.pbData)
        PkiFree(FileData.pbData);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(CanNotCommitX509CertFileError, ERROR_ACCESS_DENIED)
SET_ERROR(CanNotCommitSpecialFileError, ERROR_ACCESS_DENIED)
SET_ERROR(NoStoreOrPKCS7OrCertFileError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(UpdateStoreError)
}

//+-------------------------------------------------------------------------
//  Open Filename Store Provider (ASCII version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFilename;
    assert(pvPara);
    if (NULL == (pwszFilename = MkWStr((LPSTR) pvPara)))
        fResult = FALSE;
    else {
        fResult = OpenFilenameStoreProvW(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) pwszFilename,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszFilename);
    }
    return fResult;
}

//+=========================================================================
//  CryptAcquireCertificatePrivateKey Support Functions
//==========================================================================

// Upon entry/exit, the Cache Store is locked.
//
// OUTs are only updated for success.
STATIC BOOL GetCacheKeyContext(
    IN PCONTEXT_ELEMENT pCacheEle,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult = FALSE;
    PPROP_ELEMENT pPropEle;
    if (pPropEle = FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
        PCERT_KEY_CONTEXT pKeyContext =
            (PCERT_KEY_CONTEXT) pPropEle->pbData;
        assert(pKeyContext);
        assert(pPropEle->cbData >= sizeof(CERT_KEY_CONTEXT));
        if (pKeyContext->hCryptProv) {
            *phCryptProv = pKeyContext->hCryptProv;
            if (pdwKeySpec)
                *pdwKeySpec = pKeyContext->dwKeySpec;
            fResult = TRUE;
        }
    }
    return fResult;
}


STATIC PCRYPT_KEY_PROV_INFO GetKeyIdentifierKeyProvInfo(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if(!GetProperty(
            pCacheEle,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return NULL;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;

    // Try again, searching LocalMachine
    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;
    else
        return NULL;
}

STATIC BOOL AcquireKeyContext(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    IN OUT PCERT_KEY_CONTEXT pKeyContext,
    IN OUT BOOL *pfBadPubKey
    )
{
    BOOL fResult;
    DWORD dwAcquireFlags;
    DWORD dwIdx;

    dwAcquireFlags = pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID;
    if (dwFlags & CRYPT_ACQUIRE_SILENT_FLAG)
        dwAcquireFlags |= CRYPT_SILENT;
    pKeyContext->dwKeySpec = pKeyProvInfo->dwKeySpec;

    if (PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
            (NULL == pKeyProvInfo->pwszProvName ||
                L'\0' == *pKeyProvInfo->pwszProvName ||
                0 == _wcsicmp(pKeyProvInfo->pwszProvName, MS_DEF_PROV_W)))
        fResult = CryptAcquireContextU(
            &pKeyContext->hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            dwAcquireFlags
            );
    else if (PROV_DSS_DH == pKeyProvInfo->dwProvType &&
            (NULL == pKeyProvInfo->pwszProvName ||
                L'\0' == *pKeyProvInfo->pwszProvName ||
                0 == _wcsicmp(pKeyProvInfo->pwszProvName,
                    MS_DEF_DSS_DH_PROV_W)))
        fResult = CryptAcquireContextU(
            &pKeyContext->hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENH_DSS_DH_PROV_W,
            PROV_DSS_DH,
            dwAcquireFlags
            );
    else
        fResult = FALSE;
    if (!fResult) {
        if (!CryptAcquireContextU(
                &pKeyContext->hCryptProv,
                pKeyProvInfo->pwszContainerName,
                pKeyProvInfo->pwszProvName,
                pKeyProvInfo->dwProvType,
                dwAcquireFlags
                )) {
            pKeyContext->hCryptProv = 0;
            goto AcquireContextError;
        }
    }

    for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) {
        PCRYPT_KEY_PROV_PARAM pKeyProvParam = &pKeyProvInfo->rgProvParam[dwIdx];
        if (!CryptSetProvParam(
                pKeyContext->hCryptProv,
                pKeyProvParam->dwParam,
                pKeyProvParam->pbData,
                pKeyProvParam->dwFlags
                ))
            goto SetProvParamError;
    }


    if (dwFlags & CRYPT_ACQUIRE_COMPARE_KEY_FLAG) {
        if (!I_CertCompareCertAndProviderPublicKey(
                pCert,
                pKeyContext->hCryptProv,
                pKeyContext->dwKeySpec
                )) {
            *pfBadPubKey = TRUE;
            goto BadPublicKey;
        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    if (pKeyContext->hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pKeyContext->hCryptProv, 0);
        SetLastError(dwErr);
        pKeyContext->hCryptProv = 0;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AcquireContextError)
TRACE_ERROR(SetProvParamError)
SET_ERROR(BadPublicKey, NTE_BAD_PUBLIC_KEY)
}

//+-------------------------------------------------------------------------
//  Acquire a HCRYPTPROV handle and dwKeySpec for the specified certificate
//  context. Uses the certificate's CERT_KEY_PROV_INFO_PROP_ID property.
//  The returned HCRYPTPROV handle may optionally be cached using the
//  certificate's CERT_KEY_CONTEXT_PROP_ID property.
//
//  If CRYPT_ACQUIRE_CACHE_FLAG is set, then, if an already acquired and
//  cached HCRYPTPROV exists for the certificate, its returned. Otherwise,
//  a HCRYPTPROV is acquired and then cached via the certificate's
//  CERT_KEY_CONTEXT_PROP_ID.
//
//  The CRYPT_ACQUIRE_USE_PROV_INFO_FLAG can be set to use the dwFlags field of
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property's CRYPT_KEY_PROV_INFO
//  data structure to determine if the returned HCRYPTPROV should be cached.
//  HCRYPTPROV caching is enabled if the CERT_SET_KEY_CONTEXT_PROP_ID flag was
//  set.
//
//  If CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set, then,
//  the public key in the certificate is compared with the public
//  key returned by the cryptographic provider. If the keys don't match, the
//  acquire fails and LastError is set to NTE_BAD_PUBLIC_KEY. Note, if
//  a cached HCRYPTPROV is returned, the comparison isn't done. We assume the
//  comparison was done on the initial acquire.
//
//  The CRYPT_ACQUIRE_SILENT_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  *pfCallerFreeProv is returned set to FALSE for:
//    - Acquire or public key comparison fails.
//    - CRYPT_ACQUIRE_CACHE_FLAG is set.
//    - CRYPT_ACQUIRE_USE_PROV_INFO_FLAG is set AND
//      CERT_SET_KEY_CONTEXT_PROP_ID flag is set in the dwFlags field of the
//      certificate's CERT_KEY_PROV_INFO_PROP_ID property's
//      CRYPT_KEY_PROV_INFO data structure.
//  When *pfCallerFreeProv is FALSE, the caller must not release. The
//  returned HCRYPTPROV will be released on the last free of the certificate
//  context.
//
//  Otherwise, *pfCallerFreeProv is TRUE and the returned HCRYPTPROV must
//  be released by the caller by calling CryptReleaseContext.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec,
    OUT OPTIONAL BOOL *pfCallerFreeProv
    )
{
    BOOL fResult;
    BOOL fCallerFreeProv;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    CERT_KEY_CONTEXT KeyContext;
    memset(&KeyContext, 0, sizeof(KeyContext));
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbData;
    BOOL fKeyIdentifier = FALSE;
    BOOL fBadPubKey = FALSE;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCert))))
        goto InvalidCert;
    pCacheStore = pCacheEle->pStore;

    if (dwFlags &
            (CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_USE_PROV_INFO_FLAG)) {
        // Attempt to use existing CERT_KEY_CONTEXT_PROP_ID property

        LockStore(pCacheStore);
        if (GetCacheKeyContext(
                pCacheEle,
                phCryptProv,
                pdwKeySpec
                )) {
            if (pfCallerFreeProv)
                *pfCallerFreeProv = FALSE;
            UnlockStore(pCacheStore);
            return TRUE;
        }
        UnlockStore(pCacheStore);
    }

    if (!AllocAndGetProperty(
            pCacheEle,
            CERT_KEY_PROV_INFO_PROP_ID,
            (void **) &pKeyProvInfo,
            &cbData)) {
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;
    }

    if (!AcquireKeyContext(
            pCert,
            dwFlags,
            pKeyProvInfo,
            &KeyContext,
            &fBadPubKey
            )) {
        if (fKeyIdentifier || ERROR_CANCELLED == GetLastError())
            goto AcquireKeyContextError;

        PkiFree(pKeyProvInfo);
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;

        if (!AcquireKeyContext(
                pCert,
                dwFlags,
                pKeyProvInfo,
                &KeyContext,
                &fBadPubKey
                ))
            goto AcquireKeyContextError;
    }


    fResult = TRUE;
    if ((dwFlags & CRYPT_ACQUIRE_CACHE_FLAG)
                        ||
        ((dwFlags & CRYPT_ACQUIRE_USE_PROV_INFO_FLAG) &&
            (pKeyProvInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID))) {
        // Cache the context.

        HCRYPTPROV hCryptProv;
        DWORD dwKeySpec;

        LockStore(pCacheStore);
        // First check that another thread hasn't already cached the context.
        if (GetCacheKeyContext(
                pCacheEle,
                &hCryptProv,
                &dwKeySpec
                )) {
            CryptReleaseContext(KeyContext.hCryptProv, 0);
            KeyContext.hCryptProv = hCryptProv;
            KeyContext.dwKeySpec = dwKeySpec;
        } else {
            KeyContext.cbSize = sizeof(KeyContext);
            fResult = SetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                0,                              // dwFlags
                (void *) &KeyContext,
                TRUE                            // fInhibitProvSet
                );
        }
        UnlockStore(pCacheStore);
        if (!fResult) goto SetKeyContextPropertyError;
        fCallerFreeProv = FALSE;
    } else
        fCallerFreeProv = TRUE;

CommonReturn:
    if (pKeyProvInfo) {
        if (fKeyIdentifier)
            PkiDefaultCryptFree(pKeyProvInfo);
        else
            PkiFree(pKeyProvInfo);
    }

    *phCryptProv = KeyContext.hCryptProv;
    if (pdwKeySpec)
        *pdwKeySpec = KeyContext.dwKeySpec;
    if (pfCallerFreeProv)
        *pfCallerFreeProv = fCallerFreeProv;
    return fResult;

ErrorReturn:
    if (fBadPubKey)
        SetLastError((DWORD) NTE_BAD_PUBLIC_KEY);
    if (KeyContext.hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(KeyContext.hCryptProv, 0);
        SetLastError(dwErr);
        KeyContext.hCryptProv = 0;
    }
    fResult = FALSE;
    fCallerFreeProv = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCert, E_INVALIDARG)
SET_ERROR(NoKeyProperty, CRYPT_E_NO_KEY_PROPERTY)
TRACE_ERROR(AcquireKeyContextError)
TRACE_ERROR(SetKeyContextPropertyError)
}

//+=========================================================================
//  I_CertSyncStore and I_CertSyncStoreEx Support Functions
//==========================================================================

// Returns FALSE if unable to do the find. For instance, OutOfMemory error.
STATIC BOOL FindElementInOtherStore(
    IN PCERT_STORE pOtherStore,
    IN DWORD dwContextType,
    IN PCONTEXT_ELEMENT pEle,
    OUT PCONTEXT_ELEMENT *ppOtherEle
    )
{
    PCONTEXT_ELEMENT pOtherEle;
    BYTE rgbHash[SHA1_HASH_LEN];
    DWORD cbHash;

    *ppOtherEle = NULL;

    cbHash = SHA1_HASH_LEN;
    if (!GetProperty(
            pEle,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    assert(STORE_TYPE_CACHE == pOtherStore->dwStoreType);

    pOtherEle = NULL;
    // Enable fForceEnumArchived
    while (pOtherEle = FindElementInCacheStore(pOtherStore, dwContextType,
            &FindAnyInfo, pOtherEle, TRUE)) {
        BYTE rgbOtherHash[SHA1_HASH_LEN];
        DWORD cbOtherHash;

        cbOtherHash = SHA1_HASH_LEN;
        if (!GetProperty(
                pOtherEle,
                CERT_SHA1_HASH_PROP_ID,
                rgbOtherHash,
                &cbOtherHash
                ) || SHA1_HASH_LEN != cbOtherHash)
            return FALSE;
        if (0 == memcmp(rgbOtherHash, rgbHash, SHA1_HASH_LEN)) {
            *ppOtherEle = pOtherEle;
            return TRUE;
        }
    }

    return TRUE;
}

STATIC void AppendElementToDeleteList(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT DWORD *pcDeleteList,
    IN OUT PCONTEXT_ELEMENT **pppDeleteList
    )
{
    DWORD cDeleteList = *pcDeleteList;
    PCONTEXT_ELEMENT *ppDeleteList = *pppDeleteList;

    if (ppDeleteList = (PCONTEXT_ELEMENT *) PkiRealloc(ppDeleteList,
            (cDeleteList + 1) * sizeof(PCONTEXT_ELEMENT))) {
        AddRefContextElement(pEle);
        ppDeleteList[cDeleteList] = pEle;
        *pcDeleteList = cDeleteList + 1;
        *pppDeleteList = ppDeleteList;
    }
}

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//
//  Setting ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG in dwInFlags
//  inhibits the syncing of properties.
//
//  ICERT_SYNC_STORE_CHANGED_OUT_FLAG is returned and set in *pdwOutFlags
//  if any contexts were added or deleted from the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStoreEx(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwInFlags,
    OUT OPTIONAL DWORD *pdwOutFlags,
    IN OUT OPTIONAL void *pvReserved
    )
{
    PCERT_STORE pOrigStore = (PCERT_STORE) hOriginalStore;
    PCERT_STORE pNewStore = (PCERT_STORE) hNewStore;
    DWORD dwOutFlags = 0;

    DWORD cDeleteList = 0;
    PCONTEXT_ELEMENT *ppDeleteList = NULL;
    DWORD i;

    assert(STORE_TYPE_CACHE == pOrigStore->dwStoreType &&
        STORE_TYPE_CACHE == pNewStore->dwStoreType);

    if (STORE_TYPE_CACHE != pOrigStore->dwStoreType ||
            STORE_TYPE_CACHE != pNewStore->dwStoreType) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (pOrigStore->dwFlags & CERT_STORE_MANIFOLD_FLAG)
        ArchiveManifoldCertificatesInStore(pNewStore);

    // Loop through the original store's elements. If the context exists
    // in the new store, copy the new store's properties and delete from
    // the new store. Otherwise, put the original store's context on a
    // deferred delete list.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pOrigEle = NULL;
        // Enable fForceEnumArchived
        while (pOrigEle = FindElementInCacheStore(pOrigStore, i, &FindAnyInfo,
                pOrigEle, TRUE)) {
            PCONTEXT_ELEMENT pNewEle;
            if (FindElementInOtherStore(pNewStore, i, pOrigEle, &pNewEle)) {
                if (pNewEle) {
                    if (0 == (dwInFlags &
                            ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG))
                        CopyProperties(
                            pNewEle,
                            pOrigEle,
                            COPY_PROPERTY_INHIBIT_PROV_SET_FLAG |
                                COPY_PROPERTY_SYNC_FLAG
                            );
                    DeleteContextElement(pNewEle);
                } else {
                    dwOutFlags |= ICERT_SYNC_STORE_CHANGED_OUT_FLAG;
                    AppendElementToDeleteList(pOrigEle, &cDeleteList,
                        &ppDeleteList);
                }
            }
            //
            // else
            //  Find failed due to OutOfMemory
        }
    }

    LockStore(pOrigStore);

    // Move any remaining contexts in the new store to the original store.
    // Note, append at the end of list and not at the beginning. Another
    // thread might have been enumerating the store. Its better to find
    // 2 copies of a renewed context instead of none.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pNewEle;

        if (pNewEle = pNewStore->rgpContextListHead[i]) {
            PCONTEXT_ELEMENT pOrigEle;

            dwOutFlags |= ICERT_SYNC_STORE_CHANGED_OUT_FLAG;

            if (pOrigEle = pOrigStore->rgpContextListHead[i]) {
                // Append at end of original store
                while (pOrigEle->pNext)
                    pOrigEle = pOrigEle->pNext;
                pOrigEle->pNext = pNewEle;
                pNewEle->pPrev = pOrigEle;
            } else {
                // New entries in original store
                pOrigStore->rgpContextListHead[i] = pNewEle;
                pNewEle->pPrev = NULL;
            }

            for ( ; pNewEle; pNewEle = pNewEle->pNext) {
                // Update the elements obtained from the new store to
                // point to the original store
                pNewEle->pStore = pOrigStore;
                pNewEle->pProvStore = pOrigStore;
                SetStoreHandle(pNewEle);
            }

            // No contexts remain in new store
            pNewStore->rgpContextListHead[i] = NULL;
        }
    }

    UnlockStore(pOrigStore);

    // Delete any contexts in the deferred delete list from the original store
    while (cDeleteList--)
        DeleteContextElement(ppDeleteList[cDeleteList]);
    PkiFree(ppDeleteList);

    if (pdwOutFlags)
        *pdwOutFlags = dwOutFlags;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    )
{
    return I_CertSyncStoreEx(
        hOriginalStore,
        hNewStore,
        0,                      // dwInFlags
        NULL,                   // pdwOutFlags
        NULL                    // pvReserved
        );
}

//+-------------------------------------------------------------------------
//  Update the original store with contexts from the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertUpdateStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwReserved,
    IN OUT void *pvReserved
    )
{
    PCERT_STORE pOrigStore = (PCERT_STORE) hOriginalStore;
    PCERT_STORE pNewStore = (PCERT_STORE) hNewStore;
    DWORD i;

    assert(STORE_TYPE_CACHE == pOrigStore->dwStoreType &&
        STORE_TYPE_CACHE == pNewStore->dwStoreType);

    if (STORE_TYPE_CACHE != pOrigStore->dwStoreType ||
            STORE_TYPE_CACHE != pNewStore->dwStoreType) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    LockStore(pOrigStore);

    // Move contexts in the new store to the original store.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pNewEle;

        if (pNewEle = pNewStore->rgpContextListHead[i]) {
            PCONTEXT_ELEMENT pNewTailEle = NULL;
            PCONTEXT_ELEMENT pOrigEle;
            PCONTEXT_ELEMENT pEle;

            for (pEle = pNewEle ; pEle; pEle = pEle->pNext) {
                // Update the elements obtained from the new store to
                // point to the original store
                pEle->pStore = pOrigStore;
                pEle->pProvStore = pOrigStore;
                SetStoreHandle(pEle);

                // Remember the last element in the linked list
                pNewTailEle = pEle;
            }

            assert(pNewTailEle);
            assert(NULL == pNewEle->pPrev);
            assert(NULL == pNewTailEle->pNext);

            // Insert new store's linked list of contexts at the
            // beginning of the original store
            if (pOrigEle = pOrigStore->rgpContextListHead[i]) {
                assert(NULL == pOrigEle->pPrev);
                pOrigEle->pPrev = pNewTailEle;
                pNewTailEle->pNext = pOrigEle;
            }
            pOrigStore->rgpContextListHead[i] = pNewEle;

            // No contexts remain in new store
            pNewStore->rgpContextListHead[i] = NULL;
        }
    }

    UnlockStore(pOrigStore);

    return TRUE;
}



//+=========================================================================
//  SortedCTL APIs.
//==========================================================================

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBooleanTag[] = {ASN1UTIL_TAG_BOOLEAN, 0};
static const BYTE rgbOctetStringTag[] = {ASN1UTIL_TAG_OCTETSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};
static const BYTE rgbChoiceOfTimeTag[] =
    {ASN1UTIL_TAG_UTC_TIME, ASN1UTIL_TAG_GENERALIZED_TIME, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCtlPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - version                 CTLVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   2 - subjectUsage            SubjectUsage,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - listIdentifier          ListIdentifier OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   4 - sequenceNumber          HUGEINTEGER OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   5 - ctlThisUpdate           ChoiceOfTime,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   6 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   7 - subjectAlgorithm        AlgorithmIdentifier,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   8 - trustedSubjects         TrustedSubjects OPTIONAL,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   9 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
};
#define CTL_SEQ_VALUE_INDEX         0
#define CTL_SUBJECT_ALG_VALUE_INDEX 7
#define CTL_SUBJECTS_VALUE_INDEX    8
#define CTL_EXTENSIONS_VALUE_INDEX  9
#define CTL_VALUE_COUNT             \
    (sizeof(rgExtractCtlPara) / sizeof(rgExtractCtlPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - extnId              OBJECT IDENTIFIER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - critical            BOOLEAN DEFAULT FALSE,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbBooleanTag,
    //   3 - extnValue           OCTETSTRING
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
};
#define EXT_OID_VALUE_INDEX         1
#define EXT_OCTETS_VALUE_INDEX      3
#define EXT_VALUE_COUNT             \
    (sizeof(rgExtractExtPara) / sizeof(rgExtractExtPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX      1
#define TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX      2
#define TRUSTED_SUBJECT_VALUE_COUNT                 \
    (sizeof(rgExtractTrustedSubjectPara) / \
        sizeof(rgExtractTrustedSubjectPara[0]))

// same as above, however, return content blob for subjectAttributes instead
// of its value blob
static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara2[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractAttributePara[] = {
    // 0 - Attribute ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - type  
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - values     AttributeSetValue
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define ATTRIBUTE_OID_VALUE_INDEX                   1
#define ATTRIBUTE_VALUES_VALUE_INDEX                2
#define ATTRIBUTE_VALUE_COUNT                       \
    (sizeof(rgExtractAttributePara) / sizeof(rgExtractAttributePara[0]))



static const DWORD rgdwPrime[] = {
            // Bits - cHashBucket
        1,  //   0  - 0x00001 (1)
        2,  //   1  - 0x00002 (2)
        3,  //   2  - 0x00004 (4)
        7,  //   3  - 0x00008 (8)
       13,  //   4  - 0x00010 (16)
       31,  //   5  - 0x00020 (32)
       61,  //   6  - 0x00040 (64)
      127,  //   7  - 0x00080 (128)
      251,  //   8  - 0x00100 (256)
      509,  //   9  - 0x00200 (512)
     1021,  //  10  - 0x00400 (1024)
     2039,  //  11  - 0x00800 (2048)
     4093,  //  12  - 0x01000 (4096)
     8191,  //  13  - 0x02000 (8192)
    16381,  //  14  - 0x04000 (16384)
    32749,  //  15  - 0x08000 (32768)
    65521,  //  16  - 0x10000 (65536)
};

#define MIN_HASH_BUCKET_BITS    6
#define MIN_HASH_BUCKET_COUNT   (1 << MIN_HASH_BUCKET_BITS)
#define MAX_HASH_BUCKET_BITS    16
#define MAX_HASH_BUCKET_COUNT   (1 << MAX_HASH_BUCKET_BITS)

#define DEFAULT_BYTES_PER_CTL_ENTRY     100
#define DEFAULT_CTL_ENTRY_COUNT         256

STATIC DWORD GetHashBucketCount(
    IN DWORD cCtlEntry
    )
{
    DWORD cBits;

    if (MAX_HASH_BUCKET_COUNT <= cCtlEntry)
        cBits = MAX_HASH_BUCKET_BITS;
    else {
        DWORD cHashBucket = MIN_HASH_BUCKET_COUNT;

        cBits = MIN_HASH_BUCKET_BITS;
        while (cCtlEntry > cHashBucket) {
            cHashBucket = cHashBucket << 1;
            cBits++;
        }
        assert(cBits <= MAX_HASH_BUCKET_BITS);
    }
    return rgdwPrime[cBits];
}

STATIC DWORD GetHashBucketIndex(
    IN DWORD cHashBucket,
    IN BOOL fHashedIdentifier,
    IN const CRYPT_DATA_BLOB *pIdentifier
    )
{
    DWORD dwIndex;
    const BYTE *pb = pIdentifier->pbData;
    DWORD cb = pIdentifier->cbData;


    if (fHashedIdentifier) {
        if (4 <= cb)
            memcpy(&dwIndex, pb, 4);
        else
            dwIndex = 0;
    } else {
        dwIndex = 0;
        while (cb--) {
            if (dwIndex & 0x80000000)
                dwIndex = (dwIndex << 1) | 1;
            else
                dwIndex = dwIndex << 1;
            dwIndex += *pb++;
        }
    }
    if (0 == cHashBucket)
        return 0;
    else
        return dwIndex % cHashBucket;
}

// #define szOID_CTL                       "1.3.6.1.4.1.311.10.1"
static const BYTE rgbOIDCtl[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01};
static const CRYPT_DER_BLOB EncodedOIDCtl = {
    sizeof(rgbOIDCtl), (BYTE *) rgbOIDCtl
};

// #define szOID_SORTED_CTL                "1.3.6.1.4.1.311.10.1.1"
static const BYTE rgbOIDSortedCtlExt[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01, 0x01};
static const CRYPT_DER_BLOB EncodedOIDSortedCtlExt = {
    sizeof(rgbOIDSortedCtlExt), (BYTE *) rgbOIDSortedCtlExt
};


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
STATIC BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


STATIC BOOL ExtractSortedCtlExtValue(
    IN const CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT],
    OUT const BYTE **ppbSortedCtlExtValue,
    OUT DWORD *pcbSortedCtlExtValue,
    OUT const BYTE **ppbRemainExt,
    OUT DWORD *pcbRemainExt
    )
{
    BOOL fResult;
    const BYTE *pbEncodedExtensions;
    DWORD cbEncodedExtensions;
    const BYTE *pbEncodedSortedCtlExt;
    DWORD cbEncodedSortedCtlExt;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[EXT_VALUE_COUNT];
    LONG lSkipped;

    // Following points to the outer Extensions sequence
    pbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;
    if (0 == cbEncodedExtensions)
        goto NoExtensions;

    // Step into the Extension sequence and get pointer to the first extension.
    // The returned cbEncodedSortedCtlExt includes all of the
    // extensions in the sequence.
    if (0 >= (lSkipped = Asn1UtilExtractContent(
            pbEncodedExtensions,
            cbEncodedExtensions,
            &cbEncodedSortedCtlExt,
            &pbEncodedSortedCtlExt
            )) || CMSG_INDEFINITE_LENGTH == cbEncodedSortedCtlExt ||
                (DWORD) lSkipped + cbEncodedSortedCtlExt !=
                    cbEncodedExtensions)
        goto InvalidExtensions;

    // Decode the first extension
    cValue = EXT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncodedSortedCtlExt,
            cbEncodedSortedCtlExt,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractExtPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    // Check that the first extension is the SortedCtl extension
    if (!CompareEncodedOID(
            &rgValueBlob[EXT_OID_VALUE_INDEX],
            &EncodedOIDSortedCtlExt
            ))
        goto NoSortedCtlExtension;

    *ppbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].pbData;
    *pcbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].cbData;

    *ppbRemainExt = pbEncodedSortedCtlExt + lSkipped;
    *pcbRemainExt = cbEncodedSortedCtlExt - lSkipped;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    *ppbSortedCtlExtValue = NULL;
    *pcbSortedCtlExtValue = 0;
    *ppbRemainExt = NULL;
    *pcbRemainExt = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoExtensions, ERROR_INVALID_DATA)
SET_ERROR(InvalidExtensions, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSortedCtlExtension, ERROR_INVALID_DATA)
}


BOOL
WINAPI
SortedCtlInfoEncodeEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN PCTL_INFO pOrigCtlInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT OPTIONAL void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    PCTL_INFO pSortedCtlInfo = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    DWORD cCtlEntry;
    PCTL_ENTRY pSortedCtlEntry = NULL;
    DWORD cHashBucket = 0;
    PHASH_BUCKET_ENTRY *ppHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;

    DWORD cSortedExtension;
    PCERT_EXTENSION pSortedExtension = NULL;
    BYTE *pbSortedCtlExtValue = NULL;
    DWORD cbSortedCtlExtValue = 0;


    if (0 == (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        goto InvalidArg;

    // Make a copy of the CtlInfo. We're going to re-order the CTL entries
    // and insert a szOID_SORTED_CTL extension.
    if (NULL == (pSortedCtlInfo = (PCTL_INFO) PkiNonzeroAlloc(
            sizeof(CTL_INFO))))
        goto OutOfMemory;
    memcpy(pSortedCtlInfo, pOrigCtlInfo, sizeof(CTL_INFO));
    cCtlEntry = pSortedCtlInfo->cCTLEntry;
    if (0 < cCtlEntry) {
        DWORD i;
        DWORD j;
        PCTL_ENTRY pCtlEntry;
        DWORD cOrigExtension;
        PCERT_EXTENSION pOrigExtension;

        BOOL fHashedIdentifier =
            dwFlags & CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
        DWORD dwSortedCtlExtFlags = fHashedIdentifier ?
            SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG : 0;
        DWORD dwMaxCollision = 0;

        cHashBucket = GetHashBucketCount(cCtlEntry);
        if (NULL == (ppHashBucketHead = (PHASH_BUCKET_ENTRY *) PkiZeroAlloc(
                sizeof(PHASH_BUCKET_ENTRY) * cHashBucket)))
            goto OutOfMemory;

        if (NULL == (pHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiNonzeroAlloc(
                sizeof(HASH_BUCKET_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        // Iterate through the CTL entries and add to the appropriate
        // hash bucket.
        pCtlEntry = pSortedCtlInfo->rgCTLEntry;
        for (i = 0; i < cCtlEntry; i++) {
            DWORD HashBucketIndex;

            HashBucketIndex = GetHashBucketIndex(
                cHashBucket,
                fHashedIdentifier,
                &pCtlEntry[i].SubjectIdentifier
                );
            pHashBucketEntry[i].dwEntryIndex = i;
            pHashBucketEntry[i].pNext = ppHashBucketHead[HashBucketIndex];
            ppHashBucketHead[HashBucketIndex] = &pHashBucketEntry[i];
        }

        // Sort the entries according to the HashBucket order
        if (NULL == (pSortedCtlEntry = (PCTL_ENTRY) PkiNonzeroAlloc(
                sizeof(CTL_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        j = 0;
        for (i = 0; i < cHashBucket; i++) {
            DWORD dwCollision = 0;
            PHASH_BUCKET_ENTRY p;

            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                pSortedCtlEntry[j++] = pCtlEntry[p->dwEntryIndex];
                dwCollision++;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "SortedCtlInfoEncodeEx:: cHashBucket: %d MaxCollision: %d Flags:: 0x%x\n",
            cHashBucket, dwMaxCollision, dwSortedCtlExtFlags);
#endif
        assert(j == cCtlEntry);
        pSortedCtlInfo->rgCTLEntry = pSortedCtlEntry;

        // Insert a SortedCtl extension
        cOrigExtension = pSortedCtlInfo->cExtension;
        pOrigExtension = pSortedCtlInfo->rgExtension;
        // Check if the first extension is the SortedCtl extension
        if (cOrigExtension && 0 == strcmp(pOrigExtension[0].pszObjId,
                szOID_SORTED_CTL)) {
            cOrigExtension--;
            pOrigExtension++;
        }

        cSortedExtension = cOrigExtension + 1;
        if (NULL == (pSortedExtension = (PCERT_EXTENSION) PkiNonzeroAlloc(
                sizeof(CERT_EXTENSION) * cSortedExtension)))
            goto OutOfMemory;

        if (cOrigExtension)
            memcpy(&pSortedExtension[1], pOrigExtension,
                sizeof(CERT_EXTENSION) * cOrigExtension);

        cbSortedCtlExtValue = SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
            sizeof(DWORD) * (cHashBucket + 1);
        if (NULL == (pbSortedCtlExtValue = (BYTE *) PkiNonzeroAlloc(
                cbSortedCtlExtValue)))
            goto OutOfMemory;

        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
            &dwSortedCtlExtFlags, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
            &cHashBucket, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_MAX_COLLISION_OFFSET,
            &dwMaxCollision, sizeof(DWORD));

        pSortedExtension[0].pszObjId = szOID_SORTED_CTL;
        pSortedExtension[0].fCritical = FALSE;
        pSortedExtension[0].Value.pbData = pbSortedCtlExtValue;
        pSortedExtension[0].Value.cbData = cbSortedCtlExtValue;

        pSortedCtlInfo->cExtension = cSortedExtension;
        pSortedCtlInfo->rgExtension = pSortedExtension;
    }

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            PKCS_CTL,
            pSortedCtlInfo,
            dwFlags,
            pEncodePara,
            (void *) &pbEncoded,
            &cbEncoded
            ))
        goto CtlInfoEncodeError;

    if (0 < cCtlEntry) {
        // Update the SortedCtl extension's array of hash bucket offsets

        // First, extract values for the encoded sequence of subjects
        // and extensions.

        DWORD i;
        DWORD cCtlValue;
        CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
        const BYTE *pbEncodedSubject;
        DWORD cbEncodedSubject;
        const BYTE *pbEncodedSortedCtlExtValue;
        DWORD cbEncodedSortedCtlExtValue;
        const BYTE *pbRemainExt;
        DWORD cbRemainExt;
        BYTE *pbEncodedHashBucketOffset;
        DWORD dwEncodedHashBucketOffset;

        cCtlValue = CTL_VALUE_COUNT;
        if (0 >= Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cCtlValue,
                rgExtractCtlPara,
                rgCtlValueBlob
                ))
            goto ExtractCtlValuesError;

        pbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
        cbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;
        assert(pbEncodedSubject > pbEncoded);
        assert(cbEncodedSubject);

        assert(rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData);
        if (!ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbEncodedSortedCtlExtValue,
                &cbEncodedSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                ))
            goto ExtractSortedCtlExtValueError;
        assert(cbEncodedSortedCtlExtValue == cbSortedCtlExtValue);
        pbEncodedHashBucketOffset = (BYTE *) pbEncodedSortedCtlExtValue +
            SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

        for (i = 0; i < cHashBucket; i++) {
            PHASH_BUCKET_ENTRY p;

            dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
            memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
                sizeof(DWORD));
            pbEncodedHashBucketOffset += sizeof(DWORD);

            // Advance through the encoded subjects for the current
            // hash bucket index
            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                LONG lTagLength;
                DWORD cbContent;
                const BYTE *pbContent;
                DWORD cbSubject;

                lTagLength = Asn1UtilExtractContent(
                    pbEncodedSubject,
                    cbEncodedSubject,
                    &cbContent,
                    &pbContent
                    );
                assert(lTagLength > 0 && CMSG_INDEFINITE_LENGTH != cbContent);
                cbSubject = cbContent + lTagLength;
                assert(cbEncodedSubject >= cbSubject);
                pbEncodedSubject += cbSubject;
                cbEncodedSubject -= cbSubject;
            }
        }

        assert(0 == cbEncodedSubject);
        assert(pbEncodedSubject ==
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData +
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData);
        assert(pbEncodedHashBucketOffset + sizeof(DWORD) ==
            pbEncodedSortedCtlExtValue + cbEncodedSortedCtlExtValue);
        dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
        memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
            sizeof(DWORD));
    }

    *((BYTE **) pvEncoded) = pbEncoded;
    *pcbEncoded = cbEncoded;
    fResult = TRUE;

CommonReturn:
    PkiFree(pSortedCtlInfo);
    PkiFree(pSortedCtlEntry);
    PkiFree(ppHashBucketHead);
    PkiFree(pHashBucketEntry);
    PkiFree(pSortedExtension);
    PkiFree(pbSortedCtlExtValue);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        if (pbEncoded) {
            PFN_CRYPT_FREE pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
            pfnFree(pbEncoded);
        }
        *((BYTE **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CtlInfoEncodeError)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(ExtractSortedCtlExtValueError)
}

STATIC BOOL CreateSortedCtlHashBuckets(
    IN OUT PSORTED_CTL_FIND_INFO pSortedCtlFindInfo
    )
{
    BOOL fResult;
    DWORD cHashBucket;
    DWORD *pdwHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;
    DWORD cAllocEntry = 0;
    DWORD cEntry = 0;

    const BYTE *pbEncoded;
    DWORD cbEncoded;

#if DBG
    DWORD dwMaxCollision = 0;
#endif

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    pbEncoded = pSortedCtlFindInfo->pbEncodedSubjects;
    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;

    cHashBucket = GetHashBucketCount(cbEncoded / DEFAULT_BYTES_PER_CTL_ENTRY);
    if (NULL == (pdwHashBucketHead = (DWORD *) PkiZeroAlloc(
            sizeof(DWORD) * cHashBucket)))
        goto OutOfMemory;


    // Loop through the encoded trusted subjects. For each subject, create
    // hash bucket entry, calculate hash bucket index and insert.
    while (cbEncoded) {
        DWORD cValue;
        LONG lAllValues;
        DWORD HashBucketIndex;
        CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara,
                rgValueBlob
                )))
            goto ExtractValuesError;

        if (cEntry == cAllocEntry) {
            PHASH_BUCKET_ENTRY pNewHashBucketEntry;

            cAllocEntry += DEFAULT_CTL_ENTRY_COUNT;
            if (NULL == (pNewHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiRealloc(
                    pHashBucketEntry, sizeof(HASH_BUCKET_ENTRY) * cAllocEntry)))
                goto OutOfMemory;
            pHashBucketEntry = pNewHashBucketEntry;
        }

        if (0 == cEntry)
            // Entry[0] is used to indicate no entries for the indexed
            // HashBucket
            cEntry++;

        HashBucketIndex = GetHashBucketIndex(
            cHashBucket,
            FALSE,                  // fHashedIdentifier,
            &rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX]
            );

#if DBG
        {
            DWORD dwEntryIndex = pdwHashBucketHead[HashBucketIndex];
            DWORD dwCollision = 1;
            while (dwEntryIndex) {
                dwCollision++;
                dwEntryIndex = pHashBucketEntry[dwEntryIndex].iNext;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#endif

        pHashBucketEntry[cEntry].iNext = pdwHashBucketHead[HashBucketIndex];
        pHashBucketEntry[cEntry].pbEntry = pbEncoded;
        pdwHashBucketHead[HashBucketIndex] = cEntry;
        cEntry++;

        cbEncoded -= lAllValues;
        pbEncoded += lAllValues;
    }

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

#if DBG
    DbgPrintf(DBG_SS_CRYPT32,
        "CreateSortedCtlHashBuckets:: cEntry: %d cHashBucket: %d MaxCollision: %d\n",
        cEntry, cHashBucket, dwMaxCollision);
#endif

    pSortedCtlFindInfo->cHashBucket = cHashBucket;
    pSortedCtlFindInfo->pdwHashBucketHead = pdwHashBucketHead;
    pSortedCtlFindInfo->pHashBucketEntry = pHashBucketEntry;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pdwHashBucketHead);
    PkiFree(pHashBucketEntry);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


STATIC BOOL FastDecodeCtlSubjects(
    IN const BYTE *pbEncodedSubjects,
    IN DWORD cbEncodedSubjects,
    OUT DWORD *pcCTLEntry,
    OUT PCTL_ENTRY *ppCTLEntry
    )
{
    BOOL fResult;

    PCTL_ENTRY pAllocEntry = NULL;
    DWORD cAllocEntry;
    DWORD cbAllocEntry;

    DWORD cEntry = 0;
    PCTL_ENTRY pEntry;
    DWORD cbEntryEncoded;
    const BYTE *pbEntryEncoded;

    DWORD cAttr = 0;
    PCRYPT_ATTRIBUTE pAttr;

    DWORD cAttrValue = 0;
    PCRYPT_ATTR_BLOB pAttrValue;

    DWORD cValue;
    LONG lAllValues;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    // First: Loop through the encoded trusted subjects. Get total count of
    // Entries, Attributes and Values.
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cEntry++;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cAttr++;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;
                cAttrValue++;
                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }
        }
    }

    cAllocEntry = cEntry;
    if (0 == cEntry)
        goto SuccessReturn;

    cbAllocEntry = cEntry * sizeof(CTL_ENTRY) +
        cAttr * sizeof(CRYPT_ATTRIBUTE) +
        cAttrValue * sizeof(CRYPT_ATTR_BLOB);

    if (NULL == (pAllocEntry = (PCTL_ENTRY) PkiZeroAlloc(cbAllocEntry)))
        goto OutOfMemory;

    pEntry = pAllocEntry;
    pAttr = (PCRYPT_ATTRIBUTE) (pEntry + cEntry);
    pAttrValue = (PCRYPT_ATTR_BLOB) (pAttr + cAttr);

    // Second: Loop through the encoded trusted subjects. Update the
    // allocated Entries, Attributes and Values data structures
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        assert(0 != cEntry);
        if (0 == cEntry--)
            goto InvalidCountError;
        pEntry->SubjectIdentifier =
            rgEntryValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            ASN1encodedOID_t EncodedOid;
            BYTE *pbExtra;
            LONG lRemainExtra;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            assert(0 != cAttr);
            if (0 == cAttr--)
                goto InvalidCountError;

            if (0 == pEntry->cAttribute) {
                pEntry->cAttribute = 1;
                pEntry->rgAttribute = pAttr;
            } else
                pEntry->cAttribute++;

            EncodedOid.length = (ASN1uint16_t)
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].cbData;
            EncodedOid.value =
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].pbData;

            pbExtra = NULL;
            lRemainExtra = 0;
            I_CryptGetEncodedOID(
                &EncodedOid,
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &pAttr->pszObjId,
                &pbExtra,
                &lRemainExtra
                );

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;

                assert(0 != cAttrValue);
                if (0 == cAttrValue--)
                    goto InvalidCountError;

                if (0 == pAttr->cValue) {
                    pAttr->cValue = 1;
                    pAttr->rgValue = pAttrValue;
                } else
                    pAttr->cValue++;

                pAttrValue->cbData = cbAttrValue;
                pAttrValue->pbData = (BYTE *) pbAttrValueEncoded;
                pAttrValue++;

                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }

            pAttr++;
        }

        pEntry++;
    }

    assert(0 == cEntry && 0 == cAttr && 0 == cAttrValue);

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }
        

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcCTLEntry = cAllocEntry;
    *ppCTLEntry = pAllocEntry;
    return fResult;

ErrorReturn:
    PkiFree(pAllocEntry);
    pAllocEntry = NULL;
    cAllocEntry = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ExtractEntryError, ERROR_INVALID_DATA)
SET_ERROR(ExtractAttrError, ERROR_INVALID_DATA)
SET_ERROR(ExtractValueError, ERROR_INVALID_DATA)
SET_ERROR(InvalidCountError, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle,
    IN DWORD dwFlags
    )
{
    DWORD dwEncodingType;
    const BYTE *pbContent;                     // not allocated
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;             // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated

    const BYTE *pbCtlEncodedHdr;                // not allocated
    DWORD cbCtlEncodedHdr;
    BYTE *pbCtlReencodedHdr = NULL;
    DWORD cbCtlReencodedHdr;
    DWORD cCtlValue;
    CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
    const BYTE *pbEncodedSubjects;              // not allocated
    DWORD cbEncodedSubjects;
    const BYTE *pbSortedCtlExtValue;            // not allocated
    DWORD cbSortedCtlExtValue;
    const BYTE *pbRemainExt;                    // not allocated
    DWORD cbRemainExt;

    PCERT_EXTENSIONS pExtInfo = NULL;
    BYTE *pbAllocReencodedExt = NULL;
    BYTE *pbReencodedExt = NULL;                // not allocated
    DWORD cbReencodedExt;

    HCRYPTMSG hMsg = NULL;
    PCTL_ENTRY pCTLEntry = NULL;
    DWORD cCTLEntry;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;


    // Advance to the encoded CTL_INFO
    if (0 >= Asn1UtilExtractPKCS7SignedDataContent(
            pbCtlEncoded,
            cbCtlEncoded,
            &EncodedOIDCtl,
            &cbContent,
            &pbContent
            ))
        goto ExtractSignedDataContentError;
    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto UnsupportedIndefiniteLength;

    // Get pointers to the encoded CTL_INFO values
    cCtlValue = CTL_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbContent,
            cbContent,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cCtlValue,
            rgExtractCtlPara,
            rgCtlValueBlob
            ))
        goto ExtractCtlValuesError;

    pbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
    cbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;

    // Initialize pointer to and length of the Extensions sequence
    pbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;

    // Get pointer to the first value in the CTL sequence. Get length
    // through the subjectAlgorithm value. Don't include the TrustedSubjects
    // or Extensions.

    pbCtlEncodedHdr = rgCtlValueBlob[CTL_SEQ_VALUE_INDEX].pbData;
    cbCtlEncodedHdr = (DWORD)(rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].pbData +
        rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].cbData -
        pbCtlEncodedHdr);

    // Re-encode the CTL excluding the TrustedSubjects and Extensions.
    // Re-encode the CTL sequence to have an indefinite length and terminated
    // with a NULL tag and length.
    cbCtlReencodedHdr = cbCtlEncodedHdr + 2 + 2;
    if (NULL == (pbCtlReencodedHdr = (BYTE *) PkiNonzeroAlloc(
            cbCtlReencodedHdr)))
        goto OutOfMemory;
    pbCtlReencodedHdr[0] = ASN1UTIL_TAG_SEQ;
    pbCtlReencodedHdr[1] = ASN1UTIL_LENGTH_INDEFINITE;
    memcpy(pbCtlReencodedHdr + 2, pbCtlEncodedHdr, cbCtlEncodedHdr);
    pbCtlReencodedHdr[cbCtlEncodedHdr + 2] = ASN1UTIL_TAG_NULL;
    pbCtlReencodedHdr[cbCtlEncodedHdr + 3] = ASN1UTIL_LENGTH_NULL;

    // Decode CTL_INFO excluding the TrustedSubjects and Extensions
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbCtlReencodedHdr,
                cbCtlReencodedHdr,
                0                       // dwFlags
                ))) goto DecodeCtlError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) +
            sizeof(CTL_CONTEXT) + sizeof(CTL_CONTEXT_SUFFIX) +
            sizeof(SORTED_CTL_FIND_INFO))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;
    pEle->pShareEle = pShareEle;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = (BYTE *) pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    // pCtl->hCryptMsg = NULL;
    pCtl->pbCtlContent = (BYTE *) pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    // pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->fFastCreate = TRUE;

    if (0 == (dwFlags & CERT_CREATE_CONTEXT_SORTED_FLAG)) {
        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_ENTRY_FLAG)) {
            if (!FastDecodeCtlSubjects(
                    pbEncodedSubjects,
                    cbEncodedSubjects,
                    &cCTLEntry,
                    &pCTLEntry
                    ))
                goto FastDecodeCtlSubjectsError;
            pInfo->cCTLEntry = cCTLEntry;
            pInfo->rgCTLEntry = pCTLEntry;
            pCtlSuffix->pCTLEntry = pCTLEntry;
        }

        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG)) {
            BOOL fResult;
            DWORD dwLastErr = 0;
            HCRYPTPROV hProv = 0;
            DWORD dwProvFlags = 0;

            // Attempt to get the store's crypt provider. Serialize crypto
            // operations.
            hProv = GetCryptProv(pStore, &dwProvFlags);

            hMsg = CryptMsgOpenToDecode(
                    dwMsgAndCertEncodingType,
                    0,                          // dwFlags
                    0,                          // dwMsgType
                    hProv,
                    NULL,                       // pRecipientInfo
                    NULL                        // pStreamInfo
                    );
            if (hMsg && CryptMsgUpdate(
                    hMsg,
                    pbCtlEncoded,
                    cbCtlEncoded,
                    TRUE                    // fFinal
                    ))
                fResult = TRUE;
            else {
                fResult = FALSE;
                dwLastErr = GetLastError();
            }

            // For the store's crypt provider, release reference count. Leave
            // crypto operations critical section.
            ReleaseCryptProv(pStore, dwProvFlags);

            if (!fResult) {
                SetLastError(dwLastErr);
                goto MsgError;
            }

            pCtl->hCryptMsg = hMsg;
        }
    } else {
        pSortedCtlFindInfo = (PSORTED_CTL_FIND_INFO) ((BYTE *) pCtlSuffix +
            sizeof(CTL_CONTEXT_SUFFIX));
        pCtlSuffix->pSortedCtlFindInfo = pSortedCtlFindInfo;

        pSortedCtlFindInfo->pbEncodedSubjects = pbEncodedSubjects;
        pSortedCtlFindInfo->cbEncodedSubjects = cbEncodedSubjects;

        // Check if the CTL had the SORTED_CTL extension. If it does, update
        // the find info to point to the extension's hash bucket entry
        // offsets.
        if (ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbSortedCtlExtValue,
                &cbSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                )) {
            DWORD dwCtlExtFlags;

            if (SORTED_CTL_EXT_HASH_BUCKET_OFFSET > cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            memcpy(&dwCtlExtFlags,
                pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->fHashedIdentifier =
                dwCtlExtFlags & SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG;

            memcpy(&pSortedCtlFindInfo->cHashBucket,
                pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->pbEncodedHashBucket =
                pbSortedCtlExtValue + SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

            if (MAX_HASH_BUCKET_COUNT < pSortedCtlFindInfo->cHashBucket ||
                SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
                    (pSortedCtlFindInfo->cHashBucket + 1) * sizeof(DWORD) >
                        cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            if (0 == cbRemainExt)
                cbReencodedExt = 0;
            else {
                // Reencode the remaining extensions.
                // Re-encode the Extensions sequence to have an indefinite
                // length and terminated with a NULL tag and length.
                cbReencodedExt = cbRemainExt + 2 + 2;
                if (NULL == (pbAllocReencodedExt =
                        (BYTE *) PkiNonzeroAlloc(cbReencodedExt)))
                    goto OutOfMemory;
                pbReencodedExt = pbAllocReencodedExt;
                pbReencodedExt[0] = ASN1UTIL_TAG_SEQ;
                pbReencodedExt[1] = ASN1UTIL_LENGTH_INDEFINITE;
                memcpy(pbReencodedExt + 2, pbRemainExt, cbRemainExt);
                pbReencodedExt[cbRemainExt + 2] = ASN1UTIL_TAG_NULL;
                pbReencodedExt[cbRemainExt + 3] = ASN1UTIL_LENGTH_NULL;
            }
        } else if (cbEncodedSubjects) {
            if (!CreateSortedCtlHashBuckets(pSortedCtlFindInfo))
                goto CreateSortedCtlHashBucketsError;
        }
    }

    if (cbReencodedExt) {
        if (NULL == (pExtInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
                dwEncodingType,
                X509_EXTENSIONS,
                pbReencodedExt,
                cbReencodedExt,
                0                       // dwFlags
                ))) goto DecodeExtError;
        pInfo->cExtension = pExtInfo->cExtension;
        pInfo->rgExtension = pExtInfo->rgExtension;
        pCtlSuffix->pExtInfo = pExtInfo;
    }

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

    if (NULL == pShareEle) {
        CertPerfIncrementCtlElementCurrentCount();
        CertPerfIncrementCtlElementTotalCount();
    }

CommonReturn:
    PkiFree(pbCtlReencodedHdr);
    PkiFree(pbAllocReencodedExt);
    return pEle;
ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pExtInfo);
    PkiFree(pCTLEntry);

    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ExtractSignedDataContentError)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeCtlError)
TRACE_ERROR(DecodeExtError)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(CreateSortedCtlHashBucketsError)
TRACE_ERROR(FastDecodeCtlSubjectsError)
TRACE_ERROR(MsgError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

//+-------------------------------------------------------------------------
//  Creates the specified context from the encoded bytes. The created
//  context isn't put in a store.
//
//  dwContextType values:
//      CERT_STORE_CERTIFICATE_CONTEXT
//      CERT_STORE_CRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT
//
//  If CERT_CREATE_CONTEXT_NOCOPY_FLAG is set, the created context points
//  directly to the pbEncoded instead of an allocated copy. See flag
//  definition for more details.
//
//  If CERT_CREATE_CONTEXT_SORTED_FLAG is set, the context is created
//  with sorted entries. This flag may only be set for CERT_STORE_CTL_CONTEXT.
//  Setting this flag implicitly sets CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG and
//  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG. See flag definition for
//  more details.
//
//  If CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG is set, the context is created
//  without creating a HCRYPTMSG handle for the context. This flag may only be
//  set for CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If CERT_CREATE_CONTEXT_NO_ENTRY_FLAG is set, the context is created
//  without decoding the entries. This flag may only be set for
//  CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If unable to decode and create the context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT, CRL_CONTEXT or
//  CTL_CONTEXT is returned. The context must be freed by the appropriate
//  free context API. The context can be duplicated by calling the
//  appropriate duplicate context API.
//--------------------------------------------------------------------------
const void *
WINAPI
CertCreateContext(
    IN DWORD dwContextType,
    IN DWORD dwEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_CREATE_CONTEXT_PARA pCreatePara
    )
{
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo = NULL;
    PCONTEXT_ELEMENT pStoreEle;                 // not allocated

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    dwContextType--;
    if (CONTEXT_COUNT <= dwContextType)
        goto InvalidContextType;

    if (dwFlags & CERT_CREATE_CONTEXT_NOCOPY_FLAG) {
        if (NULL == (pNoCopyInfo = (PCONTEXT_NOCOPY_INFO) PkiZeroAlloc(
                sizeof(CONTEXT_NOCOPY_INFO))))
            goto OutOfMemory;
        if (pCreatePara && pCreatePara->cbSize >=
                offsetof(CERT_CREATE_CONTEXT_PARA, pfnFree) +
                    sizeof(pCreatePara->pfnFree)) {
            pNoCopyInfo->pfnFree = pCreatePara->pfnFree;
            if (pCreatePara->cbSize >=
                    offsetof(CERT_CREATE_CONTEXT_PARA, pvFree) +
                        sizeof(pCreatePara->pvFree) &&
                    pCreatePara->pvFree)
                pNoCopyInfo->pvFree = pCreatePara->pvFree;
            else
                pNoCopyInfo->pvFree = (void *) pbEncoded;
        }
    } else {
        if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
            goto OutOfMemory;

        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        pbEncoded = pbAllocEncoded;
    }

    if (CERT_STORE_CTL_CONTEXT - 1 == dwContextType)
        pEle = FastCreateCtlElement(
                &NullCertStore,
                dwEncodingType,
                pbEncoded,
                cbEncoded,
                NULL,                   // pShareEle
                dwFlags
                );
    else
        pEle = rgpfnCreateElement[dwContextType](
            &NullCertStore,
            dwEncodingType,
            (BYTE *) pbEncoded,
            cbEncoded,
            NULL                    // pShareEle
            );
    if (NULL == pEle)
        goto CreateElementError;

    pEle->pNoCopyInfo = pNoCopyInfo;

    if (!AddElementToStore(
            &NullCertStore,
            pEle,
            CERT_STORE_ADD_ALWAYS,
            &pStoreEle
            ))
        goto AddElementError;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    // Any To*Context would work
    return ToCertContext(pStoreEle);

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else if (pNoCopyInfo) {
        if (pNoCopyInfo->pfnFree)
            pNoCopyInfo->pfnFree(pNoCopyInfo->pvFree);
        PkiFree(pNoCopyInfo);
    } else
        PkiFree(pbAllocEncoded);
    pStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidContextType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


STATIC BOOL IsTrustedSubject(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN OUT const BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT BOOL *pfTrusted,
    OUT OPTIONAL PCRYPT_DATA_BLOB pEncodedAttributes
    )
{
    const BYTE *pbEncoded = *ppbEncoded;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            ))) {
        *pfTrusted = FALSE;
        return FALSE;
    }
    if (pSubjectIdentifier->cbData ==
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].cbData
                        &&
            0 == memcmp(pSubjectIdentifier->pbData,
                rgValueBlob[
                    TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].pbData,
                pSubjectIdentifier->cbData)) {
        *pfTrusted = TRUE;
        if (pEncodedAttributes)
            *pEncodedAttributes =
                rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];
    } else {
        cbEncoded -= lAllValues;
        *pcbEncoded = cbEncoded;
        pbEncoded += lAllValues;
        *ppbEncoded = pbEncoded;
        *pfTrusted = FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the SubjectIdentifier exists in the CTL. Optionally
//  returns a pointer to and byte count of the Subject's encoded attributes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindSubjectInSortedCTL(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    PCONTEXT_ELEMENT pCacheEle;                     // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;       // not allocated
    DWORD HashBucketIndex;
    BOOL fTrusted;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    HashBucketIndex = GetHashBucketIndex(
        pSortedCtlFindInfo->cHashBucket,
        pSortedCtlFindInfo->fHashedIdentifier,
        pSubjectIdentifier
        );

    if (pSortedCtlFindInfo->pbEncodedHashBucket) {
        DWORD dwEntryOffset[2];
        DWORD cbEncoded;
        const BYTE *pbEncoded;

        memcpy(dwEntryOffset, pSortedCtlFindInfo->pbEncodedHashBucket +
            sizeof(DWORD) * HashBucketIndex, sizeof(DWORD) * 2);

        if (dwEntryOffset[1] < dwEntryOffset[0] ||
                dwEntryOffset[1] > pCtlContext->cbCtlContent)
            goto InvalidSortedCtlExtension;

        // Iterate through the encoded TrustedSubjects until a match
        // or reached a TrustedSubject in the next HashBucket.
        cbEncoded = dwEntryOffset[1] - dwEntryOffset[0];
        pbEncoded = pCtlContext->pbCtlContent + dwEntryOffset[0];

        while (cbEncoded) {
            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;
        }
    } else if (pSortedCtlFindInfo->pdwHashBucketHead) {
        DWORD dwEntryIndex;

        dwEntryIndex = pSortedCtlFindInfo->pdwHashBucketHead[HashBucketIndex];
        while (dwEntryIndex) {
            PHASH_BUCKET_ENTRY pHashBucketEntry;
            DWORD cbEncoded;
            const BYTE *pbEncoded;

            pHashBucketEntry =
                &pSortedCtlFindInfo->pHashBucketEntry[dwEntryIndex];
            pbEncoded = pHashBucketEntry->pbEntry;
            assert(pbEncoded >= pSortedCtlFindInfo->pbEncodedSubjects &&
                pbEncoded < pSortedCtlFindInfo->pbEncodedSubjects +
                    pSortedCtlFindInfo->cbEncodedSubjects);
            cbEncoded = (DWORD)(pSortedCtlFindInfo->cbEncodedSubjects -
                (pbEncoded - pSortedCtlFindInfo->pbEncodedSubjects));
            assert(cbEncoded);

            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;

            dwEntryIndex = pHashBucketEntry->iNext;
        }
    }

    goto NotFoundError;

CommonReturn:
    return fTrusted;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    fTrusted = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(IsTrustedSubjectError)
}


//+-------------------------------------------------------------------------
//  Enumerates through the sequence of TrustedSubjects in a CTL context
//  created with CERT_CREATE_CONTEXT_SORTED_FLAG set.
//
//  To start the enumeration, *ppvNextSubject must be NULL. Upon return,
//  *ppvNextSubject is updated to point to the next TrustedSubject in
//  the encoded sequence.
//
//  Returns FALSE for no more subjects or invalid arguments.
//
//  Note, the returned DER_BLOBs point directly into the encoded
//  bytes (not allocated, and must not be freed).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSubjectInSortedCTL(
    IN PCCTL_CONTEXT pCtlContext,
    IN OUT void **ppvNextSubject,
    OUT OPTIONAL PCRYPT_DER_BLOB pSubjectIdentifier,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;                 // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated
    const BYTE *pbEncodedSubjects;
    const BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;
    if (0 == cbEncoded)
        goto NotFoundError;

    pbEncodedSubjects = pSortedCtlFindInfo->pbEncodedSubjects;
    pbEncoded = *((const BYTE **) ppvNextSubject);
    if (NULL == pbEncoded)
        pbEncoded = pbEncodedSubjects;
    else if (pbEncoded < pbEncodedSubjects ||
            pbEncoded >= pbEncodedSubjects + cbEncoded)
        goto NotFoundError;
    else
        cbEncoded -= (DWORD)(pbEncoded - pbEncodedSubjects);

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    if (pSubjectIdentifier)
        *pSubjectIdentifier =
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];
    if (pEncodedAttributes)
        *pEncodedAttributes =
            rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];

    pbEncoded += lAllValues;
    *((const BYTE **) ppvNextSubject) = pbEncoded;
    fResult = TRUE;
CommonReturn:
    return fResult;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    *ppvNextSubject = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
TRACE_ERROR(ExtractValuesError)
}

//+=========================================================================
// Key Identifier Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Decode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC PKEYID_ELEMENT DecodeKeyIdElement(
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    PKEYID_ELEMENT pEle = NULL;
    DWORD csStatus;
    MEMINFO MemInfo;

    MemInfo.pByte = (BYTE *) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbElement,
        NULL,                       // pStore
        0,                          // dwAddDisposition
        0,                          // dwContextTypeFlags
        NULL,                       // pdwContextType
        (const void **) &pEle,
        TRUE                        // fKeyIdAllowed
        );

    if (NULL == pEle && CSError != csStatus)
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);

    return pEle;
}

STATIC BOOL SerializeKeyIdElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PKEYID_ELEMENT pEle
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;

    for (pPropEle = pEle->pPropHead; pPropEle; pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if (!WriteStoreElement(
                    h,
                    pfn,
                    0,                      // dwEncodingType
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    ))
                goto WriteElementError;
        }
    }

    if (!WriteStoreElement(
            h,
            pfn,
            0,              // dwEncodingType
            FILE_ELEMENT_KEYID_TYPE,
            pEle->KeyIdentifier.pbData,
            pEle->KeyIdentifier.cbData
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Encode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC BOOL EncodeKeyIdElement(
    IN PKEYID_ELEMENT pEle,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    memset(&MemInfo, 0, sizeof(MemInfo));
    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    cbElement = MemInfo.cbSeek;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    MemInfo.pByte = pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SerializeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Get the property for the specified Key Identifier.
//
//  The Key Identifier is the SHA1 hash of the encoded CERT_PUBLIC_KEY_INFO.
//  The Key Identifier for a certificate can be obtained by getting the
//  certificate's CERT_KEY_IDENTIFIER_PROP_ID. The
//  CryptCreateKeyIdentifierFromCSP API can be called to create the Key
//  Identifier from a CSP Public Key Blob.
//
//  A Key Identifier can have the same properties as a certificate context.
//  CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO
//  structure. Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData will exceed the size of the structure.
//
//  If CRYPT_KEYID_ALLOC_FLAG is set, then, *pvData is updated with a
//  pointer to allocated memory. LocalFree() must be called to free the
//  allocated memory.
//
//  By default, searches the CurrentUser's list of Key Identifiers.
//  CRYPT_KEYID_MACHINE_FLAG can be set to search the LocalMachine's list
//  of Key Identifiers. When CRYPT_KEYID_MACHINE_FLAG is set, pwszComputerName
//  can also be set to specify the name of a remote computer to be searched
//  instead of the local machine.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            ))
        goto ReadKeyIdElementError;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    fResult = GetCallerProperty(
        pKeyIdEle->pPropHead,
        dwPropId,
        dwFlags & CRYPT_KEYID_ALLOC_FLAG ? TRUE : FALSE,
        pvData,
        pcbData
        );

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_KEYID_ALLOC_FLAG)
        *((void **) pvData) = NULL;
    *pcbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(DecodeKeyIdElementError)
}


//+-------------------------------------------------------------------------
//  Set the property for the specified Key Identifier.
//
//  For CERT_KEY_PROV_INFO_PROP_ID pvData points to the
//  CRYPT_KEY_PROV_INFO data structure. For all other properties, pvData
//  points to a CRYPT_DATA_BLOB.
//
//  Setting pvData == NULL, deletes the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to set the property for a LocalMachine
//  Key Identifier. Set pwszComputerName, to select a remote computer.
//
//  If CRYPT_KEYID_DELETE_FLAG is set, the Key Identifier and all its
//  properties is deleted.
//
//  If CRYPT_KEYID_SET_NEW_FLAG is set, the set fails if the property already
//  exists. For an existing property, FALSE is returned with LastError set to
//  CRYPT_E_EXISTS.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN const void *pvData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (dwFlags & CRYPT_KEYID_DELETE_FLAG) {
        return ILS_DeleteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName
            );
    }

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto ReadKeyIdElementError;
    }

    if (NULL == pbElement) {
        BYTE *pbKeyIdEncoded;
        if (NULL == (pbKeyIdEncoded = (BYTE *) PkiNonzeroAlloc(
                pKeyIdentifier->cbData)))
            goto OutOfMemory;
        if (NULL == (pKeyIdEle = CreateKeyIdElement(
                pbKeyIdEncoded,
                pKeyIdentifier->cbData
                )))
            goto OutOfMemory;
    } else {
        if (NULL == (pKeyIdEle = DecodeKeyIdElement(
                pbElement,
                cbElement
                )))
            goto DecodeKeyIdElementError;
        }

        if (dwFlags & CRYPT_KEYID_SET_NEW_FLAG) {
            if (FindPropElement(pKeyIdEle->pPropHead, dwPropId))
                goto KeyIdExists;
    }

    if (!SetCallerProperty(
            &pKeyIdEle->pPropHead,
            dwPropId,
            dwFlags,
            pvData
            ))
        goto SetCallerPropertyError;

    PkiFree(pbElement);
    pbElement = NULL;

    if (!EncodeKeyIdElement(
            pKeyIdEle,
            &pbElement,
            &cbElement
            ))
        goto EncodeKeyIdElementError;

    if (!ILS_WriteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            pbElement,
            cbElement
            ))
        goto WriteKeyIdElementError;

    fResult = TRUE;

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(KeyIdExists, CRYPT_E_EXISTS)
TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(SetCallerPropertyError)
TRACE_ERROR(EncodeKeyIdElementError)
TRACE_ERROR(WriteKeyIdElementError)
}

typedef struct _KEYID_ELEMENT_CALLBACK_ARG {
    DWORD                       dwPropId;
    DWORD                       dwFlags;
    void                        *pvArg;
    PFN_CRYPT_ENUM_KEYID_PROP   pfnEnum;
} KEYID_ELEMENT_CALLBACK_ARG, *PKEYID_ELEMENT_CALLBACK_ARG;

STATIC BOOL KeyIdElementCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    PKEYID_ELEMENT_CALLBACK_ARG pKeyIdArg =
        (PKEYID_ELEMENT_CALLBACK_ARG) pvArg;

    PKEYID_ELEMENT pKeyIdEle = NULL;
    PPROP_ELEMENT pPropEle;

    DWORD iProp;
    DWORD cProp = 0;
    DWORD *pdwPropId = NULL;
    void **ppvData = NULL;
    DWORD *pcbData = NULL;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    // Get number of properties
    cProp = 0;
    pPropEle = pKeyIdEle->pPropHead;
    for ( ; pPropEle; pPropEle = pPropEle->pNext) {
        if (pKeyIdArg->dwPropId) {
            if (pKeyIdArg->dwPropId == pPropEle->dwPropId) {
                cProp = 1;
                break;
            }
        } else
            cProp++;
    }

    if (0 == cProp) {
        if (0 == pKeyIdArg->dwPropId)
            fResult = pKeyIdArg->pfnEnum(
                pKeyIdentifier,
                0,                      // dwFlags
                NULL,                   // pvReserved
                pKeyIdArg->pvArg,
                0,                      // cProp
                NULL,                   // rgdwPropId
                NULL,                   // rgpvData
                NULL                    // rgcbData
                );
    } else {
        pdwPropId = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));
        ppvData = (void **) PkiZeroAlloc(cProp * sizeof(void *));
        pcbData = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));

        if (NULL == pdwPropId || NULL == ppvData || NULL == pcbData)
            goto OutOfMemory;

        iProp = 0;
        pPropEle = pKeyIdEle->pPropHead;
        for ( ; pPropEle; pPropEle = pPropEle->pNext) {
            if (pKeyIdArg->dwPropId &&
                    pKeyIdArg->dwPropId != pPropEle->dwPropId)
                continue;

            if (GetCallerProperty(
                    pPropEle,
                    pPropEle->dwPropId,
                    TRUE,                   // fAlloc
                    (void *) &ppvData[iProp],
                    &pcbData[iProp]
                    )) {
                pdwPropId[iProp] = pPropEle->dwPropId;
                iProp++;
                if (iProp == cProp)
                    break;
            }
        }

        if (0 == iProp)
            goto CommonReturn;

        fResult = pKeyIdArg->pfnEnum(
            pKeyIdentifier,
            0,                      // dwFlags
            NULL,                   // pvReserved
            pKeyIdArg->pvArg,
            iProp,
            pdwPropId,
            ppvData,
            pcbData
            );
    }


CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    if (ppvData) {
        while (cProp--)
            PkiDefaultCryptFree(ppvData[cProp]);
        PkiFree(ppvData);
    }
    PkiFree(pdwPropId);
    PkiFree(pcbData);
    return fResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Enumerate the Key Identifiers.
//
//  If pKeyIdentifier is NULL, enumerates all Key Identifers. Otherwise,
//  calls the callback for the specified KeyIdentifier. If dwPropId is
//  0, calls the callback with all the properties. Otherwise, only calls
//  the callback with the specified property (cProp = 1).
//  Furthermore, when dwPropId is specified, skips KeyIdentifiers not
//  having the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to enumerate the LocalMachine
//  Key Identifiers. Set pwszComputerName, to enumerate Key Identifiers on
//  a remote computer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumKeyIdentifierProperties(
    IN OPTIONAL const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg,
    IN PFN_CRYPT_ENUM_KEYID_PROP pfnEnum
    )
{
    BOOL fResult;

    KEYID_ELEMENT_CALLBACK_ARG KeyIdArg =
        { dwPropId, dwFlags, pvArg, pfnEnum };

    if (pKeyIdentifier) {
        BYTE *pbElement = NULL;
        DWORD cbElement;

        fResult = ILS_ReadKeyIdElement(
                pKeyIdentifier,
                dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
                pwszComputerName,
                &pbElement,
                &cbElement
                );
        if (fResult)
            fResult = KeyIdElementCallback(
                pKeyIdentifier,
                pbElement,
                cbElement,
                (void *) &KeyIdArg
                );
        PkiFree(pbElement);
    } else
        fResult = ILS_OpenAllKeyIdElements(
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            (void *) &KeyIdArg,
            KeyIdElementCallback
            );

    return fResult;
}

//+-------------------------------------------------------------------------
//  For either the CERT_KEY_IDENTIFIER_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID
//  set the Crypt KeyIdentifier CERT_KEY_PROV_INFO_PROP_ID property if the
//  other property already exists.
//
//  If dwPropId == 0, does an implicit GetProperty(KEY_PROV_INFO)
//--------------------------------------------------------------------------
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,              // may be 0
    IN const void *pvData
    )
{
    PCRYPT_HASH_BLOB pKeyIdentifier = NULL;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    void *pvOtherData = NULL;
    DWORD cbOtherData;
    CRYPT_HASH_BLOB OtherKeyIdentifier;

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        return;
    if (0 == dwPropId) {
        if (AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                (void **) &pKeyProvInfo,
                &cbKeyProvInfo
                ) && cbKeyProvInfo) {
            SetCryptKeyIdentifierKeyProvInfoProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo
                );
            PkiFree(pKeyProvInfo);
        }
        return;
    } else if (NULL == pvData)
        return;

    switch (dwPropId) {
        case CERT_KEY_IDENTIFIER_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyIdentifier = (PCRYPT_HASH_BLOB) pvData;
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvOtherData;
            }
            break;
        case CERT_KEY_PROV_INFO_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_IDENTIFIER_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvData;
                OtherKeyIdentifier.cbData = cbOtherData;
                OtherKeyIdentifier.pbData = (BYTE *)pvOtherData;
                pKeyIdentifier = &OtherKeyIdentifier;
            }
            break;
        default:
            return;
    }

    if (pvOtherData) {
        DWORD dwFlags = CRYPT_KEYID_SET_NEW_FLAG;
        if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
            dwFlags |= CRYPT_KEYID_MACHINE_FLAG;
        CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            dwFlags,
            NULL,               // pwszComputerName
            NULL,               // pvReserved
            (const void *) pKeyProvInfo
            );
        PkiFree(pvOtherData);
    }

}

//+-------------------------------------------------------------------------
//  Get the Key Identifier property for the specified element.
//
//  Only supported for certificates.
//--------------------------------------------------------------------------
STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    PCERT_INFO pCertInfo;
    PCERT_EXTENSION pExt;
    CRYPT_HASH_BLOB KeyIdentifier = { 0, NULL };
    BYTE rgbHash[MAX_HASH_LEN];

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        goto InvalidPropId;

    pCert = ToCertContext(pEle);
    pCertInfo = pCert->pCertInfo;

    if (pExt = CertFindExtension(
            szOID_SUBJECT_KEY_IDENTIFIER,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        // Skip by the octet tag, length bytes
        Asn1UtilExtractContent(
            pExt->Value.pbData,
            pExt->Value.cbData,
            &KeyIdentifier.cbData,
            (const BYTE **) &KeyIdentifier.pbData
            );
    }

    if (0 == KeyIdentifier.cbData) {
        const BYTE *pbPublicKeyInfo;
        DWORD cbPublicKeyInfo;
        if (!Asn1UtilExtractCertificatePublicKeyInfo(
                pCert->pbCertEncoded,
                pCert->cbCertEncoded,
                &cbPublicKeyInfo,
                &pbPublicKeyInfo
                ))
            goto ExtractPublicKeyInfoError;

        KeyIdentifier.cbData = sizeof(rgbHash);
        KeyIdentifier.pbData = rgbHash;
        if (!CryptHashCertificate(
                0,                      // hCryptProv
                CALG_SHA1,
                0,                      // dwFlags
                pbPublicKeyInfo,
                cbPublicKeyInfo,
                rgbHash,
                &KeyIdentifier.cbData
                ))
            goto HashPublicKeyInfoError;
    }

    if (!SetProperty(
            pEle,
            dwPropId,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            &KeyIdentifier
            ))
        goto SetKeyIdPropertyError;

    fResult = GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData
            );
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbData = 0;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(ExtractPublicKeyInfoError)
TRACE_ERROR(HashPublicKeyInfoError)
TRACE_ERROR(SetKeyIdPropertyError)
}

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    )
{
    if (CryptVerifyCertificateSignatureEx(
            hCryptProv,
            dwCertEncodingType,
            dwSubjectType,
            pvSubject,
            CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
            (void *) pIssuer,
            0,                                  // dwFlags
            NULL                                // pvReserved
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        PCCERT_CHAIN_CONTEXT pChainContext;
        CERT_CHAIN_PARA ChainPara;

        // Build a chain. Hopefully, the issuer inherit's its public key
        // parameters from up the chain

        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);
        if (CertGetCertificateChain(
                NULL,                   // hChainEngine
                pIssuer,
                NULL,                   // pTime
                pIssuer->hCertStore,
                &ChainPara,
                CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                NULL,                   // pvReserved
                &pChainContext
                ))
            CertFreeCertificateChain(pChainContext);

        // Try again. Hopefully the above chain building updated the issuer's
        // context property with the missing public key parameters
        return CryptVerifyCertificateSignatureEx(
                hCryptProv,
                dwCertEncodingType,
                dwSubjectType,
                pvSubject,
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuer,
                0,                                  // dwFlags
                NULL                                // pvReserved
                );
    }
}
#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\oidinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       oidinfo.h
//
//--------------------------------------------------------------------------

#define         IDS_EXT_AUTHORITY_KEY_IDENTIFIER    8000
#define         IDS_EXT_KEY_ATTRIBUTES              8001
#define         IDS_EXT_KEY_USAGE_RESTRICTION       8002
#define         IDS_EXT_SUBJECT_ALT_NAME            8003
#define         IDS_EXT_ISSUER_ALT_NAME             8004
#define         IDS_EXT_BASIC_CONSTRAINTS           8005
#define         IDS_EXT_KEY_USAGE                   8006
#define         IDS_EXT_CERT_POLICIES               8007
#define         IDS_EXT_SUBJECT_KEY_IDENTIFIER      8008
#define         IDS_EXT_CRL_REASON_CODE             8009
#define         IDS_EXT_CRL_DIST_POINTS             8010
#define         IDS_EXT_ENHANCED_KEY_USAGE          8011
#define         IDS_EXT_AUTHORITY_INFO_ACCESS       8012
#define         IDS_EXT_CERT_EXTENSIONS             8013
#define         IDS_EXT_NEXT_UPDATE_LOCATION        8014
#define         IDS_EXT_YESNO_TRUST_ATTR            8015
#define         IDS_EXT_RSA_emailAddr               8016
#define         IDS_EXT_RSA_unstructName            8017
#define         IDS_EXT_RSA_contentType             8018
#define         IDS_EXT_RSA_messageDigest           8019
#define         IDS_EXT_RSA_signingTime             8020
#define         IDS_EXT_RSA_counterSign             8021
#define         IDS_EXT_RSA_challengePwd            8022
#define         IDS_EXT_RSA_unstructAddr            8023
#define         IDS_EXT_RSA_SMIMECapabilities       8024
#define         IDS_EXT_RSA_preferSignedData        8025
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_CPS   8026
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE    8027
#define         IDS_EXT_PKIX_OCSP                   8028
#define         IDS_EXT_PKIX_CA_ISSUERS             8029
#define         IDS_EXT_MS_CERTIFICATE_TEMPLATE     8030
// Following was changed to IDS_ENHKEY_ENROLLMENT_AGENT
// #define         IDS_EXT_ENROLLMENT_AGENT            8031
#define         IDS_EXT_ENROLL_CERTTYPE             8032
#define         IDS_EXT_CERT_MANIFOLD               8033
#define         IDS_EXT_NETSCAPE_CERT_TYPE          8034
#define         IDS_EXT_NETSCAPE_BASE_URL           8035
#define         IDS_EXT_NETSCAPE_REVOCATION_URL     8036
#define         IDS_EXT_NETSCAPE_CA_REVOCATION_URL  8037
#define         IDS_EXT_NETSCAPE_CERT_RENEWAL_URL   8038
#define         IDS_EXT_NETSCAPE_CA_POLICY_URL      8039
#define         IDS_EXT_NETSCAPE_SSL_SERVER_NAME    8040
#define         IDS_EXT_NETSCAPE_COMMENT            8041
#define         IDS_EXT_SPC_SP_AGENCY_INFO_OBJID    8042
#define         IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID        8043
#define         IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID  8044
#define         IDS_EXT_COUNTRY_NAME                8045
#define         IDS_EXT_ORGANIZATION_NAME           8046
#define         IDS_EXT_ORGANIZATIONAL_UNIT_NAME    8047
#define         IDS_EXT_COMMON_NAME                 8048
#define         IDS_EXT_LOCALITY_NAME               8049
#define         IDS_EXT_STATE_OR_PROVINCE_NAME      8050
#define         IDS_EXT_TITLE                       8051
#define         IDS_EXT_GIVEN_NAME                  8052
#define         IDS_EXT_INITIALS                    8053
#define         IDS_EXT_SUR_NAME                    8054
#define         IDS_EXT_DOMAIN_COMPONENT            8055
#define         IDS_EXT_STREET_ADDRESS              8056
#define 	    IDS_EXT_DEVICE_SERIAL_NUMBER	    8057
#define 	    IDS_EXT_CA_VERSION		            8058
#define 	    IDS_EXT_SERIALIZED		            8059
#define 	    IDS_EXT_NT_PRINCIPAL_NAME	        8060
#define 	    IDS_EXT_PRODUCT_UPDATE		        8061
#define 	    IDS_EXT_ENROLLMENT_NAME_VALUE_PAIR  8062
#define 	    IDS_EXT_OS_VERSION                  8063
#define 	    IDS_EXT_ENROLLMENT_CSP_PROVIDER     8064
#define         IDS_EXT_CRL_NUMBER                  8065
#define         IDS_EXT_DELTA_CRL_INDICATOR         8066
#define         IDS_EXT_ISSUING_DIST_POINT          8067
#define         IDS_EXT_FRESHEST_CRL                8068
#define         IDS_EXT_NAME_CONSTRAINTS            8069
#define         IDS_EXT_POLICY_MAPPINGS             8070
#define         IDS_EXT_POLICY_CONSTRAINTS          8071
#define         IDS_EXT_CROSS_CERT_DIST_POINTS      8072
#define         IDS_EXT_APP_POLICIES                8073
#define         IDS_EXT_APP_POLICY_MAPPINGS         8074
#define         IDS_EXT_APP_POLICY_CONSTRAINTS      8075

// DSIE: Post Win2k, 8/2/2000.
#define         IDS_EXT_CT_PKI_DATA                 8076
#define         IDS_EXT_CT_PKI_RESPONSE             8077
#define         IDS_EXT_CMC                         8078
#define         IDS_EXT_CMC_STATUS_INFO             8079
#define         IDS_EXT_CMC_ADD_EXTENSIONS          8080
#define         IDS_EXT_CMC_ADD_ATTRIBUTES          8081
#define         IDS_EXT_PKCS_7_DATA                 8082
#define         IDS_EXT_PKCS_7_SIGNED               8083
#define         IDS_EXT_PKCS_7_ENVELOPED            8084
#define         IDS_EXT_PKCS_7_SIGNEDANDENVELOPED   8085
#define         IDS_EXT_PKCS_7_DIGESTED             8086
#define         IDS_EXT_PKCS_7_ENCRYPTED            8087
#define         IDS_EXT_CERTSRV_PREVIOUS_CERT_HASH  8088
#define         IDS_EXT_CRL_VIRTUAL_BASE            8089
#define         IDS_EXT_CRL_NEXT_PUBLISH            8090
#define         IDS_EXT_KP_CA_EXCHANGE              8091
#define         IDS_EXT_KP_KEY_RECOVERY_AGENT       8092
#define         IDS_EXT_CERTIFICATE_TEMPLATE        8093
#define         IDS_EXT_ENTERPRISE_OID_ROOT         8094
#define         IDS_EXT_RDN_DUMMY_SIGNER            8095
#define         IDS_EXT_ARCHIVED_KEY_ATTR           8096
#define         IDS_EXT_CRL_SELF_CDP                8097
#define         IDS_EXT_REQUIRE_CERT_CHAIN_POLICY   8098

#define         IDS_ENHKEY_PKIX_KP_SERVER_AUTH      8500
#define         IDS_ENHKEY_PKIX_KP_CLIENT_AUTH      8501
#define         IDS_ENHKEY_PKIX_KP_CODE_SIGNING     8502
#define         IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION 8503
#define         IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING 8504
#define         IDS_ENHKEY_KP_CTL_USAGE_SIGNING     8505
#define         IDS_ENHKEY_KP_TIME_STAMP_SIGNING    8506
#define         IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM 8507
#define         IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL     8508
#define         IDS_ENHKEY_PKIX_KP_IPSEC_USER       8509
#define         IDS_ENHKEY_SERVER_GATED_CRYPTO      8510
#define         IDS_ENHKEY_SGC_NETSCAPE             8511
#define         IDS_ENHKEY_KP_EFS                   8512
#define         IDS_ENHKEY_KP_WHQL                  8513
#define         IDS_ENHKEY_KP_NT5                   8514
#define         IDS_ENHKEY_KP_OEM_WHQL              8515
#define         IDS_ENHKEY_KP_EMBEDDED_NT           8516
#define 	    IDS_ENHKEY_LICENSES		            8517
#define 	    IDS_ENHKEY_LICENSES_SERVER	        8518
#define 	    IDS_ENHKEY_SMARTCARD_LOGON	        8519
#define 	    IDS_ENHKEY_DRM			            8520
#define         IDS_ENHKEY_KP_QUALIFIED_SUBORDINATION 8521
#define         IDS_ENHKEY_KP_KEY_RECOVERY          8522
#define         IDS_ENHKEY_KP_CODE_SIGNING          8523
#define         IDS_ENHKEY_KP_IPSEC_IKE_INTERMEDIATE 8524
#define 	    IDS_ENHKEY_EFS_RECOVERY			    8525

// DSIE: Post Win2k, 8/2/2000.
#define         IDS_ENHKEY_ROOT_LIST_SIGNER         8527
#define         IDS_ENHKEY_ANY_POLICY               8528
#define         IDS_ENHKEY_DS_EMAIL_REPLICATION     8529
#define         IDS_ENHKEY_ENROLLMENT_AGENT         8530
#define         IDS_ENHKEY_KP_KEY_RECOVERY_AGENT    8531
#define         IDS_ENHKEY_KP_CA_EXCHANGE           8532
#define 	    IDS_ENHKEY_KP_LIFETIME_SIGNING      8533

// DSIE: Post Win2K, 10/13/2000. Issuance Policy
#define         IDS_POLICY_ANY_POLICY               8600

#define         IDS_SYS_NAME_ROOT                   9000
#define         IDS_SYS_NAME_MY                     9001
#define         IDS_SYS_NAME_TRUST                  9002
#define         IDS_SYS_NAME_CA                     9003
#define         IDS_SYS_NAME_USERDS                 9004
#define         IDS_SYS_NAME_SMARTCARD              9005
#define         IDS_SYS_NAME_ADDRESSBOOK            9006
#define         IDS_SYS_NAME_TRUST_PUB              9007
#define         IDS_SYS_NAME_DISALLOWED             9008
#define         IDS_SYS_NAME_AUTH_ROOT              9009
#define         IDS_SYS_NAME_REQUEST                9010
#define         IDS_SYS_NAME_TRUST_PEOPLE           9011

#define         IDS_PHY_NAME_DEFAULT                9100
#define         IDS_PHY_NAME_GROUP_POLICY           9101
#define         IDS_PHY_NAME_LOCAL_MACHINE          9102
#define         IDS_PHY_NAME_DS_USER_CERT           9104
#define         IDS_PHY_NAME_ENTERPRISE             9105
#define         IDS_PHY_NAME_AUTH_ROOT              9106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\oidinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidinfo.cpp
//
//  Contents:   Cryptographic Object ID (OID) Info Functions
//
//  Functions:  I_CryptOIDInfoDllMain
//              CryptFindOIDInfo
//              CryptRegisterOIDInfo
//              CryptUnregisterOIDInfo
//              CryptEnumOIDInfo
//              CryptFindLocalizedName
//
//  Comments:
//
//  History:    24-May-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"   // wintrust.h is needed for SPC_ oids
#include "chain.h"      // chain.h is needed for ChainRetrieveObjectByUrlW()
                        // and ChainIsConnected()
#include "certca.h"     // certca.h is needed for CAOIDGetLdapURL()

// Initialized in I_CryptOIDInfoDllMain at ProcessAttach
static HMODULE hOIDInfoInst;

#define MAX_RESOURCE_OID_NAME_LENGTH    256
static LPCWSTR pwszNullName = L"";

#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_GROUP_PREFIX_CHAR    '!'
#define OID_INFO_ENCODING_TYPE          0
#define OID_INFO_NAME_VALUE_NAME        L"Name"
#define OID_INFO_ALGID_VALUE_NAME       L"Algid"
#define OID_INFO_EXTRA_INFO_VALUE_NAME  L"ExtraInfo"
#define OID_INFO_FLAGS_VALUE_NAME       L"Flags"



//+=========================================================================
//  OID Information Tables (by GROUP_ID)
//==========================================================================

#define OID_INFO_LEN sizeof(CRYPT_OID_INFO)

//+-------------------------------------------------------------------------
//  Hash Algorithm Table
//--------------------------------------------------------------------------
#define HASH_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_HASH_ALG_OID_GROUP_ID, Algid, 0, NULL

static CCRYPT_OID_INFO HashAlgTable[] = {
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha1", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha, L"sha", CALG_SHA),
    HASH_ALG_ENTRY(szOID_RSA_MD5, L"md5", CALG_MD5),
    HASH_ALG_ENTRY(szOID_RSA_MD4, L"md4", CALG_MD4),
    HASH_ALG_ENTRY(szOID_RSA_MD2, L"md2", CALG_MD2)
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))


//+-------------------------------------------------------------------------
//  Encryption Algorithm Table
//--------------------------------------------------------------------------
#define ENCRYPT_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

static CCRYPT_OID_INFO EncryptAlgTable[] = {
    ENCRYPT_ALG_ENTRY(szOID_OIWSEC_desCBC, L"des", CALG_DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_DES_EDE3_CBC, L"3des", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC2CBC, L"rc2", CALG_RC2),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC4, L"rc4", CALG_RC4),
#ifdef CMS_PKCS7
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgCMS3DESwrap, L"CMS3DESwrap", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgCMSRC2wrap, L"CMSRC2wrap", CALG_RC2),
#endif  // CMS_PKCS7
};
#define ENCRYPT_ALG_CNT (sizeof(EncryptAlgTable) / sizeof(EncryptAlgTable[0]))


//+-------------------------------------------------------------------------
//  Public Key Algorithm Table
//--------------------------------------------------------------------------
static const DWORD dwMosaicFlags = CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
                                        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

static const DWORD dwNoNullParaFlag = CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

#define PUBKEY_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

#define PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, Algid, dwFlags) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, sizeof(dwFlags), (BYTE *) &dwFlags

#define DSA_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DSS_SIGN, dwNoNullParaFlag)

#define DH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_SF, dwNoNullParaFlag)

#ifdef CMS_PKCS7
#define ESDH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_EPHEM, dwNoNullParaFlag)
#endif  // CMS_PKCS7

static CCRYPT_OID_INFO PubKeyAlgTable[] = {
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_KEYX),
    DSA_PUBKEY_ALG_ENTRY(szOID_X957_DSA, L"DSA"),
    DH_PUBKEY_ALG_ENTRY(szOID_ANSI_X942_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_SIGN),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_SIGN", CALG_RSA_SIGN),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSS"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA_SIGN"),
    DH_PUBKEY_ALG_ENTRY(szOID_RSA_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_OIWSEC_rsaXchg, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicKMandUpdSig,
        L"mosaicKMandUpdSig", CALG_DSS_SIGN, dwMosaicFlags),
#ifdef CMS_PKCS7
    ESDH_PUBKEY_ALG_ENTRY(szOID_RSA_SMIMEalgESDH, L"ESDH"),
#endif  // CMS_PKCS7
    PUBKEY_ALG_ENTRY(szOID_PKIX_NO_SIGNATURE, L"NO_SIGN", CALG_NO_SIGN),
};
#define PUBKEY_ALG_CNT (sizeof(PubKeyAlgTable) / sizeof(PubKeyAlgTable[0]))


//+-------------------------------------------------------------------------
//  Signature Algorithm Table
//--------------------------------------------------------------------------
static const ALG_ID aiRsaPubKey = CALG_RSA_SIGN;
static const DWORD rgdwMosaicSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};
static const DWORD rgdwDssSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};

#define SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiPubKey) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(aiPubKey), (BYTE *) &aiPubKey
#define RSA_SIGN_ALG_ENTRY(pszOID, pwszName, aiHash) \
    SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiRsaPubKey)

#define SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwExtra) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(rgdwExtra), (BYTE *) rgdwExtra

#define DSS_SIGN_ALG_ENTRY(pszOID, pwszName) \
    SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_SHA1, rgdwDssSign)

static CCRYPT_OID_INFO SignAlgTable[] = {
    RSA_SIGN_ALG_ENTRY(szOID_RSA_SHA1RSA, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD5RSA, L"md5RSA", CALG_MD5),
    DSS_SIGN_ALG_ENTRY(szOID_X957_SHA1DSA, L"sha1DSA"),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"shaRSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_shaRSA, L"shaRSA", CALG_SHA),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md5RSA, L"md5RSA", CALG_MD5),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD2RSA, L"md2RSA", CALG_MD2),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA2, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWDIR_md2RSA, L"md2RSA", CALG_MD2),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"sha1DSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"shaDSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_dsaSHA1,L"dsaSHA1"),
    SIGN_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicUpdatedSig, L"mosaicUpdatedSig",
        CALG_SHA, rgdwMosaicSign),
};
#define SIGN_ALG_CNT (sizeof(SignAlgTable) / sizeof(SignAlgTable[0]))


//+-------------------------------------------------------------------------
//  RDN Attribute Table
//--------------------------------------------------------------------------

// PLEASE UPDATE the following define in certstr.cpp if you add a new entry
// with a longer pwszName
// #define MAX_X500_KEY_LEN    64

// Ordered lists of acceptable RDN attribute value types. 0 terminates.
static const DWORD rgdwPrintableValueType[] = { CERT_RDN_PRINTABLE_STRING, 0 };
static const DWORD rgdwIA5ValueType[] = { CERT_RDN_IA5_STRING, 0 };
static const DWORD rgdwNumericValueType[] = { CERT_RDN_NUMERIC_STRING, 0 };
static const DWORD rgdwIA5orUTF8ValueType[] = { CERT_RDN_IA5_STRING,
                                                CERT_RDN_UTF8_STRING, 0 };

#define RDN_ATTR_ENTRY(pszOID, pwszName, rgdwValueType) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, \
    sizeof(rgdwValueType), (BYTE *) rgdwValueType
#define DEFAULT_RDN_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, 0, NULL

static CCRYPT_OID_INFO RDNAttrTable[] = {
    // Ordered with most commonly used key names at the beginning

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_COMMON_NAME, L"CN"),
    // Geographic attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_LOCALITY_NAME, L"L"),
    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATION_NAME, L"O"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME, L"OU"),

    // Verisign sticks the following in their cert names. Netscape uses the
    // "E" instead of the "Email". Will let "E" take precedence
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"E", rgdwIA5ValueType),
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"Email", rgdwIA5ValueType),

    // The following aren't used in Verisign's certs

    // Geographic attribute types:
    RDN_ATTR_ENTRY(szOID_COUNTRY_NAME, L"C", rgdwPrintableValueType),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"S"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"ST"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STREET_ADDRESS, L"STREET"),

    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"T"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"Title"),

    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"G"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GN"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GivenName"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"I"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"Initials"),

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_SUR_NAME, L"SN"),
//    RDN_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER, L"", rgdwPrintableValueType),

    // Pilot user attribute types:
    RDN_ATTR_ENTRY(szOID_DOMAIN_COMPONENT, L"DC", rgdwIA5orUTF8ValueType),

    // Explanatory attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_DESCRIPTION, L"Description"),
//  szOID_SEARCH_GUIDE                  "2.5.4.14"
//    DEFAULT_RDN_ATTR_ENTRY(szOID_BUSINESS_CATEGORY, L""),

    // Postal addressing attribute types:
//  szOID_POSTAL_ADDRESS                "2.5.4.16"
    DEFAULT_RDN_ATTR_ENTRY(szOID_POSTAL_CODE, L"PostalCode"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_POST_OFFICE_BOX, L"POBox"),
//    DEFAULT_RDN_ATTR_ENTRY(szOID_PHYSICAL_DELIVERY_OFFICE_NAME, L""),

    // Telecommunications addressing attribute types:
    RDN_ATTR_ENTRY(szOID_TELEPHONE_NUMBER, L"Phone", rgdwPrintableValueType),
//  szOID_TELEX_NUMBER                  "2.5.4.21"
//  szOID_TELETEXT_TERMINAL_IDENTIFIER  "2.5.4.22"
//  szOID_FACSIMILE_TELEPHONE_NUMBER    "2.5.4.23"

//  Following is used as a test case for a Numeric value
    RDN_ATTR_ENTRY(szOID_X21_ADDRESS, L"X21Address", rgdwNumericValueType),
//    RDN_ATTR_ENTRY(szOID_INTERNATIONAL_ISDN_NUMBER, L"", rgdwNumericValueType),
//  szOID_REGISTERED_ADDRESS            "2.5.4.26"
//    RDN_ATTR_ENTRY(szOID_DESTINATION_INDICATOR, L"", rgdwPrintableValueType)

    // Preference attribute types:
//  szOID_PREFERRED_DELIVERY_METHOD     "2.5.4.28"

    // OSI application attribute types:
//  szOID_PRESENTATION_ADDRESS          "2.5.4.29"
//  szOID_SUPPORTED_APPLICATION_CONTEXT "2.5.4.30"

    // Relational application attribute types:
//  szOID_MEMBER                        "2.5.4.31"
//  szOID_OWNER                         "2.5.4.32"
//  szOID_ROLE_OCCUPANT                 "2.5.4.33"
//  szOID_SEE_ALSO                      "2.5.4.34"

    // Security attribute types:
//  szOID_USER_PASSWORD                 "2.5.4.35"
//  szOID_USER_CERTIFICATE              "2.5.4.36"
//  szOID_CA_CERTIFICATE                "2.5.4.37"
//  szOID_AUTHORITY_REVOCATION_LIST     "2.5.4.38"
//  szOID_CERTIFICATE_REVOCATION_LIST   "2.5.4.39"
//  szOID_CROSS_CERTIFICATE_PAIR        "2.5.4.40"

    // Undocumented attribute types???
//#define szOID_???                         "2.5.4.41"

    DEFAULT_RDN_ATTR_ENTRY(szOID_DN_QUALIFIER, L"dnQualifier"),
};
#define RDN_ATTR_CNT (sizeof(RDNAttrTable) / sizeof(RDNAttrTable[0]))

//+-------------------------------------------------------------------------
//  Extension or Attribute Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define EXT_ATTR_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_EXT_OR_ATTR_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO ExtAttrTable[] = {
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER2,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_KEY_ATTRIBUTES,
        IDS_EXT_KEY_ATTRIBUTES),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE_RESTRICTION,
        IDS_EXT_KEY_USAGE_RESTRICTION),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME2,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME2,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS2,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE,
        IDS_EXT_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_CERT_POLICIES,
        IDS_EXT_CERT_POLICIES),
    EXT_ATTR_ENTRY(szOID_SUBJECT_KEY_IDENTIFIER,
        IDS_EXT_SUBJECT_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_CRL_REASON_CODE,
        IDS_EXT_CRL_REASON_CODE),
    EXT_ATTR_ENTRY(szOID_CRL_DIST_POINTS,
        IDS_EXT_CRL_DIST_POINTS),
    EXT_ATTR_ENTRY(szOID_ENHANCED_KEY_USAGE,
        IDS_EXT_ENHANCED_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_INFO_ACCESS,
        IDS_EXT_AUTHORITY_INFO_ACCESS),
    EXT_ATTR_ENTRY(szOID_CERT_EXTENSIONS,
        IDS_EXT_CERT_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_RSA_certExtensions,
        IDS_EXT_CERT_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_NEXT_UPDATE_LOCATION,
        IDS_EXT_NEXT_UPDATE_LOCATION),
    EXT_ATTR_ENTRY(szOID_YESNO_TRUST_ATTR,
        IDS_EXT_YESNO_TRUST_ATTR),
    EXT_ATTR_ENTRY(szOID_RSA_emailAddr,
        IDS_EXT_RSA_emailAddr),
    EXT_ATTR_ENTRY(szOID_RSA_unstructName,
        IDS_EXT_RSA_unstructName),
    EXT_ATTR_ENTRY(szOID_RSA_contentType,
        IDS_EXT_RSA_contentType),
    EXT_ATTR_ENTRY(szOID_RSA_messageDigest,
        IDS_EXT_RSA_messageDigest),
    EXT_ATTR_ENTRY(szOID_RSA_signingTime,
        IDS_EXT_RSA_signingTime),
    EXT_ATTR_ENTRY(szOID_RSA_counterSign,
        IDS_EXT_RSA_counterSign),
    EXT_ATTR_ENTRY(szOID_RSA_challengePwd,
        IDS_EXT_RSA_challengePwd),
    EXT_ATTR_ENTRY(szOID_RSA_unstructAddr,
        IDS_EXT_RSA_unstructAddr),
    EXT_ATTR_ENTRY(szOID_RSA_extCertAttrs, L""),
    EXT_ATTR_ENTRY(szOID_RSA_SMIMECapabilities,
        IDS_EXT_RSA_SMIMECapabilities),
    EXT_ATTR_ENTRY(szOID_RSA_preferSignedData,
        IDS_EXT_RSA_preferSignedData),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_CPS,
        IDS_EXT_PKIX_POLICY_QUALIFIER_CPS),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
        IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE),
    EXT_ATTR_ENTRY(szOID_PKIX_OCSP,
        IDS_EXT_PKIX_OCSP),
    EXT_ATTR_ENTRY(szOID_PKIX_CA_ISSUERS,
        IDS_EXT_PKIX_CA_ISSUERS),
    EXT_ATTR_ENTRY(szOID_ENROLL_CERTTYPE_EXTENSION,
        IDS_EXT_MS_CERTIFICATE_TEMPLATE),
    EXT_ATTR_ENTRY(szOID_ENROLL_CERTTYPE_EXTENSION,
        IDS_EXT_ENROLL_CERTTYPE),
    EXT_ATTR_ENTRY(szOID_CERT_MANIFOLD,
        IDS_EXT_CERT_MANIFOLD),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_TYPE,
        IDS_EXT_NETSCAPE_CERT_TYPE),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_BASE_URL,
        IDS_EXT_NETSCAPE_BASE_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_REVOCATION_URL,
        IDS_EXT_NETSCAPE_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_REVOCATION_URL,
        IDS_EXT_NETSCAPE_CA_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_RENEWAL_URL,
        IDS_EXT_NETSCAPE_CERT_RENEWAL_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_POLICY_URL,
        IDS_EXT_NETSCAPE_CA_POLICY_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_SSL_SERVER_NAME,
        IDS_EXT_NETSCAPE_SSL_SERVER_NAME),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_COMMENT,
        IDS_EXT_NETSCAPE_COMMENT),
    EXT_ATTR_ENTRY(SPC_SP_AGENCY_INFO_OBJID,
        IDS_EXT_SPC_SP_AGENCY_INFO_OBJID),
    EXT_ATTR_ENTRY(SPC_FINANCIAL_CRITERIA_OBJID,
        IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(SPC_MINIMAL_CRITERIA_OBJID,
        IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(szOID_COUNTRY_NAME,
        IDS_EXT_COUNTRY_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATION_NAME,
        IDS_EXT_ORGANIZATION_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME,
        IDS_EXT_ORGANIZATIONAL_UNIT_NAME),
    EXT_ATTR_ENTRY(szOID_COMMON_NAME,
        IDS_EXT_COMMON_NAME),
    EXT_ATTR_ENTRY(szOID_LOCALITY_NAME,
        IDS_EXT_LOCALITY_NAME),
    EXT_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME,
        IDS_EXT_STATE_OR_PROVINCE_NAME),
    EXT_ATTR_ENTRY(szOID_TITLE,
        IDS_EXT_TITLE),
    EXT_ATTR_ENTRY(szOID_GIVEN_NAME,
        IDS_EXT_GIVEN_NAME),
    EXT_ATTR_ENTRY(szOID_INITIALS,
        IDS_EXT_INITIALS),
    EXT_ATTR_ENTRY(szOID_SUR_NAME,
        IDS_EXT_SUR_NAME),
    EXT_ATTR_ENTRY(szOID_DOMAIN_COMPONENT,
        IDS_EXT_DOMAIN_COMPONENT),
    EXT_ATTR_ENTRY(szOID_STREET_ADDRESS,
        IDS_EXT_STREET_ADDRESS),
    EXT_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER,
        IDS_EXT_DEVICE_SERIAL_NUMBER),
    EXT_ATTR_ENTRY(szOID_CERTSRV_CA_VERSION,
        IDS_EXT_CA_VERSION),
    EXT_ATTR_ENTRY(szOID_SERIALIZED,
        IDS_EXT_SERIALIZED),
    EXT_ATTR_ENTRY(szOID_NT_PRINCIPAL_NAME,
        IDS_EXT_NT_PRINCIPAL_NAME),
    EXT_ATTR_ENTRY(szOID_PRODUCT_UPDATE,
        IDS_EXT_PRODUCT_UPDATE),
    EXT_ATTR_ENTRY(szOID_ENROLLMENT_NAME_VALUE_PAIR,
        IDS_EXT_ENROLLMENT_NAME_VALUE_PAIR),
    EXT_ATTR_ENTRY(szOID_OS_VERSION,
        IDS_EXT_OS_VERSION),
    EXT_ATTR_ENTRY(szOID_ENROLLMENT_CSP_PROVIDER,
        IDS_EXT_ENROLLMENT_CSP_PROVIDER),
    EXT_ATTR_ENTRY(szOID_CRL_NUMBER,
        IDS_EXT_CRL_NUMBER),
    EXT_ATTR_ENTRY(szOID_DELTA_CRL_INDICATOR,
        IDS_EXT_DELTA_CRL_INDICATOR),
    EXT_ATTR_ENTRY(szOID_ISSUING_DIST_POINT,
        IDS_EXT_ISSUING_DIST_POINT),
    EXT_ATTR_ENTRY(szOID_FRESHEST_CRL,
        IDS_EXT_FRESHEST_CRL),
    EXT_ATTR_ENTRY(szOID_NAME_CONSTRAINTS,
        IDS_EXT_NAME_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_POLICY_MAPPINGS,
        IDS_EXT_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_LEGACY_POLICY_MAPPINGS,
        IDS_EXT_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_POLICY_CONSTRAINTS,
        IDS_EXT_POLICY_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_CROSS_CERT_DIST_POINTS,
        IDS_EXT_CROSS_CERT_DIST_POINTS),
    EXT_ATTR_ENTRY(szOID_APPLICATION_CERT_POLICIES,
        IDS_EXT_APP_POLICIES),
    EXT_ATTR_ENTRY(szOID_APPLICATION_POLICY_MAPPINGS,
        IDS_EXT_APP_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_APPLICATION_POLICY_CONSTRAINTS,
        IDS_EXT_APP_POLICY_CONSTRAINTS),


    // DSIE: Post Win2K, 8/2/2000.
    EXT_ATTR_ENTRY(szOID_CT_PKI_DATA,
        IDS_EXT_CT_PKI_DATA),
    EXT_ATTR_ENTRY(szOID_CT_PKI_RESPONSE,
        IDS_EXT_CT_PKI_RESPONSE),
    EXT_ATTR_ENTRY(szOID_CMC,
        IDS_EXT_CMC),
    EXT_ATTR_ENTRY(szOID_CMC_STATUS_INFO,
        IDS_EXT_CMC_STATUS_INFO),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_EXTENSIONS,
        IDS_EXT_CMC_ADD_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_ATTRIBUTES,
        IDS_EXT_CMC_ADD_ATTRIBUTES),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_ATTRIBUTES,
        IDS_EXT_CMC_ADD_ATTRIBUTES),

    EXT_ATTR_ENTRY(szOID_PKCS_7_DATA,
        IDS_EXT_PKCS_7_DATA),
    EXT_ATTR_ENTRY(szOID_PKCS_7_SIGNED,
        IDS_EXT_PKCS_7_SIGNED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_ENVELOPED,
        IDS_EXT_PKCS_7_ENVELOPED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_SIGNEDANDENVELOPED,
        IDS_EXT_PKCS_7_SIGNEDANDENVELOPED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_DIGESTED,
        IDS_EXT_PKCS_7_DIGESTED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_ENCRYPTED,
        IDS_EXT_PKCS_7_ENCRYPTED),

    EXT_ATTR_ENTRY(szOID_CERTSRV_PREVIOUS_CERT_HASH,
        IDS_EXT_CERTSRV_PREVIOUS_CERT_HASH),
    EXT_ATTR_ENTRY(szOID_CRL_VIRTUAL_BASE,
        IDS_EXT_CRL_VIRTUAL_BASE),
    EXT_ATTR_ENTRY(szOID_CRL_NEXT_PUBLISH,
        IDS_EXT_CRL_NEXT_PUBLISH),
    EXT_ATTR_ENTRY(szOID_KP_CA_EXCHANGE,
        IDS_EXT_KP_CA_EXCHANGE),
    EXT_ATTR_ENTRY(szOID_KP_KEY_RECOVERY_AGENT,
        IDS_EXT_KP_KEY_RECOVERY_AGENT),
    EXT_ATTR_ENTRY(szOID_CERTIFICATE_TEMPLATE,
        IDS_EXT_CERTIFICATE_TEMPLATE),
    EXT_ATTR_ENTRY(szOID_ENTERPRISE_OID_ROOT,
        IDS_EXT_ENTERPRISE_OID_ROOT),
    EXT_ATTR_ENTRY(szOID_RDN_DUMMY_SIGNER,
        IDS_EXT_RDN_DUMMY_SIGNER),

    EXT_ATTR_ENTRY(szOID_ARCHIVED_KEY_ATTR,
        IDS_EXT_ARCHIVED_KEY_ATTR),
    EXT_ATTR_ENTRY(szOID_CRL_SELF_CDP,
        IDS_EXT_CRL_SELF_CDP),
    EXT_ATTR_ENTRY(szOID_REQUIRE_CERT_CHAIN_POLICY,
        IDS_EXT_REQUIRE_CERT_CHAIN_POLICY),
};


#define EXT_ATTR_CNT (sizeof(ExtAttrTable) / sizeof(ExtAttrTable[0]))

//+-------------------------------------------------------------------------
//  Enhanced Key Usage Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define ENHKEY_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO EnhKeyTable[] = {
    ENHKEY_ENTRY(szOID_PKIX_KP_SERVER_AUTH,
        IDS_ENHKEY_PKIX_KP_SERVER_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CLIENT_AUTH,
        IDS_ENHKEY_PKIX_KP_CLIENT_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CODE_SIGNING,
        IDS_ENHKEY_PKIX_KP_CODE_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_EMAIL_PROTECTION,
        IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION),
    ENHKEY_ENTRY(szOID_PKIX_KP_TIMESTAMP_SIGNING,
        IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING),
    ENHKEY_ENTRY(szOID_KP_CTL_USAGE_SIGNING,
        IDS_ENHKEY_KP_CTL_USAGE_SIGNING),
    ENHKEY_ENTRY(szOID_KP_TIME_STAMP_SIGNING,
        IDS_ENHKEY_KP_TIME_STAMP_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_END_SYSTEM,
        IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_TUNNEL,
        IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_USER,
        IDS_ENHKEY_PKIX_KP_IPSEC_USER),
   // ENHKEY_ENTRY(szOID_SERVER_GATED_CRYPTO,
   //     IDS_ENHKEY_SERVER_GATED_CRYPTO),
   // ENHKEY_ENTRY(szOID_SGC_NETSCAPE,
   //     IDS_ENHKEY_SGC_NETSCAPE),
    ENHKEY_ENTRY(szOID_KP_EFS,
        IDS_ENHKEY_KP_EFS),
    ENHKEY_ENTRY(szOID_WHQL_CRYPTO,
        IDS_ENHKEY_KP_WHQL),
    ENHKEY_ENTRY(szOID_NT5_CRYPTO,
        IDS_ENHKEY_KP_NT5),
    ENHKEY_ENTRY(szOID_OEM_WHQL_CRYPTO,
        IDS_ENHKEY_KP_OEM_WHQL),
    ENHKEY_ENTRY(szOID_EMBEDDED_NT_CRYPTO,
        IDS_ENHKEY_KP_EMBEDDED_NT),
    ENHKEY_ENTRY(szOID_LICENSES,
	IDS_ENHKEY_LICENSES),
    ENHKEY_ENTRY(szOID_LICENSE_SERVER,
	IDS_ENHKEY_LICENSES_SERVER),
    ENHKEY_ENTRY(szOID_KP_SMARTCARD_LOGON,
	IDS_ENHKEY_SMARTCARD_LOGON),
    ENHKEY_ENTRY(szOID_DRM,
	IDS_ENHKEY_DRM),
    ENHKEY_ENTRY(szOID_KP_QUALIFIED_SUBORDINATION,
        IDS_ENHKEY_KP_QUALIFIED_SUBORDINATION),
    ENHKEY_ENTRY(szOID_KP_KEY_RECOVERY,
        IDS_ENHKEY_KP_KEY_RECOVERY),
    ENHKEY_ENTRY(szOID_KP_DOCUMENT_SIGNING,
        IDS_ENHKEY_KP_CODE_SIGNING),
    ENHKEY_ENTRY(szOID_IPSEC_KP_IKE_INTERMEDIATE,
        IDS_ENHKEY_KP_IPSEC_IKE_INTERMEDIATE),
    ENHKEY_ENTRY(szOID_EFS_RECOVERY,
        IDS_ENHKEY_EFS_RECOVERY),

    //DSIE: 8/2/2000, Post Win2K.
    ENHKEY_ENTRY(szOID_ROOT_LIST_SIGNER,
        IDS_ENHKEY_ROOT_LIST_SIGNER),
    ENHKEY_ENTRY(szOID_ANY_APPLICATION_POLICY,
        IDS_ENHKEY_ANY_POLICY),
    ENHKEY_ENTRY(szOID_DS_EMAIL_REPLICATION,
        IDS_ENHKEY_DS_EMAIL_REPLICATION),
    ENHKEY_ENTRY(szOID_ENROLLMENT_AGENT,
        IDS_ENHKEY_ENROLLMENT_AGENT),
    ENHKEY_ENTRY(szOID_KP_KEY_RECOVERY_AGENT,
        IDS_ENHKEY_KP_KEY_RECOVERY_AGENT),
    ENHKEY_ENTRY(szOID_KP_CA_EXCHANGE,
        IDS_ENHKEY_KP_CA_EXCHANGE),
    ENHKEY_ENTRY(szOID_KP_LIFETIME_SIGNING,
        IDS_ENHKEY_KP_LIFETIME_SIGNING),
};
#define ENHKEY_CNT (sizeof(EnhKeyTable) / sizeof(EnhKeyTable[0]))

//+-------------------------------------------------------------------------
//  Policy Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define POLICY_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_POLICY_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO PolicyTable[] = {
    POLICY_ENTRY(szOID_ANY_CERT_POLICY,
        IDS_POLICY_ANY_POLICY),
};
#define POLICY_CNT (sizeof(PolicyTable) / sizeof(PolicyTable[0]))

#if 0

//+-------------------------------------------------------------------------
//  Template Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define TEMPLATE_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_TEMPLATE_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO TemplateTable[] = {
};
#define TEMPLATE_CNT (sizeof(TemplateTable) / sizeof(TemplateTable[0]))

#endif


//+=========================================================================
//  OID Group Tables
//
//  fLocalize is set to TRUE, if the CRYPT_OID_INFO's pwszName may be
//  a Resource ID that is used to get the localized name via LoadStringU().
//
//  Assumption, Resource ID's <= 0xFFFF.
//==========================================================================
typedef struct _GROUP_ENTRY {
    DWORD               cInfo;
    PCCRYPT_OID_INFO    rgInfo;
    BOOL                fLocalize;
} GROUP_ENTRY, *PGROUP_ENTRY;
typedef const GROUP_ENTRY CGROUP_ENTRY, *PCGROUP_ENTRY;

static CGROUP_ENTRY GroupTable[CRYPT_LAST_OID_GROUP_ID + 1] = {
    0, NULL, FALSE,                             // 0
    HASH_ALG_CNT, HashAlgTable, FALSE,          // 1
    ENCRYPT_ALG_CNT, EncryptAlgTable, FALSE,    // 2
    PUBKEY_ALG_CNT, PubKeyAlgTable, FALSE,      // 3
    SIGN_ALG_CNT, SignAlgTable, FALSE,          // 4
    RDN_ATTR_CNT, RDNAttrTable, FALSE,          // 5
    EXT_ATTR_CNT, ExtAttrTable, TRUE,           // 6
    ENHKEY_CNT, EnhKeyTable, TRUE,              // 7
    POLICY_CNT, PolicyTable, TRUE,              // 8
#if 0
    TEMPLATE_CNT, TemplateTable, TRUE,          // 9
#else
    0, NULL, FALSE,                             // 9
#endif
};


//+-------------------------------------------------------------------------
//  The following groups are dynamically updated from the registry on
//  CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static GROUP_ENTRY RegBeforeGroup;
static GROUP_ENTRY RegAfterGroup;

// Do the load once within a critical section
static BOOL fLoadedFromRegAndResources = FALSE;
static CRITICAL_SECTION LoadFromRegCriticalSection;


//+=========================================================================
//  DS Group Definitions and Data Structures
//==========================================================================

typedef struct _DS_GROUP_ENTRY {
    DWORD               cInfo;
    PCCRYPT_OID_INFO    *rgpInfo;
} DS_GROUP_ENTRY, *PDS_GROUP_ENTRY;
typedef const DS_GROUP_ENTRY CDS_GROUP_ENTRY, *PCDS_GROUP_ENTRY;

// The DS group is dynamically updated from the DS on the first call
// to CryptFindOIDInfo or CryptEnumOIDInfo for the ENHKEY, POLICY or
// TEMPLATE groups.
static DS_GROUP_ENTRY DsGroup;

// The above DsGroup is updated every DS_RETRIEVAL_DELTA_SECONDS. Since
// any returned PCCRYPT_OID_INFO can not be freed, the following group contains
// PCCRYPT_OID_INFO entries that may have been deleted from the above DS group.
static DS_GROUP_ENTRY DsDeletedGroup;

static CRITICAL_SECTION DsCriticalSection;

// For a successful DS retrieval, the following is updated with
// CurrentTime + DS_RETRIEVAL_DELTA_SECONDS.
static FILETIME DsNextUpdateTime;

#define DS_RETRIEVAL_DELTA_SECONDS  (60 * 60 * 8)
#define DS_LDAP_TIMEOUT             (10 * 1000)


static void FreeDsGroups();

static PCCRYPT_OID_INFO SearchDsGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId
    );

static BOOL EnumDsGroup(
    IN DWORD dwGroupId,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    );


//+=========================================================================
//  Localized Name Definitions and Data Structures
//==========================================================================

//+-------------------------------------------------------------------------
//  Localized Name Information
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_NAME_INFO {
    LPCWSTR         pwszCryptName;
    union {
        UINT            uIDLocalizedName;
        LPCWSTR         pwszLocalizedName;
    };
} LOCALIZED_NAME_INFO, *PLOCALIZED_NAME_INFO;


//+-------------------------------------------------------------------------
//  Predefined Localized Names Table (Localized via resource strings)
//--------------------------------------------------------------------------
static LOCALIZED_NAME_INFO PredefinedNameTable[] = {
    // System store names
    L"Root",        IDS_SYS_NAME_ROOT,
    L"My",          IDS_SYS_NAME_MY,
    L"Trust",       IDS_SYS_NAME_TRUST,
    L"CA",          IDS_SYS_NAME_CA,
    L"UserDS",      IDS_SYS_NAME_USERDS,
    L"SmartCard",   IDS_SYS_NAME_SMARTCARD,
    L"AddressBook", IDS_SYS_NAME_ADDRESSBOOK,
    L"TrustedPublisher", IDS_SYS_NAME_TRUST_PUB,
    L"Disallowed",  IDS_SYS_NAME_DISALLOWED,
    L"AuthRoot",    IDS_SYS_NAME_AUTH_ROOT,
    L"Request",     IDS_SYS_NAME_REQUEST,
    L"TrustedPeople", IDS_SYS_NAME_TRUST_PEOPLE,

    // Physical store names
    CERT_PHYSICAL_STORE_DEFAULT_NAME,           IDS_PHY_NAME_DEFAULT,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,      IDS_PHY_NAME_GROUP_POLICY,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,     IDS_PHY_NAME_LOCAL_MACHINE,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME, IDS_PHY_NAME_DS_USER_CERT,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,        IDS_PHY_NAME_ENTERPRISE,
    CERT_PHYSICAL_STORE_AUTH_ROOT_NAME,         IDS_PHY_NAME_AUTH_ROOT,
};
#define PREDEFINED_NAME_CNT  (sizeof(PredefinedNameTable) / \
                                    sizeof(PredefinedNameTable[0]))

//+-------------------------------------------------------------------------
//  Localized Name Group Table
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_GROUP_ENTRY {
    DWORD                   cInfo;
    PLOCALIZED_NAME_INFO    rgInfo;
} LOCALIZED_GROUP_ENTRY, *PLOCALIZED_GROUP_ENTRY;

#define REG_LOCALIZED_GROUP             0
#define PREDEFINED_LOCALIZED_GROUP      1
static LOCALIZED_GROUP_ENTRY LocalizedGroupTable[] = {
    // 0 - Loaded from registry
    0, NULL,
    // 1 - Predefined list of names
    PREDEFINED_NAME_CNT, PredefinedNameTable
};
#define LOCALIZED_GROUP_CNT  (sizeof(LocalizedGroupTable) / \
                                    sizeof(LocalizedGroupTable[0]))

// The localized names are loaded once. Uses the above
// LoadFromRegCriticalSection;
static BOOL fLoadedLocalizedNames = FALSE;


//+-------------------------------------------------------------------------
//  OIDInfo allocation and free functions
//--------------------------------------------------------------------------
static void *OIDInfoAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void *OIDInfoRealloc(
    IN void *pvOrg,
    IN size_t cb
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cb) : malloc(cb)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void OIDInfoFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Functions called at ProcessDetach to free the groups updated from the
//  registry during CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static void FreeGroup(
    PGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++)
        OIDInfoFree((LPSTR)pInfo->pszOID);

    OIDInfoFree((PCRYPT_OID_INFO) pGroup->rgInfo);
}

static void FreeRegGroups()
{
    FreeGroup(&RegBeforeGroup);
    FreeGroup(&RegAfterGroup);
}

//+-------------------------------------------------------------------------
//  Free resource strings allocated in groups having localized pwszName's.
//--------------------------------------------------------------------------
static void FreeGroupResources()
{
    DWORD i;
    if (!fLoadedFromRegAndResources)
        // No resource strings allocated
        return;

    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;

            for ( ; cInfo > 0; cInfo--, pInfo++) {
                // pwszName is set to pwszNullName if the allocation failed
                if (pwszNullName != pInfo->pwszName) {
                    OIDInfoFree((LPWSTR) pInfo->pwszName);
                    pInfo->pwszName = pwszNullName;
                }
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Free memory allocated for localized names
//--------------------------------------------------------------------------
static void FreeLocalizedNames()
{
    if (!fLoadedLocalizedNames)
        // No resource strings allocated
        return;

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;

        for ( ; cInfo > 0; cInfo--, pInfo++) {
            LPWSTR pwszLocalizedName = (LPWSTR) pInfo->pwszLocalizedName;
            if (pwszNullName != pwszLocalizedName)
                OIDInfoFree(pwszLocalizedName);
        }
    }

    OIDInfoFree(LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDInfoDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hOIDInfoInst = hInst;
        fRet = Pki_InitializeCriticalSection(&LoadFromRegCriticalSection);
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(&DsCriticalSection);
            if (!fRet)
                DeleteCriticalSection(&LoadFromRegCriticalSection);
        }
        break;

    case DLL_PROCESS_DETACH:
        FreeRegGroups();
        FreeGroupResources();
        FreeLocalizedNames();
        DeleteCriticalSection(&LoadFromRegCriticalSection);

        FreeDsGroups();
        DeleteCriticalSection(&DsCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}


//+-------------------------------------------------------------------------
//  Allocated and format the string consisting of the OID and GROUP_ID:
//
//  For example: 1.2.3.4!6
//--------------------------------------------------------------------------
static LPSTR FormatOIDGroupString(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    LPSTR pszOIDGroupString;
    DWORD cchOIDGroupString;
    char szGroupId[34];

    if (NULL == pInfo || pInfo->cbSize < sizeof(CRYPT_OID_INFO) ||
            (DWORD_PTR) pInfo->pszOID <= 0xFFFF) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    szGroupId[0] = CONST_OID_GROUP_PREFIX_CHAR;
    _ltoa((long) pInfo->dwGroupId, &szGroupId[1], 10);

    cchOIDGroupString = strlen(pInfo->pszOID) +
        strlen(szGroupId) +
        1;

    if (pszOIDGroupString = (LPSTR) OIDInfoAlloc(cchOIDGroupString)) {
        strcpy(pszOIDGroupString, pInfo->pszOID);
        strcat(pszOIDGroupString, szGroupId);
    }

    return pszOIDGroupString;
}

//+-------------------------------------------------------------------------
//  Wrapper function for calling CryptSetOIDFunctionValue using OID info's
//  encoding type and function name.
//--------------------------------------------------------------------------
static BOOL SetOIDInfoRegValue(
    IN LPCSTR pszOIDGroupString,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    return CryptSetOIDFunctionValue(
        OID_INFO_ENCODING_TYPE,
        CRYPT_OID_FIND_OID_INFO_FUNC,
        pszOIDGroupString,
        pwszValueName,
        dwValueType,
        pbValueData,
        cbValueData
        );
}

//+-------------------------------------------------------------------------
//  Register OID information.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;

    if (pInfo->pwszName && L'\0' != *pInfo->pwszName) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_NAME_VALUE_NAME,
                REG_SZ,
                (const BYTE *) pInfo->pwszName,
                (wcslen(pInfo->pwszName) + 1) * sizeof(WCHAR)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->Algid) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_ALGID_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &pInfo->Algid,
                sizeof(pInfo->Algid)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->ExtraInfo.cbData) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_EXTRA_INFO_VALUE_NAME,
                REG_BINARY,
                pInfo->ExtraInfo.pbData,
                pInfo->ExtraInfo.cbData
                )) goto SetOIDInfoRegValueError;
    }

    if (0 != dwFlags) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_FLAGS_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &dwFlags,
                sizeof(dwFlags)
                )) goto SetOIDInfoRegValueError;
    }

    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(SetOIDInfoRegValueError)
}

//+-------------------------------------------------------------------------
//  Unregister OID information. Only the pszOID and dwGroupId fields are
//  used to identify the OID information to be unregistered.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;
    if (!CryptUnregisterOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            pszOIDGroupString
            ))
        goto UnregisterOIDFunctionError;
    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(UnregisterOIDFunctionError)
}

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID information.
//
//  Called within critical section
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegistryCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    DWORD cchOID;
    LPCWSTR pwszName = NULL;
    DWORD cchName = 0;
    LPCSTR pszGroupId;
    DWORD dwGroupId = 0;
    ALG_ID Algid = 0;
    CRYPT_DATA_BLOB ExtraInfo = {0, NULL};
    DWORD dwFlags = 0;
    DWORD cbExtra;
    BYTE *pbExtra;
    PGROUP_ENTRY pGroup;
    PCRYPT_OID_INFO pInfo;

    // The pszOID consists of OID!<dwGroupId>, for example, 1.2.3!1
    // Start at the end and search for the '!'
    cchOID = strlen(pszOID);
    pszGroupId = pszOID + cchOID;
    while (pszGroupId > pszOID && CONST_OID_GROUP_PREFIX_CHAR != *pszGroupId)
        pszGroupId--;

    if (CONST_OID_GROUP_PREFIX_CHAR == *pszGroupId) {
        cchOID = (DWORD)(pszGroupId - pszOID);
        dwGroupId = (DWORD) atol(pszGroupId + 1);
    } else
        // Name is missing "!". Skip It.
        return TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, OID_INFO_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                pwszName = (LPWSTR) pbValueData;
                cchName = wcslen(pwszName);
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_ALGID_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(Algid))
                memcpy(&Algid, pbValueData, sizeof(Algid));
        } else if (0 == _wcsicmp(pwszValueName,
                OID_INFO_EXTRA_INFO_VALUE_NAME)) {
            if (REG_BINARY == dwValueType) {
                ExtraInfo.cbData = cbValueData;
                ExtraInfo.pbData = (BYTE *) pbValueData;
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwFlags))
                memcpy(&dwFlags, pbValueData, sizeof(dwFlags));
        }
    }

    cbExtra = LEN_ALIGN(cchOID + 1) +
        LEN_ALIGN((cchName + 1) * sizeof(WCHAR)) +
        ExtraInfo.cbData;
    if (NULL == (pbExtra = (BYTE *) OIDInfoAlloc(cbExtra)))
        return FALSE;

    if (dwFlags & CRYPT_INSTALL_OID_INFO_BEFORE_FLAG)
        pGroup = &RegBeforeGroup;
    else
        pGroup = &RegAfterGroup;

    if (NULL == (pInfo = (PCRYPT_OID_INFO) OIDInfoRealloc(
            (PCRYPT_OID_INFO) pGroup->rgInfo,
            (pGroup->cInfo + 1) * sizeof(CRYPT_OID_INFO)))) {
        OIDInfoFree(pbExtra);
        return FALSE;
    }
    pGroup->rgInfo = pInfo;
    pInfo = &pInfo[pGroup->cInfo++];

    pInfo->cbSize = sizeof(CRYPT_OID_INFO);
    pInfo->pszOID = (LPCSTR) pbExtra;
    if (cchOID)
        memcpy(pbExtra, pszOID, cchOID);
    *( ((LPSTR) pbExtra) + cchOID) = '\0';
    pbExtra += LEN_ALIGN(cchOID + 1);

    pInfo->pwszName = (LPCWSTR) pbExtra;
    if (cchName)
        memcpy(pbExtra, pwszName, (cchName + 1) * sizeof(WCHAR));
    else
        *((LPWSTR) pbExtra) = L'\0';
    pbExtra += LEN_ALIGN((cchName + 1) * sizeof(WCHAR));

    pInfo->dwGroupId = dwGroupId;
    pInfo->Algid = Algid;
    pInfo->ExtraInfo.cbData = ExtraInfo.cbData;
    if (ExtraInfo.cbData > 0) {
        pInfo->ExtraInfo.pbData = pbExtra;
        memcpy(pbExtra, ExtraInfo.pbData, ExtraInfo.cbData);
    } else
        pInfo->ExtraInfo.pbData = NULL;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Allocate and load the string for the specified resource.
//
//  If LoadString or allocation fails, returns predefined pointer to an
//  empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndLoadOIDNameString(
    IN UINT uID
    )
{
    WCHAR wszResource[MAX_RESOURCE_OID_NAME_LENGTH + 1];
    int cchResource;
    int cbResource;
    LPWSTR pwszDst;

    cchResource = LoadStringU(hOIDInfoInst, uID, wszResource,
        MAX_RESOURCE_OID_NAME_LENGTH);
    assert(0 < cchResource);
    if (0 >= cchResource)
        return (LPWSTR) pwszNullName;

    cbResource = (cchResource + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbResource);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) wszResource, cbResource);
    return pwszDst;
}

//+-------------------------------------------------------------------------
//  Allocate and copy the string.
//
//  If allocation fails, returns predefined pointer to an empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndCopyOIDNameString(
    IN LPCWSTR pwszSrc
    )
{
    DWORD cbSrc;
    LPWSTR pwszDst;

    cbSrc = (wcslen(pwszSrc) + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbSrc);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cbSrc);
    return pwszDst;
}

//+-------------------------------------------------------------------------
//  Does a LoadString for pwszName's initialized with resource IDs in groups
//  with fLocalize set.
//--------------------------------------------------------------------------
static void LoadGroupResources()
{
    DWORD i;
    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;
            for ( ; cInfo > 0; cInfo--, pInfo++) {
                UINT_PTR uID;
                uID = (UINT_PTR) pInfo->pwszName;
                if (uID <= 0xFFFF)
                    pInfo->pwszName = AllocAndLoadOIDNameString((UINT)uID);
                else
                    // ProcessDetach expects all pwszName's to be allocated
                    pInfo->pwszName = AllocAndCopyOIDNameString(
                        pInfo->pwszName);
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Load OID Information from the registry. Updates the RegBeforeGroup and
//  RegAfterGroup.
//
//  Loads resource strings in groups enabling localization of pwszName's.
//--------------------------------------------------------------------------
static void LoadFromRegistryAndResources()
{
    if (fLoadedFromRegAndResources)
        return;

    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedFromRegAndResources) {
        CryptEnumOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegistryCallback
            );
        LoadGroupResources();
        fLoadedFromRegAndResources = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Compare the OID info according to the specified key and group.
//--------------------------------------------------------------------------
static BOOL CompareOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId,
    IN PCCRYPT_OID_INFO pInfo
    )
{
    if (dwGroupId && dwGroupId != pInfo->dwGroupId)
        return FALSE;

    switch (dwKeyType) {
        case CRYPT_OID_INFO_OID_KEY:
            if (0 == _stricmp((LPSTR) pvKey, pInfo->pszOID))
                return TRUE;
            break;
        case CRYPT_OID_INFO_NAME_KEY:
            if (0 == _wcsicmp((LPWSTR) pvKey, pInfo->pwszName))
                return TRUE;
            break;
        case CRYPT_OID_INFO_ALGID_KEY:
            if (*((ALG_ID *) pvKey) == pInfo->Algid)
                return TRUE;
            break;
        case CRYPT_OID_INFO_SIGN_KEY:
            {
                ALG_ID *paiKey = (ALG_ID *) pvKey;
                ALG_ID aiPubKey;

                if (sizeof(ALG_ID) <= pInfo->ExtraInfo.cbData)
                    aiPubKey = *((ALG_ID *) pInfo->ExtraInfo.pbData);
                else
                    aiPubKey = 0;

                if (paiKey[0] == pInfo->Algid &&
                        paiKey[1] == aiPubKey)
                return TRUE;
            }
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Search the group according to the specified dwKeyType.
//
//  Note, the groups updated from the registry, RegBeforeGroup and
//  RegAfterGroup, may contain any GROUP_ID.
//--------------------------------------------------------------------------
static PCCRYPT_OID_INFO SearchGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (CompareOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId,
                pInfo
                ))
            return pInfo;
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Find OID information. Returns NULL if unable to find any information
//  for the specified key and group.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
CryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    )
{
    PCCRYPT_OID_INFO pInfo;

    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegBeforeGroup
            ))) return pInfo;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                0,
                &GroupTable[i]
                )) return pInfo;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                dwGroupId,
                &GroupTable[dwGroupId]
                )) return pInfo;
    }

    if (RegAfterGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegAfterGroup
            ))) return pInfo;

    return SearchDsGroup(
            dwKeyType,
            pvKey,
            dwGroupId
            );
}


//+-------------------------------------------------------------------------
//  Enumerate the group.
//--------------------------------------------------------------------------
static BOOL EnumGroup(
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        if (!pfnEnumOIDInfo(pInfo, pvArg))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Enumerate the OID information.
//
//  pfnEnumOIDInfo is called for each OID information entry.
//
//  Setting dwGroupId to 0 matches all groups. Otherwise, only enumerates
//  entries in the specified group.
//
//  dwFlags currently isn't used and must be set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDInfo(
    IN DWORD dwGroupId,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegBeforeGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (!EnumGroup(
                    0,                  // dwGroupId
                    &GroupTable[i],
                    pvArg,
                    pfnEnumOIDInfo
                    )) return FALSE;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (!EnumGroup(
                dwGroupId,
                &GroupTable[dwGroupId],
                pvArg,
                pfnEnumOIDInfo
                )) return FALSE;
    }

    if (RegAfterGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegAfterGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;


    return EnumDsGroup(
            dwGroupId,
            pvArg,
            pfnEnumOIDInfo
            );
}



//+=========================================================================
//  Localized Name Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered localized name values.
//
//  Called within critical section
//
//  Note at ProcessDetach, the Info entry pwszLocalizedName strings are freed.
//  Therefore, for each Info entry, do a single allocation for both the
//  pwszLocalizedName and pwszCryptName. The pwszCryptName immediately
//  follows the pwszLocalizedName.
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegLocalizedNamesCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    BOOL fResult;
    DWORD cInfo = LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo;
    PLOCALIZED_NAME_INFO pInfo =
        LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo;

    assert(CRYPT_LOCALIZED_NAME_ENCODING_TYPE == dwEncodingType);
    assert(0 == _stricmp(CRYPT_OID_FIND_LOCALIZED_NAME_FUNC, pszFuncName));
    assert(0 == _stricmp(CRYPT_LOCALIZED_NAME_OID, pszOID));

    while (cValue--) {
        if (REG_SZ == rgdwValueType[cValue]) {
            LPCWSTR pwszLocalizedName = (LPCWSTR) rgpbValueData[cValue];
            DWORD cchLocalizedName;
            DWORD cbLocalizedName;
            LPCWSTR pwszCryptName = rgpwszValueName[cValue];
            DWORD cbCryptName;

            LPWSTR pwszBothNames;
            PLOCALIZED_NAME_INFO pNewInfo;

            // Check for empty name string
            cchLocalizedName = wcslen(pwszLocalizedName);
            if (0 == cchLocalizedName)
                continue;

            cbLocalizedName = (cchLocalizedName + 1) * sizeof(WCHAR);
            cbCryptName = (wcslen(pwszCryptName) + 1) * sizeof(WCHAR);

            if (NULL == (pwszBothNames = (LPWSTR) OIDInfoAlloc(
                    cbLocalizedName + cbCryptName)))
                goto OutOfMemory;

            if (NULL == (pNewInfo = (PLOCALIZED_NAME_INFO) OIDInfoRealloc(
                    pInfo, (cInfo + 1) * sizeof(LOCALIZED_NAME_INFO)))) {
                OIDInfoFree(pwszBothNames);
                goto OutOfMemory;
            }
            pInfo = pNewInfo;
            pInfo[cInfo].pwszLocalizedName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszLocalizedName, cbLocalizedName);
            pwszBothNames =
                (LPWSTR) ((BYTE *) pwszBothNames + cbLocalizedName);
            pInfo[cInfo].pwszCryptName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszCryptName, cbCryptName);
            cInfo++;
        }
    }
    fResult = TRUE;

CommonReturn:
    LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo = cInfo;
    LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo = pInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}

static void LoadPredefinedNameResources()
{
    for (DWORD i = 0; i < PREDEFINED_NAME_CNT; i++) {
        LPWSTR pwszLocalizedName;

        // Note, the following always returns a non-NULL string pointer.
        pwszLocalizedName = AllocAndLoadOIDNameString(
            PredefinedNameTable[i].uIDLocalizedName);
        if (L'\0' == *pwszLocalizedName)
            pwszLocalizedName = NULL;
        PredefinedNameTable[i].pwszLocalizedName = (LPCWSTR) pwszLocalizedName;
    }
}

static void LoadLocalizedNamesFromRegAndResources()
{
    if (fLoadedLocalizedNames)
        return;

    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedLocalizedNames) {
        CryptEnumOIDFunction(
            CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
            CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
            CRYPT_LOCALIZED_NAME_OID,
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegLocalizedNamesCallback
            );
        LoadPredefinedNameResources();
        fLoadedLocalizedNames = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Find the localized name for the specified name. For example, find the
//  localized name for the "Root" system store name. A case insensitive
//  string comparison is done.
//
//  Returns NULL if unable to find the the specified name.
//--------------------------------------------------------------------------
LPCWSTR
WINAPI
CryptFindLocalizedName(
    IN LPCWSTR pwszCryptName
    )
{
    if (NULL == pwszCryptName || L'\0' == *pwszCryptName)
        return NULL;

    LoadLocalizedNamesFromRegAndResources();

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;
        for ( ; cInfo > 0; cInfo--, pInfo++) {
            if (0 == _wcsicmp(pwszCryptName, pInfo->pwszCryptName))
                return pInfo->pwszLocalizedName;
        }
    }

    return NULL;
}


//+=========================================================================
//  DS Group Functions
//==========================================================================

// certcli.dll has the helper function for getting the LDAP URL to the
// OID info stored in the DS.

#define sz_CERTCLI_DLL              "certcli.dll"
#define sz_CAOIDGetLdapURL          "CAOIDGetLdapURL"
#define sz_CAOIDFreeLdapURL         "CAOIDFreeLdapURL"

typedef HRESULT (WINAPI *PFN_CA_OID_GET_LDAP_URL)(
    IN  DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR  *ppwszURL
    );

typedef HRESULT (WINAPI *PFN_CA_OID_FREE_LDAP_URL)(
    IN LPCWSTR pwszURL
    );


#if 1
//+-------------------------------------------------------------------------
//  Gets the LDAP URL for and then uses to retrieve the OID info stored
//  in the DS.
//
//  Returns NULL if unable to do a successful LDAP retrieval.
//
//  If the OID object doesn't exist in the directory, returns FALSE with
//  LastError == ERROR_FILE_NOT_FOUND.
//
//  Assumption: not in DsCriticalSection
//--------------------------------------------------------------------------
static PCRYPT_BLOB_ARRAY RetrieveDsGroupByLdapUrl()
{
    PCRYPT_BLOB_ARRAY pcba = NULL;
    HRESULT hr;
    LPWSTR pwszUrl = NULL;
    HMODULE hDll = NULL;
    PFN_CA_OID_GET_LDAP_URL pfnCAOIDGetLdapURL = NULL;
    PFN_CA_OID_FREE_LDAP_URL pfnCAOIDFreeLdapURL = NULL;

    if (!ChainIsConnected())
        goto NotConnected;

    if (NULL == (hDll = LoadLibraryA(sz_CERTCLI_DLL)))
        goto LoadCertCliDllError;

    if (NULL == (pfnCAOIDGetLdapURL =
            (PFN_CA_OID_GET_LDAP_URL) GetProcAddress(hDll,
                sz_CAOIDGetLdapURL)))
        goto CAOIDGetLdapURLProcAddressError;

    if (NULL == (pfnCAOIDFreeLdapURL =
            (PFN_CA_OID_FREE_LDAP_URL) GetProcAddress(hDll,
                sz_CAOIDFreeLdapURL)))
        goto CAOIDFreeLdapURLProcAddressError;

    hr = pfnCAOIDGetLdapURL(
            CERT_OID_TYPE_ALL,
            0,                      // dwFlags
            &pwszUrl
            );
    if (S_OK != hr)
        goto CAOIDGetLdapURLError;

    if (!ChainRetrieveObjectByUrlW (
            pwszUrl,
            NULL,                   // pszObjectOid,
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS     |
                CRYPT_WIRE_ONLY_RETRIEVAL       |
                CRYPT_DONT_CACHE_RESULT         |
                CRYPT_OFFLINE_CHECK_RETRIEVAL   |
                CRYPT_LDAP_SIGN_RETRIEVAL |
                CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE,
            DS_LDAP_TIMEOUT,
            (LPVOID*) &pcba,
            NULL,                   // hAsyncRetrieve,
            NULL,                   // pCredentials,
            NULL,                   // pvVerify,
            NULL                    // pAuxInfo
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr || CRYPT_E_NOT_FOUND == dwErr)
            goto NoDsOIDObject;
        else
            goto RetrieveObjectByUrlError;
    }

    assert(pcba);

CommonReturn:
    if (hDll) {
        DWORD dwErr = GetLastError();

        if (pfnCAOIDFreeLdapURL && pwszUrl)
            pfnCAOIDFreeLdapURL(pwszUrl);
        
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return pcba;
ErrorReturn:
    assert(NULL == pcba);
    goto CommonReturn;

SET_ERROR(LoadCertCliDllError, ERROR_FILE_NOT_FOUND)
SET_ERROR(CAOIDGetLdapURLProcAddressError, ERROR_FILE_NOT_FOUND)
SET_ERROR(CAOIDFreeLdapURLProcAddressError, ERROR_FILE_NOT_FOUND)
SET_ERROR_VAR(CAOIDGetLdapURLError, hr)
SET_ERROR(NotConnected, ERROR_NOT_CONNECTED)
SET_ERROR(NoDsOIDObject, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(RetrieveObjectByUrlError)
}

#else

// Hard coded URL and credentials for testing

static PCRYPT_BLOB_ARRAY RetrieveDsGroupByLdapUrl()
{
    PCRYPT_BLOB_ARRAY pcba = NULL;

    CRYPT_CREDENTIALS Credentials;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;

// This gets overwritten by logic in cryptnet.dll
//    char szUsername[] = "domain\\username";
    char szUsername[] = "jettdom\\administrator";

    PasswordCredentials.cbSize = sizeof( PasswordCredentials );
    PasswordCredentials.pszUsername = szUsername;
//    PasswordCredentials.pszPassword = "password";
    PasswordCredentials.pszPassword = "";

    Credentials.cbSize = sizeof( Credentials );
    Credentials.pszCredentialsOid = CREDENTIAL_OID_PASSWORD_CREDENTIALS_A;
    Credentials.pvCredentials = (LPVOID)&PasswordCredentials;

    if (!ChainIsConnected())
        goto NotConnected;


    if (!ChainRetrieveObjectByUrlW (
            L"ldap://jettdomdc/CN=OID,CN=Public Key Services,CN=Services,CN=Configuration,DC=jettdom,DC=nttest,DC=microsoft,DC=com?msPKI-OIDLocalizedName,displayName,msPKI-Cert-Template-OID,flags?one",
            NULL,                   // pszObjectOid,
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS     |
                CRYPT_WIRE_ONLY_RETRIEVAL       |
                CRYPT_DONT_CACHE_RESULT         |
                CRYPT_OFFLINE_CHECK_RETRIEVAL   |
                CRYPT_LDAP_SIGN_RETRIEVAL       |
                CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE,
            DS_LDAP_TIMEOUT,
            (LPVOID*) &pcba,
            NULL,                   // hAsyncRetrieve,
            &Credentials,
            NULL,                   // pvVerify,
            NULL                    // pAuxInfo
            )) {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
            goto NoDsOIDObject;
        else
            goto RetrieveObjectByUrlError;
    }

    assert(pcba);

CommonReturn:
    return pcba;
ErrorReturn:
    assert(NULL == pcba);
    goto CommonReturn;

SET_ERROR(NotConnected, ERROR_NOT_CONNECTED)
TRACE_ERROR(NoDsOIDObject)
TRACE_ERROR(RetrieveObjectByUrlError)
}

#endif


//+-------------------------------------------------------------------------
//  Frees the DS groups
//
//  Assumption: only called at ProcessDetach
//--------------------------------------------------------------------------
static void FreeDsGroups()
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;

    cInfo = DsGroup.cInfo;
    ppInfo = DsGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++)
        OIDInfoFree((PCRYPT_OID_INFO) *ppInfo);
    OIDInfoFree(DsGroup.rgpInfo);

    cInfo = DsDeletedGroup.cInfo;
    ppInfo = DsDeletedGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++)
        OIDInfoFree((PCRYPT_OID_INFO) *ppInfo);
    OIDInfoFree(DsDeletedGroup.rgpInfo);
}


//+-------------------------------------------------------------------------
//  Adds the OID info entries to the specified DS group
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL AddDsOIDInfo(
    IN PCCRYPT_OID_INFO *ppAddInfo,
    IN DWORD cAddInfo,
    IN OUT PDS_GROUP_ENTRY pGroup
    )
{
    PCCRYPT_OID_INFO *ppInfo;
    assert(cAddInfo && ppAddInfo && *ppAddInfo);

    if (NULL == (ppInfo = (PCCRYPT_OID_INFO *) OIDInfoRealloc(
            pGroup->rgpInfo,
            (pGroup->cInfo + cAddInfo) * sizeof(PCCRYPT_OID_INFO))))
        return FALSE;

    pGroup->rgpInfo = ppInfo;

    ppInfo = &ppInfo[pGroup->cInfo];
    pGroup->cInfo += cAddInfo;
    for ( ; 0 < cAddInfo; cAddInfo --, ppAddInfo++, ppInfo++)
        *ppInfo = *ppAddInfo;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Moves the OID info entries from one DS group to another DS group
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL MoveDsOIDInfo(
    IN DWORD dwInfoIndex,
    IN DWORD cMoveInfo,
    IN OUT PDS_GROUP_ENTRY pSrcGroup,
    IN OUT PDS_GROUP_ENTRY pDstGroup
    )
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;
    DWORD i, j;

    if (0 == cMoveInfo)
        return TRUE;

    assert(dwInfoIndex + cMoveInfo <= pSrcGroup->cInfo);

    if (!AddDsOIDInfo(
            &pSrcGroup->rgpInfo[dwInfoIndex],
            cMoveInfo,
            pDstGroup
            ))
        return FALSE;

    // Move all remaining infos down
    cInfo = pSrcGroup->cInfo;
    ppInfo = pSrcGroup->rgpInfo;
    for (i = dwInfoIndex, j = i + cMoveInfo; j < cInfo; i++, j++)
        ppInfo[i] = ppInfo[j];

    pSrcGroup->cInfo = cInfo - cMoveInfo;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Creates the OID info by converting the LDAP DS attribute octets.
//
//  If any of the cb's == 0 or not a valid converted group type, returns TRUE
//  with *ppInfo = NULL
//--------------------------------------------------------------------------
static BOOL CreateDsOIDInfo(
    IN BYTE *pbOID,
    IN DWORD cbOID,
    IN BYTE *pbName,
    IN DWORD cbName,
    IN BYTE *pbGroupId,
    IN DWORD cbGroupId,
    OUT PCCRYPT_OID_INFO *ppInfo
    )
{
    BOOL fResult;
    PCRYPT_OID_INFO pInfo = NULL;
    char szType[2];
    DWORD dwType;
    DWORD dwGroupId;

    int cchName;
    LPWSTR pwszName;
    LPSTR pszOID;
    DWORD cbExtra;

    *ppInfo = NULL;

    if (0 == cbOID || 0 == cbName || 1 != cbGroupId)
        return TRUE;

    // Convert the Type bytes to the GroupId and see if a valid DS OID group
    szType[0] = (char) *pbGroupId;
    szType[1] = '\0';
    dwType = 0;
    dwType = (DWORD) atol(szType);

    switch (dwType) {
        case CERT_OID_TYPE_TEMPLATE:
            dwGroupId = CRYPT_TEMPLATE_OID_GROUP_ID;
            break;
        case CERT_OID_TYPE_ISSUER_POLICY:
            dwGroupId = CRYPT_POLICY_OID_GROUP_ID;
            break;
        case CERT_OID_TYPE_APPLICATION_POLICY:
            dwGroupId = CRYPT_ENHKEY_USAGE_OID_GROUP_ID;
            break;
        default:
            return TRUE;
    }

    // The name is a UTF8 encoded string

    cchName = UTF8ToWideChar(
        (LPSTR) pbName,
        cbName,
        NULL,           // lpWideCharStr
        0               // cchWideChar
        );

    if (1 > cchName)
        return TRUE;

    cbExtra = (cchName + 1) * sizeof(WCHAR) + (cbOID + 1);

    pInfo = (PCRYPT_OID_INFO) OIDInfoAlloc(sizeof(CRYPT_OID_INFO) + cbExtra);
    if (NULL == pInfo)
        goto OutOfMemory;
    memset(pInfo, 0, sizeof(CRYPT_OID_INFO));

    pInfo->cbSize = sizeof(CRYPT_OID_INFO);
    pInfo->dwGroupId = dwGroupId;

    pwszName = (LPWSTR) &pInfo[1];
    pInfo->pwszName = (LPCWSTR) pwszName;
    cchName = UTF8ToWideChar(
        (LPSTR) pbName,
        cbName,
        pwszName,
        cchName
        );

    if (1 > cchName)
        goto UTF8ToWideCharError;

    pwszName[cchName] = L'\0';

    pszOID = (LPSTR) (pwszName + (cchName + 1));
    pInfo->pszOID = (LPCSTR) pszOID;
    memcpy(pszOID, pbOID, cbOID);
    pszOID[cbOID] = '\0';


    *ppInfo = (PCCRYPT_OID_INFO) pInfo;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(OutOfMemory)
SET_ERROR(UTF8ToWideCharError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Creates the OID info entry corresponding to the LDAP DS attribute octets.
//
//  If the OID info entry already exists in the DsDeletedGroup, then, the
//  OID info entry is moved from DsDeletedGroup to DsGroup. Otherwise, the
//  created OID entry is added to the DsGroup.
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL CreateAndAddDsOIDInfo(
    IN BYTE *pbOID,
    IN DWORD cbOID,
    IN BYTE *pbName,
    IN DWORD cbName,
    IN BYTE *pbGroupId,
    IN DWORD cbGroupId
    )
{
    BOOL fResult;
    PCCRYPT_OID_INFO pInfo = NULL;

    DWORD cDeletedInfo;
    PCCRYPT_OID_INFO *ppDeletedInfo;
    DWORD i;

    fResult = CreateDsOIDInfo(
        pbOID,
        cbOID,
        pbName,
        cbName,
        pbGroupId,
        cbGroupId,
        &pInfo
        );

    if (NULL == pInfo)
        // Either the create failed or not a valid DS OID group
        return fResult;

    // See if we have an entry in the DS deleted group

    cDeletedInfo = DsDeletedGroup.cInfo;
    ppDeletedInfo = DsDeletedGroup.rgpInfo;
    for (i = 0; i < cDeletedInfo; i++) {
        PCCRYPT_OID_INFO pDeletedInfo = ppDeletedInfo[i];

        if (pInfo->dwGroupId == pDeletedInfo->dwGroupId &&
                0 == strcmp(pInfo->pszOID, pDeletedInfo->pszOID) &&
                0 == wcscmp(pInfo->pwszName, pDeletedInfo->pwszName))
            break;
    }

    if (i < cDeletedInfo) {
        if (!MoveDsOIDInfo(
                i,
                1,          // cInfo
                &DsDeletedGroup,
                &DsGroup
                ))
            goto MoveDsOIDInfoError;
        OIDInfoFree((PCRYPT_OID_INFO) pInfo);
    } else {
        if (!AddDsOIDInfo(&pInfo, 1, &DsGroup))
            goto AddDsOIDInfoError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
    
ErrorReturn:
    OIDInfoFree((PCRYPT_OID_INFO) pInfo);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(MoveDsOIDInfoError)
TRACE_ERROR(AddDsOIDInfoError)
}

//+-------------------------------------------------------------------------
//  Allocates and converts UNICODE string to ASCII.
//--------------------------------------------------------------------------
static LPSTR AllocAndWszToSz(
    IN LPCWSTR pwsz
    )
{
    int cchMultiByte;
    LPSTR psz = NULL;

    cchMultiByte = WideCharToMultiByte(
        CP_ACP,
        0,                      // dwFlags
        pwsz,
        -1,
        NULL,                   // psz,
        0,                      // cchMultiByte
        NULL,                   // lpDefaultChar
        NULL                    // lpfUsedDefaultChar
        );

    if (1 < cchMultiByte) {
        psz = (LPSTR) OIDInfoAlloc(cchMultiByte);

        if (NULL != psz) {
            cchMultiByte = WideCharToMultiByte(
                CP_ACP,
                0,                      // dwFlags
                pwsz,
                -1,
                psz,
                cchMultiByte,
                NULL,                   // lpDefaultChar
                NULL                    // lpfUsedDefaultChar
                );
            if (1 > cchMultiByte) {
                OIDInfoFree(psz);
                psz = NULL;
            } 
        }
    }

    return psz;
}

//+-------------------------------------------------------------------------
//  Loads the DS group by doing an LDAP URL retrieval and
//  converting the DS attribute octets into the OID info entries.
//
//  Do the load on the first call. Do subsequent reloads after
//  DS_RETRIEVAL_DELTA_SECONDS has elapsed since a successful load.
//
//  Assumption: not in DsCriticalSection
//--------------------------------------------------------------------------
static void LoadDsGroup()
{
    FILETIME CurrentTime;
    LONG lCmp;

    PCRYPT_BLOB_ARRAY pcba = NULL;
    LPSTR pszOIDAttr = NULL;
    LPSTR pszNameAttr = NULL;
    LPSTR pszLocalizedNameAttr = NULL;
    LPSTR pszGroupAttr = NULL;

    LANGID SystemDefaultLangID = 0;

    LPCSTR pszPrevIndex;    // not allocated
    BYTE *pbOID;
    DWORD cbOID;
    BYTE *pbName;
    DWORD cbName;
    BYTE *pbLocalizedName;
    DWORD cbLocalizedName;
    BYTE *pbGroupId;
    DWORD cbGroupId;
    DWORD i;

    GetSystemTimeAsFileTime(&CurrentTime);
    EnterCriticalSection(&DsCriticalSection);
    lCmp = CompareFileTime(&DsNextUpdateTime, &CurrentTime);
    LeaveCriticalSection(&DsCriticalSection);

    if (0 < lCmp)
        // Current time is before the next update time
        return;

    if (NULL == (pcba = RetrieveDsGroupByLdapUrl()) &&
            ERROR_FILE_NOT_FOUND != GetLastError())
        return;

    EnterCriticalSection(&DsCriticalSection);

    // Move all the Ds group entries to the deleted list. As we iterate
    // through the retrieved LDAP entries, most if not all of the entries
    // in the deleted group will be moved back.
    if (!MoveDsOIDInfo(
            0,              // dwInfoIndex
            DsGroup.cInfo,
            &DsGroup,
            &DsDeletedGroup
            ))
        goto MoveDsGroupOIDInfoError;

    if (NULL == pcba)
        goto NoOIDObjectReturn;

    pszOIDAttr = AllocAndWszToSz(OID_PROP_OID);
    pszNameAttr = AllocAndWszToSz(OID_PROP_DISPLAY_NAME);
    pszLocalizedNameAttr = AllocAndWszToSz(OID_PROP_LOCALIZED_NAME);
    pszGroupAttr = AllocAndWszToSz(OID_PROP_TYPE);
    if (NULL == pszOIDAttr || NULL == pszNameAttr ||
            NULL == pszLocalizedNameAttr|| NULL == pszGroupAttr)
        goto OutOfMemory;

    pszPrevIndex = "";
    pbOID = NULL;
    cbOID = 0;
    pbName = NULL;
    cbName = 0;
    pbLocalizedName = NULL;
    cbLocalizedName = 0;
    pbGroupId = NULL;
    cbGroupId = 0;
    for (i = 0; i < pcba->cBlob; i++ ) {
        PBYTE pb = pcba->rgBlob[i].pbData;
        DWORD cb = pcba->rgBlob[i].cbData;

        DWORD cbPrefix;
        LPCSTR pszIndex;
        LPCSTR pszAttr;

        pszIndex = (LPCSTR) pb;
        cbPrefix = strlen(pszIndex) + 1;
        pb += cbPrefix;
        cb -= cbPrefix;

        pszAttr = (LPCSTR) pb;
        cbPrefix = strlen(pszAttr) + 1;
        pb += cbPrefix;
        cb -= cbPrefix;

        if (0 != strcmp(pszIndex, pszPrevIndex)) {
            if (!CreateAndAddDsOIDInfo(
                    pbOID,
                    cbOID,
                    cbLocalizedName ? pbLocalizedName : pbName,
                    cbLocalizedName ? cbLocalizedName : cbName,
                    pbGroupId,
                    cbGroupId
                    ))
                goto CreateAndAddDsOIDInfoError;
            pszPrevIndex = pszIndex;
            pbOID = NULL;
            cbOID = 0;
            pbName = NULL;
            cbName = 0;
            pbLocalizedName = NULL;
            cbLocalizedName = 0;
            pbGroupId = NULL;
            cbGroupId = 0;
        }

        if (0 == _stricmp(pszAttr, pszOIDAttr)) {
            pbOID = pb;
            cbOID = cb;
        } else if (0 == _stricmp(pszAttr, pszNameAttr)) {
            pbName = pb;
            cbName = cb;
        } else if (0 == _stricmp(pszAttr, pszLocalizedNameAttr)) {
            // The LocalizedName consists of:
            //      "%d,%s", LangID, pszUTF8Name (Name isn't NULL terminated)
            if (0 == cbLocalizedName) {
                LPCSTR pszLangID;

                // Search for the ',' delimiter and convert to a \0
                pszLangID = (LPCSTR) pb;
                for ( ; 0 < cb; pb++, cb--) {
                    if (',' == *pb) {
                        *pb = 0;
                        pb++;
                        cb--;
                        break;
                    }
                }

                if (0 < cb) {
                    LANGID LangID = 0;

                    LangID = (LANGID) strtoul(pszLangID, NULL, 10);
                    if (0 != LangID) {
                        if (0 == SystemDefaultLangID)
                            SystemDefaultLangID = GetSystemDefaultLangID();
                        if (LangID == SystemDefaultLangID) {
                            cbLocalizedName = cb;
                            pbLocalizedName = pb;
                        }
                    }
                }
            }
        } else if (0 == _stricmp(pszAttr, pszGroupAttr)) {
            pbGroupId = pb;
            cbGroupId = cb;
        }
    }

    if (!CreateAndAddDsOIDInfo(
            pbOID,
            cbOID,
            cbLocalizedName ? pbLocalizedName : pbName,
            cbLocalizedName ? cbLocalizedName : cbName,
            pbGroupId,
            cbGroupId
            ))
        goto CreateAndAddDsOIDInfoError;


NoOIDObjectReturn:
    I_CryptIncrementFileTimeBySeconds(
        &CurrentTime,
        DS_RETRIEVAL_DELTA_SECONDS,
        &DsNextUpdateTime
        );

CommonReturn:
    LeaveCriticalSection(&DsCriticalSection);

    OIDInfoFree(pszOIDAttr);
    OIDInfoFree(pszNameAttr);
    OIDInfoFree(pszLocalizedNameAttr);
    OIDInfoFree(pszGroupAttr);
    if (pcba)
        CryptMemFree(pcba);
    return;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(MoveDsGroupOIDInfoError)
TRACE_ERROR(CreateAndAddDsOIDInfoError)
}

//+-------------------------------------------------------------------------
//  The DS only contains the ENHKEY, POLICY and TEMPLATE OID groups.
//--------------------------------------------------------------------------
static inline BOOL IsDsGroup(
    IN DWORD dwGroupId
    )
{
    if (0 == dwGroupId                                      ||
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID == dwGroupId    ||
            CRYPT_POLICY_OID_GROUP_ID == dwGroupId          ||
            CRYPT_TEMPLATE_OID_GROUP_ID == dwGroupId
            )
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  The DS only contains OID and NAME strings
//--------------------------------------------------------------------------
static inline BOOL IsDsKeyType(
    IN DWORD dwKeyType
    )
{
    if (CRYPT_OID_INFO_OID_KEY == dwKeyType ||
            CRYPT_OID_INFO_NAME_KEY == dwKeyType
            )
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Search the DS group according to the specified dwKeyType.
//--------------------------------------------------------------------------
static PCCRYPT_OID_INFO SearchDsGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId
    )
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;
    PCCRYPT_OID_INFO pInfo = NULL;

    if (!IsDsGroup(dwGroupId) || !IsDsKeyType(dwKeyType))
        return NULL;

    LoadDsGroup();

    EnterCriticalSection(&DsCriticalSection);

    cInfo = DsGroup.cInfo;
    ppInfo = DsGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++) {
        pInfo = *ppInfo;
        if (CompareOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId,
                pInfo
                ))
            break;
    }

    if (0 == cInfo)
        pInfo = NULL;

    LeaveCriticalSection(&DsCriticalSection);

    return pInfo;
}

//+-------------------------------------------------------------------------
//  Enumerate the DS group.
//--------------------------------------------------------------------------
static BOOL EnumDsGroup(
    IN DWORD dwGroupId,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    BOOL fResult;
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo = NULL;
    DWORD i;

    if (!IsDsGroup(dwGroupId))
        return TRUE;

    LoadDsGroup();

    EnterCriticalSection(&DsCriticalSection);

    // Make a copy of DS group OID info pointers while within the
    // DS critical section

    cInfo = DsGroup.cInfo;
    if (0 != cInfo) {
        ppInfo = (PCCRYPT_OID_INFO *) OIDInfoAlloc(
            cInfo * sizeof(PCCRYPT_OID_INFO));

        if (ppInfo)
            memcpy(ppInfo, DsGroup.rgpInfo, cInfo * sizeof(PCCRYPT_OID_INFO));
        else
            cInfo = 0;
    }

    LeaveCriticalSection(&DsCriticalSection);


    for (i = 0; i < cInfo; i++) {
        PCCRYPT_OID_INFO pInfo = ppInfo[i];

        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        if (!pfnEnumOIDInfo(pInfo, pvArg))
            goto EnumOIDInfoError;
    }

    fResult = TRUE;

CommonReturn:
    OIDInfoFree(ppInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnumOIDInfoError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\oidfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidfunc.cpp
//
//  Contents:   Cryptographic Object ID (OID) Functions
//
//  Functions:  I_CryptOIDFuncDllMain
//              CryptInitOIDFunctionSet
//              CryptInstallOIDFunctionAddress
//
//              CryptSetOIDFunctionValue
//              CryptGetOIDFunctionValue
//              CryptRegisterOIDFunction
//              CryptUnregisterOIDFunction
//              CryptRegisterDefaultOIDFunction
//              CryptUnregisterDefaultOIDFunction
//              CryptEnumOIDFunction
//
//              CryptGetOIDFunctionAddress
//              CryptGetDefaultOIDDllList
//              CryptGetDefaultOIDFunctionAddress
//              CryptFreeOIDFunctionAddress
//
//  Comments:
//              For the CryptGetOIDFunctionAddress we search the installed
//              const and str lists without
//              entering the critical section. The adds which are within
//              the critical section update the list pointers in the proper
//              order to allow list searching without locking.
//
//              However, registry loads are done with OIDFunc
//              locked.
//
//              HOLDING OID LOCK WHILE DOING A LoadLibrary() or FreeLibrary()
//              MAY LEAD TO DEADLOCK !!!
//
//
//  History:    07-Nov-96    philh   created
//              09-Aug-98    philh   changed to NOT hold OID lock when calling
//                                   LoadLibrary() or FreeLibrary().
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_STR_PREFIX_CHAR   '#'

//+-------------------------------------------------------------------------
//  OID Element Type Definitions
//--------------------------------------------------------------------------
#define CONST_OID_TYPE          1
#define STR_OID_TYPE            2
#define DLL_OID_TYPE            3

//+-------------------------------------------------------------------------
//  Dll and Procedure Element Definitions
//--------------------------------------------------------------------------
typedef struct _DLL_ELEMENT DLL_ELEMENT, *PDLL_ELEMENT;
typedef struct _DLL_PROC_ELEMENT DLL_PROC_ELEMENT, *PDLL_PROC_ELEMENT;

struct _DLL_ELEMENT {
    DWORD                   dwOIDType;
    PDLL_ELEMENT            pNext;
    LPWSTR                  pwszDll;    // expanded
    HMODULE                 hDll;
    DWORD                   dwRefCnt;
    BOOL                    fLoaded;
    PDLL_PROC_ELEMENT       pProcHead;
    LPFNCANUNLOADNOW        pfnDllCanUnloadNow;

    // The following are used to defer the freeing of Dlls until after waiting
    // at least one FREE_DLL_TIMEOUT.
    DWORD                   dwFreeCnt;  // 0, 1 or 2.
    PDLL_ELEMENT            pFreeNext;
    PDLL_ELEMENT            pFreePrev;
};

struct _DLL_PROC_ELEMENT {
    PDLL_PROC_ELEMENT       pNext;
    PDLL_ELEMENT            pDll;
    LPSTR                   pszName;
    void                    *pvAddr;    // NULL'ed when Dll is unloaded
};

// Linked list of all the Dlls. All proc elements are on one of the Dll
// element's proc list.
static PDLL_ELEMENT pDllHead;

// Linked list of Dlls waiting to be freed.
static PDLL_ELEMENT pFreeDllHead;

// Count of elements in the above list
static DWORD dwFreeDllCnt;

// When nonzero, a FreeDll callback has been registered.
static LONG lFreeDll;
static HANDLE hFreeDllRegWaitFor;
static HMODULE hFreeDllLibModule;

// Crypt32.dll hInst
static HMODULE hOidInfoInst;

// 15 seconds
#define FREE_DLL_TIMEOUT    15000

//+-------------------------------------------------------------------------
//  Installed OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _CONST_OID_FUNC_ELEMENT
    CONST_OID_FUNC_ELEMENT, *PCONST_OID_FUNC_ELEMENT;
struct _CONST_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PCONST_OID_FUNC_ELEMENT pNext;
    DWORD_PTR               dwLowOID;
    DWORD_PTR               dwHighOID;
    HMODULE                 hDll;
    void                    **rgpvFuncAddr;
};

typedef struct _STR_OID_FUNC_ELEMENT
    STR_OID_FUNC_ELEMENT, *PSTR_OID_FUNC_ELEMENT;
struct _STR_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PSTR_OID_FUNC_ELEMENT   pNext;
    LPSTR                   pszOID;
    HMODULE                 hDll;
    void                    *pvFuncAddr;
};

//+-------------------------------------------------------------------------
//  Registry OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _REG_OID_FUNC_ELEMENT
    REG_OID_FUNC_ELEMENT, *PREG_OID_FUNC_ELEMENT;
struct _REG_OID_FUNC_ELEMENT {
    DWORD                   dwEncodingType;
    PREG_OID_FUNC_ELEMENT   pNext;
    union {
        DWORD_PTR               dwOID;
        LPSTR                   pszOID;
    };
    PDLL_PROC_ELEMENT       pDllProc;
};

//+-------------------------------------------------------------------------
//  Default registry DLL list Element Definitions
//--------------------------------------------------------------------------
typedef struct _DEFAULT_REG_ELEMENT
    DEFAULT_REG_ELEMENT, *PDEFAULT_REG_ELEMENT;
struct _DEFAULT_REG_ELEMENT {
    DWORD                   dwEncodingType;
    PDEFAULT_REG_ELEMENT    pNext;

    LPWSTR                  pwszDllList;
    DWORD                   cchDllList;

    DWORD                   cDll;
    LPWSTR                  *rgpwszDll;
    PDLL_PROC_ELEMENT       *rgpDllProc;
};

//+-------------------------------------------------------------------------
//  Function Set Definition
//--------------------------------------------------------------------------
typedef struct _FUNC_SET FUNC_SET, *PFUNC_SET;
struct _FUNC_SET {
    PFUNC_SET               pNext;
    LPSTR                   pszFuncName;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncHead;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncTail;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncHead;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncTail;

    // Following are updated with OIDFunc locked
    BOOL                    fRegLoaded;
    PREG_OID_FUNC_ELEMENT   pRegBeforeOIDFuncHead;
    PREG_OID_FUNC_ELEMENT   pRegAfterOIDFuncHead;
    PDEFAULT_REG_ELEMENT    pDefaultRegHead;
};

// Linked list of all the function sets
static PFUNC_SET pFuncSetHead;

// Used to protect the adding of function sets and elements to function sets.
// Protects the pDllHead list and registry loads.
static CRITICAL_SECTION OIDFuncCriticalSection;

//+-------------------------------------------------------------------------
//  OIDFunc lock and unlock functions
//--------------------------------------------------------------------------
static inline void LockOIDFunc()
{
    EnterCriticalSection(&OIDFuncCriticalSection);
}
static inline void UnlockOIDFunc()
{
    LeaveCriticalSection(&OIDFuncCriticalSection);
}


//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetEncodingType(
    IN DWORD dwEncodingType
    )
{
    return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
        (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
        (dwEncodingType & CMSG_ENCODING_TYPE_MASK) >> 16;
}

//+-------------------------------------------------------------------------
//  Duplicate the Dll library's handle
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
static HMODULE DuplicateLibrary(
    IN HMODULE hDll
    )
{
    if (hDll) {
        WCHAR wszModule[_MAX_PATH];
        if (0 == GetModuleFileNameU(hDll, wszModule, _MAX_PATH))
            goto GetModuleFileNameError;
        if (NULL == (hDll = LoadLibraryExU(wszModule, NULL, 0)))
            goto LoadLibraryError;
    }

CommonReturn:
    return hDll;
ErrorReturn:
    hDll = NULL;
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(LoadLibraryError)
}


//+-------------------------------------------------------------------------
//  Add one or more functions with a constant OID. The constant OIDs are
//  monotonically increasing.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddConstOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[]
    )
{
    PCONST_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    void **ppvFuncAddr;

    cbEle = sizeof(CONST_OID_FUNC_ELEMENT) + cFuncEntry * sizeof(void *);
    if (NULL == (pEle = (PCONST_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = CONST_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    pEle->dwLowOID = (DWORD_PTR) rgFuncEntry[0].pszOID;
    pEle->dwHighOID = pEle->dwLowOID + cFuncEntry - 1;
    pEle->hDll = DuplicateLibrary(hDll);
    ppvFuncAddr =
        (void **) (((BYTE *) pEle) + sizeof(CONST_OID_FUNC_ELEMENT));
    pEle->rgpvFuncAddr = ppvFuncAddr;

    for (DWORD i = 0; i < cFuncEntry; i++, ppvFuncAddr++)
        *ppvFuncAddr = rgFuncEntry[i].pvFuncAddr;

    if (pFuncSet->pConstOIDFuncTail)
        pFuncSet->pConstOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pConstOIDFuncHead = pEle;
    pFuncSet->pConstOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Add single function with a string OID.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddStrOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN const CRYPT_OID_FUNC_ENTRY *pFuncEntry
    )
{
    PSTR_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    DWORD cchOID;
    LPSTR psz;

    cchOID = strlen(pFuncEntry->pszOID) + 1;
    cbEle = sizeof(STR_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pEle = (PSTR_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = STR_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    psz = (LPSTR) (((BYTE *) pEle) + sizeof(STR_OID_FUNC_ELEMENT));
    pEle->pszOID = psz;
    memcpy(psz, pFuncEntry->pszOID, cchOID);
    pEle->hDll = DuplicateLibrary(hDll);
    pEle->pvFuncAddr = pFuncEntry->pvFuncAddr;

    if (pFuncSet->pStrOIDFuncTail)
        pFuncSet->pStrOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pStrOIDFuncHead = pEle;
    pFuncSet->pStrOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the constant or string function elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSetConstAndStrElements(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PCONST_OID_FUNC_ELEMENT pConstEle;
    PSTR_OID_FUNC_ELEMENT pStrEle;

    pConstEle = pFuncSet->pConstOIDFuncHead;
    while (pConstEle) {
        PCONST_OID_FUNC_ELEMENT pNextEle = pConstEle->pNext;
        if (pConstEle->hDll)
            FreeLibrary(pConstEle->hDll);
        PkiFree(pConstEle);
        pConstEle = pNextEle;
    }

    pStrEle = pFuncSet->pStrOIDFuncHead;
    while (pStrEle) {
        PSTR_OID_FUNC_ELEMENT pNextEle = pStrEle->pNext;
        if (pStrEle->hDll)
            FreeLibrary(pStrEle->hDll);
        PkiFree(pStrEle);
        pStrEle = pNextEle;
    }
}

//+-------------------------------------------------------------------------
//  Free the function set and its elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSet(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PREG_OID_FUNC_ELEMENT pRegEle;
    PDEFAULT_REG_ELEMENT  pDefaultReg;

    FreeFuncSetConstAndStrElements(pFuncSet);

    pRegEle = pFuncSet->pRegBeforeOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pRegEle = pFuncSet->pRegAfterOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pDefaultReg = pFuncSet->pDefaultRegHead;
    while (pDefaultReg) {
        PDEFAULT_REG_ELEMENT pNext = pDefaultReg->pNext;
        PkiFree(pDefaultReg);
        pDefaultReg = pNext;
    }

    PkiFree(pFuncSet);
}

//+-------------------------------------------------------------------------
//  Free the Dll and its proc elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeDll(
    IN OUT PDLL_ELEMENT pDll
    )
{
    PDLL_PROC_ELEMENT pProcEle;

    pProcEle = pDll->pProcHead;
    while (pProcEle) {
        PDLL_PROC_ELEMENT pNextEle = pProcEle->pNext;
        PkiFree(pProcEle);
        pProcEle = pNextEle;
    }

    if (pDll->fLoaded) {
        assert(pDll->hDll);
        FreeLibrary(pDll->hDll);
    }

    PkiFree(pDll);
}


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDFuncDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = Pki_InitializeCriticalSection(&OIDFuncCriticalSection);
        hOidInfoInst = hInst;
        break;

    case DLL_PROCESS_DETACH:
        // Do interlock to guard against a potential race condition with
        // the RegWaitFor callback thread. We doing this without doing
        // a LockOIDFunc().
        if (InterlockedExchange(&lFreeDll, 0)) {
            assert(hFreeDllRegWaitFor);
            hFreeDllLibModule = NULL;
            ILS_UnregisterWait(hFreeDllRegWaitFor);
            hFreeDllRegWaitFor = NULL;
        }

        while (pFuncSetHead) {
            PFUNC_SET pFuncSet = pFuncSetHead;
            pFuncSetHead = pFuncSet->pNext;
            FreeFuncSet(pFuncSet);
        }

        while (pDllHead) {
            PDLL_ELEMENT pDll = pDllHead;
            pDllHead = pDll->pNext;
            FreeDll(pDll);
        }
        DeleteCriticalSection(&OIDFuncCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//  Initialize and return handle to the OID function set identified by its
//  function name.
//
//  If the set already exists, a handle to the existing set is returned.
//--------------------------------------------------------------------------
HCRYPTOIDFUNCSET
WINAPI
CryptInitOIDFunctionSet(
    IN LPCSTR pszFuncName,
    IN DWORD dwFlags
    )
{
    PFUNC_SET pFuncSet;

    LockOIDFunc();

    // See if the set already exists
    for (pFuncSet = pFuncSetHead; pFuncSet; pFuncSet = pFuncSet->pNext) {
        if (0 == strcmp(pszFuncName, pFuncSet->pszFuncName))
            break;
    }
    if (NULL == pFuncSet) {
        // Allocate and initialize a new set
        DWORD cchFuncName = strlen(pszFuncName) + 1;
        if (pFuncSet = (PFUNC_SET) PkiZeroAlloc(
                sizeof(FUNC_SET) + cchFuncName)) {
            LPSTR psz = (LPSTR) (((BYTE *) pFuncSet) + sizeof(FUNC_SET));
            pFuncSet->pszFuncName = psz;
            memcpy(psz, pszFuncName, cchFuncName);

            pFuncSet->pNext = pFuncSetHead;
            pFuncSetHead = pFuncSet;
        }
    }

    UnlockOIDFunc();

    return (HCRYPTOIDFUNCSET) pFuncSet;
}

//+-------------------------------------------------------------------------
//  Install a set of callable OID function addresses.
//
//  By default the functions are installed at end of the list.
//  Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list.
//
//  hModule should be updated with the hModule passed to DllMain to prevent
//  the Dll containing the function addresses from being unloaded by
//  CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the
//  case when the Dll has also regsvr32'ed OID functions via
//  CryptRegisterOIDFunction.
//
//  DEFAULT functions are installed by setting rgFuncEntry[].pszOID =
//  CRYPT_DEFAULT_OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallOIDFunctionAddress(
    IN HMODULE hModule,         // hModule passed to DllMain
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet;
    FUNC_SET AddFuncSet;
    memset(&AddFuncSet, 0, sizeof(AddFuncSet));
    int ConstFirst = -1;
    int ConstLast = 0;
    DWORD_PTR dwOID;
    DWORD_PTR dwLastOID = 0;
    DWORD i;

    dwEncodingType = GetEncodingType(dwEncodingType);
    if (NULL == (pFuncSet = (PFUNC_SET) CryptInitOIDFunctionSet(
            pszFuncName, 0)))
        return FALSE;


    // Don't need to hold lock while updating local copy of AddFuncSet.

    for (i = 0; i < cFuncEntry; i++) {
        if (0xFFFF >= (dwOID = (DWORD_PTR) rgFuncEntry[i].pszOID)) {
            if (ConstFirst < 0)
                ConstFirst = i;
            else if (dwOID != dwLastOID + 1) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = i;
            }
            ConstLast = i;
            dwLastOID = dwOID;
        } else {
            if (ConstFirst >= 0) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = -1;
            }

            if (!AddStrOIDFunc(
                    hModule,
                    dwEncodingType,
                    &AddFuncSet,
                    &rgFuncEntry[i]
                    )) goto AddStrOIDFuncError;
        }
    }
    if (ConstFirst >= 0) {
        if (!AddConstOIDFunc(
                hModule,
                dwEncodingType,
                &AddFuncSet,
                ConstLast - ConstFirst + 1,
                &rgFuncEntry[ConstFirst]
                )) goto AddConstOIDFuncError;
    }

    // NOTE:::
    //
    //  Since the get function accesses the lists without entering the critical
    //  section, the following pointers must be updated in the correct
    //  order.  Note, Get doesn't access the tail.

    LockOIDFunc();

    if (AddFuncSet.pConstOIDFuncHead) {
        if (NULL == pFuncSet->pConstOIDFuncHead) {
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pConstOIDFuncTail->pNext = pFuncSet->pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
        } else {
            pFuncSet->pConstOIDFuncTail->pNext = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        }
    }

    if (AddFuncSet.pStrOIDFuncHead) {
        if (NULL == pFuncSet->pStrOIDFuncHead) {
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pStrOIDFuncTail->pNext = pFuncSet->pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
        } else {
            pFuncSet->pStrOIDFuncTail->pNext = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        }
    }

    UnlockOIDFunc();
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    FreeFuncSetConstAndStrElements(&AddFuncSet);
    goto CommonReturn;
TRACE_ERROR(AddConstOIDFuncError)
TRACE_ERROR(AddStrOIDFuncError)
}

STATIC LPSTR EncodingTypeToRegName(
    IN DWORD dwEncodingType
    )
{
    LPSTR pszRegName;
    DWORD cchRegName;
    char szEncodingTypeValue[33];

    dwEncodingType = GetEncodingType(dwEncodingType);
    _ltoa(dwEncodingType, szEncodingTypeValue, 10);
    cchRegName = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX) +
        strlen(szEncodingTypeValue) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
        strcat(pszRegName, szEncodingTypeValue);
    }

    return pszRegName;
}

// Returns FALSE for an invalid EncodingType reg name
STATIC BOOL RegNameToEncodingType(
    IN LPCSTR pszRegEncodingType,
    OUT DWORD *pdwEncodingType
    )
{
    BOOL fResult = FALSE;
    DWORD dwEncodingType = 0;
    const DWORD cchPrefix = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
    if (pszRegEncodingType && (DWORD) strlen(pszRegEncodingType) >= cchPrefix &&
            2 == CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                pszRegEncodingType, cchPrefix,
                CRYPT_OID_REG_ENCODING_TYPE_PREFIX, cchPrefix)) {
        long lEncodingType;
        lEncodingType = atol(pszRegEncodingType + cchPrefix);
        if (lEncodingType >= 0 && lEncodingType <= 0xFFFF) {
            dwEncodingType = (DWORD) lEncodingType;
            fResult = TRUE;
        }
    }
    *pdwEncodingType = dwEncodingType;
    return fResult;
}

STATIC LPSTR FormatOIDFuncRegName(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{

    LPSTR pszRegEncodingType;
    LPSTR pszRegName;
    DWORD cchRegName;
    char szOID[34];

    if (pszOID == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    if (NULL == (pszRegEncodingType = EncodingTypeToRegName(dwEncodingType)))
        return NULL;

    if ((DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    cchRegName = strlen(CRYPT_OID_REGPATH "\\") +
        strlen(pszRegEncodingType) + 1 +
        strlen(pszFuncName) + 1 +
        strlen(pszOID) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REGPATH "\\");
        strcat(pszRegName, pszRegEncodingType);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszFuncName);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszOID);
    }

    PkiFree(pszRegEncodingType);
    return pszRegName;
}

//+-------------------------------------------------------------------------
//  Set the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegSetValueEx for the possible value types.
//
//  String types are UNICODE.
//
//  If pbValueData == NULL and cbValueData == 0, deletes the value.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition)))
        goto RegCreateKeyError;

    if (NULL == pbValueData && 0 == cbValueData) {
        if (ERROR_SUCCESS != (lStatus = RegDeleteValueU(
                hKey,
                pwszValueName)))
            goto RegDeleteValueError;
    } else {
        if (ERROR_SUCCESS != (lStatus = RegSetValueExU(
                hKey,
                pwszValueName,
                0,          // dwReserved
                dwValueType,
                pbValueData,
                cbValueData)))
            goto RegSetValueError;
    }

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegCreateKeyError, lStatus)
SET_ERROR_VAR(RegDeleteValueError, lStatus)
SET_ERROR_VAR(RegSetValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Get the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegEnumValue for the possible value types.
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValueType,
    OUT BYTE *pbValueData,
    IN OUT DWORD *pcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_READ,
            &hKey))) {
        if (ERROR_FILE_NOT_FOUND == lStatus) {
            // Inhibit error tracing
            SetLastError((DWORD) lStatus);
            goto ErrorReturn;
        }
        goto RegOpenKeyError;
    }

    if (ERROR_SUCCESS != (lStatus = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // lpdwReserved
            pdwValueType,
            pbValueData,
            pcbValueData))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    *pdwValueType = 0;
    *pcbValueData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegQueryValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Register the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
//  In addition to registering the DLL, you may override the
//  name of the function to be called. For example,
//      pszFuncName = "CryptDllEncodeObject",
//      pszOverrideFuncName = "MyEncodeXyz".
//  This allows a Dll to export multiple OID functions for the same
//  function name without needing to interpose its own OID dispatcher function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN OPTIONAL LPCWSTR pwszDll,
    IN OPTIONAL LPCSTR pszOverrideFuncName
    )
{
    BOOL fResult;
    LPWSTR pwszOverrideFuncName = NULL;

    if (pwszDll) {
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_DLL_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszDll,
                (wcslen(pwszDll) + 1) * sizeof(WCHAR)))
            goto SetDllError;
    }

    if (pszOverrideFuncName) {
        if (NULL == (pwszOverrideFuncName = MkWStr(
                (LPSTR) pszOverrideFuncName)))
            goto MkWStrError;
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszOverrideFuncName,
                (wcslen(pwszOverrideFuncName) + 1) * sizeof(WCHAR)))
            goto SetFuncNameError;
    }

    fResult = TRUE;
CommonReturn:
    if (pwszOverrideFuncName)
        FreeWStr(pwszOverrideFuncName);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetDllError)
TRACE_ERROR(SetFuncNameError)
TRACE_ERROR(MkWStrError)
}

//+-------------------------------------------------------------------------
//  Unregister the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    LPSTR pszRegOID;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    // Separate off the OID component of the RegName. Its the
    // last component of the name.
    pszRegOID = pszRegName + strlen(pszRegName);
    while (*pszRegOID != '\\')
        pszRegOID--;
    *pszRegOID++ = '\0';

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_WRITE,
            &hKey))) goto RegOpenKeyError;

    if (ERROR_SUCCESS != (lStatus = RegDeleteKeyA(
            hKey,
            pszRegOID)))
        goto RegDeleteKeyError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegDeleteKeyError, lStatus)
}

STATIC BOOL GetDefaultDllList(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    OUT LPWSTR pwszList,
    IN OUT DWORD *pcchList
    )
{
    BOOL fResult;
    DWORD dwType;
    DWORD cchList;
    DWORD cbList;

    cchList = *pcchList;
    if (pwszList) {
        if (cchList < 3)
            goto InvalidArg;
        else
            // make room for two extra null terminators
            cchList -= 2;
    } else
        cchList = 0;

    cbList = cchList * sizeof(WCHAR);
    fResult = CryptGetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            &dwType,
            (BYTE *) pwszList,
            &cbList);
    cchList = cbList / sizeof(WCHAR);
    if (!fResult) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            if (cchList)
                cchList += 2;
            goto GetOIDFunctionValueError;
        }
        cchList = 0;
    } else if (!(REG_MULTI_SZ == dwType ||
            REG_SZ == dwType || REG_EXPAND_SZ == dwType))
        goto BadDefaultListRegType;

    if (pwszList) {
        // Ensure the list has two null terminators
        pwszList[cchList++] = L'\0';
        pwszList[cchList++] = L'\0';
    } else {
        if (cchList == 0)
            cchList = 3;
        else
            cchList += 2;
    }
    fResult = TRUE;
CommonReturn:
    *pcchList = cchList;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOIDFunctionValueError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(BadDefaultListRegType, E_INVALIDARG)
}

// Remove any entries following the first empty string.
STATIC DWORD AdjustDefaultListLength(
    IN LPCWSTR pwszList
    )
{
    LPCWSTR pwsz = pwszList;
    DWORD cch;
    while (cch = wcslen(pwsz))
        pwsz += cch + 1;

    return (DWORD)(pwsz - pwszList) + 1;
}

//+-------------------------------------------------------------------------
//  Register the Dll containing the default function to be called for the
//  specified encoding type and function name.
//
//  Unlike CryptRegisterOIDFunction, you can't override the function name
//  needing to be exported by the Dll.
//
//  The Dll is inserted before the entry specified by dwIndex.
//    dwIndex == 0, inserts at the beginning.
//    dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD dwIndex,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwsz, pwszInsert, pwszSrc, pwszDest;
    DWORD cch, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca((cchDllList + cchDll) * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Check if the Dll already exists in the list
    pwsz = pwszDllList;
    while (cch = wcslen(pwsz)) {
        if (0 == _wcsicmp(pwsz, pwszDll))
            goto DllExistsError;
        pwsz += cch + 1;
    }

    // Find the Null terminated DLL in the DllList to insert before.
    // We insert before the dwIndex.
    pwszInsert = pwszDllList;
    while (dwIndex-- && 0 != (cch = wcslen(pwszInsert)))
        pwszInsert += cch + 1;

    // Before inserting, we need to move all the remaining entries in the
    // existing DllList.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    assert(pwszInsert < pwszDllList + cchDllList);
    if (pwszInsert >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszInsert);
    assert(cchRemain);
    pwszSrc = pwszDllList + cchDllList - 1;
    pwszDest = pwszSrc + cchDll;
    while (cchRemain--)
        *pwszDest-- = *pwszSrc--;
    assert(pwszSrc + 1 == pwszInsert);

    // Insert the pwszDll
    memcpy(pwszInsert, pwszDll, cchDll * sizeof(WCHAR));

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList + cchDll) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(DllExistsError, ERROR_FILE_EXISTS)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

BOOL
WINAPI
CryptUnregisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwszDelete, pwszMove;
    DWORD cchDelete, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Search the DllList for a match
    pwszDelete = pwszDllList;
    while (cchDelete = wcslen(pwszDelete)) {
        if (0 == _wcsicmp(pwszDll, pwszDelete))
            break;
        pwszDelete += cchDelete + 1;
    }

    if (0 == cchDelete) goto DllNotFound;
    cchDelete++;
    assert(cchDelete == cchDll);

    // Move all the Dll entries that follow.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    pwszMove = pwszDelete + cchDelete;
    assert(pwszMove < pwszDllList + cchDllList);
    if (pwszMove >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszMove);
    assert(cchRemain);
    while (cchRemain--)
        *pwszDelete++ = *pwszMove++;

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList - cchDelete) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(DllNotFound, ERROR_FILE_NOT_FOUND)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

#define MAX_SUBKEY_LEN      128

STATIC HKEY GetNextRegSubKey(
    IN HKEY hKey,
    IN OUT DWORD *piSubKey,
    IN LPCSTR pszFuncNameMatch,
    OUT char szSubKeyName[MAX_SUBKEY_LEN]
    )
{
    HKEY hSubKey;

    if (pszFuncNameMatch && *pszFuncNameMatch) {
        if ((*piSubKey)++ > 0 || strlen(pszFuncNameMatch) >= MAX_SUBKEY_LEN)
            return NULL;
        strcpy(szSubKeyName, pszFuncNameMatch);
    } else {
        if (ERROR_SUCCESS != RegEnumKeyA(
                hKey,
                (*piSubKey)++,
                szSubKeyName,
                MAX_SUBKEY_LEN))
            return NULL;
    }

    if (ERROR_SUCCESS == RegOpenKeyExA(
            hKey,
            szSubKeyName,
            0,                  // dwReserved
            KEY_READ,
            &hSubKey))
        return hSubKey;
    else
        return NULL;
}

STATIC BOOL GetRegValues(
    IN HKEY hKey,
    OUT void **ppvAlloc,
    OUT DWORD *pcValue,
    OUT DWORD **ppdwValueType,
    OUT LPWSTR **pppwszValueName,
    OUT BYTE ***pppbValueData,
    OUT DWORD **ppcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;

    void *pvAlloc = NULL;

    DWORD cValue;
    DWORD iValue;
    DWORD cchMaxName;
    DWORD cbMaxData;
    DWORD cbAlignData = 0;

    DWORD *pdwValueType;
    LPWSTR *ppwszValueName;
    BYTE **ppbValueData;
    DWORD *pcbValueData;

    LPWSTR pwszName;
    BYTE *pbData;

    if (ERROR_SUCCESS != (lStatus = RegQueryInfoKeyU(
            hKey,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValue,
            &cchMaxName,
            &cbMaxData,
            NULL,
            NULL
            ))) goto RegQueryInfoKeyError;

    // Do a single allocation for all the arrays, value names and
    // value data. Update the array pointers.
    if (cValue > 0) {
        BYTE *pbAlloc;
        DWORD cbAlloc;

        // Include NULL terminator for the name and align the data length
        // Also, include two NULL terminators to be added for the data.
        // Ensures REG_MULTI_SZ is always NULL terminated.
        cchMaxName++;
        if (4 > cbMaxData)
            cbMaxData = 4;
        cbAlignData = LEN_ALIGN(cbMaxData + 2 * sizeof(WCHAR));

        cbAlloc = (sizeof(DWORD) + sizeof(LPWSTR) + sizeof(BYTE *) +
             sizeof(DWORD) + cchMaxName * sizeof(WCHAR) + cbAlignData) * cValue;
        if (NULL == (pvAlloc = PkiNonzeroAlloc(cbAlloc)))
            goto OutOfMemory;

        pbAlloc = (BYTE *) pvAlloc;

        ppwszValueName = (LPWSTR *) pbAlloc;
        pbAlloc += sizeof(LPWSTR) * cValue;
        ppbValueData = (BYTE **) pbAlloc;
        pbAlloc += sizeof(BYTE *) * cValue;
        pdwValueType = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;
        pcbValueData = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;

        pbData = pbAlloc;
        pbAlloc += cbAlignData * cValue;
        pwszName = (LPWSTR) pbAlloc;
        assert(((BYTE *) pvAlloc) + cbAlloc ==
            pbAlloc + (cchMaxName * sizeof(WCHAR)) * cValue);
    } else {
        ppwszValueName = NULL;
        ppbValueData = NULL;
        pdwValueType = NULL;
        pcbValueData = NULL;
        pbData = NULL;
        pwszName = NULL;
    }

    for (iValue = 0; iValue < cValue;
                iValue++, pwszName += cchMaxName, pbData += cbAlignData) {
        DWORD cchName = cchMaxName;
        DWORD cbData = cbMaxData;
        DWORD dwType;

        if (ERROR_SUCCESS != (lStatus = RegEnumValueU(
                hKey,
                iValue,
                pwszName,
                &cchName,
                NULL,       // pdwReserved
                &dwType,
                pbData,
                &cbData
                )))
            goto RegEnumValueError;

        // Ensure the data has two NULL terminators for REG_MULTI_SZ
        // Note cbAlignData >= cbMaxData + 2 * sizeof(WCHAR)
        memset(pbData + cbData, 0, 2 * sizeof(WCHAR));

        pdwValueType[iValue] = dwType;
        ppwszValueName[iValue] = pwszName;
        ppbValueData[iValue] = pbData;
        pcbValueData[iValue] = cbData;
    }

    fResult = TRUE;
CommonReturn:
    *ppvAlloc = pvAlloc;
    *pcValue = cValue;
    *ppdwValueType = pdwValueType;
    *pppwszValueName = ppwszValueName;
    *pppbValueData = ppbValueData;
    *ppcbValueData = pcbValueData;
    return fResult;

ErrorReturn:
    if (pvAlloc) {
        PkiFree(pvAlloc);
        pvAlloc = NULL;
    }

    cValue = 0;
    pdwValueType = NULL;
    ppwszValueName = NULL;
    ppbValueData = NULL;
    pcbValueData = NULL;

    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegQueryInfoKeyError, lStatus)
SET_ERROR_VAR(RegEnumValueError, lStatus)
}

//+-------------------------------------------------------------------------
//  Enumerate the OID functions identified by their encoding type,
//  function name and OID.
//
//  pfnEnumOIDFunc is called for each registry key matching the input
//  parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches
//  any. Setting pszFuncName or pszOID to NULL matches any.
//
//  Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the
//  DEFAULT functions
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc
    )
{
    HKEY hRegKey;
    LPSTR pszEncodingType = NULL;
    char szOID[34];

    if (CRYPT_MATCH_ANY_ENCODING_TYPE != dwEncodingType) {
        dwEncodingType = GetEncodingType(dwEncodingType);
        if (NULL == (pszEncodingType = EncodingTypeToRegName(dwEncodingType)))
            return FALSE;
    }

    if (pszOID && (DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((DWORD) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            CRYPT_OID_REGPATH,
            0,                  // dwReserved
            KEY_READ,
            &hRegKey)) {
        // Enumerate and optionally match encoding type
        HKEY hEncodingTypeKey;
        DWORD iEncodingType = 0;
        char szRegEncodingType[MAX_SUBKEY_LEN];
        while (hEncodingTypeKey = GetNextRegSubKey(hRegKey,
                &iEncodingType, pszEncodingType, szRegEncodingType)) {
            // Convert the EncodingType string and validate
            DWORD dwRegEncodingType;
            if (RegNameToEncodingType(szRegEncodingType, &dwRegEncodingType)) {
                // Enumerate and optionally match FuncName, for example,
                // ("CryptDllEncodeObject")
                HKEY hFuncName;
                DWORD iFuncName = 0;
                char szRegFuncName[MAX_SUBKEY_LEN];
                while (hFuncName = GetNextRegSubKey(hEncodingTypeKey,
                        &iFuncName, pszFuncName, szRegFuncName)) {
                    // Enumerate and optionally match OID string ("1.2.3.4")
                    HKEY hOID;
                    DWORD iOID = 0;
                    char szRegOID[MAX_SUBKEY_LEN];
                    while (hOID = GetNextRegSubKey(hFuncName, &iOID, pszOID,
                            szRegOID)) {
                        // Read and allocate  the registry values
                        void *pvAlloc;
                        DWORD cValue;
                        DWORD *pdwValueType;
                        LPWSTR *ppwszValueName;
                        BYTE **ppbValueData;
                        DWORD *pcbValueData;

                        if (GetRegValues(
                                hOID,
                                &pvAlloc,
                                &cValue,
                                &pdwValueType,
                                &ppwszValueName,
                                &ppbValueData,
                                &pcbValueData)) {
                            pfnEnumOIDFunc(
                                dwRegEncodingType,
                                szRegFuncName,
                                szRegOID,
                                cValue,
                                pdwValueType,
                                (LPCWSTR *) ppwszValueName,
                                (const BYTE **) ppbValueData,
                                pcbValueData,
                                pvArg);
                            if (pvAlloc)
                                PkiFree(pvAlloc);
                        }
                        RegCloseKey(hOID);
                    }
                    RegCloseKey(hFuncName);
                }
            }
            RegCloseKey(hEncodingTypeKey);
        }
        RegCloseKey(hRegKey);
    }

    if (pszEncodingType)
        PkiFree(pszEncodingType);
    return TRUE;
}


//+=========================================================================
//  Registry and Dll Load Functions
//==========================================================================

// Note, returned Dll element isn't AddRef'ed
STATIC PDLL_ELEMENT FindDll(
    IN LPCWSTR pwszDll      // not expanded
    )
{
    LPWSTR pwszExpandDll; // _alloca'ed
    WCHAR rgch[4];
    DWORD cchDll;
    PDLL_ELEMENT pDll;

    if (0 == (cchDll = ExpandEnvironmentStringsU(
            pwszDll,
            rgch,               // lpszDest, NON_NULL for win95
            sizeof(rgch)/sizeof(rgch[0]))))     // cchDest
        return NULL;
    __try {
        pwszExpandDll = (LPWSTR) _alloca(cchDll * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
    if (0 == ExpandEnvironmentStringsU(
            pwszDll,
            pwszExpandDll,
            cchDll))
        return NULL;

    LockOIDFunc();

    // Check if we already have an entry
    for (pDll = pDllHead; pDll; pDll = pDll->pNext) {
        if (0 == _wcsicmp(pwszExpandDll, pDll->pwszDll))
            break;
    }

    if (NULL == pDll) {
        // Need to create a new DLL entry and add to our list
        if (pDll = (PDLL_ELEMENT) PkiZeroAlloc(
                sizeof(DLL_ELEMENT) + cchDll * sizeof(WCHAR))) {
            LPWSTR pwszEleDll;

            pDll->dwOIDType = DLL_OID_TYPE;
            pwszEleDll = (LPWSTR) ((BYTE *) pDll + sizeof(DLL_ELEMENT));
            memcpy(pwszEleDll, pwszExpandDll, cchDll * sizeof(WCHAR));
            pDll->pwszDll = pwszEleDll;
            pDll->pNext = pDllHead;
            pDllHead = pDll;
        }
    }

    UnlockOIDFunc();
    return pDll;
}

// Upon entry/exit OIDFunc is locked
STATIC PDLL_PROC_ELEMENT AddDllProc(
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    PDLL_PROC_ELEMENT pProcEle = NULL;
    PDLL_ELEMENT pDll;
    DWORD cchFuncName;
    DWORD cbEle;
    LPSTR psz;

    cchFuncName = strlen(pszFuncName) + 1;
    cbEle = sizeof(DLL_PROC_ELEMENT) + cchFuncName;
    if (NULL == (pProcEle = (PDLL_PROC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pDll = FindDll(pwszDll)))
        goto FindDllError;

    pProcEle->pNext = pDll->pProcHead;
    pDll->pProcHead = pProcEle;
    pProcEle->pDll = pDll;
    psz = (LPSTR) ((BYTE *) pProcEle + sizeof(DLL_PROC_ELEMENT));
    memcpy(psz, pszFuncName, cchFuncName);
    pProcEle->pszName = psz;
    pProcEle->pvAddr = NULL;

CommonReturn:
    return pProcEle;
ErrorReturn:
    PkiFree(pProcEle);
    pProcEle = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FindDllError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddRegOIDFunc(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszDll,
    IN DWORD dwCryptFlags
    )
{
    PREG_OID_FUNC_ELEMENT pOIDEle = NULL;
    PDLL_PROC_ELEMENT pProcEle; // not allocated, doesn't need to be free'ed
    DWORD cchOID;
    DWORD cbEle;
    LPSTR psz;

    if (0xFFFF < (DWORD_PTR) pszOID)
        cchOID = strlen(pszOID) + 1;
    else
        cchOID = 0;
    cbEle = sizeof(REG_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pOIDEle = (PREG_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pProcEle = AddDllProc(pszFuncName, pwszDll)))
        goto AddDllProcError;

    pOIDEle->dwEncodingType = dwEncodingType;

    if (dwCryptFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
        pOIDEle->pNext = pFuncSet->pRegBeforeOIDFuncHead;
        pFuncSet->pRegBeforeOIDFuncHead = pOIDEle;
    } else {
        pOIDEle->pNext = pFuncSet->pRegAfterOIDFuncHead;
        pFuncSet->pRegAfterOIDFuncHead = pOIDEle;
    }
    if (cchOID) {
        psz = (LPSTR) ((BYTE *) pOIDEle + sizeof(REG_OID_FUNC_ELEMENT));
        memcpy(psz, pszOID, cchOID);
        pOIDEle->pszOID = psz;
    } else
        pOIDEle->dwOID = (DWORD_PTR) pszOID;
    pOIDEle->pDllProc = pProcEle;

CommonReturn:
    return;
ErrorReturn:
    PkiFree(pOIDEle);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddDllProcError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddDefaultDllList(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCWSTR pwszInDllList,
    IN DWORD cchInDllList
    )
{
    LPWSTR pwszDllList;         // _alloca'ed
    LPWSTR pwsz;
    DWORD cchDllList;
    DWORD cchDll;
    DWORD cDll;

    DWORD i;

    PDEFAULT_REG_ELEMENT pEle = NULL;
    DWORD cbEle;
    LPWSTR *ppwszEleDll;
    PDLL_PROC_ELEMENT *ppEleDllProc;
    LPWSTR pwszEleDllList;

    // Ensure cchDllList has 2 terminating NULL characters
    assert(cchInDllList && pwszInDllList);
    cchDllList = cchInDllList + 2;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    memcpy(pwszDllList, pwszInDllList, cchInDllList * sizeof(WCHAR));
    pwszDllList[cchInDllList] = L'\0';
    pwszDllList[cchInDllList + 1] = L'\0';


    // Get count of null terminated Dlls
    cDll = 0;
    for (pwsz = pwszDllList; 0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1)
        cDll++;

    if (0 == cDll)
        goto NoDll;

    cbEle = sizeof(DEFAULT_REG_ELEMENT) +
        cDll * sizeof(LPWSTR) +
        cDll * sizeof(PDLL_PROC_ELEMENT) +
        cchDllList * sizeof(WCHAR)
        ;

    if (NULL == (pEle = (PDEFAULT_REG_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;
    ppwszEleDll = (LPWSTR *) ((BYTE *) pEle + sizeof(DEFAULT_REG_ELEMENT));
    ppEleDllProc = (PDLL_PROC_ELEMENT *) ((BYTE *) ppwszEleDll +
        cDll * sizeof(LPWSTR));
    pwszEleDllList = (LPWSTR) ((BYTE *) ppEleDllProc +
        cDll * sizeof(PDLL_PROC_ELEMENT));

    assert((BYTE *) pwszEleDllList + cchDllList * sizeof(WCHAR) ==
        (BYTE *) pEle + cbEle);

    pEle->dwEncodingType = dwEncodingType;
//  pEle->pNext =
    memcpy(pwszEleDllList, pwszDllList, cchDllList * sizeof(WCHAR));
    pEle->pwszDllList = pwszEleDllList;
    pEle->cchDllList = cchDllList;
    pEle->cDll = cDll;
    pEle->rgpwszDll = ppwszEleDll;
    pEle->rgpDllProc = ppEleDllProc;

    for (pwsz = pwszEleDllList, i  = 0;
                    0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1, i++) {
        ppwszEleDll[i] = pwsz;
        if (NULL == (ppEleDllProc[i] = AddDllProc(
                pFuncSet->pszFuncName, pwsz)))
            goto AddDllProcError;
    }
    assert (i == cDll);

    pEle->pNext = pFuncSet->pDefaultRegHead;
    pFuncSet->pDefaultRegHead = pEle;

CommonReturn:
    return;

ErrorReturn:
    PkiFree(pEle);
    goto CommonReturn;

TRACE_ERROR(NoDll);
TRACE_ERROR(OutOfMemory);
TRACE_ERROR(AddDllProcError);
}


//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID functions.
//
//  Called with OIDFunc locked
//--------------------------------------------------------------------------
STATIC BOOL WINAPI EnumRegFuncCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) pvArg;

    BOOL fDefaultDllList = FALSE;
    LPCWSTR pwszDll = NULL;                 // not allocated
    DWORD cchDll = 0;
    LPCWSTR pwszOverrideFuncName = NULL;    // not allocated
    DWORD dwCryptFlags = 0;

    assert(pFuncSet);

    if (CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID)
            // Invalid OID. Skip it.
            goto InvalidOID;
    } else if (0 == _stricmp(CRYPT_DEFAULT_OID, pszOID))
        fDefaultDllList = TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, CRYPT_OID_REG_DLL_VALUE_NAME)) {
            if (REG_SZ == dwValueType || REG_EXPAND_SZ == dwValueType ||
                    (fDefaultDllList && REG_MULTI_SZ == dwValueType)) {
                pwszDll = (LPCWSTR) pbValueData;
                cchDll = cbValueData / sizeof(WCHAR);
            } else
                // Invalid "Dll" value.
                goto InvalidDll;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                LPCWSTR pwszValue = (LPCWSTR) pbValueData;
                if (L'\0' != *pwszValue)
                    pwszOverrideFuncName = pwszValue;
            } else
                // Invalid "FuncName" value.
                goto InvalidFuncName;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwCryptFlags))
                memcpy(&dwCryptFlags, pbValueData, sizeof(dwCryptFlags));
            // else
            //  Ignore invalid CryptFlags value type
        }
    }

    if (0 == cchDll || L'\0' == *pwszDll)
        goto NoDll;

    if (fDefaultDllList)
        AddDefaultDllList(
            dwEncodingType,
            pFuncSet,
            pwszDll,
            cchDll
            );
    else {
        BYTE rgb[_MAX_PATH];
        if (pwszOverrideFuncName) {
            if (!MkMBStr(rgb, _MAX_PATH, pwszOverrideFuncName,
                    (LPSTR *) &pszFuncName))
                goto MkMBStrError;
        }
        AddRegOIDFunc(
            dwEncodingType,
            pFuncSet,
            pszFuncName,
            pszOID,
            pwszDll,
            dwCryptFlags
            );
        if (pwszOverrideFuncName)
            FreeMBStr(rgb, (LPSTR) pszFuncName);
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(InvalidOID)
TRACE_ERROR(InvalidDll)
TRACE_ERROR(InvalidFuncName)
TRACE_ERROR(NoDll)
TRACE_ERROR(MkMBStrError)
}

STATIC void LoadRegFunc(
    IN OUT PFUNC_SET pFuncSet
    )
{
    LockOIDFunc();
    if (pFuncSet->fRegLoaded)
        goto CommonReturn;

    CryptEnumOIDFunction(
        CRYPT_MATCH_ANY_ENCODING_TYPE,
        pFuncSet->pszFuncName,
        NULL,                           // pszOID
        0,                              // dwFlags
        (void *) pFuncSet,              // pvArg
        EnumRegFuncCallback
        );
    pFuncSet->fRegLoaded = TRUE;

CommonReturn:
    UnlockOIDFunc();
    return;
}

// Upon entry/exit OIDFunc is locked
STATIC void RemoveFreeDll(
    IN PDLL_ELEMENT pDll
    )
{
    // Remove Dll from free list
    if (pDll->pFreeNext)
        pDll->pFreeNext->pFreePrev = pDll->pFreePrev;
    if (pDll->pFreePrev)
        pDll->pFreePrev->pFreeNext = pDll->pFreeNext;
    else if (pDll == pFreeDllHead)
        pFreeDllHead = pDll->pFreeNext;
    // else
    //  Not on any list

    pDll->pFreeNext = NULL;
    pDll->pFreePrev = NULL;

    assert(dwFreeDllCnt);
    if (dwFreeDllCnt)
        dwFreeDllCnt--;
}

// Upon entry/exit OIDFunc is locked
STATIC void AddRefDll(
    IN PDLL_ELEMENT pDll
    )
{
    pDll->dwRefCnt++;
    if (pDll->dwFreeCnt) {
        pDll->dwFreeCnt = 0;
        RemoveFreeDll(pDll);
    }
}

// Note, MUST NOT HOLD OID LOCK WHILE CALLING FreeLibrary()!!
//
// Therefore, will put the Dll's to be freed on a list while holding the
// OID LOCK. After releasing the OID LOCK, will iterate through the
// list and call FreeLibrary().
STATIC VOID NTAPI FreeDllWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut     // ???
    )
{
    PDLL_ELEMENT pFreeDll;
    HMODULE *phFreeLibrary = NULL;  // _alloca'ed
    DWORD cFreeLibrary = 0;

    LockOIDFunc();

    if (dwFreeDllCnt) {
        DWORD dwOrigFreeDllCnt = dwFreeDllCnt;
    __try {
        phFreeLibrary = (HMODULE *) _alloca(
            dwOrigFreeDllCnt * sizeof(HMODULE));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto OutOfMemory;
    }

        pFreeDll = pFreeDllHead;
        assert(pFreeDll);
        while (pFreeDll) {
            PDLL_ELEMENT pDll = pFreeDll;
            pFreeDll = pFreeDll->pFreeNext;

            assert(pDll->dwFreeCnt);
            if (0 == --pDll->dwFreeCnt) {
                RemoveFreeDll(pDll);

                assert(pDll->fLoaded);
                if (!pDll->fLoaded)
                    continue;
                if (NULL == pDll->pfnDllCanUnloadNow ||
                        S_OK == pDll->pfnDllCanUnloadNow()) {
                    assert(cFreeLibrary < dwOrigFreeDllCnt);
                    if (cFreeLibrary < dwOrigFreeDllCnt) {
                        PDLL_PROC_ELEMENT pEle;

                        // Loop and NULL all proc addresses
                        for (pEle = pDll->pProcHead; pEle; pEle = pEle->pNext)
                            pEle->pvAddr = NULL;

                        pDll->pfnDllCanUnloadNow = NULL;
                        // Add to array to be freed after releasing lock!!
                        assert(pDll->hDll);
                        phFreeLibrary[cFreeLibrary++] = pDll->hDll;
                        pDll->hDll = NULL;
                        pDll->fLoaded = FALSE;
                    }
                }
            }
        }
    } else {
        assert(NULL == pFreeDllHead);
    }

    if (NULL == pFreeDllHead) {
        assert(0 == dwFreeDllCnt);
        // Do interlock to guard against a potential race condition at
        // PROCESS_DETACH. Note, PROCESS_DETACH doesn't do a LockOIDFunc().
        if (InterlockedExchange(&lFreeDll, 0)) {
            HANDLE hRegWaitFor;
            HMODULE hDllLibModule;

            hRegWaitFor = hFreeDllRegWaitFor;
            hFreeDllRegWaitFor = NULL;
            hDllLibModule = hFreeDllLibModule;
            hFreeDllLibModule = NULL;
            UnlockOIDFunc();

            while (cFreeLibrary--)
                FreeLibrary(phFreeLibrary[cFreeLibrary]);

            assert(hRegWaitFor);
            ILS_ExitWait(hRegWaitFor, hDllLibModule);
            assert(FALSE);
            return;
        }
    }

CommonReturn:
    UnlockOIDFunc();
    while (cFreeLibrary--)
        FreeLibrary(phFreeLibrary[cFreeLibrary]);
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(OutOfMemory);
}

STATIC void ReleaseDll(
    IN PDLL_ELEMENT pDll
    )
{
    LockOIDFunc();
    assert(pDll->dwRefCnt);
    if (0 == --pDll->dwRefCnt) {
        assert(pDll->fLoaded);
        if (!pDll->fLoaded)
            goto CommonReturn;

        assert(0 == pDll->dwFreeCnt);
        if (pDll->dwFreeCnt)
            goto CommonReturn;

        if (0 == lFreeDll) {
            assert(NULL == hFreeDllRegWaitFor);
            assert(NULL == hFreeDllLibModule);

            // Inhibit crypt32.dll from being unloaded until this thread
            // exits.
            hFreeDllLibModule = DuplicateLibrary(hOidInfoInst);
            if (!ILS_RegisterWaitForSingleObject(
                    &hFreeDllRegWaitFor,
                    NULL,                   // hObject
                    FreeDllWaitForCallback,
                    NULL,                   // Context
                    FREE_DLL_TIMEOUT,
                    0                       // dwFlags
                    )) {
                hFreeDllRegWaitFor = NULL;
                if (hFreeDllLibModule) {
                    FreeLibrary(hFreeDllLibModule);
                    hFreeDllLibModule = NULL;
                }
                goto RegisterWaitForError;
            }

            lFreeDll = 1;
        }

        assert(NULL == pDll->pFreeNext);
        assert(NULL == pDll->pFreePrev);
        pDll->dwFreeCnt = 2;
        if (pFreeDllHead) {
            pFreeDllHead->pFreePrev = pDll;
            pDll->pFreeNext = pFreeDllHead;
        }
        pFreeDllHead = pDll;
        dwFreeDllCnt++;
    }

CommonReturn:
    UnlockOIDFunc();
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(RegisterWaitForError)
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL LoadDll(
    IN PDLL_ELEMENT pDll
    )
{
    BOOL fResult;
    HMODULE hDll = NULL;
    LPFNCANUNLOADNOW pfnDllCanUnloadNow = NULL;

    LockOIDFunc();
    if (pDll->fLoaded)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        hDll = LoadLibraryExU(pDll->pwszDll, NULL, 0);
        if (hDll)
            pfnDllCanUnloadNow = (LPFNCANUNLOADNOW) GetProcAddress(
                hDll, "DllCanUnloadNow");
        LockOIDFunc();
        
        AddRefDll(pDll);
        if (!pDll->fLoaded) {
            assert(1 == pDll->dwRefCnt);
            assert(0 == pDll->dwFreeCnt);
            assert(pDll->pwszDll);
            assert(NULL == pDll->hDll);
            if (NULL == (pDll->hDll = hDll)) {
                pDll->dwRefCnt = 0;
                goto LoadLibraryError;
            }
            hDll = NULL;
            pDll->fLoaded = TRUE;

            assert(NULL == pDll->pfnDllCanUnloadNow);
            pDll->pfnDllCanUnloadNow = pfnDllCanUnloadNow;
        }
    }

    fResult = TRUE;
CommonReturn:
    UnlockOIDFunc();
    if (hDll) {
        // Dll was loaded by another thread.
        DWORD dwErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(LoadLibraryError);
}


// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDllProcAddr(
    IN PDLL_PROC_ELEMENT pEle,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    BOOL fResult;
    void *pvAddr;
    PDLL_ELEMENT pDll;

    LockOIDFunc();

    pDll = pEle->pDll;
    assert(pDll);

    if (pvAddr = pEle->pvAddr)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        fResult = LoadDll(pDll);
        if (fResult) {
            assert(pDll->hDll);
            pvAddr = GetProcAddress(pDll->hDll, pEle->pszName);
        }
        LockOIDFunc();
        if (!fResult)
            goto LoadDllError;

        if (pvAddr)
            pEle->pvAddr = pvAddr;
        else {
            ReleaseDll(pDll);
            goto GetProcAddressError;
        }
    }

    fResult = TRUE;

CommonReturn:
    *ppvFuncAddr = pvAddr;
    *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
    UnlockOIDFunc();

    return fResult;
ErrorReturn:
    fResult = FALSE;
    pDll = NULL;
    pvAddr = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadDllError)
TRACE_ERROR(GetProcAddressError)
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetRegOIDFunctionAddress(
    IN PREG_OID_FUNC_ELEMENT pRegEle,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;
        if (0xFFFF >= (DWORD_PTR) pszOID) {
            if (pszOID != pRegEle->pszOID)
                continue;
        } else {
            if (0xFFFF >= (DWORD_PTR) pRegEle->pszOID ||
                    0 != _stricmp(pszOID, pRegEle->pszOID))
                continue;
        }

        return GetDllProcAddr(
            pRegEle->pDllProc,
            ppvFuncAddr,
            phFuncAddr
            );
    }

    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDefaultRegOIDFunctionAddress(
    IN PFUNC_SET pFuncSet,
    IN DWORD dwEncodingType,
    IN LPCWSTR pwszDll,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PDEFAULT_REG_ELEMENT pRegEle = pFuncSet->pDefaultRegHead;
    PDLL_ELEMENT pDll;

    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;

        for (DWORD i = 0; i < pRegEle->cDll; i++) {
            if (0 == _wcsicmp(pwszDll, pRegEle->rgpwszDll[i]))
                return GetDllProcAddr(
                    pRegEle->rgpDllProc[i],
                    ppvFuncAddr,
                    phFuncAddr
                    );
        }
    }

    if (pDll = FindDll(pwszDll)) {
        if (LoadDll(pDll)) {
            if (*ppvFuncAddr = GetProcAddress(pDll->hDll,
                    pFuncSet->pszFuncName)) {
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
                return TRUE;
            } else
                ReleaseDll(pDll);
        }
    }

    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Search the list of installed functions for an OID and EncodingType match.
//  If not found, search the registry.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it.
//
//  For a registry match, the Dll containing the function is loaded.
//
//  By default, both the registered and installed function lists are searched.
//  Set CRYPT_GET_INSTALLED_OID_FUNC_FLAG to only search the installed list
//  of functions. This flag would be set by a registered function to get
//  the address of a pre-installed function it was replacing. For example,
//  the registered function might handle a new special case and call the
//  pre-installed function to handle the remaining cases.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    DWORD_PTR dwOID;

    dwEncodingType = GetEncodingType(dwEncodingType);

    if (0xFFFF < (DWORD_PTR) pszOID && CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID) {
            SetLastError((DWORD) E_INVALIDARG);
            *ppvFuncAddr = NULL;
            *phFuncAddr = NULL;
            return FALSE;
        }
    }

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegBeforeOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegBeforeOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    if (0xFFFF >= (dwOID = (DWORD_PTR) pszOID)) {
        PCONST_OID_FUNC_ELEMENT pConstEle = pFuncSet->pConstOIDFuncHead;
        while (pConstEle) {
            if (dwEncodingType == pConstEle->dwEncodingType &&
                    dwOID >= pConstEle->dwLowOID &&
                    dwOID <= pConstEle->dwHighOID) {
                *ppvFuncAddr = pConstEle->rgpvFuncAddr[
                    dwOID - pConstEle->dwLowOID];
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pConstEle;
                return TRUE;
            }
            pConstEle = pConstEle->pNext;
        }
    } else {
        PSTR_OID_FUNC_ELEMENT pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(pszOID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }
    }

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegAfterOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegAfterOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    SetLastError((DWORD) ERROR_FILE_NOT_FOUND);
    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Get the list of registered default Dll entries for the specified
//  function set and encoding type.
//
//  The returned list consists of none, one or more null terminated Dll file
//  names. The list is terminated with an empty (L"\0") Dll file name.
//  For example: L"first.dll" L"\0" L"second.dll" L"\0" L"\0"
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDDllList(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    OUT LPWSTR pwszDllList,
    IN OUT DWORD *pcchDllList
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    PDEFAULT_REG_ELEMENT pRegEle;

    DWORD cchRegDllList = 2;
    LPWSTR pwszRegDllList = L"\0\0";

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    dwEncodingType = GetEncodingType(dwEncodingType);

    pRegEle = pFuncSet->pDefaultRegHead;
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType == pRegEle->dwEncodingType) {
            cchRegDllList = pRegEle->cchDllList;
            assert(cchRegDllList >= 2);
            pwszRegDllList = pRegEle->pwszDllList;
            break;
        }
    }

    fResult = TRUE;
    if (pwszDllList) {
        if (cchRegDllList > *pcchDllList) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else
            memcpy(pwszDllList, pwszRegDllList, cchRegDllList * sizeof(WCHAR));
    }
    *pcchDllList = cchRegDllList;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Either: get the first or next installed DEFAULT function OR
//  load the Dll containing the DEFAULT function.
//
//  If pwszDll is NULL, search the list of installed DEFAULT functions.
//  *phFuncAddr must be set to NULL to get the first installed function.
//  Successive installed functions are returned by setting *phFuncAddr
//  to the hFuncAddr returned by the previous call.
//
//  If pwszDll is NULL, the input *phFuncAddr
//  is always CryptFreeOIDFunctionAddress'ed by this function, even for
//  an error.
//
//  If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT
//  function. *phFuncAddr is ignored upon entry and isn't
//  CryptFreeOIDFunctionAddress'ed.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it or CryptGetDefaultOIDFunctionAddress can also
//  be called for a NULL pwszDll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN OPTIONAL LPCWSTR pwszDll,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    IN OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    dwEncodingType = GetEncodingType(dwEncodingType);

    if (NULL == pwszDll) {
        // Get from installed list
        PSTR_OID_FUNC_ELEMENT pStrEle = (PSTR_OID_FUNC_ELEMENT) *phFuncAddr;

        if (pStrEle && STR_OID_TYPE == pStrEle->dwOIDType)
            pStrEle = pStrEle->pNext;
        else
            pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(CRYPT_DEFAULT_OID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }

        SetLastError(ERROR_FILE_NOT_FOUND);
        *ppvFuncAddr = NULL;
        *phFuncAddr = NULL;
        return FALSE;
    } else
        return GetDefaultRegOIDFunctionAddress(
            pFuncSet,
            dwEncodingType,
            pwszDll,
            ppvFuncAddr,
            phFuncAddr);
}

//+-------------------------------------------------------------------------
//  Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress
//  or CryptGetDefaultOIDFunctionAddress.
//
//  If a Dll was loaded for the function its unloaded. However, before doing
//  the unload, the DllCanUnloadNow function exported by the loaded Dll is
//  called. It should return S_FALSE to inhibit the unload or S_TRUE to enable
//  the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded.
//
//  DllCanUnloadNow has the following signature:
//      STDAPI  DllCanUnloadNow(void);
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFreeOIDFunctionAddress(
    IN HCRYPTOIDFUNCADDR hFuncAddr,
    IN DWORD dwFlags
    )
{
    PDLL_ELEMENT pDll = (PDLL_ELEMENT) hFuncAddr;
    if (pDll && DLL_OID_TYPE == pDll->dwOIDType) {
        DWORD dwErr = GetLastError();
        ReleaseDll(pDll);
        SetLastError(dwErr);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certstor\policy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       policy.cpp
//
//  Contents:   Certificate Chain Policy APIs
//
//  Functions:  CertChainPolicyDllMain
//              CertVerifyCertificateChainPolicy
//              CertDllVerifyBaseCertificateChainPolicy
//              CertDllVerifyBasicConstraintsCertificateChainPolicy
//              CertDllVerifyAuthenticodeCertificateChainPolicy
//              CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy
//              CertDllVerifySSLCertificateChainPolicy
//              CertDllVerifyNTAuthCertificateChainPolicy
//              CertDllVerifyMicrosoftRootCertificateChainPolicy
//
//  History:    16-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"
#include "softpub.h"

#include "wininet.h"
#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif


#define INVALID_NAME_ERROR_STATUS   ( \
    CERT_TRUST_INVALID_NAME_CONSTRAINTS             | \
    CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT    | \
    CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT      | \
    CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT    | \
    CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT           \
    )

#define INVALID_POLICY_ERROR_STATUS   ( \
    CERT_TRUST_INVALID_POLICY_CONSTRAINTS           | \
    CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY               \
    )

BOOL fWildcardsEnabledInSslServerCerts = TRUE;

//+-------------------------------------------------------------------------
//  Global cert policy critical section.
//--------------------------------------------------------------------------
static CRITICAL_SECTION CertPolicyCriticalSection;

//+-------------------------------------------------------------------------
//  Cached certificate store used for NTAuth certificate chain policy.
//--------------------------------------------------------------------------
static HCERTSTORE hNTAuthCertStore = NULL;

//
//  support for MS test roots!!!!
//
static BYTE rgbTestRoot[] = 
{
#include "mstest1.h"
};

static BYTE rgbTestRootCorrected[] = 
{
#include "mstest2.h"
};

static BYTE rgbTestRootBeta1[] = 
{
#include "mstestb1.h"
};

static CERT_PUBLIC_KEY_INFO rgTestRootPublicKeyInfo[] = 
{
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0},
    {szOID_RSA_RSA, 0, NULL,
        sizeof(rgbTestRootCorrected), rgbTestRootCorrected, 0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootBeta1), rgbTestRootBeta1, 0}
};
#define NTESTROOTS (sizeof(rgTestRootPublicKeyInfo)/ \
                            sizeof(rgTestRootPublicKeyInfo[0]))

HCRYPTOIDFUNCSET hChainPolicyFuncSet;

typedef BOOL (WINAPI *PFN_CHAIN_POLICY_FUNC) (
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyMicrosoftRootCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

static const CRYPT_OID_FUNC_ENTRY ChainPolicyFuncTable[] = {
    CERT_CHAIN_POLICY_BASE, CertDllVerifyBaseCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE,
        CertDllVerifyAuthenticodeCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE_TS,
        CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy,
    CERT_CHAIN_POLICY_SSL,
        CertDllVerifySSLCertificateChainPolicy,
    CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
        CertDllVerifyBasicConstraintsCertificateChainPolicy,
    CERT_CHAIN_POLICY_NT_AUTH,
        CertDllVerifyNTAuthCertificateChainPolicy,
    CERT_CHAIN_POLICY_MICROSOFT_ROOT,
        CertDllVerifyMicrosoftRootCertificateChainPolicy,
};

#define CHAIN_POLICY_FUNC_COUNT (sizeof(ChainPolicyFuncTable) / \
                                    sizeof(ChainPolicyFuncTable[0]))


BOOL
WINAPI
CertChainPolicyDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hChainPolicyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                CHAIN_POLICY_FUNC_COUNT,
                ChainPolicyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!Pki_InitializeCriticalSection(&CertPolicyCriticalSection))
            goto InitCritSectionError;
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&CertPolicyCriticalSection);
        if (hNTAuthCertStore)
            CertCloseStore(hNTAuthCertStore, 0);
        break;

    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+-------------------------------------------------------------------------
//  Lock and unlock global cert policy functions
//--------------------------------------------------------------------------
static inline void CertPolicyLock()
{
    EnterCriticalSection(&CertPolicyCriticalSection);
}
static inline void CertPolicyUnlock()
{
    LeaveCriticalSection(&CertPolicyCriticalSection);
}


//+-------------------------------------------------------------------------
//  Verify that the certificate chain satisfies the specified policy
//  requirements. If we were able to verify the chain policy, TRUE is returned
//  and the dwError field of the pPolicyStatus is updated. A dwError of 0
//  (ERROR_SUCCESS, S_OK) indicates the chain satisfies the specified policy.
//
//  If dwError applies to the entire chain context, both lChainIndex and
//  lElementIndex are set to -1. If dwError applies to a simple chain,
//  lElementIndex is set to -1 and lChainIndex is set to the index of the
//  first offending chain having the error. If dwError applies to a
//  certificate element, lChainIndex and lElementIndex are updated to 
//  index the first offending certificate having the error, where, the
//  the certificate element is at:
//      pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
//
//  The dwFlags in pPolicyPara can be set to change the default policy checking
//  behaviour. In addition, policy specific parameters can be passed in
//  the pvExtraPolicyPara field of pPolicyPara.
//
//  In addition to returning dwError, in pPolicyStatus, policy OID specific
//  extra status may be returned via pvExtraPolicyStatus.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;

    if (!CryptGetOIDFunctionAddress(
            hChainPolicyFuncSet,
            0,                      // dwEncodingType,
            pszPolicyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
        goto GetOIDFuncAddrError;

    fResult = ((PFN_CHAIN_POLICY_FUNC) pvFuncAddr)(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOIDFuncAddrError)
}


static inline PCERT_CHAIN_ELEMENT GetRootChainElement(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD dwRootChainIndex = pChainContext->cChain - 1;
    DWORD dwRootElementIndex =
        pChainContext->rgpChain[dwRootChainIndex]->cElement - 1;

    return pChainContext->rgpChain[dwRootChainIndex]->
                                        rgpElement[dwRootElementIndex];
}

void GetElementIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex,
    OUT LONG *plElementIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];

            if (pEle->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
                *plChainIndex = (LONG) i;
                *plElementIndex = (LONG) j;
                return;
            }
        }
    }

    *plChainIndex = -1;
    *plElementIndex = -1;
}

void GetChainIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        if (pChain->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
            *plChainIndex = (LONG) i;
            return;
        }
    }

    *plChainIndex = -1;
}


//+=========================================================================
//  CertDllVerifyBaseCertificateChainPolicy Functions
//==========================================================================

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwContextError;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;
    DWORD dwErrorStatusMask;

    dwContextError = pChainContext->TrustStatus.dwErrorStatus;


    if (0 == dwContextError) {
        // Valid chain
        dwError = 0;
        goto CommonReturn;
    }

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (dwContextError &
            (CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)) {
        dwError = (DWORD) TRUST_E_CERT_SIGNATURE;
        dwErrorStatusMask =
            CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
        if (dwErrorStatusMask & CERT_TRUST_IS_NOT_SIGNATURE_VALID)
            goto GetElementIndexReturn;
        else
            goto GetChainIndexReturn;
    } 

    if (dwContextError & CERT_TRUST_IS_UNTRUSTED_ROOT) {
        dwErrorStatusMask = CERT_TRUST_IS_UNTRUSTED_ROOT;
        if (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG) {
            ;
        } else if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG)) {
            dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
            goto GetElementIndexReturn;
        } else {
            // Check if one of the "test" roots
            DWORD i;
            BOOL fTestRoot;
            PCERT_CHAIN_ELEMENT pRootElement;
            PCCERT_CONTEXT pRootCert;

            pRootElement = GetRootChainElement(pChainContext);
            assert(pRootElement->TrustStatus.dwInfoStatus &
                CERT_TRUST_IS_SELF_SIGNED);
            pRootCert = pRootElement->pCertContext;

            fTestRoot = FALSE;
            for (i = 0; i < NTESTROOTS; i++) {
                if (CertComparePublicKeyInfo(
                        pRootCert->dwCertEncodingType,
                        &pRootCert->pCertInfo->SubjectPublicKeyInfo,
                        &rgTestRootPublicKeyInfo[i])) {
                    fTestRoot = TRUE;
                    break;
                }
            }
            if (fTestRoot) {
                if (0 == (dwFlags & CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG)) {
                    dwError = (DWORD) CERT_E_UNTRUSTEDTESTROOT;
                    goto GetElementIndexReturn;
                }
            } else {
                dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
                goto GetElementIndexReturn;
            }
        }
    }

    if (dwContextError & CERT_TRUST_IS_PARTIAL_CHAIN) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG)) {
            dwError = (DWORD) CERT_E_CHAINING;
            dwErrorStatusMask = CERT_TRUST_IS_PARTIAL_CHAIN;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_REVOKED) {
        dwError = (DWORD) CRYPT_E_REVOKED;
        dwErrorStatusMask = CERT_TRUST_IS_REVOKED;
        goto GetElementIndexReturn;
    }

    if (dwContextError & (CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
            CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG)) {
            dwError = (DWORD) CERT_E_WRONG_USAGE;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
                CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
            if (dwContextError & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)
                goto GetElementIndexReturn;
            else
                goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG)) {
            dwError = (DWORD) CERT_E_EXPIRED;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_VALID;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_CTL_IS_NOT_TIME_VALID;
            dwError = (DWORD) CERT_E_EXPIRED;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & INVALID_NAME_ERROR_STATUS) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG)) {
            dwError = (DWORD) CERT_E_INVALID_NAME;
            dwErrorStatusMask = INVALID_NAME_ERROR_STATUS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & INVALID_POLICY_ERROR_STATUS) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG)) {
            dwError = (DWORD) CERT_E_INVALID_POLICY;
            dwErrorStatusMask = INVALID_POLICY_ERROR_STATUS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
        if (0 == (dwFlags &
                    CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG)) {
            dwError = (DWORD) TRUST_E_BASIC_CONSTRAINTS;
            dwErrorStatusMask = CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_NESTED) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_NESTED;
            dwError = (DWORD) CERT_E_VALIDITYPERIODNESTING;
            goto GetElementIndexReturn;
        }
    }

    dwError = 0;

    // Note, OFFLINE takes precedence over NO_CHECK

    if (dwContextError & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) {
        if ((dwFlags & CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) !=
                CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) {
            DWORD i;
            for (i = 0; i < pChainContext->cChain; i++) {
                DWORD j;
                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

                for (j = 0; j < pChain->cElement; j++) {
                    PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
                    DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
                    DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
                    DWORD dwRevokeError;
                    BOOL fEnableRevokeError;

                    if (0 == (dwEleError &
                            CERT_TRUST_REVOCATION_STATUS_UNKNOWN))
                        continue;

                    assert(pEle->pRevocationInfo);
                    dwRevokeError = pEle->pRevocationInfo->dwRevocationResult;
                    if (CRYPT_E_NO_REVOCATION_CHECK != dwRevokeError)
                        dwRevokeError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
                    fEnableRevokeError = FALSE;

                    if (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) {
                        // Chain Root
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else if (0 == i && 0 == j) {
                        // End certificate
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else if (0 == j) {
                        // CTL signer certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else  {
                        // CA certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    }

                    if (fEnableRevokeError) {
                        if (0 == dwError ||
                                CRYPT_E_REVOCATION_OFFLINE == dwRevokeError) {
                            dwError = dwRevokeError;
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;

                            if (CRYPT_E_REVOCATION_OFFLINE == dwError)
                                goto CommonReturn;
                        }
                    }
                }
            }
        }
    }


CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;

GetElementIndexReturn:
    GetElementIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex, &lElementIndex);
    goto CommonReturn;

GetChainIndexReturn:
    GetChainIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex);
    goto CommonReturn;
}

//+=========================================================================
//  CertDllVerifyBasicConstraintsCertificateChainPolicy Functions
//==========================================================================

// If dwFlags is 0, allow either CA or END_ENTITY for dwEleIndex == 0
BOOL CheckChainElementBasicConstraints(
    IN PCERT_CHAIN_ELEMENT pEle,
    IN DWORD dwEleIndex,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    PCERT_INFO pCertInfo = pEle->pCertContext->pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo = NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo2 = NULL;
    DWORD cbInfo;

    BOOL fCA;
    BOOL fEndEntity;
    BOOL fPathLenConstraint;
    DWORD dwPathLenConstraint;

    if (0 == pCertInfo->cExtension) 
        goto SuccessReturn;

    if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS2,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS2, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo2,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        fCA = pInfo2->fCA;
        fEndEntity = !fCA;
        fPathLenConstraint = pInfo2->fPathLenConstraint;
        dwPathLenConstraint = pInfo2->dwPathLenConstraint;
    } else if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        if (pExt->fCritical && pInfo->cSubtreesConstraint)
            goto SubtreesError;

        if (pInfo->SubjectType.cbData > 0) {
            BYTE bRole = pInfo->SubjectType.pbData[0];
            fCA = (0 != (bRole & CERT_CA_SUBJECT_FLAG));
            fEndEntity = (0 != (bRole & CERT_END_ENTITY_SUBJECT_FLAG));
        } else {
            fCA = FALSE;
            fEndEntity = FALSE;
        }
        fPathLenConstraint = pInfo->fPathLenConstraint;
        dwPathLenConstraint = pInfo->dwPathLenConstraint;
    } else
        goto SuccessReturn;


    if (0 == dwEleIndex) {
        if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG) {
            if (!fEndEntity)
                goto NotAnEndEntity;
        }
        if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG) {
            if (!fCA)
                goto NotACA;
        }
    } else {
        if (!fCA)
            goto NotACA;

        if (fPathLenConstraint) {
            // Check count of CAs below
            if (dwEleIndex - 1 > dwPathLenConstraint)
                goto PathLengthError;
        }
    }
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    PkiFree(pInfo2);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(NotACA)
TRACE_ERROR(NotAnEndEntity)
TRACE_ERROR(SubtreesError)
TRACE_ERROR(PathLengthError)
TRACE_ERROR(DecodeError)
}

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwFlags;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize) {
        dwFlags = pPolicyPara->dwFlags;
        dwFlags &= (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG);
        if (dwFlags == (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
                BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG))
            dwFlags = 0;    // 0 => allow CA or END_ENTITY
    } else
        dwFlags = 0;

    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            if (!CheckChainElementBasicConstraints(pChain->rgpElement[j], j,
                    dwFlags)) {
                assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS,
                    lElementIndex) < pPolicyStatus->cbSize);
                pPolicyStatus->dwError = (DWORD) TRUST_E_BASIC_CONSTRAINTS;
                pPolicyStatus->lChainIndex = (LONG) i;
                pPolicyStatus->lElementIndex = (LONG) j;
                return TRUE;
            }
        }
        // Allow CTL to be signed by either a CA or END_ENTITY
        dwFlags = 0;
    }

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeCertificateChainPolicy Functions
//
//  On July 1, 2000 philh removed all of the individual/commercial
//  stuff. It hasn't been used for years!.
//==========================================================================

// Returns TRUE if the signer cert has the Code Signing EKU or if the signer
// cert has the legacy Key Usage extension with either the individual or
// commercial usage.
//
// For backwards compatibility, allow a signer cert without any EKU's
BOOL CheckAuthenticodeChainPurpose(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    BOOL fResult;
    PCERT_CHAIN_ELEMENT pEle;
    PCCERT_CONTEXT pCert;
    PCERT_INFO pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD cbInfo;

    pEle = pChainContext->rgpChain[0]->rgpElement[0];
    if (NULL == pEle->pApplicationUsage) {
        // No usages. Good for any usage.
        // Do we want to allow this?? Yes, for backward compatibility
        goto SuccessReturn;
    } else {
        DWORD cUsage;
        LPSTR *ppszUsage;

        cUsage = pEle->pApplicationUsage->cUsageIdentifier;
        ppszUsage = pEle->pApplicationUsage->rgpszUsageIdentifier;
        for ( ; cUsage > 0; cUsage--, ppszUsage++) {
            if (0 == strcmp(*ppszUsage, szOID_PKIX_KP_CODE_SIGNING))
                goto SuccessReturn;
        }
    }

    pCert = pEle->pCertContext;
    pCertInfo = pCert->pCertInfo;

    if (0 == pCertInfo->cExtension)
        goto NoSignerCertExtensions;
    
    if (NULL == (pExt = CertFindExtension(
            szOID_KEY_USAGE_RESTRICTION,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )))
        goto NoSignerKeyUsageExtension;

    if (!CryptDecodeObjectEx(
            pCert->dwCertEncodingType,
            X509_KEY_USAGE_RESTRICTION,
            pExt->Value.pbData,
            pExt->Value.cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    if (pInfo->cCertPolicyId) {
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;

        cPolicyId = pInfo->cCertPolicyId;
        pPolicyId = pInfo->rgCertPolicyId;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) {
            DWORD cElementId = pPolicyId->cCertPolicyElementId;
            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
            {
                if (0 == strcmp(*ppszElementId,
                        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID))
                    goto SuccessReturn;
                else if (0 == strcmp(*ppszElementId,
                        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
                    goto SuccessReturn;
            }
        }
    }

    goto NoSignerLegacyPurpose;
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(NoSignerCertExtensions)
TRACE_ERROR(NoSignerKeyUsageExtension)
TRACE_ERROR(DecodeError);
TRACE_ERROR(NoSignerLegacyPurpose)
}

void MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOKATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else if (dwRegPolicySettings & (WTPF_OFFLINEOK_COM | WTPF_OFFLINEOK_IND))
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;

    *pdwFlags = dwFlags;
}


void GetAuthenticodePara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings,
    OUT PCMSG_SIGNER_INFO *ppSignerInfo
    )
{
    *ppSignerInfo = NULL;
    *pdwRegPolicySettings = 0;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                pSignerInfo) < pAuthPara->cbSize)
            *ppSignerInfo = pAuthPara->pSignerInfo;
    }
}

// Map the CRYPT_E_ revocation errors to the corresponding CERT_E_
// revocation errors
static DWORD MapToAuthenticodeError(
    IN DWORD dwError
    )
{
    switch (dwError) {
        case CRYPT_E_REVOKED:
            return (DWORD) CERT_E_REVOKED;
            break;
        case CRYPT_E_NO_REVOCATION_DLL:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
        case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
            return (DWORD) CERT_E_REVOCATION_FAILURE;
            break;
    }
    return dwError;
}

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    PCMSG_SIGNER_INFO pSignerInfo;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;


    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodePara(pPolicyPara, &dwRegPolicySettings, &pSignerInfo);

    MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;

        if (CERT_E_REVOCATION_FAILURE != dwError)
            goto CommonReturn;
        // else
        //  for REVOCATION_FAILURE let
        //  PURPOSE and BASIC_CONSTRAINTS errors take precedence
    }

    if (pSignerInfo) {
        // Check that either the chain has the code signing EKU or
        // the signer cert has the legacy Key Usage extension containing
        // the commerical or individual policy.
        if (!CheckAuthenticodeChainPurpose(pChainContext)) {
            dwError = (DWORD) CERT_E_PURPOSE;
            lChainIndex = 0;
            lElementIndex = 0;
            goto CommonReturn;
        }
    }
        
    if (pSignerInfo)
        BasePolicyPara.dwFlags =
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
    else
        BasePolicyPara.dwFlags = 0;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (BasePolicyStatus.dwError) {
        dwError = BasePolicyStatus.dwError;
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    if (offsetof(CERT_CHAIN_POLICY_STATUS, pvExtraPolicyStatus) <
            pPolicyStatus->cbSize &&
                pPolicyStatus->pvExtraPolicyStatus) {
        // Since the signer statement's Commercial/Individual flag is no
        // longer used, default to individual
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS pAuthStatus =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS)
                pPolicyStatus->pvExtraPolicyStatus;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS,
                fCommercial) < pAuthStatus->cbSize)
            pAuthStatus->fCommercial = FALSE;
    }
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy Functions
//==========================================================================

void MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOCATIONONTS)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else if (dwRegPolicySettings & (WTPF_OFFLINEOK_COM | WTPF_OFFLINEOK_IND))
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;

    *pdwFlags = dwFlags;
}


void GetAuthenticodeTimeStampPara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings
    )
{
    *pdwRegPolicySettings = 0;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
    }
}


BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodeTimeStampPara(
        pPolicyPara, &dwRegPolicySettings);

    MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifySSLCertificateChainPolicy Functions
//==========================================================================

// www.foobar.com == www.foobar.com
// Www.Foobar.com == www.fooBar.cOm
// www.foobar.com == *.foobar.com
// www.foobar.com == w*.foobar.com
// www.foobar.com == ww*.foobar.com
// www.foobar.com != *ww.foobar.com
// abcdef.foobar.com != ab*ef.foobar.com
// abcdef.foobar.com != abc*ef.foobar.com
// abcdef.foobar.com != abc*def.foobar.com
// www.foobar.com != www.f*bar.com
// www.foobar.com != www.*bar.com
// www.foobar.com != www.foo*.com
// www.foobar.com != www.*.com
// foobar.com != *.com
// www.foobar.abc.com != *.abc.com
// foobar.com != *.*
// foobar != *
// abc.def.foobar.com != a*.d*.foobar.com
// abc.foobar.com.au != *.*.com.au
// abc.foobar.com.au != www.*.com.au

BOOL CompareSSLDNStoCommonName(LPCWSTR pDNS, LPCWSTR pCN)
{
    BOOL fUseWildCardRules = FALSE;

    if (NULL == pDNS || L'\0' == *pDNS ||
            NULL == pCN || L'\0' == *pCN)
        return FALSE;

    if(fWildcardsEnabledInSslServerCerts)
    {
        if(wcschr(pCN, L'*') != NULL)
        {
            fUseWildCardRules = TRUE;
        }
    }

    if(fUseWildCardRules)
    {
        DWORD    nCountPeriods  = 1;
        BOOL     fExactMatch    = TRUE;
        BOOL     fComp;
        LPCWSTR  pWild;

        pWild = wcschr(pCN, L'*');
        if(pWild)
        {
            // Fail if CN contains more than one '*'.
            if(wcschr(pWild + 1, L'*'))
            {
                return FALSE;
            }

            // Fail if the wildcard isn't in the first name component.
            if(pWild > wcschr(pCN, L'.'))
            {
                return FALSE;
            }
        }

        while(TRUE)
        {
            fComp = (CSTR_EQUAL == CompareStringU(
                                            LOCALE_USER_DEFAULT,
                                            NORM_IGNORECASE,
                                            pDNS,
                                            1,             // cchCount1
                                            pCN,
                                            1));           // cchCount2

            if ((!fComp && *pCN != L'*') || !(*pDNS) || !(*pCN))
            {
                break;
            }

            if (!fComp)
            {
                fExactMatch = FALSE;
            }

            if (*pCN == L'*')
            {
                nCountPeriods = 0;

                if (*pDNS == L'.')
                {
                    pCN++;
                }
                else
                {
                    pDNS++;
                }
            }
            else
            {
                if (*pDNS == L'.')
                {
                    nCountPeriods++;
                }

                pDNS++;
                pCN++;
            }
        }

        return((*pDNS == 0) && (*pCN == 0) && ((nCountPeriods >= 2) || fExactMatch));
    }
    else
    {
        if (CSTR_EQUAL == CompareStringU(
                LOCALE_USER_DEFAULT,
                NORM_IGNORECASE,
                pDNS,
                -1,             // cchCount1
                pCN,
                -1              // cchCount2
                ))
            return TRUE;
        else
            return FALSE;
    }
}

BOOL IsSSLServerNameInNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pNameInfoBlob,
    IN LPCWSTR pwszServerName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRDN;
    PCERT_RDN pRDN;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pNameInfoBlob->pbData,
            pNameInfoBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
        for ( ; cAttr > 0; cAttr--, pAttr++) {
            if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                continue;
            if (0 == strcmp(pAttr->pszObjId, szOID_COMMON_NAME)) {
                if (CompareSSLDNStoCommonName(pwszServerName,
                        (LPCWSTR) pAttr->Value.pbData))
                    goto SuccessReturn;
            }
        }
    }

    goto ErrorReturn;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//
//  Returns:
//      1 - found a matching DNS_NAME choice
//      0 - AltName has DNS_NAME choices, no match
//     -1 - AltName doesn't have DNS_NAME choices
//
int IsSSLServerNameInAltName(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_DER_BLOB pAltNameBlob,
    IN LPCWSTR pwszServerName
    )
{
    int iResult = -1;           // default to no DNS_NAME choices
    PCERT_ALT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pAltNameBlob->pbData,
            pAltNameBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_DNS_NAME == pEntry->dwAltNameChoice) {
            if (CompareSSLDNStoCommonName(pwszServerName,
                    pEntry->pwszDNSName))
                goto SuccessReturn;
            else
                iResult = 0;
        }
    }

    goto ErrorReturn;

SuccessReturn:
    iResult = 1;
CommonReturn:
    PkiFree(pInfo);
    return iResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

BOOL IsSSLServerName(
    IN PCCERT_CONTEXT pCertContext,
    IN LPCWSTR pwszServerName
    )
{
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    DWORD dwCertEncodingType = pCertContext->dwCertEncodingType;
    PCERT_EXTENSION pExt;

    pExt = CertFindExtension(
        szOID_SUBJECT_ALT_NAME2,
        pCertInfo->cExtension,
        pCertInfo->rgExtension
        );

    if (NULL == pExt) {
        pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            );
    }

    if (pExt) {
        int iResult;
        iResult = IsSSLServerNameInAltName(dwCertEncodingType,
            &pExt->Value, pwszServerName);

        if (0 < iResult)
            return TRUE;
        else if (0 == iResult)
            return FALSE;
        // else
        //  AltName didn't have any DNS_NAME choices
    }

    return IsSSLServerNameInNameInfo(dwCertEncodingType,
                &pCertInfo->Subject, pwszServerName);
}


BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD fdwChecks;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    SSL_EXTRA_CERT_CHAIN_POLICY_PARA NullSSLExtraPara;
    PSSL_EXTRA_CERT_CHAIN_POLICY_PARA pSSLExtraPara;    // not allocated

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);


    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        pSSLExtraPara =
            (PSSL_EXTRA_CERT_CHAIN_POLICY_PARA) pPolicyPara->pvExtraPolicyPara;
        if (offsetof(SSL_EXTRA_CERT_CHAIN_POLICY_PARA, pwszServerName) >=
                pSSLExtraPara->cbSize) {
            SetLastError((DWORD) ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        pSSLExtraPara = &NullSSLExtraPara;
        memset(&NullSSLExtraPara, 0, sizeof(NullSSLExtraPara));
        NullSSLExtraPara.cbSize = sizeof(NullSSLExtraPara);
        NullSSLExtraPara.dwAuthType = AUTHTYPE_SERVER;
    }
        
    fdwChecks = pSSLExtraPara->fdwChecks;
    if (fdwChecks) {
        if (fdwChecks & SECURITY_FLAG_IGNORE_UNKNOWN_CA)
            // 11-Nov-98 per Sanjay Shenoy removed
            // CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
            dwFlags |= CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;

        if (fdwChecks & SECURITY_FLAG_IGNORE_WRONG_USAGE)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
        if (fdwChecks & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
        if (fdwChecks & SECURITY_FLAG_IGNORE_CERT_CN_INVALID)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG;
    }

    // Do the basic chain policy verification. SSL overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        // Map to errors understood by wininet
        switch (dwError) {
            case CERT_E_CHAINING:
                dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
                break;
            case CERT_E_INVALID_NAME:
                dwError = (DWORD) CERT_E_CN_NO_MATCH;
                break;
            case CERT_E_INVALID_POLICY:
                dwError = (DWORD) CERT_E_PURPOSE;
                break;
            case TRUST_E_BASIC_CONSTRAINTS:
                dwError = (DWORD) CERT_E_ROLE;
                break;
            default:
                break;
        }

        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        if (CRYPT_E_NO_REVOCATION_CHECK != dwError &&
                CRYPT_E_REVOCATION_OFFLINE != dwError)
            goto CommonReturn;
        // else
        //  for NO_REVOCATION or REVOCATION_OFFLINE let
        //  ServerName errors take precedence
    }
        

    // Note, this policy can also be used for LDAP ServerName strings. These
    // strings can have the following syntax:
    //   svc-class/host/service-name[@domain]
    //
    // Will parse the ServerName as follows:
    //   take everything after the last forward slash and before the "@"
    //   (if any).

    if (pSSLExtraPara->pwszServerName) {
        DWORD cbServerName;
        LPWSTR pwszServerName;              // _alloca'ed
        LPWSTR pwsz;
        WCHAR wc;

        cbServerName = (wcslen(pSSLExtraPara->pwszServerName) + 1) *
            sizeof(WCHAR);
        __try {
            pwszServerName = (LPWSTR) _alloca(cbServerName);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = (DWORD) E_OUTOFMEMORY;
            goto EndCertError;
        }
        memcpy(pwszServerName, pSSLExtraPara->pwszServerName, cbServerName);

        for (pwsz = pwszServerName; wc = *pwsz; pwsz++) {
            if (L'/' == wc)
                pwszServerName = pwsz + 1;
            else if (L'@' == wc) {
                *pwsz = L'\0';
                break;
            }
        }

        if (0 == (fdwChecks & SECURITY_FLAG_IGNORE_CERT_CN_INVALID)) {
            if (!IsSSLServerName(
                    pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
                    pwszServerName
                    )) {
                dwError = (DWORD) CERT_E_CN_NO_MATCH;
                goto EndCertError;
            }
        }
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    return TRUE;

EndCertError:
    lChainIndex = 0;
    lElementIndex = 0;
    goto CommonReturn;
}


//+=========================================================================
//  CertDllVerifyNTAuthCertificateChainPolicy Functions
//==========================================================================

// Open and cache the store containing CAs trusted for NT Authentication.
// Also, enable auto resync for the cached store.
HCERTSTORE OpenNTAuthStore()
{
    HCERTSTORE hStore;

    hStore = hNTAuthCertStore;
    if (NULL == hStore) {
        // Serialize opening of the cached store
        CertPolicyLock();

        hStore = hNTAuthCertStore;
        if (NULL == hStore) {
            hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                0,                  // dwEncodingType
                0,                  // hCryptProv
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                    CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                L"NTAuth"
                );
            if (hStore) {
                CertControlStore(
                    hStore,
                    0,                  // dwFlags
                    CERT_STORE_CTRL_AUTO_RESYNC,
                    NULL                // pvCtrlPara
                    );
                hNTAuthCertStore = hStore;
            }
        }

        CertPolicyUnlock();
    }

    return hStore;
}

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    DWORD dwError;
    LONG lChainIndex = 0;
    LONG lElementIndex = 0;
    PCERT_SIMPLE_CHAIN pChain;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    if (!CertDllVerifyBaseCertificateChainPolicy(
            pszPolicyOID,
            pChainContext,
            pPolicyPara,
            pPolicyStatus
            ))
        return FALSE;
    if (dwError = pPolicyStatus->dwError) {
        if (CRYPT_E_NO_REVOCATION_CHECK != dwError &&
                CRYPT_E_REVOCATION_OFFLINE != dwError)
            return TRUE;
        // else
        //  for NO_REVOCATION or REVOCATION_OFFLINE let
        //  following errors take precedence

        // Remember revocation indices
        lChainIndex = pPolicyStatus->lChainIndex;
        lElementIndex = pPolicyStatus->lElementIndex;
    }

    fResult = CertDllVerifyBasicConstraintsCertificateChainPolicy(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    if (!fResult || 0 != pPolicyStatus->dwError)
        return fResult;

    // Check if we have a CA certificate that issued the end entity
    // certificate. Its Element[1] in the first simple chain.
    pChain = pChainContext->rgpChain[0];
    if (2 > pChain->cElement)
        goto MissingCACert;

    if (IPR_IsNTAuthRequiredDisabled() &&
            (pChain->TrustStatus.dwInfoStatus &
                CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS)) {
        // If its not required that the issuing CA be in the NTAuth store
        // and there are valid name constraints for all name spaces including
        // UPN, then, we can skip the test for being in the NTAuth store.
        ;
    } else {
        PCCERT_CO