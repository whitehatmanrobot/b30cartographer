t time_t _FAR_ *);
struct tm _FAR_ * _FAR_ _cdecl localtime(const time_t _FAR_ *);
time_t _FAR_ _cdecl mktime(struct tm _FAR_ *);
size_t _FAR_ _cdecl strftime(char _FAR_ *, size_t, const char _FAR_ *,
	const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strdate(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strtime(char _FAR_ *);
time_t _FAR_ _cdecl time(time_t _FAR_ *);
void _FAR_ _cdecl tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the signal values and declares the signal functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */

/* signal types */
/* SIGINT, SIGFPE, SIGILL, SIGSEGV, and SIGABRT are recognized on DOS 3.x */

#define SIGINT		2	/* interrupt - corresponds to DOS 3.x int 23H */
#define SIGILL		4	/* illegal instruction - invalid function image */
#define SIGFPE		8	/* floating point exception */
#define SIGSEGV 	11	/* segment violation */
#define SIGTERM 	15	/* Software termination signal from kill */
#define SIGUSR1 	16	/* User defined signal 1 */
#define SIGUSR2 	17	/* User defined signal 2 */
#define SIGUSR3 	20	/* User defined signal 3 */
#define SIGBREAK	21	/* Ctrl-Break sequence */
#define SIGABRT 	22	/* abnormal termination triggered by abort call */


/* signal action codes */
/* SIG_DFL and SIG_IGN are recognized on DOS 3.x */

#define SIG_DFL (void (_FAR_ _cdecl _LOADDS_ *)())0	 /* default signal action */
#define SIG_IGN (void (_FAR_ _cdecl _LOADDS_ *)())1	 /* ignore */
#define SIG_SGE (void (_FAR_ _cdecl _LOADDS_ *)())3	 /* signal gets error */
#define SIG_ACK (void (_FAR_ _cdecl _LOADDS_ *)())4	 /* error if handler not setup */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (_FAR_ _cdecl _LOADDS_ *)())-1	 /* signal error value */


/* function prototypes */

void (_FAR_ _cdecl _LOADDS_ * _FAR_ _cdecl signal(int,
	void (_FAR_ _cdecl _LOADDS_ *)()))();
#ifndef _MT
int _FAR_ _cdecl raise(int);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structure used by the stat() and fstat()
*	routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define structure for returning status information */

#ifndef _STAT_DEFINED
struct stat {
	dev_t st_dev;
	ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	dev_t st_rdev;
	off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};
#define _STAT_DEFINED
#endif

#define S_IFMT		0170000 	/* file type mask */
#define S_IFDIR 	0040000 	/* directory */
#define S_IFCHR 	0020000 	/* character special */
#define S_IFREG 	0100000 	/* regular */
#define S_IREAD 	0000400 	/* read permission, owner */
#define S_IWRITE	0000200 	/* write permission, owner */
#define S_IEXEC 	0000100 	/* execute/search permission, owner */


/* function prototypes */

int _FAR_ _cdecl fstat(int, struct stat _FAR_ *);
int _FAR_ _cdecl stat(char _FAR_ *, struct stat _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines types used in defining values returned by system
*	level calls for file status and time information.
*	[System V]
*
****/

#ifndef _INO_T_DEFINED
typedef unsigned short ino_t;		/* i-node number (not used on DOS) */
#define _INO_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef short dev_t;			/* device code */
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long off_t;			/* file offset value */
#define _OFF_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\da\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#ifdef _MT
#define _NFILE	40
#else
#define _NFILE	20
#endif
#define EOF	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
	char _FAR_ *_ptr;
	int   _cnt;
	char _FAR_ *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *	+ 1 (in case P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 20
#define SYS_OPEN 20
#define TMP_MAX 32767


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifdef _DLL
extern FILE _FAR_ _cdecl _iob[];
#else
extern FILE _near _cdecl _iob[];
#endif
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#define stdaux (&_iob[3])
#define stdprn (&_iob[4])


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


/* function prototypes */

#ifndef _STDIO_DEFINED
int _FAR_ _cdecl _filbuf(FILE _FAR_ *);
int _FAR_ _cdecl _flsbuf(int, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _fsopen(const char _FAR_ *,
	const char _FAR_ *, int);
void _FAR_ _cdecl clearerr(FILE _FAR_ *);
int _FAR_ _cdecl fclose(FILE _FAR_ *);
int _FAR_ _cdecl fcloseall(void);
FILE _FAR_ * _FAR_ _cdecl fdopen(int, const char _FAR_ *);
int _FAR_ _cdecl feof(FILE _FAR_ *);
int _FAR_ _cdecl ferror(FILE _FAR_ *);
int _FAR_ _cdecl fflush(FILE _FAR_ *);
int _FAR_ _cdecl fgetc(FILE _FAR_ *);
int _FAR_ _cdecl fgetchar(void);
int _FAR_ _cdecl fgetpos(FILE _FAR_ *, fpos_t _FAR_ *);
char _FAR_ * _FAR_ _cdecl fgets(char _FAR_ *, int, FILE _FAR_ *);
int _FAR_ _cdecl fileno(FILE _FAR_ *);
int _FAR_ _cdecl flushall(void);
FILE _FAR_ * _FAR_ _cdecl fopen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl fprintf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fputc(int, FILE _FAR_ *);
int _FAR_ _cdecl fputchar(int);
int _FAR_ _cdecl fputs(const char _FAR_ *, FILE _FAR_ *);
size_t _FAR_ _cdecl fread(void _FAR_ *, size_t, size_t, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl freopen(const char _FAR_ *,
	const char _FAR_ *, FILE _FAR_ *);
int _FAR_ _cdecl fscanf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fsetpos(FILE _FAR_ *, const fpos_t _FAR_ *);
int _FAR_ _cdecl fseek(FILE _FAR_ *, long, int);
long _FAR_ _cdecl ftell(FILE _FAR_ *);
size_t _FAR_ _cdecl fwrite(const void _FAR_ *, size_t, size_t,
	FILE _FAR_ *);
int _FAR_ _cdecl getc(FILE _FAR_ *);
int _FAR_ _cdecl getchar(void);
char _FAR_ * _FAR_ _cdecl gets(char _FAR_ *);
int _FAR_ _cdecl getw(FILE _FAR_ *);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl _pclose(FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _popen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl printf(const char _FAR_ *, ...);
int _FAR_ _cdecl putc(int, FILE _FAR_ *);
int _FAR_ _cdecl putchar(int);
int _FAR_ _cdecl puts(const char _FAR_ *);
int _FAR_ _cdecl putw(int, FILE _FAR_ *);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
void _FAR_ _cdecl rewind(FILE _FAR_ *);
int _FAR_ _cdecl rmtmp(void);
int _FAR_ _cdecl scanf(const char _FAR_ *, ...);
void _FAR_ _cdecl setbuf(FILE _FAR_ *, char _FAR_ *);
int _FAR_ _cdecl setvbuf(FILE _FAR_ *, char _FAR_ *, int, size_t);
int _FAR_ _cdecl sprintf(char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl sscanf(const char _FAR_ *, const char _FAR_ *, ...);
char _FAR_ * _FAR_ _cdecl tempnam(char _FAR_ *, char _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl tmpfile(void);
char _FAR_ * _FAR_ _cdecl tmpnam(char _FAR_ *);
int _FAR_ _cdecl ungetc(int, FILE _FAR_ *);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl vfprintf(FILE _FAR_ *, const char _FAR_ *, va_list);
int _FAR_ _cdecl vprintf(const char _FAR_ *, va_list);
int _FAR_ _cdecl vsprintf(char _FAR_ *, const char _FAR_ *, va_list);
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define fileno(_stream)   ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)

#ifdef _MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
int _FAR_ _cdecl system(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\es\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\cs\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if
# the local code page is not Czech.

CFOPT=-DLCP -DCS

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\cs\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Pedchoz operan systm na jednotce C:";

CHAR DntBootIniLine[] = "Instalace nebo inovace systmu Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalace systmu Windows XP \n";
CHAR DntPersonalHeader[]      = "\n Instalace systmu Windows XP Home Edition\n";
CHAR DntWorkstationHeader[]   = "\n Instalace systmu Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Instalace systmu Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Analza parametr...";
CHAR DntEnterEqualsExit[]     = "ENTER=Konec";
CHAR DntEnterEqualsRetry[]    = "ENTER=Zkusit znovu";
CHAR DntEscEqualsSkipFile[]   = "ESC=Vynechat soubor";
CHAR DntEnterEqualsContinue[] = "ENTER=Pokraovat";
CHAR DntPressEnterToExit[]    = "Instalace neme pokraovat. Ukonete instalaci klvesou ENTER.";
CHAR DntF3EqualsExit[]        = "F3=Konec";
CHAR DntReadingInf[]          = "Nat se soubor INF %s...";
CHAR DntCopying[]             = " Kopruje se: ";
CHAR DntVerifying[]           = "  Ovuje se: ";
CHAR DntCheckingDiskSpace[]   = "Zjiovn msta na disku...";
CHAR DntConfiguringFloppy[]   = "Konfigurace diskety...";
CHAR DntWritingData[]         = "Zpis parametr instalanho programu...";
CHAR DntPreparingData[]       = "Zjiovn parametr instalanho programu...";
CHAR DntFlushingData[]        = "Zpis dat na disk...";
CHAR DntInspectingComputer[]  = "Analza potae...";
CHAR DntOpeningInfFile[]      = "Otevrn souboru INF...";
CHAR DntRemovingFile[]        = "Odstraovn souboru %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Odstranit soubory";
CHAR DntXEqualsSkipFile[]     = "X=Vynechat soubor";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Nainstaluje systm Windows 2002 Server nebo Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:zdrojov_cesta]] [/t[:doasn_jednotka]]",
    "      [/u[:soubor odpovd]] [/udf:id[,soubr_UDF]]",
    "      [/r:sloka] [/r[x]:sloka] [/e:pkaz] [/a]",
    "",
    "",
    "/s[:zdrojov_cesta]",
    "   Uruje umstn zdrojovch soubor systmu Windows.",
    "   Mus se zadat pln cesta ve tvaru x:[cesta]",
    "   nebo \\\\server\\sdlen[\\cesta].",
    "",
    "/t[:doasn_jednotka]",
    "   Uruje jednotku, na ni instalan program umst doasn instalan",
    "   soubory a na ni nainstaluje systm Windows.",
    "   Pokud nen zadna, instalan program se pokus vyhledat jednotku sm.",
    "",
    "/u[:soubor odpovd]",
    "   Provede bezobslunou instalaci pomoc souboru odpovd (vyaduje",
    "   pepna /s). Soubor odpovd obsahuje odpovdi na nkter nebo",
    "   vechny dotazy, na nا uivatel obvykle odpovd bhem instalace.",
    "",
    "/udf:id[,soubor_UDF]   ",
    "   Identifiktor  (id) uruje, jakm zpsobem modifikuje soubor UDF ",
    "   (Uniqueness Database File) soubor odpovd  ",
    "   (viz pepna /u). Parametr /udf pedefinuje hodnoty v souboru ",
    "   odpovd a tento indentifiktor uruje, kter hodnoty v souboru UDF",
    "   budou pouity. Pokud soubor UDF nen zadn, instalan program ",
    "   vs vyzve ke vloen diskety obsahujc soubor $Unique$.udb.",
    "",
    "/r[:sloka]",
    "   Uruje volitelnou sloku, kter m bt nainstalovna. Sloka",
    "   po dokonen instalace zstane v pvodnm umstn.",
    "",
    "/rx[:sloka]",
    "   Uruje volitelnou sloku, kter m bt zkoprovna. Sloka bude ",
    "   po dokonen instalace odstranna.",
    "",
    "/e   Uruje pkaz ke sputn po dokonen grafick sti instalace.",
    "",
    "/a   Zapne monosti usnadnn.",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Nainstaluje systm Windows XP.",
    "",
    "WINNT [/S[:]zdroj_cesta] [/T[:]do_jednotka] [/I[:]soubor_INF]",
    "      [/U[:soubor_skriptu]]",
    "      [/R[X]:adres] [/E:pkaz] [/A]",
    "",
    "/D[:]koen_winnt",
    "       Tato monost ji nen podporovna.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Instalan program nem dost pamti a neme pokraovat.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Zvolte, zda chcete nainstalovat nsledujc funkce usnadnn:",
    DntEmptyString,
    "[ ] Chcete-li nainstalovat program Lupa, stisknte F1",
#ifdef NARRATOR
    "[ ] Chcete-li nainstalovat program Pedtn obrazovky, stisknte F2",
#endif
#if 0
    "[ ] Chcete-li nainstalovat program Klvesnice na obrazovce, stisknte F3",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Instalan program mus znt umstn soubor systmu Windows XP.",
  "Zadejte cestu k umstn soubor systmu Windows XP.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Zadan zdroj nen platn i pstupn, nebo neobsahuje platnou",
                   "instalaci systmu Windows XP. Zadejte novou cestu, kde se soubory",
                   "systmu Windows XP nalzaj. Pomoc klvesy BACKSPACE vymate znaky",
                   "a zadejte novou cestu.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Instalan program nemohl nast dan informan soubor, nebo",
                " je informan soubor pokozen. Obrate se na sprvce systmu.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//


SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Zadan jednotka pro doasn instalan soubory nen platn, nebo neobsahuje",
  "alespo %u megabajt (%lu bajt) volnho msta.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Systm Windows XP potebuje svazek diskov jednotky s nejmn %u megabajty",
   "(%lu bajty) volnho msta. Instalan program vyuije st tohoto",
   "prostoru k ukldn doasnch soubor bhem instalace. Dan jednotka",
   "mus bt na trvale pipojenm pevnm disku, kter je podporovn,",
   "systmem Windows XP a jednotka nesm bt komprimovna.",
   DntEmptyString,
   "Instalan program nemohl najt dnou jednotku s poadovanm volnm",
   "prostorem.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Na danm spoutcm disku (obvykle C:) nen dost prostoru pro",
  "instalaci bez disket. Instalace bez disket vyaduje nejmn",
  "3,5 MB (3,641,856 bajt) volnho msta na dan jednotce.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Sekce [%s] informanho souboru instalanho programu chyb",
                       "nebo je pokozena. Obrate se na sprvce systmu.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Na zadan clov jednotce se nepodailo vytvoit adres:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Zkontrolujte clovou jednotku, zda neobsahuje soubory s nzvy, kter",
                       "se shoduj s clovm adresem. Zkontrolujte tak kabely dan jednotky.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Instalan program nemohl zkoprovat soubor:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy ESC bude chyba ignorovna a instalace bude pokraovat.",
   "  Stisknutm klvesy F3 ukonte instalaci.",
   DntEmptyString,
   "Poznmka: Pokud budete chybu ignorovat a pokraovat, mete se setkat",
   "          s chybami i pozdji.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Kopie uvedenho souboru vytvoen instalanm programem, nen shodn",
   "s originlem. To me bt zpsobeno chybami st, disketov jednotky,",
   "nebo jinmi hardwarovmi problmy.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy ESC bude chyba ignorovna a instalace bude pokraovat.",
   "  Stisknutm klvesy F3 ukonte instalaci.",
   DntEmptyString,
   "Poznmka: Pokud budete chybu ignorovat a pokraovat, mete se setkat",
   "s chybami i pozdji.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Pokud budete chybu ignorovat, nebude soubor zkoprovn.",
   "Tato volba je urena zkuenm uivatelm, kte rozum",
   "nsledkm chybjcch systmovch soubor.",
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy X tento soubor peskote.",
   DntEmptyString,
   "Poznmka: Pokud soubor vynechte, neme instalan program zaruit",
   "spnou instalaci nebo inovaci systmu Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Pokejte, ne budou odstranny pedchoz doasn soubory.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Pokejte, ne budou zkoprovny soubory na pevn disk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Pokejte, ne budou zkoprovny soubory na disketu.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Instalace vyaduje tyi przdn naformtovan diskety (vysok hustota).",
   "Tyto diskety budou instalanm programem oznaovny jako \"Spoutc disk",
   "instalace systmu Windows XP\", \"Disk .2 instalace systmu Windows XP\"",
   "\"Disk .3 instalace systmu Windows XP\" a",
   "\"Disk .4 instalace systmu Windows XP\".",
   DntEmptyString,
   "Vlote jednu z tchto ty disket do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .3 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .2 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Spoutc disk instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Instalace vyaduje tyi przdn naformtovan diskety (vysok hustota).",
   "Tyto diskety budou instalanm programem oznaovny jako \"Sputc disk",
   "instalace systmu Windows XP\", \"Disk .2 instalace systmu Windows XP\",",
   "\"Disk .3 instalace systmu Windows XP\" a \"Disk .4 instalace",
   "systmu Windows XP\".",
   DntEmptyString,
   "Vlote jednu z tchto ty disket do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .3 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .2 instalace systmu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Spoutc disk instalace systmu Windows XP\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Vloen disketa nen naformtovan pro pouit v systmu MS-DOS.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Vloen disketa nen naformtovan na standardn formt systmu MS-DOS",
  "(vysok hustota) nebo je pokozen. Instalan program neme disketu pout.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Instalan program neme urit velikost volnho msta na disket.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Vloen disketa neumouje vysokou hustotu zznamu, nebo nen przdn.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Instalan program nemohl zapisovat do systmov oblasti vloen diskety.",
  "Disketa je pravdpodobn nepouiteln.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).

//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Data naten ze systmov oblasti diskety neodpovdaj dve zapsanm",
  "informacm, nebo se instalanmu program data nepodailo nast",
  "a ovit.",
  DntEmptyString,
  "To je zpsobeno jednou nebo vce z nsledujch okolnost:",
  DntEmptyString,
  "  Pota byl infikovn potaovm virem.",
  "  Vloen disketa je pokozen.",
  "  Na disketov jednotce jsou pote s hardwarem nebo konfigurac.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Instalanmu programu se nepodail zpis na disketu v jednotce A:. Vloen",
  "disketa me bt pokozena. Zkuste pout jinou disketu.",
  NULL
}
};



//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Systm Windows XP nen na potai zcela          ",
                    "  nainstalovn. Ukonte-li nyn instalaci, budete  ",
                    "  ji muset spustit znovu, aby bylsystm             ",
                    "  Windows XP nainstalovn.                          ",
                    "                                                    ",
                    " Stisknutm klvesy ENTER bude instalace pokraovat.",
                    " Stisknutm klvesy F3 instalaci ukonte.          ",
                    "ĺ",
                    "  F3=Konec  ENTER=Pokraovat                        ",
                    "ͼ",
                    NULL
                  }
                };



//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Instalan program bude restartovat pota. Po novm sputn",
  "bude instalace systmu Windows XP pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu Windows\" ",
  "vloen do jednotky A: ped restartovnm.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Instalan program dokonil st instalace v prosted systmu MS-DOS.",
  "Instalan program nyn restartuje pota. Po novm sputn",
  "bude instalace systmu Windows XP pokraovat.",
  DntEmptyString,                       
  "Zajistte, aby byl \"Spoutc disk instalace systmu Windows XP\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Instalan program nyn restartuje pota. Po novm sputn",
  "bude instalace systmu Windows XP pokraovat.",
  DntEmptyString,
  "Pokud je v jednotce A: vloena disketa, vyjmte ji.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude instalace systmu Windows XP pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu Windows XP\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm ENTER se vrtte do systmu MS-DOS. Pak restartujte pota,",
  "aby mohla instalace systmu Windows XP pokraovat.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude instalace systmu Windows XP pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu Windows XP\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm ENTER se vrtte do systmu MS-DOS. Pak restartujte pota,",
  "aby mohla instalace systmu Windows XP pokraovat.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude intstalace systmu Windows XP pokraovat.",
  DntEmptyString,
  "Pokud je v jednotce A: vloena disketa, vyjmte ji.",
  DntEmptyString,
  "Stisknutm klvesy ENTER se vrtte do systmu MS-DOS. Pak restartujte",
  "pota, aby mohla instalace systmu Windows XP pokraovat.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Probh koprovn soubor:                                    ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Tento program vyaduje ke sputn systm MS-DOS, verzi 5.0 nebo vy.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Instalan program zjistil, e disketov jednotka A: neexistuje, nebo",
  "podporuje pouze nzkou hustotu. Ke sputn instalace je poadovna",
  "jednotka s kapacitou 1,2 MB nebo vy.",
#else
{ "Instalan program zjistil, e disketov jednotka A: neexistuje, nebo",
  "se nejedn o jednotku 3,5\" s vysokou hustotou. K proveden instalace ",
  " s disketami je poadovna jednotka s kapacitou 1,44 MB nebo vy.",
  DntEmptyString,
  "K instalaci systmu Windows XP bez pouit disket muste spustit tento",
  "program znovu a zadat na pkazov dce parametr /b.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Instalan program zjistil, e tento pota neobsahuje procesor 80486",
  "nebo vy. Na takovm potai nelze systm Windows XP spustit.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Tento program nelze spustit v 32bitov verzi systmu Windows.",
  DntEmptyString,
  "Pouijte program winnt32.exe.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Instalan program zjistil, e v potai nen dost instalovan pamti",
  "ke sputn systmu Windows XP.",
  DntEmptyString,
  "Poadovan pam؜: %lu%s MB",
  "Rozpoznan pam؜: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "dte instalan program, aby odstranil soubory systmu Windows XP",
    "z uvedenho adrese. Instalace systmu Windows v uvedenm",
    "adresi bude trvale zniena.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Stisknutm F3 instalaci ukonte, ani by byl odstrann jakkoli soubor.",
    "  Stisknutm X soubory systmu Windows odstrante z ve uvedenho adrese.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Nepodailo se otevt uveden soubor s protokolem o instalaci.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Ze zadanho adrese nen mon odstranit soubory systmu Windows.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "V uvedenm souboru s protokolem o instalaci se nepodailo najt",
  "sekci %s.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Ze zadanho adrese nen mon odstranit soubory systmu Windows.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vykejte prosm, probh odstraovn soubor systmu Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Nepodailo se nainstalovat sputc zavad؟ systmu Windows.",
  DntEmptyString,
  "Ujistte se, e jednotka C: je naformtovan a e nen pokozen.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Soubor skriptu, kter byl zadn na pkazovm dku pomoc pepnae /u,",
  "se nepodailo otevt.",
  DntEmptyString,
  "Bezobslun instalace neme pokraovat.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Soubor skriptu, kter byl zadn na pkazovm dku pomoc pepnae /u,",
  DntEmptyString,

  "%s",
  DntEmptyString,
  "obsahuje chybu syntaxe na dku %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Dolo k vnitn chyb instalanho programu.",
  DntEmptyString,
  "Peloen zprvy pi zavdn jsou pli dlouh.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Dolo k intern chyb instalace.",
  DntEmptyString,
  "Nepodailo se najt msto pro uloen strnkovacho souboru.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "V potai se nepodailo najt program SmartDrive. Program SmartDrive",
  "vrazn urychluje tuto st instalace systmu Windows.",
  DntEmptyString,
  "Mli byste ukonit instalaci, spustit program SmartDrive a pot instalaci",
  "znovu spustit.",
  "Podrobnosti o programu SmartDrive naleznete v dokumentaci k systmu MS-DOS.",
  DntEmptyString,
    "  Stisknutm klvesy F3 instalaci ukonte.",
    "  Stisknutm klvesy ENTER mete pokraovat bez programu SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR nenalezen";
CHAR BootMsgDiskError[] = "Chyba disku";
CHAR BootMsgPressKey[] = "Restartujte libovolnou klvesou";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\da\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Tidligere operativsystem p C:";

CHAR DntBootIniLine[] = "Windows XP Installation/Opgradering";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP Installation\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Home Edition Installation\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional Installation\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server Installation\n";
CHAR DntParsingArgs[]         = "Gennemsger argumenter...";
CHAR DntEnterEqualsExit[]     = "ENTER=Afslut";
CHAR DntEnterEqualsRetry[]    = "ENTER=Forsg igen";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignorer fil";
CHAR DntEnterEqualsContinue[] = "ENTER=Fortst";
CHAR DntPressEnterToExit[]    = "Installation kan ikke fortstte. Tryk p ENTER for at afslutte.";
CHAR DntF3EqualsExit[]        = "F3=Afslut";
CHAR DntReadingInf[]          = "Lser INF-file %s...";
CHAR DntCopying[]             = "    Kopierer: ";
CHAR DntVerifying[]           = " Verificerer: ";
CHAR DntCheckingDiskSpace[]   = "Kontrollerer plads p harddisken...";
CHAR DntConfiguringFloppy[]   = "Konfigurerer diskette...";
CHAR DntWritingData[]         = "Skriver installationsparametre...";
CHAR DntPreparingData[]       = "Kontrollerer installationsparametre...";
CHAR DntFlushingData[]        = "Flytter data til harddisken...";
CHAR DntInspectingComputer[]  = "Kontrollerer computeren...";
CHAR DntOpeningInfFile[]      = "bner INF-fil...";
CHAR DntRemovingFile[]        = "Fjerner filen %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Fjern filer";
CHAR DntXEqualsSkipFile[]     = "X=Ignorer fil";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installerer Windows 2002 Server eller Windows XP Professional.",
    "",
    "",
    "WINNT [/S[:kildesti]] [/T[:midlertidigt drev]]",
    "      [/U[:svarfil]] [/UDF:id[,UDF_file]]",
    "      [/R:mappe] [/R[X]:mappe] [/e:kommando] [/A]",
    "",
    "",
    "/S[:kildesti]",
    "       Angiver placeringen af Windows-filerne.",
    "       Det skal vre en komplet sti i form af x:[sti] eller",
    "       \\\\server\\share[sti].",
    "       Standardvrdien er den aktuelle mappe.",
    "",
    "/T[:midlertidigt drev]",
    "       Angiver et drev til at lgge midlertidige installationsfiler og",
    "       hvor Windows XP skal installeres. Hvis det ikke er angivet,", 
    "       vil installationsprogrammet selv lede efter et drev.",
    "",
    "/U[:svarfil]",
    "       Udfrer en automatiseret installation vha. en svarfil (krver",
    "       /s). Svarfilen besvarer nogle eller alle installations-",
    "       sprgsml, som brugeren normalt svarer p under installationen",
    "",
    "/UDF:id[,UDF_file] ",
    "       Angiver en identifikator (id), som Installation bruger til ",
    "       at specificer, hvordan en UDF-databasefil ndrer en svarfil",
    "       (se /u). Parameteren /UDF springer vrdierne i svarfilen ",
    "       over, og identifikatoren bestemmer hvilke vrdier i  UDF-",
    "       filen der skal anvendes. Hvis der ikke angives en UDF-fil,",
    "       bliver du bedt om at indstte en diskette med filen $Unique$.udb.",
    "",
    "/R[:mappe]",
    "       Angiver en valgfri mappe, der skal installeres. Mappen",
    "       bevares efter at installationen er afsluttet.",
    "/Rx[:mappe]",
    "       Angiver en valgfri mappe, der skal kopieres. Mappen",
    "       slettes, nr installationen er afsluttet.",
    "",
    "/E     Angiver en kommando, der skal kres efter GUI-delen af installationen.",
    "",
    "/A     Aktiverer Hjlp til handicappede.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installerer Windows XP.",
    "",
    "WINNT [/S[:]kildesti] [/T[:]midlertidigt drev] [/I[:]inf-fil]",
    "      [/U[:scriptfil]]",
    "      [/R[X]:mappe] [/E:kommando] [/A]",
    "",
    "/D[:]winnt-rodmappe",
    "       Denne indstilling findes ikke lngere.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
		   { "Installation har ikke mere hukommelse og kan ikke fortstte.",
		     NULL
		   }
		 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Vlg hvilke Hjlp til handicappede-faciliteter, der skal installeres:",
    DntEmptyString,
    "[ ] Tryk p F1 for Microsoft Forstrrelsesglas",
#ifdef NARRATOR
    "[ ] Tryk p F2 for Microsoft Oplser",
#endif
#if 0
    "[ ] Tryk p F3 for Microsoft Skrmtastatur",
#endif
    NULL

}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Installationsprogrammet skal vide, hvor Windows XP-filerne er placeret.",
  "Angiv stien, hvor Windows XP-filerne er placeret.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
		 { "Den angivne kilde er ikke gyldig, ikke til rdighed, eller indeholder ikke en",
                   "gyldig Windows XP Installation. Angiv en ny sti, hvor Windows XP-",
		   "filerne kan findes. Brug TILBAGE for at slette tegn, og",
		   "skriv stien.",
		   NULL
		 }
	       };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
	      { "Installation kunne ikke lse informationsfilen, eller informationsfilen",
		"er beskadiget. Kontakt systemadministratoren.",
		NULL
	      }
	    };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{  "Drevet til de midlertidige filer er ikke et gyldigt drev",
   "eller det har ikke mindst %u MB (%lu byte) plads",
   "til rdighed.",
   NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{ "Windows XP krver en harddisk med mindst %u MB",
  "(%lu byte) plads til rdighed. Installation bruger en del af denne",
  "plads til at gemme midlertidige filer under installationen. Drevet",
  "skal vre en permanent, lokal harddisk, som kan anvendes af Windows XP,",
  "og det m ikke vre komprimeret.",
  DntEmptyString,
  "Installation kunne ikke finde et drev med den krvede mngde plads",
  "til rdighed.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Der er ikke tilstrkkelig hukommelse p startdrevet (sdvanligvis C:)",
  "til en installation uden disketter. En installation uden disketter krver mindst",
  "3,5 MB (3.641.856 byte) ledig plads p drevet.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
		     { "Afsnittet [%s] i installationsoplysningsfilen",
		       "mangler eller er beskadiget. Kontakt systemadministratoren.",
		       NULL
		     }
		   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
		     { "Installation kunne ikke oprette denne mappe p destinationsdrevet:",
		       DntEmptyString,
		       "%s",
		       DntEmptyString,
		       "Kontroller, at der ikke er andre filer eller mapper, der har samme navn",
		       "og derved skaber en konflikt. Kontroller ogs, at kablerne til drevet er korrekt monteret.",
		       NULL
		     }
		   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Installation kunne ikke kopiere nedenstende fil:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryk p ENTER for at kopiere igen.",
   "  Tryk p ESC for at ignorere fejlen og fortstte Installation.",
   "  Tryk p F3 for at afbryde Installation.",
   DntEmptyString,
   "Bemrk! Hvis du vlger at ignorere fejlen, kan der opst problemer senere",
   "under installationen.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Den kopi, Installation har lavet af filen nedenfor, er ikke identisk med",
   "originalen. Det kan skyldes netvrksfejl, diskettefejl eller andre ",
   "hardwarebetingede problemer.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryk p ENTER for at prve at kopiere igen.",
   "  Tryk p ESC for at ignorere fejlen og fortstte Installation.",
   "  Tryk p F3 for at afbryde Installation.",
   DntEmptyString,
   "Bemrk! Hvis du vlger at ignorere fejlen, kan der opst problemer senere",
   "under installationen.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Hvis denne fejl ignoreres, vil filen ikke blive kopieret.",
   "Dette alternativ er for erfarne brugere, som forstr",
   "konsekvenserne af manglende systemfiler.",
   DntEmptyString,
   "  Tryk p ENTER for at kopiere igen.",
   "  Tryk p X for at springe filen over.",
   DntEmptyString,
   "Bemrk! Hvis filen springes over, kan installationsprogrammet ikke",
   "garantere en vellykket installation eller opgradering af Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
	{ "Vent, mens Installation fjerner tidligere midlertidige filer.",
	   NULL
	}
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
		   { "Vent, mens Installation kopierer filer til harddisken.",
		     NULL
		   }
		 },
DnsWaitCopyFlop= { 13,6,
		   { "Vent, mens Installation kopierer filer til disketten.",
		     NULL
		   }
		 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Installation skal bruge fire formaterede, tomme high-density disketter.",
   "Installation vil referere til disse disketter som \"Windows XP Installation",
   "Startdiskette,\" \"Windows XP Installationsdiskette 2,\" \"Windows XP",
   " Installationsdiskette 3\" og \"Windows XP Installationsdiskette 4.\"",
   DntEmptyString,
   "Indst en af de fire disketter i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 3.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 2.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Startdiskette.\"",
     NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Installation skal bruge fire formaterede, tomme high-density disketter",
   "Installation vil referere til disse disketter som \"Windows XP Installation",
   "Startdiskette,\" \"Windows XP Installationsdiskette 2,\" \"Windows XP",
   "Installationsdiskette 3\" og \"Windows XP Installationsdiskette 4\"",
   DntEmptyString,
   "Inds't en af de fire disketter i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives \"Windows XP Installationsdiskette 3.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives\"Windows XP Installationsdiskette 2.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Indst en formateret, tom high-density diskette i drev A:.",
   "Denne diskette navngives\"Windows XP Startdiskette.\"",
  NULL
}
};


//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Disketten er ikke formateret til brug for MS-DOS.",
  "Installation kan ikke bruge denne diskette.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Disketten er enten ikke formateret som high density, ikke formateret med",
  "et standard MS-DOS-format eller er beskadiget. Disketten kan ikke bruges.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Installation kan ikke bestemme mngden af plads til rdighed p disketten.",
  "Installation kan ikke bruge denne diskette.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Disketten er enten ikke tom eller ikke high density.",
  "Installation kan ikke bruge denne diskette.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Installation kunne ikke skrive til systemomrdet p disketten.",
  "Disketten er sandsynligvis ubrugelig.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Dataene, Installation lste fra systemomrdet p disketten,",
  "passer ikke med de data, der blev skrevet, eller Installation",
  "kunne ikke lse systemomrdet af disketten under verificering.",
  DntEmptyString,
  "Dette skyldes en eller flere af nedenstende rsager:",
  DntEmptyString,
  "  Computeren er blevet inficeret med virus.",
  "  Disketten er beskadiget.",
  "  Der er problemer med konfigurationen af hardwaren i diskettedrevet.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Installation kunne ikke skrive p disketten i drev A:.",
  "Disketten er mske beskadiget. Prv med en anden diskette",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
		  { "ͻ",
                    "  Windows XP er ikke frdiginstalleret.               ",
		    "  Du skal starte Installation igen for                ",
                    "  at installere Windows XP, hvis du afbryder          ",
		    "  installationsprogrammet nu.                         ",
		    "                                                      ",
		    "   Tryk p ENTER for at fortstte installationen.    ",
		    "   Tryk p F3 for at afbryde installationen.         ",
		    "ĺ",
		    "  F3=Afbryd  ENTER=Fortst                            ",
		    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//
SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet. Installation vil",
  "nu genstarte computeren. Nr computeren genstarter, fortstter",
  "Windows XP Installation.",
  DntEmptyString,
  "Kontroller, at disketten \"Windows XP Startdiskette\" er i drev A:",
  "inden du fortstter.",
  DntEmptyString,
  "Tryk p ENTER for at genstarte computeren og fortstte",
  "Windows XP Installation.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet. Installation vil",
  "nu genstarte computeren. Nr computeren genstarter, fortstter",
  "Windows XP Installation.",
  DntEmptyString,
  "Kontroller, at disketten \"Windows XP Startdiskette\" er i drev A:",
  "inden du fortstter.",
  DntEmptyString,
  "Tryk p ENTER for at genstarte computeren og fortstte",
  "Windows XP Installation.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet. Installation vil",
  "nu genstarte computeren. Nr computeren genstarter, fortstter",
  "Windows XP Installation.",
  DntEmptyString,
  "Hvis der er en diskette i drev A:, skal den fjernes nu.",
  DntEmptyString,
  "Tryk p ENTER for at genstarte computeren og fortstte",
  "Windows XP Installation.",
  NULL
}
};
//
// Need another set for '/w' switch since we can't reboot from within Windows.
//
SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet.",
  "Du skal nu genstarte computeren. Nr computeren er genstartet,",
  "vil Windows XP Installation fortstte.",
  DntEmptyString,
  "Kontroller, at disketten \"Windows XP",
  "Startdiskette\" er indsat i drev A: inden du fortstter.",
  DntEmptyString,
  "Tryk p ENTER for at vende tilbage til MS-DOS. Genstart herefter computeren",
  "for at fortstte Windows XP Installation.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet.",
  "Du skal nu genstarte computeren. Nr computeren er genstartet,",
  "vil Windows XP Installation fortstte.",
  DntEmptyString,
  "Kontroller, at disketten \"Windows XP",
  "Startdiskette\" er indsat i drev A:, inden du fortstter.",
  DntEmptyString,
  "Tryk p ENTER for at vende tilbage til MS-DOS. Genstart herefter computeren",
  "for at fortstte Windows XP Installation.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Den MS-DOS-baserede del af Installation er afsluttet.",
  "Du skal nu genstarte computeren. Nr computeren er genstartet,",
  "vil Windows XP Installation fortstte.",
  DntEmptyString,
  "Hvis der er en diskette i drev A:, skal den fjernes nu.",
  DntEmptyString,
  "Tryk p ENTER for at vende tilbage til MS-DOS. Genstart herefter computeren",
  "for at fortstte Windows XP Installation.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
	     { "ͻ",
	       " Installation kopierer filer...                                 ",
	       "                                                                ",
	       "      Ŀ      ",
	       "                                                              ",
	       "            ",
	       "ͼ",
	       NULL
	     }
	   };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Dette program krver MS-DOS version 5.0 eller nyere for at kunne kre.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Installation har fundet frem til, at diskettedrevet A: mangler eller er",
  "et low-density drev. Der skal bruges et drev med 1,2 MB eller mere",
  "for at afvikle Installation.",
#else
{ "Installation har fundet frem til, at diskettedrevet A: mangler eller",
  "ikke er et 3,5\" drev. Der skal bruges et drev med 1,44 MB eller mere",
  "for at afvikle Installation med disketter.",
  DntEmptyString,
  "For at installere Windows XP uden brug af disketter skal du genstarte",
  "dette program og angive /b p kommandolinjen.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Installation har fundet frem til, at computeren ikke indeholder en 80486",
  "eller nyere CPU. Windows XP kan ikke kre p denne computer.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dette program kan ikke kres p en 32-bit version af Windows.",
  DntEmptyString,
  "Brug winnt32.exe i stedet for.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Installation har fundet frem til, computeren ikke har nok hukommelse",
  "til Windows XP.",
  DntEmptyString,
  "Hukommelse krvet: %lu%s MB",
  "Hukommelse fundet: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Installation blev bedt om at fjerne Windows XP-filerne fra mappen",
    "nedenfor. Windows-installationen i denne mappe vil blive",
    "fjernet permanent.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Tryk p F3 for at afslutte Installation uden at fjerne filer.",
    "  Tryk p X for at fjerne Windows-filerne fra mappen.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Installation kunne ikke bne installationslogfilen nedenfor.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Installation kan ikke fjerne Windows-filerne fra den angivne mappe.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Installation kan ikke finde afsnittet %s i installationslogfilen",
  "nedenfor.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Installation kan ikke fjerne Windows-filerne fra den angivne mappe.",
  NULL
}
},
DnsRemovingNtFiles = { 3,5,
{ "           Vent, mens Installation fjerner Windows-filerne.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Installation kunne ikke installere Windows Boot-indlser.",
  DntEmptyString,
  "Kontroller, at drev C: er formateret, og at drevet ikke er",
  "beskadiget.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Script-filen angivet med kommandolinjeparameteren /u",
  "var ikke tilgngelig",
  DntEmptyString,
  "Automatisk installation kan ikke fortstte.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Script-filen angivet med kommandolinjeparameteren /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "indeholder en syntaksfejl i linje %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Der er opstet en intern installationsfejl.",
  DntEmptyString,
  "De oversatte startbeskeder er for lange.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "Could not find a place for a swap file.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Installation fandt ikke SmartDrive on your computer. SmartDrive kan",
  "forbedre ydelsen betydeligt under denne del af Windows-installationen.",
  DntEmptyString,
  "Du br afslutte nu, starte SmartDrive og derefter genstarte Installation.",
  "Se i din dokumentation til DOS for at f flere oplysninger om SmartDrive.",
  DntEmptyString,
  " Tryk p F3 for at slutte installationen.",
  " Tryk p ENTER for at fortstte uden SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR mangler";
CHAR BootMsgDiskError[] = "Diskfejl";
CHAR BootMsgPressKey[] = "Tryk p en tast for genstart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\fi\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\el\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "磜  穫  C:";

CHAR DntBootIniLine[] = "ᩫ/៣  Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n ᩫ  Windows XP\n";
CHAR DntPersonalHeader[]      = "\n ᩫ  Windows XP Personal\n";
CHAR DntWorkstationHeader[]   = "\n ᩫ  Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n ᩫ  Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "᢬ ⫨...";
CHAR DntEnterEqualsExit[]     = "ENTER=륦";
CHAR DntEnterEqualsRetry[]    = "ENTER=ᢞ";
CHAR DntEscEqualsSkipFile[]   = "ESC=ᢜ 妬";
CHAR DntEnterEqualsContinue[] = "ENTER=⮜";
CHAR DntPressEnterToExit[]    = " ᩫ  夘   婜. ⩫ ENTER  ⥦.";
CHAR DntF3EqualsExit[]        = "F3=륦";
CHAR DntReadingInf[]          = "ᚤਫ਼  妬 INF %s...";
CHAR DntCopying[]             = ": ";
CHAR DntVerifying[]           = "㟜: ";
CHAR DntCheckingDiskSpace[]   = "뢜 騦  婡...";
CHAR DntConfiguringFloppy[]   = "樭ਫ਼ ⫘...";
CHAR DntWritingData[]         = " ⫨ 垩...";
CHAR DntPreparingData[]       = " ⫨ 垩...";
CHAR DntFlushingData[]        = "ਫ਼   婡...";
CHAR DntInspectingComputer[]  = "᢬ ...";
CHAR DntOpeningInfFile[]      = "ꤦ 妬 INF...";
CHAR DntRemovingFile[]        = "ᨚ 妬 %s";
CHAR DntXEqualsRemoveFiles[]  = "X=ᨚ 妬";
CHAR DntXEqualsSkipFile[]     = "X=ᢜ 妬";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "  Windows 2002 Server   Windows XP Professional.",
    "",
    "",
    "WINNT [/s[: ⢜]] [/t[:ᛘ]]",
    "	   [/u[: 桨]] [/udf:id[,UDF_]]",
    "	   [/r:ᡜ] [/r[x]:ᡜ] [/e:] [/a]",
    "",
    "",
    "/s[: ⢜]",
    "   坜  ⩞ ⢜    Windows.",
    "    ⩞ ⧜  夘  㨞   礫 x:\\[]  ",
    "	\\\\\\殨[\\].",
    "",
    "/t[:ᛘ]",
    "     暨 ᩫ  ⫞  ਠ   ⤞",
    "   ᛘ  ᩫ  Windows XP    ᛘ.     ⩞",
    "    暨 ᩫ  㩜    ᛘ.",
    "",
    "/u[: 桨]",
    "     暨 ᩫ  矞  㩞  妬 桨",
    "   (嫘 /s).   桨 ⮜ 㩜  ᧦  梜  㩜",
    "    圪 ᢢ   㩫   ᨡ  ᩫ.",
    "",
    "/udf:id[,UDF_]	",
    "   眠 ⤘ ਠ (id)     暨",
    "   ᩫ   婜  ⤘  UDF (Uniqueness Database",
    "   File)  ⤘  桨 (嫜 /u).  ᣜ /udf",
    "	     桨   ਠ",
    "   坜    妬 UDF 礫.  ",
    "     UDF,  暨 ᩫ    ",
    "   㩜  ⫘    ⮜   $Unique$.udb.",   
    "",
    "/r[:ᡜ]",
    "	坜 ⤘  ᡜ  ᩫ. ",
    "	ᡜ ⤜   ⢦  ᣣ ᩫ.",
    "",
    "/rx[:ᡜ]",
    "	坜 ⤘  ᡜ  ᩫ.  ᡜ",
    "	嫘   ⢦  ᣣ ᩫ.",
    "",
    "/e 坜    ⢜    㣘  ",
    "   ᣣ ᩫ.",
    "",
    "/a	    ᫦   ᚡ.",
     NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "  Windows XP.",
    "",
    "WINNT [/S[:]㧨⢜] [/T[:]ᛘ] [/I[:]INF]",
    "      [/O[X]] [/X | [/F] [/C]] [/B] [/U[:妛⩣]]",
    "      [/R[X]:ᢦ] [/E:] [/A]",
    "",
    "/D[:]winntroot",
    "           坜 .",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { " 㣞     暨 ᩫ  夘   婜.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "     ᩫ:",
    DntEmptyString,
    "[ ] ⩫ F1      Microsoft",
#ifdef NARRATOR
    "[ ] ⩫ F2     Microsoft",
#endif
#if 0
    "[ ] ⩫ F3   暠 椞  Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ " 暨 ᩫ ᝜  ⩞    Windows XP.",
  "᚜    ⩞ 槦 婡    Windows XP.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { " ⤞ ⢜  夘 ⚡,  夘 ᩠   ⮜",
                   " ⚡ ᩫ  Windows XP. ᚜    ⩞  ",
                   "⧜  婡    Windows XP. 㩫  㡫 BACKSPACE",
                   "  ᯜ  㨜  㩫  ⮜  .",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "_ 㫘   ᚤਫ਼   暨 ᩫ  妬  (INF)",
                "   ⮜ . 㩫     㣘 .",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ " ⤞ ᛘ   ਠ   ᩫ  夘",
  " ⚡ ᛘ   ⮜ ᮠ %u  (%lu byte)",
  "⩠ 騦.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  " Windows XP  ⤘ 棦   婡 ᮠ %u ",
   "(%lu byte) ⩠ 騦.  ᩫ  㩜",
   "⨦  騦  ਠ 㡜     ᩫ.",
   " ᛘ 婡 ⧜  婡  ⤘   婡  ",
   "棜   Windows XP   ⧜  夘 ⤞.",
   DntEmptyString,
   " 暨 ᩫ  㫘   婜 ⫦ 婡 ",
   "妪  ⫝̸ 矜  磜 騦.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ " 矜 騦  ᛘ  夞 ( C:)  ",
  "   ⫘.    ⫘ ",
  "ᮠ 3,5 MB (3.641.856 byte) ⩠ 騦  夞  ᛘ.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { " 櫞 [%s]  妬   ᣣ ᩫ ",
                       "ᨮ  ⮜ . 㩫     㣘 .",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { " ᩫ  㫘   㩜   暦  ᛘ .",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "⚥  ᛘ   嫜 櫠  ᨮ    因 椦",
                       " 暦 . ⚥ 婞   礛  ",
                       "夘 ੫.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  " ᩫ  㫘   ᯜ   :",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " ⩫ ENTER  ᢞ  嘪 .",
   " ⩫ ESC  枩  ᢣ  ⮠  ᩫ.",
   " ⩫ F3  ⥦   暨 ᩫ.",
   DntEmptyString,
   "ਫ਼: M 枩  ᢣ  ⮠  ᩫ, ",
   "婜 ᢢ 㣘   ᨡ  ᩫ.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  " 嚨  妬  稚  暨 ᩫ  夘",
   "因    .    墜  ᢣ  禬,",
   "㣘  ⫘  ᢢ 㣘    .",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " ⩫ ENTER  ᢞ  嘪 .",
   " ⩫ ESC  枩  ᢣ  ⮠  ᩫ.",
   " ⩫ F3  ⥦   暨 ᩫ.",
   DntEmptyString,
   "ਫ਼: M 枩  ᢣ  ⮠  ᩫ, ",
   "婜 ᢢ 㣘   ᨡ  ᩫ.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  " 㩜  ᢣ    嚨  妬.",
   "   坜  ਞ⤦ 㩫  妠 ",
   " ⧜   ⢢   㣘.",
   DntEmptyString,
   " ⩫ ENTER  ᢞ  嘪 .",
   " ⩫ I  枩  妬.",
   DntEmptyString,
   "ਫ਼: M 枩  ᢣ  ⮠  ᩫ, ",
   "  夜  ᩫ  ៣  Windows XP  .",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "⤜ 橦  ᩫ   磜 ਠ .",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "⤜ 橦  ᩫ ᭜    婡.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "⤜ 橦  ᩫ ᭜    ⫘.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  " 暨 ᩫ    ⫝̸  櫞",
   "⤜.  夜    \"ᩫ  Windows XP",
   "⫘ 夞,\" \"ᩫ  Windows XP ⫘ #2,\" \"ᩫ ",
   " Windows XP ⫘ #3\" and \"ᩫ  Windows XP ⫘ #4.\"",
   DntEmptyString,
   "㩫     ⩩ ⫝̸  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 4\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 4\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 3\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 2\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 夞\"",  
   NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  " 暨 ᩫ    ⫝̸  櫞",
   "⤜.  夜    \"ᩫ  Windows XP",
   "⫘ 夞,\" \"ᩫ  Windows XP ⫘ #2,\" \"ᩫ",
   " Windows XP ⫘ #3\"  \"ᩫ  Windows XP ⫘ #4.\"",
   DntEmptyString,
   "㩫     ⩩ ⫝̸  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 4\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 4\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 3\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 2\"",
   NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "㩫   ⫘  櫞, ⤞  ᛘ A:.",
   "  ⫘  夜 \"ᩫ  Windows XP ⫘ 夞\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "  ⫘  夘  櫞, ⤞  㩞  MS-DOS",
  " 夘 ⤞.  夘   㩞    ᩫ.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "  ⫘  夘  櫞, ⤞  㩞  MS-DOS",
  " 夘 ⤞.  夘   㩞    ᩫ.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ " 暨 ᩫ  夘   婜  矜 騦",
  " ⫘  㩘.  夘   㩞    ᩫ.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ " ⫘  㩘  夘  櫞   夘 .",
  " 夘   㩞   ⫘   ᩫ.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ " 㫘      ᩫ   㣘 ",
  "⫘.  夘   㩞   ⫘   ᩫ.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ " ᚤਫ਼    ᩫ   㣘  ⫘",
  " ᝜       㫘   ᚤਫ਼  ",
  "ᩫ   㣘  ⫘   㟜 .",
  DntEmptyString,
  " 墜    櫜    㡜:",
  DntEmptyString,
  "    ⮜   ⤘ .",
  "   ⤞ ⫘ 夘 ⤞.",
  "   ᛘ ⫘ ⮜ ⤘ 晢   矣 ⫨.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ " 㫘     ⫘  ᛘ A:.   ⫘",
  " 夘 ⤞. ᩫ   ⫘.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "   Windows XP  ⮦         ",
                    "   穫 .  婜  暨         ",
                    "  ᩫ 騘  ⧜   ᢠ    ",
                    "    㩜  Windows XP.               ",
                    "     * 㩫 ENTER  婜  ᩫ. ",
                    "     * 㩫 F3  婜  ᩫ.      ",
                    "Ķ",
                    "  F3=륦  ENTER=⮜                         ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP  婜   夞.",
  DntEmptyString,
  "嫜 櫠  ⫘  \"ᩫ  Windows XP", 
  "⫘ 夞\" 婡  ᛘ A:  婜.",
  DntEmptyString,
  "⩫ ENTER  夞    ⮠  ᩫ",
  " Windows XP.",
  NULL
}
},

DnsAboutToRebootS =  
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP  婜   夞.",
  DntEmptyString,
  "嫜 櫠  ⫘  \"ᩫ  Windows XP", 
  "⫘ 夞\" 婡  ᛘ A:  婜.",
  DntEmptyString,
  "⩫ ENTER  夞    ⮠  ᩫ",
  " Windows XP.",
 NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP 坜   夞.",
  DntEmptyString,
  " ᨮ  ⫘  ᛘ A:, ⩫  騘.",
  DntEmptyString,
  "⩫ ENTER  夞    ⮠  ᩫ",
  " Windows XP.",
  NULL
}
};


//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP 坜   夞.",
  DntEmptyString,
  "嫜 櫠  ⫘  \"ᩫ  Windows XP", 
  "⫘ 夞\" 婡  ᛘ A:  婜.",
  DntEmptyString,
  "⩫ ENTER    MS-DOS, 㩫   ",
  "婫  暨 ᩫ  Windows XP.",
  NULL
}

},
DnsAboutToExitS =
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP 坜   夞.",
  DntEmptyString,
  "嫜 櫠  ⫘  \"ᩫ  Windows XP", 
  "⫘ 夞\" 婡  ᛘ A:  婜.",
  DntEmptyString,
  "⩫ ENTER    MS-DOS, 㩫   ",
  "婫  暨 ᩫ  Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ " 㣘  ᩫ  坜  MS-DOS 韞.",
  " 暨 ᩫ  㩜 ᢠ   .",
  "  ᩫ  Windows XP 坜   夞.",
  DntEmptyString,
  " ᨮ  ⫘  ᛘ A:, ⩫  騘.",
  DntEmptyString,
  "⩫ ENTER    MS-DOS, 㩫   ",
  "婫  暨 ᩫ  Windows XP.",
  NULL
}
};


//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               "  暨 ᩫ ᭜ ...                 ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "  暨  MS-DOS ⡛ 5.0  櫜.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ " 暨 ᩫ 槠 櫠  ᛘ A:  ᨮ  夘",
  "ᛘ  櫞.   ⢜  ᣣ ᩫ",
  "嫘  ᛘ ⫘ 1,2   櫜.",
#else
{" 暨 ᩫ 槠 櫠  ᛘ A:  ᨮ  夘",
 "3,5   櫞. 嫘  ᛘ A:  ਞ櫞 1,44 ",
 " 髜   ᩫ  ⫝̸.",
 DntEmptyString,
"  ᩫ  Windows XP   㩞 , 㩫 ᢠ ",
"暨  婫   /b   .",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ " 暨 ᩫ 槠 櫠     ⫝̸",
  " 80486  櫜.  夘   ⢜  Windows XP.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ " 夘   ⢜  ᣣ   ⡛ 32 bit  Windows.",
  DntEmptyString,
  "㩫 winnt32.exe.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ " 暨 ᩫ 槠 櫠  ⤞ 㣞  ",
  "    ⢜  Windows XP.",
  DntEmptyString,
  "㣞  嫘: %lu%s Mb",
  "㣞  婫: %lu%s Mb",
  NULL
}
};

//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   " 暨 ᩫ  㩜    Windows XP ",
    " 棜  ᢦ.  ᩫ  Windows XP ",
    "  ᢦ   .",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    " ⩫ F3  ⥦   暨 ᩫ  ᨚ .",
    " ⩫   ᨚ    Windows    ᢦ.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ " 㫘          ᩫ.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  " 暨 ᩫ  夘   㩜   ", 
  "Windows XP   ⤦ ᢦ.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ " 夘  稜   暨 ᩫ  櫞 %s",
  " 棜     ᩫ.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  " 暨 ᩫ  夘   㩜   ", 
  "Windows XP   ⤦ ᢦ.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           ⤜ 橦 礫    Windows XP.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ " 夘   ᩫ  ᣣ 夞  Windows XP.",
  DntEmptyString,
  "嫜 櫠  ᛘ  C: 夘 ⤞   夘 ⤞.",
 NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ " 㫘   橙   ⩣   婫  ",
  "槫 /u   .",
  DntEmptyString,
  "   矞  夘   .",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "  ⩣   婫   槫 /u  ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  ", ⮜ ⤘ ᢣ 礫   %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "ᩫ ⤘ ૜ ᢣ  ᩫ.",
  DntEmptyString,
  " ᩜ   夞 夘  ᢜ.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "ᩫ ⤘ ૜ ᢣ  ᩫ.",
  DntEmptyString,
  " 㫘   稜 ⩞    .",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ " 暨 ᩫ  槠 SmartDrive   . ",
  "SmartDrive  驜   橜   ᩞ ᩫ",
  " Windows.",
  DntEmptyString,
  "嫘 ᣜ ⥦, 夞 SmartDrive  夞 ",
  "ᩫ. ⥫  ਫ਼ DOS  櫜 圪.",
  DntEmptyString,
    "  ⩫ F3  ⥦   暨 ᩫ.",
    "  ⩫ ENTER   婜   SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\fr\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\es\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo anterior en C:";

CHAR DntBootIniLine[] = "Instalacin/actualizacin de Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalacin de Windows XP \n";
CHAR DntPersonalHeader[]      = "\n Instalacin de Windows XP Personal \n";
CHAR DntWorkstationHeader[]   = "\n Instalacin de Windows XP Professional \n";
CHAR DntServerHeader[]        = "\n Instalacin de Windows XP Server \n";
CHAR DntParsingArgs[]         = "Analizando argumentos...";
CHAR DntEnterEqualsExit[]     = "Entrar=Salir";
CHAR DntEnterEqualsRetry[]    = "Entrar=Reintentar";
CHAR DntEscEqualsSkipFile[]   = "Esc=Omitir archivo";
CHAR DntEnterEqualsContinue[] = "Entrar=Continuar";
CHAR DntPressEnterToExit[]    = "El programa de instalacin no puede continuar. Presione Entrar para salir.";
CHAR DntF3EqualsExit[]        = "F3=Salir";
CHAR DntReadingInf[]          = "Leyendo el archivo INF %s...";
CHAR DntCopying[]             = "    Copiando: ";
CHAR DntVerifying[]           = " Comprobando: ";
CHAR DntCheckingDiskSpace[]   = "Comprobando espacio en disco...";
CHAR DntConfiguringFloppy[]   = "Configurando disquete...";
CHAR DntWritingData[]         = "Escribiendo parmetros de instalacin...";
CHAR DntPreparingData[]       = "Determinando los parmetros de instalacin...";
CHAR DntFlushingData[]        = "Transfiriendo los datos al disco...";
CHAR DntInspectingComputer[]  = "Examinando su equipo...";
CHAR DntOpeningInfFile[]      = "Abriendo el archivo INF...";
CHAR DntRemovingFile[]        = "Quitando el archivo %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Quitar archivos";
CHAR DntXEqualsSkipFile[]     = "X=Omitir archivo";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instala Windows 2002 Server o Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:]rutaorigen] [/t[:]unidadtemp]",
    "      [/u[:archivo de respuesta]] [/udf:id[,UDF_file]]",
    "      [/r:carpeta] [/r[x]:carpeta] [/e:comando] [/a]",
    "",
    "",
    "/s[:rutaorigen]",
    "   Especifica la ubicacin de origen de los archivos de Windows.",
    "   La ubicacin debe ser una ruta completa de la forma x:\\[ruta] o ",
    "   \\\\servidor\\recurso compartido[\\ruta]. ",
    "",
    "/t[:unidadtemp]",
    "   Indica al programa de instalacin colocar los archivos temporales",
    "   en la unidad especificada e instalar Windows XP en esa unidad. ",
    "   Si no especifica una ubicacin, el programa intentar ubicar una ",
    "   unidad por usted.",
    "",
    "/u[:archivo de respuesta]",
    "   Realiza una instalacin desatendida usando un archivo de respuesta",
    "   (requiere /s). Este archivo da respuestas a algunas o todas las",
    "   peticiones a que el usuario normalmente responde durante la instalacin.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indica un identificador (id) que usa la instalacin para especificar cmo ",
    "   un archivo de base de datos de unicidad (UDF) modifica un archivo de  ",
    "   respuesta (vea /u). El parmetro /udf anula valores en el archivo de ",
    "   respuesta y el identificador determina qu valores del archivo UDF se",
    "   utilizan. Si no se especifica un archivo UDF_file, la instalacin le pide ",
    "   insertar un disco que contenga el archivo $Unique$.udb.",
    "",
    "/r[:carpeta]",
    "   Especifica una carpeta opcional que se instalar. La carpeta se conserva",
    "   despus de terminar la instalacin.",
    "",
    "/rx[:folder]",
    "   Especifica una carpeta opcional que se copiar. La carpeta se ",
    "   elimina tras terminar la instalacin.",
    "",
    "/e Especifica un comando que se ejecutar al final de la instalacin en modo GUI.",
    "",
    "/a  Habilita opciones de accesibilidad.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala Windows XP.",
    "",
    "WINNT [/S[:]rutaorigen] [/T[:]unidadtemp] [/I[:]archivoinf]",
    "      [/U[:archivocomandos]]",
    "      [/R[X]:directorio] [/E:comando] [/A]",
    "",
    "/D[:]raz de winnt",
    "       Esta opcin ya no se admite.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memoria insuficiente para continuar con la instalacin.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{    "Elija las utilidades de accesibilidad a instalar:",
    DntEmptyString,
    "[ ] Presione F1 para el Ampliador de Microsoft",
#ifdef NARRATOR
    "[ ] Presione F2 para Narrador de Microsoft",
#endif
#if 0
    "[ ] Presione F3 para el Teclado en pantalla de Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "El Programa de instalacin debe saber dnde estn ubicados los",
  "archivos de Windows XP.",
  "Escriba la ruta donde se encuentran los archivos de Windows XP.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "El origen especificado no es vlido, inaccessible o no contiene un",
                   "programa de instalacin de Windows XP vlido. Escriba una nueva ruta",
                   "de acceso donde se pueden encontrar los archivos de Windows XP. Use",
                   "la tecla Retroceso para eliminar caracteres y escriba la nueva ruta.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "El programa de instalacin no ha podido leer el archivo de informacin",
                "o el archivo est daado.",
                "Pngase en contacto con su administrador de sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "La unidad que ha especificado que contiene los archivos temporales",
  "de instalacin no es una unidad vlida o no tiene al menos %u MB",
  "(%lu bytes) de espacio en disco libre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remember that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{   "Windows XP necesita un volumen de disco duro con un mnimo de %u MB",
  "(%lu bytes) de espacio en disco libre. La instalacin usar parte",
  "de ese espacio para almacenar archivos temporales durante la",
  "instalacin. La unidad debe estar en un disco duro local compatible",
  "con Windows XP y no debe ser una unidad comprimida.",
   DntEmptyString,
   "El programa de instalacin no ha encontrado una unidad con el suficiente",
  "espacio en disco requerido.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "No hay suficiente espacio en su unidad de inicializacin (normalmente C:)",
  "para la operacin sin discos. Esta operacin requiere al",
  "menos 3,5 MB (3.641.856 bytes) de espacio libre en su unidad.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La seccin [%s] del archivo de informacin",
                       "de la instalacin no se ha encontrado o est daada.",
                       "Pngase en contacto con el administrador del sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "El programa de instalacin no puede crear el siguiente directorio en",
                       "la unidad de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Compruebe la unidad de destino y asegrese de que no hay ningn archivo ",
                       "con el mismo nombre que la unidad de destino. Compruebe tambin las ",
                       "conexiones de la unidad.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "El programa de instalacin no puede copiar el siguiente archivo:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Presione Entrar para volver a intentar copiar el archivo.",
   "  Presione Esc para omitir el error y continuar con la instalacin.",
   "  Presione F3 para salir del programa de instalacin.",
   DntEmptyString,
  "Nota: si elige omitir el error y continuar, puede que encuentre errores",
  "      ms adelante en la instalacin.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "The copy made by Setup of the file listed below is not identical to the",
   "original. This may be the result of network errors, floppy disk problems,",
   "or other hardware-related trouble.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Presione Entrar para volver a intentar la operacin de copia.",
   "  Presione Esc para omitir el error y continuar con la instalacin.",
   "  Presione F3 para salir del programa de instalacin.",
   DntEmptyString,
   "Nota: si elige omitir el error y continuar, puede que encuentre errores",
   "      ms adelante en la instalacin.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Si omite el error este archivo no ser copiado.",
   "Esta opcin est destinada a usuarios avanzados que comprenden",
   "las consecuencias de perder archivos de sistema.",
   DntEmptyString,
   "  Presione Entrar para volver a intentar la operacin de copia.",
   "  Presione X para omitir este archivo.",
   DntEmptyString,
   "Nota: si omite el archivo, no se podr garantizar",
   "una correcta instalacin o actualizacin de Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Espere mientras se quitan los archivos temporales.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Espere mientras se copian los archivos en su disco duro.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Espere mientras se copian los archivos en el disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "El programa requiere que le proporcione cuatro discos de alta densidad",
   "formateados. El programa se referir a ellos como \"Disco de inicio de instalacin de",
   "Windows XP,\" \"Disco de instalacin nm. 2 de Windows XP,\" \"Disco de",
   "instalacin nm. 3 de Windows XP\" y \"Disco de instalacin nm. 4 de Windows XP.\"",
   DntEmptyString,
   "Inserte uno de estos cuatro discos en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{   "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 3 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 2 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de inicio de instalacin de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{   "El programa requiere que le proporcione cuatro discos de alta densidad",
   "formateados. El programa se referir a ellos como \"Disco de inicio de instalacin de",
   "Windows XP,\" \"Disco de instalacin nm. 2 de Windows XP,\" \"Disco de",
   "instalacin nm. 3 de Windows XP\" y \"Disco de instalacin nm. 4 de Windows XP.\"",
   DntEmptyString,
   "Inserte uno de estos tres discos en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 3 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 2 de Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de inicio de instalacin de Windows XP.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "El disco que ha proporcionado no est formateado para usarse con MS-DOS.",
  "El programa de instalacin no puede usar este disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Este disco no es de alta densidad, no tiene el formato estndar de",
  "MS-DOS o est daado.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "El programa de instalacin no puede determinar el espacio libre en el",
  "disco que ha proporcionado.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "El disco que ha proporcionado no es de alta densidad o no est vaco.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "El programa de instalacin no puede escribir en el rea de sistema",
  "del disquete. Lo ms probable es que no se pueda utilizar este disco.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Los datos que el programa de instalacin ha ledo del rea de sistema",
  "del disco no corresponden con los datos escritos, o el programa de",
  "instalacin no puede leer el rea de sistema del disco para la",
  "comprobacin.",
  DntEmptyString,
  "Esto se debe a una o varias de las siguientes condiciones:",
  DntEmptyString,
  "  Su equipo est infectado por un virus.",
  "  El disco suministrado est daado.",
  "  Existe un problema con el hardware o la configuracin de la unidad.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "El programa de instalacin no ha podido escribir en el disco de la",
  "unidad A. Puede que el disco est daado. Intntelo con otro disco.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  No se ha terminado de instalar Windows XP en     ",
                    "  su  equipo. Si sale ahora, debe ejecutar el      ",
                    "  programa de instalacin de nuevo para instalar   ",
                    "  Windows XP correctamente.                        ",
                    "                                                   ",
                    "    * Presione Entrar para continuar.              ",
                    "    * Presione F3 para salir de la instalacin.    ",
                    "ĺ",
                    "    F3=Salir                 Entrar=Continuar      ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{"La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows XP.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows XP.\"",
  "est insertado en la unidad A: antes de continuar.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows XP.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows XP.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows XP.\"",
  "est insertado en la unidad A: antes de continuar.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows XP.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado continuar con la instalacin de Windows XP.",
  DntEmptyString,
  "Si hay algn disco en la unidad A:, qutelo ahora.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows XP.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{  "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado continuar la instalacin de Windows XP.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows XP.\"",
  "est insertado en la unidad A:.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows XP.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows XP.\"",
  "est insertado en la unidad A:.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows XP.",
  DntEmptyString,
  "Si hay algn disco en la unidad A:, qutelo ahora.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
  " El programa de instalacin est copiando archivos...           ",
  "                                                                ",
  "      Ŀ      ",
  "                                                              ",
  "            ",
  "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa necesita la versin 5.0 o posterior de MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{  "El programa de instalacin ha determinado que la unidad A no existe o",
  "es una unidad de baja densidad. El programa de instalacin necesita una",
  "unidad con una capacidad de 1,2 MB o superior para ejecutarse.",
#else
{ "El programa de instalacin ha determinado que la unidad A no existe o",
  "no es una unidad de 3,5\". El programa de instalacin necesita una",
  "unidad con una capacidad de 1,44 MB o superior para ejecutarse con",     
  "discos.",
  DntEmptyString,
  "Para instalar Windows XP usando discos, reinicie el programa",
  "especificando /b en la lnea de comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "El programa de instalacin ha determinado que su equipo no",
  "contine una CPU 80486 o posterior. Windows XP no puede ejecutarse",
  "en este equipo.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa no puede ejecutarse en ninguna versin de Windows de 32 bits.",
  DntEmptyString,
  "Use WINNT32.EXE en su lugar.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "El programa de instalacin ha determinado que no hay memoria suficiente",
  "para ejecutar Windows XP.",
  DntEmptyString,
  "Memoria requerida: %lu%s MB",
  "Memoria detectada: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Ha pedido quitar archivos de Windows XP del directorio siguiente.",
    "Perder de forma permanente la instalacin de Windows.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Presione F3 para salir de la instalacin sin quitar archivos.",
    "  Presione X para quitar archivos de Windows de este directorio.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "No se puede abrir el siguiente archivo de registro de la instalacin.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "La instalacin no puede quitar archivos de Windows del directorio.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "No se puede encontrar la seccin  %s en el siguiente archivo",
  "de registro de la instalacin.",
  DntEmptyString,
  "%s",
  DntEmptyString,
   "La instalacin no puede quitar archivos de Windows del directorio.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Espere a que se quiten los archivos de Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "El programa de instalacin no puede instalar el cargador de",
  "inicio de Windows.",
   DntEmptyString,
  "Asegrese que su unidad C: est formateada y en buen estado.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{  "No se puede tener acceso al archivo de comandos especificado con",
  "la opcin /u de la lnea de comandos.",
  DntEmptyString,
  "La operacin no asistida no puede continuar.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{"El archivo de comandos especificado con el parmetro /u ",
DntEmptyString,
  "%s",
  DntEmptyString,
  "contiene un error sintctico en la lnea %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Error interno del programa de instalacin.",
  DntEmptyString,
  "Los mensajes de inicio traducidos son demasiado largos.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Error interno del programa de instalacin.",
  DntEmptyString,
  "No se puede encontrar un sitio para un archivo de intercambio.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "El programa de instalacin no detect SmartDrive en",
  "su equipo. SmartDrive mejorar apreciablemente el",
  "desempeo de esta fase de la instalacin de Windows.",
  DntEmptyString,
  "Debe salir ahora, iniciar SmartDrive y reiniciar la",
  "instalacin. Lea la documentacin de DOS para los",
  "detalles acerca de SmartDrive.",
  DntEmptyString,
    "  Presione F3 para salir de la instalacin.",
    "  Presione ENTRAR para continuar sin SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Error de disco";
CHAR BootMsgPressKey[] = "Pres. una tecla";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\el\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Greek.

CFOPT=-DLCP -DEL

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\ger\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\it\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\hu\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Hungarian.

CFOPT=-DLCP -DHU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\fr\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Systme d'exploitation prcdent sur C:";

CHAR DntBootIniLine[] = "Installation/Mise  niveau de Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installation de Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Installation de Windows XP dition familiale\n";
CHAR DntWorkstationHeader[]   = "\n Installation de Windows XP Professionnel\n";
CHAR DntServerHeader[]        = "\n Installation de Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Analyse des arguments...";
CHAR DntEnterEqualsExit[]     = "ENTREE=Quitter";
CHAR DntEnterEqualsRetry[]    = "ENTREE=Recommencer";
CHAR DntEscEqualsSkipFile[]   = "ECHAP=Ignorer le fichier";
CHAR DntEnterEqualsContinue[] = "ENTREE=Continuer";
CHAR DntPressEnterToExit[]    = "L'installation ne peut pas continuer. Appuyez sur ENTREE pour quitter.";
CHAR DntF3EqualsExit[]        = "F3=Quitter";
CHAR DntReadingInf[]          = "Lecture du fichier INF %s...";
CHAR DntCopying[]             = "     Copie de : ";
CHAR DntVerifying[]           = " Vrification : ";
CHAR DntCheckingDiskSpace[]   = "Vrification de l'espace disque...";
CHAR DntConfiguringFloppy[]   = "Configuration de la disquette...";
CHAR DntWritingData[]         = "Ecriture des paramtres d'installation...";
CHAR DntPreparingData[]       = "Recherche des paramtres d'installation...";
CHAR DntFlushingData[]        = "Enregistrement des donnes sur le disque...";
CHAR DntInspectingComputer[]  = "Inspection de l'ordinateur...";
CHAR DntOpeningInfFile[]      = "Ouverture du fichier INF...";
CHAR DntRemovingFile[]        = "Suppression du fichier %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Supprimer les fichiers";
CHAR DntXEqualsSkipFile[]     = "X=Ignorer le fichier";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installe Windows 2002 Server ou Windows XP Professionnel.",
    "",
    "",
    "WINNT [/s[:chemin_source]] [/t[:lecteur_temporaire]]",
    "	   [/u[:fichier rponse]] [/udf:id[,fichier_UDF]]",
    "	   [/r:dossier] [/r[x]:dossier] [/e:commande] [/a]",
    "",
    "",
    "/s[:chemin_source]",
    "	Spcifie l'emplacement source des fichiers Windows.",
    "	L'emplacement doit tre un chemin complet de la forme x:\\[chemin] ou ",
    "	\\\\serveur\\partage[\\chemin]. ",
    "",
    "/t[:lecteur_temporaire]",
    "	Indique au programme d'installation de placer les fichiers temporaires ",
    "	sur le lecteur spcifi et d'installer Windows XP sur celui-ci. ",
    "	Si vous ne spcifiez pas d'emplacement ; le programme d'installation ",
    "	essaie de trouver un lecteur  votre place.",
    "",
    "/u[:fichier rponse]",
    "	Effectue une installation sans assistance en utilisant un fichier ",
    "	rponse (ncessite /s). Celui-ci fournit les rponses  toutes ou ",
    "	une partie des questions normalement poses  l'utilisateur. ",
    "",
    "/udf:id[,fichier_UDF]",
    "	Indique un identificateur (id) utilis par le programme d'installation ",
    "	pour spcifier comment un fichier bases de donnes d'unicit (UDF) ",
    "	modifie un fichier rponse (voir /u). Le paramtre /udf remplace les ",
    "	valeurs dans le fichier rponse ; et l'identificateur dtermine quelles ",
    "	valeurs du fichier UDF sont utilises. Si aucun fichier UDF n'est ",
    "	spcifi, vous devrez insrer un disque contenant le fichier $Unique$.udb.",
    "",
    "/r[:dossier]",
    "	Spcifie un dossier optionnel  installer. Le dossier",
    "	sera conserv aprs la fin de l'installation.",
    "",
    "/rx[:dossier]",
    "	Spcifie un dossier optionnel  installer. Le dossier",
    "	sera supprim  la fin de l'installation.",
    "",
    "/e	Spcifie une commande  excuter  la fin de l'installation en mode GUI.",
    "",
    "/a	Active les options d'accessibilit.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installe Windows XP.",
    "",
    "WINNT [/S[:]chemin_source] [/T[:]lecteur_temporaire] [/I[:]fichier_inf]",
    "      [/U[:fichier_script]]",
    "      [/R[X]:rpertoire] [/E:commande] [/A]",
    "",
    "/D[:]racine_winnt",
    "       Cette option n'est plus prise en charge.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Mmoire insuffisante pour l'installation. Impossible de continuer.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Choisissez les utilitaires d'accessibilit  installer :",
    DntEmptyString,
    "[ ] Appuyez sur F1 pour la Loupe Microsoft",
#ifdef NARRATOR
    "[ ] Appuyez sur F2 pour Microsoft Narrator",
#endif
#if 0
    "[ ] Appuyez sur F3 pour Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Indiquez le chemin dans lequel se trouvent les fichiers de",
  "Windows XP puis appuyez sur ENTREE pour dmarrer l'installation.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "La source spcifie n'est pas valide ou accessible, ou ne contient pas",
                   "un jeu de fichiers valide pour l'installation de Windows XP. Entrez un",
                   "nouveau chemin pour les fichiers de Windows XP. Utilisez la touche",
                   "RETOUR ARRIERE pour supprimer des caractres, puis entrez le chemin.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Impossible de lire le fichier d'informations de l'installation ou le",
                "fichier est endommag. Contactez votre administrateur systme.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Le lecteur spcifi pour les fichiers temporaires d'installation n'est",
  "pas valide ou ne contient pas au moins %u mgaoctets (%lu octets)",
  "d'espace libre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP a besoin d'un disque dur avec au moins %u mgaoctets",
   "(%lu octets) d'espace libre. Le programme d'installation utilisera",
   "une partie de cet espace pour stocker des fichiers temporaires pendant",
   "l'installation. Le lecteur doit tre un disque dur local non amovible,",
   "pris en charge par Windows XP, et non compress.",
   DntEmptyString,
   "Le programme d'installation n'a pas pu trouver un tel lecteur avec la",
   "quantit d'espace libre requise.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Il n'y a pas assez d'espace sur votre disque de dmarrage (en gnral C:)",
  "pour une opration sans disquettes. Une opration sans disquettes ncessite",
  "au moins 3,5 Mo (3 641 856 octets) d'espace libre sur ce disque.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La section [%s] du fichier d'informations de l'installation",
                       "est absente ou est endommage. Contactez votre administrateur systme.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Impossible de crer le rpertoire suivant sur le lecteur destination :",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Vrifiez le lecteur destination et son cblage, et qu'aucun fichier n'existe",
                       "avec un nom semblable  celui du rpertoire destination.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Le programme d'installation n'a pas pu copier le fichier suivant :",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur ECHAP pour ignorer l'erreur et continuer l'installation.",
   "  Appuyez sur F3 pour quitter le programme d'installation.",
   DntEmptyString,
   "Remarque : Si vous choisissez d'ignorer l'erreur et de continuer, vous",
   "rencontrerez peut-tre plus tard des erreurs d'installation.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "La copie du fichier ci-dessous faite par le programme d'installation ne",
   "correspond pas  l'original. Ceci est peut-tre le rsultat d'erreurs",
   "rseau, de problmes de disquettes ou d'autres problmes lis au matriel.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur ECHAP pour ignorer l'erreur et continuer l'installation.",
   "  Appuyez sur F3 pour quitter le programme d'installation.",
   DntEmptyString,
   "Remarque : Si vous choisissez d'ignorer l'erreur et de continuer, vous",
   "rencontrerez peut-tre plus tard des erreurs d'installation.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorer l'erreur signifie que ce fichier ne sera pas copi.",
   "Cette option est destine aux utilisateurs expriments qui comprennent",
   "les ramifications des fichiers systme manquants.",
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur X pour ignorer ce fichier.",
   DntEmptyString,
   "Remarque : en ignorant ce fichier, le programme d'installation ne peut",
   "pas garantir une installation ou une mise  niveau russie de Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Veuillez patienter pendant la suppression des anciens fichiers temporaires.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Patientez pendant la copie des fichiers sur votre disque dur.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Patientez pendant la copie des fichiers sur la disquette.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Le programme d'installation ncessite quatre disquettes formates, vierges,",
   "et de haute densit. Le programme d'installation leur donnera comme nom :",
   "\"Disquette de dmarrage de l'installation de Windows XP\",", 
   "\"Disquette d'installation de Windows XP numro 2\",", 
   "\"Disquette d'installation de Windows XP numro 3\",", 
   "et \"Disquette d'installation de Windows XP numro 4\".", 
   DntEmptyString,
   "Veuillez insrer dans le lecteur A: la disquette qui deviendra la",
   "\"Disquette d'installation de Windows XP numro 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 3\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 2\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate. Nommez-",
   "la \"Disquette de dmarrage de l'installation de Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Le programme d'installation ncessite quatre disquettes formates, vierges,",
   "et de haute densit. Le programme d'installation leur donnera comme nom :",
   "\"Disquette de dmarrage de l'installation de Windows XP\",", 
   "\"Disquette d'installation de Windows XP numro 2\",", 
   "\"Disquette d'installation de Windows XP numro 3\",", 
   "et \"Disquette d'installation de Windows XP numro 4\".", 
   DntEmptyString,
   "Veuillez insrer dans le lecteur A: la disquette qui deviendra la",
   "\"Disquette d'installation de Windows XP numro 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 3\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows XP numro 2\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette de dmarrage de l'installation de Windows XP\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "La disquette que vous avez fournie n'est pas formate pour MS-DOS",
  "Le programme d'installation ne peut pas utiliser cette disquette.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Cette disquette n'est pas formate en haute densit, au format MS-DOS,",
  "ou est endommage. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Impossible de dterminer l'espace disponible sur la disquette",
   "fournie. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "La disquette que vous avez fournie n'est pas de haute densit ou n'est",
  "pas vierge. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Le programme d'installation n'a pas pu crire dans la zone systme de",
  "la disquette fournie. La disquette est probablement inutilisable.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Les donnes lues par le programme d'installation depuis la zone systme",
  "de la disquette ne correspondent pas aux donnes qui ont t crites, ou",
  "il est impossible de lire la zone systme de la disquette pour la vrifier.",
  DntEmptyString,
  "Ceci est d au moins  l'une des conditions suivantes :",
  DntEmptyString,
  "  Votre ordinateur a t atteint par un virus.",
  "  La disquette que vous avez fournie est peut-tre endommage.",
  "  Le lecteur a un problme matriel ou de configuration.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Le programme d'installation n'a pas pu crire sur la disquette dans le",
  "lecteur A:. La disquette peut tre endommage. Essayez une autre disquette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    " Windows XP n'est pas compltement install sur votre ordinateur.       ",
                    " Si vous quittez le programme d'installation maintenant, il faudra      ",
                    " l'excuter  nouveau pour installer Windows XP.                        ",
                    "                                                                        ",
                    "     Appuyez sur ENTREE pour continuer l'installation.                 ",
                    "     Appuyez sur F3 pour quitter le programme d'installation.          ",
                    "͹",
                    "    F3=Quitter          ENTREE=Continuer                                ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows XP", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows XP", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "S'il y a une disquette dans le lecteur A:, retirez-la.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows XP", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows XP", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows XP continuera.",
  DntEmptyString,
  "S'il y a une disquette dans le lecteur A:, retirez-la.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Le programme d'installation copie des fichiers...              ",
               "                                                                ",
               "      ͻ      ",
               "                                                              ",
               "      ͼ      ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Ce programme ncessite MS-DOS version 5.0 ou ultrieure pour fonctionner.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Le programme d'installation a dtermin que le lecteur A: est absent ou",
  "est un lecteur faible densit. Un lecteur d'une capacit de 1.2",
  "mgaoctets ou plus est requis pour excuter le programme d'installation.",
#else
{ "Le programme d'installation a dtermin que le lecteur A: n'existe pas ou",
  "n'est pas haute densit 3.5\". Un lecteur A: d'une capacit de 1.44 Mo ou",
  "plus est requis pour excuter installer  partir de disquettes.",
  DntEmptyString,
  "Pour installer Windows XP sans disquettes, redmarrez ce programme",
  "et spcifiez /b  l'invite de commandes.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Le programme d'installation a dtect que cet ordinateur ne possde pas de",
  "processeur 80486 ou plus rcent. Windows XP ne pourra pas fonctionner.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Ce programme ne peut s'excuter sous aucune version 32 bits de Windows.",
  DntEmptyString,
  "Utilisez plutt WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Le programme d'installation a dtermin qu'il n'y a pas assez de mmoire",
  "disponible dans cet ordinateur pour installer Windows XP.",
  DntEmptyString,
  "Mmoire requise :  %lu%s Mo",
  "Mmoire dtecte : %lu%s Mo",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Vous avez demand au programme d'installation de supprimer les fichiers",
    "Windows XP du rpertoire nomm ci-dessous. L'installation",
    "Windows de ce rpertoire sera dtruite de manire permanente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "Appuyez sur :",
    "  F3 pour arrter l'installation sans supprimer de fichiers.",
    "  X pour supprimer les fichiers Windows XP du rpertoire ci-dessus.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Impossible d'ouvrir le fichier journal de l'installation nomm ci-dessous.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossible de supprimer les fichiers Windows XP du rpertoire spcifi.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Le programme d'installation ne trouve pas la section %s",
  "dans le fichier journal de l'installation nomm ci-dessous.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossible de supprimer les fichiers Windows XP du rpertoire spcifi.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "       Veuillez patienter pendant la suppression des fichiers Windows XP.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Impossible d'installer le chargeur de dmarrage de Windows XP.",
  DntEmptyString,
  "Vrifiez que votre lecteur C: est format et qu'il n'est pas",
  "endommag.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Le fichier script spcifi avec le commutateur de ligne de commande", 
  "/u n'est pas accessible.",
  DntEmptyString,
  "L'opration ne peut pas continuer sans contrle.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Le fichier script spcifi par l'option /u de la ligne de commande",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contient une erreur de syntaxe  la ligne %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Une erreur interne du programme d'installation s'est produite.",
  DntEmptyString,
  "Les messages d'initialisation traduits sont trop longs.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Une erreur interne du programme d'installation s'est produite.",
  DntEmptyString,
  "Impossible de trouver la place pour un fichier d'change.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive n'a pas t dtect sur votre ordinateur. SmartDrive amliore",
  "les performances de cette tape de l'installation de Windows XP.",
  DntEmptyString,
  "Vous devriez quitter maintenant, dmarrer SmartDrive et redmarrer",
  "l'installation. Consultez votre documentation DOS sur SmartDrive.",
  DntEmptyString,
    "  Appuyez sur F3 pour quitter l'installation.",
    "  Appuyez sur ENTREE pour continuer sans SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR manque";
CHAR BootMsgDiskError[] = "Err. disque";
CHAR BootMsgPressKey[] = "Appuyez une touche pour redmarrer";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\fi\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Aikaisempi kyttjrjestelm asemassa C:";

CHAR DntBootIniLine[] = "Windows XP:n asennus tai pivitys";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP:n asennus\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Home Editionin asennus\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professionalin asennus\n";
CHAR DntServerHeader[]        = "\n Windows .NET Serverin asennus\n";                 CHAR DntParsingArgs[]         = "Argumenttien jsennys...";
CHAR DntEnterEqualsExit[]     = "ENTER=Lopeta";
CHAR DntEnterEqualsRetry[]    = "ENTER=Yrit uudelleen";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ohita tiedosto";
CHAR DntEnterEqualsContinue[] = "ENTER=Jatka";
CHAR DntPressEnterToExit[]    = "Asennusohjelma ei voi jatkaa. Lopeta painamalla ENTER.";
CHAR DntF3EqualsExit[]        = "F3=Lopeta";
CHAR DntReadingInf[]          = "Luetaan INF-tiedostoa %s...";
CHAR DntCopying[]             = "   Kopioidaan: ";
CHAR DntVerifying[]           = " Tarkistetaan: ";
CHAR DntCheckingDiskSpace[]   = "Tarkistetaan levytila...";
CHAR DntConfiguringFloppy[]   = "Mritetn levykett...";
CHAR DntWritingData[]         = "Kirjoitetaan parametreja...";
CHAR DntPreparingData[]       = "Kartoitetaan asennusparametreja...";
CHAR DntFlushingData[]        = "Siirretn data levylle...";
CHAR DntInspectingComputer[]  = "Tarkistetaan tietokone...";
CHAR DntOpeningInfFile[]      = "Avataan INF-tiedosto...";
CHAR DntRemovingFile[]        = "Poistetaan %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Poista tiedostot";
CHAR DntXEqualsSkipFile[]     = "X=Ohita tiedosto";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Asentaa Windows XP:n.",
    "",
    "",
    "WINNT [/s[:]lhdepolku] [/t[:]temp-asema]",
    "      [/u[:komentotiedosto]] [/udf:id[,UDF-tiedosto]]",
    "      [/r:kansio] [/r[x]:kansio] [/e:komento] [/a]",
    "",
    "",
    "/S[:]lhdepolku",
    "       Mritt Windows-lhdetiedostojen sijainnin.",
    "       Polku tytyy kirjoittaa muodossa x:[polku] tai",
    "       \\\\palvelin\\jakonimi[polku].",
    "       Oletuksena on nykyinen kansio.",
    "",
    "/T[:]tmp-asema",
    "       Mritt vliaikaisten asennustiedostojen aseman.",
    "       Jos mrityst ei tehd, asennusohjelma yritt etsi aseman.",
    "",
    "/u[:vastaustiedosto]",
    "   Automaattinen asennus kytten vastaustiedostoa (vaatii /s)",
    "   Vastaustiedostossa on vastaukset joihinkin tai kaikkiin",
    "   kysymyksiin, joihin kyttj vastaa asennuksen aikana.",
    "",
    "/udf:tunnus[,UDF-tiedosto] ",
    "   Mritt tunnuksen, jota asennus kytt vastaustiedoston ",
    "   (katso /u) muokkaamiseen UDF-tiedostolla (Uniqueness ",
    "   Database File). /udf-valitsin korvaa vastaustiedoston ",
    "   arvot. Tunnus mritt UDF-tiedostossa kytettvt arvot. ",
    "   Jos UDF-tiedostoa ei ole mritetty, asennus pyyt ",
    "   asettamaan levykkeen, jolla on $Unique$.udb-tiedosto.",
    "",
    "/r[:kansio]",
    "   Mritt vaihtoehtoisen kopiointikansion.",
    "   Kansio silytetn asennuksen ptytty.",
    "",
    "/rx[:kansio]",
    "   Mritt vaihtoehtoisen kopiointikansion.",
    "   Kansio poistetaan asennuksen jlkeen.",
    "",
    "/e Mritt asennuksen graafisen osan jlkeen suoritettavan komennon.",
    "",
    "/a Ottaa helppokytttoiminnot kyttn.",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Asentaa Windows XP -kyttjrjestelmn.",
    "",
    "WINNT [/S[:]lhdepolku] [/T[:]temp-asema] [/I[:]inf-tied]",
    "      [/U[:komentotiedosto]]",
    "      [/R[X]:kansio] [/E:komento] [/A]", 
    "",
    "/D[:]winnthak",
    "       Tt vaihtoehtoa ei en tueta.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Muisti loppui. Asennusohjelmaa ei voi jatkaa.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Valitse asennettavat helppokytttoiminnot:",
    DntEmptyString,
    "[ ] Valitse Microsoft Suurennuslasi painamalla F1",
#ifdef NARRATOR
    "[ ] Valitse Microsoft Narrator painamalla F2",
#endif
#if 0
    "[ ] Valitse Microsoft On-Screen-nppimist painamalla F3",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Asennusohjelma tarvitsee Windows XP -tiedostojen kansion.",
  "Anna kansiopolku, josta Windows XP -tiedostot lytyvt.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Mritetty lhde ei kelpaa, se ei ole kytettviss tai",
                   "ei sisll kelvollista Windows XP:n asennusohjelmaa.",
                   "Anna uusi polku, josta Windows XP:n tiedostot lytyvt.",
                   "Poista merkkej ASKELPALAUTTIMELLA ja kirjoita uusi polku.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Asennusohjelma ei voinut lukea informaatiotiedostoa tai tiedosto on",
                "vahingoittunut. Ota yhteys jrjestelmnvalvojaan.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Vliaikaisille asennustiedostoille mritetty asema ei kelpaa",
  "tai asemassa ei ole %u megatavua (%lu tavua)",
  "vapaata levytilaa.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{ "Windows XP vaatii kiintolevyn, jolla on vhintn %u megatavua",
  "(%lu tavua) tilaa. Asennusohjelma kytt osan tst tilasta",
  "vliaikaistiedostojen tallentamiseen asennuksen aikana. Aseman on",
  "oltava kiinte, paikallinen, Windows XP:n tukema kiintolevy eik",
  "asemassa saa olla kytss DoubleSpace tai muu pakkausohjelma.",
  DntEmptyString,
  "Asennusohjelma ei havainnut tarvittua asemaa, jolla on",
  "riittvsti vapaata levytilaa.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Kynnistysasemassa (yleens C:) ei ole tarpeeksi tilaa levykkeetnt",
  "asennusta varten. Levykkeetnt asennusta varten tarvitaan",
  "vhintn 3,5 Mt (3 641 856 tavua) vapaata levytilaa.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Asennusohjelman informaatiotiedoston osa [%s] ei ole kytettviss",
                       "tai on vahingoittunut. Ota yhteys jrjestelmnvalvojaan.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Asennusohjelma ei voinut luoda seuraavaa kansiota kohdeasemaan.",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Tarkista kohdeasema ja varmista, ett kohdekansiossa ei ole tiedostoja,",
                       "jotka ovat samoja kuin kohdekansio. Tarkista mys kaapelointi asemaan.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Asennusohjelma ei voinut kopioida seuraavaa tiedostoa:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Yrit toimintoa uudelleen painamalla ENTER.",
   "  Jt virhe huomiotta ja jatka asennusta painamalla ESC.",
   "  Lopeta asennusohjelma painamalla F3.",
   DntEmptyString,
   "Huomautus: Jos jtt virheen huomiotta ja jatkat, saatat kohdata",
   "uusia virhetilanteita myhemmin asennusohjelman aikana.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Asennusohjelman mritetyst tiedostosta tekem kopio ei vastaa",
   "tydellisesti alkuperist. Syyn voivat olla verkkovirheet,",
   "levykeongelmat tai muut laitteisto-ongelmat.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Yrit toimintoa uudelleen painamalla ENTER.",
   "  Jt virhe huomiotta ja jatka asennusta painamalla ESC.",
   "  Lopeta asennus painamalla F3.",
   DntEmptyString,
   "Huomaa: Jos jtt virheen huomiotta ja jatkat, saatat kohdata uusia",
   "virheit myhemmin asennusohjelman aikana.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Jos jtt virheen huomiotta, tt tiedostoa ei kopioida.",
   "Valitse tm vaihtoehto vain, jos tiedt mit seurauksia",
   "puuttuva jrjestelmtiedosto voi aiheuttaa.",
   DntEmptyString,
   "  Yrit toimintoa uudelleen painamalla ENTER.",
   "  Ohita tiedosto painamalla X.",
   DntEmptyString,
   "Huomautus: Jos ohitat tiedoston, Asennus ei voi taata",
   "Windows NT:n asennuksen tai pivityksen onnistumista.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Odota. Asennus poistaa aikaisemmat vliaikaistiedostot.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "     Odota. Asennus kopioi tiedostot kiintolevylle.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "     Odota. Asennus kopioi tiedostot levykkeelle.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Asennus tarvitsee kolme alustettua, suurtiheyksist levykett. Nihin",
   "levykkeisiin viitataan myhemmin nimill \"Windows XP Asennuksen",
   "kynnistyslevyke,\" \"Windows XP Asennuslevyke 2\", \"Windows ",
   "XP Asennuslevyke 3\" ja \"Windows XP Asennuslevyke 4.\"",
   DntEmptyString,
   "Aseta yksi levykkeist asemaan A:.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 3.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 2.\"",
  NULL

}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Asennus tarvitsee alustetun, suurtiheyksisen levykeen. Thn",
   "levykkeeseen viitataan myhemmin nimell \"Windows XP Asennuksen",
   "kynnistyslevyke.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Asennus tarvitsee nelj alustettua, suurtiheyksist levykett. Nihin",
   "levykkeisiin viitataan myhemmin nimill \"Windows XP Asennuksen",
   "kynnistyslevyke\", \"Windows XP Asennuslevyke 2\", ja \"Windows XP",
   "Asennuslevyke 3\".",
   DntEmptyString,
   "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 3.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuslevyke 2.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Aseta levykeasemaan A: alustettu ja tyhj suurtiheyksinen levyke.",
   "Anna tlle levykkeelle nimi \"Windows XP Asennuksen kynnistyslevyke.\"",
  NULL
}
};


//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Antamaasi levykett ei ole alustettu kytettvksi MS-DOSissa.",
  "Asennusohjelma ei voi kytt levykett.",
  NULL
}
};


//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Levyke ei ole HD-levyke, sen alustus ei ole MS-DOS-standardin mukainen",
  "tai se on vahingoittunut. Asennusohjelma ei voi kytt tt levykett.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Asennusohjelma ei voi mritt levykkeell olevan vapaan levytilan",
  "mr. Asennus ei voi kytt tt levykett.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Levyke ei ole tyhj tai HD-levyke.",
  "Asennus ei voi kytt tt levykett.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Asennusohjelma ei voi kirjoittaa levykkeen jrjestelmalueelle.",
  "Levyke on ehk kyttkelvoton.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Asennusohjelman lukemat tiedot levykkeen jrjestelmalueelta eivt vastaa",
  "kirjoitettuja tietoja tai asennusohjelma ei voinut lukea levykkeen",
  "jrjestelmaluetta tarkistuksen suorittamiseksi.",
  DntEmptyString,
  "Syit voivat olla:",
  DntEmptyString,
  "  Tietokoneessasi on virus.",
  "  Levyke on vahingoittunut.",
  "  Levyasemassa on laitteisto- tai kokoonpanomritysongelma.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Asennusohjelma ei voinut kirjoittaa levykkeelle asemassa A:.",
  "Levyke saattaa olla vahingoittunut.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Windows XP:n asennusta ei ole suoritettu loppuun.       ",
                    "  Jos lopetat asennusohjelman nyt, Windows XP tulee       ",
                    "  asentaa myhemmin uudelleen asennusohjelmalla.          ",
                    "                                                          ",
                    "      Jatka asennusta painamalla ENTER.                  ",
                    "      Lopeta asennus painamalla F3.                      ",
                    "ĺ",
                    "  F3=Lopeta  ENTER=Jatka                                  ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma kynnist",
  "tietokoneesi uudelleen. Tmn jlkeen Windows XP:n asennus jatkuu.",
  " ",
  DntEmptyString,
  "Varmista, ett levyke nimelt \"Windows XP Asennuksen",
  "kynnistyslevyke\" on levykeasemassa A:.",
  DntEmptyString,
  "Jatka Windows XP:n asennusta ja kynnist tietokoneesi painamalla ENTER.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma",
  "kynnist tietokoneesi uudelleen. Uudelleenkynnistyksen",
  "jlkeen Windows XP:n asennus jatkuu.",
  DntEmptyString,
  "Varmista, ett levyke nimelt \"Windows XP Asennuksen",
  "kynnistyslevyke\" on levykeasemassa A:.",
  DntEmptyString,
  "Jatka Windows XP:n asennusta ja kynnist tietokoneesi painamalla ENTER.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma",
  "kynnist tietokoneesi uudelleen. Uudelleenkynnistyksen",
  "jlkeen Windows XP:n asennus jatkuu.",
  DntEmptyString,
  "Jos levykeasemassa A: on levyke, poista se.",
  DntEmptyString,
  "Jatka Windows XP:n asennusta ja kynnist tietokoneesi painamalla ENTER.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma kynnist",
  "tietokoneesi uudelleen. Tmn jlkeen Windows XP:n asennus jatkuu.",
  " ",
  DntEmptyString,
  "Varmista, ett levyke nimelt \"Windows XP Asennuksen",
  "kynnistyslevyke\" on levykeasemassa A:.",
  DntEmptyString,
  "Palaa MS-DOS:iin painamalla ENTER ja kynnist tietokoneesi uudelleen ",
  "jatkaaksesi Windows XP:n asennusta.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma kynnist",
  "tietokoneesi uudelleen. Tmn jlkeen Windows XP:n asennus jatkuu.",
  " ",
  DntEmptyString,
  "Varmista, ett levyke nimelt \"Windows XP Asennuksen",
  "kynnistyslevyke\" on levykeasemassa A:.",
  DntEmptyString,
  "Palaa MS-DOS:iin painamalla ENTER ja kynnist tietokoneesi uudelleen ",
  "jatkaaksesi Windows XP:n asennusta.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Asennusohjelman DOS-osuus on nyt suoritettu. Asennusohjelma kynnist",
  "tietokoneesi uudelleen. Tmn jlkeen Windows XP:n asennus jatkuu.",
  " ",
  DntEmptyString,
  "Jos levykeasemassa A: on levyke, poista se.",
  DntEmptyString,
  "Palaa MS-DOS:iin painamalla ENTER ja kynnist tietokoneesi uudelleen ",
  "jatkaaksesi Windows XP:n asennusta.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Asennus kopioi tiedostoja...                                   ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Tm ohjelma vaatii MS-DOS-version 5.0 tai uudemman.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Asennusohjelman mukaan asemaa A: ei ole olemassa tai asema",
  "on matalatiheyksinen. Asennusohjelma tarvitsee aseman, jonka",
  "kapasiteetti on 1,2 megatavua tai suurempi.",
#else
{ "Asennusohjelman mukaan asemaa A: ei ole olemassa tai se ei ole",
  "suuritiheyksinen 3.5\" asema. Levykeasennus vaatii aseman A:,",
  "jonka kapasiteetti on 1,44 megatavua tai suurempi.",
  DntEmptyString,
  "Jos haluat asentaa Windows XP:n kyttmtt levykkeit, kynnist",
  "asennus parametrilla /b.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Asennusohjelman mritysten mukaan tietokoneen suoritin ei ole 80486 tai",
  "uudempi. Windows XP:t ei voi kytt tietokoneessa.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Ohjelmaa ei voi kynnist Windowsin 32-bittisess versiossa.",
  DntEmptyString,
  "Kyt WINNT32.EXE-ohjelmaa.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Asennusohjelman mukaan tietokoneessa ei ole riittvsti muistia",
  "Windows XP:lle.",
  DntEmptyString,
  "Muistia tarvitaan: %lu%s megatavua",
  "Muistia havaittu:  %lu%s megatavua",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Olet pyytnyt asennusohjelmaa poistamaan Windows XP -tiedostot",
    "alla olevasta kansiosta. Kansiossa oleva Windows XP poistetaan",
    "pysyvsti.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Poistu asennusohjelmasta poistamatta tiedostoja painamalla F3.",
    "  Poista Windows XP -tiedostot kansiosta painamalla X.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Asennus ei voi avata alla mainittua asennuksen lokitiedostoa.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Asennus ei voi poistaa Windows XP -tiedostoja mritetyst kansiosta.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Asennus ei lyd osaa %s alla mainitusta",
  "asennuslokitiedostosta.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Asennus ei voi poistaa Windows XP -tiedostoja mritetyst kansiosta.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Odota. Asennusohjelma poistaa Windows XP -tiedostoja.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Asennus ei voinut asentaa Windows XP -kynnistyslatausta.",
  DntEmptyString,
  "Varmista, ett asema C on alustettu ja ettei se ole",
  "vioittunut.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Komentorivivalitsimen /u mrittm komentotiedostoa",
  "ei voitu kytt.",
  DntEmptyString,
  "Toimintoa ei voi jatkaa.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Komentorivivalitsimen /u mrittm komentotiedosto",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "sislt syntaksivirheen rivill %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Sisinen asennusvirhe.",
  DntEmptyString,
  "Knnetyt kynnistyssanomat ovat liian pitki.",
  NULL
  }
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Sisinen asennusvirhe.",
  DntEmptyString,
  "Sivutustiedostolle ei ole tilaa.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Asennusohjelma ei lytnyt SmartDrive tietokoneestasi. SmartDrive",
  "nopeuttaa huomattavasti asentamista tss asennuksen vaiheessa.",
  DntEmptyString,
  "Lopeta asennusohjelma nyt, kynnist SmartDrive ja kynnist asennus",
  "uudelleen. Saat listietoja SmartDrive-ohjelmasta DOSin ohjeista.",
  DntEmptyString,
    "  Lopeta asennus painamalla F3.",
    "  Jatka suorittamatta SmartDrive-ohjelmaa painamalla ENTER.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR puuttuu";
CHAR BootMsgDiskError[] = "Levyvirhe";
CHAR BootMsgPressKey[] = "Kynnist painamalla jotain nppint";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\hu\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Korbbi opercis rendszer a C meghajtn: ";

CHAR DntBootIniLine[] = "Windows XP telepts/frissts";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP - telepts\n ";
CHAR DntPersonalHeader[]      = "\n Windows XP Home Edition - telepts\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional - telepts\n ";
CHAR DntServerHeader[]        = "\n Windows 2002 Server - telepts\n ";
CHAR DntParsingArgs[]         = "Argumentumok feldolgozsa...";
CHAR DntEnterEqualsExit[]     = "ENTER=Kilps";
CHAR DntEnterEqualsRetry[]    = "ENTER=Ismt";
CHAR DntEscEqualsSkipFile[]   = "ESC=Fjl kihagysa";
CHAR DntEnterEqualsContinue[] = "ENTER=Folytats";
CHAR DntPressEnterToExit[]    = "A telepts nem folytathat. Az ENTER-t megnyomva kilp a programbl.";
CHAR DntF3EqualsExit[]        = "F3=Kilps";
CHAR DntReadingInf[]          = "INF-fjl olvassa: %s...";
CHAR DntCopying[]             = "       Msols: ";
CHAR DntVerifying[]           = " Visszaolvass: ";
CHAR DntCheckingDiskSpace[]   = "Szabad hely keresse a lemezen...";
CHAR DntConfiguringFloppy[]   = "Hajlkonylemez konfigurlsa...";
CHAR DntWritingData[]         = "Teleptsi paramterek rsa...";
CHAR DntPreparingData[]       = "Teleptsi paramterek megllaptsa...";
CHAR DntFlushingData[]        = "Adatok lemezre rsa...";
CHAR DntInspectingComputer[]  = "A szmtgp vizsglata...";
CHAR DntOpeningInfFile[]      = "INF-fjl megnyitsa...";
CHAR DntRemovingFile[]        = "Fjl trlse: %s";
CHAR DntXEqualsRemoveFiles[]  = "X=A fjlok trlse";
CHAR DntXEqualsSkipFile[]     = "X=A fjl kihagysa";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "A Windows 2002 Server vagy Windows XP Professional opercis rendszer teleptse",
    "",
    "",
    "WINNT [/s[:]forrs] [/t[:]ideiglenes_meghajt]",
    "      [/u[:vlaszfjl]] [/udf:azonost[,UDF_fjl]]",
    "      [/r:mappa] [/r[x]:mappa] [/e:parancs] [/a]",
    "",
    "",
    "/s[:]forrs",
    "   A Windows-fjlok helye.",
    "   Teljes elrsi tnak kell lennie, vagy x:[elrsi t] vagy",
    "   \\\\kiszolgl\\megosztsnv[elrsi t] formban.",
    "",
    "/t[:]ideiglenes_meghajt",
    "   A telepts tmeneti fjljait trol meghajt neve.",
    "   Ha nem ad meg semmit, a program magtl prbl tallni egyet.",
    "",
    "/u[:vlaszfjl]",
    "   Felgyelet nlkli telepts vlaszfjlbl. (A /s kapcsolt is meg",
    "   kell adni.) A vlaszfjl a telepts sorn bekrt adatok egy rszt",
    "   vagy egszt tartalmazza.",
    "",
    "/udf:azonost[,UDF_fjl] ",
    "   Olyan azonostt jelez, amely megadja, hogy a rendszer a telepts sorn",
    "   az egyedi adatbzis segtsgvel hogyan mdostsa a vlaszfjlt (lsd: /u).",
    "   A /udf paramter fellrja a vlaszfjlban megadott rtkeket, s ez",
    "   az azonosthatrozza meg, hogy az UDF mely rtke legyen hasznlva.",
    "   Ha nem ad meg UDF_fjlt, a rendszer bekri a $Unique$.udb fjlt tartalmaz",
    "   hajlkonylemezt.",
    "",
    "/r[:mappa]",
    "   Egy vlaszthat teleptsi mappt ad meg. A mappa megmarad a telepts utn.",
    "",
    "/rx[:mappa]",
    "   Egy vlaszthat msolsi mappt ad meg. A mappt a rendszer a telepts",
    "   utn trli.",
    "",
    "/e:parancs A telepts befejezse utn vgrehajtand parancs.",
    "",
    "/a Kisegt lehetsgek engedlyezse.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "A Windows XP opercis rendszer teleptse",
    "",
    "WINNT [/S[:]forrs] [/T[:]ideiglenes_meghajt] [/I[:]INF_fjl]",
    "      [[/U[:parancsfjl]]",
    "      [/R[X]:knyvtr] [/E:parancs] [/A]",
    "",
    "/D[:]winnt_gykr",
    "      Ez a kapcsol a program jelen verzijban nem hasznlhat.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Elfogyott a memria. A telepts nem folytathat.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Vlassza ki a telepteni kvnt segdprogramokat:",
    DntEmptyString,
    "[ ] F1 - Microsoft Nagyt",
#ifdef NARRATOR
    "[ ] F2 - Microsoft Narrtor",
#endif
#if 0
    "[ ] F3 - Microsoft Kperny-billentyzet",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "A teleptshez meg kell adnia, hogy hol tallhatk a Windows XP fjljai.",
  "Adja meg a fjlok elrsi tjt.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A megadott elrsi t hibs, nem lehet elrni, vagy nem tallhatk rajta",
                   "a Windows XP teleptshez szksges fjlok. Adjon meg egy j elrsi",
                   "utat. A BACKSPACE gombbal trlheti a felesleges karaktereket.)",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "A teleptsi informcit tartalmaz INI-fjlt nem lehet beolvasni,",
                "vagy a fjl srlt. Keresse meg a rendszergazdt.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Az tmeneti fjlok trolsra megadott meghajt nem ltezik, vagy nincs",
  "rajta legalbb %u megabjt (%lu bjt) szabad hely.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "A Windows XP teleptshez egy legalbb %u megabjt (%lu bjt)",
   "szabad helyet tartalmaz ktet szksges. A lemezterlet egy rsze",
   "tmeneti fjlok trolsra fog szolglni. A ktetnek egy olyan",
   "merevlemezen kell elhelyezkednie, amit a Windows XP tmogat. A",
   "ktet nem lehet tmrtve.",
   DntEmptyString,
   "A rendszerben nem tallhat olyan meghajt, amely kielgti ezeket",
   "a kvetelmnyeket. ",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nincs elg hely a rendszerindt meghajtn (ez rendszerint a C:)",
  "a hajlkonylemezek nlkli teleptshez. Ehhez legalbb ",
  "3,5 MB (3 641 856 bjt) szabad helyre van szksg.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A teleptsi informcit tartalmaz fjl [%s] szakasza",
                       "hibs vagy hinyzik. Keresse meg a rendszergazdt.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Az albbi knyvtr nem hozhat ltre a clmeghajtn:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Vizsglja meg a meghajtt, hogy a megadott nven nem ltezik-e",
                       "mr egy msik fjl, ami megakadlyozza a knyvtr ltrehozst.",
                       "Vizsglja meg a meghajt kbeleit is.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Az albbi fjlt nem sikerlt tmsolni:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  Az ESC gomb megnyomsval figyelmen kvl hagyhatja a hibt",
   "   s folytathatja a teleptst.",
   "  Az F3 gomb megnyomsval kilphet a programbl.",
   DntEmptyString,
   "Megjegyzs: Ha figyelmen kvl hagyja a hibt, s folytatja a teleptst,",
   "            akkor ez a tovbbiakban jabb hibkhoz vezethet.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Az albbi fljrl a telepts sorn ksztett msolat",
   "nem egyezik az eredetivel. Ezt hlzati hiba, srlt",
   "hajlkonylemez, vagy ms hardverhiba okozhatta.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  Az ESC gomb megnyomsval figyelmen kvl hagyhatja a hibt",
   "   s folytathatja a teleptst.",
   "  Az F3 gomb megnyomsval kilphet a programbl.",
   DntEmptyString,
   "Megjegyzs: Ha figyelmen kvl hagyja a hibt, s folytatja a teleptst,", 
   "            akkor ez a tovbbiakban jabb hibkhoz vezethet.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "A hiba figyelmen kvl hagysa azt jelenti, hogy a program nem msolja",
   "t ezt a fjlt. Ez a funkci kpzett felhasznlknak val, akik tisztban",
   "vannak a hinyz rendszerfjlok lehetsges kvetkezmnyeivel.",
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  A fjl kihagyshoz nyomja meg az X gombot.",
   DntEmptyString,
   "Megjegyzs: ha kihagyja ezt a fjlt, a Windows XP sikeres",
   "            teleptse nem garantlhat.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Vrjon, amg a program trli a korbbi tmeneti fjlokat.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                  { "Vrjon, amg a program tmsolja a szksges fjlokat a lemezre.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                  { "Vrjon, amg a program tmsolja a fjlokat a hajlkonylemezre.",
                    NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "A teleptshez ngy res, formzott, nagykapacits hajlkonylemezre",
   "van szksg. Ezeket a lemezeket a tovbbiakban \"Windows XP",
   "teleptsi indtlemez,\" \"Windows XP 2. teleptsi lemez,",
   "\"Windows XP 3. teleptsi lemez\" s \"Windows XP 4.", 
   "teleptsi lemez.\" nven fogjk hvni.\"",
   DntEmptyString,
   "Helyezze be a ngy lemez egyikt az A: meghajtba.",
   "Ez lesz a \"Windows XP 4. teleptsi lemez.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "4. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "3. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "2. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "teleptsi indtlemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "A teleptshez ngy res, formzott, nagykapacits hajlkonylemezre",
   "van szksg. Ezeket a lemezeket a tovbbiakban \"Windows XP",
   "teleptsi indtlemez,\" \"Windows XP 2. teleptsi lemez,",
   "\"Windows XP 3. teleptsi lemez\" s \"Windows XP 4.", 
   "teleptsi lemez.\" nven fogjk hvni.",
   DntEmptyString,
   "Helyezze be a ngy lemez egyikt az A: meghajtba.",
   "Ez lesz a \"Windows XP 4. teleptsi lemez.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP 4.",
   "teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "3. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "2. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows XP",
   "teleptsi rendszerindt lemez\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "A meghajtba helyezett hajlkonylemez nem MS-DOS formtum.",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Ez a lemez nem nagykapacits, nem MS-DOS formtum, vagy hibs. ",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Nem sikerlt megllaptani a hajlkonylemezen tallhat szabad terlet ",
  "nagysgt. A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "A hajlkonylemez nem nagykapacits, vagy nem res. ",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Nem sikerlt rni a hajlkonylemez rendszerterletre. ",
  "A lemez alighanem hasznlhatatlan.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "A hajlkonylemez rendszerterlete nem olvashat vissza, vagy",
  "a visszaolvasssal kapott adatok nem egyeznek meg azzal, amit",
  "a program a telepts sorn idert.",
  DntEmptyString,
  "Ennek az albbi okai lehetnek:",
  DntEmptyString,
  "  A szmtgpen vrus van.",
  "  A hajlkonylemez srlt.",
  "  A hajlkonylemezes meghajt hardverhibs, vagy rosszul van belltva.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Nem sikerlt rni az A: meghajtban tallhat lemezre. A lemez ",
  "bizonyra megsrlt. Prblkozzon msik lemezzel.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    " A Windows XP teleptse nem kszlt el.                   ",
                    " Ha most kilp, akkor a Windows XP teleptsnek           ",
                    " befejezshez jra kell indtania a teleptsi programot. ",
                    "                                                           ",
                    "    A telepts folytatshoz nyomja meg az ENTER gombot. ",
                    "    A kilpshez nyomja meg az F3 gombot.                 ",
                    "ĺ",
                    "  F3=Kilps  ENTER=Folytats                              ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik.",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows XP teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "A szmtgp jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt.",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik.",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows XP teleptsi",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Ha van hajlkonylemez az A: meghajtban, akkor most tvoltsa el. ",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows XP teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt.",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows XP teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows XP teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Ha van hajlkonylemez az A: meghajtban, akkor most tvoltsa el. ",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Fjlok msolsa...                                             ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "A program a futtatshoz MS-DOS 5.0, vagy annl jabb verzira van szksg.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Az A: hajlkonylemezes meghajt nem ltezik, vagy kis kapacits. ",
  "A teleptshez 1.2 megabjtos, vagy annl nagyobb kapacits ",
  "meghajtra van szksg.",
#else
{ " Az A: hajlkonylemezes meghajt nem ltezik, vagy nem nagykapacits ",
  "3.5\" egysg. A hajlkonylemezes teleptshez az A: meghajtnak ",
  "legalbb 1.44 megabjt kapacitsnak kell lennie. ",
  DntEmptyString,
  "Ha hajlkonylemezek ksztse nlkl kvnja telepteni a Windows XP",
  "opercis rendszert, akkor indtsa jra a programot a /b kapcsolval.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "A szmtgp processzora nem i80486, vagy ennl jabb. ",
  "A Windows XP nem futtathat ezen a szmtgpen.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "A Winnt.exe nem hasznlhat semmilyen 32 bites verzij Windows esetn.",
  DntEmptyString,
  "Hasznlja helyette a winnt32.exe programot.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Ebben a szmtgpben nincs elg memria a Windows XP futtatshoz",
  DntEmptyString,
  "         Szksges memria: %lu%s MB",
  "Rendelkezsre ll memria: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "A program az albbi knyvtrban tallhat Windows XP fjljainak",
    "trlsre kszl. Az ebben a knyvtrban teleptett Windows-telepts",
    "vgleg megsemmisl.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Ha megnyomja az F3 gombot, a fjlok trlse nlkl kilp a programbl.",
    "  Ha megnyomja az X gombot, a program trli a Windows fjljait",
    "   a fenti knyvtrbl.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Nem sikerlt megnyitni az albbi teleptsi naplfjlt.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A megadott knyvtrbl nem lehet trlni a Windows fjljait.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Az albbi teleptsi naplfjl %s szakasza nem tallhat.",
  "  ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A megadott knyvtrbl nem lehet trlni a Windows fjljait.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vrjon, amg a program trli a Windows fjljait.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Nem sikerlt telepteni a Windows rendszerindt (Boot Loader) programot.",
  DntEmptyString,
  "Vizsglja meg, hogy a C: meghajt meg van-e formzva, s hogy nem srlt-e.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "A /u kapcsolval megadott parancsfjlt ",
  "nem lehet elrni.",
  DntEmptyString,
  "A felgyelet nlkli telepts nem hajthat vgre.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "A /u kapcsolval megadott parancsfjl",
   DntEmptyString,
   "%s",
   DntEmptyString,
   "szintaktikai hibt tartalmaz a %u. sorban.",
   DntEmptyString,
   NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Rendszerteleptsi hiba trtnt.",
  DntEmptyString,
  "A fordtsok tl hosszak.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Rendszerteleptsi hiba trtnt.",
  DntEmptyString,
  "Nem tallhat hely a lapozfjl szmra.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "A rendszer nem tallja a szmtgpen a SmartDrive programot.",
  "A SmartDrive hasznlata sokkal hatkonyabb teszi a telepts ezen",
  "szakasznak teljestmnyt.",
  DntEmptyString,
  "Most lpjen ki, indtsa el a SmartDrive-ot, majd indtsa jra a teleptst.",
  "Nzze meg a DOS-dokumentciban a SmartDrive programot.",
  DntEmptyString,
    "  A kilpshez nyomja meg az F3 gombot.",
    "  A Telepts SmartDrive nlkli folytatshoz nyomja le az Enter gombot.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Hinyz NTLDR";
CHAR BootMsgDiskError[] = "Lemezhiba";
CHAR BootMsgPressKey[] = "Nyomjon le egy gombot";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\nl\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\jpn\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

#ifdef NEC_98
CHAR DnfBackupFiles_PC98[]  = "BackupFiles_PC98";
#endif // NEC_98


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows XP Installation/Upgrade";

//
// Plain text, status msgs.
//

#ifdef NEC_98
CHAR DntStandardHeader[]      = "\n Windows XP ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntPersonalHeader[]      = "\n Windows XP Personal ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntServerHeader[]        = "\n Windows 2002 Server ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
#else // NEC_98
CHAR DntStandardHeader[]      = "\n Windows XP ZbgAbv\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Personal ZbgAbv\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional ZbgAbv\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server ZbgAbv\n";
#endif // NEC_98
CHAR DntParsingArgs[]         = "𒲂ׂĂ܂...";
CHAR DntEnterEqualsExit[]     = "Enter=I";
CHAR DntEnterEqualsRetry[]    = "Enter=Ďs";
CHAR DntEscEqualsSkipFile[]   = "ESC=XLbv";
CHAR DntEnterEqualsContinue[] = "Enter=s";
CHAR DntPressEnterToExit[]    = "ZbgAbv𑱍sł܂BEnter L[ĂB";
CHAR DntF3EqualsExit[]        = "F3=I";
CHAR DntReadingInf[]          = "INF t@C %s ǂݎĂ܂...";
CHAR DntCopying[]             = "Rs[: ";
CHAR DntVerifying[]           = "  : ";
CHAR DntCheckingDiskSpace[]   = "fBXN̈`FbNĂ܂...";
CHAR DntConfiguringFloppy[]   = "tbs[ fBXN\\Ă܂...";
CHAR DntWritingData[]         = "ZbgAbv p[^ł܂...";
CHAR DntPreparingData[]       = "ZbgAbv p[^𔻒fĂ܂...";
CHAR DntFlushingData[]        = "f[^fBXNɏł܂...";
CHAR DntInspectingComputer[]  = "Rs[^Ă܂...";
CHAR DntOpeningInfFile[]      = "INF t@CJĂ܂...";
CHAR DntRemovingFile[]        = "t@C %s 폜Ă܂";
CHAR DntXEqualsRemoveFiles[]  = "X=t@C̍폜";
CHAR DntXEqualsSkipFile[]     = "X=t@C̃XLbv";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows 2002 Server ܂ Windows XP Professional ̃ZbgAbvs܂B",
    "",
    "",
    "WINNT [/s[:\\[X pX]] [/t[:ꎞIȃhCu]]",
    "	   [/u[:t@C]] [/udf:ID [,UDF t@C]]",
    "	   [/r:tH_] [/r[x]:tH_] [/e:R}h] [/a]",
    "",
    "",
    "/s[:\\[X pX]",
    "	Windows t@C̊i[Ăꏊw肵܂B",
    "	x:[pX] ܂ \\\\T[o[\\L[pX] ̌`",
    "	t pXw肵Ȃ΂Ȃ܂B",
    "",
    "/t[:ꎞIȃhCu]",
    "	w肵hCuɈꎞt@Ci[āAWindows XP",
    "	̃hCuɃCXg[܂BhCuȗƁA",
    "	ZbgAbv vOK؂ȃhCu肵܂B",
    "",
    "/u[:t@C]",
    "	t@CgpĖlZbgAbvs܂ (/s IvV",
    "	Kvł)Bt@CƂ́AZbgAbv̊ԁAGh [U[",
    "	ʏɉmFbZ[Ẅꕔ܂ׂ͂Ăɑ΂鉞",
    "	邽߂̂̂łB",
    "",
    "/udf:ID [,UDF t@C]	",
    "	ʎq (ID) ɂӐf[^x[X t@C (UDF) ǂ̂悤",
    "	t@CύX邩w肵܂ (/u IvVQ)B",
    "	/udf p[^͉t@CɂlD悵܂Bʎq",
    "	UDF t@Ĉǂ̒lg邩肵܂BUDF t@Cw",
    "	ȂꍇA$Unique$.udb t@CfBXN}",
    "	悤ɋ߂܂B",
    "",
    "/r[:tH_]",
    "	CXg[IvV tH_w肵܂B",
    "	tH_̓ZbgAbvIc܂B",
    "",
    "/rx[:tH_]",
    "	Rs[IvV tH_w肵܂B",
    "	tH_̓ZbgAbvIA폜܂B",
    "",
    "/e	GUI [h̃ZbgAbv̍ŌɎsR}hw肵܂B",
    "",
    "/a	[U[⏕IvVgp\\ɂ܂B",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows XP CXg[܂B",
    "",
    "WINNT [/S[:]\\[X pX] [/T[:]ꎞIȃhCu] [/I[:]INF t@C]",
    "      [/U[:XNvg t@C]",
    "      [/R[X]:fBNg] [/E:R}h] [/A]",
    "",
    "/D:WinNT [g",
    "       ̃IvV̓T|[gĂ܂B",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "ŝ߁AZbgAbv𑱍sł܂B",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
//{   "CXg[郆[U[⏕[eBeBIł:",
{   "̃[U[⏕[eBeBCXg[邩ǂIł:",
    DntEmptyString,
    "[ ] Microsoft g勾́AF1 L[܂",
#if 0
    "[ ] Microsoft Narrator ́AF2 L[܂",
    "[ ] Microsoft On-Screen Keyboard ́AF3 L[܂",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Windows XP ̃t@Cǂɂ邩mKv܂B",
  "Windows XP ̃t@Ci[ĂpX͂ĂB",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "w肵pXAANZXł܂B܂́AWindows XP ",
                   "ZbgAbv vO܂BWindows XP ̃t@C",
                   "i[Ă鐳pX͂ĂBŏɓ͂",
                   "BackSpace L[ŏApX͂ĂB",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "ZbgAbvt@CǂݎȂAt@CĂ",
                "\\܂BVXeǗ҂ɑkĂB",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "ZbgAbv t@CꎞIɊi[邽߂Ɏw肵",
  "hCułB܂́A%u MB (%lu oCg) ȏ",
  "󂫃fBXN̈悪܂B",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP ɂ́AȂƂ %u MB (%lu oCg) ̃n[h fBXN",
   "hCű󂫗̈悪KvłBɂ́AZbgAbv vO",
   "CXg[ɎgpAꎞIȃt@C̊i[ɗvXy[X",
   "܂܂܂BgphCu Windows XP T|[g郍[J",
   "n[h fBXN hCułȂ΂Ȃ܂B܂AkhCu",
   "gpł܂B",
   DntEmptyString,
   "CXg[ɕKvȋ󂫗̈̂hCu܂łB",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "X^[gAbv hCu (ʏ C:) ɁAtbs[gpȂ",
  "ɕKvȗ̈悪܂Btbs[gpȂɂ́AȂ",
  "Ƃ 3.5 MB (3,641,856 oCg) ̋󂫗̈悪̃hCuɕKvłB",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "ZbgAbvt@C [%s] ZNV݂ȂA",
                       "܂͉Ă܂BVXeǗ҂ɑkĂB",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "ړĨhCuɎ̃fBNg쐬ł܂ł:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "hCu`FbNAړĨfBNgƓÕt@C",
                       "݂ȂƂmFĂB܂AfBXN hCu",
                       "P[uڑ`FbNĂB",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "̃t@CRs[ł܂łB",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "Rs[Ďsɂ́AEnter L[ĂB",
   "G[𖳎ăZbgAbv𑱍sɂ́AEsc L[",
   "ĂB",
   "ZbgAbvIɂ́AF3 L[ĂB",
   DntEmptyString,
   ": G[𖳎ăZbgAbv𑱍sꍇɂ́A",
   "ōēxG[\\܂B",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "ZbgAbvɂăRs[ꂽ̃t@ĆAIWi",
   "قȂĂ܂Blbg[NAtbs[ fBXNA邢͂",
   "̂ق̃n[hEFAɖ肪\\܂B",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "Rs[Ďsɂ́AEnter L[ĂB",
   "G[𖳎ăZbgAbv𑱍sɂ́AEsc L[",
   "ĂB",
   "ZbgAbvIɂ́AF3 L[ĂB",
   DntEmptyString,
   ": G[𖳎ăZbgAbv𑱍sꍇɂ́A",
   "ōēxG[\\܂B",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "G[𖳎ƁÃt@C̓Rs[܂B̃Iv",
   "V́AVXe t@C݂ȂƂ̉eł",
   "[U[łB",
   DntEmptyString,
   "Rs[Ďsɂ́AEnter L[ĂB",
   "̃t@CXLbvɂ́AX L[ĂB",
   DntEmptyString,
   ": t@CXLbvꍇɂ́AWindows XP ̃CXg[",
   "܂̓AbvO[hSɍsۏ؂͂ł܂B",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "ꎞIȃt@C폜Ă܂B΂炭҂B",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "n[h fBXNɃt@CRs[܂B΂炭҂B",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "tbs[ fBXNɃt@CRs[܂B΂炭҂B",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "4 ̃tH[}bgς݂̋̍xtbs[ fBXNKvłB",
   "4 ̃fBXN \"Windows XP ZbgAbv u[g fBXN\"A",
   "\"Windows XP ZbgAbv fBXN #2\"A",
   "\"Windows XP ZbgAbv fBXN #3\"A",
   "\"Windows XP ZbgAbv fBXN #4\" ƌĂ΂܂B",
   DntEmptyString,
#ifdef NEC_98
   "ꂩ̃fBXNtbs[ fBXNu 1 ڂɑ}Ă",
   "B̃fBXN \"Windows XP ZbgAbv fBXN #4\"",
   "ɂȂ܂B",
#else // NEC_98
   "ꂩ̃fBXNhCu A: ɑ}ĂB̃fBXN",
   " \"Windows XP ZbgAbv fBXN #4\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #4\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv",
   "fBXN #4\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #3\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP Zbg Abv",
   "fBXN #3\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #2\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv",
   "fBXN #2\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv u[g fBXN\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv",
   "u[g fBXN\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "4 ̃tH[}bgς݂̋̍xtbs[ fBXNKvłB",
   "4 ̃fBXN \"Windows XP ZbgAbv u[g fBXN\"A",
   "\"Windows XP ZbgAbv fBXN #2\"A",
   "\"Windows XP ZbgAbv fBXN #3\"A",
   "\"Windows XP ZbgAbv fBXN #4\" ƌĂ΂܂B",
   DntEmptyString,
#ifdef NEC_98
   "ꂩ̃fBXNtbs[ fBXNu 1 ڂɑ}Ă",
   "B̃fBXN \"Windows XP ZbgAbv fBXN #4\" ",
   "Ȃ܂B",
#else // NEC_98
   "ꂩ̃fBXNhCu A: ɑ}ĂB̃fBXN",
   " \"Windows XP ZbgAbv fBXN #4\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #4\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv",
   "fBXN #4\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #3\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv ",
   "fBXN #3\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv fBXN #2\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv ",
   "fBXN #2\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 ڂɃtH[}bgς݂̖gpx",
   "tbs[ fBXN}ĂB̃fBXN \"Windows",
   "XP ZbgAbv u[g fBXN\" ɂȂ܂B",
#else // NEC_98
{  "hCu A: ɃtH[}bgς݂̋̍xtbs[ fBXN",
   "}ĂB̃fBXN \"Windows XP ZbgAbv ",
   "u[g fBXN\" ɂȂ܂B",
#endif // NEC_98
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "hCuɑ}Ătbs[ fBXN MS-DOS ",
  "tH[}bgĂȂ߁Agpł܂B",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "̃tbs[ fBXN͎gpł܂BxtH[}bg",
  "܂ MS-DOS ̕WtH[}bgł͂ȂAĂ\\",
  "܂B",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "}ꂽtbs[ fBXN̋󂫗̈𔻒fł܂B",
  "̃fBXN͎gpł܂B",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "}ꂽtbs[ fBXN͍x^Cvł͂ȂA",
  "ł͂܂B̃fBXN͎gpł܂B",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "}ꂽtbs[ fBXÑVXëɏ݂",
  "ł܂B̃fBXN͎gpłȂ\\܂B",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "tbs[ fBXÑVXë悩ǂݎf[^",
  "܂ꂽf[^ƈvĂȂA܂̓tbs[ fBXN",
  "VXë邽߂ɓǂݎ邱Ƃł܂B",
  DntEmptyString,
  "̌l܂B",
  DntEmptyString,
  " Rs[^EBXɊĂB",
  " tbs[ fBXNĂB",
  " tbs[ fBXN hCuɃn[hEFA܂͍\\̖肪B",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
#ifdef NEC_98
{ "tbs[ fBXNu 1 ڂ̃tbs[ fBXNւ݂̏",
  "s܂B̃tbs[ fBXN͑Ă\\",
  "܂Bʂ̃tbs[ fBXNŎsĂB",
#else // NEC_98
{ "hCu A: ̃tbs[ fBXNւ݂̏Ɏs܂B",
  "tbs[ fBXN͑Ă\\܂Bʂ̃tbs[ ",
  "fBXNŎsĂB",
#endif // NEC_98
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 6,6,
#ifdef NEC_98
                  { "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
                    "E     Windows XP Sɂ͐ݒ肳Ă܂B                  E",
                    "E     ŃZbgAbvIꍇ́AŃZbgAbv     E",
                    "E     Ďs Windows XP ݒ肵Ȃ΂Ȃ܂B         E",
                    "E                                                                E",
                    "E      ZbgAbv𑱍sɂ́AEnter L[ĂB E",
                    "E      ZbgAbvIɂ́AF3 L[ĂB    E",
                    "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
                    "E F3=I  Enter=s                                            E",
                    "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
#else // NEC_98
                  { "",
                    "     Windows XP Sɂ͐ݒ肳Ă܂B                   ",
                    "     ŃZbgAbvIꍇ́AŃZbgAbv      ",
                    "     Ďs Windows XP ݒ肵Ȃ΂Ȃ܂B          ",
                    "                                                                 ",
                    "      ZbgAbv𑱍sɂ́AEnter L[ĂB  ",
                    "      ZbgAbvIɂ́AF3 L[ĂB     ",
                    "-----------------------------------------------------------------",
                    "  F3=I  Enter=s                                            ",
                    "",
#endif // NEC_98
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BċNAZbgAbv vO̓CXg[",
  "s܂B",
  DntEmptyString,
  "ZbgAbv vO쐬 \"Windows XP ZbgAbv",
#ifdef NEC_98
  "u[g fBXN\" tbs[ fBXNu 1 ڂɑ}",
  "B",
#else // NEC_98
  "u[g fBXN\" hCu A: ɑ}ĂB",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ƃRs[^ċNăZbgAbv𑱍s܂B",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BRs[^̍ċNAWindows XP ZbgAbv",
  "s܂B",
  DntEmptyString,
  "ZbgAbv vO쐬 \"Windows XP ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 ڂɑ}ĂB",
#else // NEC_98
  "fBXN\" hCu A: ɑ}ĂB",
#endif // NEC_98
  DntEmptyString,
  "łAEnter L[ĂB",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BRs[^̍ċNAWindows XP ZbgAbv",
  "s܂B",
  DntEmptyString,
#ifdef NEC_98
  "tbs[ fBXNu 1 ڂɃtbs[ fBXN}Ă",
  "ꍇ́AoĂB",
#else // NEC_98
  "hCu A: Ƀtbs[ fBXN}Ăꍇ́Ao",
  "B",
#endif // NEC_98
  DntEmptyString,
  "łAEnter L[ĂB",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BRs[^̍ċNAWindows XP ZbgAbv",
  "s܂B",
  DntEmptyString,
  "ZbgAbv vO쐬 \"Windows XP ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 ڂɑ}",
  "B",
#else // NEC_98
  "fBXN\" hCu A: ɑ}ĂB",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ɖ߂ARs[^ċN",
  "Windows XP ZbgAbv𑱍sĂB",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BRs[^̍ċNAWindows XP ZbgAbv",
  "s܂B",
  DntEmptyString,
  "ZbgAbv vO쐬 \"Windows XP ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 ڂɑ}ĂB",
#else // NEC_98
  "fBXN\" hCu A: ɑ}ĂB",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ɖ߂ARs[^ċN ",
  "Windows XP ZbgAbv𑱍sĂB",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "ZbgAbv vO MS-DOS s͊܂BRs[^",
  "ċN܂BRs[^̍ċNAWindows XP ZbgAbv",
  "s܂B",
  DntEmptyString,
#ifdef NEC_98
  "tbs[ fBXNu 1 ڂɃtbs[ fBXN}Ă",
  "ꍇ́AoĂB",
#else // NEC_98
  "hCu A: Ƀtbs[ fBXN}Ăꍇ́Ao",
  "B",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ɖ߂ARs[^ċN ",
  "Windows XP ZbgAbv𑱍sĂB",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
#ifdef NEC_98
             { "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
               "E t@CRs[Ă܂...                                E",
               "E                                                              E",
               "E    EEEEEEEEEEEEEEEEEEEEEEEEEEE    E",
               "E    E                                                  E    E",
               "E    EEEEEEEEEEEEEEEEEEEEEEEEEEE    E",
               "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
#else // NEC_98
             { "",
               " t@CRs[Ă܂...                                  ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
#endif // NEC_98
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "̃vOsɂ́AMS-DOS Version 5.0 ",
  "܂͂ȍ~KvłB",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
#ifdef NEC_98
{ "tbs[ fBXNu 1 ڂᖧxhCuł邩A",
  "݂܂BZbgAbv vO̎sɂ́A1.25 MB",
#else // NEC_98
{ "tbs[ fBXN hCu A: ᖧxhCuł邩A",
  "݂܂BZbgAbv vO̎sɂ́A1.2 MB",
#endif // NEC_98
  "܂͂ȏ̗̈̃hCuKvłB",
#else
#ifdef NEC_98
{ "tbs[ fBXNu 1 ڂx 3.5 C` hC",
  "uł͂ȂA݂܂Btbs[gpZbg",
  "Abvɂ́A1.25 MB ܂͂ȏ̗eʂ̃tbs[",
  "fBXNuKvłB",
#else // NEC_98
{ "tbs[ fBXN hCu A: x 3.5 C` h",
  "Cuł͂ȂA݂܂Btbs[gpZbg",
  "Abvɂ́A1.44 MB ܂͂ȏ̗̈ A: hCu",
  "KvłB",
#endif // NEC_98
  DntEmptyString,
  "tbs[gpȂ Windows XP CXg[ɂ́A",
  "̃vO /B XCb`w肵ăR}h C",
  "ċNĂB",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "̃Rs[^ɂ́A80486 ܂͂ȏ CPU ",
  "Ă܂BWindows XP ̃Rs[^Ŏs",
  "Ƃ͂ł܂B",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "̃vO 32 rbg o[W Windows ł͓삵܂B",
  DntEmptyString,
  "ɁAWINNT32.EXE gĂB",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "̃Rs[^ɂ́AWindows XP ̃CXg[s",
  "̂ɏ\\ȃ܂B",
  DntEmptyString,
  "Kvȃe:   %lu%s MB",
  "oe: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "̃fBNg Windows XP ̃t@C폜܂B",
    "̃fBNgɂ Windows XP ͊Sɏ܂B",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "F3 L[ƁAt@C폜ɃZbgAbvI",
    "܂BX L[ƁÃfBNg Windows ",
    "t@C폜܂B",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "̃ZbgAbv O t@CJ܂B",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "w肳ꂽfBNg Windows t@C폜ł܂B",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "̃ZbgAbv O t@C %s ZNV܂B",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "w肳ꂽfBNg Windows t@C폜ł܂B",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "      Windows t@C폜Ă܂B΂炭҂B",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Windows u[g [_[CXg[ł܂łB",
  DntEmptyString,
#ifdef NEC_98
  "%s: hCutH[}bgĂ邩AhCuĂȂ",
#else // NEC_98
  "C: hCutH[}bgĂ邩AhCuĂȂ",
#endif // NEC_98
  "mFĂB",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "/U IvVŎw肳ꂽXNvg t@CɃANZXł܂",
  "łB",
  DntEmptyString,
  "lZbgAbv𑱍sł܂B",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "/U IvVŎw肳ꂽXNvg t@C",
  DntEmptyString,
  "%s",
  DntEmptyString,
  " %u sڂɍ\\G[܂B",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "ZbgAbv G[܂B",
  DntEmptyString,
  "{̃u[g bZ[W܂B",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "ZbgAbv G[܂B",
  DntEmptyString,
  "Xbv t@C̏ꏊ܂łB",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Rs[^ SmartDrive o܂łBSmartDrive ɂA",
  "̃tF[ỸZbgAbṽptH[}X啝Ɍł܂B",
  DntEmptyString,
  "ZbgAbvI SmartDrive NĂAZbgAbv",
  "ċNĂB",
  "SmartDrive ̏ڍׂɂĂ DOS ̃hLgQƂĂB",
  DntEmptyString,
    "ZbgAbvIɂ́AF3 L[ĂB",
    "SmartDrive g킸ɃZbgAbv𑱍sɂ́A",
    "Enter L[ĂB",
  NULL
}
};


//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";

#ifdef NEC_98
SCREEN
FormatError = { 3,5,
{ "ZbgAbv t@CꎞIɊi[邽߂Ɍ",
  "hCu 256 ZN^ŃtH[}bgĂ邩܂́A",
  "n[hfBXNł͂܂B",
  "",
  "/T IvVɂāAꎞIɃZbgAbv t@Ci[",
  "hCuw肵ĂB",
  NULL
}
};
#endif // NEC_98

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

CFOPT=-DJAPAN -DDOS_V

# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Japanese.

CFOPT=$(CFOPT) -DLCP

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\no\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\ger\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Vorheriges Betriebssystem auf Laufwerk C:";

CHAR DntBootIniLine[] = "Installation/Update von Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Personal Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional Setup\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server Setup\n";
CHAR DntParsingArgs[]         = "Argumente werden analysiert...";
CHAR DntEnterEqualsExit[]     = "EINGABE=Beenden";
CHAR DntEnterEqualsRetry[]    = "EINGABE=Erneut versuchen";
CHAR DntEscEqualsSkipFile[]   = "ESC=Datei auslassen";
CHAR DntEnterEqualsContinue[] = "EINGABE=Weiter";
CHAR DntPressEnterToExit[]    = "Setup muss beendet werden. Bitte EINGABETASTE drcken.";
CHAR DntF3EqualsExit[]        = "F3=Beenden";
CHAR DntReadingInf[]          = "INF-Datei %s wird gelesen...";
CHAR DntCopying[]             = "  Datei: ";
CHAR DntVerifying[]           = "  Datei: ";
CHAR DntCheckingDiskSpace[]   = "Speicherplatz wird berprft...";
CHAR DntConfiguringFloppy[]   = "Setup-Diskette wird konfiguriert...";
CHAR DntWritingData[]         = "Setup-Parameter wird geschrieben...";
CHAR DntPreparingData[]       = "Setup-Parameter wird ermittelt...";
CHAR DntFlushingData[]        = "Daten werden auf Setup-Diskette geschrieben...";
CHAR DntInspectingComputer[]  = "Computer wird untersucht...";
CHAR DntOpeningInfFile[]      = "INF-Datei wird geffnet...";
CHAR DntRemovingFile[]        = "Datei %s wird gelscht.";
CHAR DntXEqualsRemoveFiles[]  = "L=Dateien lschen";
CHAR DntXEqualsSkipFile[]     = "A=Datei auslassen";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'l',
      DniAccelRemove2 = (ULONG)'L';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'a',
      DniAccelSkip2 = (ULONG)'A';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installiert Windows 2002 Server oder Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:Quellpfad]] [/t[:Temporrlaufwerk]]",
    "      [/u[:Antwortdatei]] [/udf:Kennung[,UDF-Datei]]",
    "      [/r:Ordner] [/r[x]:Ordner] [/e:Befehl] [/a]",
    "",
    "",
    "/s[:Quellpfad]",
    "   Gibt an, wo sich die Windows-Dateien befinden.",
    "   Es muss ein vollstndiger Pfad in der Form x:[Pfad] oder ",
    "   \\\\Server\\Freigabe[Pfad] angegeben werden.",
    "",
    "/t[:Temporrlaufwerk]",
    "   Weist Setup an, die temporren Dateien auf dem angegebenen",
    "   Laufwerk zu speichern und Windows XP dort zu installieren.",
    "   Wenn kein Laufwerk angegeben wird, versucht Setup ein geeignetes ",
    "   Laufwerk zu bestimmen.",
    "",
    "/u[:Antwortdatei]",
    "   Fhrt eine unbeaufsichtigte Installation mithilfe einer Antwortdatei",
    "   durch (erfordert /s). Die Antwortdatei enthlt einige oder alle",
    "   Antworten zu Anfragen, die der Benutzer normalerweise whrend der",
    "   Installation beantwortet.",
    "",
    "/udf:Kennung[,UDF-Datei] ",
    "   Legt eine Kennung fest, die angibt, wie eine UDF-Datei",
    "   (Uniqueness Database File) eine Antwortdatei verndert (siehe /u).",
    "   Der Parameter /udf berschreibt Werte in der Antwortdatei und die",
    "   Kennung bestimmt, welche Werte der UDF-Datei zu verwenden sind.",
    "   Wird keine UDF-Datei angegeben, fordert Setup zum Einlegen",
    "   einer Diskette mit der Datei \"$Unique$.udb\" auf.",
    "",
    "/r[:Ordner]",
    "   Gibt einen optionalen Ordner an, der kopiert werden soll.",
    "   Der Ordner bleibt nach Abschluss der Installation erhalten.",
    "",
    "/rx[:Ordner]",
    "   Gibt einen optionalen Ordner an, der kopiert werden soll.",
    "   Der Ordner wird nach Abschluss der Installation gelscht.",
    "",
    "/e Legt einen Befehl fest, der nach Abschluss des im Grafikmodus",
    "   durchgefhrten Teils der Installation ausgefhrt werden soll.",
    "",
    "/a Aktiviert Optionen fr Eingabehilfen.",
    NULL
};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installieren von Windows XP",
    "",
    "WINNT [/s[:]Quellpfad]  [/t[:]Temporrlaufwerk]  [/i[:]INF-Datei]",
    "      [/u[:Antwortdatei]]",
    "      [/r[x]:Verzeichnis] [/e:Befehl] [/a]",
    "",
    "/d[:]NT-Verzeichnis",
    "       Diese Option wird nicht mehr untersttzt.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Nicht gengend Arbeitsspeicher. Setup kann nicht fortgesetzt werden.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Geben Sie an, ob Sie die folgende Eingabehilfe installieren mchten:",
    DntEmptyString,
    "[ ] Drcken Sie die F1-TASTE fr Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Drcken Sie die F2-TASTE fr Microsoft Narrator",
#endif
#if 0
    "[ ] Drcken Sie die F3-TASTE fr Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Geben Sie den Pfad fr das Verzeichnis ein, in dem sich die ",
  "Windows XP-Dateien befinden.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Die angegebene Quelle ist unzulssig, nicht zugreifbar oder enthlt",
                   "keine zulssige Windows XP Setup-Installation. Geben Sie einen neuen",
                   "Pfad ein, in dem sich die Windows XP-Dateien befinden. Verwenden Sie",
                   "die RCKTASTE zum Lschen von Zeichen, und geben Sie dann den Pfad ein.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Setup konnte die INF-Datei nicht lesen, oder die INF-Datei ",
                "ist beschdigt. Wenden Sie sich an den Systemadministrator.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{  "Die zur Speicherung der temporren Setup-Dateien angegebene Festplatte",
   "ist keine zulssige Festplatte oder hat nicht mindestens %u MB ",
   "(%lu Bytes) freien Speicherplatz.",
   NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{ "Windows XP bentigt ein Laufwerk mit mindestens %u MB (%lu Bytes)",
  "freiem Speicherplatz. Setup verwendet Teile dieses Speicherplatzes, um die",
  "temporren Dateien whrend der Installation zu speichern. Dieses Laufwerk",
  "muss sich auf einer lokalen Festplatte befinden, die von Windows XP",
  "untersttzt wird und nicht komprimiert ist.",
  DntEmptyString,
  "Setup konnte kein Laufwerk mit dem erforderlichen freien Speicherplatz",
  "finden.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Es liegt nicht gengend Speicherplatz auf dem Startlaufwerk ",
  "(gewhnlich Laufwerk C:) vor, um die Installation ohne Disketten",
  "durchzufhren. Fr die Installation ohne Disketten ist min-",
  "destens 3,5 MB (3.641.856 Bytes) freier Speicherplatz auf diesem",
  "Laufwerk erforderlich.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Der Abschnitt [%s] der Setup-INF-Datei ist nicht vorhanden",
                       "oder unbrauchbar. Wenden Sie sich an den Systemadministrator.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Setup konnte folgendes Verzeichnis nicht auf dem ",
                       "Ziellaufwerk erstellen:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "berprfen Sie das Ziellaufwerk und stellen Sie sicher, ",
                       "dass keine Dateien existieren, deren Namen mit dem ",
                       "Ziellaufwerk bereinstimmen. berprfen Sie auerdem die ",
                       "Kabelverbindungen zum Laufwerk.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup konnte folgende Datei nicht kopieren:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die ESC-TASTE, um den Fehler zu ignorieren und Setup ",
   "   fortzusetzen.",
   "  Drcken Sie die F3-TASTE, um Setup zu beenden.",
   DntEmptyString,
   "Hinweis: Falls Sie den Fehler ignorieren und Setup fortsetzen, knnen ",
   "         im weiteren Verlauf der Installation Fehler auftreten.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Die von Setup erstellte Kopie der unten angezeigten Datei stimmt nicht ",
   "mit dem Original berein. Dies kann durch Netzwerkprobleme, Disketten-",
   "probleme oder andere Hardwareprobleme verursacht worden sein.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die ESC-TASTE, um den Fehler zu ignorieren und Setup ",
   "   fortzusetzen.",
   "  Drcken Sie die F3-TASTE, um Setup zu beenden.",
   DntEmptyString,
   "Hinweis: Falls Sie den Fehler ignorieren und Setup fortsetzen, knnen ",
   "         im weiteren Verlauf der Installation Fehler auftreten.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Falls Sie den Fehler ignorieren, wird diese Datei nicht kopiert.",
   "Diese Option ist fr erfahrene Benutzer, die sich ber die ",
   "Auswirkungen von fehlenden Systemdateien im Klaren sind.",
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die A-TASTE, um die Datei auszulassen.",
   DntEmptyString,
   "Hinweis: Falls Sie diese Datei auslassen, kann Setup kein ",
   "         erfolgreiches Aktualisieren oder Installieren von",
   "         Windows XP garantieren.",
  NULL
}
};


//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Bitte warten Sie, whrend Setup alte temporre Dateien entfernt.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Bitte warten Sie, whrend Setup die Dateien in ein ",
                     "temporres Verzeichnis auf der Festplatte kopiert.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Bitte warten Sie, whrend Setup die ",
                     "Dateien auf die Diskette kopiert.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//


SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Zur Durchfhrung des Setups bentigen Sie vier leere, formatierte ",
   "HD-Disketten. Setup wird diese Disketten als \"Windows XP",
   "Setup-Startdiskette\", \"Windows XP Setup-Diskette 2\",",
   "\"Windows XP Setup-Diskette 3\" und \"Windows XP",
   "Setup-Diskette 4\" bezeichnen.",
   DntEmptyString,
   "Legen Sie eine der vier Disketten in Laufwerk A: ein. Diese",
   "Diskette wird spter als \"Windows XP Setup-Diskette 4\"",
   "bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows XP Setup-",
      "Diskette 4\" bezeichnet.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows XP Setup-",
      "Diskette 3\" bezeichnet.",
        NULL
        }
        };

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows XP Setup-",
   "Diskette 2\" bezeichnet.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows XP Setup-",
   "Startdiskette\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Zur Durchfhrung des Setups bentigen Sie vier leere, formatierte ",
   "HD-Disketten. Setup wird diese Disketten als \"Windows XP",
   "Setup-Startdiskette\", \"Windows XP Setup-Diskette 2\",",
   "\"Windows XP Setup-Diskette 3\" und \"Windows XP",
   "Setup-Diskette 4\" bezeichnen.",
   DntEmptyString,
   "Legen Sie eine der vier Disketten in Laufwerk A: ein. Diese Dis-",
   "kette wird spter als \"Windows XP Setup-Diskette 4\" ",
   "bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows XP Setup-",
      "Diskette 4\" bezeichnet.",
        NULL
        }
        };



SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows XP Setup-",
   "Diskette 3\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows XP Setup-",
   "Diskette 2\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows XP Setup-",
   "Startdiskette\" bezeichnet.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Die bereitgestellte Diskette ist nicht zur Verwendung unter MS-DOS",
  "formatiert. Setup kann diese Diskette nicht verwenden.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Diese Diskette ist entweder nicht HD-formatiert, hat nicht das",
  "Standard-MS-DOS-Format oder ist beschdigt. Setup kann diese",
  "Diskette nicht verwenden.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup kann nicht feststellen, wieviel freier Speicherplatz auf der",
  "bereitgestellten Diskette zur Verfgung steht. Setup kann diese",
  "Diskette nicht verwenden.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Die bereitgestellte Diskette ist nicht HD-formatiert oder ",
  "nicht leer. Setup kann diese Diskette nicht verwenden.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup konnte den Systembereich der bereitgestellten Diskette ",
  "nicht beschreiben. Die Diskette ist wahrscheinlich unbrauchbar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Die Daten, die Setup vom Systembereich der Diskette gelesen hat,",
  "stimmen nicht mit den geschriebenen Daten berein, oder Setup",
  "konnte den Systembereich der Diskette nicht zur Verifikation lesen.",
  DntEmptyString,
  "Dies wird durch einen oder mehrere der folgenden Zustnde verursacht:",
  DntEmptyString,
  "  Der Computer ist mit einem Virus infiziert.",
  "  Die bereitgestellte Diskette ist beschdigt.",
  "  Bei dem Diskettenlaufwerk besteht ein Hardware- oder ",
  "   Konfigurationsproblem.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup konnte die Diskette in Laufwerk A: nicht beschreiben. ",
  "Die Diskette ist wahrscheinlich beschdigt. Versuchen Sie es ",
  "mit einer anderen Diskette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Windows XP wurde nicht vollstndig auf diesem       ",
                    "  Computer installiert. Wenn Sie Setup jetzt beenden, ",
                    "  mssen Sie Setup erneut durchfhren, um Windows XP  ",
                    "  zu installieren. Drcken Sie                        ",
                    "                                                      ",
                    "      die EINGABETASTE, um Setup fortzusetzen.       ",
                    "      die F3-TASTE, um Setup zu beenden.             ",
                    "                                                      ",
                    "͹",
                    "  F3=Beenden  EINGABE=Fortsetzen                      ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass sich die \"Windows XP Setup-Startdiskette\"",
  "in Laufwerk A: befindet, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows XP fortzusetzen.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass sich die \"Windows XP Setup-Startdiskette\"",
  "in Laufwerk A: befindet, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows XP fortzusetzen.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Entfernen Sie ggf. die in Laufwerk A: eingelegte Diskette.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows XP fortzusetzen.",
  NULL
}
};


//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass die \"Windows XP Setup-Startdiskette\"",
  "in Laufwerk A: eingelegt ist, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows XP Setup fortzusetzen.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass die \"Windows XP Setup-Startdiskette\"",
  "in Laufwerk A: eingelegt ist, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows XP Setup fortzusetzen.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows XP fortgesetzt.",
  DntEmptyString,
  "Entfernen Sie ggf. die in Laufwerk A: eingelegte Diskette.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows XP Setup fortzusetzen.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Dateien werden kopiert ...                                     ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Um dieses Programm auszufhren, bentigen Sie MS-DOS,",
  "Version 5.0 oder hher.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Es wurde festgestellt, dass das Diskettenlaufwerk A: nicht existiert",
  "oder kein HD-Laufwerk ist. Um Setup durchzufhren, bentigen Sie ein ",
  "Laufwerk mit einer Kapazitt von mindestens 1,2 MB.",
#else
{ "Es wurde festgestellt, dass das Diskettenlaufwerk A: nicht existiert",
  "oder kein 3,5-Zoll-Laufwerk ist. Um die Installation mit Disketten",
  "durchzufhren, bentigen Sie ein Laufwerk A: mit einer Kapazitt",
  "von mindestens 1,44 MB.",
  DntEmptyString,
  "Um Windows XP ohne Disketten zu installieren, mssen Sie Setup neu",
  "starten und dabei den Parameter /b angeben.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Es wurde festgestellt, dass dieser Computer keinen 80486- oder neueren ",
  "Prozessor besitzt. Windows XP kann auf diesem Computer nicht ausgefhrt",
  "werden.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dieses Programm kann nicht unter einer 32-Bit-Version von Windows",
  DntEmptyString,
  "ausgefhrt werden. Verwenden Sie stattdessen WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Es wurde festgestellt, dass in diesem Computer nicht ",
  "gengend Speicherplatz fr Windows XP vorhanden ist.",
  DntEmptyString,
  "Erforderlicher Speicherplatz: %lu%s MB",
  "Vorhandener Speicherplatz:    %lu%s MB",
  NULL
}
};
//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Sie haben Setup angewiesen, die Windows XP-Dateien im unten angezeigten",
    "Verzeichnis zu lschen. Die Windows-Installation in diesem Verzeichnis",
    "ist danach nicht mehr verfgbar.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "Drcken Sie die",
    " F3-TASTE, um die Installation ohne Lschen der Dateien abzubrechen.",
    " L-TASTE, um die Windows-Dateien im angegebenen Verzeichnis zu lschen.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup konnte die unten angegebene Setup-Protokolldatei nicht ffnen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kann die Windows-Dateien des angegebenen Verzeichnisses nicht",
  "lschen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup kann den %s-Abschnitt der unten angegebenen Setup-",
  "Protokolldatei nicht finden.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kann die Windows-Dateien des angegebenen Verzeichnisses nicht",
  "lschen.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "       Bitte warten Sie, bis Setup die Windows-Dateien gelscht hat.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup konnte das Windows-Ladeprogramm nicht installieren.",
  DntEmptyString,
  "Stellen Sie sicher, dass das Laufwerk C: formatiert und nicht ",
  "beschdigt ist.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Auf die mit der Option /u angegebene Antwortdatei ",
  "konnte nicht zugegriffen werden.",
  DntEmptyString,
  "Der Vorgang kann nicht fortgesetzt werden.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "In der mit der Option /u angegebenen Antwortdatei",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "liegt ein Syntaxfehler in Zeile %u vor.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "The translated boot messages are too long.",
  NULL
}
};
SCREEN
DnsNoSwapDrive = { 3,5,
{ "Es ist ein interner Setup-Fehler aufgetreten.",
  DntEmptyString,
  "Es konnte keine Auslagerungsdatei erstellt werden.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive konnte auf diesem Computer nicht gefunden werden. SmartDrive wird",
  "die Geschwindigkeit dieser Phase des Windows-Setup wesentlich verbessern.",
  DntEmptyString,
  "Sie sollten die Installation jetzt beenden, SmartDrive starten und dann",
  "Setup erneut starten. Schlagen Sie in der DOS-Dokumentation nach, um",
  "Informationen ber SmartDrive zu erhalten.",
  DntEmptyString,
    "  Drcken Sie die F3-TASTE, um Setup abzubrechen.",
    "  Drcken Sie die EINGABETASTE, um Setup ohne SmartDrive fortzusetzen.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR nicht gefunden";
CHAR BootMsgDiskError[] = "Datentrgerfehler";
CHAR BootMsgPressKey[] = "Neustart mit beliebiger Taste";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\it\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo precedente su C:";

CHAR DntBootIniLine[] = "Installazione/Aggiornamento di Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installazione di Windows XP\n ";
CHAR DntPersonalHeader[]      = "\n Installazione di Windows XP Personal\n ";
CHAR DntWorkstationHeader[]   = "\n Installazione di Windows XP Professional\n ";
CHAR DntServerHeader[]        = "\n Installazione di Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Analisi parametri...";
CHAR DntEnterEqualsExit[]     = "INVIO=Esci";
CHAR DntEnterEqualsRetry[]    = "INVIO=Riprova";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignora file";
CHAR DntEnterEqualsContinue[] = "INVIO=Continua";
CHAR DntPressEnterToExit[]    = "Impossibile continuare. Premere INVIO per uscire.";
CHAR DntF3EqualsExit[]        = "F3=Esci";
CHAR DntReadingInf[]          = "Lettura del file INF %s...";
CHAR DntCopying[]             = "    Copia: ";
CHAR DntVerifying[]           = " Verifica: ";
CHAR DntCheckingDiskSpace[]   = "Controllo spazio su disco...";
CHAR DntConfiguringFloppy[]   = "Configurazione del disco floppy...";
CHAR DntWritingData[]         = "Scrittura dei parametri di configurazione...";
CHAR DntPreparingData[]       = "Determinazione dei parametri di configurazione...";
CHAR DntFlushingData[]        = "Scaricamento dati su disco...";
CHAR DntInspectingComputer[]  = "Analisi computer...";
CHAR DntOpeningInfFile[]      = "Apertura file INF...";
CHAR DntRemovingFile[]        = "Rimozione file %s";
CHAR DntXEqualsRemoveFiles[]  = "I=Rimozione file";
CHAR DntXEqualsSkipFile[]     = "I=Ignora file";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'i',
      DniAccelRemove2 = (ULONG)'I';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'i',
      DniAccelSkip2 = (ULONG)'I';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installa Windows 2002 Server o Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:percorso origine]] [/t[:unit]]",
    "	   [/u[:file risposta]] [/udf:id[,UDF_file]]",
    "	   [/r:cartella] [/r[x]:cartella] [/e:comando] [/a]",
    "",
    "",
    "/s[:percorso origine]",
    "	Specifica la posizione dei file origine di Windows.",
    "   Deve essere un percorso completo con sintassi x:\\[percorso] o ",
    "	\\\\server\\condivisione[\\percorso].",
    "",
    "/t[:unit]",
    "   Specifica l'unit che conterr i file temporanei di installazione,",
    "	e su cui installare Windows XP. ",
    "   Se non specificato, verr cercata un'unit adatta.",
    "",
    "/u[:file risposta]",
    "	Installazione non sorvegliata con file di risposta (richiede /s).",
    "	Il file di risposta fornisce le informazioni richieste fornite",
    "	solitamente dall'utente finale durante l'installazione.",
    "",
    "/udf:id[,UDF_file]	",
    "	Indica un identificatore (id) utilizzato dall'installazione",
    "	per specificare come un file UDF (Uniqueness Database File) ",
    "	modifica un file di risposta (vedere /u). Il parametro /udf",
    "	sovrascrive i valori nel file di risposta e l'identificatore",
    "	determina quali valori del file UDF sono utilizzati. Se il ",
    "	file UDF non  specificato sar richiesto di inserire un disco ",
    "	con il file $Unique$.udb file.",   
    "",
    "/r[:cartella]",
    "	Specifica la directory opzionale da installare. La",
    "	cartella resta dopo il termine dell'installazione.",
    "",
    "/rx[:cartella]",
    "	Specifica la directory opzionale da copiare. La cartella ",
    "	viene eliminata dopo il termine dell'installazione.",
    "",
    "/e	Specifica comando da eseguire dopo la parte grafica dell'installazione.",
    "",
    "/a	Abilita le opzioni di Accesso facilitato.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installa Windows XP.",
    "",
    "WINNT [/S[:]percorsoorigine] [/T[:]unit] [/I[:]fileINF]",
    "      [/O[X]] [/X | [/F] [/C]] [/B] [/U[:fileprocedura]]",
    "      [/R[X]:directory] [/E:comando] [/A]",
    "",
    "/D[:]dir winnt",
    "       Questa opzione non  pi supportata.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memoria esaurita. Impossibile proseguire l'installazione.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selezionare le utilit da installare:",
    DntEmptyString,
    "[ ] Premere F1 per Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Premere F2 per Microsoft Narrator",
#endif
#if 0
    "[ ] Premere F3 per Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Specificare il percorso dei file di Windows XP.",
  "",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "L'origine specificata non  valida, non  accessibile, o non contiene",
                   "un'installazione di Windows XP corretta. Specificare un nuovo percorso",
                   "per i file di Windows XP. Usare il tasto BACKSPACE per",
                   "cancellare i caratteri e digitare il percorso.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Il file INF di informazioni non  leggibile oppure  danneggiato",
                "Rivolgersi all'amministratore del sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "L'unit specificata per i file temporanei dell'installazione non ",
  "un'unit valida o non contiene almeno %u megabyte (%lu byte)",
  "di spazio disponibile.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP richiede un volume sul disco rigido con almeno %u megabyte",
   "(%lu byte) disponibili. Il programma di installazione user",
   "parte dello spazio per memorizzare temporaneamente i file durante",
   "l'installazione. L'unit deve essere su un disco rigido locale",
   "permanente supportato da Windows XP e non deve essere un'unit compressa.",
   DntEmptyString,
   "Non  stato possibile trovare un'unit di questo tipo con la quantit",
   "di spazio disponibile richiesta.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Non c' spazio sufficiente nell'unit di avvio (di solito C:)",
  "per operazione senza floppy disk. Un'operazione senza floppy disk richiede",
  "almeno 3,5 MB (3.641.856 bytes) di spazio libero su quell'unit.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La sezione [%s] del file di informazioni per l'installazione",
                       " assente o danneggiata. Rivolgersi all'amministratore di sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Impossibile creare le seguenti directory sull'unit di destinazione.",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Controllare che sull'unit destinazione non esistano file con lo stesso",
                       "nome della directory di destinazione. Controllare inoltre la corretta",
                       "connessione dei cavi.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Impossibile copiare il seguente file:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere ESC per ignorare l'errore e continuare l'installazione.",
   " Premere F3 per uscire dall'installazione.",
   DntEmptyString,
   "Nota: ignorando l'errore e proseguendo l'installazione  possibile che",
   "si verifichino altri errori nel corso dell'installazione.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "La copia effettuata del file indicato non corrisponde al file originale.",
   "Questo potrebbe essere dovuto a errori di rete, problemi del disco floppy",
   "o altri errori relativi all'hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere ESC per ignorare l'errore e continuare l'installazione.",
   " Premere F3 per uscire dall'installazione.",
   DntEmptyString,
   "Nota: ignorando l'errore e proseguendo l'installazione  possibile che",
   "si verifichino altri errori nel corso dell'installazione.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorando l'errore il file non sar copiato.",
   "Questa opzione  destinata ad utenti esperti che comprendono",
   "le conseguenze della mancanza di file di sistema.",
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere I per ignorare il file.",
   DntEmptyString,
   "Nota: ignorando il file, l'installazione o l'aggiornamento",
   "di Windows XP potrebbero non essere effettuati correttamente.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Attendere la fine della rimozione dei precedenti file temporanei.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Attendere la fine della copia dei file sul disco rigido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Attendere la fine della copia dei file sul disco floppy.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Sono richiesti quattro dischi floppy ad alta densit, formattati e vuoti.",
   "Verr fatto riferimento a tali dischi come \"Disco di avvio",
   "dell'installazione di Windows XP\", \"Disco 2 - Installazione",
   "di Windows XP\",  \"Disco 3 - Installazione di",
   "Windows XP.\" e \"Disco 4 - Installazione di",
   "Windows XP.\"",
   DntEmptyString,
   "Inserire uno dei quattro dischi nell'unit A:.",
   "Questo diverr il \"Disco 4 - Installazione di Windows XP.\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diverr il \"Disco 4 - Installazione di Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diverr il \"Disco 3 - Installazione di Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diventer il \"Disco 2 - Installazione di Windows XP.\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diventer il \"Disco di avvio dell'installazione di Windows XP.\"",
   
   NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Sono richiesti quattro dischi floppy ad alta densit, formattati e vuoti.",
   "Verr fatto riferimento a tali dischi come \"Disco di avvio",
   "dell'installazione di Windows XP\", \"Disco 2 - Installazione di",
   "Windows XP\", \"Disco 3 - Installazione di Windows XP,\" e \"Disco 4 - Installazione di Windows XP.\"",
   DntEmptyString,
   "Inserire uno dei tre dischi nell'unit A:.",
   "Tale disco diventer il \"Disco 4 - Installazione di Windows XP.\"",

  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 4 - Installazione di Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 3 - Installazione di Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 2 - Installazione di Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo disco diventer \"Disco di avvio dell'installazione di",
   "Windows XP.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Il disco floppy fornito non  formattato per l'uso con MS-DOS.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Il disco floppy non  formattato ad alta densit, non ha un formato",
  "standard MS-DOS o  danneggiato. Impossibile usare questo disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Impossibile determinare la quantit di spazio disponibile sul disco floppy",
  "fornito. Impossibile usare questo disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Il disco floppy non  ad alta densit oppure non  vuoto.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Impossibile scrivere l'area di sistema del disco floppy fornito.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "I dati letti dall'area di sistema del disco floppy non corrispondono a",
  "quelli scritti, o il programma di installazione non ha potuto leggere",
  "l'area di sistema del disco floppy per la verifica.",
  DntEmptyString,
  "Potrebbe essersi verificato uno dei seguenti problemi:",
  DntEmptyString,
  "  Il computer  stato infettato da un virus.",
  "  Il disco floppy fornito  danneggiato.",
  "  L'unit disco floppy ha un problema hardware o di configurazione.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Impossibile scrivere sul disco floppy nell'unit A:. Il disco floppy",
  "potrebbe essere danneggiato. Provare con un altro disco floppy.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Windows XP non  completamente installato         ",
                    " sul computer. Se si esce ora, occorrer            ",
                    " rieseguire l'installazione di Windows XP.          ",
                    "                                                    ",
                    "      Premere INVIO per continuare.                ",
                    "      Premere F3 per uscire dall'installazione.    ",
                    "ĺ",
                    "  F3=Esci  INVIO=Continua                           ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "L'installazione di Windows XP continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows XP\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e continuare l'installazione di",
  "Windows XP.",
  NULL
}
},

DnsAboutToRebootS =  
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "Dopo il riavvio del computer, l'installazione di Windows XP continuer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows XP\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e continuare l'installazione di",
  "Windows XP.",
 NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "Dopo il riavvio del computer, l'installazione di Windows XP continuer.",
  DntEmptyString,
  "Se  presente un dischetto nell'unit A:, rimuoverlo adesso.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e proseguire l'installazione di",
  "Windows XP.",
  NULL
}
};


//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows XP",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows XP\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per ritornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows XP.",
  NULL
}

},
DnsAboutToExitS =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows XP",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows XP\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per ritornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows XP",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Se c' un dischetto nell'unit A:  necessario rimuoverlo ora.", 
  DntEmptyString,
  "Premere INVIO per tornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows XP.",
  NULL
}
};


//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Copia dei file in corso...                                     ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Questo programa richiede MS-DOS versione 5.0 o successiva.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "L'unit floppy A: non esiste o  un'unit a",
  "bassa densit. Per eseguire l'installazione occorre un'unit con una",
  "capacit di 1,2 Megabyte o maggiore.",
#else
{"L'unit floppy A: non esiste o non  un'unit da 3,5 pollici",
 "ad alta densit. Bisogna usare un'unit da 1,44 Mb o superiore",
 "per l'installazione con i dischi floppy.",
 DntEmptyString,
"Per installare Windows XP senza usare dischi floppy, riavviare il programma",
"con l'opzione /b nella riga di comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Processore 80486 o superiore non presente sul computer in uso.",
  "Impossibile eseguire Windows XP.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Impossibile eseguire questo programma su una versione a 32 bit di Windows.",
  DntEmptyString,
  "Utilizzare winnt32.exe.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Il computer non disponde di memoria sufficiente",
  "per l'esecuzione di Windows XP.",
  DntEmptyString,
  "Memoria richiesta: %lu%s Mb",
  "Memoria rilevata : %lu%s Mb",
  NULL
}
};

//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "E' stato richiesto di rimuovere i file di installazione di Windows XP dalla",
    "directory specificata. L'installazione di Windows XP in questa directory",
    "sar distrutta.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    " Premere F3 per uscire dall'installazione senza rimuovere i file.",
    " Premere I per rimuovere i file di Windows XP dalla directory specificata.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Impossibile aprire il file registro di installazione specificato.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossibile rimuovere i file di Windows XP dalla directory specificata.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Impossibile trovare la sezione %s nel file registro",
  "di installazione specificato.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossibile rimuovere i file di Windows XP dalla directory specificata.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Attendere la rimozione dei file di Windows XP.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Impossibile installare il programma di avvio di Windows XP.",
  DntEmptyString,
  "Assicurarsi che l'unit C: sia formattata e che non sia daneggiata.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Impossibile accedere al file specificato con l'opzione",
  "/u nella riga di comando.",
  DntEmptyString,
  "Impossibile proseguire con l'operazione non sorvegliata.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Il file della procedura specificato con l'opzione /u ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "nella riga di di comando presenta un errore di sintassi",
  "alla riga %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Errore interno di installazione.",
  DntEmptyString,
  "Messaggi di avvio troppo lunghi.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Si  verificato un errore interno di installazione.",
  DntEmptyString,
  "Impossibile allocare il file di swapping.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Non  stato rilevato SmartDrive. SmartDrive migliorer notevolmente",
  "le prestazioni in questa fase dell'installazione.",
  DntEmptyString,
  "Uscire ora, avviare SmartDrive e riavviare l'installazione .",
  "Consultare la documentazione DOS per ulteriori informazioni.",
  DntEmptyString,
    "  Premere F3 per uscire dall'installazione.",
    "  Premere INVIO per continuare senza SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR mancante";
CHAR BootMsgDiskError[] = "Errore disco";
CHAR BootMsgPressKey[] = "Premere un tasto per riavviare";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\pt\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\pl\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Poprzedni system operacyjny na dysku C:";

CHAR DntBootIniLine[] = "Instalacja/uaktualnienie systemu Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalator systemu Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Instalator systemu Windows XP Personal\n";
CHAR DntWorkstationHeader[]   = "\n Instalator systemu Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Instalator systemu Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Sprawdzanie argumentw...";
CHAR DntEnterEqualsExit[]     = "ENTER=Zakocz";
CHAR DntEnterEqualsRetry[]    = "ENTER=Ponw prb";
CHAR DntEscEqualsSkipFile[]   = "ESC=Pomi plik";
CHAR DntEnterEqualsContinue[] = "ENTER=Kontynuuj";
CHAR DntPressEnterToExit[]    = "Nie mona kontynuowa instalacji. Nacinij klawisz ENTER, aby zakoczy instalacj.";
CHAR DntF3EqualsExit[]        = "F3=Zakocz";
CHAR DntReadingInf[]          = "Odczyt pliku INF %s...";
CHAR DntCopying[]             = "  Kopiowanie: ";
CHAR DntVerifying[]           = " Weryfikacja: ";
CHAR DntCheckingDiskSpace[]   = "Sprawdzanie miejsca na dysku...";
CHAR DntConfiguringFloppy[]   = "Konfigurowanie dyskietki...";
CHAR DntWritingData[]         = "Zapisywanie parametrw Instalatora...";
CHAR DntPreparingData[]       = "Okrelanie parametrw Instalatora...";
CHAR DntFlushingData[]        = "adowanie danych na dysk...";
CHAR DntInspectingComputer[]  = "Kontrola komputera...";
CHAR DntOpeningInfFile[]      = "Otwieranie pliku INF...";
CHAR DntRemovingFile[]        = "Usuwanie pliku %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Usu pliki";
CHAR DntXEqualsSkipFile[]     = "X=Pomi plik";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instaluje system Windows 2002 Server lub Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:]cieka rdowa] [/t[:]dysk tymczasowy]",
    "      [/u[:plik odpowiedzi]] [/udf:id[,plik UDF]]",
    "      [/r:folder] [/r[x]:folder] [/e:polecenie] [/a]",
    "",
    "",
    "/s[:cieka rdowa]",
    "       Okrela lokalizacj rdow plikw systemu Windows.",
    "       Musi to by pena cieka, np.: x:\\[cieka] lub",
    "       \\\\serwer\\udzia[\\cieka].",
    "",
    "/t[:dysk tymczasowy]",
    "       Okrela dysk, na ktrym Instalator ma umieci pliki tymczasowe",
    "       i zainstalowa system Windows XP. Jeeli dysk nie zostanie",
    "       podany, Instalator prbuje automatycznie wybra dysk.",
    "",
    "/u[:plik odpowiedzi]",
    "       Wykonuje instalacj nienadzorowan uywajc pliku odpowiedzi",
    "       (wymaga /s). Plik odpowiedzi zawiera odpowiedzi na niektre",
    "       lub wszystkie pytania, na ktre zwykle odpowiada uytkownik",
    "       w czasie instalacji.",
    "",
    "/udf:id[,plik UDF] ",
    "       Wskazuje identyfikator (id), ktrego Instalator ma uy",
    "       do okrelenia, jak plik bazy danych unikatowych (UDF) zmodyfikuje",
    "       plik odpowiedzi (zobacz przecznik /u). Parametr /udf zastpuje",
    "       wartoci w pliku odpowiedzi, a podany identyfikator okrela, ktre",
    "       wartoci z pliku UDF maj by uyte. Jeeli nie zostanie podany",
    "       plik UDF, Instalator wywietli monit o woenie dysku zawierajcego",
    "       plik $Unique$.udb.",
    "",
    "/r[:folder]",
    "       Okrela dodatkowy folder do zainstalowania. Folder ten pozostaje",
    "       na dysku po zakoczeniu pracy Instalatora.",
    "",
    "/rx[:folder]",
    "       Okrela dodatkowy katalog do skopiowania. Folder ten jest usuwany",
    "       po zakoczeniu pracy Instalatora.",
    "",
    "/e     Okrela polecenie do wykonania po zakoczeniu pracy Instalatora",
    "       w trybie graficznym.",
    "",
    "/a     Wcza opcje uatwie dostpu.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instaluje system Windows XP.",
    "",
    "WINNT [/S[:]cieka rdowa] [/T[:]dysk tymczasowy] [/I[:]plik inf]",
    "      [[/U[:plik skryptu]]",
    "      [/R[X]:katalog] [/E:polecenie] [/A]",
    "",
    "/D[:]winntroot",
    "       Ta opcja nie jest ju obsugiwana.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Brak pamici. Instalator nie moe kontynuowa pracy.",
                     NULL
                   }
                 };
//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Wybierz narzdzia uatwie dostpu, ktre chcesz zainstalowa:",
    DntEmptyString,
    "[ ] Nacinij klawisz F1, aby wybra program Lupa firmy Microsoft",
#ifdef NARRATOR
    "[ ] Nacinij klawisz F2, aby wybra program Microsoft Narrator",
#endif
#if 0
    "[ ] Nacinij klawisz F3, aby wybra program Klawiatura ekranowa Microsoft",
#endif
    NULL
}
};
//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Instalator potrzebuje informacji o pooeniu plikw systemu Windows XP.",
  "Wprowad ciek do plikw systemu Windows XP.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Podane rdo jest nieprawidowe, nie jest dostpne lub nie zawiera",
                   "prawidowych plikw instalacyjnych systemu Windows XP. Podaj now",
                   "ciek do plikw systemu Windows XP. Uyj klawisza Backspace",
                   "do usunicia starej cieki i wpisz now.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Instalator nie moe odczyta pliku informacyjnego lub plik informacyjny",
                "jest uszkodzony. Skontaktuj si z administratorem systemu.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Dysk podany jako miejsce do przechowywania plikw tymczasowych Instalatora",
  "jest nieprawidowy lub nie zawiera co najmniej %u MB (%lu bajtw)",
  "wolnego miejsca.",
  NULL
}
};                                                                               

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "System Windows XP potrzebuje woluminu dysku twardego z co najmniej %u MB",
   "(%lu bajtw) wolnego miejsca. Instalator uyje czci tego miejsca",
   "do przechowywania plikw tymczasowych podczas instalacji. Dysk ten",
   "musi by stale doczonym lokalnym dyskiem twardym obsugiwanym przez",
   "system Windows XP i nie moe by skompresowany.",
   DntEmptyString,
   "Instalator nie odnalaz dysku z wymagan iloci wolnego miejsca.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Brak wolnego miejsca na dysku startowym (zwykle C:)",
  "do instalacji bez uycia dyskietek. Instalacja bez dyskietek wymaga",
  "3,5 MB (3 641 856 bajtw) wolnego miejsca na dysku.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Sekcja [%s] pliku informacyjnego Instalatora nie istnieje",
                       "lub jest uszkodzona. Skontaktuj si z administratorem systemu.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Instalator nie mg utworzy katalogw na dysku docelowym:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Sprawd dysk docelowy i upewnij si, czy nie zawiera on plikw z nazwami,",
                       "ktre s identyczne z katalogiem docelowym. Sprawd rwnie podczenie dysku.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Instalator nie mg skopiowa nastpujcego pliku:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz ESC, aby zignorowa bd i kontynuowa instalacj.",
   "  Nacinij klawisz F3, aby zakoczy instalacj.",
   DntEmptyString,
   "Uwaga: jeli wybierzesz zignorowanie bdu i kontynuacj instalacji,",
   "moe to spowodowa bdy podczas dalszej instalacji.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Utworzona podczas instalacji kopia wymienionego poniej pliku nie jest identyczna",
   "z oryginaem. Moe to by wynikiem bdw sieci, problemw ze stacj dyskietek",
   "lub innych problemw zwizanych ze sprztem.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz ESC, aby zignorowa bd i kontynuowa instalacj.",
   "  Nacinij klawisz F3, aby zakoczy instalacj.",
   DntEmptyString,
   "Uwaga: jeli wybierzesz zignorowanie bdu i kontynuacj instalacji,",
   "moe to spowodowa bdy podczas dalszej instalacji.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Zignorowanie bdu spowoduje, e plik nie zostanie skopiowany.",
   "Ta opcja przeznaczona jest dla zaawansowanych uytkownikw rozumiejcych",
   "znaczenie uszkodzonych plikw systemu.",
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz X, aby pomin plik.",
   DntEmptyString,
   "Uwaga: jeli pominiesz plik, Instalator nie moe zagwarantowa",
   "pomylnej instalacji lub uaktualnienia systemu Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Zaczekaj, a Instalator usunie poprzednie pliki tymczasowe.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Zaczekaj, a Instalator skopiuje pliki na dysk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Zaczekaj, a Instalator skopiuje pliki na dyskietk.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Instalator potrzebuje czterech sformatowanych, pustych dyskietek o duej ",
   "gstoci. Bd to: ",
   "\"Dysk rozruchowy Instalatora systemu Windows XP\",",
   "\"Windows XP - dysk instalacyjny nr 2\",",
   "\"Windows XP - dysk instalacyjny nr 3\" i ",
   "\"Windows XP - dysk instalacyjny nr 4\".",
   DntEmptyString,
   "W jedn z tych czterech dyskietek do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 3\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 2\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Dysk rozruchowy Instalatora systemu Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Instalator potrzebuje czterech sformatowanych, pustych dyskietek o duej ",
   "gstoci. Bd to: ",
   "\"Dysk rozruchowy Instalatora systemu Windows XP\",",
   "\"Windows XP - dysk instalacyjny nr 2\",",
   "\"Windows XP - dysk instalacyjny nr 3\" i ",
   "\"Windows XP - dysk instalacyjny nr 4\".",
   DntEmptyString,
   "W jedn z tych czterech dyskietek do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 3\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows XP - dysk instalacyjny nr 2\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Dysk rozruchowy Instalatora systemu Windows XP\".",
  NULL
}
};

//
// Ta dyskietka nie jest sformatowana.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Dostarczona dyskietka nie jest sformatowana do uycia",
  "w systemie MS-DOS. Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Ta dyskietka nie jest sformatowana w duej gstoci, jest sformatowana",
  "w standardowym formacie MS-DOS lub jest uszkodzona. Instalator nie moe",
  "uy tej dyskietki.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Instalator nie moe okreli iloci wolnego miejsca na dostarczonej",
  "dyskietce. Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Dostarczona dyskietka nie jest duej gstoci lub nie jest pusta.",
  "Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Instalator nie mg zapisywa w obszarze systemowym na dostarczonej",
  "dyskietce. Dyskietka prawdopodobnie jest bezuyteczna.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Dane odczytane z obszaru systemowego tej dyskietki nie odpowiadaj",
  "danym, ktre zostay zapisane lub Instalator nie mg dokona",
  "odczytu z obszaru sytemowego dyskietki danych do weryfikacji.",
  DntEmptyString,
  "Jest to spowodowane jednym lub kilkoma z nastpujcych powodw:",
  DntEmptyString,
  "  Komputer jest zaraony wirusem.",
  "  Dostarczona dyskietka jest uszkodzona.",
  "  Wystpuje problem sprztowy lub konfiguracji stacji dyskietek.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Instalator nie mg dokona zapisu na dyskietce w stacji A:. Dyskietka moe",
  "by uszkodzona. Sprbuj uy innej dyskietki.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    " System Windows XP nie jest cakowicie zainstalowany   ",
                    " na tym komputerze. Jeli zakoczysz instalacj teraz, ",
                    " konieczne bdzie ponowne uruchomienie Instalatora     ",
                    " w celu zainstalowania systemu Windows XP.             ",
                    "                                                       ",
                    "  Nacinij klawisz ENTER, aby kontynuowa instalacj. ",
                    "  Nacinij klawisz F3, aby zakoczy instalacj.      ",
                    "ĺ",
                    "  F3=Zakocz  ENTER=Kontynuuj                          ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e \"Dysk rozruchowy Instalatora",
  "systemu Windows XP\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows XP.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e \"Dysk rozruchowy Instalatora ",
  "systemu Windows XP\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows XP.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Jeli w stacji A: znajduje si dyskietka, wyjmij j teraz.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows XP.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e  \"Dysk rozruchowy Instalatora ",
  "systemu Windows XP\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e  \"Dysk rozruchowy Instalatora ",
  "systemu Windows XP\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows XP bdzie kontynuowana.",
  DntEmptyString,
  "Jeli w stacji A: znajduje si dyskietka, wyjmij j teraz.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Trwa kopiowanie plikw...                                      ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Do uruchomienia tego programu jest wymagany system MS-DOS",
  "w wersji 5.0 lub nowszej.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Instalator wykry, e stacja dyskietek A: nie istnieje lub jest",
  "maej gstoci. Do uruchomienia Instalatora wymagana jest stacja",
  "dyskietek o pojemnoci 1,2 MB lub wikszej.",
#else
{ "Instalator wykry, e stacja dyskietek A: nie istnieje lub nie jest",
  "stacj 3,5\" duej gstoci. Do instalacji z uyciem dyskietek",
  "wymagana jest stacja o pojemnoci 1,44 MB lub wikszej.",
  DntEmptyString,
  "Aby zainstalowa system Windows XP bez uycia dyskietek, ponownie",
  "uruchom ten program z przecznikiem /b w wierszu polecenia.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Instalator wykry, e ten komputer nie ma procesora 80486 lub",
  "nowszego. System Windows XP nie moe by uruchomiony na tym komputerze.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Ten program nie moe by uruchomiony w adnym 32-bitowym systemie Windows.",
  DntEmptyString,
  "Zamiast tego uyj pliku WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Instalator wykry niewystarczajc ilo pamici w tym komputerze",
  "do uruchomienia systemu Windows XP.",
  DntEmptyString,
  "Pami wymagana: %lu%s MB",
  "Pami wykryta:  %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Zostao wybrane usunicie wszystkich plikw systemu Windows XP",
    "z katalogu wymienionego poniej. Instalacja systemu Windows",
    "w tym katalogu zostanie trwale usunita.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Nacinij klawisz F3, aby zakoczy instalacj bez usuwania plikw.",
    "  Nacinij klawisz X, aby usun pliki systemu Windows z tego katalogu.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Instalator nie mg otworzy poniszego pliku dziennika instalacji.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Instalator nie moe usun plikw systemu Windows z tego katalogu.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Instalator nie moe znale sekcji %s w nastpujcym pliku ",
  "dziennika instalacji.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Instalator nie moe usun plikw systemu Windows z tego katalogu.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Zaczekaj, a Instalator usunie pliki systemu Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Instalacja programu Windows Boot Loader jest niemoliwa.",
  DntEmptyString,
  "Upewnij si, czy dysk C: jest sformatowany i czy nie jest uszkodzony.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Plik skryptu okrelony z przecznikiem wiersza polece /u,",
  "jest niedostpny.",
  DntEmptyString,
  "Instalacja nienadzorowana nie moe by kontynuowana.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Plik skryptu okrelony z przecznikiem wiersza polece /u ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "zawiera bd skadniowy w wierszu %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Wystpi bd wewntrzny Instalatora.",
  DntEmptyString,
  "Przetumaczone komunikaty rozruchowe s zbyt dugie.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Wystpi bd wewntrzny Instalatora.",
  DntEmptyString,
  "Nie mona znale miejsca na plik wymiany.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Instalator nie wykry zainstalowanego na tym komputerze programu SmartDrive.",
  "Program SmartDrive znaczco zwiksza wydajno tej fazy instalacji systemu",
  "Windows.",
  DntEmptyString,
  "Zaleca si zakoczenie instalacji, uruchomienie programu SmartDrive",
  "i ponowne uruchomienie Instalatora. Poszukaj w dokumentacji systemu DOS",
  "informacji na temat programu SmartDrive.",
  DntEmptyString,
    ".  Nacinij klawisz F3, aby zakoczy instalacj.",
    ".  Nacinij klawisz ENTER, aby kontynuowa bez programu SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Brak pliku NTLDR";
CHAR BootMsgDiskError[] = "Bd dysku";
CHAR BootMsgPressKey[] = "Nacinij jaki klawisz, aby zrestartowa";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\psu\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Pseudo.

CFOPT=-DLCP -DPSU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\pl\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Polish.

CFOPT=-DLCP -DPL

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\pt\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo anterior em C:";

CHAR DntBootIniLine[] = "Instalaao/actualizaao do Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Programa de configuraao do Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Programa de configuraao do Windows XP Personal\n";
CHAR DntWorkstationHeader[]   = "\n Programa de configuraao do Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Programa de configuraao do Windows .Net Server\n";
CHAR DntParsingArgs[]         = "A analisar argumentos...";
CHAR DntEnterEqualsExit[]     = "ENTER=Sair";
CHAR DntEnterEqualsRetry[]    = "ENTER=Tentar novamente";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignorar ficheiro";
CHAR DntEnterEqualsContinue[] = "ENTER=Continuar";
CHAR DntPressEnterToExit[]    = "O programa de configuraao nao pode continuar. Prima ENTER para sair.";
CHAR DntF3EqualsExit[]        = "F3=Sair";
CHAR DntReadingInf[]          = "A ler o ficheiro INF %s...";
CHAR DntCopying[]             = "    A copiar: ";
CHAR DntVerifying[]           = " A verificar: ";
CHAR DntCheckingDiskSpace[]   = "A verificar o espao em disco...";
CHAR DntConfiguringFloppy[]   = "A configurar a disquete...";
CHAR DntWritingData[]         = "A escrever os parmetros do prog. de config...";
CHAR DntPreparingData[]       = "A determinar os parmetros do prog. de config...";
CHAR DntFlushingData[]        = "A guardar dados em disco...";
CHAR DntInspectingComputer[]  = "A inspeccionar o computador...";
CHAR DntOpeningInfFile[]      = "A abrir o ficheiro INF...";
CHAR DntRemovingFile[]        = "A remover o ficheiro %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remover ficheiros";
CHAR DntXEqualsSkipFile[]     = "X=Ignorar o ficheiro";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Configura o Windows .Net Server ou o Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:caminho_de_origem]] [/t[:unidade_temp]]",
    "      [/u[:ficheiro_de_respostas]] [/udf:id[,ficheiro_UDF]]",
    "      [/r:pasta] [/r[x]:pasta] [/e:comando] [/a]",
    "",
    "",
    "/s[:caminho de origem]",
    "   Especifica a localizaao da origem dos ficheiros ",
    "   do Windows. A localizaao tem que ser um ",
    "   caminho inteiro da forma x:\\[caminho] ou ",
    "   \\\\servidor\\partilha[\\caminho]. ",
    "",
    "/t[:unidade_temp]",
    "   Direcciona o programa de configuraao para colocar",
    "   ficheiros temporrios na unidade especificada e instalar ",
    "   o Windows XP nessa unidade. Se nao especificar uma ",
    "   localizaao, o programa de configuraao tenta localizar ",
    "   uma unidade.",
    "",
    "/u[:ficheiro_de_respostas]",
    "   Executa um programa de configuraao autnomo utilizando",
    "   um ficheiro de respostas (requer /s). O ficheiro de ",
    "   respostas fornece respostas a algumas ou a todas as ",
    "   escolhas que o utilizador final normalmente responde ",
    "   durante o programa de configuraao.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indica um identificador (id) que o programa de configuraao",
    "   utiliza para especificar como um 'Ficheiro de base de dados ",
    "   nico' (UDF) modifica um ficheiro de respostas (ver /u). ",
    "   O parmetro /udf sobrepoe valores no ficheiro de respostas, ",
    "   e o identificador determina que valores no ficheiro UDF sao ",
    "   utilizados. Se nao for especificado um ficheiro_UDF, o ",
    "   programa de configuraao pede-lhe que insira um disco que ",
    "   contenha o ficheiro $Unique$.udb.",
    "",
    "/r[:pasta]",
    "   Especifica uma pasta opcional para ser instalada. A pasta",
    "   permanece depois de o programa de configuraao concluir.",
    "",
    "/rx[:pasta]",
    "   Especifica uma pasta opcional para ser copiada. A pasta ",
    "    apagada depois de o programa de configuraao concluir.",
    "",
    "/e Especifica um comando a ser executado no fim do programa ",
    "   de configuraao em modo-GUI.",
    "",
    "/a Activa as opoes de acessibilidade.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala o Windows XP.",
    "",
    "WINNT [/S[:]caminho_de_origem] [/T[:]unidade_temp] [/I[:]ficheiro_inf]",
    "      [[/U[:ficheiro_script]]",
    "      [/R[X]:pasta] [/E:comando] [/A]",
    "",
    "/D[:]winntroot",
    " Esta opao j nao  suportada.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "O programa de configuraao esgotou a memria e nao pode continuar.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Escolha os utilitrios de acessibilidade a instalar:",
    DntEmptyString,
    "[ ] Prima F1 para o Ampliador da Microsoft",
#ifdef NARRATOR
    "[ ] Prima F2 para o Sistema de falha da Microsoft",
#endif
#if 0
    "[ ] Prima F3 para o Teclado-no-ecra da Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "O programa de configuraao tem de saber onde estao localizados os",
  "ficheiros do Windows XP. Introduza o caminho onde os ficheiros do",
  "Windows XP podem ser encontrados.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A origem especificada nao  vlida, nao est acessvel ou nao contm uma",
                   "instalaao v lida do programa de configuraao do Windows XP. Introduza",
                   "um novo caminho onde os ficheiros do Windows XP podem ser encontrados.",
                   "Utilize a tecla BACKSPACE para eliminar caracteres e escreva o caminho.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "O programa de configuraao nao pode ler o ficheiro de informaoes ou",
                "este est danificado. Contacte o administrador de sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "A unidade que especificou para conter os ficheiros temporrios",
  "do programa de configuraao nao , v lida ou nao possui pelo",
  "menos %u megabytes (%lu bytes) de espao livre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remember that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "O Windows XP exige um volume de disco rgido com pelo menos %u",
   "megabytes (%lu bytes) de espao livre. O programa de configuraao",
   "utilizar parte deste espao para armazenar ficheiros temporrios",
   "durante a instalaao. A unidade tem de ser um disco rgido local",
   "permanentemente ligado, suportado pelo Windows XP e nao pode ser",
   "uma unidade comprimida.",
   DntEmptyString,
   "O programa de configuraao nao pode localizar uma unidade com estas",
   "caractersticas com o espao livre necessrio.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nao existe espao livre na unidade de arranque (normalmente C:)",
  "para operar sem disquetes. A operaao sem disquetes exige pelo",
  "menos 3,5 MB (3.641.856 bytes) de espao livre nessa unidade.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A secao [%s] no ficheiro de informaoes do programa",
                       "de configuraao nao est presente ou est danificada.",
                       "Contacte o administrador de sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "O programa de configuraao nao pode criar a pasta seguinte ",
                       "na unidade de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Verifique a unidade de destino e certifique-se de que nao existem",
                       "ficheiros com nomes que coincidam com a pasta de destino. Verifique",
                       "tambm a cablagem da unidade.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "O programa de configuraao nao pode copiar o ficheiro seguinte:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima ESC para ignorar o erro e continuar a configuraao.",
   "o  Prima F3 para sair do programa de configuraao.",
   DntEmptyString,
   "Nota: Se optar por ignorar o erro e continuar, pode deparar-se",
   "com problemas mais tarde no programa de configuraao.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "A cpia efectuada pelo programa de configuraao do ficheiro abaixo nao",
   ", idntica ao original. Tal pode ser o resultado de erros na rede,",
   "problemas na disquete ou outros problemas relacionados com o hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima ESC para ignorar o erro e continuar a configuraao.",
   "o  Prima F3 para sair do programa de configuraao.",
   DntEmptyString,
   "Nota: Se optar por ignorar o erro e continuar, pode deparar-se",
   "com problemas mais tarde no programa de configuraao.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorar o erro significa que este ficheiro nao ser copiado.",
   "Esta opao  para utilizadores avanados que compreendem as",
   "ramificaoes da falta de ficheiros de sistema.",
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima X para ignorar este ficheiro.",
   DntEmptyString,
   "Nota: Se ignorar este ficheiro, o programa de configuraao",
   "nao pode garantir a instalaao ou actualizaao com xito",
   "do Windows Whistler.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Aguarde enquanto o programa de configuraao remove ficheiros",
          "temporrios anteriores.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Aguarde enquanto o programa de configuraao copia",
                     "ficheiros para o disco rgido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Aguarde enquanto o programa de configuraao copia",
                     "ficheiros para a disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "O programa de configuraao necessita de quatro disquetes formatadas",
   "de alta densidade, que serao denominadas de \"Disq. de arranque do",
   "prog. de config. do Windows XP,\" \"Disq. 2 do prog. de config. do",
   "Windows XP,\" \"Disq. 3 do prog. de config. do Windows Whistler\"",
   "e \"Disq. 4 do prog. de config. do Windows XP.\"",
   DntEmptyString,
   "Introduza uma destas quatro disquetes na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 3 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 2 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. de arranque do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "O programa de configuraao necessita de quatro disquetes formatadas de",
   "alta densidade, que serao denominadas \"Disq. de arranque do prog. de",
   "config. do Windows Whistler,\" \"Disq. 2 do prog. de config. do Windows Whistler,\"",
   "\"Disq. 3 do prog. de config. do Windows XP\" e \"Disq. 4 do prog.",
   "de config. do Windows Whistler.\"",
   DntEmptyString,
   "Introduza uma destas quatro disquetes na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 3 do prog. de config. do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 2 do prog. de config. do Windows XP.\"",
  NULL       
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. de arranque do prog. de config. do Windows XP.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "A disquete fornecida nao est formatada em MS-DOS.",
  "O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Esta disquete nao foi formatada em alta densidade, com",
  "um formato MS-DOS padrao ou est danificada. O programa de ",
  "configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "O programa de configuraao nao pode determinar o espao livre na disquete",
  "fornecida. O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "A disquete fornecida nao , de alta densidade ou nao est vazia.",
  "O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "O programa de configuraao nao pode escrever na rea de sistema da",
  "disquete fornecida, que est provavelmente inutilizvel.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (i.e., what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Os dados que o programa de configuraao leu da rea de sistema da disquete",
  "nao coincidem com os dados que foram escritos ou o programa de configuraao",
  "nao pode ler rea de sistema da disquete para verificaao.",
  DntEmptyString,
  "A causa  uma ou mais das condioes seguintes:",
  DntEmptyString,
  "o  O computador est infectado com vrus.",
  "o  A disquete fornecida est danificada.",
  "o  Existe um problema de hardware ou de configuraao com a unidade de disquetes.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "O programa de configuraao nao pode escrever na disquete na unidade A:.",
  "A disquete pode estar danificada. Tente com outra disquete.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  O Windows XP nao est completamente instalado.    ",
                    "  Se abandonar agora o programa de configuraao     ",
                    "  poder ter de o executar novamente para            ",
                    "  configurar o Windows XP.                          ",
                    "                                                    ",
                    "     o Prima ENTER para continuar o programa de     ",
                    "       configuraao.                                ",
                    "     o Prima F3 para abandonar o programa de        ",
                    "       configuraao.                                ",
                    "ĺ",
                    "  F3=Sair  ENTER=Continuar                          ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows XP\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows XP\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Se existir uma disquete na unidade A:, remova-a agora.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows XP\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, onde deve reiniciar o computador",
  "para continuar o programa de configuraao do Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows XP\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, em seguida reinicie o computador",
  "para continuar o programa de configuraao do Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows XP ir continuar.",
  DntEmptyString,
  "Se existir uma disquete na unidade A:, remova-a agora.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, onde deve reiniciar o computador",
  "para continuar o programa de configuraao do Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " O programa de configuraao est a copiar os ficheiros...       ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa necessita da versao 5.0 ou posterior do MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "O programa de configuraao detectou que A: nao existe ou , uma unidade",
  "de baixa densidade.  necessria uma unidade A: de 1,2 Megabytes ou",
  "superior para executar o programa de configuraao.",
#else
{ "O programa de configuraao detectou que A: nao existe ou nao , uma",
  "unidade de 3,5\" de alta densidade.  necessria uma unidade A: de",
  "1,44 Megabytes ou superior para o programa de configuraao funcionar",
  "com disquetes.",
  DntEmptyString,
  "Para instalar o Windows XP sem recorrer a disquetes, reinicie",
  "este programa e especifique /b na linha de comandos.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "O programa de configuraao detectou que este computador nao tem uma",
  "CPU 80486 ou posterior. O Windows XP nao pode ser executado neste",
  "computador.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa nao se executa em nenhuma versao do Windows de 32 bits.",
  DntEmptyString,
  "Utilize antes o WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "O programa de configuraao detectou que nao existe memria suficiente",
  "instalada neste computador para o Windows XP.",
  DntEmptyString,
  "Memria necessria: %lu%s MB",
  "Memria detectada: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Manifestou o desejo de que o programa de configuraao remova",
    "os ficheiros do Windows XP da pasta abaixo. A instalaao do",
    "Windows XP nesta pasta ser destruda permanentemente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "o  Prima F3 para sair do programa de configuraao sem remover",
    "   quaisquer ficheiros.",
    "o  Prima X para remover os ficheiros do Windows XP da pasta acima.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "O programa de configuraao nao pode abrir o ficheiro de registo abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "O programa de configuraao nao pode remover os ficheiros do Windows",
  "da pasta.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "O programa de configuraao nao pode encontrar a secao %s no ficheiro",
  "de registo nomeado abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "O programa de configuraao nao pode remover os ficheiros do Windows",
  "da pasta.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "     Aguarde enquanto o programa de configuraao remove os ficheiros",
  "     do Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "O programa de configuraao nao pode instalar o Windows Boot Loader.",
  DntEmptyString,
  "Certifique-se de que a unidade C: est formatada e de que nao",
  "est danificada.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "O ficheiro de script especificado com o parmetro de linha de",
  "comandos /u nao pode ser acedido.",
  DntEmptyString,
  "A operaao automtica nao pode continuar.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "O ficheiro de script especificado com o parmetro de linha de comandos /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contm um erro sintctico na linha %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Ocorreu um erro interno ao programa de configuraao",
  DntEmptyString,
  "As mensagens de arranque traduzidas sao demasiado compridas.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Ocorreu um erro interno do programa de configuraao.",
  DntEmptyString,
  "Nao foi possvel encontrar um local para um ficheiro de comutaao.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "O programa de configuraao nao detectou uma SmartDrive no computador.",
  "O SmartDrive ir melhorar o desempenho desta fase do programa de",
  "configuraao de uma forma significativa.",
  DntEmptyString,
  "Deve sair, iniciar o SmartDrive e, em seguida, reiniciar o programa",
  "de configuraao. Consulte a sua documentaao DOS para detalhes",
  "acerca do SmartDrive.",
  DntEmptyString,
    "o  Prima F3 para sair do programa de configuraao.",
    "o  Prima ENTER para continuar sem o SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Erro do disco";
CHAR BootMsgPressKey[] = "Prima qualquer tecla para reiniciar";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\ru\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Russian.

CFOPT=-DLCP -DRU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\sv\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\nl\dntext.c ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Vorig besturingssysteem op C:";

CHAR DntBootIniLine[] = "Windows XP - installatie/upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Home Edition Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional Setup\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server Setup\n";
CHAR DntParsingArgs[]         = "Parseren van argumenten...";
CHAR DntEnterEqualsExit[]     = "ENTER=Afsluiten";
CHAR DntEnterEqualsRetry[]    = "ENTER=Opnieuw";
CHAR DntEscEqualsSkipFile[]   = "ESC=Bestand overslaan";
CHAR DntEnterEqualsContinue[] = "ENTER=Doorgaan";
CHAR DntPressEnterToExit[]    = "Setup kan niet doorgaan. Druk op ENTER als u Setup wilt beindigen.";
CHAR DntF3EqualsExit[]        = "F3=Beindigen";
CHAR DntReadingInf[]          = "Bezig met het lezen van INF-bestand %s...";
CHAR DntCopying[]             = "Bezig met het kopiren van: ";
CHAR DntVerifying[]           = "Bezig met controleren van : ";
CHAR DntCheckingDiskSpace[]   = "Bezig met controleren van schijfruimte...";
CHAR DntConfiguringFloppy[]   = "Bezig met configureren van diskette...";
CHAR DntWritingData[]         = "Bezig met schrijven van setup-parameters...";
CHAR DntPreparingData[]       = "Bezig met bepalen van setup-parameters...";
CHAR DntFlushingData[]        = "Gegevens worden naar diskette overgebracht...";
CHAR DntInspectingComputer[]  = "Computer wordt genspecteerd...";
CHAR DntOpeningInfFile[]      = "INF-bestand wordt geopend...";
CHAR DntRemovingFile[]        = "Wissen van bestand %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Bestanden verwijderen";
CHAR DntXEqualsSkipFile[]     = "X=Bestand overslaan";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows 2002 Server of Windows XP Professional installeren.",
    "",
    "",
    "WINNT [/s[:bronpad]] [/t[:tijdelijk station]]",
    "      [/u[:standaardsjabloon]] [/udf:ID[,UDF-bestand]]",
    "      [/r:map] [/r[x]:map] [/e:opdracht] [/a]",
    "",
    "",
    "/s[:bronpad]",
    "   De bronlocatie van de Windows-bestanden. De locatie",
    "	moet een volledig pad zijn met de indeling x:\\[pad] of ",
    "	\\\\server\\share[\\pad]. ",
    "",
    "/t[:tijdelijk station]",
    "	Setup plaatst tijdelijke bestanden op het opgegeven station",
    "	en installeert Windows XP op dat station. Als u geen locatie",
    "	opgeeft, probeert Setup een station voor u te zoeken.",
    "",
    "/u[:antwoordbestand]",
    "   Setup zonder toezicht uitvoeren met een antwoordbestand",
    "   (vereist /s). Het antwoordbestand geeft antwoord op",
    "   sommige of alle vragen die de eindgebruiker doorgaans",
    "   tijdens de installatieprocedure moet beantwoorden.",
    "",
    "/udf:ID[,UDF-bestand]	",
    "	Een id opgeven die Setup gebruikt om te bepalen hoe een UDF-",
    "	bestand (Uniqueness Database File) een antwoordbestand",
    "	wijzigt (zie /u). De parameter /udf heft waarden in het",
    "	antwoordbestand op, en de id bepaalt welke waarden in"
    "   het UDF-bestand worden gebruikt. Als geen UDF-bestand"
    "   wordt opgegeven, vraagt Setup u om een diskette met het"
    "   bestand $Unique$.udb te plaatsen.",
    "",
    "/r[:map]",
    "   Opgeven of er een extra map moet worden genstalleerd.",
    "	De map blijft bestaan nadat Setup is voltooid.",
    "",
    "/rx[:map]",
    "	Opgeven of er een extra map moet worden gekopieerd.",
    "	De map wordt verwijderd nadat Setup is voltooid.",
    "",
    "/e	Opgeven of er aan het einde van de GUI-modus van Setup",
    "	een opdracht moet worden uitgevoerd.",
    "",
    "/a	Toegankelijkheidsopties inschakelen.",
    NULL

};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows XP installeren.",
    "",
    "WINNT [/S[:]bronpad] [/T[:]tijdelijk station] [/I[:]INF-bestand]",
    "      [/U[:scriptbestand]]",
    "      [/R[X]:map] [/E:opdracht] [/A]",
    "",
    "/D[:]winntroot",
    "       Deze optie wordt niet meer ondersteund.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
		   { "Onvoldoende geheugen. Setup kan niet doorgaan.",
		     NULL
		   }
		 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selecteer de te installeren hulpprogramma's voor toegankelijkheid:",
    DntEmptyString,
    "[ ] Druk op F1 voor Microsoft Vergrootglas",
#ifdef NARRATOR
    "[ ] Druk op F2 voor Microsoft Verteller",
#endif
#if 0
    "[ ] Druk op F3 voor Microsoft Schermtoetsenbord",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Setup moet weten waar de Windows XP-bestanden kunnen worden",
  "gevonden. Geef het pad op waar de bestanden zich bevinden.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
		 { "De opgegeven bron is niet geldig, niet toegankelijk, of er bevindt",
		   "zich geen geldig exemplaar van Windows XP Setup. Geef het pad",
		   "waar de Windows XP-bestanden zich bevinden opnieuw op. Gebruik",
		   "de BACKSPACE-toets om tekens te wissen en geef een geldig pad op.",
		   NULL
		 }
	       };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
	      { "Setup kan het gegevensbestand niet lezen of het gegevensbestand ",
		"is beschadigd. Neem contact op met de systeembeheerder.",
		NULL
	      }
	    };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Het station dat u hebt opgegeven om tijdelijke Setup-bestanden", 
  "op op te slaan, is geen geldig station of heeft minder dan %u MB",
  "(%lu bytes) aan vrije ruimte beschikbaar",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
 DnsNoLocalSrcDrives = { 3,4,
 {  "Voor Windows XP is een volume met tenminste %u MB (%lu bytes)",
    "aan vrije ruimte nodig. Setup gebruikt een gedeelte van deze ruimte",
    "om tijdens de installatie tijdelijk bestanden op te slaan.",
    "Het station moet zich op een lokale vaste schijf bevinden die",
    "door Windows XP wordt ondersteund, maar die niet is gecomprimeerd.",
    DntEmptyString,
    "Setup kan een dergelijk station met de benodigde hoeveelheid vrije",
    "ruimte niet vinden.",
   NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Er is onvoldoende ruimte op het opstartstation (doorgaans C:)",
  "om een installatie zonder diskettes te kunnen uitvoeren. Voor",
  "een installatie zonder gebruik van diskettes is tenminste 3,5 MB (3.641.856 Bytes)",
  "aan vrije schijfruimte op dat station nodig.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
		     { "De sectie [%s] van het Setup-gegevensbestand is niet",
		       "aanwezig of is beschadigd. Neem contact met de", 
		       "systeembeheerder op.",
		       NULL
		     }
		   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
		     { "Setup kan de volgende map niet op het doelstation maken:",
		       DntEmptyString,
		       "%s",
		       DntEmptyString,
		       "Controleer het doelstation en zorg ervoor dat er geen",
		       "bestanden met dezelfde naam als de doelmap bestaan.",
		       "Controleer ook de bekabeling van het station.",
		       NULL
		     }
		   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup kan het volgende bestand niet kopiren:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op ESC als u de fout wilt negeren en met Setup wilt doorgaan.",
   "  Druk op F3 als u Setup wilt afsluiten.",
   DntEmptyString,
   "Let op: als u negeren kiest en vervolgens doorgaat, kunnen er",
   "later tijdens de installatieprocedure fouten optreden.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "De door Setup gemaakte kopie van het hieronder genoemde bestand",
   "is niet identiek aan het origineel. Dit kan veroorzaakt zijn",
   "door netwerkfouten, problemen met diskettes, of andere problemen", 
   "met hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op ESC als u de fout wilt negeren en met Setup wilt doorgaan.",
   "  Druk op F3 als u Setup wilt afsluiten.",
   DntEmptyString,
   "Let op: als u negeren kiest en vervolgens doorgaat, kunnen er",
   "later tijdens de installatieprocedure fouten optreden.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Als u deze fout negeert, betekent dit dat dit bestand niet wordt",
   "gekopieerd. Deze optie is bedoeld voor gevorderde gebruikers die de",
   "consequenties van ontbrekende systeembestanden kennen.",
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op X als u dit bestand wilt overslaan.",
   DntEmptyString,
   "Opmerking: als u het bestand overslaat, kan een geslaagde",
   "installatie van of upgrade naar Windows XP niet worden gegarandeerd.",
  NULL
}
};


//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
	{ "De oude tijdelijke bestanden worden verwijderd.",
	   NULL
	}
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
		   { "De bestanden worden naar de vaste schijf gekopieerd.",
		     NULL
		   }
		 },
DnsWaitCopyFlop= { 13,6,
		   { "De bestanden worden naar de diskette gekopieerd.",
		     NULL
		   }
		 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Er zijn vier lege, geformatteerde HD-diskettes (hoge dichtheid) nodig.",
   "Setup verwijst naar deze diskettes als de 'Windows XP Setup-opstartdiskette', ",
   "'Windows XP Setup-diskette 2', 'Windows XP Setup-diskette 3', ",
   "en 'Windows XP Setup-diskette 4'.",
   DntEmptyString,
   "Plaats een van deze vier diskettes in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 3'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 2'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt de 'Windows XP Setup-opstartdiskette'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Er zijn vier lege, geformatteerde HD-diskettes (hoge dichtheid) nodig.",
   "Setup verwijst naar deze diskettes als de 'Windows XP Setup-opstartdiskette', ",
   "'Windows XP Setup-diskette 2', 'Windows XP Setup-diskette 3', ",
   "en 'Windows XP Setup-diskette 4'.",
   DntEmptyString,
   "Plaats een van deze vier diskettes in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 3'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows XP Setup-diskette 2'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt de 'Windows XP Setup-opstartdiskette'.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "De diskette is niet geformatteerd voor MS-DOS.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Deze diskette is niet met hoge dichtheid geformatteerd of niet ",
  "geformatteerd met het standaard-MS-DOS-indeling, of de diskette", 
  "is beschadigd. Setup kan de diskette niet gebruiken.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup kan de hoeveelheid vrije ruimte op de diskette niet bepalen.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "De diskette heeft geen hoge dichtheid of is niet leeg.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup kan niets naar het systeemgebied van de diskette schrijven.",
  "De diskette is waarschijnlijk onbruikbaar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{  "De gegevens die Setup op het systeemgebied van de diskette heeft",
   "gelezen, komen niet overeen met de opgeslagen gegevens of Setup ",
   "kan het systeemgebied op de diskette niet controleren.",
  DntEmptyString,
   "Mogelijke oorzaken van dit probleem zijn:",
  DntEmptyString,
   "  De computer is door een virus genfecteerd.",
   "  De diskette is beschadigd.",
   "  Het diskettestation heeft een hardware- of configuratieprobleem.", 
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup kan niets naar de diskette in station A: schrijven. De diskette",
  "is mogelijk beschadigd. Probeer een andere diskette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
		  { "ͻ",
		    "   Windows XP Setup is niet voltooid.               ",
		    "   Als u Setup nu afsluit, zult u dit installatie-  ",
		    "   programma opnieuw moeten uitvoeren als u         ",
		    "   Windows XP later alsnog wilt installeren.        ",
		    "                                                    ",
		    "    Druk op ENTER als u met Setup wilt doorgaan.   ",
		    "    Druk op F3 als u Setup wilt afsluiten.         ",
		    "ĺ",
		    "            F3=Afsluiten  ENTER=Doorgaan            ",
		    "ͼ",
		    NULL
		  }
		};


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows XP Setup-",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows XP Setup voort te zetten.",
   NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows XP Setup-",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows XP Setup voort te zetten.",
   NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Verwijder de diskette uit het diskettestation.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows XP Setup voort te zetten.",
   NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows XP Setup-'",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows XP Setup door te gaan.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows XP Setup-'",
  "opstartdiskette in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows XP Setup door te gaan.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Verwijder de diskette uit het diskettestation.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows XP Setup door te gaan.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
	     { "ͻ",
               "      Setup is bezig met het kopiren van bestanden...          ",
	       "                                                                ",
	       "      Ŀ      ",
	       "                                                              ",
	       "            ",
	       "ͼ",
	       NULL
	     }
	   };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Voor dit programma is MS-DOS-versie 5.0 of hoger nodig.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Setup heeft vastgesteld dat diskettestation A: niet bestaat, of dat",
  "het een diskettestation met lage dichtheid is. Er is een station met ",
  "een capaciteit van 1,2 MB of hoger nodig om Setup te kunnen uitvoeren.",
#else
{ "Setup heeft vastgesteld dat diskettestation A: niet bestaat of dat het",
  "geen 3,5-inch diskettestation met hoge dichtheid is. Voor een installatie met diskettes",
  " is een station met een capaciteit van 1.44 MB of hoger nodig.",
  DntEmptyString,
  "Om Windows XP zonder diskettes te installeren, moet u dit programma",
  "met de schakeloptie /b starten.",
#endif
  NULL
}
},


DnsRequires486 = { 3,5,
{ "Setup heeft bepaald dat deze computer niet over een 80486-processor of hoger",
  "beschikt. Windows XP kan niet op deze computer worden uitgevoerd.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dit programma kan niet op een 32-bits versie van Windows worden uitgevoerd.",
  DntEmptyString,
  "Gebruik in plaats hiervan WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Setup heeft vastgesteld dat er niet genoeg geheugen in deze computer",
  "is genstalleerd om Windows XP te kunnen uitvoeren",
  DntEmptyString,
  "Benodigd geheugen: %lu%s MB",
  "Aanwezig geheugen: %lu%s MB",
  NULL
}
};

//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "U hebt Setup gevraagd de Windows XP-bestanden uit de onderstaande",
    "map te verwijderen. De Windows-installatie in deze map zal voorgoed",
    "onbruikbaar zijn.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Druk op F3 als u Setup wilt beindigen zonder de bestanden te",
    "   verwijderen.",
    "  Druk op X als u de Windows-bestanden uit de bovengenoemde map",
    "   wilt verwijderen.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup kan het onderstaande installatielogboekbestand niet openen",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kan de Windows-bestanden niet uit de opgegeven map verwijderen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup kan de sectie %s niet in het onderstaande",
  "installatielogboekbestand vinden.", 
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kan de Windows-bestanden niet uit de opgegeven map verwijderen",
NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           De Windows-bestanden worden verwijderd.",
NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup kan het Windows-opstartlaadprogramma niet installeren.",
  DntEmptyString,
  "Controleer of station C: is geformatteerd en of het station niet",
  "is beschadigd.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Kan geen toegang krijgen tot het scriptbestand dat met de",
  "schakeloptie /u is opgegeven.",
  DntEmptyString,
  "Installatie zonder toezicht kan niet doorgaan.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Het scriptbestand dat met de schakeloptie /u is opgegeven",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "bevat een syntaxisfout in regel %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Er is een interne fout in Setup opgetreden.",
  DntEmptyString,
  "De vertaalde opstartberichten zijn te lang.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Er is een interne fout in Setup opgetreden.",
  DntEmptyString,
  "Het wisselbestand kan nergens worden gemaakt.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Setup heeft SmartDrive niet op de computer gevonden. SmartDrive",
  "verbetert de prestaties tijdens deze fase van de installatie.",
  DntEmptyString,
  "U moet Setup nu afsluiten, SmartDrive starten en vervolgens Setup",
  "opnieuw starten.",
  "Raadpleeg de DOS-handleiding voor meer informatie over SmartDrive.",
  DntEmptyString,
    "  Druk op F3 als u Setup wilt afsluiten.",
    "  Druk op ENTER als u zonder SmartDrive wilt doorgaan.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR ontbreekt";
CHAR BootMsgDiskError[] = "Schijffout";
CHAR BootMsgPressKey[] = "Druk toets om opnieuw te starten";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\no\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Tidligere operativsystem p C:";

CHAR DntBootIniLine[] = "Installere eller Oppgradere Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installere Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Installere Windows XP Home Edition\n";
CHAR DntWorkstationHeader[]   = "\n Installere Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Installere Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Analyserer argumenter...";
CHAR DntEnterEqualsExit[]     = "Enter=Avslutt";
CHAR DntEnterEqualsRetry[]    = "Enter=Prv igjen";
CHAR DntEscEqualsSkipFile[]   = "ESC=Hopp over filen";
CHAR DntEnterEqualsContinue[] = "Enter=Fortsett";
CHAR DntPressEnterToExit[]    = "Installasjonsprogrammet kan ikke fortsette. Trykk Enter for  avslutte.";
CHAR DntF3EqualsExit[]        = "F3=Avslutt";
CHAR DntReadingInf[]          = "Leser INF-filen %s...";
CHAR DntCopying[]             = "  Kopierer: ";
CHAR DntVerifying[]           = "   Sjekker: ";
CHAR DntCheckingDiskSpace[]   = "Kontrollerer diskplass...";
CHAR DntConfiguringFloppy[]   = "Konfigurerer diskett...";
CHAR DntWritingData[]         = "Skriver installasjonsparametere...";
CHAR DntPreparingData[]       = "Henter installasjonsparametere...";
CHAR DntFlushingData[]        = "Flytter data til disken...";
CHAR DntInspectingComputer[]  = "Kontrollerer datamaskinen...";
CHAR DntOpeningInfFile[]      = "pner INF-filen...";
CHAR DntRemovingFile[]        = "Fjerner filen %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Fjern filer";
CHAR DntXEqualsSkipFile[]     = "X=Hopp over fil";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installerer Windows 2002 Server eller Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:]kildebane] [/t[:]midlstasjon]",
    "      [/u[:svarfil]] [/udf:id[,UDF_fil]]",
    "      [/r:mappe] [/r[x]:mappe] [/e:kommando] [/a]",
    "",
    "",
    "/s[:kildebane]",
    "   Angir kildeplasseringen til Windows-filene.",
    "   Dette m vre en fullstending bane av typen x:[bane] ",
    "   eller \\\\server\\ressurs[\\bane].",
    "",
    "/t[:midlstasjon]",
    "   Angir at installasjonsprogrammet skal plassere midlertidige filer p.",
    "   den angitte stasjonen, og installere Windows XP p den stasjonen.",
    "   Hvis du ikke angir en plassering, vil installasjonsprogrammet prve ",
    "   finne en stasjon.",
    "",
    "/u[:svarfil]",
    "   Utfrer en uovervket installasjon ved hjelp av en svarfil (krever",
    "   /s). Svarfilen gir svar p noen eller alle sprsmlene som slutt-",
    "   brukeren vanligvis svarer p under installasjonen.",
    "",
    "udf:id[,UDF_file] ",
    "   Angir en identifikator (id) som installasjonsprogrammet bruker til ",
    "   angi hvordan en UDF (Uniqueness Database File) endrer en svarfil (se",
    "   /u). Parameteren /udf overstyrer verdier i svarfilen, og identifika-",
    "   toren angir hvilke verdier i UDF-filen som brukes. Hvis UDF_fil ikke",
    "   angis, vil installasjonsprogrammet be om en diskett som inneholder",
    "   filen $Unique$.udb.",
    "",
    "/r[:mappe]",
    "   Angir en valgfri mappe som skal installeres. Mappen fjernes ikke nr",
    "   installasjonen er fullfrt.",
    "",
    "/rx[:mappe]",
    "   Angir en valgfri mappe som skal kopieres. Mappen slettes nr instal-",
    "   lasjonen er fullfrt",
    "",
    "/e Angir kommando som skal kjres p slutten av den GUI-installasjonen.",
    "",
    "/a Aktiverer tilgjengelighetsalternativer.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installerer Windows XP.",
    "",
    "WINNT [/S[:]kildebane] [/T[:]midlstasjon] [/I[:]inffil]",
    "      [[/U[:skriptfil]]",
    "      [/R[X]:mappe] [/E:kommando] [/A]",
    "",
    "/D[:]winntroot",
    "       Dette alternativet stttes ikke lenger.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
		   { "Ikke nok minne til installasjonsprogrammet. Kan ikke fortsette.",
		     NULL
		   }
		 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Velg tilgjengelighetsalternativene som skal installeres:",
    DntEmptyString,
    "[ ] Trykk F1 for Microsoft Forstrrelsesprogram",
#ifdef NARRATOR
    "[ ] Trykk F2 for Microsoft Talesystem",
#endif
#if 0
    "[ ] Trykk F3 for Microsoft Skjermtastatur",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Installasjonsprogrammet m vite plasseringen til Windows XP-",
  "filene. Angi banen til Windows XP-filene.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
		 { "Angitt kilde er enten ugyldig, utilgjengelig, eller inneholder ikke",
		   "en gyldig Windows XP-installasjon.  Skriv inn en ny bane hvor",
		   "Windows XP-filene finnes. Bruk Tilbake for  slette tegn og",
		   "skriv inn banen.",
		   NULL
		 }
	       };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
	      { "Installasjonsprogrammet kunne ikke lese informasjonsfilen, eller s er",
		"informasjonsfilen skadet. Kontakt systemansvarlig.",
		NULL
	      }
	    };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{  "Stasjonen du har valgt for midlertidige installasjonsfiler er ikke",
   "en gyldig stasjon, eller har ikke minst %u MB (%lu byte) ledig",
   "plass.",
   NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{ "Windows XP krever et harddiskvolum med minst %u MB",
  "(%lu bytes)ledig diskplass. Installasjonsprogrammet vil bruke deler av",
  "denne plassen til  lagre midlertidige filer under installasjonen.",
  "Stasjonen m vre en fast tilkoblet, lokal harddisk som kan brukes av",
  "Windows XP, og kan ikke vre en komprimert stasjon.",
  DntEmptyString,
  "Installasjonsprogrammet fant ingen slik stasjon med den ndvendige mengden",
  "ledig plass.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Det er ikke nok ledig plass p oppstartsstasjonen (vanligvis C:)",
  "til diskettfri operasjon. Diskettfri operasjon krever minst",
  "3,5 MB (3 641 856 byte) ledig plass p den stasjonen.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
		     { "[%s]-avsnittet i informasjonsfilen til installasjonsprogrammet",
		       "mangler eller er skadet. Kontakt systemansvarlig.",
		       NULL
		     }
		   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
		     { "Installasjonsprogrammet kan ikke opprette flgende mappe p mlstasjonen:",
		       DntEmptyString,
		       "%s",
		       DntEmptyString,
		       "Kontroller at mlstasjonen ikke inneholder filer med samme navn som",
		       "mlmappen. Kontroller ogs kabeltilkoblingen til stasjonen.",
		       NULL
		     }
		   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Installasjonsprogrammet kan ikke kopiere filen:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Trykk Enter for  prve  kopiere p nytt.",
   "  Trykk ESC for  ignorere feilen og fortsette installasjonsprogrammet.",
   "  Trykk F3 for  avslutte installasjonsprogrammet.",
   DntEmptyString,
   "Obs!  Hvis du velger  ignorere feilen kan du f problemer senere i",
   "installasjonsprogrammet.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Kopien installasjonsprogrammet lagde av filen nedenfor er ikke identisk",
   "med originalen. Dette kan vre p grunn av nettverksfeil, diskettproblemer",
   "eller andre maskinvareproblemer.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Trykk Enter for  prve  kopiere p nytt.",
   "  Trykk ESC for  ignorere feilen og fortsette installasjonsprogrammet.",
   "  Trykk F3 for  avslutte installasjonsprogrammet.",
   DntEmptyString,
   "Obs!  Hvis du velger  ignorere feilen kan du f problemer senere i",
   "installasjonsprogrammet.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Hvis du ignorerer denne meldingen, vil ikke filen bli kopiert.",
   "Dette alternativet er for erfarne brukere som forstr",
   "konsekvensen av manglende systemfiler.",
   DntEmptyString,
   "  Trykk Enter for  prve  kopiere p nytt.",
   "  Trykk X for  hoppe over filen.",
   DntEmptyString,
   "Obs!  Hvis du hopper over filen er det ikke sikkert at Windows",
   "XP vil bli fullstendig installert eller oppgradert.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
	{ "Vent mens installasjonsprogrammet fjerner midlertidige filer.",
	   NULL
	}
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 8,6,
		   { "Vent mens installasjonsprogrammet kopierer filer til harddisken.",
		     NULL
		   }
		 },
DnsWaitCopyFlop= { 8,6,
		   { "Vent mens installasjonsprogrammet kopierer filer til disketten.",
		     NULL
		   }
		 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Installasjonsprogrammet trenger fire formaterte og tomme disketter med hy",
   "tetthet. Installasjonsprogrammet vil referere til disse diskettene som",
   "\"Oppstartsdiskett for Windows XP\",",
   "\"Installasjonsdiskett 2 for Windows XP\",",
   "\"Installasjonsdiskett 3 for Windows XP\" og",
   "\"Installasjonsdiskett 4 for Windows XP\".",
   DntEmptyString,
   "Sett en av disse fire diskettene inn i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 4 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 4 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 3 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 2 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Oppstartsdiskett for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Installasjonsprogrammet trenger fire formaterte og tomme disketter med hy",
   "tetthet. Installasjonsprogrammet vil referere til disse diskettene som",
   "\"Oppstartsdiskett for Windows XP\",",
   "\"Installasjonsdiskett 2 for Windows XP\",",
   "\"Installasjonsdiskett 3 for Windows XP\" og",
   "\"Installasjonsdiskett 4 for Windows XP\".",
   DntEmptyString,
   "Sett en av disse fire diskettene inn i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 4 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 4 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 3 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Installasjonsdiskett 2 for Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Sett inn en formatert og tom diskett med hy tetthet i stasjon A:.",
   "Denne disketten vil bli \"Oppstartsdiskett for Windows XP\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Disketten er ikke formatert for bruk med MS-DOS.",
  "Denne disketten kan ikke brukes av installasjonsprogrammet.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Denne disketten er enten ikke formatert med hy tetthet eller for bruk ",
  "med standard MS-DOS, eller den er skadet. Disketten kan ikke brukes.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Installasjonsprogrammet finner ikke ut hvor mye ledig plass det er p.",
  "disketten. Den kan ikke brukes.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Disketten har ikke hy tetthet, eller er ikke tom.",
  "Den kan ikke brukes.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Installasjonsprogrammet kan ikke skrive til systemomrdet p disketten.",
  "Disketten er sannsynligvis ubrukelig.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Dataene som installasjonsprogrammet leste fra systemomrdet p disketten er",
  "ikke lik dataene som ble skrevet, eller s kunne ikke systemomrdet p",
  "disketten leses for bekreftelse.",
  DntEmptyString,
  "Det kan vre en eller flere grunner til dette:",
  DntEmptyString,
  "  Datamaskinen er infisert av et virus.",
  "  Disketten er skadet.",
  "  Det er et maskinvare- eller konfigurasjonsproblem med diskettstasjonen",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Installasjonsprogrammet kan ikke skrive til disketten i stasjon A:.",
  "Disketten kan vre skadet. Prv en annen diskett",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
		  { "ͻ",
		    "  Windows XP er ikke fullstendig installert p      ",
		    "  datamaskinen. Hvis du avslutter installasjons-    ",
		    "  programmet, m du kjre installasjonsprogrammet   ",
		    "  p nytt for  installere Windows XP.              ",
		    "                                                    ",
		    "      Trykk Enter for  fortsette.                 ",
		    "      Trykk F3 for  avslutte.                     ",
		    "ĺ",
		    "  F3=Avslutt  Enter=Fortsett                        ",
		    "ͼ",
		    NULL
		  }
		};



//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er fullfrt.",
  "Datamaskinen vil n bli startet p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Kontroller at disketten \"Oppstartsdiskett for Windows XP\" ",
  "er satt inn i stasjon A: fr du fortsetter.",
  DntEmptyString,
  "Trykk Enter for  starte datamaskinen p nytt og fortsette.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er fullfrt.",
  "Datamaskinen vil n bli startet p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Kontroller at disketten \"Oppstartsdiskett for Windows XP\" ",
  "er satt inn i stasjon A: fr du fortsetter.",
  DntEmptyString,
  "Trykk Enter for  starte datamaskinen p nytt og fortsette.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er ferdig.",
  "Datamaskinen vil n bli startet p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Hvis det er en diskett i stasjon A: m den fjernes.",
  DntEmptyString,
  "Trykk Enter for  starte datamaskinen p nytt og fortsette.",
  NULL
}
};

//
//Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er ferdig.",
  "Du m n starte datamaskinen p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Kontroller at disketten \"Oppstartsdiskett for Windows XP\" ",
  "er satt inn i stasjon A: fr du fortsetter.",
  DntEmptyString,
  "Trykk Enter for  g tilbake til MS-DOS, og start datamaskinen p nytt",
  "for  fortsette installasjonen av Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er ferdig.",
  "Du m n starte datamaskinen p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Kontroller at disketten \"Oppstartsdiskett for Windows XP\"",
  "er satt inn i stasjon A: fr du fortsetter.",
  DntEmptyString,
  "Trykk Enter for  g tilbake til MS-DOS, og start datamaskinen p nytt",
  "for  fortsette installasjonen av Windows XP",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Den MS-DOS-baserte delen av installasjonsprogrammet er ferdig.",
  "Du m n starte datamaskinen p nytt. Windows XP-",
  "installasjonen fortsetter etter omstarten.",
  DntEmptyString,
  "Hvis det er en diskett i stasjon A:, m den fjernes.",
  DntEmptyString,
  "Trykk Enter for  g tilbake til MS-DOS, og start datamaskinen p nytt",
  "for  fortsette installasjonen av Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
	     { "ͻ",
	       " Installasjonsprogrammet kopierer filer...                      ",
	       "                                                                ",
	       "      Ŀ      ",
	       "                                                              ",
	       "            ",
	       "ͼ",
	       NULL
	     }
	   };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Dette programmet krever MS-DOS versjon 5.0 eller nyere.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Installasjonsprogrammet har oppdaget at stasjon A: enten ikke finnes",
  "eller er en stasjon med lav tetthet. Installasjonsprogrammer krever",
  "en stasjon med en kapasitet p minst 1,2 MB.",
#else
{ "Installasjonsprogrammet har oppdaget at stasjon A: enten ikke finnes",
  "eller ikke er en 3.5\"-stasjon med hy tetthet. Installasjonsprogrammet",
  "krever en stasjon med en kapasitet p minst 1,44 MB.",
  DntEmptyString,
  "For  installere Windows XP uten  bruke disketter, m du starte",
  "dette programmet p nytt med bryteren /b fra kommandolinjen.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Installasjonsprogrammet har oppdaget at datamaskinens CPU ikke er en",
   "80486 eller nyere. Windows XP kan ikke kjres p denne maskinen.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dette programmet kan ikke kjres p 32-biters Windows-versjoner.",
  DntEmptyString,
  "Bruk Winnt32.exe i stedet.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Installasjonsprogrammet har oppdaget at det ikke er nok minne p denne",
  "datamaskinen til  kjre Windows XP.",
  DntEmptyString,
  "Minne som kreves:    %lu%s MB",
  "Minne som er funnet: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Du har bedt installasjonsprogrammet om  fjerne Windows XP-filer",
    "fra mappen som er nevnt nedenfor. Windows-installasjonen i denne mappen",
    "vil bli delagt for godt.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Trykk F3 for  avslutte installasjonsprogrammet uten  fjerne filer.",
    "  Trykk X for  fjerne Windows-filene fra mappen ovenfor.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Installasjonsprogrammet kunne ikke pne loggfilen nevnt nedenfor.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Installasjonsprogrammet kunne ikke fjerne filer fra den angitte katalogen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Installasjonsprogrammet finner ikke avsnittet %s",
  "i loggfilen som er nevnt nedenfor.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Installasjonsprogrammet kunne ikke fjerne filer fra den angitte mappen.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vent mens installasjonsprogrammet fjerner Windows-filene.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Installasjonsprogrammet kan ikke installere oppstartslasteren for Windows.",
  DntEmptyString,
  "Kontroller at stasjon C: er formatert, og at stasjonen ikke er",
  "skadet.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Fr ikke tilgang til skriptfilen som ble angitt med kommandolinje-",
  "bryteren /u.",
  DntEmptyString,
  "Ouvervket operasjon kan ikke fortsette.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Skriptfilen angitt med kommandolinjebryteren /u ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "har en syntaksfeil i linje %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Det har oppsttt en intern installasjonsfeil.",
  DntEmptyString,
  "De oversatte oppstartsmeldingene er for lange.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Det har oppsttt en intern installasjonsfeil.",
  DntEmptyString,
  "Ikke nok plass til vekslefil.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Installasjonsprogrammet har ikke oppdaget SmartDrive p datamaskinen.",
  "SmartDrive ker ytelsen betydelig for denne delen av installasjonen.",
  DntEmptyString,
  "Du br avslutte n, starte SmartDrive og kjre installasjonsprogrammet",
  "p nytt. Se i DOS-dokumentasjonen for mer informasjon om SmartDrive.",
  DntEmptyString,
    "  Trykk F3 for  avslutte installasjonsprogrammet.",
    "  Trykk Enter for  fortsette uten SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR mangler";
CHAR BootMsgDiskError[] = "Diskfeil";
CHAR BootMsgPressKey[] = "Trykk en tast for  starte p nytt";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\tst\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\tr\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Pseudo.

CFOPT=-DLCP -DTR

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\us2\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

BINPLACE_OPT=-P .\placefil.txt

DNTEXT_C_FILE= $(O)\dntext.c

!INCLUDE ..\makefile.inc

$(O)\dntext.c : ..\usa\dntext.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\usa\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows XP Installation/Upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Personal Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional Setup\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server Setup\n";
CHAR DntParsingArgs[]         = "Parsing arguments...";
CHAR DntEnterEqualsExit[]     = "ENTER=Exit";
CHAR DntEnterEqualsRetry[]    = "ENTER=Retry";
CHAR DntEscEqualsSkipFile[]   = "ESC=Skip File";
CHAR DntEnterEqualsContinue[] = "ENTER=Continue";
CHAR DntPressEnterToExit[]    = "Setup cannot continue. Press ENTER to exit.";
CHAR DntF3EqualsExit[]        = "F3=Exit";
CHAR DntReadingInf[]          = "Reading INF file %s...";
CHAR DntCopying[]             = "   Copying: ";
CHAR DntVerifying[]           = " Verifying: ";
CHAR DntCheckingDiskSpace[]   = "Checking disk space...";
CHAR DntConfiguringFloppy[]   = "Configuring floppy disk...";
CHAR DntWritingData[]         = "Writing Setup parameters...";
CHAR DntPreparingData[]       = "Determining Setup parameters...";
CHAR DntFlushingData[]        = "Flushing data to disk...";
CHAR DntInspectingComputer[]  = "Inspecting computer...";
CHAR DntOpeningInfFile[]      = "Opening INF file...";
CHAR DntRemovingFile[]        = "Removing file %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remove files";
CHAR DntXEqualsSkipFile[]     = "X=Skip File";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Sets up Windows 2002 Server or Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:sourcepath]] [/t[:tempdrive]]",
    "      [/u[:answer file]] [/udf:id[,UDF_file]]",
    "      [/r:folder] [/r[x]:folder] [/e:command] [/a]",
    "",
    "",
    "/s[:sourcepath]",
    "   Specifies the source location of the Windows files.",
    "   The location must be a full path of the form x:[path] or ",
    "   \\\\server\\share[path]. ",
    "",
    "/t[:tempdrive]",
    "   Directs Setup to place temporary files on the specified",
    "   drive and to install Windows XP on that drive. If you do ",
    "   do not specify a location, Setup attempts to locate a drive ",
    "   for you.",
    "",
    "/u[:answer file]",
    "   Performs an unattended Setup using an answer file (requires",
    "   /s). The answer file provides answers to some or all of the",
    "   prompts that the end user normally responds to during Setup.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indicates an identifier (id) that Setup uses to specify how ",
    "   a Uniqueness Database File (UDF) modifies an answer file  ",
    "   (see /u).The /udf parameter overrides values in the answer ",
    "   file, and the identifier determines which values in the UDF",
    "   file are used. If no UDF_file is specified, Setup prompts ",
    "   you to insert a disk that contains the $Unique$.udb file.",
    "",
    "/r[:folder]",
    "   Specifies an optional folder to be installed. The folder",
    "   remains after Setup finishes.",
    "",
    "/rx[:folder]",
    "   Specifies an optional folder to be copied. The folder is ",
    "   deleted after Setup finishes.",
    "",
    "/e Specifies a command to be executed at the end of GUI-mode Setup.",
    "",
    "/a Enables accessibility options.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installs Windows XP.",
    "",
    "WINNT [/S[:]sourcepath] [/T[:]tempdrive] [/I[:]inffile]",
    "      [[/U[:scriptfile]]",
    "      [/R[X]:directory] [/E:command] [/A]",
    "",
    "/D[:]winntroot",
    "       This option is no longer supported.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Setup is out of memory and cannot continue.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Choose the accessibility utilities to install:",
    DntEmptyString,
    "[ ] Press F1 for Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Press F2 for Microsoft Narrator",
#endif
#if 0
    "[ ] Press F3 for Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Setup needs to know where the Windows XP files are located.",
  "Enter the path where Windows XP files are to be found.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "The source specified is not valid, not accessible, or does not contain a",
                   "valid Windows XP Setup installation.  Enter a new path where Windows XP",
                   "files are to be found.  Use the BACKSPACE key to delete characters and then",
                   "type the path.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Setup was unable to read its information file, or the information file is",
                "corrupt.  Contact your system administrator.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "The drive you have specified to contain temporary setup files is not",
  "a valid drive or does not contain at least %u megabytes (%lu bytes)",
  "of free space.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP requires a hard drive volume with at least %u megabytes",
   "(%lu bytes) of free disk space. Setup will use part of this space",
   "for storing temporary files during installation. The drive must be",
   "on a permanently attached local hard disk supported by Windows XP,",
   "and must not be a compressed drive.",
   DntEmptyString,
   "Setup was unable to locate such a drive with the required amount of free",
   "space.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "There is not enough space on your startup drive (usually C:)",
  "for floppyless operation. Floppyless operation requires at least",
  "3.5 MB (3,641,856 bytes) of free space on that drive.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "The [%s] section of the Setup information file is",
                       "not present or is corrupt.  Contact your system administrator.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Setup was unable to create the following directory on the target drive:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Check the target drive and make sure no files exist with names that",
                       "coincide with the target directory.  Also check cabling to the drive.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup was unable to copy the following file:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press ESC to ignore the error and continue Setup.",
   "  Press F3 to exit Setup.",
   DntEmptyString,
   "Note: If you choose to ignore the error and continue you may encounter",
   "errors later in Setup.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "The copy made by Setup of the file listed below is not identical to the",
   "original. This may be the result of network errors, floppy disk problems,",
   "or other hardware-related trouble.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press ESC to ignore the error and continue Setup.",
   "  Press F3 to exit Setup.",
   DntEmptyString,
   "Note: If you choose to ignore the error and continue you may encounter",
   "errors later in Setup.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignoring the error means that this file will not be copied.",
   "This option is intended for advanced users who understand",
   "the ramifications of missing system files.",
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press X to skip this file.",
   DntEmptyString,
   "Note: If you skip the file, Setup cannot guarantee",
   "successful installation or upgrade of Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Please wait while Setup removes previous temporary files.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Please wait while Setup copies files to your hard disk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Please wait while Setup copies files to the floppy disk.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Setup requires you to provide four formatted, blank high-density floppy",
   "disks. Setup will refer to these disks as \"Windows XP Setup",
   "Boot Disk,\" \"Windows XP Setup Disk #2,\" \"Windows XP",
   " Setup Disk #3\" and \"Windows XP Setup Disk #4.\"",
   DntEmptyString,
   "Please insert one of these four disks into drive A:.",
   "This disk will become \"Windows XP Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #3.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #2.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Boot Disk.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Setup requires you to provide four formatted, blank high-density floppy",
   "disks. Setup will refer to these disks as \"Windows XP Setup",
   "Boot Disk,\" \"Windows XP Setup Disk #2,\" \"Windows XP",
   "Setup Disk #3,\" and \"Windows XP Setup Disk #4.\"",
   DntEmptyString,
   "Please insert one of these four disks into drive A:.",
   "This disk will become \"Windows XP Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #3.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Disk #2.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows XP Setup Boot Disk.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "The floppy disk you have provided is not formatted for use with MS-DOS.",
  "Setup is unable to use this disk.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "This floppy disk is not formatted high-density, not formatted with a",
  "standard MS-DOS format, or is corrupted. Setup is unable to use this disk.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup is unable to determine the amount of free space on the floppy disk",
  "you have provided. Setup is unable to use this disk.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "The floppy you have provided is not high-density or is not blank.",
  "Setup is unable to use this disk.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup was unable to write to the system area of the floppy disk you have",
  "provided. The disk is probably unusable.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "The data Setup read from the system area of the floppy disk does not match",
  "the data that was written, or Setup was unable to read the system area of",
  "the floppy disk for verification.",
  DntEmptyString,
  "This is caused by one or more of the following conditions:",
  DntEmptyString,
  "  Your computer has been infected by a virus.",
  "  The floppy disk you have provided is damaged.",
  "  A hardware or configuration problem exists with the floppy disk drive.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup was unable to write to the floppy disk in drive A:. The floppy disk",
  "may be damaged. Try a different floppy disk.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Windows XP is not completely set up on your       ",
                    "  computer. If you quit Setup now, you will need    ",
                    "  to run Setup again to set up Windows XP.          ",
                    "                                                    ",
                    "      Press ENTER to continue Setup.               ",
                    "      Press F3 to quit Setup.                      ",
                    "ĺ",
                    "  F3=Exit  ENTER=Continue                           ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows XP Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows XP Setup.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows XP Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows XP Setup.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "If there is a floppy disk in drive A:, remove it now.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows XP Setup.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows XP Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows XP Setup.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows XP Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows XP Setup.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows XP Setup will continue.",
  DntEmptyString,
  "If there is a floppy disk in drive A:, remove it now.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows XP Setup.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Setup is copying files...                                      ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "This program requires MS-DOS version 5.0 or higher to run.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Setup has determined that floppy drive A: is non-existent or is a low",
  "density drive. A drive with a capacity of 1.2 Megabytes or higher is",
  "required to run Setup.",
#else
{ "Setup has determined that floppy drive A: is non-existent or is not",
  "a high-density 3.5\" drive. An A: drive with a capacity of 1.44 Megabytes",
  "or higher is required for Setup operation with floppies.",
  DntEmptyString,
  "To install Windows XP without using floppies, restart this program",
  "and specify /b on the command line.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Setup has determined that this computer does not contain an 80486 or",
  "later CPU. Windows XP cannot run on this computer.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "This program does not run on any 32-bit version of Windows.",
  DntEmptyString,
  "Use WINNT32.EXE instead.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Setup has determined that there is not enough memory installed in",
  "this computer for Windows XP.",
  DntEmptyString,
  "Memory required: %lu%s MB",
  "Memory detected: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "You have asked Setup to remove Windows XP files from the directory",
    "named below. The Windows installation in this directory will be",
    "permanently destroyed.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Press F3 to exit Setup without removing any files.",
    "  Press X to remove Windows files from the above directory.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup was unable to open the setup log file named below.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup is unable to remove Windows files from the specified directory.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup is unable to find the %s section in the setup",
  "log file named below.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup is unable to remove Windows files from the specified directory.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Please wait while Setup removes Windows files.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup was unable to install Windows Boot Loader.",
  DntEmptyString,
  "Ensure that your C: drive is formatted and that the drive is not",
  "damaged.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "The script file specified with the /u command line switch",
  "could not be accessed.",
  DntEmptyString,
  "Unattended operation cannot continue.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "The script file specified with the /u command line switch",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contains a syntax error on line %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "The translated boot messages are too long.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "Could not find a place for a swap file.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Setup did not detect SmartDrive on your computer. SmartDrive will",
  "greatly improve the performance of this phase of Windows Setup.",
  DntEmptyString,
  "You should exit now, start SmartDrive, and then restart Setup.",
  "See your DOS documentation for details about SmartDrive.",
  DntEmptyString,
    "  Press F3 to exit Setup.",
    "  Press ENTER to continue without SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\tr\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "C zerindeki nceki letim Sistemi:";

CHAR DntBootIniLine[] = "Windows XP Ykleme/Ykseltme";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows XP Kur\n";
CHAR DntPersonalHeader[]      = "\n Windows XP Personal Kur\n";
CHAR DntWorkstationHeader[]   = "\n Windows XP Professional Kur\n";
CHAR DntServerHeader[]        = "\n Windows 2002 Server Kur \n";
CHAR DntParsingArgs[]         = "Deikenleri zmlyor...";
CHAR DntEnterEqualsExit[]     = "ENTER=k";
CHAR DntEnterEqualsRetry[]    = "ENTER=Yeniden Dene";
CHAR DntEscEqualsSkipFile[]   = "ESC=Dosyay Ge";
CHAR DntEnterEqualsContinue[] = "ENTER=Devam";
CHAR DntPressEnterToExit[]    = "Kur devam edemiyor. kmak iin ENTER'a basn";
CHAR DntF3EqualsExit[]        = "F3=k";
CHAR DntReadingInf[]          = "INF dosyas %s okunuyor...";
CHAR DntCopying[]             = "   Kopyalanyor: ";
CHAR DntVerifying[]           = " Dorulanyor: ";
CHAR DntCheckingDiskSpace[]   = "Disk alan inceleniyor...";
CHAR DntConfiguringFloppy[]   = "Disk yaplandrlyor...";
CHAR DntWritingData[]         = "Kur parametreleri yazlyor...";
CHAR DntPreparingData[]       = "Kur parametreleri belirleniyor...";
CHAR DntFlushingData[]        = "Veriler diske atlyor...";
CHAR DntInspectingComputer[]  = "Bilgisayar denetleniyor...";
CHAR DntOpeningInfFile[]      = "INF dosyas alyor...";
CHAR DntRemovingFile[]        = "%s dosyas kaldrlyor";
CHAR DntXEqualsRemoveFiles[]  = "X=Dosyalar kaldr";
CHAR DntXEqualsSkipFile[]     = "X=Dosyay Ge";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows 2002 Server ya da Windows XP Professional kurar.",
    "",
    "",
    "WINNT [/s[:kaynakyolu]] [/t[:geicisrc]]",
    "	   [/u[:yant dosyas]] [/udf:id[,UDF_dosyas]]",
    "	   [/r:klasr] [/r[x]:klasr] [/e:komut] [/a]",
    "",
    "",
    "/s[:kaynakyolu]",
    "   Windows dosyalarnn kaynan belirtir.",
    "   Yer, x:\\[yol] ya da \\\\sunucu\\paylam[yol]",
    "   biiminde tam bir yol olmal. ",
    "",
    "/t[:geicisrc]",
    "	Kur'u geici dosyalar belirtilen srcye yerletirmeye ve ",
    "   Windows XP'yi o srcye yklemeye ynlendirir. Bir yer ",
    "   belirtmezseniz, Kur sizin yerinize bir src bulmay ",
    "	dener.",
    "",
    "/u[:yant dosyas]",
    "	Bir yant dosyas kullanarak katlmsz bir Kur gerekletirir (/s ",
    "	gerektirir). Yant dosyas Kur srasnda normal olarak son kullancnn ",
    "   yantlad sorularn bir ksmna ya da tmne yantlar verir.",
    "",
    "/udf:id[,UDF_dosyas]	",
    "	Kur'un, Benzersizlik Veritaban Dosyasnn (UDF) yant dosyasn nasl ",
    "	deitireceini belirlemekte kullanaca kimlii (id) belirtir ",
    "   (bkz /u). /udf parametresi yant dosyasndaki deerleri geersiz klar ",
    "	ve kimlik, UDF dosyasndaki hangi deerlerin kullanldn belirler. ",
    "   UDF_dosyas belirtilmezse Kur $Unique$.udb dosyasn ieren ",
    "	diski yerletirmenizi ister.",
    "",
    "/r[:klasr]",
    "	Yklenecek seime bal bir klasr belirtir. Klasr ",
    "	Kur bittikten sonra kalr.",
    "",
    "/rx[:klasr]",
    "	Kopyalanacak seime bal bir klasr belirtir. Kur ",
    "	bittikten sonra klasr silinir.",
    "",
    "/e	GUI kipte Kur sonunda altrlacak bir komut belirtir.",
    "",
    "/a	Eriilebilirlik seeneklerini etkinletir.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows XP'yi Ykler.",
    "",
    "WINNT [/S[:]kaynakyolu] [/T[:]geicisrc] [/I[:]infdosyas]",
    "      [[/U[:komutdosyas]]",
    "      [/R[X]:dizin] [/E:komut] [/A]",
    "",
    "/D[:]winntkk",
    "       Bu seenek artk desteklenmiyor.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Bellek bittiinden Kur devam edemiyor.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Yklenecek eriilebilirlik hizmet programlarn sein:",
    DntEmptyString,
    "[ ] Microsoft Byte iin F1'e basn",
#ifdef NARRATOR
    "[ ] Microsoft Okuyucu iin F2'ye basn",
#endif
#if 0
    "[ ] Microsoft Ekran Klavyesi iin F3'e basn",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Kur'un Windows XP dosyalarnn yerini bilmesi gerekiyor. ",
  "Windows XP dosyalarnn bulunduu yolu girin.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Belirtilen kaynak geersiz, eriilemez ya da geerli bir ",
                   "Windows XP Kur yklemesi iermiyor.  Windows XP ",
                   "dosyalarnn bulunduu yeni bir yol girin.  Karakterleri ",
                   "silmek iin BACKSPACE tuunu kullanp yolu yazn.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Kur, bilgi dosyasn okuyamad ya da bilgi dosyas bozuk. ",
                "Sistem yneticinizle grn.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Geici kur dosyalarn ierdiini belirttiiniz src geerli bir ",
  "src deil ya da en az %u megabayt bo alan ",
  "iermiyor (%lu bayt).",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP, en az %u megabayt (%lu bayt) bo alan olan ",
   "bir sabit disk gerektirir. Kur, bu alann bir ksmn ykleme ",
   "srasnda geici dosyalar saklamak iin kullanr. Src, ",
   "Windows XP tarafndan desteklenen kalc olarak bal yerel ",
   "bir sabit disk zerinde olmal ve sktrlm bir src olmamaldr. ",
   DntEmptyString,
   "Kur, gerekli miktarda bo alan olan bir src ",
   "bulamad.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Disketsiz ilem iin balang srcnzde yeterli alan yok (genellikle C:)",
  "Disketsiz ilem, src zerinde en az 3.5 MB (3,641,856 bayt) ",
  "bo alan gerektirir.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Kur bilgi dosyasnn [%s] blm yok ya da bozuk. ",
                       "Sistem yneticinizle grn.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Kur, hedef srcde aadaki dizini oluturamad:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Hedef srcy denetleyip hedef dizinle ad akan dosya ",
                       "olmamasn salayn.  Src kablo balantsn da denetleyin.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Kur aadaki dosyay kopyalayamad:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Hatay yoksayarak Kur'a devam etmek iin ESC'e basn.",
   "  Kur'dan kmak iin F3'e basn.",
   DntEmptyString,
   "Not: Hatay yoksayarak devam etmeyi seerseniz daha sonra Kur'da",
   "hatalarla karlaabilirsiniz.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Dosyann Kur tarafndan oluturulan aadaki kopyas zgn kopyayla",
   "ayn deil. Bu, a hatalarnn, disket sorunlarnn ya da dier donanmla",
   "ilgili sorunlarn sonucu olabilir.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Hatay yoksayp Kur'a devam etmek iin ESC'e basn.",
   "  Kur'dan kmak iin F3'e basn.",
   DntEmptyString,
   "Not: Hatay yoksayp devam etmeyi seerseniz daha sonra Kur'da ",
   "hatalarla karlaabilirsiniz.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Hatay yoksaymak bu dosyann kopyalanmayaca anlamna gelir.",
   "Bu seenek, eksik sistem dosyalarnn pratik ayrntlarn anlayan",
   "ileri dzeydeki kullanclar iin hedeflenmitir.",
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Bu dosyay gemek iin X'e basn.",
   DntEmptyString,
   "Not: Bu dosyay geerseniz, Kur baarl bir Windows XP ykleme ya da",
   "ykseltme gvencesi veremez.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Kur geici dosyalar kaldrrken bekleyin.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Kur dosyalar sabit diskinize kopyalarken bekleyin.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Kur dosyalar diskete kopyalarken bekleyin.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Kur, biimlendirilmi yksek younlukta drt bo disket salamanz ",
   "gerektirir. Kur, bu disketleri \"Windows XP Kur ",
   "nykleme Disketi,\" \"Windows XP Kur Disketi #2,\" \"Windows XP",
   " Kur Disketi #3\" ve \"Windows XP Kur Disketi #4\" olarak ister.",
   DntEmptyString,
   "Bu drt disketten birini A: srcsne yerletirin.",
   "Bu disket \"Windows XP Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #3\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #2\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur nykleme Disketi\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Kur, biimlendirilmi yksek younlukta drt bo disket salamanz ",
   "gerektirir. Kur, bu disketleri \"Windows XP Kur ",
   "nykleme Disketi,\" \"Windows XP Kur Disketi #2,\" \"Windows XP",
   " Kur Disketi #3\" ve \"Windows XP Kur Disketi #4\" olarak ister.",
   DntEmptyString,
   "Bu drt disketten birini A: srcsne yerletirin.",
   "Bu disket \"Windows XP Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #3\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur Disketi #2\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows XP Kur nykleme Disketi\" oluyor.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Saladnz disket MS-DOS ile kullanm iin biimlendirilmemi.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Bu disket yksek younlukta standart MS-DOS biimiyle biimlendirilmemi",
  "ya da bozuk. Kur bu disketi kullanamyor.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Kur, saladnz disketteki bo alan miktarn belirleyemiyor.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Saladnz disket yksek younlukta deil ya da dolu.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Kur, saladnz disketin sistem alanna yazamad.",
  "Disket kullanlamaz olabilir.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Disketin sistem alanndan Kur'un okuduu veriyle yazlan",
  "veri uyumuyor ya da Kur disketin sistem alann dorulama",
  "iin okuyamad.",
  DntEmptyString,
  "Bunun nedeni aadaki durumlardan biri ya da birka olabilir:",
  DntEmptyString,
  "  Bilgisayarnza virs bulam.",
  "  Saladnz disket zarar grm.",
  "  Disket srcsyle ilgili bir donanm ya da yaplandrma sorunu var.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Kur, A: srcsndeki diskete yazamad. Disket",
  "zarar grm olabilir. Baka bir disket deneyin.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "  Windows XP sisteminize tam olarak kurulmad.      ",
                    "  Kur'dan imdi karsanz Windows XP'yi kurmak     ",
                    "  iin Kur'u yeniden altrmanz gerekir.         ",
                    "                                                    ",
                    "      Kur'a devam etmek iin ENTER'a basn.        ",
                    "      Kur'dan kmak iin F3'e basn.              ",
                    "ĺ",
                    "  F3=k  ENTER=Devam                               ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows XP Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows XP Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows XP Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows XP Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  "A: srcsnde bir disket varsa imdi karn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows XP Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows XP Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows XP Kur'a",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows XP Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows XP Kur'a",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows XP Kur devam eder.",
  DntEmptyString,
  " A: srcsnde bir disket varsa imdi karn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows XP Kur'a ",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Kur dosyalar kopyalyor...                                    ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Bu programn almas iin MS-DOS srm 5.0 veya yukars gereklidir.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Kur, A: disket srcsnn var olmadn ya da dk younlukta bir",
  "src olduunu belirledi.  Kur'u altrmak iin 1.2 MB ya da",
  "daha yksek kapasitesi olan bir src gerekli.",
#else
{ "Kur, A: disket srcsnn var olmadn ya da yksek younlukta bir ",
  "3.5\" src olmadn belirledi. Disketlerle Kur ilemi iin 1.44",
  "MB ya da daha yksek kapasitesi olan bir A: srcs gereklidir.",
  DntEmptyString,
  "Windows XP'yi disket kullanmadan yklemek iin bu program yeniden",
  "balatn ve komut satrnda /b anahtarn belirtin.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Kur, bu bilgisayarn 80486 veya yukars bir ",
  "CPU iermediini belirledi. Windows XP bu bilgisayar zerinde alamaz.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Bu program 32-bit Windows srmlerinde altrlamaz.",
  DntEmptyString,
  "Yerine WINNT32.EXE kullann.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Kur, bu bilgisayarda Windows XP iin ykl",
  "yeterli bellek olmadn belirledi.",
  DntEmptyString,
  "Gerekli bellek: %lu%s MB",
  "Alglanan bellek: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Kur'un aadaki dizinden Windows XP dosyalarn kaldrmasn",
    "istediniz. Bu dizindeki Windows yklemesi kalc",
    "olarak kaldrlr.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Dosya kaldrmadan Kur'dan kmak iin F3'e basn.",
    "  Yukardaki dizinden Windows dosyalarn kaldrmak iin X'e basn.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Kur, aadaki kur gnlk dosyasn aamad.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Kur, belirtilen dizinden Windows dosyalarn kaldramad.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Kur, aadaki kur gnlk dosyasnda",
  "%s blmn bulamad.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Kur, belirtilen dizinden Windows dosyalarn kaldramyor.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Kur, Windows dosyalarn kaldrrken bekleyin.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Kur, Windows nykleme Ykleyicisi'ni ykleyemedi.",
  DntEmptyString,
  "C: srcnzn biimlendirilmi ve zarar",
  "grmemi olmasn salayn.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "/u komut satr anahtaryla belirtilen komut dosyasna",
  "eriilemedi.",
  DntEmptyString,
  "Katlmsz ilem devam edemiyor.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "/u komut satr anahtar ile belirtilen komut dosyas",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "bir sz dizimi hatas ieriyor. Satr %u",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Bir i Kur hatas olutu.",
  DntEmptyString,
  "evrilen nykleme iletileri ok uzun.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ " Bir i Kur hatas olutu.",
  DntEmptyString,
  "Takas dosyas iin bir yer bulunamad.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Kur, bilgisayarnzda SmartDrive alglamad. SmartDrive,",
  "Windows Kur'un bu aamadaki performansn byk lde artrr.",
  DntEmptyString,
  "imdi kp SmartDrive' balattktan sonra Kur'u yeniden",
  "balatn. SmartDrive hakknda ayrnt iin DOS belgelerinize bakn.",
  DntEmptyString,
    "  Kur'dan kmak iin F3'e basn.",
    "  SmartDrive olmadan devam etmek iin ENTER'a basn.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR eksik";
CHAR BootMsgDiskError[] = "Disk hatasi";
CHAR BootMsgPressKey[] = "Yeniden baslatmak icin bir tusa basin";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\sv\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]          = "Directories";
CHAR DnfFiles[]                = "Files";
CHAR DnfFloppyFiles0[]         = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]         = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]         = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]         = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]         = "FloppyFiles.x";
CHAR DnfSpaceRequirements[]    = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]        = "Miscellaneous";
CHAR DnfRootBootFiles[]        = "RootBootFiles";
CHAR DnfAssemblyDirectories[]  = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Tidigare operativsystem p enhet C";

CHAR DntBootIniLine[] = "Installation/uppgradering av Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installationsprogram fr Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Installationsprogram fr Windows XP Home Edition\n";
CHAR DntWorkstationHeader[]   = "\n Installationsprogram fr Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Installationsprogram fr Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Parametrar analyseras...";
CHAR DntEnterEqualsExit[]     = "Retur=Avsluta";
CHAR DntEnterEqualsRetry[]    = "Retur=Frsk igen";
CHAR DntEscEqualsSkipFile[]   = "Esc=Hoppa ver fil";
CHAR DntEnterEqualsContinue[] = "Retur=Fortstt";
CHAR DntPressEnterToExit[]    = "Det gr inte att fortstta. Tryck p Retur fr att avsluta.";
CHAR DntF3EqualsExit[]        = "F3=Avsluta";
CHAR DntReadingInf[]          = "INF-filen %s lses...";
CHAR DntCopying[]             = "   Kopierar: ";
CHAR DntVerifying[]           = " Verifierar: ";
CHAR DntCheckingDiskSpace[]   = "Diskutrymme kontrolleras...";
CHAR DntConfiguringFloppy[]   = "Disketten konfigureras...";
CHAR DntWritingData[]         = "Installationsparametrar skrivs...";
CHAR DntPreparingData[]       = "Installationsparametrar kontrolleras...";
CHAR DntFlushingData[]        = "Data skrivs till disk...";
CHAR DntInspectingComputer[]  = "Datorn undersks...";
CHAR DntOpeningInfFile[]      = "INF-fil ppnas...";
CHAR DntRemovingFile[]        = "%s tas bort";
CHAR DntXEqualsRemoveFiles[]  = "T=Ta bort filer";
CHAR DntXEqualsSkipFile[]     = "H=Hoppa ver fil";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'t',
      DniAccelRemove2 = (ULONG)'T';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'h',
      DniAccelSkip2 = (ULONG)'H';

CHAR DntEmptyString[] = "";

//
// Usage text.
//


PCHAR DntUsage[] = {

    "Installerar Windows 2002 Server eller Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:kllskvg]] [/t[:tempenhet]]",
    "      [/u[:svarsfil]] [/udf:id[,UDF_fil]]",
    "      [/r:mapp] [/r[x]:mapp] [/e:kommando] [/a]",
    "",
    "",
    " /s[:kllskvg]",
    "   Anger skvgen till kllfilerna fr Windows XP.",
    "   Mste anges som en fullstndig skvg. Anvnd syntaxen ",
    "   x:[skvg] eller \\\\server\\resurs[skvg] nr du anger skvgen. ",
    "",
    "/t[:tempenhet]",
    "   Anger att installationsprogrammet ska placera temporra filer p",
    "   den angivna enheten och att Windows XP ska installeras p den ",
    "   enheten. Om du inte anger ngon plats, kommer installationsprogrammet ",
    "   att vlja en enhet t dig.",
    "",
    "/u[:svarsfil]",
    "   Installationsprogrammet krs i obevakat lge med hjlp av en svarsfil",
    "   (krver /s). Svarsfilen innehller svar p ngra eller alla de",
    "   frgor som anvndaren normalt svarar p under installationen.",
    "",
    "/udf:id[,UDF_fil]	",
    "   Anger en identifierare (id) som installationsprogrammet anvnder ",
    "   fr att ange hur en UDF (Uniqueness Database File) ndrar svarsfil ",
    "   (se /u). Parametern /udf sidostter vrden i svarsfilen, ",
    "   och identifieraren bestmmer vilka vrden i UDF-filen som ska",
    "   anvndas. Om ingen UDF_fil anges, uppmanas du att stta in ",
    "   en disk som innehller filen $Unique$.udb.",
    "",
    "/r[:mapp]",
    "   Anger en valfri mapp som ska installeras. Mappen ",
    "   finns kvar efter att installationsprogrammet slutfrts.",
    "",
    "/rx[:mapp]",
    "   Anger en valfri mapp som ska kopieras. Mappen tas ",
    "   bort efter att installationsprogrammet slutfrts.",
    "",
    "/e Anger ett kommando som ska kras i slutet av ",
    "   installationsprogrammets GUI-del.",
    "",
    "/a Aktiverar hjlpmedel.",
    NULL

};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installerar Windows XP.",
    "",
    "WINNT [/S[:]kllskvg] [/T[:]temp-enhet] [/I[:]INF-fil]",
    "      [/U[:skriptfil]]",
    "      [/R[X]:katalog] [/E:kommando] [/A]",
    "",
    "/D[:]winnt-rot",
    "       Detta alternativ stds inte lngre.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Slut p ledigt minne. Det gr inte att fortstta.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Vlj vilka hjlpmedel som ska anvndas:",
    DntEmptyString,
    "[ ] Tryck F1 fr Microsoft Skrmfrstoraren",
#ifdef NARRATOR
    "[ ] Tryck F2 fr Microsoft Skrmlsaren",
#endif
#if 0
    "[ ] Tryck F3 fr Microsoft Skrmtangentbordet",
 #endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Installationsprogrammet behver information om var filerna fr",
  "Windows XP finns. Ange skvgen till filerna.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Den angivna skvgen r felaktig. Antingen finns den inte, eller s",
                   "innehller den inte en giltig version av installationsprogrammet",
                   "fr Windows XP. Ange en ny skvg genom att frst radera tecken",
                   "med Backsteg.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Installationsprogrammet kunde inte lsa informationsfilen",
                "eller s r filen skadad. Kontakta systemadministratren.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Enheten som angivits fr lagring av temporra filer r antingen inte en",
  "giltig enhet eller s har den inte %u MB (%lu byte)",
  "ledigt utrymme.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP krver en hrddiskvolym med tminstone %u MB",
   "(%lu byte) ledigt utrymme. En del av utrymmet anvnds fr att",
   "lagra temporra filer under installationen. Enheten mste vara p",
   "en permanent ansluten lokal hrddisk som stds av Windows och",
   "enheten fr inte vara komprimerad.",
   DntEmptyString,
   "Installationsprogrammet hittar ingen sdan enhet med tillrckligt",
   "mycket ledigt utrymme.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Det finns inte tillrckligt med ledigt minne p startenheten",
  "(vanligtvis C) fr installation utan diskett. Installation utan diskett",
  "krver minst 3,5 MB (3,641,856 byte) av ledigt minne p enheten.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Avsnittet [%s] i informationsfilen fr installationsprogrammet",
                       "saknas eller r skadat. Kontakta systemadministratren.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Det gick inte att skapa fljande katalog i mlkatalogen:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Kontrollera att det inte finns ngra filer p mlenheten som har samma namn",
                       "som mlkatalogen. Kontrollera ven kablarna till enheten.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Det gr inte att kopiera fljande fil:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryck p Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck p Esc fr att ignorera felet och fortstta installationen.",
   "  Tryck p F3 fr att avsluta installationsprogrammet.",
   DntEmptyString,
   "Obs! Om du vljer att ignorera felet och fortstta kan det orsaka fel",
   "senare under installationen.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Kopian av filen nedan r inte identisk med originalet.",
   "Orsaken kan vara ett ntverksfel, fel p disketten eller ett maskinvaru-",
   "fel.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryck p Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck p Esc fr att ignorera felet och fortstta installationen.",
   "  Tryck p F3 fr att avsluta installationsprogrammet.",
   DntEmptyString,
   "Obs! Om du vljer att ignorera felet och fortstta kan det orsaka fel",
   "senare under installationen.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignoreras felet kommer filen inte att kopieras.",
   "Alternativet ska enbart utfras av erfarna anvndare som",
   "frstr konsekvenserna av att systemfiler saknas.",
   DntEmptyString,
   "  Tryck p Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck H fr att hoppa ver filen.",
   DntEmptyString,
   "Om du hoppar ver filen kan inte en korrekt installation",
   "eller uppdatering av Windows XP garanteras.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Vnta medan tidigare temporra filer tas bort.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Vnta medan filer kopieras till hrddisken.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Vnta medan filer kopieras till disketten.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Under installationen behvs 4 tomma och formaterade hgdensitetsdisketter.",
   "Disketterna kommer att benmnas enligt fljande:", 
   "Startdiskett fr Windows XP,",
   "Installationsdiskett 2 fr Windows XP", 
   "Installationsdiskett 3 fr Windows XP",
   "Installationsdiskett 4 fr Windows XP",
   DntEmptyString,
   "Stt in en av disketterna i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows XP.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 3 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 2 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Startdiskett fr Windows XP.",
  NULL
}
};


SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Under installationen behvs 4 tomma och formaterade hgdensitetsdisketter.",
   "Disketterna kommer att benmnas enligt fljande:",
   "Startdiskett fr Windows XP",
   "Installationsdiskett 2 fr Windows XP",
   "Installationsdiskett 3 fr Windows XP",
   "Installationsdiskett 4 fr Windows XP",
   DntEmptyString,
   "Stt in en av disketterna i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 3 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 2 fr Windows XP.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Startdiskett fr Windows XP.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Disketten r inte formaterad fr att anvndas med MS-DOS och",
  "kan drfr inte anvndas av installationsprogrammet.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Disketten r antingen inte en hgdensitetsdiskett, inte",
  "formaterad med MS-DOS standardformat eller s r den skadad.",
  "Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Det gr inte att avgra hur mycket ledigt utrymme det finns p",
  "disketten. Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Disketten r inte en hgdensitetsdiskett eller s r den inte tom.",
  "Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Det gr inte att skriva till systemsektorn p disketten.",
  "Disketten r troligen oanvndbar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Data som lstes frn diskettens systemsektor verensstmde inte med data",
  "som skrevs, eller s kunde inte installationsprogrammet lsa diskettens",
  "systemsektor fr verifiering.",
  DntEmptyString,
  "Det kan bero p ett eller flera av fljande fel:",
  DntEmptyString,
  "  Datorn r virusinfekterad.",
  "  Disketten r skadad.",
  "  Diskettstationen r felaktigt maskinvarukonfigururerad.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Det gr inte att skriva till disketten i enhet A:.",
  "Disketten kan vara skadad. Frsk med en annan diskett.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "ͻ",
                    "                                                     ",
                    "  Windows XP r inte fullstndigt installerat.       ",
                    "  Om installationsprogrammet avslutas, mste det     ",
                    "  kras om frn brjan fr att Windows XP            ",
                    "  ska kunna installeras.                             ",
                    "                                                     ",
                    "   Tryck p Retur fr att fortstta installationen. ",
                    "   Tryck p F3 fr att avsluta installationen.      ",
                    "ĺ",
                    "                                                     ",
                    "  F3=Avsluta  Retur=Fortstt                         ",
                    "                                                     ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows XP",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck p Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows XP finns",
  "i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck p Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Ta ut eventuell diskett i enhet A:.",
  DntEmptyString,
  "Tryck p Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows XP",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck p Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows XP",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck p Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows XP.",
  DntEmptyString,
  "Om det finns en diskett i enhet A:, mste du ta bort disketten.",
  DntEmptyString,
  "Tryck p Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               " Filer kopieras...                                              ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "MS-DOS version 5.0 eller senare behvs fr att kunna kra det hr programmet.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Diskettenhet A: saknas eller s r den en enhet fr lgdensitets-",
  "disketter. Fr att kunna kra installationsprogrammet krvs",
  "en diskettenhet med minst 1,2 MB kapacitet.",
#else
{ "Diskettenhet A: saknas eller s r den ingen 3,5-tums hgdensitensenhet.",
  "Det krvs en enhet A: med minst 1,44 MB kapacitet fr att gra en",
  "installation med disketter.",
  DntEmptyString,
  "Om du vill gra en installation utan disketter avslutar du programmet och",
  "startar om det med vxeln /b.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Den hr datorn har inte en 80486-processor eller hgre.",
  "Det gr inte att kra Windows XP p den hr datorn.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "WINNT.EXE kan inte kras p 32-bitarsversioner av Windows.",
  DntEmptyString,
  "Anvnd WINNT32.EXE fr att uppgradera eller installera Windows XP.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Det finns inte tillrckligt mycket minne installerat i datorn fr att",
  "kunna kra Windows XP.",
  DntEmptyString,
  "Minne som krvs:    %lu%s MB",
  "Tillgngligt minne: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Du har angett att du vill ta bort Windows XP-filer frn",
    " nedanstendekatalog. Windows-installationen i den hr katalogen",
    "kommer att frsvinna.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Tryck p F3 fr att avsluta installationen utan att ta bort filerna.",
    "  Tryck p T fr att ta bort filerna.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Det gr inte att ppna installationsloggfilen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Det gr inte att ta bort Windows-filer frn katalogen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Det gr inte att hitta avsnittet %s i installationsloggfilen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Det gr inte att ta bort Windows-filer frn katalogen.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vnta medan Windows-filer tas bort.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Det gick inte att installera startladdaren fr Windows.",
  DntEmptyString,
  "Kontrollera att enhet C r formaterad och inte r skadad.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Det gick inte att f tkomst till angivna skriptfilen med",
  "vxeln /u.",
  DntEmptyString,
  "Overvakad operation kan inte fortstta.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Skriptfilen som angetts med kommandovxeln /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "innehller ett syntaxfel p rad %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Ett fel internt installationsfel har uppsttt.",
  DntEmptyString,
  "De versatta startmeddelandena r fr lnga.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Ett internt fel uppstod i installationsprogrammet.",
  DntEmptyString,
  "Det gick inte att hitta ngon plats fr vxlingsfilen.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive hittades inte p datorn. SmartDrive kar prestandan",
  "radikalt fr den hr installationsfasen.",
  DntEmptyString,
  "Du br avsluta nu, starta SmartDrive, och sedan starta om installations-",
  "programmet. Mer information om SmartDrive finns i DOS-dokumentationen.",
  DntEmptyString,
    "  Tryck p F3 fr att avsluta installationsprogrammet.",
    "  Tryck p Retur fr att fortstta utan SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR saknas";
CHAR BootMsgDiskError[] = "Diskfel";
CHAR BootMsgPressKey[] = "Tryck p valfri tangent fr omstart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\ru\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows XP Installation/Upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n ⠭ Windows XP\n";
CHAR DntPersonalHeader[]      = "\n ⠭ Windows XP Personal\n";
CHAR DntWorkstationHeader[]   = "\n ⠭ Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n ⠭ Windows XP Server\n";
CHAR DntParsingArgs[]         = " 㬥⮢...";
CHAR DntEnterEqualsExit[]     = "=室";
CHAR DntEnterEqualsRetry[]    = "=";
CHAR DntEscEqualsSkipFile[]   = "ESC=ய 䠩";
CHAR DntEnterEqualsContinue[] = "=த";
CHAR DntPressEnterToExit[]    = " த ⠭.    室.";
CHAR DntF3EqualsExit[]        = "F3=室";
CHAR DntReadingInf[]          = "⥭ INF-䠩 %s...";
CHAR DntCopying[]             = " ஢: ";
CHAR DntVerifying[]           = "    ஢ઠ: ";
CHAR DntCheckingDiskSpace[]   = "஢ઠ   ᪥...";
CHAR DntConfiguringFloppy[]   = "ன  ᪠...";
CHAR DntWritingData[]         = " ࠬ஢ ⠭...";
CHAR DntPreparingData[]       = "롮 ࠬ஢ ⠭...";
CHAR DntFlushingData[]        = "   ...";
CHAR DntInspectingComputer[]  = "஢ઠ ...";
CHAR DntOpeningInfFile[]      = "⨥ INF-䠩...";
CHAR DntRemovingFile[]        = " 䠩 %s";
CHAR DntXEqualsRemoveFiles[]  = "X= 䠩";
CHAR DntXEqualsSkipFile[]     = "X=ய 䠩";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Keep in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "⠭ Windows 2002 Server  Windows XP Professional",
    "",
    "WINNT [/s[:室_]] [/t[:ࠡ稩_]]",
    "      [/u[:䠩_⢥⮢]] [udf:id[,UDF_䠩]]",
    "      [/r:] [/rx:] [/e:] [/a]",
    "",
    "/s[:]室_",
    "    室 ᯮ 䠩 Windows.",
    "     㪠     x:[] ",
    "   \\\\ࢥ\\[].",
    "",
    "/t[:ࠡ稩_]",
    "      ࠧ饭 ६ 䠩 ⠭ ",
    "     ࠧ饭 ⠭ ⥬ Windows XP.",
    "   ᫨   㪠, ணࠬ ⠭ ⠥ ",
    "   ᠬ⥫쭮  ࠡ稩 .",
    "",
    "/u[:䠩_⢥⮢]",
    "    ⬠ ⠭  ᯮ짮 䠩 ⢥⮢",
    "   (ॡ 㪠 ࠬ /s).  ⢥⮢ ᮤন ⢥",
    "        ணࠬ ⠭, 筮 ",
    "   ⢥   짮⥫.",
    "udf:id[,UDF_䠩]",
    "   뢠 䨪 (ID), ᯮ㥬 ணࠬ ⠭",
    "    ⮣, ⮡ ।,  UDF-䠩 㤥  ࠬ",
    "   䠩 ⢥⮢ (. ࠬ /u). ࠬ /udf ४뢠 祭",
    "   䠩 ⢥⮢,  䨪 㪠뢠,  祭 UDF-䠩",
    "    ᯮ짮. ᫨ UDF-䠩  㪠, ணࠬ ⠭",
    "    ᪥  䠩 $Unique$.udb",
    "",
    "/r[:]",
    "    易⥫   ⠭.   ࠭",
    "   ᫥ 襭 ⠭.",
    "",
    "/rx[:]",
    "    易⥫   ஢.   㤠",
    "   ᫥ 襭 ⠭.",
    "",
    "/e:",
    "    믮 㪠   砭 ᪮  ",
    "   ⠭.",
    "",
    "/a 砥 ᯥ樠     娬 ७",
    "    ࠭祭 .",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "믮 ⠭ Windows XP.",
    "",
    "WINNT [/S[:]室_] [/T[:]ࠡ稩_] [/I[:]inf_䠩]",
    "      [/U[:䠩_業]]",
    "      [/R[x]:] [/E:] [/A]",
    "",
    "/D[:]winntroot",
    "        ࠬ   ন.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "ணࠬ ⠭  墠⠥  -  த ࠡ.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   ",  ᯥ樠  ᫥ ⠭:",
    DntEmptyString,
    "[ ]   F1  ⠭ ࠭ ",
#ifdef NARRATOR
    "[ ]   F2  ⠭ ࠭ ",
#endif
#if 0
    "[ ]   F3  ⠭ ࠭ ",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "ணࠬ ⠭ 室 ,  室 䠩 Windows XP.",
  " ,    䠩 Windows XP.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { " 室   ७,  㯥   ᮤন ࠢ쭮",
                   " ⠭ 䠩 Windows XP.   , ",
                   "  䠩 Windows XP. ᯮ  BACKSPACE ",
                   "㤠  ᨬ,  ⥬ 㪠 ࠢ .",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "ணࠬ ⠭    ᢮ inf-䠩   䠩 ᯮ祭.",
                "  ⥬ .",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ ",   ࠭  ࠧ饭 ६ 䠩 ⠭, ",
  " ࠢ ᪮   ᮤন  ࠩ  %u ",
  "( %lu ) ᢮ ᪮ ࠭⢠.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows XP 室 ⮬  ⪮ ᪥,  ஬ ᢮",
   "  %u  (%lu ). ணࠬ ⠭ ᯮ",
   " ⮣ ࠭⢠  ࠭ ६ 䠩, 室 ",
   "६ ⠭.  ⮬  室  ﭭ 祭",
   "쭮 ⪮ ᪥, ন Windows XP,   ",
   " ᦠ ᪮.",
   DntEmptyString,
   "ணࠬ ⠭  ᬮ 㦨 ⠪    ꥬ",
   "᢮ ᪮ ࠭⢠.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "筮 ᢮   ⮢ ᪥ (筮 C:)",
  " 믮 ⠭  ᯮ짮 ᪥. ⠭ ",
  "ᯮ짮 ᪥ ॡ  ⥫ 3.5 ",
  "(3,641,856 ) ᢮ ࠭⢠  ⮬ ᪥.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { " [%s] ଠ樮 䠩 ணࠬ ⠭",
                       "  ०.    ⥬ .",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "ணࠬ ⠭  㤠 ᮧ 㪠   筮 ",
                       "⪮ ᪥:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "஢    㡥  ⮬,     䠩",
                       " , ᮢ騬  ᮧ . ஢ ⠪",
                       " ᮥ  ⮣ ᪠.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "ணࠬ ⠭  㤠 ᪮஢ ᫥騩 䠩:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "     ७ 樨 ஢.",
   "   ESC  ஢ 訡  த ⠭.",
   "   F3  ४饭 ⠭.",
   DntEmptyString,
   ": ஢ ⮩ 訡  த ⠭ ",
   "ਢ  쭥襬  㣨 訡 ⠭.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  " ணࠬ ⠭  㪠  䠩  ᮢ",
   " ਣ.    १⮬ ⥢ 訡, ᡮ ᪮,",
   "㣨  㤮.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "     ७ 樨 ஢.",
   "   ESC  ஢ 訡  த ⠭.",
   "   F3  ४饭 ⠭.",
   DntEmptyString,
   ": ஢ ⮩ 訡  த ⠭ ",
   "ਢ  쭥襬  㣨 訡 ⠭.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "஢ ⮩ 訡 砥,   䠩  㤥 ᪮஢.",
   " ࠬ ।祭   짮⥫,  ",
   ",   ᫮   ⢨ ⥬ 䠩.",
   DntEmptyString,
   "     ७ 樨 ஢.",
   "   X  ⮣, ⮡ ய  䠩.",
   DntEmptyString,
   ": ᫨  䠩 㤥 ய饭, ணࠬ ⠭  ",
   "࠭஢ ᯥ譮 ⠭   Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 4,6,
        { ",  ணࠬ ⠭ 㤠 騥 ६ 䠩.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 4,6,
                   { ",  ணࠬ ⠭ ᪮ 䠩  ⪨ .",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 4,6,
                   { ",  ணࠬ ⠭ ᪮ 䠩  ᪥.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "ணࠬ ⠭ ॡ  ଠ஢,  ᪥",
   "᮪ ⭮.  쭥襬 ணࠬ ⠭ 㤥 ",
   " ᪥ \"⠭  1 Windows XP\", ",
   "\"⠭  2 Windows XP\", ",
   "\"⠭  3 Windows XP\"  ",
   "\"⠭  4 Windows XP\".",
   DntEmptyString,
   "⠢     ᪥  ᪮ A:.",
   "㤥 ᮧ \"⠭  4 Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  4 Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  3 Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  2 Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  1 Windows XP\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "ணࠬ ⠭ ॡ  ଠ஢,  ᪥",
   "᮪ ⭮.  쭥襬 ணࠬ ⠭ 㤥 ",
   " ᪥ \"⠭  1 Windows 2002\", ",
   "\"⠭  2 Windows 2002\", ",
   "\"⠭  3 Windows 2002\"  ",
   "\"⠭  4 Windows 2002\".",
   DntEmptyString,
   "⠢     ᪥  ᪮ A:.",
   "㤥 ᮧ \"⠭  4 Windows 2002\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  4 Windows 2002\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  3 Windows 2002\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  2 Windows 2002\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "⠢ ଠ஢,  ᪥ ᮪ ⭮",
   " ᪮ A:.",
   "㤥 ᮧ \"⠭  1 Windows 2002\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "।⠢ ᪥  ଠ஢  ᯮ짮  MS-DOS.",
  "ணࠬ ⠭   ᯮ짮  ᪥.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ " ᪥    ଠ஢ ᪥⮩ ᮪ ⭮,",
  " ଠ஢  ⠭  MS-DOS ᯮᮡ,  ०.",
  "ணࠬ ⠭   ᯮ짮  ᪥.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "ணࠬ ⠭  㤠 । ꥬ ᢮   ⮩",
  "᪥. ணࠬ ⠭   ᯮ짮  ᪥.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ " ᪥    ᪥⮩ ᮪ ⭮,  㦥 ᮤন",
  " 䠩. ணࠬ ⠭   ᯮ짮  ᪥.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "ணࠬ ⠭  㤠 믮   ⥬  ",
  "⮩ ᪥. ⭮,  ᪥  ਣ  ᯮ짮.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ ", ⠭ ணࠬ ⠭  ⥬  ⮩ ᪥",
  "  ᮢ  ᠭ묨,  ணࠬ ⠭  㤠",
  " ⥬  ᪥  ஢ન.",
  DntEmptyString,
  "   맢 ᫥騬 稭:",
  DntEmptyString,
  "    ࠦ ᮬ.",
  "  ।⠢ ᪥ ०.",
  "  㤮 ᪮ ࠢ  ୮ ஥.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "ணࠬ ⠭  㤠    ᪥, ⠭",
  " ᪮ A:. ,  ᪥ ०. ஡ ᯮ짮",
  " ᪥.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 10,6,
                  { "ͻ",
                    "  Windows XP  뫠  ⠭  ⮬         ",
                    "  . ᫨  ⠭ ᥩ,           ",
                    "    믮 ⠭ Windows XP.       ",
                    "                                                           ",
                    "       <>  த ⠭.           ",
                    "       <F3>  ४饭 ⠭              ",
                    "Ķ",
                    "  F3=室  =த                                ",
                    "ͼ",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  " ணࠬ ⠭ ந १㧪 .",
  "᫥ १㧪 ⠭ Windows XP 㤥 த.",
  DntEmptyString,
  "। ⥬,  த ࠡ, 㡥  ⮬,  ⮢",
  "࠭ ᪥ \"⠭  1 Windows XP\"",
  "⠢  ᪮ A:.",
  DntEmptyString,
  "   १㧪   த ⠭",
  "Windows XP.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  " ணࠬ ⠭ ந १㧪 .",
  "᫥ १㧪 ⠭ Windows 2002 㤥 த.",
  DntEmptyString,
  "। ⥬,  த ࠡ, 㡥  ⮬,  ⮢",
  "࠭ ᪥ \"⠭  1 Windows 2002\"",
  "⠢  ᪮ A:.",
  DntEmptyString,
  "   १㧪   த ⠭",
  "Windows 2002.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  " ணࠬ ⠭ ந १㧪 .",
  "᫥ १㧪 ⠭ Windows XP 㤥 த.",
  DntEmptyString,
  "᫨  ᪮ A: ⠢ ᪥,  .",
  DntEmptyString,
  "   १㧪   த ⠭",
  "Windows XP.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  "  室 १㧨 .",
  "᫥ १㧪 ⠭ Windows XP 㤥 த.",
  DntEmptyString,
  "। ⥬,  த ࠡ, 㡥  ⮬,  ⮢",
  "࠭ ᪥ \"⠭  1 Windows XP\" ",
  "⠢  ᪮ A:.",
  DntEmptyString,
  "   室  MS-DOS,  ⥬ १㧨 ",
  " த ⠭ Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  "  室 १㧨 .",
  "᫥ १㧪 ⠭ Windows 2002 㤥 த.",
  DntEmptyString,
  "। ⥬,  த ࠡ, 㡥  ⮬,  ⮢",
  "࠭ ᪥ \"⠭  1 Windows 2002\" ",
  "⠢  ᪮ A:.",
  DntEmptyString,
  "   室  MS-DOS,  ⥬ १㧨 ",
  " த ⠭ Windows 2002.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ " ⠯ ⠭  ࠢ MS-DOS 襭.",
  "  室 १㧨 .",
  "᫥ १㧪 ⠭ Windows XP 㤥 த.",
  DntEmptyString,
  "᫨  ᪮ A: ⠢ ᪥,  .",
  DntEmptyString,
  "   室  MS-DOS,  ⥬ १㧨 ",
  " த ⠭ Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "ͻ",
               "      ணࠬ ⠭ 믮 ஢ 䠩...       ",
               "                                                                ",
               "      Ŀ      ",
               "                                                              ",
               "            ",
               "ͼ",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ " 믮 ⮩ ணࠬ 室 MS-DOS ᨨ 5.0  .",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "ணࠬ ⠭ ।,  ᪮ A:   ",
  " ⭮.  믮 ⠭ 室 ᪮, ᯮᮡ",
  "ࠡ  ᪥⠬ ꥬ 1,2   .",
#else
{ "ணࠬ ⠭ ।,  ᪮ A:  ",
  "  3,5\" ᪮ ᮪ ⭮. 室 ᪮,",
  "ᯮᮡ ࠡ  ᪥⠬ ꥬ 1,44    ",
  "⠭  ᯮ짮 ᪥",
  DntEmptyString,
  "⮡ 믮 ⠭ Windows XP  ᯮ짮 ᪥,",
  "१  ணࠬ  ᯮ ࠬ  /b   ",
  "ப.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "ணࠬ ⠭ ।,   ⮬   80486",
  "   . Windows XP   ࠡ",
  " ⮬ .",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ " ணࠬ   ࠡ  ࠢ 32-⭮ ᨨ Windows.",
  DntEmptyString,
  "  ᫥ ᯮ짮 ணࠬ WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "ணࠬ ⠭ ।,   ⮬   ⠭",
  "筮 ⢠ ⨢   ࠡ Windows XP.",
  DntEmptyString,
  "ॡ㥬 ꥬ : %lu%s ",
  "騩 ꥬ : %lu%s ",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 3,5,
{   " ᨫ ணࠬ ⠭ 㤠 䠩 Windows XP ",
    "㪠  . ⠭  ⮩  ",
    "Windows 㤥 㭨⮦.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "   F3  室  ⠭  㤠 - 䠩.",
    "   X  㤠 䠩 Windows  㪠  .",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "ணࠬ ⠭  㤠  㪠  LOG-䠩 ⠭.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "ணࠬ ⠭   㤠 䠩 Windows  㪠",
  ".",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "ணࠬ ⠭  㤠 㦨 ࠧ %s",
  " 㪠  LOG-䠩 ⠭.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "ணࠬ ⠭   㤠 䠩 Windows  㪠",
  ".",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "        ,  ணࠬ ⠭ 㤠 䠩 Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "ணࠬ ⠭  㤠 ⠭ Windows Boot Loader.",
  DntEmptyString,
  ",   C: ଠ஢  ன⢮ ࠢ.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ " 㯠  䠩 業, 㪠   ࠬ",
  " ப /u.",
  DntEmptyString,
  " த 믮 ⮬᪮ ⠭",
  " ⥫⢠ .",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ " 業, 㪠   ࠬ  ப /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "ᮤন ᨭ⠪ 訡  ப %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "ந諠 ७ 訡 ணࠬ ⠭.",
  DntEmptyString,
  "ॢ ᮮ饭 㧪 ᫨誮 .",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "ந諠 ७ 訡 ணࠬ ⠭.",
  DntEmptyString,
  " 㤠    䠩 窨.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ " 㤠  SmartDrive  ⮬ . SmartDrive ⢥",
  "蠥 ᪮ 믮 ⮩ 䠧 ⠭ Windows.",
  DntEmptyString,
  "멤  ணࠬ ⠭,  SmartDrive,  ⥬",
  "᭮  ணࠬ ⠭. ⥫ ᢥ ",
  "ணࠬ SmartDrive    㬥樨  DOS.",
  DntEmptyString,
    "   F3  室  ணࠬ ⠭.",
    "     த ⠭  SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

CFOPT=$(CFOPT) -DNARRATOR=1

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\htmlctrl.cpp ===
////////////////////////////////////////////////////////////////
// Microsoft Systems Journal -- December 1999
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#include "StdAfx.h"
#include "HtmlCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CHtmlCtrl, CHtmlView)
BEGIN_MESSAGE_MAP(CHtmlCtrl, CHtmlView)
	ON_WM_DESTROY()
	ON_WM_MOUSEACTIVATE()
END_MESSAGE_MAP()

//////////////////
// Create control in same position as an existing static control with
// the same ID (could be any kind of control, really)
//
BOOL CHtmlCtrl::CreateFromStatic(UINT nID, CWnd* pParent)
{
	CStatic wndStatic;
	if (!wndStatic.SubclassDlgItem(nID, pParent))
		return FALSE;

	// Get static control rect, convert to parent's client coords.
	CRect rc;
	wndStatic.GetWindowRect(&rc);
	pParent->ScreenToClient(&rc);
	wndStatic.DestroyWindow();

	// create HTML control (CHtmlView)
	return Create(NULL,						 // class name
		NULL,										 // title
		(WS_CHILD | WS_VISIBLE ),			 // style
		rc,										 // rectangle
		pParent,									 // parent
		nID,										 // control ID
		NULL);									 // frame/doc context not used
}

////////////////
// Override to avoid CView stuff that assumes a frame.
//
void CHtmlCtrl::OnDestroy()
{
	// This is probably unecessary since ~CHtmlView does it, but
	// safer to mimic CHtmlView::OnDestroy.
	if (m_pBrowserApp) {
		m_pBrowserApp->Release();
		m_pBrowserApp = NULL;
	}
	CWnd::OnDestroy(); // bypass CView doc/frame stuff
}

////////////////
// Override to avoid CView stuff that assumes a frame.
//
int CHtmlCtrl::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT msg)
{
	// bypass CView doc/frame stuff
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, msg);
}

//////////////////
// Override navigation handler to pass to "app:" links to virtual handler.
// Cancels the navigation in the browser, since app: is a pseudo-protocol.
//
void CHtmlCtrl::OnBeforeNavigate2( LPCTSTR lpszURL,
	DWORD nFlags,
	LPCTSTR lpszTargetFrameName,
	CByteArray& baPostedData,
	LPCTSTR lpszHeaders,
	BOOL* pbCancel )
{
	const char APP_PROTOCOL[] = "app:";
	int len = _tcslen(APP_PROTOCOL);
	if (_tcsnicmp(lpszURL, APP_PROTOCOL, len)==0) {
		OnAppCmd(lpszURL + len);
		*pbCancel = TRUE;
	}
}

//////////////////
// Called when the browser attempts to navigate to "app:foo"
// with "foo" as lpszWhere. Override to handle app commands.
//
void CHtmlCtrl::OnAppCmd(LPCTSTR lpszWhere)
{
	// default: do nothing
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\dt\dt.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dt.cpp

Abstract:

    Utility to do some disk related operations

Author:

    Vijay Jayaseelan (vijayj)  26 April 2001

Revision History:

    None

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <bootmbr.h>
#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <tchar.h>
#include <locale>
#include <winioctl.h>

//
// Usage format
//
PCWSTR  Usage = L"Usage: dt.exe /?\r\n"
                 L"dt.exe /dump {[drive-letter] | [disk-number]} start-sector sector-count\r\n"
				 L"dt.exe /diskinfo disk-number\r\n";
                     
//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, (PWSTR)str.c_str());
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}


//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        os << PrgUsage << std::endl;
    }
};

//
// Program Arguments abstraction
//
struct ProgramArguments {
    bool            DumpSectors;
    ULONG           DiskIndex;
    std::wstring    DriveLetter;
    LONGLONG        StartingSector;
    ULONG           NumSectors;
    std::wstring    DeviceName;    
    bool            DumpDiskInfo;
    
    
    ProgramArguments(INT Argc, WCHAR *Argv[]) {
        bool ShowUsage = false;

        DumpSectors = false;
        DumpDiskInfo = false;
        DiskIndex = -1;
        StartingSector = -1;
        NumSectors = -1;

        for (ULONG Index=1; !ShowUsage && (Index < Argc); Index++) {
            if (!_wcsicmp(Argv[Index], TEXT("/dump"))) {                
            	ShowUsage = TRUE;
            	
                if (((Index + 4) == Argc)) {
                    Index++;
                    DriveLetter = Argv[Index++];

                    if ((DriveLetter.length() == 1)) {
                        if (iswdigit(DriveLetter[0])) {
                            WCHAR   StrBuffer[64];
                            
                            DiskIndex = _wtol(DriveLetter.c_str());
                            DriveLetter[0] = UNICODE_NULL;

                            swprintf(StrBuffer, 
                                TEXT("\\\\.\\PHYSICALDRIVE%d"),
                                DiskIndex);

                            DeviceName = StrBuffer;
                        } else {
                            DeviceName = TEXT("\\\\.\\") + DriveLetter + TEXT(":");
                        }

                        StartingSector = (LONGLONG)(_wtoi64(Argv[Index++]));;
                        NumSectors = (ULONG)_wtol(Argv[Index++]);

                        ShowUsage = !(((DiskIndex != -1) || (DriveLetter[0])) &&
                                      (NumSectors != 0));
                        DumpSectors = !ShowUsage;                        
                    }                        
                }                    
            } else if (!_wcsicmp(Argv[Index], TEXT("/diskinfo"))) {                

                DumpDiskInfo = TRUE;
                ShowUsage = TRUE;
                DriveLetter = Argv[++Index];			                     

                if ((DriveLetter.length() == 1)) {
                    if (iswdigit(DriveLetter[0])) {
                        WCHAR   StrBuffer[64];
                        
                        DiskIndex = _wtol(DriveLetter.c_str());
                        DriveLetter[0] = UNICODE_NULL;

                        swprintf(StrBuffer, 
                            TEXT("\\\\.\\PHYSICALDRIVE%d"),
                            DiskIndex);

                        DeviceName = StrBuffer;
                        ShowUsage = FALSE;
                    }
                }                           
            } else {
            	ShowUsage = TRUE;
            }            	
        }            

        if (ShowUsage) {
            throw new ProgramUsage(Usage);
        }                        
    }

};

//
// Dumps the given binary data of the specified size
// into the output stream with required indent size
//
void
DumpBinary(unsigned char *Data, int Size,
           std::ostream& os, int Indent = 16)
{
    if (Data && Size) {
        int  Index = 0;
        int  foo;
        char szBuff[128] = {'.'};
        int  Ruler = 0;

        while (Index < Size) {
            if (!(Index % Indent)) {
                if (Index) {
                    szBuff[Indent] = 0;
                    os << szBuff;
                }

                os << std::endl;
                os.width(8);
                os.fill('0');
                os << Ruler << "  ";
                Ruler += Indent;
            }

            foo = *(Data + Index);
            szBuff[Index % Indent] = ::isalnum(foo) ? (char)foo : (char)'.';
            os.width(2);
            os.fill('0');
            os.flags(std::ios::uppercase | std::ios::hex);
            os << foo << ' ';
            Index++;
        }

        while (Index % Indent) {
            os << '   ';
            Index++;
            szBuff[Index % Indent] = ' ';
        }

        szBuff[Indent] = 0;
        os << szBuff;
    } else {
      os << std::endl << "no data" << std::endl;
    }
}

//
// Abstracts block device (interface)
//
class W32BlockDevice {
public:
    W32BlockDevice(const std::wstring &name, ULONG SecSize) : 
        SectorSize(SecSize), DeviceHandle(INVALID_HANDLE_VALUE), Name(name){
            
        //
        // Open the device
        //
        DeviceHandle = CreateFile(Name.c_str(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);


        DWORD LastError = GetLastError();

        if (LastError) {
            throw new W32Error(LastError);
        }                    
    }
    
    virtual ~W32BlockDevice() {
        if (DeviceHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(DeviceHandle);                
        }
    };        

    ULONG GetSectorSize() const { return SectorSize; }
    
    //
    // Reads the requested size of data from the given sector
    //
    virtual DWORD ReadSectors(LONGLONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {        
        LARGE_INTEGER MoveLength;

        MoveLength.QuadPart = Index * SectorSize;
        
        SetFilePointerEx(DeviceHandle,
                    MoveLength,
                    NULL,
                    FILE_BEGIN);

        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesRead = 0;
            
            if (!ReadFile(DeviceHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesRead,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }

    //
    // Writes the requested size of data to the specified sector
    //
    virtual DWORD WriteSectors(ULONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {
        LARGE_INTEGER MoveLength;

        MoveLength.QuadPart = Index * SectorSize;
        
        SetFilePointerEx(DeviceHandle,
                    MoveLength,
                    NULL,
                    FILE_BEGIN);
        
        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesWritten = 0;
            
            if (!WriteFile(DeviceHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesWritten,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }    

    virtual std::ostream& Dump(std::ostream &os) {
        os << TEXT("Device Name = ") << TEXT("(") << Name << TEXT(")") << std::endl;

        return os;
    }

    const HANDLE GetHandle() const { return DeviceHandle; }
    
protected:    

    //
    // Data members
    //
    HANDLE  DeviceHandle;
    ULONG   SectorSize;
    std::wstring    Name;
};    


VOID
DumpSectors(
    IN ProgramArguments &Args
    )
{
    
    if (Args.DumpSectors) {                
        W32BlockDevice  Device(Args.DeviceName, 512);        
        WCHAR   LongString[64];
        BYTE    Sector[4096];
        ULONG   SectorCount = Args.NumSectors;
        LONGLONG StartingSector = Args.StartingSector;

        Device.Dump(std::cout);
        
        while (SectorCount && (Device.ReadSectors(StartingSector, Sector) == NO_ERROR)) {
            std::cout << std::endl << "Sector : " << std::dec;
            LongString[0] = 0;
            std::cout << _i64tow(StartingSector, LongString, 10);
            DumpBinary(Sector, Device.GetSectorSize(), std::cout);
            std::cout << std::endl;

            SectorCount--;
            StartingSector++;
        }                
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    DWORD LastError = GetLastError();
    
    if (LastError != NO_ERROR) {
        throw new W32Error(LastError);
    }
}

#ifndef _WIN64 

std::ostream&
operator<<(std::ostream &os, const ULONGLONG &LargeInteger) {
    WCHAR	Buffer[64];

    swprintf(Buffer, L"%I64u", LargeInteger);
    os << Buffer;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const LONGLONG &LargeInteger) {
    WCHAR	Buffer[64];

    swprintf(Buffer, L"%I64d", LargeInteger);
    os << Buffer;

    return os;
}

#endif // ! _WIN64

inline
std::ostream&
operator<<(std::ostream &os, const LARGE_INTEGER &LargeInteger) {
    return (os << LargeInteger.QuadPart);
}


inline
std::ostream&
operator<<(std::ostream &os, const GUID &Guid) {
    WCHAR   Buffer[MAX_PATH];

    swprintf(Buffer, 
        TEXT("{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]);

    os << Buffer;    
        
    return os;
}

inline
std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_MBR &MbrPartInfo) {    
    WCHAR Buffer[MAX_PATH];

    swprintf(Buffer, 
        TEXT("Type : 0x%02lX, Active : %ws, Recognized : %ws, Hidden Sectors : %d"),
        MbrPartInfo.PartitionType,
        (MbrPartInfo.BootIndicator ? TEXT("TRUE") : TEXT("FALSE")),
        (MbrPartInfo.HiddenSectors ? TEXT("TRUE") : TEXT("FALSE")),
        MbrPartInfo.HiddenSectors);
    
    os << Buffer << std::endl;
    
    return os;
}

inline
std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_GPT &GptPartInfo) {
    os << "Type : " << GptPartInfo.PartitionType << ", ";
    os << "Id : " << GptPartInfo.PartitionId << ", ";
    os << "Attrs : " << GptPartInfo.Attributes << ", ";
    os << "Name : " << std::wstring(GptPartInfo.Name);
    
    return os;
}

std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_EX &PartInfo) {
    os << "Partition# : " << std::dec << PartInfo.PartitionNumber;
    os << ", Start : " << PartInfo.StartingOffset.QuadPart;
    os << ", Length : " << PartInfo.PartitionLength.QuadPart << std::endl;

    switch(PartInfo.PartitionStyle) {
        case PARTITION_STYLE_MBR:
            os << PartInfo.Mbr;
            break;

        case PARTITION_STYLE_GPT:
            os << PartInfo.Gpt;
            break;

        default:
            break;                
    }

    os << std::endl;
   
    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_MBR &MbrInfo) {
    os << "Signature : " << std::hex << MbrInfo.Signature;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_GPT &GptInfo) {
    os << "Disk ID : " << GptInfo.DiskId << ", ";
    os << "Starting Offset : " << std::dec << GptInfo.StartingUsableOffset << ", ";
    os << "Usable Length : " << std::dec << GptInfo.UsableLength << ", ";
    os << "Max Partition Count : " << std::dec << GptInfo.MaxPartitionCount;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_EX &DriveInfo) {
    os << "Disk Type : ";

    switch (DriveInfo.PartitionStyle) {
    	case PARTITION_STYLE_MBR:
    		os << "MBR";
    		break;

    	case PARTITION_STYLE_GPT:
    		os << "GPT";
    		break;

    	default:
    		os << "Unknown";
    		break;
    }					

    os << ", Partition Count : " << std::dec << DriveInfo.PartitionCount << " ";

    switch(DriveInfo.PartitionStyle) {
    	case PARTITION_STYLE_MBR:
    		os << DriveInfo.Mbr;
    		break;

    	case PARTITION_STYLE_GPT:
    		os << DriveInfo.Gpt;
    		break;

    	default:
    		break;
    }

    os << std::endl << std::endl;

    for (ULONG Index = 0; Index < DriveInfo.PartitionCount; Index++) {
    	if (DriveInfo.PartitionEntry[Index].PartitionNumber) {
    		os << DriveInfo.PartitionEntry[Index];
            os << std::endl;
    	}			
    }

    os << std::endl;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DISK_GEOMETRY &DiskInfo) {
    os << "Heads : " << std::dec << DiskInfo.TracksPerCylinder;
    os << ", Cylinders : " << DiskInfo.Cylinders;
    os << ", Sectors/Track : " << std::dec << DiskInfo.SectorsPerTrack;
    os << ", Bytes/Sector : " << std::dec << DiskInfo.BytesPerSector;

    return os;
}


void
DumpDiskCharacteristics(
	IN ProgramArguments &Args
	)
{
    DWORD LastError = NO_ERROR;

    if (Args.DumpDiskInfo){
        W32BlockDevice	Device(Args.DeviceName, 512);
        HANDLE DeviceHandle = (HANDLE)Device.GetHandle();
        ULONG BufferLength = 16 * 1024;
        PBYTE Buffer = new BYTE[BufferLength];

        if (Buffer) {
            DWORD BytesReturned = 0;
            PDISK_GEOMETRY	DiskInfo = (PDISK_GEOMETRY)Buffer;

            Device.Dump(std::cout);

            if (DeviceIoControl(DeviceHandle,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,						
                    Buffer,
                    BufferLength,
                    &BytesReturned,
                    NULL)) {
                std::cout << (*DiskInfo) << std::endl;

                PDRIVE_LAYOUT_INFORMATION_EX DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)Buffer;

                if (DeviceIoControl(DeviceHandle,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,						
                        Buffer,
                        BufferLength,
                        &BytesReturned,
                        NULL)) {

                    //
                    // dump the disk information
                    //
                	std::cout << (*DriveLayout);
                }
            }	

            LastError = GetLastError();
            			
            delete []Buffer;
        } 
    } else {
    	SetLastError(ERROR_INVALID_PARAMETER);
    }				

    if (LastError == NO_ERROR) {
        LastError = GetLastError();
    }			    

    if (LastError != NO_ERROR) {
        throw new W32Error(LastError);
    }
}

//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    
    try {    
        ProgramArguments    Args(Argc, Argv);

        if (Args.DumpSectors) {
            DumpSectors(Args);          
        } else if (Args.DumpDiskInfo) {
            DumpDiskCharacteristics(Args);
        } else {
            throw new ProgramUsage(Usage);
        }            
    }
    catch(W32Error  *W32Err) {
        Result = 1;                
        
        if (W32Err) {
            W32Err->Dump(std::cout);
            delete W32Err;
        }   
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        
        if (PrgExp) {
            PrgExp->Dump(std::cout);
            delete PrgExp;
        }            
    } catch (exception *Exp) {
        Result = 1;

        if (Exp) {
            std::cout << Exp->what() << std::endl;
        }            
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\filedialogex.h ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#pragma once

// Windows 2000 version of OPENFILENAME.
// The new version has three extra members.
// This is copied from commdlg.h
//
struct OPENFILENAMEEX : public OPENFILENAME { 
  void *        pvReserved;
  DWORD         dwReserved;
  DWORD         FlagsEx;
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialogEx: Encapsulate Windows-2000 style open dialog.
//
class CFileDialogEx : public CFileDialog {
	DECLARE_DYNAMIC(CFileDialogEx)
public:
	CFileDialogEx(BOOL bOpenFileDialog, // TRUE for open, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

	// override
	virtual INT_PTR DoModal();

protected:
	OPENFILENAMEEX m_ofnEx;	// new Windows 2000 version of OPENFILENAME

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	// virtual fns that handle various notifications
	virtual BOOL OnFileNameOK();
	virtual void OnInitDone();
	virtual void OnFileNameChange();
	virtual void OnFolderChange();
	virtual void OnTypeChange();

	DECLARE_MESSAGE_MAP()
	//{{AFX_MSG(CFileDialogEx)
	//}}AFX_MSG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\dbcsfchk\dbcsfchk.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbcsfchk.cpp

Abstract:

    Does some simple checking to see if the 
    file is a valid DBCS file and counts
    the number of DBCS characters

Author:

    Vijay Jayaseelan (vijayj) Oct-18-2000

Revision History:

    None

--*/

#include <iostream>
#include <string>
#include <windows.h>
#include <tchar.h>
#include <mbctype.h>

//
// Usage format
//
std::wstring Usage(L"Usage: dbcsfchk.exe filename codepage");

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, str.c_str());
    return os;
}

//
// Abstracts a Win32 error
//
struct W32Error{
    DWORD   ErrorCode;

    W32Error(DWORD ErrCode) : ErrorCode(ErrCode){}

    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Parses the arguments
//
BOOL
ParseArguments(
    IN  INT Argc,
    IN  TCHAR *Argv[],
    OUT TCHAR *FileName,
    OUT ULONG &CodePage
    )
{
    BOOL    Result = FALSE;

    if (FileName && (Argc > 2)) {        
        _tcscpy(FileName, Argv[1]);

        CodePage = atol(Argv[2]);
        Result  = TRUE;
    }

    return Result;
}

BOOL
ValidateDbcsData(
    IN const TCHAR *Data,
    IN ULONG Length,
    OUT ULONG &LineNumber,
    OUT ULONG &Offset,
    OUT ULONG &ValidDbcsChars
    )
{
    BOOL    Result = FALSE;
    const   TCHAR *CurrPtr = Data;

    Offset = 0;
    ValidDbcsChars = 0;
    
    while (Offset < Length) {
        if (_ismbblead(*(UCHAR*)CurrPtr)) {
            Offset++;
            
            if (_ismbbtrail(*(UCHAR *)(CurrPtr + 1))) {
                Offset++;
                CurrPtr += 2;
                ValidDbcsChars++;
                continue;
            } else {
                break;
            }                
        } 

        if (*CurrPtr == '\n') {
            LineNumber++;
        } else if ((*CurrPtr == '\r') && (*(CurrPtr+1) == '\n')) {
            LineNumber++;
            Offset++;
            CurrPtr++;
        }      

        Offset++;
        CurrPtr++;        
    }

    Result = (Offset == Length);        

    if (Result) {
        LineNumber = 0;
    }                        
     
    return Result;
}
    

//
// Main entry point
//
INT
__cdecl
_tmain(
    IN  INT Argc,
    IN  TCHAR *Argv[]
    )
{
    INT     Result = 1;

    try {
        TCHAR   FileName[MAX_PATH] = {0};
        ULONG   CodePage = 0;
        
        //
        // Parse the arguments
        //
        if (ParseArguments(Argc, Argv, FileName, CodePage)) {
            //
            // Set the code page
            //
            if (!_setmbcp(CodePage)) {
                std::cout << "Using Code Page : " << _getmbcp() << std::endl;

                //
                // Open the file
                //
                HANDLE  FileHandle = CreateFile(FileName,
                                        GENERIC_READ,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);


                if (FileHandle == INVALID_HANDLE_VALUE) {
                    throw new W32Error(GetLastError());
                }

                //
                // Map the file in memory (as readonly)
                //
                HANDLE  FileMapHandle = CreateFileMapping(FileHandle,
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            0,
                                            NULL);


                if (!FileMapHandle) {
                    DWORD Error = GetLastError();
                    
                    CloseHandle(FileHandle);
                    throw new W32Error(Error);
                }                                
                    

                TCHAR   *Data = (TCHAR *)MapViewOfFile(FileMapHandle,
                                                FILE_MAP_READ,
                                                0,
                                                0,
                                                0);
                                        
                if (!Data) {
                    DWORD   Error = GetLastError();

                    CloseHandle(FileMapHandle);
                    CloseHandle(FileHandle);

                    throw new W32Error(Error);
                }


                //
                // Get the length of the file
                //
                            
                BY_HANDLE_FILE_INFORMATION  FileInfo = {0};

                if (!GetFileInformationByHandle(FileHandle,
                            &FileInfo)) {
                    DWORD   Error = GetLastError();

                    UnmapViewOfFile(Data);
                    CloseHandle(FileMapHandle);
                    CloseHandle(FileHandle);

                    throw new W32Error(Error);
                }                        
                

                ULONG LineNumber = 0;
                ULONG ErrorOffset = 0;
                ULONG DbcsCount = 0;

                //
                // Validate the Data
                //
                BOOL  Result = ValidateDbcsData(Data, 
                                        FileInfo.nFileSizeLow,
                                        LineNumber,
                                        ErrorOffset,
                                        DbcsCount);


                if (!Result) {
                    std::cout << "Character not valid at line number : " 
                              << std::dec << LineNumber 
                              << " offset : " << std::dec << ErrorOffset
                              << std::endl;
                } else {
                    Result = 0; // no errors\
                    
                    std::cout << FileName << " is valid DBCS file with " 
                        << std::dec << DbcsCount << " DBCS char(s)" << std::endl;
                }                

                //
                // Clean up
                //
                UnmapViewOfFile(Data);
                CloseHandle(FileMapHandle);
                CloseHandle(FileHandle);            
            } else {
                std::cout << "Error in setting Code Page to : " 
                    << std::dec << CodePage << std::endl;
            }                    
        } else {
            std::cout << Usage << std::endl;
        }    
    }        
    catch(W32Error *Error) {
        Error->Dump(std::cout);
        delete Error;
    }
    catch(...) {
        std::cout << "Internal error" << std::endl;
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\html2bmp.h ===
// Html2Bmp.h : main header file for the HTML2BMP application
//

#if !defined(AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_)
#define AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp:
// See Html2Bmp.cpp for the implementation of this class
//

class CHtml2BmpApp : public CWinApp
{
public:
	CHtml2BmpApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHtml2BmpApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CHtml2BmpApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CEigeneCommandLineInfo : public CCommandLineInfo
{
public:
	virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

	CStringArray* cmdLine;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\html2bmp.cpp ===
// Html2Bmp.cpp : Defines the class behaviors for the application.
// 
// created: JurgenE
//

#include "stdafx.h"
#include "Html2Bmp.h"
#include "HtmlDlg.h"
#include "FileDialogEx.h"
#include "iostream.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp

BEGIN_MESSAGE_MAP(CHtml2BmpApp, CWinApp)
	//{{AFX_MSG_MAP(CHtml2BmpApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp construction

CHtml2BmpApp::CHtml2BmpApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CHtml2BmpApp object

CHtml2BmpApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp initialization

BOOL CHtml2BmpApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CHtmlDlg dlg;

	CString m_HtmlFile;
	CString m_TemplateBitmapFile;
	CString m_OutputBitmapFile;

	CStringArray* cmdLine = new CStringArray;
	CEigeneCommandLineInfo cmdInfo;
	cmdInfo.cmdLine = cmdLine;
	ParseCommandLine(cmdInfo);

	INT_PTR m = cmdLine->GetSize();
	CString cTest;

	// read all command line options
	for(int j = 0; j < m; j++)
	{
		cTest = cmdLine->GetAt(j);
		cTest.MakeLower();

		if(cTest == "?")	// HTML file
		{
			CString help;
			help = "Usage: Html2Bmp [-h HTMLfile] [-t TemplateBitmap] [-o OutputBitmap]\n\r\n\r";
			help += "Example: Html2Bmp -h c:\\scr\\screen1.html    ; template bitmap will be extracted from screen1.html\n\r";
			help += "                Html2Bmp -h c:\\scr\\screen1.html  -t template.bmp\n\r";
			help += "\n\rContact: Jurgen Eidt";
			AfxMessageBox(help, MB_ICONINFORMATION);

			return FALSE;
		}

		if(cTest == "h")	// HTML file
		{
			if(j+1 < m)
			{
				m_HtmlFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}

		if(cTest == "t")	// Template bitmap file
		{
			if(j+1 < m)
			{
				m_TemplateBitmapFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}

		if(cTest == "o")	// output bitmap file
		{
			if(j+1 < m)
			{
				m_OutputBitmapFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}
	}

	cmdLine->RemoveAll();
	delete cmdLine;

	if(m_HtmlFile.IsEmpty())
	{
		CFileDialogEx fd(TRUE, NULL, NULL, 
			OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 
			"HTML files (*.html;*.htm) |*.html;*.htm|All files (*.*)|*.*||", NULL );

		if(fd.DoModal() == IDOK)
			m_HtmlFile = fd.GetPathName();
		else
			return FALSE;
	}


	dlg.m_HtmlFile = m_HtmlFile;
	dlg.m_TemplateBitmapFile = m_TemplateBitmapFile;
	dlg.m_OutputBitmapFile = m_OutputBitmapFile;

	dlg.DoModal();

/*
	CHtml2BmpDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}
*/
	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

void CEigeneCommandLineInfo::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{
/* 
	lpszParam The parameter or flag.
	bFlag Indicates whether lpszParam is a parameter or a flag.
	bLast Indicates if this is the last parameter or flag on the command line.
*/

	// disable the shell from processing the user defined cmd line arguments
//	CCommandLineInfo::ParseParam(lpszParam, bFlag, bLast);


	cmdLine->Add(lpszParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\htmlctrl.h ===
////////////////////////////////////////////////////////////////
// Microsoft Systems Journal -- December 1999
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif
#include <afxhtml.h>

class CHtmlCtrl : public CHtmlView {
public:
	CHtmlCtrl() { }
	~CHtmlCtrl() { }

	BOOL CreateFromStatic(UINT nID, CWnd* pParent);

	// Normally, CHtmlView destroys itself in PostNcDestroy,
	// but we don't want to do that for a control since a control
	// is usually implemented as a stack object in a dialog.
	//
	virtual void PostNcDestroy() {  }

	// overrides to bypass MFC doc/view frame dependencies
	afx_msg void OnDestroy();
	afx_msg int  OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT msg);

	// override to trap "app:" pseudo protocol
	virtual void OnBeforeNavigate2( LPCTSTR lpszURL,
		DWORD nFlags,
		LPCTSTR lpszTargetFrameName,
		CByteArray& baPostedData,
		LPCTSTR lpszHeaders,
		BOOL* pbCancel );

	// override to handle links to "app:mumble...". lpszWhere will be "mumble"
	virtual void OnAppCmd(LPCTSTR lpszWhere);

	DECLARE_MESSAGE_MAP();
	DECLARE_DYNAMIC(CHtmlCtrl)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\filedialogex.cpp ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Largely based on original implementation by Michael Lemley.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
// CFileDialogEx implements a CFileDialog that uses the new Windows
// 2000 style open/save dialog. Use companion class CDocManagerEx in an
// MFC framework app.
//
#include "stdafx.h"
#include <afxpriv.h>
#include "FileDialogEx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static BOOL IsWin2000();

IMPLEMENT_DYNAMIC(CFileDialogEx, CFileDialog)

CFileDialogEx::CFileDialogEx(BOOL bOpenFileDialog, LPCTSTR lpszDefExt,
	LPCTSTR lpszFileName, DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
	CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
		dwFlags, lpszFilter, pParentWnd)
{
}


BEGIN_MESSAGE_MAP(CFileDialogEx, CFileDialog)
	//{{AFX_MSG_MAP(CFileDialogEx)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL IsWin2000() 
{
   OSVERSIONINFOEX osvi;
   BOOL bOsVersionInfoEx;

   // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
   // which is supported on Windows 2000.
   //
   // If that fails, try using the OSVERSIONINFO structure.

   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

   if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
   {
      // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
         return FALSE;
   }

   switch (osvi.dwPlatformId)
   {
      case VER_PLATFORM_WIN32_NT:

         if ( osvi.dwMajorVersion >= 5 )
            return TRUE;

         break;
   }
   return FALSE; 
}

//////////////////
// DoModal override copied mostly from MFC, with modification to use
// m_ofnEx instead of m_ofn.
//
INT_PTR CFileDialogEx::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

	// WINBUG: This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);

	if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);

	memset(&m_ofnEx, 0, sizeof(m_ofnEx));
	memcpy(&m_ofnEx, &m_ofn, sizeof(m_ofn));
    if (IsWin2000())
	   m_ofnEx.lStructSize = sizeof(m_ofnEx);

	INT_PTR nResult;
	if (m_bOpenFileDialog)
		nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofnEx);
	else
		nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofnEx);

	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	pThreadState->m_pAlternateWndInit = NULL;

	// WINBUG: Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofnEx.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);

	PostModal();
	return nResult ? nResult : IDCANCEL;
}

//////////////////
// When the open dialog sends a notification, copy m_ofnEx to m_ofn in
// case handler function is expecting updated information in the
// OPENFILENAME struct.
//
BOOL CFileDialogEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

   return CFileDialog::OnNotify( wParam, lParam, pResult);
}

////////////////////////////////////////////////////////////////
// The following functions are provided for testing purposes, to
// demonstrate that they in fact called; ie, that MFC's internal dialog
// proc is hooked up properly. Delete them if you like.
//
BOOL CFileDialogEx::OnFileNameOK()
{
	TRACE(_T("CFileDialogEx::OnFileNameOK\n"));
   return CFileDialog::OnFileNameOK();
}

void CFileDialogEx::OnInitDone()
{
	TRACE(_T("CFileDialogEx::OnInitDone\n"));
   CFileDialog::OnInitDone();
}

void CFileDialogEx::OnFileNameChange()
{
	TRACE(_T("CFileDialogEx::OnFileNameChange\n"));
   CFileDialog::OnFileNameChange();
}

void CFileDialogEx::OnFolderChange()
{
	TRACE(_T("CFileDialogEx::OnFolderChange\n"));
   CFileDialog::OnFolderChange();
}

void CFileDialogEx::OnTypeChange()
{
	TRACE(_T("OnTypeChange(), index = %d\n"), m_ofn.nFilterIndex);
   CFileDialog::OnTypeChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_)
#define AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Html2Bmp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_HTML2BMP_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_HTML                        129
#define IDC_HTMLVIEW                    1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Html2Bmp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\htmldlg.cpp ===
// HtmlDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Html2Bmp.h"
#include "HtmlDlg.h"
#include "IParser.h"

#include <fstream.h> 
#include <direct.h>

#define TIMERID 1

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg dialog


CHtmlDlg::CHtmlDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHtmlDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHtmlDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_nTimerID = 0;
}


void CHtmlDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHtmlDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHtmlDlg, CDialog)
	//{{AFX_MSG_MAP(CHtmlDlg)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg message handlers

BOOL CHtmlDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	if(m_OutputBitmapFile.IsEmpty())
		m_OutputBitmapFile = m_HtmlFile + _T(".bmp");

	if(m_HtmlFile.Left(2) != _T(":") && m_HtmlFile.Left(3) != _T("\\"))
	{
		char buffer[_MAX_PATH];
		_getcwd(buffer, _MAX_PATH);

		CString prefix(buffer);

		if(prefix.Right(1) != _T("\\"))
			prefix += _T("\\");

		m_HtmlFile = prefix + m_HtmlFile;
	}

    if(m_TemplateBitmapFile.IsEmpty())
	{
		m_BmpFile = GetTemplateBmp();

		if(m_BmpFile.Left(1) != _T(".") || m_BmpFile.Left(1) != _T("\\"))
		{
			char buffer[_MAX_PATH];
			_getcwd(buffer, _MAX_PATH);

			CString prefix(buffer);

			if(prefix.Right(1) != _T("\\"))
				prefix += _T("\\");

			m_BmpFile = prefix + m_BmpFile;
		}
	}
	else
		m_BmpFile = m_TemplateBitmapFile;


	CFile BmpFileTest;
	if(!BmpFileTest.Open(m_BmpFile, CFile::modeRead))
	{
		if(m_TemplateBitmapFile.IsEmpty())
			AfxMessageBox(_T("The target bitmap could not be located inside the HTML page:\n") + m_HtmlFile + _T("\nCheck the HTML page."));
		else
			AfxMessageBox(_T("The target bitmap could not be loaded:\n") + m_TemplateBitmapFile);

		EndDialog(1);
		return FALSE;
	}

	BITMAPFILEHEADER BmpFileTestHdr;
	DIBSECTION BmpFileTestDibSection;

	// file header 
	BmpFileTest.Read(&BmpFileTestHdr, sizeof(BmpFileTestHdr));
	
	// BitmapInfoHeader
	BmpFileTest.Read(&BmpFileTestDibSection.dsBmih , sizeof(BmpFileTestDibSection.dsBmih));

	BmpFileTest.Close();

	m_biCompression = BmpFileTestDibSection.dsBmih.biCompression;
	m_bitw = BmpFileTestDibSection.dsBmih.biWidth;
	m_bith = BmpFileTestDibSection.dsBmih.biHeight;


	int ScreenX = GetSystemMetrics(SM_CXSCREEN);
	int ScreenY = GetSystemMetrics(SM_CYSCREEN);

//	SetWindowPos(&CWnd::wndTop, (ScreenX - m_bitw)/2, (ScreenY - m_bith)/2, m_bitw+10, m_bith+10, SWP_SHOWWINDOW);
	SetWindowPos(&CWnd::wndTop, 0, 0, ScreenX, ScreenY, SWP_SHOWWINDOW);

	VERIFY(m_htmlCtrl.CreateFromStatic(IDC_HTMLVIEW, this));

	m_htmlCtrl.MoveWindow(0, 0, ScreenX, ScreenY);
//	m_htmlCtrl.MoveWindow((ScreenX - m_bitw)/2, (ScreenY - m_bith)/2, ScreenX, ScreenY);
	m_htmlCtrl.Navigate(m_HtmlFile);	

	m_nTimerID = SetTimer(TIMERID, 100, NULL);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHtmlDlg::OnTimer(UINT nIDEvent) 
{
	if(nIDEvent == m_nTimerID )
	{
		// Don't know what gets all loaded into the page,
		// so wait until everything is loaded and then start creating the bitmap
		if(!m_htmlCtrl.GetBusy())
		{
			KillTimer(TIMERID);
			m_nTimerID = 0;

			Capture();

			EndDialog(1);
		}
	}
	
	CDialog::OnTimer(nIDEvent);
}

CString CHtmlDlg::GetTemplateBmp() 
{
	ifstream* pHtmlFile = new ifstream(m_HtmlFile, ios::nocreate);
	if(*pHtmlFile == NULL || pHtmlFile->bad())
	{
		delete pHtmlFile;
		return "";
	}
	else
	{
		pHtmlFile->seekg(0, ios::end);
		int size = pHtmlFile->tellg();
		pHtmlFile->seekg(0, ios::beg);
		unsigned char* buf = new unsigned char[size];
		pHtmlFile->read(buf, size);

		CString HtmlContent(buf);

		CIParser IParser(HtmlContent);
		delete pHtmlFile;

		return IParser.TemplateBitmapName;
	}	
}

void CHtmlDlg::Capture() 
{
	CPaintDC dc(this); // device context for painting
	
	CDC memdc;
	memdc.CreateCompatibleDC(&dc);
	
	CBitmap Bitmap;
	if(!Bitmap.Attach(::LoadImage(NULL, m_BmpFile, IMAGE_BITMAP, 0, 0,
		LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE)))
	{
		AfxMessageBox(_T("The following bitmap could not be loaded:\n") + m_BmpFile);
		return;
	}

	DIBSECTION DibSection;

	::GetObject(
	  (HBITMAP)Bitmap,  // handle to graphics object
	  sizeof(DIBSECTION),     // size of buffer for object information
	  &DibSection  // buffer for object information
	);


	BITMAP bmp;
	Bitmap.GetBitmap(&bmp);
//	int bitw = bmp.bmWidth;
//	int bith = bmp.bmHeight;
	int bmBitsPixel = bmp.bmBitsPixel;
	

	memdc.SelectObject(&Bitmap);

	memdc.BitBlt(0, 0, m_bitw, m_bith, &dc, 0, 0, SRCCOPY);

    // Convert the color format to a count of bits. 
    int cClrBits = bmp.bmPlanes * bmp.bmBitsPixel; 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 

	int nColors = 1 << cClrBits;
	RGBQUAD* pColors = new RGBQUAD[nColors];
    if(cClrBits != 24)
	{
		::GetDIBColorTable(
		  memdc.m_hDC,           // handle to DC
		  0,  // color table index of first entry
		  nColors,     // number of entries to retrieve
		  pColors   // array of color table entries
		);
	}


	CFile file;
	if(!file.Open(m_OutputBitmapFile, CFile::modeWrite | CFile::modeCreate))
	{
		AfxMessageBox(_T("The target bitmap could not be created:\n") + m_OutputBitmapFile);
		return;
	}

    // For Windows NT/2000, the width must be DWORD aligned unless 
    // the bitmap is RLE compressed.
    // For Windows 95/98, the width must be WORD aligned unless the 
    // bitmap is RLE compressed.
	int PictureSize = DWORD_ALIGNED(m_bitw * bmBitsPixel * 8) * m_bith / 8;


	unsigned char* buf;

    if(cClrBits == 4 && m_biCompression == BI_RLE4
		|| cClrBits == 8 && m_biCompression == BI_RLE8) 
		buf = Compress((DibSection.dsBmih.biCompression = m_biCompression), (unsigned char*)DibSection.dsBm.bmBits, m_bitw, PictureSize);
	else
	{
		buf = (unsigned char*)DibSection.dsBm.bmBits;
		DibSection.dsBmih.biCompression = BI_RGB;
	}

	DibSection.dsBmih.biSizeImage = PictureSize;
/*
biCompression 
Specifies the type of compression for a compressed bottom-up bitmap 
(top-down DIBs cannot be compressed). This member can be one of the following values. 

Value Description 
BI_RGB An uncompressed format. 
BI_RLE8 A run-length encoded (RLE) format for bitmaps with 8 bpp. 
		The compression format is a 2-byte format consisting of a count byte followed 
		by a byte containing a color index. For more information, see Bitmap Compression.  
BI_RLE4 An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format 
		consisting of a count byte followed by two word-length color indexes. 
		For more information, see Bitmap Compression. 
*/


	// Fill in the fields of the file header 
	BITMAPFILEHEADER hdr;

	hdr.bfType = ((WORD) ('M' << 8) | 'B');	// is always "BM"
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + 
                 DibSection.dsBmih.biSize + DibSection.dsBmih.biClrUsed 
                 * sizeof(RGBQUAD) + DibSection.dsBmih.biSizeImage); 
	hdr.bfReserved1 = 0;
	hdr.bfReserved2 = 0;
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    DibSection.dsBmih.biSize + DibSection.dsBmih.biClrUsed 
                    * sizeof (RGBQUAD); 

	// Write the file header 
	file.Write(&hdr, sizeof(hdr));
	
	// BitmapInfoHeader
	file.Write(&DibSection.dsBmih , sizeof(DibSection.dsBmih));

	// Color table
    if(cClrBits != 24)
		file.Write(pColors , DibSection.dsBmih.biClrUsed * sizeof (RGBQUAD));

	
	// Write the bits 
	file.Write(buf, PictureSize);
}

unsigned char* CHtmlDlg::Compress(int cMode, unsigned char* bmBits, int width, int& PictureSize) 
{
	if(cMode == BI_RLE4)
	{
		unsigned char* buf = new unsigned char[2*PictureSize+1];
		ZeroMemory(buf, 2*PictureSize+1);

		int cIndex = 0;
		int cSize = 0;
		int LineCount = 0;
		unsigned char c;

		int i = 0;
		while(i < PictureSize)
		{
			c = bmBits[i++];
			cSize = 1;
			while(i < PictureSize)
			{
				LineCount += 2;	// 2 pixel pro Byte

				if(bmBits[i] == c && cSize < 127 && LineCount < width)
				{
					cSize++;
				}
				else
				{
					buf[cIndex++] = 2*cSize;	// 2 pixel pro Byte
					buf[cIndex++] = c;

					if(LineCount >= width)
					{
						LineCount = 0;
						buf[cIndex++] = 0;
						buf[cIndex++] = 0;
					}

					break;
				}

				i++;
			}
		}

		// und den Rest noch bearbeiten
		if(cSize > 1)
		{
			buf[cIndex++] = 2*cSize;
			buf[cIndex++] = c;
		}

		PictureSize = cIndex;
		return buf;
	}
	else
	if(cMode == BI_RLE8)
	{
		unsigned char* buf = new unsigned char[2*PictureSize+1];
		ZeroMemory(buf, 2*PictureSize+1);

		int cIndex = 0;
		int cSize = 0;
		int LineCount = 0;
		unsigned char c;

		int i = 0;
		while(i < PictureSize)
		{
			c = bmBits[i++];
			cSize = 1;
			while(i < PictureSize)
			{
				LineCount++;

				if(bmBits[i] == c && cSize < 127 && LineCount < width)
				{
					cSize++;
				}
				else
				{
					buf[cIndex++] = (unsigned char)cSize;
					buf[cIndex++] = c;

					if(LineCount >= width)
					{
						LineCount = 0;
						buf[cIndex++] = 0;
						buf[cIndex++] = 0;
					}

					break;
				}

				i++;
			}
		}

		// und den Rest noch bearbeiten
		if(cSize > 1)
		{
			buf[cIndex++] = (unsigned char)cSize;
			buf[cIndex++] = c;
		}

		PictureSize = cIndex;
		return buf;
	}

	return bmBits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\iparser.h ===
// IParser.h: interface for the CIParser class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_)
#define AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CIParser  
{
public:
	CIParser(CString& Source);
	virtual ~CIParser();

private:
	CString m_Source;

public:
	CString TemplateBitmapName;

private:
	void LexAnalyse();

	bool isNameOrNumber(TCHAR c)
	{
		return isName(c) || isNumber(c);
	}

	bool isName(TCHAR c)
	{
		return (c >= _T('a') && c <= _T('z'))
			|| (c >= _T('A') && c <= _T('Z')) 
			|| (c == _T('_'));
	}

	bool isNumber(TCHAR c)
	{
		return c >= _T('0') && c <= _T('9');
	}


	bool isWhiteSpace(TCHAR c)
	{
		return c == L' ' || c == L'\t';
	}

	bool isEndl(TCHAR c)
	{
		return c == L'\n' || c == L'\r';
	}

	bool isSeparator(TCHAR c)
	{
		return c == _T(',');
	}

	bool isHochKomma(TCHAR c)
	{
		return c == _T('\'') || c == _T('\"');
	}
	bool isHTMLopenBracket(TCHAR c)
	{
		return c == _T('<');
	}

	bool isHTMLclosingBracket(TCHAR c)
	{
		return c == _T('>');
	}
};

#endif // !defined(AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\htmldlg.h ===
#if !defined(AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_)
#define AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HtmlDlg.h : header file
//

#include "HtmlCtrl.h"

#define DWORD_ALIGNED(bits)    (((bits) + 31) / 32 * 4)

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg dialog

class CHtmlDlg : public CDialog
{
// Construction
public:
	CHtmlDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CHtmlDlg)
	enum { IDD = IDD_HTML };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHtmlDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString m_HtmlFile;
	CString m_TemplateBitmapFile;
	CString m_OutputBitmapFile;

private:
	CHtmlCtrl m_htmlCtrl;
	UINT_PTR m_nTimerID;

	int m_bitw;
	int m_bith;
	int m_biCompression;
	CString m_BmpFile;

private:
	void Capture();
	CString GetTemplateBmp();
	unsigned char* Compress(int cMode, unsigned char* bmBits, int width, int& PictureSize);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHtmlDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\html2bmp\iparser.cpp ===
// IParser.cpp: implementation of the CIParser class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Html2Bmp.h"
#include "IParser.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIParser::CIParser(CString& Source)
{
	m_Source = Source + _T(" ");
	LexAnalyse();
}

CIParser::~CIParser()
{
}

void CIParser::LexAnalyse()
{
	// <table border="0" width="648" cellspacing="0" cellpadding="0" 
	// height="530" background="template.bmp">

	int len = m_Source.GetLength()-1;
	int i = 0;
	CString word;

	while(i < len)
	{
		// start with an HTML tag
		if(isHTMLopenBracket(m_Source[i]))
		{
			word = _T("");
			while(i < len)
			{
				word += m_Source[i++];
						
				if(!isNameOrNumber(m_Source[i]))
				{
					// we are in the table
					if(!word.CompareNoCase(_T("<table")))
					{
						word = _T("");
						while(i < len)
						{
							if(isWhiteSpace(m_Source[i]))
								i++;
							else
								word += m_Source[i++];
		
							if(!isNameOrNumber(m_Source[i]))
							{
								// is it the background attribute?
								if(!word.CompareNoCase(_T("background")))
								{
									// skip the assignment operator and the first quote (if any)
									word = _T("");
									while(i < len)
									{
										if(isNameOrNumber(m_Source[i]))
											break;
										
										i++;
									}

									// extract the file name
									while(i < len)
									{
										if(isHochKomma(m_Source[i])
											|| isHTMLclosingBracket(m_Source[i]))
											break;

										word += m_Source[i];

										i++;
									}

									// Done!
									TemplateBitmapName = word;
									return;
								}

								word = _T("");
							}

							if(isHTMLclosingBracket(m_Source[i]))
								break;
						}
					}
				}

				if(isHTMLclosingBracket(m_Source[i]))
					break;
			}

			continue;
		}

		i++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\imgdt\imgdt.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    imgdt.cpp

Abstract:

    Tool to manipulate the link date/time
    stamp in binaries

    NOTE : For I386/IA64 binaries only.

    MappedFile abstracts the mapped binary
    file in the memory and has methods to
    get and set link datetime stamp. While
    setting the datetime stamp it also
    recomputes and updates the new checksum.

Author:

    Vijay Jayaseelan (vijayj) Sep-23-2000

Revision History:

    None

--*/

#include <iostream>
#include <string>
#include <exception>
#include <algorithm>
#include <windows.h>
#include <imagehlp.h>
#include <io.h>

//
// Usage format
//
std::wstring Usage(L"Usage: imgdt filename [mm/dd/yyyy] [hh:mm:ss]");


//
// Prototypes
//
BOOL
FileTimeToTimeDateStamp(
    LPFILETIME FileTime,
    DWORD &DateTime
    );

BOOL 
TimeDateStampToFileTime( 
    DWORD DateTime, 
    LPFILETIME FileTime 
    );  

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, str.c_str());
    return os;
}

std::ostream& operator<<(std::ostream &os, const SYSTEMTIME &Time) {
    os << Time.wMonth << '/' << Time.wDay << '/' << Time.wYear;    
    os << ", " << Time.wHour << ":" << Time.wMinute << ":" << Time.wSecond;

    return os;
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid program usage or help
//
struct ProgramUsage : public InvalidArguments {
    std::wstring UsageStr;

    ProgramUsage(const std::wstring &Usage) : UsageStr(Usage){}
    
    const char *what() const throw() {
        return "Program Usage";
    }

    void Dump(std::ostream &os) {
        os << UsageStr << std::endl;
    }
};

//
// Invalid file name
//
struct InvalidFileName : InvalidArguments {
    std::wstring     FileName;
    
    InvalidFileName(const std::wstring &file) : FileName(file){}

    const char *what() const throw() {
        return "Invalid Filename";
    }

    virtual void Dump(std::ostream &os) {
        os << what() << " : " << FileName << std::endl;
    }
};


//
// Argument cracker
//
struct ProgramArguments {
    std::wstring    ImageName;
    bool            Set;
    SYSTEMTIME      TimeToSet;

    ProgramArguments(int Argc, wchar_t *Argv[]) {
        Set = false;
        memset(&TimeToSet, 0, sizeof(SYSTEMTIME));
        
        if (Argc > 1) {
            ImageName = Argv[1];

            if ((ImageName == L"/?") || (ImageName == L"?") ||
                (ImageName == L"-?")) {
                throw new ProgramUsage(Usage);
            }

            if (_waccess(ImageName.c_str(), 0)) {
                throw new InvalidFileName(ImageName);
            }

            if (Argc > 2) {
                Set = true;
                std::wstring Date = Argv[2];

                if (!ParseDateTime(Date, TimeToSet.wMonth, 
                        TimeToSet.wDay, TimeToSet.wYear)) {
                    throw new InvalidArguments();                        
                }

                if (Argc > 3) {
                    std::wstring Time = Argv[3];

                    if (!ParseDateTime(Time, TimeToSet.wHour, 
                            TimeToSet.wMinute, TimeToSet.wSecond, L':')) {
                        throw new InvalidArguments();                        
                    }                    
                }

                if (!IsValidSystemTime()) {
                    throw new InvalidArguments();
                }
            }
        } else {
            throw new ProgramUsage(Usage);
        }
    }

    bool ParseDateTime(const std::wstring &Input,
            WORD &First, WORD &Second, WORD &Third, wchar_t Separator = L'/') {
        bool Result = false;                
        std::wstring::size_type Count = std::count(Input.begin(), Input.end(), Separator);

        if (Count == 2) {
            std::wstring::size_type FirstSlashPos = Input.find(Separator);
            std::wstring::size_type SecondSlashPos = Input.find(Separator, FirstSlashPos + 1);
            std::wstring FirstStr = Input.substr(0, FirstSlashPos);
            std::wstring SecondStr = Input.substr(FirstSlashPos + 1, 
                                    SecondSlashPos - FirstSlashPos - 1);
            std::wstring ThirdStr = Input.substr(SecondSlashPos + 1);

            wchar_t *Temp = NULL;
            
            long Value = wcstol(FirstStr.c_str(), &Temp, 10);

            if (!errno) {
                First = (WORD)Value;

                Value = wcstol(SecondStr.c_str(), &Temp, 10);

                if (!errno) {
                    Second = (WORD)Value;

                    Value = wcstol(ThirdStr.c_str(), &Temp, 10);

                    if (!errno) {
                        Third = (WORD)Value;
                    }
                }
            }

            if (!errno) {
                Result = true;
            }
        }

        return Result;
    }    

    bool IsValidSystemTime() {
        return (TimeToSet.wYear && TimeToSet.wMonth && TimeToSet.wDay &&
                (TimeToSet.wMonth < 13) && (TimeToSet.wDay < 32) &&
                (TimeToSet.wSecond < 60) && (TimeToSet.wMinute < 60) &&
                (TimeToSet.wHour < 24));
    }

    friend std::ostream operator<<(std::ostream &os, const ProgramArguments &Args) {
        os << "Arguments : " 
           << Args.ImageName << ", "
           << "Set = " << Args.Set;

        if (Args.Set) {           
            os << ", " << Args.TimeToSet << std::endl;
        }            

        return os;           
    }
};


//
// Memory mapped file abstraction
//
class MappedFile {
public:
    MappedFile(const std::wstring &ImgName) : ImageName(ImgName){
        DWORD ErrorCode = 0;

        ImageFileHandle = ImageFileMap = NULL;
        ImageFileView = NULL;
        ImageHdr = NULL;
        
        ImageFileHandle = CreateFileW(ImageName.c_str(),
                                GENERIC_WRITE | GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (ImageFileHandle != INVALID_HANDLE_VALUE) {
            ImageFileMap = CreateFileMapping(ImageFileHandle,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL);

            if (ImageFileMap) {
                ImageFileView = MapViewOfFile(ImageFileMap,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    0);

                if (ImageFileView) {
                    ImageHdr = ImageNtHeader(ImageFileView);

                    if (!ImageHdr) {
                        ErrorCode = GetLastError();
                    }
                } else {
                    ErrorCode = GetLastError();
                }   
            } else {
                ErrorCode = GetLastError();
            }            
        } else {
            ErrorCode = GetLastError();
        }        


        if (ErrorCode) {
            throw new W32Error(ErrorCode);
        }
    }

    DWORD GetDateTime(SYSTEMTIME &Time) {
        FILETIME    FileTime;
        DWORD       DateTime = ImageHdr->FileHeader.TimeDateStamp;

        ZeroMemory(&FileTime, sizeof(FILETIME));

        if (TimeDateStampToFileTime(DateTime, &FileTime)) {
            FileTimeToSystemTime(&FileTime, &Time);
        }            

        return GetLastError();
    }

    DWORD SetDateTime(SYSTEMTIME &Time) {
        FILETIME    FileTime;

        ZeroMemory(&FileTime, sizeof(FILETIME));

        std::cout << Time << std::endl;

        if (SystemTimeToFileTime(&Time, &FileTime)) {
            DWORD DateTime = 0;
            BY_HANDLE_FILE_INFORMATION FileInfo = {0};            
            
            if (FileTimeToTimeDateStamp(&FileTime, DateTime) &&
                GetFileInformationByHandle(ImageFileHandle, &FileInfo)) {
                ImageHdr->FileHeader.TimeDateStamp = DateTime;

                DWORD   HdrSum = 0;
                DWORD   ChkSum = 0;

                PIMAGE_NT_HEADERS NtHdrs = CheckSumMappedFile(ImageFileView,
                                                FileInfo.nFileSizeLow,
                                                &HdrSum,
                                                &ChkSum);

                if (NtHdrs) {
                    if (ImageHdr->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64) {
                        PIMAGE_NT_HEADERS64 NtHdrs64 =  
                                                (PIMAGE_NT_HEADERS64)NtHdrs;
                                                
                        NtHdrs64->OptionalHeader.CheckSum = ChkSum;
                    } else {
                        NtHdrs->OptionalHeader.CheckSum = ChkSum;
                    }
                }
            }
        }

        return GetLastError();
    }

    ~MappedFile() {
        if (ImageFileView)
            UnmapViewOfFile(ImageFileView);

        if (ImageFileMap)
            CloseHandle(ImageFileMap);

        if (ImageFileHandle && (ImageFileHandle != INVALID_HANDLE_VALUE))
            CloseHandle(ImageFileHandle);
    }
   
protected:
    //
    // data members
    //
    HANDLE  ImageFileHandle;
    HANDLE  ImageFileMap;
    PVOID   ImageFileView;
    PIMAGE_NT_HEADERS ImageHdr;
    std::wstring ImageName;
};

//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    
    try {
        DWORD Error = 0;
        ProgramArguments    Args(Argc, Argv);        
        MappedFile          ImgFile(Args.ImageName);

        if (Args.Set) {
            Error = ImgFile.SetDateTime(Args.TimeToSet);
        } else {
            Error = ImgFile.GetDateTime(Args.TimeToSet);

            if (!Error) {
                std::cout << Args.TimeToSet << std::endl;
            }                
        }                    

        if (Error) {
            throw new W32Error(Error);
        }
    }
    catch(ProgramUsage *PrgUsg) {
        Result = 1;
        PrgUsg->Dump(std::cout);
        delete PrgUsg;
    } catch (InvalidArguments *InvArgs) {
        Result = 1;
        InvArgs->Dump(std::cout);
        delete InvArgs;
        std::cout << Usage;
    } catch (ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}

//
// These functions convert GMT time datetime stamp
// to FILETIME and vice-versa
//
BOOL
FileTimeToTimeDateStamp(
    LPFILETIME FileTime,
    DWORD &DateTime
    )
{
    __int64 t1970 = 0x019DB1DED53E8000; // Magic... GMT...  Don't ask....
    __int64 Time = 0;

    memcpy(&Time, FileTime, sizeof(Time));
    Time -= t1970;
    Time /= 10000000;

    DateTime = (DWORD)Time;
    
    return TRUE;
}


BOOL 
TimeDateStampToFileTime( 
    DWORD DateTime, 
    LPFILETIME FileTime 
    )
{
    __int64 t1970 = 0x019DB1DED53E8000; // Magic... GMT...  Don't ask....

    __int64 timeStampIn100nsIncr = (__int64)DateTime * 10000000;

    __int64 finalValue = t1970 + timeStampIn100nsIncr;

    memcpy(FileTime, &finalValue, sizeof( finalValue ) );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\fileenum\ansi.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ansi.c

Abstract:

    Builds A versions of the fileenum APIs.

Author:

    Jim Schmidt (jimschm) 16-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 27-Nov-1996  Added level and filter to EnumTree
    Jim Schmidt (jimschm) 20-Dec-1996  Added callback levels and made single
                                       source file for both A and W versions

    Mike Condra (mikeco)  02-Jun-1997  Add excluded-file/path functions
--*/

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#include "no_pch.h"

#include "..\..\inc\fileenum.h"

typedef struct {
    FILEENUMPROCA fnEnumCallback;
    FILEENUMFAILPROCA fnFailCallback;
    DWORD         EnumID;
    LPVOID        pParam;
    DWORD         Levels;
    DWORD         CurrentLevel;
    DWORD         AttributeFilter;
} ENUMSTRUCTA, *PENUMSTRUCTA;

BOOL EnumTreeEngineA (LPCSTR CurrentPath, PENUMSTRUCTA pes);
BOOL IsPathExcludedA (DWORD EnumID, LPCSTR Path);
BOOL IsFileExcludedA (DWORD EnumID, LPCSTR File, BYTE byBitmask[]);
BOOL BuildExclusionsFromInfA (DWORD EnumID, PEXCLUDEINFA ExcludeInfStruct);
void CreateBitmaskA (DWORD EnumID, LPCSTR FindPattern, BYTE byBitmask[]);

//
// Build A versions of fileenum
//

#define EnumerateAllDrivesT         EnumerateAllDrivesA
#define FILEENUMPROCT               FILEENUMPROCA
#define FILEENUMFAILPROCT           FILEENUMFAILPROCA
#define PEXCLUDEINFT                PEXCLUDEINFA
#define EnumerateTreeT              EnumerateTreeA
#define ENUMSTRUCTT                 ENUMSTRUCTA
#define PENUMSTRUCTT                PENUMSTRUCTA
#define EnumTreeEngineT             EnumTreeEngineA
#define IsPathExcludedT             IsPathExcludedA
#define CreateBitmaskT              CreateBitmaskA
#define IsFileExcludedT             IsFileExcludedA
#define BuildExclusionsFromInfT     BuildExclusionsFromInfA
#define ClearExclusionsT            ClearExclusionsA
#define ExcludeFileT                ExcludeFileA
#define ExcludePathT                ExcludePathA

#include "enumaw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\fileenum\copyfile.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    File copy functions

    The code in this source file traverses a drive tree and calls
    an external callback function for each file.  An INF can be
    provided to exclude files and/or directories from enumeration.

Author:

    Mike Condra 16-Aug-1996

Revision History:

    calinn   29-Ian-1998   Modified CopyFileCallback to reset directory attributes for delete op.
    jimschm  20-Dec-1996   Modified return codes

--*/

#include "no_pch.h"
#include "fileenum.h"
#include <winnls.h>

#ifndef UNICODE
#ifdef DEBUG
#error UNICODE required for DEBUGMSG macro
#endif
#endif


BOOL
CALLBACK
CopyFileCallbackA(
                  LPCSTR szFullFileSpecIn,
                  LPCSTR DontCare,
                  WIN32_FIND_DATAA *pFindData,
                  DWORD dwEnumHandle,
                  LPVOID pVoid,
                  PDWORD CurrentDirData
                  )
/*
    This function is the built-in callback for CopyTree. Its purpose is to
    build the target filespec, give the user-supplied callback a chance to
    veto the copy, then perform the copy and any directory creation it
    requires.  The signature of this function is the generic callback
    used for EnumerateTree.
*/
{
    COPYTREE_PARAMSA *pCopyParams = (COPYTREE_PARAMSA*)pVoid;
    int nCharsInFullFileSpec = ByteCountA (szFullFileSpecIn);
    INT rc;

    // Set return code
    if (COPYTREE_IGNORE_ERRORS & pCopyParams->flags)
        rc = CALLBACK_CONTINUE;
    else
        rc = CALLBACK_FAILED;

    // Build output path
    if (pCopyParams->szEnumRootOutWack)
    {
        StringCopyA(pCopyParams->szFullFileSpecOut, pCopyParams->szEnumRootOutWack);
        StringCatA (pCopyParams->szFullFileSpecOut, szFullFileSpecIn + pCopyParams->nCharsInRootInWack);
    }

    //
    // If a callback was supplied, give it a chance to veto the copy.  This callback is
    // different from the one given to an EnumerateTree function, since the latter can
    // terminate enumeration by returning FALSE.
    //
    if (pCopyParams->pfnCallback)
    {
        if (!pCopyParams->pfnCallback(
                szFullFileSpecIn,
                pCopyParams->szFullFileSpecOut,
                pFindData,
                dwEnumHandle,
                pVoid,
                CurrentDirData
                ))
        {
            return CALLBACK_CONTINUE;
        }
    }

    // Copy, move or delete the file if requested
    if ((COPYTREE_DOCOPY & pCopyParams->flags) ||
        (COPYTREE_DOMOVE & pCopyParams->flags))
    {
        BOOL fNoOverwrite = (0 != (COPYTREE_NOOVERWRITE & pCopyParams->flags));

        //
        // Create the directory. The function we call expects a full filename,
        // and considers the directory to end at the last wack. If this object
        // is a directory, we need to add at least a wack to make sure the last
        // path element is treated as part of the directory, not as a filename.
        //
        {
            CHAR strTemp[MAX_MBCHAR_PATH];
            StringCopyA(strTemp, pCopyParams->szFullFileSpecOut);
            if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                AppendUncWackA(strTemp);
            }

            if (ERROR_SUCCESS != MakeSurePathExistsA(strTemp,FALSE))
            {
                return rc;
            }
        }


        //
        // Copy or move the file
        //
        if (0 == (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (COPYTREE_DOCOPY & pCopyParams->flags)
            {
                if (!CopyFileA(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut,
                    fNoOverwrite
                    ))
                {
                    if (!fNoOverwrite)
                    {
                        return rc;
                    }
                    if (ERROR_FILE_EXISTS != GetLastError())
                    {
                        return rc;
                    }
                }
            }
            else if (COPYTREE_DOMOVE & pCopyParams->flags)
            {
                // If allowed to overwrite, delete the target if it exists
                if (!fNoOverwrite && DoesFileExistA(pCopyParams->szFullFileSpecOut))
                {
                    SetFileAttributesA (pCopyParams->szFullFileSpecOut, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileA(pCopyParams->szFullFileSpecOut))
                    {
                        return rc;
                    }
                }
                // Move the file
                if (!MoveFileA(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut
                    ))
                {
                    return rc;
                }
            }
        }
        //
        // Copy the source file-or-directory's attributes to the target
        //
        SetFileAttributesA(pCopyParams->szFullFileSpecOut,
                pFindData->dwFileAttributes);
    }
    else if (COPYTREE_DODELETE & pCopyParams->flags) {
        SetFileAttributesA (szFullFileSpecIn, FILE_ATTRIBUTE_NORMAL);
        if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            RemoveDirectoryA (szFullFileSpecIn);
        }
        else {
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            DeleteFileA (szFullFileSpecIn);
        }
    }

    return CALLBACK_CONTINUE;
}



BOOL
CALLBACK
CopyFileCallbackW(
                  LPCWSTR szFullFileSpecIn,
                  LPCWSTR DontCare,
                  WIN32_FIND_DATAW *pFindData,
                  DWORD dwEnumHandle,
                  LPVOID pVoid,
                  PDWORD CurrentDirData
                  )
{
    COPYTREE_PARAMSW *pCopyParams = (COPYTREE_PARAMSW*)pVoid;
    int nCharsInFullFileSpec = wcslen (szFullFileSpecIn);
    INT rc;

    // Set return code
    if (COPYTREE_IGNORE_ERRORS & pCopyParams->flags)
        rc = CALLBACK_CONTINUE;
    else
        rc = CALLBACK_FAILED;

    // Build output path
    if (pCopyParams->szEnumRootOutWack)
    {
        StringCopyW (pCopyParams->szFullFileSpecOut, pCopyParams->szEnumRootOutWack);
        StringCatW (pCopyParams->szFullFileSpecOut, szFullFileSpecIn + pCopyParams->nCharsInRootInWack);
    }

    //
    // If a callback was supplied, give it a chance to veto the copy.  This callback is
    // different from the one given to an EnumerateTree function, since the latter can
    // terminate enumeration by returning FALSE.
    //
    if (pCopyParams->pfnCallback)
    {
        if (!pCopyParams->pfnCallback(
                szFullFileSpecIn,
                pCopyParams->szFullFileSpecOut,
                pFindData,
                dwEnumHandle,
                pVoid,
                CurrentDirData
                ))
        {
            return CALLBACK_CONTINUE;
        }
    }

    // Copy or move the file if requested
    if ((COPYTREE_DOCOPY & pCopyParams->flags) ||
        (COPYTREE_DOMOVE & pCopyParams->flags))
    {
        BOOL fNoOverwrite = (0 != (COPYTREE_NOOVERWRITE & pCopyParams->flags));

        //
        // Create the directory. The function we call expects a full filename,
        // and considers the directory to end at the last wack. If this object
        // is a directory, we need to add at least a wack to make sure the last
        // path element is treated as part of the directory, not as a filename.
        //
        {
            WCHAR strTemp[MAX_WCHAR_PATH];
            StringCopyW(strTemp, pCopyParams->szFullFileSpecOut);
            if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                AppendUncWackW(strTemp);
            }

            if (ERROR_SUCCESS != MakeSurePathExistsW(strTemp,FALSE))
            {
                return rc;
            }
        }

        //
        // Copy or move the file
        //
        if (0 == (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (COPYTREE_DOCOPY & pCopyParams->flags)
            {
                DEBUGMSG ((DBG_NAUSEA, "Copying %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                if (!CopyFileW(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut,
                    fNoOverwrite
                    ))
                {
                    if (!fNoOverwrite)
                    {
                        LOG ((LOG_ERROR, "CopyFileW failed.  Could not copy %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                        return rc;
                    }

                    if (ERROR_FILE_EXISTS != GetLastError())
                    {
                        LOG ((LOG_ERROR, "CopyFileW failed.  Could not copy %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                        return rc;
                    }
                }
            }
            else if (COPYTREE_DOMOVE & pCopyParams->flags)
            {
                // If allowed to overwrite, delete the target if it exists
                if (!fNoOverwrite && DoesFileExistW(pCopyParams->szFullFileSpecOut))
                {
                    SetFileAttributesW (pCopyParams->szFullFileSpecOut, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileW(pCopyParams->szFullFileSpecOut))
                    {
                        LOG ((LOG_ERROR, "DeleteFileW failed.  Could remove %s before moving", pCopyParams->szFullFileSpecOut));
                        return rc;
                    }
                }
                // Move the file
                if (!MoveFileW(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut
                    ))
                {
                    LOG ((LOG_ERROR, "MoveFileW failed.  Could not move %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                    return rc;
                }
            }
        }
        //
        // Copy the source file-or-directory's attributes to the target
        //
        SetFileAttributesW(pCopyParams->szFullFileSpecOut,
                pFindData->dwFileAttributes);
    }
    else if (COPYTREE_DODELETE & pCopyParams->flags) {
        SetFileAttributesW (szFullFileSpecIn, FILE_ATTRIBUTE_NORMAL);
        if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DEBUGMSG ((DBG_NAUSEA, "Delete dir %ls", szFullFileSpecIn));
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            RemoveDirectoryW (szFullFileSpecIn);
        }
        else {
            DEBUGMSG ((DBG_NAUSEA, "Delete file %ls", szFullFileSpecIn));
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            DeleteFileW (szFullFileSpecIn);
        }
    }

    return CALLBACK_CONTINUE;
}



BOOL
CopyTreeA(
    IN  LPCSTR szEnumRootIn,
    IN  LPCSTR szEnumRootOut,
    IN  DWORD dwEnumHandle,
    IN  DWORD flags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFA ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCA pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCA pfnFailCallback OPTIONAL
    )

/*
    This function enumerates a subtree of a disk drive, and optionally
    copies it to another location. No check is made to ensure the target
    is not contained within the source tree -- this condition could lead
    to unpredictable results.

    The parameters are a superset of those for EnumerateTree.  The caller-
    supplied optional callback function can veto the copying of individual
    files, but cannot (as of 9/10) end the enumeration.

    Directories will be created as necessary to complete the copy.
*/

{
    COPYTREE_PARAMSA copyParams;
    CHAR szEnumRootInWack[MAX_MBCHAR_PATH];
    CHAR szEnumRootOutWack[MAX_MBCHAR_PATH];

    //
    // Build wacked copies of paths for use in parameter block.
    //

    //
    // Input path
    //
    StringCopyA(szEnumRootInWack, szEnumRootIn);
    AppendUncWackA(szEnumRootInWack);
    copyParams.szEnumRootInWack = szEnumRootInWack;
    copyParams.nCharsInRootInWack = ByteCountA(szEnumRootInWack);

    //
    // If output path is NULL, store 0 length and a NULL ptr in param block.
    //
    if (NULL != szEnumRootOut)
    {
        StringCopyA(szEnumRootOutWack, szEnumRootOut);
        AppendUncWackA(szEnumRootOutWack);
        copyParams.szEnumRootOutWack = szEnumRootOutWack;
        copyParams.nCharsInRootOutWack = ByteCountA(szEnumRootOutWack);
    }
    else
    {
        copyParams.szEnumRootOutWack = NULL;
        copyParams.nCharsInRootOutWack = 0;
    }

    copyParams.pfnCallback = pfnCallback;
    copyParams.flags = flags;

    if ((flags & COPYTREE_DOCOPY) &&
        (flags & COPYTREE_DOMOVE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (flags & COPYTREE_DODELETE) {
        AttributeFilter |= FILTER_DIRS_LAST;
    }

    return EnumerateTreeA(
        szEnumRootInWack,
        CopyFileCallbackA,
        pfnFailCallback,
        dwEnumHandle,
        (LPVOID)&copyParams,
        Levels,
        ExcludeInfStruct,
        AttributeFilter);
}

BOOL
CopyTreeW(
    IN  LPCWSTR szEnumRootIn,
    IN  LPCWSTR szEnumRootOut,
    IN  DWORD dwEnumHandle,
    IN  DWORD flags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFW ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCW pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCW pfnFailCallback OPTIONAL
    )

{
    COPYTREE_PARAMSW copyParams;
    WCHAR szEnumRootInWack[MAX_WCHAR_PATH];
    WCHAR szEnumRootOutWack[MAX_WCHAR_PATH];

    //
    // Place wacked copies of paths in parameter block.
    //

    //
    // Input Path
    //
    StringCopyW(szEnumRootInWack, szEnumRootIn);
    AppendUncWackW(szEnumRootInWack);
    copyParams.szEnumRootInWack = szEnumRootInWack;
    copyParams.nCharsInRootInWack = wcslen(szEnumRootInWack);

    //
    // If output path is NULL, put 0 length and NULL ptr in param block.
    //
    if (NULL != szEnumRootOut)
    {
        StringCopyW(szEnumRootOutWack, szEnumRootOut);
        AppendUncWackW(szEnumRootOutWack);
        copyParams.szEnumRootOutWack = szEnumRootOutWack;
        copyParams.nCharsInRootOutWack = wcslen(szEnumRootOutWack);
    }
    else
    {
        copyParams.szEnumRootOutWack = NULL;
        copyParams.nCharsInRootOutWack = 0;
    }

    copyParams.pfnCallback = pfnCallback;
    copyParams.flags = flags;

    if ((flags & COPYTREE_DOCOPY) &&
        (flags & COPYTREE_DOMOVE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (flags & COPYTREE_DODELETE) {
        AttributeFilter |= FILTER_DIRS_LAST;
    }

    return EnumerateTreeW(
        szEnumRootInWack,
        CopyFileCallbackW,
        pfnFailCallback,
        dwEnumHandle,
        (LPVOID)&copyParams,
        Levels,
        ExcludeInfStruct,
        AttributeFilter);
}


DWORD
CreateEmptyDirectoryA (
    PCSTR Dir
    )
{
    DWORD rc;

    if (!DeleteDirectoryContentsA (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND)
            return rc;
    }

    if (!RemoveDirectoryA (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND) {
            return rc;
        }
    }

    return MakeSurePathExistsA (Dir, TRUE);
}


DWORD
CreateEmptyDirectoryW (
    PCWSTR Dir
    )
{
    DWORD rc;

    if (!DeleteDirectoryContentsW (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND)
            return rc;
    }

    if (!RemoveDirectoryW (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND) {
            return rc;
        }
    }

    return MakeSurePathExistsW (Dir, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\undostub\interface.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    interface.c

Abstract:

    Implements the APIs exposed by osuninst.dll. This version is a no-op stub used
    to allow non-X86 components to use the API.

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <undo.h>

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )

{
    return TRUE;
}

UNINSTALLSTATUS
IsUninstallImageValid (
    UNINSTALLTESTCOMPONENT DontCare,
    OSVERSIONINFOEX *BackedUpOsVersion          OPTIONAL
    )
{
    return Uninstall_Unsupported;
}


BOOL
RemoveUninstallImage (
    VOID
    )
{
    return TRUE;
}


BOOL
ExecuteUninstall (
    VOID
    )
{
    return FALSE;
}


ULONGLONG
GetUninstallImageSize (
    VOID
    )
{
    return 0;
}

BOOL
ProvideUiAlerts (
    IN      HWND UiParent
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\fileenum\fileenum.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    fileenum.c

Abstract:

    The code in this source file traverses a drive tree and calls
    an external callback function for each file.  An INF can be
    provided to exclude files and/or directories from enumeration.

Author:

    Jim Schmidt (jimschm) 16-Aug-1996

Revision History:

    Marc R. Whitten (marcw) 11-Sep-1997 Tweaked exclusion handling code, removed
                                        obsolete code.

    Mike Condra (mikeco)  02-Jun-1996   Add fns to tap into file/path exclusion

    Jim Schmidt (jimschm) 20-Dec-1996   Added callback levels and made single
                                        source file for both A and W versions
    Jim Schmidt (jimschm) 27-Nov-1996   Added level and filter to EnumTree



--*/

#ifndef UNICODE
#define UNICODE
#endif

#include "no_pch.h"

#include "..\..\inc\fileenum.h"

typedef struct {
    FILEENUMPROCW     fnEnumCallback;
    FILEENUMFAILPROCW fnFailCallback;
    DWORD             EnumID;
    LPVOID            pParam;
    DWORD             Levels;
    DWORD             CurrentLevel;
    DWORD             AttributeFilter;
} ENUMSTRUCTW, *PENUMSTRUCTW;

BOOL EnumTreeEngineW (LPCWSTR CurrentPath, PENUMSTRUCTW pes);
BOOL IsPathExcludedW (DWORD EnumID, LPCWSTR Path);
BOOL IsFileExcludedW (DWORD EnumID, LPCWSTR File, BYTE byBitmask[]);
BOOL BuildExclusionsFromInfW (DWORD EnumID, PEXCLUDEINFW ExcludeInfStruct);
void CreateBitmaskW (DWORD EnumID, LPCWSTR FindPattern, BYTE byBitmask[]);



BOOL
WINAPI
FileEnum_Entry (
        IN HINSTANCE hinstDLL,
        IN DWORD dwReason,
        IN LPVOID lpv)

/*++

Routine Description:

  FileEnum_Entry is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.  For this LIB, it
  does nothing.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        break;


    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


/*++

Routine Description:

    GenerateEnumID maintains a static that is used to generate unique
    enumeration handles for callers.  The enumeration handle is guaranteed to
    be unique for the first 2^32 calls.

Arguments:

    none

Return Value:

    A DWORD enumeration handle that may be used to identify an exclusion
    list.

--*/

DWORD
GenerateEnumID (
    void
    )
{
    static DWORD s_EnumID = 0;

    return ++s_EnumID;
}


//
// Build W versions of fileenum APIs
//

#define FILEENUMPROCT               FILEENUMPROCW
#define FILEENUMFAILPROCT           FILEENUMFAILPROCW
#define PEXCLUDEINFT                PEXCLUDEINFW
#define ENUMSTRUCTT                 ENUMSTRUCTW
#define PENUMSTRUCTT                PENUMSTRUCTW
#define EnumerateAllDrivesT         EnumerateAllDrivesW
#define EnumerateTreeT              EnumerateTreeW
#define EnumTreeEngineT             EnumTreeEngineW
#define IsPathExcludedT             IsPathExcludedW
#define CreateBitmaskT              CreateBitmaskW
#define IsFileExcludedT             IsFileExcludedW
#define BuildExclusionsFromInfT     BuildExclusionsFromInfW
#define ClearExclusionsT            ClearExclusionsW
#define ExcludeFileT                ExcludeFileW
#define ExcludePathT                ExcludePathW

#include "enumaw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\fileenum\enumaw.c ===
#define MAX_DRIVES  64


BOOL
EnumerateAllDrivesT (
                     IN  FILEENUMPROCT fnEnumCallback,
                     IN  FILEENUMFAILPROCT fnFailCallback,
                     IN  DWORD EnumID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFT ExcludeInfStruct,
                     IN  DWORD AttributeFilter
                     )

/*++

Routine Description:

    EnumerateAllDrives first builds an exclusion list if an exclusion INF path
    is provided, and then enumerates every file on every drive that is not
    excluded.  The callback function is called once per file.  The pParam
    parameter is passed to the callback.

Arguments:

    fnEnumCallback     - A pointer to your callback function
    EnumID         - A caller-defined value used to identify the exclusion list
    pParam             - LPVOID passed to callback function
    ExcludeInfStruct   - Struct containing INF file information for excluding dirs or files
    AttributeFilter    - FILTER_xxx constants

Return Value:

    TRUE if function succeeds.  Call GetLastError for error code if return
    value is FALSE.

--*/

{
    TCHAR   LogicalDrives[MAX_DRIVES];
    DWORD   rc;
    PCTSTR p;
    UINT    driveType;

    rc = GetLogicalDriveStrings (
            MAX_DRIVES,
            LogicalDrives
            );

    if (!rc || rc > MAX_DRIVES) {
        if (rc)
            SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    for (p = LogicalDrives ; *p ; p = GetEndOfString (p) + 1) {

        driveType = GetDriveType(p);
        if (driveType == DRIVE_REMOTE || driveType == DRIVE_CDROM) {
            continue;
        }


        if (!EnumerateTreeT (p,
                             fnEnumCallback,
                             fnFailCallback,
                             EnumID,
                             pParam,
                             ENUM_ALL_LEVELS,
                             ExcludeInfStruct,
                             AttributeFilter
                             ))
            break;
    }

    return (*p == 0);
}




BOOL
EnumerateTreeT (
                IN  PCTSTR EnumRoot,
                IN  FILEENUMPROCT fnEnumCallback,
                IN  FILEENUMFAILPROCT fnFailCallback,   OPTIONAL
                IN  DWORD EnumID,
                IN  LPVOID pParam,
                IN  DWORD Levels,
                IN  PEXCLUDEINFT ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                )

/*++

Routine Description:

    EnumerateTree is similar to EnumerateAllDrives, except it allows you to
    enumerate a specific drive, or a specific subdir on a drive.  Supply the
    drive letter and optional subdirectory in EnumRoot.  Before enumerating,
    EnumerateTree will first build an exclusion list if an exclusion INF path
    is provided.  Then every file below EnumRoot is enumerated, and the
    callback is called once per file, passing pParam unchanged.

Arguments:

    EnumRoot           - Drive and optional path to enumerate
    fnEnumCallback     - A pointer to your callback function
    fnFailCallback     - A pointer to optional fn that logs enumeration errors
    EnumID             - A caller-defined value used to identify the exclusion list
    pParam             - LPVOID passed to callback function
    ExcludeInfStruct   - Struct containing INF file information for excluding dirs or files
    AttributeFilter    - FILTER_xxx constants

Return Value:

    TRUE if function succeeds.  Call GetLastError for error code if return
    value is FALSE.

--*/

{
    ENUMSTRUCTT es;
    BOOL b;

    if (ExcludeInfStruct)
        if (!BuildExclusionsFromInfT (
                EnumID,
                ExcludeInfStruct
            )) {
            DEBUGMSG ((DBG_ERROR, "Error in exclusion file"));
            return FALSE;
        }

    es.fnEnumCallback  = fnEnumCallback;
    es.fnFailCallback  = fnFailCallback;
    es.EnumID          = EnumID;
    es.pParam          = pParam;
    es.Levels          = Levels;
    es.CurrentLevel    = 1;
    es.AttributeFilter = AttributeFilter;

    if (!IsPathLengthOk(EnumRoot))
    {
        if (NULL != fnFailCallback)
        {
            fnFailCallback(EnumRoot);
            return TRUE;
        }
    }

    if (IsPathExcludedT (EnumID, EnumRoot))
        return TRUE;

    b = EnumTreeEngineT (EnumRoot, &es);

    return b;
}


BOOL
EnumTreeEngineT (
    PCTSTR CurrentPath,
    PENUMSTRUCTT pes
    )
{
    WIN32_FIND_DATA fd;                         // A find struct for this subdir
    HANDLE          hFind;                      // A find handle for this subdir
    PTSTR          FullFilePath;               // Buffer used to build file path
    static TCHAR    FindPattern[MAX_TCHAR_PATH * 2]; // Temp buffer used to build pattern
    BYTE            byBitmask[MAX_PATH];        // Bitmask is used to speed exclusion lookup
    static DWORD    Attrib;                     // Temp attribute storage for filter processing
    static INT      rc;                         // Callback return value
    DWORD           PrevLevelCt;                // Storage for parent's max depth setting
    BOOL            RecurseStatus;
    DWORD           CurrentDirData = 0;

    //
    // Do nothing when CurrentPath is at the size limit.
    //
    if (!IsPathLengthOk(CurrentPath))
    {
        if (NULL != pes->fnFailCallback)
        {
            pes->fnFailCallback(CurrentPath);
        }
        return TRUE;
    }

    PrevLevelCt = pes->Levels;


    StringCopy (FindPattern, CurrentPath);

    //
    // Create a bitmask that tells us when subdirectories match partial
    // file patterns.
    //

    ZeroMemory (byBitmask, sizeof (byBitmask));
    CreateBitmaskT (pes->EnumID, FindPattern, byBitmask);

    AppendPathWack (FindPattern);
    StringCat (FindPattern, TEXT("*"));
    hFind = FindFirstFile (FindPattern, &fd);

    if (hFind != INVALID_HANDLE_VALUE) {

        do {

            FullFilePath = JoinPaths (CurrentPath, fd.cFileName);

            __try {
                //
                // Ignore this path if FullFilePath is too long
                // this way fd.cFileName will surely be within limits (since it's shorter)
                //
                if (!IsPathLengthOk (FullFilePath)) {
                    if (NULL != pes->fnFailCallback) {
                        pes->fnFailCallback(FullFilePath);
                    }
                    continue;
                }

                // Filter directories named ".", "..". Set Attrib symbol.
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                    if (!StringCompare (fd.cFileName, TEXT(".")) ||
                        !StringCompare (fd.cFileName, TEXT("..")))
                        continue;

                    Attrib = FILTER_DIRECTORIES;
                } else {
                    Attrib = FILTER_FILES;
                }

                // Call the callback
                if (Attrib & pes->AttributeFilter) {
                    rc = CALLBACK_CONTINUE;

                    switch (Attrib) {
                    case FILTER_DIRECTORIES:
                        // Ignore excluded paths
                        if (IsPathExcludedT (pes->EnumID, FullFilePath)) {
                            break;
                        }

                        // Callback for 'directory first'
                        if (!(pes->AttributeFilter & FILTER_DIRS_LAST)) {
                            rc = pes->fnEnumCallback  (
                                        FullFilePath,
                                        NULL,
                                        &fd,
                                        pes->EnumID,
                                        pes->pParam,
                                        &CurrentDirData
                                        );
                        }

                        if (rc >= CALLBACK_CONTINUE && pes->CurrentLevel != pes -> Levels) {
                            // Recurse on directory
                            pes->CurrentLevel++;
                            RecurseStatus = EnumTreeEngineT (FullFilePath, pes);
                            pes->CurrentLevel--;
                            if (!RecurseStatus) {
                                PushError();
                                FindClose(hFind);
                                PopError();
                                return FALSE;
                            }
                        }

                        // Callback for 'directory last'
                        if (pes->AttributeFilter & FILTER_DIRS_LAST) {
                            rc = pes->fnEnumCallback  (
                                        FullFilePath,
                                        NULL,
                                        &fd,
                                        pes->EnumID,
                                        pes->pParam,
                                        &CurrentDirData
                                        );
                        }

                        break;

                    case FILTER_FILES:
                        if (!IsFileExcludedT (pes->EnumID, FullFilePath, byBitmask)) {
                            rc = pes->fnEnumCallback  (FullFilePath,
                                                       NULL,
                                                       &fd,
                                                       pes->EnumID,
                                                       pes->pParam,
                                                       &CurrentDirData
                                                       );
                        }

                        break;
                    }

                    if (rc == CALLBACK_FAILED) {
                        PushError();
                        FindClose (hFind);
                        PopError();
                        return FALSE;
                    }
                    else if (rc == CALLBACK_SUBDIR_DONE) {
                        break;
                    }
                    else if (rc > 0) {
                        pes->Levels = pes->CurrentLevel + rc;
                    }
                }
                else if (Attrib == FILTER_DIRECTORIES && !IsPathExcludedT (pes->EnumID, FullFilePath)) {
                    // Recurse on directory.
                    if (pes->CurrentLevel != pes -> Levels) {

                        pes->CurrentLevel++;
                        RecurseStatus = EnumTreeEngineT (FullFilePath, pes);
                        pes->CurrentLevel--;
                        if (!RecurseStatus) {
                            PushError();
                            FindClose(hFind);
                            PopError();
                            return FALSE;
                        }
                    }
                }
            }
            __finally {
                FreePathString (FullFilePath);
            }
        } while (FindNextFile (hFind, &fd));

        FindClose (hFind);

        //
        // Test error code returned from FindNextFile
        //
        if (GetLastError() != ERROR_NO_MORE_FILES && GetLastError() != ERROR_SUCCESS)
        {
            //
            // Caller to handle not-ready message
            //
            if (GetLastError() != ERROR_NOT_READY)
            {
                DEBUGMSG((DBG_ERROR,
                    "EnumTreeEngineT: Error from FindNextFile.\n"
                    "  FindPattern:       %s\n"
                    "  Error: %u (%x)",
                        FindPattern,
                        GetLastError(),GetLastError()));
            }
            return FALSE;
        }
        SetLastError(ERROR_SUCCESS);
    }
    else {

        //
        // Test return codes from FindFirstFile
        //
        if (GetLastError () != ERROR_NO_MORE_FILES)
        {
            //
            // Caller to handle not-ready message
            //
            if (GetLastError() != ERROR_NOT_READY)
            {
                DEBUGMSG((DBG_WARNING,
                    "EnumTreeEngineT: Warning from FindFirstFile.\n"
                    "  FindPattern: %s\n",
                        FindPattern));
            }
            // return FALSE;
        }
        SetLastError (ERROR_SUCCESS);
    }

    // If a callback returned a positive, non-zero number, the depth
    // of the subdirectory search was limited for this level.  Now that
    // this level is done, we must restore the depth value of our parent.
    pes->Levels = PrevLevelCt;

    return TRUE;
}


/*++

  A bitmask is used in IsFileExcluded for faster relative directory searches.
  Instead of looking in the MemDb for each part of the path, IsFileExcluded
  skips segments that are known not to match.  We create the bitmask here
  by looking up each portion of FindPattern.  Bit 1 is set if the last
  subdirectory exists in the file exclusion list, Bit 2 is set if the last
  two subdirectories exist in the file exclusion list, and so on.

  For example, assume FindPattern is set to C:\DEV\FOO\BAR.  CreateBitmask
  first looks in the memory database for BAR\*, and if it is found bit 1 is set.
  Then CreateBitmask looks in the memory database for FOO\BAR\*, and sets bit
  2.  Again the function looks up DEV\FOO\BAR\* for bit 3 and finally
  C:\DEV\FOO\BAR\* for bit 4.

  Bit 0 is always set (empty paths always match).

  Once this bitmask is set up, IsFileExcluded can test only the patterns that
  are known to exist.

  --*/

void
CreateBitmaskT (
    DWORD EnumID,
    PCTSTR FindPattern,
    BYTE byBitmask[]
    )
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;
    int nByte;
    int nBitVal;

    // Always set bit 0
    byBitmask[0] |= 1;

    // Build full file spec
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES
        );

    End = GetEndOfString (EnumPath);
    StringCopy (End, FindPattern);
    AppendPathWack (End);
    StringCat (End, TEXT("*"));

    // Start with last subdirectory, and build mask in reverse
    p = _tcsrchr (EnumPath, TEXT('\\'));
    nByte = 0;
    nBitVal = 2;
    do  {
        // Move back to previous backslash
        for (p = _tcsdec (EnumPath, p) ;
             p >= End && *p != TEXT('\\') ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Check if partial file is in the tree
        wsprintf (
            ShortPath,
            TEXT("%s\\%X\\%s%s"),
            MEMDB_CATEGORY_FILEENUM,
            EnumID,
            MEMDB_FIELD_FE_FILES,
            p
            );

        if (MemDbGetPatternValueWithPattern (ShortPath, NULL))
            byBitmask[nByte] |= nBitVal;

        // Inc bit pos
        nBitVal *= 2;
        if (nBitVal == 256) {
            nBitVal = 1;
            nByte++;
        }
    } while (p > End);
}


BOOL
IsPathExcludedT (DWORD EnumID, PCTSTR Path)
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;

    // Try full paths
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_PATHS
        );

    End = GetEndOfString (EnumPath);
    p = _tcsappend (End, Path);

    if (MemDbGetPatternValue (EnumPath, NULL)) {

        return TRUE;
    }

    // Try partial paths
    do  {
        // Move back to previous backslash
        for (p = _tcsdec (EnumPath, p) ;
             p > End && (*p != TEXT('\\')) ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Check if partial path is in the tree
        if (p > End && p[1]) {
            wsprintf (
                ShortPath,
                TEXT("%s\\%X\\%s%s"),
                MEMDB_CATEGORY_FILEENUM,
                EnumID,
                MEMDB_FIELD_FE_PATHS,
                p
                );

            if (MemDbGetPatternValue (ShortPath, NULL)) {
                return TRUE;
            }
        }
    } while (p > End);

    return FALSE;
}


BOOL
IsFileExcludedT (DWORD EnumID, PCTSTR File, BYTE byBitmask[])
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;
    int nByte;
    int nBit;

    // Build full file spec
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES
        );

    End = GetEndOfString (EnumPath);
    p = _tcsappend (End, File);

    //
    // Try partial file specs until full spec is reached
    //

    nByte = 0;
    nBit = 1;
    do  {
        //
        // Move back to previous backslash in path
        // (p starts at NULL of EnumPath, End is in the middle of EnumPath)
        //

        for (p = _tcsdec (EnumPath, p) ;
             p >= End && (*p != TEXT('\\')) ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Bitmask is used to make sure slightly expensive query is necessary
        if (byBitmask[nByte] & nBit) {

            //
            // Check if partial file is in the tree
            //

            wsprintf (
                ShortPath,
                TEXT("%s\\%X\\%s%s"),
                MEMDB_CATEGORY_FILEENUM,
                EnumID,
                MEMDB_FIELD_FE_FILES,
                p
                );

            if (MemDbGetPatternValue (ShortPath, NULL)) {

                return TRUE;
            }
        }

        nBit *= 2;
        if (nBit == 256) {
            nBit = 1;
            nByte++;
        }
    } while (p > End);

    return FALSE;
}


//
// ClearExclusions removes all enumaration exclusions.  It is called
// automatically at the end of enumeration when an exclusion INF file is
// used.  Use it when you need to programmatically build an exclusion list
// with ExcludeDrive, ExcludePath, and ExcludeFile.
//
// You can combine programmatic exclusions with an exclusion INF file, but
// beware that the programmatic exclusions will be cleared after
// EnumarteAllDrives or EnumerateTree completes.
//
// If you do not use an INF, the programmatic exclusions will not
// automatically be cleared.
//
// EnumID  - Caller-defined value to identify enumeration exclusion list
//

VOID
ClearExclusionsT (
    DWORD EnumID
    )
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (EnumPath, TEXT("%s\\%X"), MEMDB_CATEGORY_FILEENUM, EnumID);

    MemDbDeleteTree (EnumPath);
}



/*++

Routine Description:

    ExcludePath adds a path name to the exclusion list.  There are two
    cases:

     1. A full path spec is supplied, including the drive letter or
        UNC double-backslash.
     2. The path does not start with a drive letter and is a portion of
        a full path.

    The dot and double-dot directories are not supported.  Any part of
    the path may contain wildcard characters, but a wildcard can not
    be used in place of a backslash.

Arguments:

    EnumID   - A caller-defined value that identifies the exclusion list
    Path         - The path specification as described above

Return Value:

    none

--*/

VOID
ExcludePathT (
              IN  DWORD EnumID,
              IN  PCTSTR Path
              )

{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\%s"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_PATHS,
        Path
        );

    MemDbSetValue (EnumPath, 0);
}


/*++

Routine Description:

    ExcludeFile adds a file spec to the exclusion list.  There are two
    cases:

     1. A full path spec is supplied, including the drive letter or
        UNC double-backslash.
     2. The path does not start with a drive letter and is a portion of
        a full path.

    The dot and double-dot directories are not supported.  Any part of
    the path may contain wildcard characters, but a wildcard can not
    be used in place of a backslash.

Arguments:

    EnumID   - A caller-defined value that identifies the exclusion list
    File         - The file specification as described above

Return Value:

    none

--*/

VOID
ExcludeFileT (
    IN  DWORD EnumID,
    IN  PCTSTR File
    )

{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\%s"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES,
        File
        );

    MemDbSetValue (EnumPath, 0);
}



BOOL
BuildExclusionsFromInfT (DWORD EnumID,
                         PEXCLUDEINFT ExcludeInfStruct)
{
    HINF hInf;
    INFCONTEXT ic;
    TCHAR Exclude[MAX_TCHAR_PATH * 2];

    // Attempt to open
    hInf = SetupOpenInfFile (ExcludeInfStruct->ExclusionInfPath, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
        return FALSE;

    // Read in path exclusions
    if (ExcludeInfStruct->PathSection) {
        if (SetupFindFirstLine (hInf, ExcludeInfStruct->PathSection, NULL, &ic)) {
            do  {
                if (SetupGetStringField (&ic, 1, Exclude, MAX_TCHAR_PATH, NULL)) {
                    ExcludePathT (EnumID, Exclude);
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
    }

    // Read in file exclusions
    if (ExcludeInfStruct->FileSection) {
        if (SetupFindFirstLine (hInf, ExcludeInfStruct->FileSection, NULL, &ic)) {
            do  {
                if (SetupGetStringField (&ic, 1, Exclude, MAX_TCHAR_PATH, NULL)) {
                    ExcludeFileT (EnumID, Exclude);
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
    }

    // Clean up
    SetupCloseInfFile (hInf);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\fileenum\no_pch.h ===
#define STRICT

#include "chartype.h"

//
// System includes
//

#include <windows.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <setupapi.h>

//
// Project includes
//
#include "migutil.h"
#include "memdb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\tools\lockmem\lockmem.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    lockmem.cpp

Abstract:

    This utility locks the memory of all the modules currently 
    mapped in the process address space.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com) 26'July'2001

Revision History:

--*/


#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <psapi.h>

using namespace std;

//
// class abstracting the process with module
// details
//
class Process {
public:
    //
    // constructor
    //
    Process(ULONG Pid = 0) {
        //
        // enable the required privileges
        //
        if (!PrivilegeEnabled) {
            EnableRequiredPrivileges();
            PrivilegeEnabled = TRUE;
        }

        if (Pid) {
            ProcessID = Pid;
        } else {
            ProcessID = GetCurrentProcessId();
        }            

        SelfProcess = (ProcessID == GetCurrentProcessId());
        
        hProcess = 0;
        ::ZeroMemory(&hLoadedModules, sizeof(hLoadedModules));
        
        //
        // Open the process
        //
        hProcess = ::OpenProcess(PROCESS_ALL_ACCESS,
                                    FALSE, ProcessID);

        if (!hProcess)
            throw new InvalidProcessID(ProcessID, ::GetLastError());

        DWORD   cbNeeded = 0;

        //
        // Get the module details
        //
        if (!::EnumProcessModules(hProcess, hLoadedModules, 
                    sizeof(hLoadedModules), &cbNeeded)) {
            ::CloseHandle(hProcess);
            hProcess = 0;
            
            throw new EnumerationError(::GetLastError());
        }
    }

    //
    // destructor
    //
    ~Process() {
        if (hProcess) {
            ::CloseHandle(hProcess);
        }            
    }    

    DWORD GetTotalWSSize(VOID) const {
        DWORD TotalSize = 0;
        
        for (int Index=0; 
                ((Index < sizeof(hLoadedModules)/sizeof(HMODULE)) && 
                    hLoadedModules[Index]);
                Index++ ) {                
            MODULEINFO  ModuleInformation = {0};

            if (GetModuleInformation(hProcess,
                    hLoadedModules[Index],
                    &ModuleInformation,
                    sizeof(MODULEINFO))) {
                TotalSize += ModuleInformation.SizeOfImage;
            }                        
        }

        return TotalSize;
    }

    DWORD
    GetWSSizeLimits(
        SIZE_T   &MinimumSize,
        SIZE_T   &MaximumSize
        )
    {
        GetProcessWorkingSetSize(hProcess,
            &MinimumSize,
            &MaximumSize);

        return ::GetLastError();            
    }

    DWORD LockMemory(DWORD &LockedMemorySize) {
        DWORD Result = ERROR_SUCCESS;
        DWORD TotalSize = GetTotalWSSize();                                

        LockedMemorySize = 0;

        //
        // just make the WS limit twice the size of the 
        // total module size
        //       
        if (SetProcessWorkingSetSize(hProcess,
                TotalSize * 2,
                TotalSize * 2)) {
            if (SelfProcess) {                    
                for (int Index=0; 
                        ((Index < sizeof(hLoadedModules)/sizeof(HMODULE)) && 
                            hLoadedModules[Index]);
                        Index++ ) {                
                    MODULEINFO  ModuleInformation = {0};

                    if (GetModuleInformation(hProcess,
                            hLoadedModules[Index],
                            &ModuleInformation,
                            sizeof(MODULEINFO))) {
                        if (!IsBadCodePtr((FARPROC)ModuleInformation.lpBaseOfDll)) {
                            if (!VirtualLock(ModuleInformation.lpBaseOfDll,
                                    ModuleInformation.SizeOfImage)) {
                                Result = ::GetLastError();            
                            } else {
                                LockedMemorySize += ModuleInformation.SizeOfImage;
                            }                                
                        } else {
                            Result = ERROR_ACCESS_DENIED;
                        }                        
                    }                        
                }
            }
        } else {
            Result = ::GetLastError();
        }            

        return Result;
    }

    //
    // dump utility
    //
    friend ostream& operator<<(ostream &os, const Process& rhs) {
        char    ModuleName[MAX_PATH] = {0};
        
        os << "Process ID: " << rhs.ProcessID << endl;
        os << "Loaded Modules: " << endl;

        for (   int Index=0; 
                ((Index < sizeof(rhs.hLoadedModules)/sizeof(HMODULE)) && 
                    rhs.hLoadedModules[Index]);
                Index++ ) {                
            if (::GetModuleFileNameExA(rhs.hProcess, rhs.hLoadedModules[Index],
                        ModuleName, sizeof(ModuleName))) {
                MODULEINFO  ModuleInformation = {0};

                if (GetModuleInformation(rhs.hProcess,
                        rhs.hLoadedModules[Index],
                        &ModuleInformation,
                        sizeof(MODULEINFO))) {
                    os << ModuleName << " (" << ModuleInformation.lpBaseOfDll
                       << "," << ModuleInformation.SizeOfImage << ")" << endl;
                } else {                                                            
                    os << ModuleName << endl;                        
                }                    
            }                        
        }

        DWORD   TotalSize = rhs.GetTotalWSSize();
        
        os << "Total Size: " << dec << TotalSize << " Bytes = " 
           << dec << TotalSize / 1024 << " KB = " 
           << dec << TotalSize / (1024 * 1024) << " MB." << endl;

        return os;
    }

protected:
    //
    // data members
    //
    HANDLE  hProcess;
    HMODULE hLoadedModules[1024];
    ULONG   ProcessID;
    BOOLEAN SelfProcess; 
    static BOOLEAN PrivilegeEnabled;

public:
    //
    // exceptions
    //
    struct ProcessException{
        ULONG   ErrCode;
        virtual void dump(ostream &os) = 0;
    };
    
    struct InvalidProcessID : public ProcessException {
        ULONG   ProcessID;
        
        InvalidProcessID(ULONG Pid, ULONG Err) :  ProcessID(Pid){
            ErrCode = Err;
        }

        void dump(ostream &os) {
            os << *this;
        }

        friend ostream& operator<<(ostream& os, const InvalidProcessID& rhs) {
            os << "Invalid Process ID : " << rhs.ProcessID 
               << " Error Code : " << rhs.ErrCode << endl;
            return os;
        }
    };       

    struct EnumerationError : public ProcessException {
        EnumerationError(ULONG Err) {
            ErrCode=Err;
        }

        void dump(ostream &os) {
            os << *this;
        }

        friend ostream& operator<<(ostream& os, const EnumerationError& rhs) {
            os << "Enumeration Error : " << rhs.ErrCode << endl;
            return os;
        }
    };                        

    //
    // gives the process the required privileges
    //
    DWORD
    EnableRequiredPrivileges(
        VOID
        )
    {
        HANDLE Token ;
        UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + 
                    (sizeof( LUID_AND_ATTRIBUTES ) * 3) ]  = {0};
        PTOKEN_PRIVILEGES Privs;
        DWORD Result = ERROR_SUCCESS;

        if (::OpenProcessToken(hProcess,
                          MAXIMUM_ALLOWED,
                          &Token))

        {
            Privs = (PTOKEN_PRIVILEGES) Buf ;
                
            Privs->PrivilegeCount = 3 ;

            LookupPrivilegeValue(NULL, 
                SE_DEBUG_NAME, 
                &(Privs->Privileges[0].Luid));
                
            Privs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

            LookupPrivilegeValue(NULL,
                SE_INC_BASE_PRIORITY_NAME, 
                &(Privs->Privileges[1].Luid));
                
            Privs->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED ;

            LookupPrivilegeValue(NULL,
                SE_LOCK_MEMORY_NAME, 
                &(Privs->Privileges[2].Luid));
            Privs->Privileges[2].Attributes = SE_PRIVILEGE_ENABLED ;

            ::AdjustTokenPrivileges(Token,
                                   FALSE,
                                   Privs,
                                   NULL,
                                   NULL,
                                   NULL);

            Result = ::GetLastError();                                   

            ::CloseHandle(Token);
        } else {
            Result = ::GetLastError();                                   
        }

        return Result;
    }
};


struct UsageException{};

//
// static data member
//
BOOLEAN Process::PrivilegeEnabled = FALSE;

DWORD
LockModules(
    VOID
    )
{
    Process SelfProcess;
    DWORD LockedMemorySize = 0;

    return SelfProcess.LockMemory(LockedMemorySize);
}


#ifdef _CONOSOLE_VERSION

//
// global data
//
const string Usage = "Usage: lm.exe [process-to-execute]\n";
const int    MinimumArgs = 2;
const string ShowHelp1 = "/?";
const string ShowHelp2 = "-h";
const string SelfProcess = "-self";


/*
/* main() entry point
*/
int
__cdecl
main( 
    int Argc, 
    char *Argv[] 
    )
{
    int     Result = 0;

    try {
        if (Argc == MinimumArgs) {
            char        *EndPtr = 0;
            string      Arg1(Argv[1]);

            //
            // verify arguments
            //
            if (Arg1 == ShowHelp1 || Arg1 == ShowHelp2)
                throw UsageException();

            DWORD LastError = ERROR_SUCCESS;
            SIZE_T Min = 0, Max = 0;
            DWORD LockedMemorySize = 0;
            DWORD WSSize = 0;
                            
            if (Arg1 != SelfProcess) {
                PROCESS_INFORMATION ProcessInfo = {0};
                STARTUPINFOA StartupInfo = {0};
                char    ExecutableName[MAX_PATH];
                
                strcpy(ExecutableName, Arg1.c_str());
                
                BOOL CreateResult = CreateProcessA(NULL,
                                        ExecutableName,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL,
                                        &StartupInfo,
                                        &ProcessInfo);

                if (CreateResult) {
                    cout << "Waiting for : " << ExecutableName 
                         << "..." << endl;
                         
                    WaitForSingleObject(ProcessInfo.hProcess,
                        2000);

                    Process ExecedProcess(ProcessInfo.dwProcessId);

                    cout << ExecedProcess << endl;

                    ExecedProcess.GetWSSizeLimits(Min, Max);

                    cout << "Existing WS Limits : " << dec << Min 
                        << ", " << Max << endl;

                    LastError = ExecedProcess.LockMemory(LockedMemorySize);

                    ExecedProcess.GetWSSizeLimits(Min, Max);

                    cout << "New WS Limits : " << dec << Min 
                         << ", " << Max << endl;
                         
                    cout << "Locked " << dec << LockedMemorySize << " / "
                         << ExecedProcess.GetTotalWSSize() << " Bytes" << endl;
                } else {
                    LastError = GetLastError();
                }       
            } else {
                Process SelfProcess;
                
                cout << SelfProcess << endl;
                
                SelfProcess.GetWSSizeLimits(Min, Max);
                cout << "Existing WS Limits : " << dec << Min 
                    << ", " << Max << endl;

                LastError = SelfProcess.LockMemory(LockedMemorySize);

                SelfProcess.GetWSSizeLimits(Min, Max);
                cout << "New WS Limits : " << dec << Min 
                    << ", " << Max << endl;

                cout << "Locked " << dec << LockedMemorySize << " / "
                     << SelfProcess.GetTotalWSSize() << " Bytes" << endl;
            }                                

            if (ERROR_SUCCESS != LastError) {
                cout << "Error : " << dec << LastError << endl;
            }                
        } else {
            cerr << Usage;
            Result = 1;
        }
    } catch(Process::ProcessException *pExp) {
        pExp->dump(cerr);
        delete pExp;
    } catch (...) {
        cerr << Usage;
        Result = 1;
    }

    return Result;
}

#endif // _CONSOLE_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\bintree.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bintree.c

Abstract:

    Routines that manage the memdb binary tree structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     30-Dec-1998  Hacked in AVL balancing
    jimschm     23-Sep-1998  Proxy nodes, so MemDbMoveTree can replace end nodes too
    jimschm     29-May-1998  Ability to replace center nodes in key strings
    jimschm     21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif

#define MAX_MEMDB_SIZE  0x08000000  //128 MB
#define KSF_FLAGS_TO_COPY       (KSF_USERFLAG_MASK|KSF_ENDPOINT|KSF_BINARY|KSF_PROXY_NODE)

DWORD
pNewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive,
    IN  BOOL Endpoint
    );

DWORD
pAllocKeyToken (
    IN      PCWSTR KeyName,
    OUT     PINT AdjustFactor
    );

VOID
pDeallocToken (
    IN      DWORD Token
    );

DWORD
pFindPatternKeyWorker (
    IN      PCWSTR SubKey,
    IN      PCWSTR End,
    IN      DWORD RootOffset,
    IN      BOOL EndPatternAllowed
    );

#ifdef DEBUG
VOID
pDumpTree (
    IN      DWORD Root,
    IN      PCSTR Title         OPTIONAL
    );

VOID
pCheckBalanceFactors (
    IN      DWORD Root
    );

DWORD g_SingleRotations = 0;
DWORD g_DoubleRotations = 0;
DWORD g_Deletions = 0;
DWORD g_Insertions = 0;

#define INCSTAT(x)      (x++)

#else

#define pDumpTree(arg1,arg2)
#define INCSTAT(x)

#endif


#define ANTIDIRECTION(x)        ((x)^KSF_BALANCE_MASK)
#define FLAGS_TO_INT(x)         ((INT) ((x)==KSF_LEFT_HEAVY ? -1 : (x)==KSF_RIGHT_HEAVY ? 1 : 0))
#define INT_TO_FLAGS(x)         ((DWORD) ((x)==-1 ? KSF_LEFT_HEAVY : (x)==1 ? KSF_RIGHT_HEAVY : 0))

//
// Implementation
//


DWORD
pRotateOnce (
    OUT     PDWORD RootPtr,
    IN      DWORD ParentOffset,
    IN      DWORD PivotOffset,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT GrandParent;
    PKEYSTRUCT Parent;
    PKEYSTRUCT Pivot;
    PKEYSTRUCT TempKey;
    DWORD Temp;
    INT OldRootBalance;
    INT NewRootBalance;
    DWORD OldDir, NewDir;

    INCSTAT(g_SingleRotations);

    MYASSERT (ParentOffset != INVALID_OFFSET);
    MYASSERT (PivotOffset != INVALID_OFFSET);

    Parent = GetKeyStruct (ParentOffset);
    Pivot = GetKeyStruct (PivotOffset);

    if (Direction == KSF_LEFT_HEAVY) {
        //
        // Perform LL rotation
        //

        Temp = Pivot->Right;

        Pivot->Right = ParentOffset;
        Pivot->Parent = Parent->Parent;
        Parent->Parent = PivotOffset;

        Parent->Left = Temp;

    } else {
        //
        // Preform RR rotation
        //

        Temp = Pivot->Left;

        Pivot->Left = ParentOffset;
        Pivot->Parent = Parent->Parent;
        Parent->Parent = PivotOffset;

        Parent->Right = Temp;
    }

    if (Temp != INVALID_OFFSET) {

        TempKey = GetKeyStruct (Temp);
        TempKey->Parent = ParentOffset;

    }

    OldDir = Parent->Flags & KSF_BALANCE_MASK;
    NewDir = Pivot->Flags & KSF_BALANCE_MASK;

    OldRootBalance  = FLAGS_TO_INT (OldDir);
    NewRootBalance  = FLAGS_TO_INT (NewDir);

    if (Direction == KSF_LEFT_HEAVY) {
        OldRootBalance = -(++NewRootBalance);
    } else {
        OldRootBalance = -(--NewRootBalance);
    }

    Pivot->Flags = (Pivot->Flags & (~KSF_BALANCE_MASK)) | INT_TO_FLAGS(NewRootBalance);
    Parent->Flags = (Parent->Flags & (~KSF_BALANCE_MASK)) | INT_TO_FLAGS(OldRootBalance);

    //
    // Fix grandparent/root to parent linkage
    //

    if (Pivot->Parent != INVALID_OFFSET) {
        GrandParent = GetKeyStruct (Pivot->Parent);

        if (GrandParent->Left == ParentOffset) {
            GrandParent->Left = PivotOffset;
        } else {
            GrandParent->Right = PivotOffset;
        }

    } else {
        *RootPtr = PivotOffset;
    }

    return PivotOffset;
}


DWORD
pRotateTwice (
    OUT     PDWORD RootPtr,
    IN      DWORD ParentOffset,
    IN      DWORD PivotOffset,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT GrandParent;
    PKEYSTRUCT Parent;
    PKEYSTRUCT Pivot;
    PKEYSTRUCT Child;
    DWORD ChildOffset;
    PKEYSTRUCT GrandChildLeft;
    PKEYSTRUCT GrandChildRight;
    DWORD AntiDirection;
    DWORD Flag;
    INT ParentDir;
    INT PivotDir;
    INT ChildDir;

    INCSTAT(g_DoubleRotations);

    //
    // Initialize pointers
    //

    MYASSERT (ParentOffset != INVALID_OFFSET);
    MYASSERT (PivotOffset != INVALID_OFFSET);

    Parent = GetKeyStruct (ParentOffset);
    Pivot = GetKeyStruct (PivotOffset);

    if (Direction == KSF_LEFT_HEAVY) {
        AntiDirection = KSF_RIGHT_HEAVY;
        ChildOffset = Pivot->Right;
    } else {
        AntiDirection = KSF_LEFT_HEAVY;
        ChildOffset = Pivot->Left;
    }

    MYASSERT (ChildOffset != INVALID_OFFSET);
    Child = GetKeyStruct (ChildOffset);

    if (Child->Left != INVALID_OFFSET) {
        GrandChildLeft = GetKeyStruct (Child->Left);
    } else {
        GrandChildLeft = NULL;
    }

    if (Child->Right != INVALID_OFFSET) {
        GrandChildRight = GetKeyStruct (Child->Right);
    } else {
        GrandChildRight = NULL;
    }

    //
    // Perform the rotation
    //

    if (Direction == KSF_LEFT_HEAVY) {
        //
        // Perform LR rotation
        //

        Child->Parent = Parent->Parent;

        Parent->Left = Child->Right;
        if (GrandChildRight) {
            GrandChildRight->Parent = ParentOffset;
        }

        Pivot->Right = Child->Left;
        if (GrandChildLeft) {
            GrandChildLeft->Parent = PivotOffset;
        }

        Child->Left = PivotOffset;
        Pivot->Parent = ChildOffset;

        Child->Right = ParentOffset;
        Parent->Parent = ChildOffset;

    } else {
        //
        // Preform RL rotation
        //

        Child->Parent = Parent->Parent;

        Parent->Right = Child->Left;
        if (GrandChildLeft) {
            GrandChildLeft->Parent = ParentOffset;
        }

        Pivot->Left = Child->Right;
        if (GrandChildRight) {
            GrandChildRight->Parent = PivotOffset;
        }

        Child->Right = PivotOffset;
        Pivot->Parent = ChildOffset;

        Child->Left = ParentOffset;
        Parent->Parent = ChildOffset;


    }

    //
    // Fix balance factors
    //

    Flag = Child->Flags & KSF_BALANCE_MASK;
    ChildDir = FLAGS_TO_INT (Flag);

    if (Direction == KSF_RIGHT_HEAVY) {
        ParentDir = -max (ChildDir, 0);
        PivotDir  = -min (ChildDir, 0);
    } else {
        ParentDir = -min (ChildDir, 0);
        PivotDir  = -max (ChildDir, 0);
    }

    Parent->Flags = Parent->Flags & (~KSF_BALANCE_MASK) | INT_TO_FLAGS(ParentDir);
    Pivot->Flags  = Pivot->Flags & (~KSF_BALANCE_MASK) | INT_TO_FLAGS(PivotDir);
    Child->Flags  = Child->Flags & (~KSF_BALANCE_MASK);

    //
    // Fix grandparent/root to parent linkage
    //

    if (Child->Parent != INVALID_OFFSET) {
        GrandParent = GetKeyStruct (Child->Parent);

        if (GrandParent->Left == ParentOffset) {
            GrandParent->Left = ChildOffset;
        } else {
            GrandParent->Right = ChildOffset;
        }

    } else {
        *RootPtr = ChildOffset;
    }

    return ChildOffset;
}


VOID
pBalanceInsertion (
    OUT     PDWORD RootPtr,
    IN      DWORD ChangedNode,
    IN      DWORD PivotEnd
    )
{
    DWORD PrevPivot;
    DWORD PivotNode;
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD BalanceFlags;

    PivotNode = ChangedNode;
    MYASSERT (PivotNode != INVALID_OFFSET);

    //
    // Initialize previous pivot to be the changed node,
    // and begin balancing at its parent
    //

    PrevPivot = PivotNode;
    KeyStruct = GetKeyStruct (PivotNode);
    PivotNode = KeyStruct->Parent;

    //
    // Balance the tree starting at the changed node and going
    // up until PivotEnd is reached.  PivotEnd is the offset to
    // the deepest node with a balance of non-zero.
    //

    MYASSERT (PivotNode != INVALID_OFFSET || PivotNode == PivotEnd);

    while (PivotNode != INVALID_OFFSET) {

        KeyParent = GetKeyStruct (PivotNode);

        BalanceFlags = KeyParent->Flags & KSF_BALANCE_MASK;

        if (BalanceFlags == KSF_LEFT_HEAVY) {

            if (KeyParent->Left == PrevPivot) {

                MYASSERT (KeyStruct == GetKeyStruct (PrevPivot));

                if (KeyStruct->Flags & KSF_LEFT_HEAVY) {
                    //
                    // LL rotation
                    //

                    pRotateOnce (RootPtr, PivotNode, PrevPivot, KSF_LEFT_HEAVY);

                } else if (KeyStruct->Flags & KSF_RIGHT_HEAVY) {
                    //
                    // LR rotation
                    //

                    pRotateTwice (RootPtr, PivotNode, PrevPivot, KSF_LEFT_HEAVY);

                }

            } else {
                KeyParent->Flags = KeyParent->Flags & (~KSF_BALANCE_MASK);
            }

        } else if (BalanceFlags == KSF_RIGHT_HEAVY) {

            if (KeyParent->Right == PrevPivot) {

                MYASSERT (KeyStruct == GetKeyStruct (PrevPivot));

                if (KeyStruct->Flags & KSF_RIGHT_HEAVY) {
                    //
                    // RR rotation
                    //

                    pRotateOnce (RootPtr, PivotNode, PrevPivot, KSF_RIGHT_HEAVY);

                } else if (KeyStruct->Flags & KSF_LEFT_HEAVY) {
                    //
                    // RL rotation
                    //

                    pRotateTwice (RootPtr, PivotNode, PrevPivot, KSF_RIGHT_HEAVY);

                }

            } else {
                KeyParent->Flags = KeyParent->Flags & (~KSF_BALANCE_MASK);
            }

        } else {
            if (KeyParent->Right == PrevPivot) {
                KeyParent->Flags = (KeyParent->Flags & (~KSF_BALANCE_MASK)) | KSF_RIGHT_HEAVY;
            } else {
                KeyParent->Flags = (KeyParent->Flags & (~KSF_BALANCE_MASK)) | KSF_LEFT_HEAVY;
            }
        }

        if (PivotNode == PivotEnd) {
            break;
        }

        PrevPivot = PivotNode;
        PivotNode = KeyParent->Parent;
        KeyStruct = KeyParent;
    }
}


VOID
pBalanceDeletion (
    OUT     PDWORD RootPtr,
    IN      DWORD NodeNeedingAdjustment,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT ChildStruct;
    DWORD ChildOffset;
    DWORD Node;
    DWORD AntiDirection;
    DWORD OldNode;
    DWORD OrgParent;

    Node = NodeNeedingAdjustment;
    MYASSERT (Node != INVALID_OFFSET);

    KeyStruct = GetKeyStruct (Node);

    for (;;) {

        MYASSERT (KeyStruct == GetKeyStruct (Node));
        AntiDirection = ANTIDIRECTION (Direction);
        OrgParent = KeyStruct->Parent;

        //
        // Case 1 - parent was initially balanced (terminates balancing)
        //

        if (!(KeyStruct->Flags & KSF_BALANCE_MASK)) {
            KeyStruct->Flags |= AntiDirection;
            break;
        }

        //
        // Case 2 - parent was heavy on side that was deleted
        //

        if (KeyStruct->Flags & Direction) {
            KeyStruct->Flags = KeyStruct->Flags & (~KSF_BALANCE_MASK);
        }

        //
        // Cases 3, 4 and 5 - deletion caused imbalance in parent
        //

        else {
            MYASSERT (KeyStruct->Flags & AntiDirection);

            ChildOffset = Direction == KSF_LEFT_HEAVY ?
                                KeyStruct->Right :
                                KeyStruct->Left;

            MYASSERT (ChildOffset != INVALID_OFFSET);

            ChildStruct = GetKeyStruct (ChildOffset);

            if (!(ChildStruct->Flags & KSF_BALANCE_MASK)) {
                //
                // Case 3 - single rotation needed (terminates balancing).  We
                //          don't care that Node changes during rotation.
                //

                pRotateOnce (RootPtr, Node, ChildOffset, AntiDirection);
                break;

            } else if (ChildStruct->Flags & Direction) {
                //
                // Case 4 - double rotation needed, Node is changed during rotation
                //

                Node = pRotateTwice (RootPtr, Node, ChildOffset, AntiDirection);

            } else {
                //
                // Case 5 - single rotation needed, Node is changed during rotation
                //

                Node = pRotateOnce (RootPtr, Node, ChildOffset, AntiDirection);
            }
        }

        //
        // Continue climbing the tree
        //

        OldNode = Node;
        Node = OrgParent;

        if (Node != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Node);

            if (KeyStruct->Left == OldNode) {
                Direction = KSF_LEFT_HEAVY;
            } else {
                Direction = KSF_RIGHT_HEAVY;
            }
        } else {
            break;
        }
    }


}


#ifdef DEBUG

VOID
DumpBinTreeStats (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "MemDb Binary Tree Stats:\n\n"
            "  Insertions: %u\n"
            "  Deletions: %u\n"
            "  Single Rotations: %u\n"
            "  Double Rotations: %u\n",
        g_Insertions,
        g_Deletions,
        g_SingleRotations,
        g_DoubleRotations
        ));
}


INT
pComputeHeight (
    IN      DWORD Offset
    )
{
    PKEYSTRUCT KeyStruct;
    INT Left, Right;

    if (Offset == INVALID_OFFSET) {
        return 0;
    }

    KeyStruct = GetKeyStruct (Offset);

    Left = pComputeHeight (KeyStruct->Left);
    Right = pComputeHeight (KeyStruct->Right);

    return 1 + max (Left, Right);
}


VOID
pMakeNum (
    OUT     PTSTR Msg,
    IN      DWORD Offset,
    IN      TCHAR LeftChar,
    IN      TCHAR RightChar
    )
{
    TCHAR Num[32];
    INT Len;
    PTSTR OrgMsg;
    INT i;

    _stprintf (Num, TEXT("%u"), Offset);
    Len = (6 - TcharCount (Num)) / 2;

    OrgMsg = Msg;

    for (i = 0 ; i < Len ; i++) {
        *Msg++ = LeftChar;
    }

    for (i = 0 ; Num[i] ; i++) {
        *Msg++ = Num[i];
    }

    OrgMsg += 6;
    while (Msg < OrgMsg) {
        *Msg++ = RightChar;
    }

    *Msg = 0;
}


VOID
pDumpTree (
    IN      DWORD Root,
    IN      PCSTR Title         OPTIONAL
    )
{
    DWORD Offset;
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD MaxLevel;
    DWORD Spaces;
    UINT u;
    TCHAR Msg[16384];
    UINT Pos;
    INT Pass;
    GROWBUFFER NodesA = GROWBUF_INIT;
    GROWBUFFER NodesB = GROWBUF_INIT;
    PGROWBUFFER Nodes;
    PGROWBUFFER NextNodes;
    PDWORD OffsetPtr;
    PDWORD EndOfList;
    INT HalfWidth;
    TCHAR LeftChar, RightChar;

    if (Root == INVALID_OFFSET) {
        return;
    }

    if (Title) {
        LOGDIRECTA (DBG_VERBOSE, "\r\n");
        LOGDIRECTA (DBG_VERBOSE, Title);
        LOGDIRECTA (DBG_VERBOSE, "\r\n\r\n");
    }

    for (Pass = 0 ; Pass < 2 ; Pass++) {

        MaxLevel = (DWORD) pComputeHeight (Root);
        MaxLevel = min (MaxLevel, 10);

        if (Pass == 0) {
            HalfWidth = 3;
            Spaces = 6;
        } else {
            HalfWidth = 1;
            Spaces = 2;
        }

        for (u = 1 ; u < MaxLevel ; u++) {
            Spaces *= 2;
        }

        NodesB.End = 0;
        Nodes = &NodesA;
        NextNodes = &NodesB;

        GrowBufAppendDword (NextNodes, Root);

        for (u = 0 ; u < MaxLevel ; u++) {

            //
            // Swap growbufs
            //

            if (Nodes == &NodesA) {
                Nodes = &NodesB;
                NextNodes = &NodesA;
            } else {
                Nodes = &NodesA;
                NextNodes = &NodesB;
            }

            NextNodes->End = 0;

            //
            // Process all nodes
            //

            EndOfList = (PDWORD) (Nodes->Buf + Nodes->End);

            for (OffsetPtr = (PDWORD) (Nodes->Buf) ; OffsetPtr < EndOfList ; OffsetPtr++) {

                //
                // Add all children as next nodes
                //

                Offset = *OffsetPtr;

                if (Offset == INVALID_OFFSET) {
                    GrowBufAppendDword (NextNodes, INVALID_OFFSET);
                    GrowBufAppendDword (NextNodes, INVALID_OFFSET);
                } else {
                    KeyStruct = GetKeyStruct (Offset);
                    GrowBufAppendDword (NextNodes, KeyStruct->Left);
                    GrowBufAppendDword (NextNodes, KeyStruct->Right);
                }

                //
                // Print current node
                //

                Pos = 0;

                LeftChar = TEXT(' ');
                RightChar = TEXT(' ');

                if (Offset != INVALID_OFFSET) {
                    KeyStruct = GetKeyStruct (Offset);

                    if (KeyStruct->Parent != INVALID_OFFSET) {

                        KeyParent = GetKeyStruct (KeyStruct->Parent);

                        if (KeyParent->Right == Offset) {
                            LeftChar = TEXT('\'');
                        } else if (KeyParent->Left == Offset) {
                            RightChar = TEXT('\'');
                        }
                    }

                    for ( ; Pos < (Spaces - HalfWidth) ; Pos++) {
                        Msg[Pos] = LeftChar;
                    }

                    if (Pass == 0) {
                        pMakeNum (Msg + Pos, Offset, LeftChar, RightChar);
                    } else {
                        _stprintf (Msg + Pos, TEXT("%2i"), FLAGS_TO_INT (KeyStruct->Flags & KSF_BALANCE_MASK));
                    }

                    Pos += TcharCount (Msg + Pos);
                }

                while (Pos < Spaces * 2) {
                    Msg[Pos] = RightChar;
                    Pos++;
                }

                Msg[Pos] = 0;

                LOGDIRECT (DBG_VERBOSE, Msg);

            }

            LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));

            for (OffsetPtr = (PDWORD) (Nodes->Buf) ; OffsetPtr < EndOfList ; OffsetPtr++) {

                Offset = *OffsetPtr;

                for (Pos = 0 ; Pos < Spaces ; Pos++) {
                    Msg[Pos] = TEXT(' ');
                }

                if (Offset != INVALID_OFFSET) {
                    KeyStruct = GetKeyStruct (*OffsetPtr);
                    if (KeyStruct->Left != INVALID_OFFSET ||
                        KeyStruct->Right != INVALID_OFFSET
                        ) {
                        Msg[Pos] = '|';
                        Pos++;
                    }
                }

                while (Pos < Spaces * 2) {
                    Msg[Pos] = TEXT(' ');
                    Pos++;
                }

                Msg[Pos] = 0;

                LOGDIRECT (DBG_VERBOSE, Msg);
            }

            Spaces /= 2;
            LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));

            Spaces = max (Spaces, 1);
        }

        LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));
    }

    FreeGrowBuffer (&NodesA);
    FreeGrowBuffer (&NodesB);
}


BOOL
pCheckTreeBalance (
    IN      DWORD Root,
    IN      BOOL Force
    )
{
    DWORD NextOffset;
    DWORD PrevOffset;
    DWORD Offset;
    PKEYSTRUCT KeyStruct;
    DWORD MinLevel = 0xFFFFFFFF;
    DWORD MaxLevel = 0;
    DWORD Level = 0;
    DWORD Nodes = 0;
    static DWORD SpotCheck = 0;

    //
    // Don't perform this check every single time
    //

    if (!Force) {
        SpotCheck++;
        if (SpotCheck == 10000) {
            SpotCheck = 0;
        } else {
            return FALSE;
        }
    }

    if (Root == INVALID_OFFSET) {
        return FALSE;
    }

    pCheckBalanceFactors (Root);

    NextOffset = Root;

    //
    // Get leftmost node
    //

    do {
        Offset = NextOffset;
        Level++;
        KeyStruct = GetKeyStruct (Offset);
        NextOffset = KeyStruct->Left;
    } while (NextOffset != INVALID_OFFSET);

    //
    // Recurse through entire tree
    //

    PrevOffset = INVALID_OFFSET;

    do {
        //
        // Visit node at Offset
        //

        Nodes++;
        KeyStruct = GetKeyStruct (Offset);

        if (KeyStruct->Left == INVALID_OFFSET ||
            KeyStruct->Right == INVALID_OFFSET
            ) {

            MinLevel = min (MinLevel, Level);
            MaxLevel = max (MaxLevel, Level);
        }

        //
        // Go to the next node
        //

        if (KeyStruct->Right != INVALID_OFFSET) {

            //
            // Go to left-most node of right
            //

            KeyStruct = GetKeyStruct (Offset);
            NextOffset = KeyStruct->Right;

            while (NextOffset != INVALID_OFFSET) {
                Offset = NextOffset;
                Level++;
                KeyStruct = GetKeyStruct (Offset);
                NextOffset = KeyStruct->Left;
            }
        }

        else {

            //
            // Go to parent, looping if its right child is the
            // previous node.
            //

            do {
                PrevOffset = Offset;
                Offset = KeyStruct->Parent;
                Level--;

                if (Offset == INVALID_OFFSET) {
                    break;
                }

                KeyStruct = GetKeyStruct (Offset);

            } while (KeyStruct->Right == PrevOffset);
        }

    } while (Offset != INVALID_OFFSET);

    DEBUGMSG_IF ((
        (MaxLevel - MinLevel) > 3,
        DBG_NAUSEA,
        "Binary tree imbalance detected: MinLevel=%u, MaxLevel=%u, Nodes=%u",
        MinLevel,
        MaxLevel,
        Nodes
        ));

    return TRUE;
}


INT
pComputeBalanceFactor (
    IN      DWORD Offset
    )
{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct (Offset);

    return pComputeHeight (KeyStruct->Right) - pComputeHeight (KeyStruct->Left);
}


VOID
pCheckBalanceFactors (
    IN      DWORD Root
    )
{
    DWORD Offset;
    INT Factor;
    PKEYSTRUCT KeyStruct;

    Offset = GetFirstOffset (Root);

    while (Offset != INVALID_OFFSET) {

        KeyStruct = GetKeyStruct (Offset);
        Factor = pComputeBalanceFactor (Offset);

        if ((Factor == -1 && !(KeyStruct->Flags & KSF_LEFT_HEAVY)) ||
            (Factor == 1  && !(KeyStruct->Flags & KSF_RIGHT_HEAVY)) ||
            (!Factor      &&  (KeyStruct->Flags & KSF_BALANCE_MASK))
            ) {

            pDumpTree (Root, "Tree Balance Factor Error");
            DEBUGMSG ((DBG_WHOOPS, "Tree balance factors are wrong!"));
            break;
        }

        if (Factor < -1 || Factor > 1) {

            pDumpTree (Root, "Balance Factor Out of Bounds.");
            DEBUGMSG ((DBG_WHOOPS, "Balance factors out of bounds!"));
            break;
       }



        Offset = GetNextOffset (Offset);
    }
}

#endif

PBYTE
pAllocMemoryFromDb (
    IN      UINT RequestSize,
    OUT     PDWORD Offset,
    OUT     PINT AdjustFactor
    )
{
    PBYTE result;
    PBYTE newBuf;

    //
    // Grow heap if necessary
    //

    *AdjustFactor = 0;

    if (RequestSize + g_db->End > g_db->AllocSize) {
        if (g_db->AllocSize < 0x100000) {
            g_db->AllocSize += BLOCK_SIZE;
        } else {
            g_db->AllocSize *= 2;
        }

        if (g_db->AllocSize >= MAX_MEMDB_SIZE) {
            OutOfMemory_Terminate ();
        }

        if (g_db->Buf) {
            newBuf = (PBYTE) MemReAlloc (g_hHeap, 0, g_db->Buf, g_db->AllocSize);
        } else {
            newBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_db->AllocSize);
        }

        if (!newBuf) {
            // g_db->AllocSize must be bigger than 2G
            OutOfMemory_Terminate();
        }

        //
        // provide relocation difference to caller
        //

        if (g_db->Buf) {
            *AdjustFactor = (INT) ((PBYTE) newBuf - (PBYTE) g_db->Buf);
        }

        g_db->Buf = newBuf;
    }

    result = g_db->Buf + g_db->End;
    *Offset = g_db->End;
    g_db->End += RequestSize;

    return result;
}

PKEYSTRUCT
pAllocKeyStructBlock (
    OUT     PDWORD Offset,
    OUT     PINT AdjustFactor
    )
{
    DWORD delOffset;
    DWORD prevDel;
    PKEYSTRUCT keyStruct = NULL;

    //
    // Look for free block
    //

    *AdjustFactor = 0;

    prevDel = INVALID_OFFSET;
    delOffset = g_db->FirstDeleted;

    while (delOffset != INVALID_OFFSET) {
        keyStruct = GetKeyStruct (delOffset);
        prevDel = delOffset;
        delOffset = keyStruct->NextDeleted;
    }

    //
    // Alloc new block if no free space
    //

    if (delOffset == INVALID_OFFSET) {

        //
        // Calc position in block
        //

        keyStruct = (PKEYSTRUCT) pAllocMemoryFromDb (sizeof (KEYSTRUCT), Offset, AdjustFactor);

    } else {
        //
        // Delink free block if recovering free space
        //

        *Offset = delOffset;

        if (prevDel != INVALID_OFFSET) {
            GetKeyStruct (prevDel)->NextDeleted = keyStruct->NextDeleted;
        } else {
            g_db->FirstDeleted = keyStruct->NextDeleted;
        }
    }

    return keyStruct;
}


DWORD
pAllocKeyStruct (
    IN OUT PDWORD ParentOffsetPtr,
    IN     PCWSTR KeyName,
    IN     DWORD PrevLevelNode
    )

/*++

Routine Description:

  pAllocKeyStruct allocates a block of memory in the single
  heap, expanding it if necessary.

  The KeyName must not already be in the tree, and
  ParentOffsetPtr must point to a valid DWORD offset
  variable.  ParentOffsetPtr, or one of the children
  of ParentOffsetPtr, will be linked to the new struct.

Arguments:

  ParentOffsetPtr  - Address of a DWORD that holds the offset to
                     the root.  Within the function, the variable
                     will change to point to the parent of the
                     new struct.

  KeyName - The string identifying the key.  It cannot
            contain backslashes.  The new struct will
            be initialized and this name will be copied
            into the struct.

  PrevLevelNode - Specifies the previous level root offset

Return Value:

  An offset to the new structure.

--*/

{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD Offset;
    DWORD NodeOffsetParent;
    INT cmp;
    DWORD PivotEnd;
    PDWORD RootPtr;
    INT adjustFactor;
    DWORD newToken;

    INCSTAT(g_Insertions);

#ifdef DEBUG
    pCheckTreeBalance (*ParentOffsetPtr, FALSE);
#endif

    KeyStruct = pAllocKeyStructBlock (
                    &Offset,
                    &adjustFactor
                    );

    //
    // Database might have moved. Relocate any pointers within the database now.
    //

    if (ParentOffsetPtr != &g_db->FirstLevelRoot) {
        ParentOffsetPtr = (PDWORD) ((PBYTE) ParentOffsetPtr + adjustFactor);
    }

    //
    // Init new block
    //

    KeyStruct->NextLevelRoot = INVALID_OFFSET;
    KeyStruct->PrevLevelNode = PrevLevelNode;
    KeyStruct->Left = INVALID_OFFSET;
    KeyStruct->Right = INVALID_OFFSET;
    KeyStruct->dwValue = 0;
    KeyStruct->Flags = 0;
#ifdef DEBUG
    KeyStruct->Signature = SIGNATURE;
#endif

    newToken = pAllocKeyToken (KeyName, &adjustFactor);

    //
    // Again the database might have moved
    //

    KeyStruct = (PKEYSTRUCT) ((PBYTE) KeyStruct + adjustFactor);

    if (ParentOffsetPtr != &g_db->FirstLevelRoot) {
        ParentOffsetPtr = (PDWORD) ((PBYTE) ParentOffsetPtr + adjustFactor);
    }

    //
    // finish updating keystruct
    //

    KeyStruct->KeyToken = newToken;

    //
    // Put it in the tree
    //

    NodeOffsetParent = INVALID_OFFSET;
    PivotEnd = INVALID_OFFSET;
    RootPtr = ParentOffsetPtr;

    while (*ParentOffsetPtr != INVALID_OFFSET) {

        NodeOffsetParent = *ParentOffsetPtr;

        KeyParent = GetKeyStruct (*ParentOffsetPtr);

        if (KeyParent->Flags & KSF_BALANCE_MASK) {
            PivotEnd = *ParentOffsetPtr;
        }

        cmp = StringICompareW (KeyName, GetKeyToken (KeyParent->KeyToken));

        if (cmp < 0) {
            ParentOffsetPtr = &KeyParent->Left;
        } else if (cmp > 0) {
            ParentOffsetPtr = &KeyParent->Right;
        } else {
            MYASSERT (FALSE);
        }
    }

    KeyStruct->Parent = NodeOffsetParent;
    *ParentOffsetPtr = Offset;

#ifdef DEBUG
    // If using retail structs, delete Signature from BlockPtr
    if (!g_UseDebugStructs) {
        MoveMemory (
            KeyStruct,
            (PCBYTE) KeyStruct + (sizeof (KEYSTRUCT_DEBUG) - sizeof (KEYSTRUCT_RETAIL)),
            sizeof (KEYSTRUCT_RETAIL)
            );
    }
#endif

    //
    // Balance the tree
    //

    pBalanceInsertion (RootPtr, Offset, PivotEnd);

#ifdef DEBUG
    pCheckTreeBalance (*RootPtr, FALSE);
#endif

    return Offset;
}


VOID
pDeallocKeyStruct (
    IN      DWORD Offset,
    IN OUT  PDWORD RootPtr,
    IN      BOOL DelinkFlag,
    IN      BOOL ClearFlag
    )

/*++

Routine Description:

  pDeallocKeyStruct first deletes all structures pointed to by
  NextLevelRoot.  After all items are deleted from the next
  level, pDeallocKeyStruct optionally delinks the struct from
  the binary tree.  Before exiting, the struct is given to the
  deleted block chain.

Arguments:

  Offset      - An offset to the item as provided by pAllocKeyStruct
                or any of the Find functions.
  RootPtr     - A pointer to the level tree root variable.  This value
                will be updated if delinking is involved.
  DelinkFlag  - A flag indicating TRUE to delink the struct from
                the binary tree it is in, or FALSE if the struct is
                only to be added to the deleted block chain.
  ClearFlag   - Specifies FALSE if the key struct's children are to
                be deleted, or TRUE if the current key struct should
                simply be cleaned up but left allocated.

Return Value:

  none

--*/

{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    PKEYSTRUCT KeyChild;
    PKEYSTRUCT KeyLeftmost;
    PKEYSTRUCT KeyLeftChild;
    PKEYSTRUCT KeyRightChild;
    DWORD Leftmost;
    DWORD NodeOffset;
    PDWORD ParentOffsetPtr;
    WCHAR TempStr[MEMDB_MAX];
    DWORD Direction = 0;
    DWORD RebalanceOffset;

    KeyStruct = GetKeyStruct (Offset);

    //
    // Remove endpoints from hash table
    //

    if (KeyStruct->Flags & KSF_ENDPOINT) {
        PrivateBuildKeyFromOffset (0, Offset, TempStr, NULL, NULL, NULL);
        RemoveHashTableEntry (TempStr);

        //
        // Free binary value on key
        //

        FreeKeyStructBinaryBlock (KeyStruct);
        KeyStruct->Flags &= ~KSF_ENDPOINT;
    }

    //
    // Call recursively if there are sublevels to this key
    //

    if (!ClearFlag) {
        if (KeyStruct->NextLevelRoot != INVALID_OFFSET) {

            NodeOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

            while (NodeOffset != INVALID_OFFSET) {
                pDeallocKeyStruct (NodeOffset, &KeyStruct->NextLevelRoot, FALSE, FALSE);
                NodeOffset = GetNextOffset (NodeOffset);
            }
        }

        //
        // Remove the item from its binary tree
        //

        if (DelinkFlag) {
            //
            // Find parent-to-child pointer
            //

            if (KeyStruct->Parent != INVALID_OFFSET) {

                KeyParent = GetKeyStruct (KeyStruct->Parent);

                if (KeyParent->Left == Offset) {
                    ParentOffsetPtr = &KeyParent->Left;
                    Direction = KSF_LEFT_HEAVY;
                } else {
                    ParentOffsetPtr = &KeyParent->Right;
                    Direction = KSF_RIGHT_HEAVY;
                }

            } else {
                ParentOffsetPtr = RootPtr;
            }

            if (KeyStruct->Left == INVALID_OFFSET &&
                KeyStruct->Right == INVALID_OFFSET
                ) {
                //
                // No children; reset parent, then rebalance tree
                //

                *ParentOffsetPtr = INVALID_OFFSET;
                RebalanceOffset = KeyStruct->Parent;

            } else if (KeyStruct->Left == INVALID_OFFSET) {
                //
                // Only a right child; bring it up a level and rebalance
                //

                *ParentOffsetPtr = KeyStruct->Right;
                KeyChild = GetKeyStruct (*ParentOffsetPtr);
                KeyChild->Parent = KeyStruct->Parent;

                //
                // The moved node's balance factor must be set the same as the
                // node we are deleting.  The rebalancing will correct it.
                //

                KeyChild->Flags = (KeyChild->Flags & (~KSF_BALANCE_MASK)) |
                                  (KeyStruct->Flags & KSF_BALANCE_MASK);

                Direction = KSF_RIGHT_HEAVY;
                RebalanceOffset = KeyStruct->Right;

            } else if (KeyStruct->Right == INVALID_OFFSET) {

                //
                // Only a left child; bring it up a level and rebalance
                //

                *ParentOffsetPtr = KeyStruct->Left;
                KeyChild = GetKeyStruct (*ParentOffsetPtr);
                KeyChild->Parent = KeyStruct->Parent;

                //
                // The moved node's balance factor must be set the same as the
                // node we are deleting.  The rebalancing will correct it.
                //

                KeyChild->Flags = (KeyChild->Flags & (~KSF_BALANCE_MASK)) |
                                  (KeyStruct->Flags & KSF_BALANCE_MASK);

                Direction = KSF_LEFT_HEAVY;
                RebalanceOffset = KeyStruct->Left;

            } else {

                //
                // Two children - find min val of right subtree (the leftmost node
                // of the right child).
                //

                Leftmost = KeyStruct->Right;

                KeyLeftmost = GetKeyStruct (Leftmost);

                while (KeyLeftmost->Left != INVALID_OFFSET) {
                    Leftmost = KeyLeftmost->Left;
                    KeyLeftmost = GetKeyStruct (Leftmost);
                }

                //
                // If Leftmost has right children, and it is not the
                // right child of the node we are deleting, then
                // hook right subtree to parent.
                //
                // If Leftmost does not have right children, then
                // remove its parent's linkage
                //

                if (Leftmost != KeyStruct->Right) {

                    KeyParent = GetKeyStruct (KeyLeftmost->Parent);

                    if (KeyLeftmost->Right != INVALID_OFFSET) {

                        //
                        // Because of the balance properties, we know that
                        // we have a single leaf node to the right.  Its
                        // balance factor is zero, and we move it to a
                        // position where it remains zero.
                        //

                        KeyRightChild = GetKeyStruct (KeyLeftmost->Right);
                        MYASSERT (KeyRightChild->Left == INVALID_OFFSET);
                        MYASSERT (KeyRightChild->Right == INVALID_OFFSET);

                        KeyParent->Left = KeyLeftmost->Right;
                        KeyRightChild->Parent = KeyLeftmost->Parent;

                    } else {

                        KeyParent->Left = INVALID_OFFSET;
                    }

                    //
                    // We are affecting the balance factor of the
                    // parent.  Rebalancing must start at the leftmost
                    // node's parent.
                    //

                    RebalanceOffset = KeyLeftmost->Parent;
                    Direction = KSF_LEFT_HEAVY;     // we deleted from the left side

                } else {
                    //
                    // In this case there is no leftmost node of the right child.
                    // Therefore, we reduced the height of the right side.
                    //

                    RebalanceOffset = Leftmost;
                    Direction = KSF_RIGHT_HEAVY;
                }

                //
                // Now leftmost is available to replace the deleted
                // node
                //

                KeyLeftmost->Parent = KeyStruct->Parent;
                *ParentOffsetPtr = Leftmost;

                KeyLeftmost->Left = KeyStruct->Left;
                KeyLeftChild = GetKeyStruct (KeyStruct->Left);
                KeyLeftChild->Parent = Leftmost;

                if (Leftmost != KeyStruct->Right) {

                    KeyLeftmost->Right = KeyStruct->Right;
                    MYASSERT (KeyStruct->Right != INVALID_OFFSET);

                    KeyRightChild = GetKeyStruct (KeyStruct->Right);
                    KeyRightChild->Parent = Leftmost;
                }

                //
                // We need to copy the balance factor of what we are deleting to the
                // replacement node.
                //

                KeyLeftmost->Flags = (KeyLeftmost->Flags & (~KSF_BALANCE_MASK)) |
                                     (KeyStruct->Flags & KSF_BALANCE_MASK);

            }

            //
            // Rebalance the tree
            //

            if (RebalanceOffset != INVALID_OFFSET) {
                MYASSERT (Direction);

                if (Direction) {
                    //pDumpTree (*RootPtr, "Before rebalance");
                    pBalanceDeletion (RootPtr, RebalanceOffset, Direction);
                    //pDumpTree (*RootPtr, "Final tree");
                }
            }

#ifdef DEBUG
            pCheckTreeBalance (*RootPtr, FALSE);
#endif

        }

        //
        // Donate block to free space unless caller does not
        // want child structs freed.
        //

        pDeallocToken (KeyStruct->KeyToken);
        KeyStruct->NextDeleted = g_db->FirstDeleted;

        g_db->FirstDeleted = Offset;
    }
}


VOID
pRemoveHashEntriesForNode (
    IN      PCWSTR Root,
    IN      DWORD Offset
    )

/*++

Routine Description:

  pRemoveHashEntriesFromNode removes all hash table entries from all children
  of the specified node.  This function is called recursively.

Arguments:

  Root   - Specifies the root string that corresponds with Offset.  This must
           also contain the temporary hive root.
  Offset - Specifies the offset of the node to process.  The node and all of
           its children will be removed from the hash table.

Return Value:

  None.

--*/

{
    DWORD ChildOffset;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;

    //
    // Remove hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Offset);

    if (KeyStruct->Flags & KSF_ENDPOINT) {
        RemoveHashTableEntry (Root);

#ifdef DEBUG
        {
            DWORD HashOffset;

            HashOffset = FindStringInHashTable (Root, NULL);
            if (HashOffset != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb move duplicate: %s", Root));
            }
        }
#endif
    }

    //
    // Recurse for all children, removing hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

    while (ChildOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildOffset);
        StringCopyW (End, GetKeyToken (KeyStruct->KeyToken));
        pRemoveHashEntriesForNode (ChildRoot, ChildOffset);

        ChildOffset = GetNextOffset (ChildOffset);
    }
}


VOID
pAddHashEntriesForNode (
    IN      PCWSTR Root,
    IN      DWORD Offset,
    IN      BOOL AddRoot
    )

/*++

Routine Description:

  pAddHashEntriesForNode adds hash table entries for the specified root and
  all of its children.

Arguments:

  Root    - Specifies the root string that corresponds to Offset.  This string
            must also include the temporary hive root.
  Offset  - Specifies the node offset to begin processing.  The node and all
            of its children are added to the hash table.
  AddRoot - Specifies TRUE if the root should be added to the hash table,
            FALSE otherwise.


Return Value:

  None.

--*/

{
    DWORD ChildOffset;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;
    DWORD HashOffset;

    //
    // Add hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Offset);

    if (AddRoot && KeyStruct->Flags & KSF_ENDPOINT) {

        HashOffset = FindStringInHashTable (Root, NULL);

        if (HashOffset != Offset) {

#ifdef DEBUG
            if (HashOffset != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb duplicate: %s", Root));
            }
#endif

            AddHashTableEntry (Root, Offset);
        }
    }

    //
    // Recurse for all children, adding hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

    while (ChildOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildOffset);
        StringCopyW (End, GetKeyToken (KeyStruct->KeyToken));
        pAddHashEntriesForNode (ChildRoot, ChildOffset, TRUE);

        ChildOffset = GetNextOffset (ChildOffset);
    }
}


BOOL
pFindPlaceForNewNode (
    IN      PKEYSTRUCT InsertNode,
    IN      PDWORD TreeRootPtr,
    OUT     PDWORD ParentOffsetPtr,
    OUT     PDWORD *ParentToChildOffsetPtr,
    OUT     PDWORD PivotEnd
    )

/*++

Routine Description:

  pFindPlaceForNewNode searches a level for the position within the tree.
  This is used to insert new unique keys in the tree.

Arguments:

  InsertNode             - Specifies the allocated but unlinked node.  Its
                           Key member must be valid.
  TreeRootPtr            - Specifies a pointer to the memory that holds the
                           root offset.  This is used to walk the tree.  It
                           can be INVALID_OFFSET.
  ParentOffsetPtr        - Receives the offset to the parent node
  ParentToChildOffsetPtr - Recieves the address of the left or right child
                           pointer within the parent struct
  PivotEnd               - Receives the offset of the tree node that should
                           stop balancing

Return Value:

  TRUE if a spot was found in the tree for InsertNode, or FALSE if a spot was
  not found (because the key name is already in the tree).

--*/

{
    PDWORD ParentPtr;
    PKEYSTRUCT Parent;
    INT cmp;

    ParentPtr = TreeRootPtr;
    *ParentOffsetPtr = INVALID_OFFSET;
    *PivotEnd = INVALID_OFFSET;

    while (*ParentPtr != INVALID_OFFSET) {

        *ParentOffsetPtr = *ParentPtr;
        Parent = GetKeyStruct (*ParentPtr);

        if (Parent->Flags & KSF_BALANCE_MASK) {
            *PivotEnd = *ParentPtr;
        }

        cmp = StringICompareW (GetKeyToken (InsertNode->KeyToken), GetKeyToken (Parent->KeyToken));

        if (cmp < 0) {
            ParentPtr = &Parent->Left;
        } else if (cmp > 0) {
            ParentPtr = &Parent->Right;
        } else {
            return FALSE;
        }
    }

    *ParentToChildOffsetPtr = ParentPtr;

    return TRUE;
}


VOID
pMergeFamilies (
    IN      PDWORD DestTreeRootPtr,
    IN      DWORD MergeSrcOffset,
    IN      DWORD MergeDestPrevLevelOffset
    )

/*++

Routine Description:

  pMergeFamilies takes two tree families and merges them together.  When
  duplicates are found, their linkage is abandoned, but they are not
  deallocated.  This allows MemDbBuildKeyFromOffset to continue to work.

Arguments:

  DestTreeRootPtr          - Specifies the address of the destination level's
                             root variable.  This is potentially altered with
                             insertion and balancing.
  MergeSrcOffset           - Specifies the offset to the source tree family
                             (STF).  The STF is merged into the destination
                             tree indicated by DestTreeRootPtr.
  MergeDestPrevLevelOffset - Specifies the offset to the previous level node.
                             This value cannot be INVALID_OFFSET.

Return Value:

  None.

--*/

{
    PKEYSTRUCT MergeSrc;
    PKEYSTRUCT MergeDest;
    PDWORD ParentToChildOffsetPtr;
    DWORD ParentOffset;
    DWORD DestCollisionOffset;
    DWORD PivotEnd;
    GROWBUFFER NextLevelMerge = GROWBUF_INIT;
    DWORD NodeOffset;
    PDWORD NextLevelOffsetPtr;
    UINT Pos;
    BOOL FoundPlaceForNode;

    //
    // Look for a place within the tree indicated by the offset
    // stored in DestTreeRootPtr.  If one is found, we can simply
    // relink the node at MergeSrcOffset.  Otherwise, we have to
    // recursively merge the next level of MergeSrcOffset, and
    // we have to abandon MergeSrcOffset.
    //

    MergeSrc = GetKeyStruct (MergeSrcOffset);
    MYASSERT (MergeSrc);

    FoundPlaceForNode = pFindPlaceForNewNode (
                            MergeSrc,
                            DestTreeRootPtr,
                            &ParentOffset,
                            &ParentToChildOffsetPtr,
                            &PivotEnd
                            );

    if (FoundPlaceForNode) {
        //
        // Since we found a place to put the src family, it is
        // easy to hook it and its next level into the dest
        // family.
        //

        MergeSrc->Parent = ParentOffset;
        *ParentToChildOffsetPtr = MergeSrcOffset;

        MergeSrc->Flags = MergeSrc->Flags & (~KSF_BALANCE_MASK);
        MergeSrc->Left = INVALID_OFFSET;
        MergeSrc->Right = INVALID_OFFSET;
        MergeSrc->PrevLevelNode = MergeDestPrevLevelOffset;

        pBalanceInsertion (DestTreeRootPtr, MergeSrcOffset, PivotEnd);

#ifdef DEBUG
        pCheckTreeBalance (*DestTreeRootPtr, FALSE);
#endif

    } else {
        //
        // We found a collision, then we have to abandon MergeSrc,
        // removing linkage to the parent and children -- but preserving
        // the linkage to the previous level.  Finally, we have to call
        // this function recursively to hook up all the next level nodes.
        //

        DestCollisionOffset = ParentOffset;      // renamed to be more accurate

        MergeDest = GetKeyStruct (DestCollisionOffset);
        MYASSERT (MergeDest);

        MergeSrc->Parent = INVALID_OFFSET;
        MergeSrc->Left = INVALID_OFFSET;
        MergeSrc->Right = INVALID_OFFSET;
        MergeSrc->PrevLevelNode = MergeDestPrevLevelOffset;

        //
        // If this is an end point, then try to preserve value and flags
        //

        if (MergeSrc->Flags & KSF_ENDPOINT) {

            if (MergeDest->Flags & KSF_ENDPOINT) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "MemDb: Loss of value and flags in %s",
                    GetKeyToken (MergeSrc->KeyToken)
                    ));

            } else {
                MergeDest->Flags = MergeDest->Flags & ~KSF_FLAGS_TO_COPY;
                MergeDest->Flags |= MergeSrc->Flags & KSF_FLAGS_TO_COPY;
                MergeDest->dwValue = MergeSrc->dwValue;
            }
        }

        //
        // Save away all entries in the next src level into a grow buffer,
        // then call pMergeFamilies recursively.
        //

        NodeOffset = GetFirstOffset (MergeSrc->NextLevelRoot);

        while (NodeOffset != INVALID_OFFSET) {

            NextLevelOffsetPtr = (PDWORD) GrowBuffer (&NextLevelMerge, sizeof (DWORD));
            MYASSERT (NextLevelOffsetPtr);

            *NextLevelOffsetPtr = NodeOffset;
            NodeOffset = GetNextOffset (NodeOffset);
        }

        NextLevelOffsetPtr = (PDWORD) NextLevelMerge.Buf;

        for (Pos = 0 ; Pos < NextLevelMerge.End ; Pos += sizeof (DWORD)) {

            pMergeFamilies (
                &MergeDest->NextLevelRoot,
                *NextLevelOffsetPtr,
                DestCollisionOffset
                );

            NextLevelOffsetPtr++;

        }

        FreeGrowBuffer (&NextLevelMerge);
    }
}


DWORD
pMoveKey (
    IN      DWORD OriginalKey,
    IN      PCWSTR NewKeyRoot,
    IN      PCWSTR NewKeyRootWithHive
    )

/*++

Routine Description:

  pMoveKey moves a key (and all of its children) to a new root.  If the
  caller specifies a source key that has no children, a proxy node is created
  to maintain offsets.  The proxy node is not listed in the hash table.

Arguments:

  OriginalKey        - Specifies the offset to the original key that needs to
                       be moved.  It does not need to be an endpoint, and may
                       have children.
  NewKeyRoot         - Specifies the new root for OriginalKey.  It may have
                       multiple levels (separated by backslashes).
  NewKeyRootWithHive - Different from NewKeyRoot only when the node is in a
                       temporary hive.  This is used for the hash table only.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    DWORD ReplacementKey;
    PKEYSTRUCT SrcKey, DestKey, ChildKey;
    PKEYSTRUCT KeyParent;
    DWORD NodeOffset;
    GROWBUFFER Children = GROWBUF_INIT;
    PDWORD ChildOffsetPtr;
    DWORD Pos;
    WCHAR OriginalRoot[MEMDB_MAX];
    BOOL Endpoint;

    //
    // Check requirements
    //

    SrcKey = GetKeyStruct (OriginalKey);
    if (!SrcKey) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: pMoveKey can't find original key %s", OriginalKey));
        return INVALID_OFFSET;
    }

    if (SrcKey->Flags & KSF_PROXY_NODE) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: pMoveKey can't move proxy node %s", OriginalKey));
        return INVALID_OFFSET;
    }

    Endpoint = SrcKey->Flags & KSF_ENDPOINT;

    if (!PrivateBuildKeyFromOffset (0, OriginalKey, OriginalRoot, NULL, NULL, NULL)) {
        return INVALID_OFFSET;
    }

    //
    // Allocate new key
    //

    ReplacementKey = pNewKey (NewKeyRoot, NewKeyRootWithHive, FALSE);

    if (ReplacementKey == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    SrcKey = GetKeyStruct (OriginalKey);
    DestKey = GetKeyStruct (ReplacementKey);

    if (!SrcKey || !DestKey) {
        return INVALID_OFFSET;
    }

    DEBUGMSG ((DBG_NAUSEA, "Moving %s to %s", OriginalRoot, NewKeyRootWithHive));

    //
    // Remove all hash entries for all children
    //

    pRemoveHashEntriesForNode (OriginalRoot, OriginalKey);

    //
    // Record all children in an array
    //

    NodeOffset = GetFirstOffset (SrcKey->NextLevelRoot);

    while (NodeOffset != INVALID_OFFSET) {
        ChildOffsetPtr = (PDWORD) GrowBuffer (&Children, sizeof (DWORD));
        if (!ChildOffsetPtr) {
            return INVALID_OFFSET;
        }

        *ChildOffsetPtr = NodeOffset;

        NodeOffset = GetNextOffset (NodeOffset);
    }

    //
    // Move next level pointer to new node.  There are two cases
    // to handle:
    //
    //  1. Destination exists and has children.  Here the source
    //     needs to be merged into the destination.
    //
    //  2. Destination is brand new and has no children.  Here we
    //     simply move the source children to the destination.
    //
    // During this process, the hash table is updated accordingly.
    //

    if (DestKey->NextLevelRoot != INVALID_OFFSET) {
        //
        // Hard case, merge children to new parent's family
        //

        ChildOffsetPtr = (PDWORD) Children.Buf;

        for (Pos = 0 ; Pos < Children.End ; Pos += sizeof (DWORD)) {

            pMergeFamilies (
                &DestKey->NextLevelRoot,
                *ChildOffsetPtr,
                ReplacementKey
                );

            ChildOffsetPtr++;

        }

    } else {
        //
        // Easy case, link children to new parent
        //

        DestKey->NextLevelRoot = SrcKey->NextLevelRoot;
        SrcKey->NextLevelRoot = INVALID_OFFSET;

        if (DestKey->Flags & KSF_ENDPOINT) {
            DEBUGMSG ((
                DBG_WARNING,
                "MemDb: Loss of value and flags in %s",
                GetKeyToken (SrcKey->KeyToken)
                ));

        } else {
            DestKey->Flags = DestKey->Flags & ~KSF_FLAGS_TO_COPY;
            DestKey->Flags |= SrcKey->Flags & KSF_FLAGS_TO_COPY;
            DestKey->dwValue = SrcKey->dwValue;
        }

        ChildOffsetPtr = (PDWORD) Children.Buf;

        for (Pos = 0 ; Pos < Children.End ; Pos += sizeof (DWORD)) {
            NodeOffset = *ChildOffsetPtr;
            ChildOffsetPtr++;

            ChildKey = GetKeyStruct (NodeOffset);
            ChildKey->PrevLevelNode = ReplacementKey;
        }
    }

    //
    // Add all new entries to hash table
    //

    pAddHashEntriesForNode (NewKeyRootWithHive, ReplacementKey, FALSE);

    //
    // Free the original key node, or if an endpoint, make the
    // node a proxy to the new node (to maintain offsets).
    //

    if (!Endpoint) {

        SrcKey->NextLevelRoot = INVALID_OFFSET;
        KeyParent = GetKeyStruct (SrcKey->PrevLevelNode);
        pDeallocKeyStruct (OriginalKey, &KeyParent->NextLevelRoot, TRUE, FALSE);

    } else {

        DestKey->Flags   = (DestKey->Flags & KSF_BALANCE_MASK) | (SrcKey->Flags & (~KSF_BALANCE_MASK));
        DestKey->dwValue = SrcKey->dwValue;

        SrcKey->Flags = KSF_PROXY_NODE | (SrcKey->Flags & KSF_BALANCE_MASK);
        SrcKey->dwValue = ReplacementKey;
        SrcKey->NextLevelRoot = INVALID_OFFSET;
    }

    FreeGrowBuffer (&Children);

    return ReplacementKey;
}


BOOL
MemDbMoveTreeA (
    IN      PCSTR RootNode,
    IN      PCSTR NewRoot
    )

/*++

Routine Description:

  MemDbMoveTree is the external interface to pMoveKey.  See description in
  pMoveKey for details.

Arguments:

  RootNode - Specifies the node to move.

  NewRoot - Specifies the new root for RootNode.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PCWSTR UnicodeRootNode;
    PCWSTR UnicodeNewRoot;
    BOOL b = FALSE;

    UnicodeRootNode = ConvertAtoW (RootNode);
    UnicodeNewRoot = ConvertAtoW (NewRoot);

    if (UnicodeRootNode && UnicodeNewRoot) {
        b = MemDbMoveTreeW (UnicodeRootNode, UnicodeNewRoot);
    }

    FreeConvertedStr (UnicodeRootNode);
    FreeConvertedStr (UnicodeNewRoot);

    return b;
}


BOOL
MemDbMoveTreeW (
    IN      PCWSTR RootNode,
    IN      PCWSTR NewRoot
    )
{
    DWORD Offset;
    WCHAR Temp[MEMDB_MAX];
    WCHAR NewRootWithHive[MEMDB_MAX];
    PWSTR p, q;
    PCWSTR SubKey;
    BOOL b = FALSE;
    INT HiveLen;

    if (StringIMatch (RootNode, NewRoot)) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot move tree because source and dest are the same"));
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (RootNode);

        //
        // Copy key to temp buffer
        //

        StringCopyW (Temp, SubKey);

        if (*Temp == 0) {
            DEBUGMSG ((DBG_WHOOPS, "MemDbMoveTree requires a root"));
            __leave;
        }

        //
        // Compute the new root with the original hive
        //

        if (StringIMatchW (Temp, RootNode)) {
            // no hive case
            StringCopyW (NewRootWithHive, NewRoot);
        } else {
            HiveLen = wcslen (RootNode) - wcslen (SubKey);
            StringCopyTcharCountW (NewRootWithHive, RootNode, HiveLen);
            StringCopyW (AppendWackW (NewRootWithHive), NewRoot);
        }

        //
        // Find the last offset of the root key
        //

        q = Temp;
        Offset = INVALID_OFFSET;

        do {

            if (Offset == INVALID_OFFSET) {
                Offset = g_db->FirstLevelRoot;
            } else {
                Offset = GetKeyStruct (Offset)->NextLevelRoot;
            }

            if (Offset == INVALID_OFFSET) {
                DEBUGMSGW ((DBG_VERBOSE, "MemDbMoveTree root %s not found", RootNode));
                __leave;
            }

            p = wcschr (q, L'\\');
            if (p) {
                *p = 0;
            }

            Offset = FindKeyStruct (Offset, q);

            if (Offset == INVALID_OFFSET) {
                DEBUGMSGW ((DBG_VERBOSE, "MemDbMoveTree root %s not found", RootNode));
                __leave;
            }

            q = p + 1;

        } while (p);

        //
        // Now move the key
        //

        Offset = pMoveKey (Offset, NewRoot, NewRootWithHive);

        if (Offset != INVALID_OFFSET) {
            b = TRUE;
        } else {
            DEBUGMSGW ((DBG_WHOOPS, "Can't move %s to %s", RootNode, NewRoot));
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


PKEYSTRUCT
pGetKeyStructWithProxy (
    IN DWORD Offset
    )

/*++

Routine Description:

  pGetKeyStructWithProxy returns a pointer given an offset.  It also implements proxy
  nodes, transparent to the rest of memdb.  The debug version checks the
  signature and validity of each offset.  It is assumed that Offset is always
  valid.

Arguments:

  Offset - Specifies the offset to the node

Return Value:

  The pointer to the node.

--*/

{
    PKEYSTRUCT KeyStruct;

#ifdef DEBUG

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in pGetKeyStructWithProxy at offset %u", Offset));
        return NULL;
    }

    if (!g_db->Buf) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }

    if (Offset > g_db->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in pGetKeyStructWithProxy (offset %u)", Offset));
        return NULL;
    }
#endif

    KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset);


#ifdef DEBUG

    if (!g_UseDebugStructs) {

        KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset - sizeof (DWORD));

    } else if (KeyStruct->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in pGetKeyStructWithProxy at offset %u!", Offset));
        return NULL;
    }

#endif

    if (KeyStruct->Flags & KSF_PROXY_NODE) {
        return pGetKeyStructWithProxy (KeyStruct->dwValue);
    }

    return KeyStruct;
}


PKEYSTRUCT
GetKeyStruct (
    IN DWORD Offset
    )

/*++

Routine Description:

  GetKeyStruct returns a pointer given an offset.  It does not support proxy
  nodes, so the rest of memdb accesses the unaltered tree.  The debug version
  checks the signature and validity of each offset.  It is assumed that Offset
  is always valid.

Arguments:

  Offset - Specifies the offset to the node

Return Value:

  The pointer to the node.

--*/

{
    PKEYSTRUCT KeyStruct;

#ifdef DEBUG

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at offset %u", Offset));
        return NULL;
    }

    if (!g_db->Buf) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }

    if (Offset > g_db->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in GetKeyStruct (offset %u)", Offset));
        return NULL;
    }
#endif

    KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset);


#ifdef DEBUG

    if (!g_UseDebugStructs) {

        KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset - sizeof (DWORD));

    } else if (KeyStruct->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in GetKeyStruct at offset %u!", Offset));
        return NULL;
    }

#endif

    return KeyStruct;
}


DWORD
FindKeyStruct (
    IN DWORD RootOffset,
    IN PCWSTR KeyName
    )

/*++

Routine Description:

  FindKeyStruct takes a key name and looks for the
  offset in the tree specified by RootOffset.  The key
  name must not contain backslashes.

Arguments:

  RootOffset - An offset to the root of the level

  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    int cmp;

    //
    // Walk the binary tree looking for KeyName
    //

    while (RootOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (RootOffset);
        cmp = StringICompareW (KeyName, GetKeyToken (KeyStruct->KeyToken));
        if (!cmp) {
            break;
        }

        if (cmp < 0) {
            RootOffset = KeyStruct->Left;
        } else {
            RootOffset = KeyStruct->Right;
        }
    }

    return RootOffset;
}


DWORD
GetFirstOffset (
    IN  DWORD RootOffset
    )

/*++

Routine Description:

  GetFirstOffset walks down the left side of the binary tree
  pointed to by RootOffset, and returns the left-most node.

Arguments:

  RootOffset    - An offset to the root of the level

Return Value:

  An offset to the leftmost structure, or INVALID_OFFSET if the
  root was invalid.

--*/


{
    PKEYSTRUCT KeyStruct;

    if (RootOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    //
    // Go to leftmost node of root
    //

    KeyStruct = GetKeyStruct (RootOffset);
    while (KeyStruct->Left != INVALID_OFFSET) {
        RootOffset = KeyStruct->Left;
        KeyStruct = GetKeyStruct (RootOffset);
    }

    return RootOffset;
}


DWORD
GetNextOffset (
    IN  DWORD NodeOffset
    )

/*++

Routine Description:

  GetNextOffset traverses the binary tree in order.  This
  technique relies on parent links to traverse without a
  stack or recursion.

Arguments:

  NodeOffset  - Offset to a node in the tree, usually the
            return value from GetFirstOffset or GetNextOffset.

Return Value:

  An offset to the next structure, or INVALID_OFFSET if the
  end is reached.

--*/

{
    PKEYSTRUCT KeyStruct;
    DWORD Last;

    KeyStruct = GetKeyStruct (NodeOffset);

    //
    // If right child exist, go to leftmost node of right child
    //

    if (KeyStruct->Right != INVALID_OFFSET) {

        //
        // Go to right child
        //

        NodeOffset = KeyStruct->Right;

        //
        // Go to left-most of right child
        //

        KeyStruct = GetKeyStruct (NodeOffset);
        while (KeyStruct->Left != INVALID_OFFSET) {
            NodeOffset = KeyStruct->Left;
            KeyStruct = GetKeyStruct (NodeOffset);
        }
    }

    //
    // Else move up to parent
    //

    else {
        //
        // Climb to top of processed nodes
        //

        do {
            Last = NodeOffset;
            NodeOffset = KeyStruct->Parent;

            if (NodeOffset != INVALID_OFFSET) {
                KeyStruct = GetKeyStruct (NodeOffset);
            } else {
                break;  // reached the root of tree
            }
        } while (Last == KeyStruct->Right);
    }

    return NodeOffset;
}


DWORD
pFindPatternKeyStruct (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR KeyName
    )

/*++

Routine Description:

  pFindPatternKeyStruct takes a key name and looks for the
  offset in the tree specified by RootOffset.  The key name must
  not contain backslashes, and the stored key name is
  treated as a pattern.

Arguments:

  RootOffset - An offset to the root of the level
  NodeOffset - The previous return value from pFindPatternKeyStruct
               (for enumeration) or INVALID_OFFSET for the first
               call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    //
    // if NodeOffset is invalid, this is the first search item
    //

    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    //
    // otherwise advance NodeOffset
    //

    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }


    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key (string in KeyStruct->KeyToken is the pattern)
        if (IsPatternMatchW (GetKeyToken (KeyStruct->KeyToken), KeyName)) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
pFindKeyStructUsingPattern (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR PatternStr
    )

/*++

Routine Description:

  pFindKeyStructUsingPattern takes a key pattern and looks
  for the offset in the tree specified by RootOffset.  The key
  name must not contain backslashes, but can contain wildcards.

Arguments:

  RootOffset - An offset to the root of the level

  NodeOffset - The previous return value from pFindPatternKeyStruct
               (for enumeration) or INVALID_OFFSET for the first
               call.

  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    // if NodeOffset is invalid, this is the first search item
    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    // otherwise advance NodeOffset
    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }

    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key
        if (IsPatternMatchW (PatternStr, GetKeyToken (KeyStruct->KeyToken))) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
pFindPatternKeyStructUsingPattern (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR PatternStr
    )

/*++

Routine Description:

  pFindPatternKeyStructUsingPattern takes a key pattern and looks
  for the offset in the tree specified by RootOffset.  The key name
  must not contain backslashes, but can contain wildcards.  The
  wildcards in the stored key are processed as well.

Arguments:

  RootOffset      - An offset to the root of the level
  NodeOffset      - The previous return value from pFindPatternKeyStruct
                (for enumeration) or INVALID_OFFSET for the first
                call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    // if NodeOffset is invalid, this is the first search item
    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    // otherwise advance NodeOffset
    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }


    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key (PatternStr is the pattern)
        if (IsPatternMatchW (PatternStr, GetKeyToken (KeyStruct->KeyToken))) {
            return NodeOffset;
        }

        // Compare key (string in KeyStruct->KeyToken is the pattern)
        if (IsPatternMatchW (GetKeyToken (KeyStruct->KeyToken), PatternStr)) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
FindKey (
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKey locates a complete key string and returns
  the offset to the KEYSTRUCT, or INVALID_OFFSET if
  the key path does not exist.  The FullKeyPath
  must supply the complete path to the KEYSTRUCT.

Arguments:

  FullKeyPath - A backslash-delimited key path to a value

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    return FindStringInHashTable (FullKeyPath, NULL);
}


DWORD
FindPatternKey (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath,
    IN  BOOL EndPatternAllowed
    )

/*++

Routine Description:

  FindPatternKey locates a complete key string and returns
  the offset to the KEYSTRUCT, or INVALID_OFFSET if the
  key path does not exist.  Each stored part of the key is
  treated as a pattern, and FullKeyPath must supply the
  complete path to the KEYSTRUCT without wildcards.

Arguments:

  RootOffset        - An offset to the level's binary tree root
  FullKeyPath       - A backslash-delimited key path to a value
                      without wildcards.
  EndPatternAllowed - Specifies TRUE if the stored pattern can
                      have an asterisk at the end, to indicate
                      any subkeys, or FALSE if the pattern matches
                      on the same level only.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX + 1];
    PWSTR p;
    PCWSTR End;

    //
    // Divide the string into a multi-sz
    //

    StringCopyW (Path, FullKeyPath);

    for (p = Path ; *p ; p++) {
        if (*p == L'\\') {
            *p = 0;
        }
    }

    End = p;
    if (End > Path && *(End - 1) == 0) {
        //
        // Special case: the wack was at the end of the string.
        // Therefore, inc End so we test that final empty value.
        //

        End++;
    }

    if (End == Path) {
        DEBUGMSG ((DBG_ERROR, "FindPatternKey: Empty key not allowed"));
        return INVALID_OFFSET;
    }

    //
    // Now test the key against all stored patterns
    //

    return pFindPatternKeyWorker (Path, End, RootOffset, EndPatternAllowed);
}


DWORD
pFindPatternKeyWorker (
    IN      PCWSTR SubKey,
    IN      PCWSTR End,
    IN      DWORD RootOffset,
    IN      BOOL EndPatternAllowed
    )
{
    DWORD Offset;
    PCWSTR NextSubKey;
    DWORD MatchOffset;
    PKEYSTRUCT KeyStruct;

    NextSubKey = GetEndOfString (SubKey) + 1;

    // Begin an enumeration of the matches
    Offset = pFindPatternKeyStruct (RootOffset, INVALID_OFFSET, SubKey);

    while (Offset != INVALID_OFFSET) {
        //
        // Is there more in the caller's key string to test?
        //

        if (NextSubKey < End) {
            //
            // Yes, call pFindPatternKeyWorker recursively
            //

            MatchOffset = pFindPatternKeyWorker (
                                NextSubKey,
                                End,
                                GetKeyStruct (Offset)->NextLevelRoot,
                                EndPatternAllowed
                                );

            if (MatchOffset != INVALID_OFFSET) {
                //
                // We found one match.  There may be others, but
                // we return this one.
                //

                return MatchOffset;
            }

        } else {
            //
            // No, if this is an endpoint, return the match.
            //

            KeyStruct = GetKeyStruct (Offset);

            if (KeyStruct->Flags & KSF_ENDPOINT) {
                return Offset;
            }
        }

        // Continue enumeration
        Offset = pFindPatternKeyStruct (RootOffset, Offset, SubKey);
    }

    //
    // The normal search failed.  Now we test for an endpoint that has
    // just an asterisk.  If we find one, we return it as our match.
    // This only applies when we have more subkeys, and EndPatternAllowed
    // is TRUE.
    //

    if (NextSubKey < End && EndPatternAllowed) {
        // Begin another enumeration of the matches
        Offset = pFindPatternKeyStruct (RootOffset, INVALID_OFFSET, SubKey);

        while (Offset != INVALID_OFFSET) {
            //
            // If EndPatternAllowed is TRUE, then test this offset
            // for an exact match with an asterisk.
            //

            KeyStruct = GetKeyStruct (Offset);

            if (KeyStruct->Flags & KSF_ENDPOINT) {
                if (StringMatchW (GetKeyToken (KeyStruct->KeyToken), L"*")) {
                    return Offset;
                }
            }

            // Continue enumeration
            Offset = pFindPatternKeyStruct (RootOffset, Offset, SubKey);
        }
    }


    //
    // No match was found
    //

    return INVALID_OFFSET;
}



DWORD
FindKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKeyUsingPattern locates a key string using a pattern
  and returns the offset to the KEYSTRUCT, or INVALID_OFFSET
  if the key path does not exist.  Each part of the stored key
  is treated as a literal string.

Arguments:

  RootOffset  - An offset to the level's binary tree root

  FullKeyPath - A backslash-delimited key path to a value
                with optional wildcards.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, NextLevelOffset;

    StringCopyW (Path, FullKeyPath);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, '\\');
    if (p) {
        End = _wcsinc (p);
        *p = 0;
    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Offset = pFindKeyStructUsingPattern (RootOffset, INVALID_OFFSET, Start);

    //
    // If this is the last level, we may have found the key!
    //

    if (!End) {
        while (Offset != INVALID_OFFSET) {
            if (GetKeyStruct (Offset)->Flags & KSF_ENDPOINT) {
                return Offset;
            }

            Offset = pFindKeyStructUsingPattern (RootOffset, Offset, Start);
        }
    }

    //
    // Otherwise recursively examine next level
    //

    while (Offset != INVALID_OFFSET) {

        //
        // Look at all subkeys for a match
        //

        NextLevelOffset = GetKeyStruct (Offset)->NextLevelRoot;
        NextLevelOffset = FindKeyUsingPattern (NextLevelOffset, End);

        //
        // When the recursive search succeeded, propagate the return value
        //

        if (NextLevelOffset != INVALID_OFFSET) {
            return NextLevelOffset;
        }

        //
        // No match, continue looking in this level for another match
        //

        Offset = pFindKeyStructUsingPattern (RootOffset, Offset, Start);
    }

    return INVALID_OFFSET;
}


DWORD
FindPatternKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  pFindPatternKeyUsingPattern locates a patterned key string
  using a pattern and returns the offset to the KEYSTRUCT,
  or INVALID_OFFSET if the key path does not exist.  Each
  part of the key is treated as a pattern.

Arguments:

  RootOffset          - An offset to the level's binary tree root
  FullKeyPath - A backslash-delimited key path to a value
                    with optional wildcards.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, NextLevelOffset;

    StringCopyW (Path, FullKeyPath);
    End = Path;

    // Split string at backslash
    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = p + 1;
        *p = 0;
    }
    else
        End = NULL;

    // Look at this level for the very first key
    Offset = pFindPatternKeyStructUsingPattern (RootOffset, INVALID_OFFSET, Start);

    // If this is the last level, we may have found the key!
    if (!End) {
        while (Offset != INVALID_OFFSET) {
            if (GetKeyStruct (Offset)->Flags & KSF_ENDPOINT)
                return Offset;

            Offset = pFindPatternKeyStructUsingPattern (RootOffset, Offset, Start);
        }
    }

    // Otherwise recursively examine next level
    while (Offset != INVALID_OFFSET) {

        // Look at all subkeys for a match
        NextLevelOffset = GetKeyStruct (Offset)->NextLevelRoot;
        NextLevelOffset = FindPatternKeyUsingPattern (NextLevelOffset, End);

        // When the recursive search succeeded, propagate the return value
        if (NextLevelOffset != INVALID_OFFSET)
            return NextLevelOffset;

        // No match, continue looking in this level for another match
        Offset = pFindPatternKeyStructUsingPattern (RootOffset, Offset, Start);
    }

    return INVALID_OFFSET;
}


DWORD
pNewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive,
    IN  BOOL Endpoint
    )

/*++

Routine Description:

  NewKey allocates a key struct off our heap, and links it into the binary
  tree.  KeyStr must be a full key path, and any part of the path that does
  not exist will be created.  KeyStr must not already exist (though parts
  of it can exist).

Arguments:

  KeyStr - The full path to the value, separated by backslashes.
           Each string between backslashes will cause a key
           struct to be allocated and linked.  Some of the
           structs may already have been allocated.

  KeyStrWithHive - The full path to the value, plus the hive
                   prefix (if any).  Can be the same as KeyStr
                   if there is no hive prefix.

  Endpoint - Specifies TRUE if new node is an endpoint, or FALSE if
             it is not.

Return Value:

  An offset to the last node of the new structure, or
  INVALID_OFFSET if the key could not be allocated.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, ThisLevelRoot;
    PDWORD ParentOffsetPtr;
    PKEYSTRUCT KeyStruct;
    DWORD LastLevel;
    BOOL NewNodeCreated = FALSE;

    StringCopyW (Path, KeyStr);
    End = Path;
    ThisLevelRoot = g_db->FirstLevelRoot;
    ParentOffsetPtr = &g_db->FirstLevelRoot;
    LastLevel = INVALID_OFFSET;

    do  {
        // Split string at backslash
        Start = End;
        p = wcschr (End, L'\\');
        if (p) {
            End = p + 1;
            *p = 0;
        }
        else
            End = NULL;

        // Look in tree for key
        if (!NewNodeCreated) {
            Offset = FindKeyStruct (ThisLevelRoot, Start);
        } else {
            Offset = INVALID_OFFSET;
        }

        if (Offset == INVALID_OFFSET) {
            // Add a new key if it was not found
            Offset = pAllocKeyStruct (ParentOffsetPtr, Start, LastLevel);
            if (Offset == INVALID_OFFSET) {
                return Offset;
            }

            NewNodeCreated = TRUE;
        }

        // Continue to next level
        KeyStruct = GetKeyStruct (Offset);
        LastLevel = Offset;
        ThisLevelRoot = KeyStruct->NextLevelRoot;
        ParentOffsetPtr = &KeyStruct->NextLevelRoot;
    } while (End);

    if (Endpoint) {
        if (!(KeyStruct->Flags & KSF_ENDPOINT)) {
            NewNodeCreated = TRUE;
        }

        KeyStruct->Flags |= KSF_ENDPOINT;

        if (NewNodeCreated) {
            AddHashTableEntry (KeyStr, Offset);
        }
    }

    return Offset;
}


DWORD
NewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive
    )
{
    return pNewKey (KeyStr, KeyStrWithHive, TRUE);
}


VOID
DeleteKey (
    IN      PCWSTR KeyStr,
    IN OUT  PDWORD RootPtr,
    IN      BOOL MustMatch
    )

/*++

Routine Description:

  DeleteKey takes a key path and puts the key struct in the deleted
  block chain.  Any sub-levels are deleted as well.  Optionally,
  the binary tree in which the key participates in may be updated.

Arguments:

  KeyStr     - The full path to the value, separated by backslashes.
  RootPtr    - A pointer to the level's binary tree root variable.
               If necessary, the variable is updated.
  MustMatch  - A flag indicating if the delete only applies to
               end points or if any matching struct is to be deleted.
               TRUE indicates only endpoints can be deleted.

Return Value:

  none

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset;
    DWORD NextOffset;
    PKEYSTRUCT KeyStruct;

    INCSTAT(g_Deletions);

    StringCopyW (Path, KeyStr);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = _wcsinc (p);
        *p = 0;

    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Offset = pFindKeyStructUsingPattern (*RootPtr, INVALID_OFFSET, Start);

    //
    // If this is the last level, delete the matching keys
    // (may need to be endpoints if MustMatch is TRUE)
    //

    if (!End) {
        while (Offset != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Offset);
            NextOffset = pFindKeyStructUsingPattern (*RootPtr, Offset, Start);

            //
            // If must match and lower levels exist, don't delete, just turn
            // off the endpoint flag
            //

            if (MustMatch && KeyStruct->NextLevelRoot != INVALID_OFFSET) {
                // Call to clean up, not to delink or recurse
                pDeallocKeyStruct (Offset, RootPtr, FALSE, TRUE);
            }

            //
            // Else delete the struct if an endpoint or don't care about
            // endpoints
            //

            else if (!MustMatch || (KeyStruct->Flags & KSF_ENDPOINT)) {
                // Call to free the entire key struct and all children
                pDeallocKeyStruct (Offset, RootPtr, TRUE, FALSE);
            }

            Offset = NextOffset;
        }
    }

    //
    // Otherwise recursively examine next level for each match
    //

    else {
        while (Offset != INVALID_OFFSET) {
            //
            // Delete all matching subkeys
            //

            NextOffset = pFindKeyStructUsingPattern (*RootPtr, Offset, Start);
            DeleteKey (End, &GetKeyStruct (Offset)->NextLevelRoot, MustMatch);

            //
            // If this is not an endpoint and has no children, delete it
            //

            KeyStruct = GetKeyStruct (Offset);
            if (KeyStruct->NextLevelRoot == INVALID_OFFSET &&
                !(KeyStruct->Flags & KSF_ENDPOINT)
                ) {
                // Call to free the entire key struct
                pDeallocKeyStruct (Offset, RootPtr, TRUE, FALSE);
            }

            //
            // Continue looking in this level for another match
            //

            Offset = NextOffset;
        }
    }
}


VOID
CopyValToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    )
{
    if (ValPtr) {
        if (!(KeyStruct->Flags & KSF_BINARY)) {
            *ValPtr = KeyStruct->dwValue;
        } else {
            *ValPtr = 0;
        }
    }
}


VOID
CopyFlagsToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    )
{
    if (ValPtr) {
        *ValPtr = KeyStruct->Flags & KSF_USERFLAG_MASK;
    }
}


BOOL
PrivateBuildKeyFromOffset (
    IN      DWORD StartLevel,               // zero-based
    IN      DWORD TailOffset,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PDWORD ValPtr,                  OPTIONAL
    OUT     PDWORD UserFlagsPtr,            OPTIONAL
    OUT     PDWORD Chars                    OPTIONAL
    )

/*++

Routine Description:

  PrivateBuildKeyFromOffset generates the key string given an offset.  The
  caller can specify the start level to skip root nodes.  It is assumed that
  TailOffset is always valid.

Arguments:

  StartLevel   - Specifies the zero-based level to begin building the key
                 string.  This is used to skip the root portion of the key
                 string.
  TailOffset   - Specifies the offset to the last level of the key string.
  Buffer       - Receives the key string, must be able to hold MEMDB_MAX
                 characters.
  ValPtr       - Receives the key's value
  UserFlagsPtr - Receives the user flags
  Chars        - Receives the number of characters in Buffer

Return Value:

  TRUE if the key was build properly, FALSE otherwise.

--*/

{
    static DWORD Offsets[MEMDB_MAX];
    PKEYSTRUCT KeyStruct;
    DWORD CurrentOffset;
    DWORD OffsetEnd;
    DWORD OffsetStart;
    register PWSTR p;
    register PCWSTR s;

    //
    // Build string
    //

    OffsetEnd = MEMDB_MAX;
    OffsetStart = OffsetEnd;

    CurrentOffset = TailOffset;
    while (CurrentOffset != INVALID_OFFSET) {
        //
        // Record offset
        //
        OffsetStart--;
        Offsets[OffsetStart] = CurrentOffset;

        //
        // Dec for start level and go to parent
        //
        CurrentOffset = pGetKeyStructWithProxy (CurrentOffset)->PrevLevelNode;
    }

    //
    // Filter for "string is not long enough"
    //
    OffsetStart += StartLevel;
    if (OffsetStart >= OffsetEnd) {
        return FALSE;
    }

    //
    // Transfer node's value and flags to caller's variables
    //
    CopyValToPtr (pGetKeyStructWithProxy (TailOffset), ValPtr);
    CopyFlagsToPtr (pGetKeyStructWithProxy (TailOffset), UserFlagsPtr);

    //
    // Copy each piece of the string to Buffer and calculate character count
    //
    if (Buffer) {
        p = Buffer;
        for (CurrentOffset = OffsetStart ; CurrentOffset < OffsetEnd ; CurrentOffset++) {
            KeyStruct = pGetKeyStructWithProxy (Offsets[CurrentOffset]);
            s = GetKeyToken (KeyStruct->KeyToken);
            while (*s) {
                *p++ = *s++;
            }
            *p++ = L'\\';
        }
        p--;
        *p = 0;

        if (Chars) {
            *Chars = (p - Buffer) / sizeof (WCHAR);
        }

    } else if (Chars) {
        *Chars = 0;

        for (CurrentOffset = OffsetStart ; CurrentOffset < OffsetEnd ; CurrentOffset++) {
            KeyStruct = pGetKeyStructWithProxy (Offsets[CurrentOffset]);
            *Chars += wcslen(GetKeyToken (KeyStruct->KeyToken)) + 1;
        }

        *Chars -= 1;
    }

    return TRUE;
}


UINT
pComputeTokenHash (
    IN      PCWSTR KeyName
    )
{
    UINT hash;

    hash = 0;
    while (*KeyName) {
        hash = (hash << 1) ^ (*KeyName++);
    }

    return hash % TOKENBUCKETS;
}


DWORD
pFindKeyToken (
    IN      PCWSTR KeyName,
    OUT     PUINT Hash
    )
{
    DWORD offset;
    PTOKENSTRUCT tokenStruct;
    INT cmp;

    *Hash = pComputeTokenHash (KeyName);

    offset = g_db->TokenBuckets[*Hash];

    while (offset != INVALID_OFFSET) {
        tokenStruct = (PTOKENSTRUCT) (g_db->Buf + offset);
        if (StringMatchW (tokenStruct->String, KeyName)) {
            break;
        }

        offset = tokenStruct->Right;
    }

    return offset;
}


DWORD
pAllocKeyToken (
    IN      PCWSTR KeyName,
    OUT     PINT AdjustFactor
    )
{
    PTOKENSTRUCT tokenStruct;
    PTOKENSTRUCT tokenParent;
    DWORD tokenOffset;
    UINT size;
    PDWORD parentToChildLink;
    DWORD newNodeParentOffset;
    DWORD pivotPoint;
    INT cmp;
    UINT hash;

    //
    // Use existing token first
    //

    tokenOffset = pFindKeyToken (KeyName, &hash);
    if (tokenOffset != INVALID_OFFSET) {
        *AdjustFactor = 0;
        return tokenOffset;
    }

    //
    // Existing token does not exist -- allocate a new one
    //

    size = sizeof (TOKENSTRUCT) + SizeOfStringW (KeyName);

    tokenStruct = (PTOKENSTRUCT) pAllocMemoryFromDb (
                                        size,
                                        &tokenOffset,
                                        AdjustFactor
                                        );

    tokenStruct->Right = g_db->TokenBuckets[hash];
    StringCopyW (tokenStruct->String, KeyName);
    g_db->TokenBuckets[hash] = tokenOffset;

    return tokenOffset;
}


VOID
pDeallocToken (
    IN      DWORD Token
    )
{
    return;
}


PCWSTR
GetKeyToken (
    IN      DWORD Token
    )
{
    PTOKENSTRUCT tokenStruct;

    tokenStruct = (PTOKENSTRUCT) (g_db->Buf + Token);
    return tokenStruct->String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\binvals.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    binvals.c

Abstract:

    Routines to manage binary blocks associated with memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif


static PBINARYBLOCK g_FirstBlockPtr = NULL;

//
// Implementation
//

PBYTE
pGetBinaryData (
    IN      PBINARYBLOCK BlockPtr
    )

/*++

Routine Description:

  pGetBinaryData returns a pointer to the data portion of a
  BINARYBLOCK struct.

Arguments:

  BlockPtr - A pointer to a BINARYBLOCK struct.

Return Value:

  A pointer to the binary data of BlockPtr, or NULL if BlockPtr
  is invalid.

--*/

{
#ifdef DEBUG

    // Verify checked block is valid
    if (BlockPtr && BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((
            DBG_ERROR,
            "Signature of %x is invalid, can't get binary data",
            g_FirstBlockPtr
            ));
        return NULL;
    }
#endif

    if (!BlockPtr) {
        return NULL;
    }

    return BlockPtr->Data;
}


DWORD
pGetBinaryDataSize (
    IN      PBINARYBLOCK BlockPtr
    )
{
#ifdef DEBUG
    // Verify checked block is valid
    if (BlockPtr && BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((
            DBG_ERROR,
            "Signature of %x is invalid, can't get binary data",
            g_FirstBlockPtr
            ));
        return 0;
    }
#endif

    if (!BlockPtr) {
        return 0;
    }

    return BlockPtr->Size - sizeof (BINARYBLOCK);
}


PCBYTE
GetKeyStructBinaryData (
    PKEYSTRUCT KeyStruct
    )
{
    if (!KeyStruct || !(KeyStruct->Flags & KSF_BINARY)) {
        return NULL;
    }

    return pGetBinaryData (KeyStruct->BinaryPtr);
}


DWORD
GetKeyStructBinarySize (
    PKEYSTRUCT KeyStruct
    )
{
    if (!KeyStruct || !(KeyStruct->Flags & KSF_BINARY)) {
        return 0;
    }

    return pGetBinaryDataSize (KeyStruct->BinaryPtr);
}


PBINARYBLOCK
pGetFirstBinaryBlock (
    VOID
    )

/*++

Routine Description:

  pGetFristBinaryBlock returns a pointer to the first allocated
  BINARYBLOCK struct, or NULL if no structs are allocated.  This
  routine is used with pGetNextBinaryBlock to walk all allocated
  blocks.

Arguments:

  none

Return Value:

  A pointer to the the first allocated BINARYBLOCK struct, or NULL
  if there are no structs allocated.

--*/

{
#ifdef DEBUG
    // Verify checked block is valid
    if (g_FirstBlockPtr && g_FirstBlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "First binary block %x signature is invalid", g_FirstBlockPtr));
        return NULL;
    }
#endif

    return g_FirstBlockPtr;
}


PBINARYBLOCK
pGetNextBinaryBlock (
    IN      PBINARYBLOCK BlockPtr
    )

/*++

Routine Description:

  pGetNextBinaryBlock returns a pointer to the next allocated
  BINARYBLOCK struct, or NULL if no more blocks are allocated.

Arguments:

  BlockPtr - The non-NULL return value of pGetFirstBinaryBlock or
             pGetNextBinaryBlock

Return Value:

  A pointer to the next BINARYBLOCK struct, or NULL if no more blocks
  are allocated.

--*/

{
    if (!BlockPtr) {
        return NULL;
    }

#ifdef DEBUG
    // Verify checked block is valid
    if (BlockPtr->NextPtr && BlockPtr->NextPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Binary block %x signature is invalid", BlockPtr->NextPtr));
        return NULL;
    }
#endif

    return BlockPtr->NextPtr;
}


PBINARYBLOCK
AllocBinaryBlock (
    IN      PCBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD OwningKey
    )

/*++

Routine Description:

  AllocBinaryBlock returns a pointer to an initialized BINARYBLOCK
  structure, or NULL if the structure could not be allocated.  If
  the structure is allocated, Data is copied to the newly allocated
  block.  Call pFreeBinaryBlock to clean up this allocation.

Arguments:

  Data      - A pointer to a block of binary data to be copied into
              the newly allocated structure
  DataSize  - The number of bytes to copy (may be zero)
  OwningKey - The offset of the key who owns the data block

Return Value:

  A pointer to the binary block structure, or NULL if it could not
  be allocated.

--*/

{
    PBINARYBLOCK BlockPtr;
    DWORD AllocSize;

    AllocSize = DataSize + sizeof (BINARYBLOCK);

    BlockPtr = (PBINARYBLOCK) MemAlloc (g_hHeap, 0, AllocSize);
    if (!BlockPtr) {
        // DataSize must be bigger than 2G
        OutOfMemory_Terminate();
    }

    //
    // Initialize block struct
    //

    if (DataSize) {
        CopyMemory (BlockPtr->Data, Data, DataSize);
    }

    BlockPtr->Size = AllocSize;
    BlockPtr->OwningKey = OwningKey;

#ifdef DEBUG
    BlockPtr->Signature = SIGNATURE;
#endif

    //
    // Link block to list of allocated blocks
    //

    BlockPtr->NextPtr = g_FirstBlockPtr;
    if (g_FirstBlockPtr) {
        g_FirstBlockPtr->PrevPtr = BlockPtr;
    }
    g_FirstBlockPtr = BlockPtr;

    BlockPtr->PrevPtr = NULL;

    //
    // Return
    //

    return BlockPtr;
}


VOID
pFreeBinaryBlock (
    PBINARYBLOCK BlockPtr,
    BOOL Delink
    )

/*++

Routine Description:

  pFreeBinaryBlock frees memory allocated for a binary block and optionally
  delinks it from the allocation list.

Arguments:

  BlockPtr  - A pointer to the block to delete
  Delink    - TRUE if structure should be delinked from allocation list,
              or FALSE if the allocation list does not need to be maintained

Return Value:

  none

--*/

{
    if (!BlockPtr) {
        return;
    }

#ifdef DEBUG
    if (BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Can't free block %x because signature is invalid", BlockPtr));
        return;
    }
#endif

    if (Delink) {

#ifdef DEBUG

        if (BlockPtr->PrevPtr && BlockPtr->PrevPtr->Signature != SIGNATURE) {
            DEBUGMSG ((DBG_ERROR, "Can't free block %x because prev block (%x) signature is invalid", BlockPtr, BlockPtr->PrevPtr));
            return;
        }

        if (BlockPtr->NextPtr && BlockPtr->NextPtr->Signature != SIGNATURE) {
            DEBUGMSG ((DBG_ERROR, "Can't free block %x because next block (%x) signature is invalid", BlockPtr, BlockPtr->NextPtr));
            return;
        }

#endif

        if (BlockPtr->PrevPtr) {
            BlockPtr->PrevPtr->NextPtr = BlockPtr->NextPtr;
        } else {
            g_FirstBlockPtr = BlockPtr->NextPtr;
        }

        if (BlockPtr->NextPtr) {
            BlockPtr->NextPtr->PrevPtr = BlockPtr->PrevPtr;
        }
    }

    MemFree (g_hHeap, 0, BlockPtr);
}


VOID
FreeKeyStructBinaryBlock (
    PKEYSTRUCT KeyStruct
    )

/*++

Routine Description:

  FreeKeyStructBinaryBlock frees a binary block and resets the
  KSF_BINARY flag, if the key struct has a binary block allocated.

Arguments:

  none

Return Value:

  none

--*/

{
    if (KeyStruct->Flags & KSF_BINARY) {
        pFreeBinaryBlock (KeyStruct->BinaryPtr, TRUE);
        KeyStruct->BinaryPtr = NULL;
        KeyStruct->Flags &= ~KSF_BINARY;
    }
}


VOID
FreeAllBinaryBlocks (
    VOID
    )

/*++

Routine Description:

  FreeAllBinaryBlocks removes all memory associated with binary
  blocks.  This function is used for final cleanup.

Arguments:

  none

Return Value:

  none

--*/

{
    PBINARYBLOCK NextBlockPtr;

    while (g_FirstBlockPtr) {
        NextBlockPtr = g_FirstBlockPtr->NextPtr;
        pFreeBinaryBlock (g_FirstBlockPtr, FALSE);
        g_FirstBlockPtr = NextBlockPtr;
    }
}


BOOL
LoadBinaryBlocks (
    HANDLE File
    )
{
    BOOL b;
    DWORD Count;
    DWORD Owner = 0;
    DWORD Size;
    DWORD Read;
    DWORD d;
    PBYTE TempBuf = NULL;
    PBINARYBLOCK NewBlock;

    b = ReadFile (File, &Count, sizeof (DWORD), &Read, NULL);

    if (b && Count) {
        //
        // Alloc binary objects
        //

        for (d = 0 ; b && d < Count ; d++) {
            // Get Size and Owner
            b = ReadFile (File, &Size, sizeof (DWORD), &Read, NULL);
            if (Size > BLOCK_SIZE * 32) {
                b = FALSE;
            }
            if (b) {
                b = ReadFile (File, &Owner, sizeof (DWORD), &Read, NULL);
            }

            // Alloc a temporary buffer to read in data
            if (b) {
                TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, Size);

                b = ReadFile (File, TempBuf, Size, &Read, NULL);

                // If data read OK, create binary block object
                if (b) {
                    NewBlock = AllocBinaryBlock (TempBuf, Size, Owner);
                    if (!NewBlock) {
                        b = FALSE;
                    } else {
                        // Link owner to new memory location
                        MYASSERT (GetKeyStruct (Owner)->Flags & KSF_BINARY);
                        GetKeyStruct(Owner)->BinaryPtr = NewBlock;
                    }
                }

                MemFree (g_hHeap, 0, TempBuf);
                TempBuf = NULL;
            }
        }
    }

    if (TempBuf) {
        MemFree (g_hHeap, 0, TempBuf);
    }

    return b;
}


BOOL
SaveBinaryBlocks (
    HANDLE File
    )
{
    BOOL b;
    DWORD Count;
    DWORD Size;
    PBINARYBLOCK BinaryPtr;
    DWORD Written;

    //
    // Count the binary objects
    //

    BinaryPtr = pGetFirstBinaryBlock();
    Count = 0;

    while (BinaryPtr) {
        Count++;
        BinaryPtr = pGetNextBinaryBlock (BinaryPtr);
    }

    //
    // Write count to disk
    //
    b = WriteFile (File, &Count, sizeof (DWORD), &Written, NULL);

    if (b) {
        //
        // Write the binary objects
        //

        BinaryPtr = pGetFirstBinaryBlock();

        while (b && BinaryPtr) {
            //
            // Format per object:
            //
            //  Size    (DWORD)
            //  Owner   (DWORD)
            //  Data    (Size)
            //

            Size = pGetBinaryDataSize (BinaryPtr);
            b = WriteFile (File, &Size, sizeof (DWORD), &Written, NULL);

            if (b) {
                b = WriteFile (File, &BinaryPtr->OwningKey, sizeof (DWORD), &Written, NULL);
            }

            if (b && Size) {
                b = WriteFile (File, pGetBinaryData (BinaryPtr), Size, &Written, NULL);
                if (Written != Size) {
                    b = FALSE;
                }
            }

            BinaryPtr = pGetNextBinaryBlock(BinaryPtr);
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\memdb.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdb.c

Abstract:

    A simple memory-based database for associating flags
    with a string.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     23-Sep-1998  Expanded user flags to 24 bits (from 12 bits)
    calinn      12-Dec-1997  Extended MemDbMakePrintableKey and MemDbMakeNonPrintableKey
    jimschm     03-Dec-1997  Added multi-thread synchronization
    jimschm     22-Oct-1997  Split into multiple source files,
                             added multiple memory block capability
    jimschm     16-Sep-1997  Hashing: delete fix
    jimschm     29-Jul-1997  Hashing, user flags added
    jimschm     07-Mar-1997  Signature changes
    jimschm     03-Mar-1997  PrivateBuildKeyFromOffset changes
    jimschm     18-Dec-1996  Fixed deltree bug

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif


//
// Global delcaration
//

PDATABASE g_db;
GROWLIST g_DatabaseList = GROWLIST_INIT;
BYTE g_SelectedDatabase;
PHIVE g_HeadHive;
CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG

#define FILE_SIGNATURE DEBUG_FILE_SIGNATURE
BOOL g_UseDebugStructs = TRUE;

#else

#define FILE_SIGNATURE RETAIL_FILE_SIGNATURE

#endif

//
// Private prototypes
//

INT
pCreateDatabase (
    PCWSTR Name
    );

BOOL
pInitializeDatabase (
    OUT     PDATABASE Database,
    IN      PCWSTR Name
    );

BOOL
pFreeDatabase (
    IN OUT  PDATABASE Database
    );

VOID
pFreeSelectedDatabase (
    VOID
    );

VOID
pFreeAllDatabases (
    VOID
    );

BOOL
pPrivateMemDbGetValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    );

BOOL
pInitializeMemDb (
    VOID
    );


//
// Implementation
//


BOOL
MemDb_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD Reason,
    IN PVOID lpv
    )

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  Reason    - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (Reason) {

    case DLL_PROCESS_ATTACH:
        if (!pInitializeMemDb()) {
            return FALSE;
        }

        InitializeCriticalSection (&g_MemDbCs);

        InitOperationTable();

        break;

    case DLL_PROCESS_DETACH:
        pFreeAllDatabases();
        FreeGrowList (&g_DatabaseList);
        DeleteCriticalSection (&g_MemDbCs);

        DumpBinTreeStats();

        break;
    }

    return TRUE;
}


BOOL
pInitializeMemDb (
    VOID
    )
{
    FreeGrowList (&g_DatabaseList);
    ZeroMemory (&g_DatabaseList, sizeof (g_DatabaseList));
    g_db = NULL;

    if (!InitializeHashBlock()) {
        return FALSE;
    }

    if (pCreateDatabase (L"") != 0) {
        return FALSE;
    }

    g_SelectedDatabase = 1;
    SelectDatabase (0);

    return TRUE;
}




BOOL
pInitializeDatabase (
    OUT     PDATABASE Database,
    IN      PCWSTR Name
    )
{
    UINT u;

    Database->AllocSize = BLOCK_SIZE;

    Database->Buf = (PBYTE) MemAlloc (g_hHeap, 0, Database->AllocSize);

    Database->End = 0;
    Database->FirstLevelRoot = INVALID_OFFSET;
    Database->FirstDeleted = INVALID_OFFSET;

    MYASSERT (INVALID_OFFSET == 0xFFFFFFFF);
    FillMemory (Database->TokenBuckets, sizeof (Database->TokenBuckets), 0xFF);

    _wcssafecpy (Database->Hive, Name, MAX_HIVE_NAME);

    return TRUE;
}

BOOL
pFreeDatabase (
    IN OUT  PDATABASE Database
    )
{
    if (Database->Buf) {
        MemFree (g_hHeap, 0, Database->Buf);
        Database->Buf = NULL;
    }
    Database->End = 0;
    Database->FirstLevelRoot = INVALID_OFFSET;
    Database->FirstDeleted = INVALID_OFFSET;
    Database->Hive[0] = 0;

    return TRUE;
}


INT
pCreateDatabase (
    PCWSTR Name
    )
{
    DATABASE Database;
    BYTE Index;
    UINT Count;
    UINT u;

    //
    // Does key exist already?
    //

    if (g_db) {
        SelectDatabase (0);

        if (INVALID_OFFSET != FindKeyStruct (g_db->FirstLevelRoot, Name)) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot create %ls because it already exists!", Name));
            SetLastError (ERROR_ALREADY_EXISTS);
            return -1;
        }
    }

    //
    // Scan list for a blank spot
    //

    Count = GrowListGetSize (&g_DatabaseList);
    for (u = 0 ; u < Count ; u++) {
        if (!GrowListGetItem (&g_DatabaseList, u)) {
            break;
        }
    }

    if (u < Count) {
        //
        // Use empty slot
        //

        Index = (BYTE) u;
    } else if (Count < 256) {
        //
        // No empty slot; grow the list
        //

        Index = (BYTE) Count;
        if (!GrowListAppend (&g_DatabaseList, NULL, 0)) {
            DEBUGMSG ((DBG_WARNING, "Could not create database because GrowListAppend failed"));
            return -1;
        }
    } else {
        DEBUGMSG ((DBG_ERROR, "Cannot have more than 256 databases in memdb!"));
        return -1;
    }

    //
    // Create the database memory block
    //

    pInitializeDatabase (&Database, Name);

    if (!GrowListSetItem (&g_DatabaseList, (UINT) Index, (PBYTE) &Database, sizeof (Database))) {
        DEBUGMSG ((DBG_WARNING, "Could not create database because GrowListSetItem failed"));
        pFreeDatabase (&Database);
        return -1;
    }

    return (INT) Index;
}


VOID
pDestroySelectedDatabase (
    VOID
    )
{
    //
    // Free all resources for the database
    //

    pFreeSelectedDatabase ();

    //
    // For all databases except for the root, free the DATABASE
    // structure in g_DatabaseList.
    //

    if (g_SelectedDatabase) {
        GrowListResetItem (&g_DatabaseList, (UINT) g_SelectedDatabase);
    }
}


VOID
pFreeSelectedDatabase (
    VOID
    )
{
    //
    // Free all resources used by a single database
    //

    if (g_db->Buf) {
        MemFree (g_hHeap, 0, g_db->Buf);
    }

    FreeAllBinaryBlocks();

    ZeroMemory (g_db, sizeof (DATABASE));
}


VOID
pFreeAllDatabases (
    VOID
    )
{
    UINT Count;
    UINT Index;

    //
    // Free all database blocks
    //

    Count = GrowListGetSize (&g_DatabaseList);
    for (Index = 0 ; Index < Count ; Index++) {
        if (SelectDatabase ((BYTE) Index)) {
            pDestroySelectedDatabase();
        }
    }

    //
    // Free global hash table
    //

    FreeHashBlock();

    SelectDatabase(0);
}


BOOL
SelectDatabase (
    BYTE DatabaseId
    )
{
    PDATABASE Database;

    if (g_SelectedDatabase == DatabaseId) {
        return TRUE;
    }

    Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, (UINT) DatabaseId);
    if (!Database) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: Invalid database selection!"));
        return FALSE;
    }

    g_db = Database;
    g_SelectedDatabase = DatabaseId;

    return TRUE;
}


PCWSTR
SelectHive (
    PCWSTR FullKeyStr
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    PCWSTR End;

    //
    // Determine if root of FullKeyStr is part of a hive
    //

    End = wcschr (FullKeyStr, L'\\');
    if (End) {
        Count = GrowListGetSize (&g_DatabaseList);
        for (Index = 1 ; Index < Count ; Index++) {
            Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

            if (Database && StringIMatchABW (Database->Hive, FullKeyStr, End)) {
                //
                // Match found; select the database and return the subkey
                //

                SelectDatabase ((BYTE) Index);
                End = _wcsinc (End);
                return End;
            }
        }
    }
    SelectDatabase (0);

    return FullKeyStr;
}


BOOL
IsTemporaryKey (
    PCWSTR FullKeyStr
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    PCWSTR End;

    End = wcschr (FullKeyStr, L'\\');
    if (!End) {
        End = GetEndOfStringW (FullKeyStr);
    }
    Count = GrowListGetSize (&g_DatabaseList);
    for (Index = 1 ; Index < Count ; Index++) {
        Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

        if (Database && StringIMatchABW (Database->Hive, FullKeyStr, End)) {
            //
            // Match found; return true
            //
            return TRUE;
        }
    }
    return FALSE;
}


//
// MemDbSetValue creates or modifies KeyStr.  The value of the key is changed
// when the return value is TRUE.
//

BOOL
PrivateMemDbSetValueA (
    PCSTR Key,
    DWORD Val,
    DWORD SetFlags,
    DWORD ClearFlags,
    PDWORD Offset
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (Key);
    if (p) {
        b = PrivateMemDbSetValueW (p, Val, SetFlags, ClearFlags, Offset);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
PrivateMemDbSetValueW (
    PCWSTR Key,
    DWORD Val,
    DWORD SetFlags,
    DWORD ClearFlags,
    PDWORD Offset
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (Key);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            KeyOffset = NewKey (SubKey, Key);
            if (KeyOffset == INVALID_OFFSET) {
                __leave;
            }
        }

        KeyStruct = GetKeyStruct (KeyOffset);
        FreeKeyStructBinaryBlock (KeyStruct);

        KeyStruct->dwValue = Val;
        if (Offset) {
            *Offset = KeyOffset | (g_SelectedDatabase << RESERVED_BITS);
        }
        KeyStruct->Flags = KeyStruct->Flags & ~(ClearFlags & KSF_USERFLAG_MASK);
        KeyStruct->Flags = KeyStruct->Flags | (SetFlags & KSF_USERFLAG_MASK);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


BOOL
PrivateMemDbSetBinaryValueA (
    IN      PCSTR Key,
    IN      PCBYTE Data,
    IN      DWORD SizeOfData,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (Key);
    if (p) {
        b = PrivateMemDbSetBinaryValueW (p, Data, SizeOfData, Offset);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
PrivateMemDbSetBinaryValueW (
    IN      PCWSTR Key,
    IN      PCBYTE Data,
    IN      DWORD SizeOfData,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (Key);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            KeyOffset = NewKey (SubKey, Key);
            if (KeyOffset == INVALID_OFFSET) {
                __leave;
            }

        }

        KeyStruct = GetKeyStruct (KeyOffset);

        // Free existing buffer
        FreeKeyStructBinaryBlock (KeyStruct);

        // Alloc new buffer
        KeyStruct->BinaryPtr = AllocBinaryBlock (Data, SizeOfData, KeyOffset);
        if (!KeyStruct->BinaryPtr) {
            __leave;
        }

        KeyStruct->Flags |= KSF_BINARY;

        if (Offset) {
            *Offset = KeyOffset | (g_SelectedDatabase << RESERVED_BITS);
        }

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


BOOL
MemDbSetValueA (
    IN  PCSTR KeyStr,
    IN  DWORD dwValue
    )
{
    return PrivateMemDbSetValueA (KeyStr, dwValue, 0, 0, NULL);
}

BOOL
MemDbSetValueW (
    IN  PCWSTR KeyStr,
    IN  DWORD dwValue
    )
{
    return PrivateMemDbSetValueW (KeyStr, dwValue, 0, 0, NULL);
}

BOOL
MemDbSetValueAndFlagsA (
    IN  PCSTR KeyStr,
    IN  DWORD dwValue,
    IN  DWORD SetUserFlags,
    IN  DWORD ClearUserFlags
    )
{
    return PrivateMemDbSetValueA (KeyStr, dwValue, SetUserFlags, ClearUserFlags, NULL);
}

BOOL
MemDbSetValueAndFlagsW (
    IN  PCWSTR KeyStr,
    IN  DWORD dwValue,
    IN  DWORD SetUserFlags,
    IN  DWORD ClearUserFlags
    )
{
    return PrivateMemDbSetValueW (KeyStr, dwValue, SetUserFlags, ClearUserFlags, NULL);
}

BOOL
MemDbSetBinaryValueA (
    IN      PCSTR KeyStr,
    IN      PCBYTE Data,
    IN      DWORD DataSize
    )
{
    return PrivateMemDbSetBinaryValueA (KeyStr, Data, DataSize, NULL);
}


BOOL
MemDbSetBinaryValueW (
    IN      PCWSTR KeyStr,
    IN      PCBYTE Data,
    IN      DWORD DataSize
    )
{
    return PrivateMemDbSetBinaryValueW (KeyStr, Data, DataSize, NULL);
}



//
// GetValue takes a full key string and returns the
// value to the caller-supplied DWORD.  Value
// may be NULL to check only for existance of the
// value.
//

BOOL
pPrivateMemDbGetValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = pPrivateMemDbGetValueW (p, Value, UserFlagsPtr);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
pPrivateMemDbGetValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyStr);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);
        CopyFlagsToPtr (GetKeyStruct (KeyOffset), UserFlagsPtr);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbGetValueA (
    IN  PCSTR Key,
    OUT PDWORD ValuePtr         OPTIONAL
    )
{
    return pPrivateMemDbGetValueA (Key, ValuePtr, NULL);
}

BOOL
MemDbGetValueW (
    IN  PCWSTR Key,
    OUT PDWORD ValuePtr         OPTIONAL
    )
{
    return pPrivateMemDbGetValueW (Key, ValuePtr, NULL);
}

BOOL
MemDbGetValueAndFlagsA (
    IN  PCSTR Key,
    OUT PDWORD ValuePtr,        OPTIONAL
    OUT PDWORD UserFlagsPtr
    )
{
    return pPrivateMemDbGetValueA (Key, ValuePtr, UserFlagsPtr);
}

BOOL
MemDbGetValueAndFlagsW (
    IN  PCWSTR Key,
    OUT PDWORD ValuePtr,       OPTIONAL
    OUT PDWORD UserFlagsPtr
    )
{
    return pPrivateMemDbGetValueW (Key, ValuePtr, UserFlagsPtr);
}


PCBYTE
MemDbGetBinaryValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD DataSize        OPTIONAL
    )
{
    PCWSTR p;
    BYTE const * b = NULL;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetBinaryValueW (p, DataSize);
        FreeConvertedStr (p);
    }

    return b;
}

PCBYTE
MemDbGetBinaryValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD DataSize        OPTIONAL
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    PCBYTE Result = NULL;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyStr);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        KeyStruct = GetKeyStruct (KeyOffset);

        if (DataSize) {
            *DataSize = GetKeyStructBinarySize (KeyStruct);
        }

        Result = GetKeyStructBinaryData (KeyStruct);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return Result;
}


//
// GetPatternValue takes a full key string and returns the
// value to the caller-supplied DWORD.  The stored value string
// is treated as a pattern, but KeyStr is not a pattern.
// The return value represents the first match found.
//

BOOL
MemDbGetPatternValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetPatternValueW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
MemDbGetPatternValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SubKey = SelectHive (KeyStr);

        KeyOffset = FindPatternKey (g_db->FirstLevelRoot, SubKey, FALSE);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


//
// MemDbGetStoredEndPatternValue takes a full key string and returns the
// value to the caller-supplied DWORD.  The stored value string
// is treated as a pattern, but KeyStr is not a pattern.
// The return value represents the first match found.
//
// If the last stored key segment is an asterisk, then the pattern
// is considered to match.
//

BOOL
MemDbGetStoredEndPatternValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetStoredEndPatternValueW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
MemDbGetStoredEndPatternValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SubKey = SelectHive (KeyStr);

        KeyOffset = FindPatternKey (g_db->FirstLevelRoot, SubKey, TRUE);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


//
// GetValueWithPattern takes a full key string that may contain
// wildcards between the backslashes, and returns the value
// to the caller-supplied DWORD.  The stored value string
// is not treated as a pattern.  The return value represents
// the first match found.
//

BOOL
MemDbGetValueWithPatternA (
    IN  PCSTR KeyPattern,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyPattern);
    if (p) {
        b = MemDbGetValueWithPatternW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
MemDbGetValueWithPatternW (
    IN  PCWSTR KeyPattern,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyPattern);

        KeyOffset = FindKeyUsingPattern (g_db->FirstLevelRoot, SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}



BOOL
MemDbGetPatternValueWithPatternA (
    IN  PCSTR KeyPattern,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyPattern);
    if (p) {
        b = MemDbGetPatternValueWithPatternW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
MemDbGetPatternValueWithPatternW (
    IN  PCWSTR KeyPattern,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyPattern);

        KeyOffset = FindPatternKeyUsingPattern (g_db->FirstLevelRoot, SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


VOID
MemDbDeleteValueA (
    IN  PCSTR KeyStr
    )
{
    PCWSTR p;

    p = ConvertAtoW (KeyStr);
    if (p) {
        MemDbDeleteValueW (p);
        FreeConvertedStr (p);
    }
}

VOID
MemDbDeleteValueW (
    IN  PCWSTR KeyStr
    )
{
    PCWSTR SubKey;

    EnterCriticalSection (&g_MemDbCs);

    SubKey = SelectHive (KeyStr);
    DeleteKey (SubKey, &g_db->FirstLevelRoot, TRUE);

    LeaveCriticalSection (&g_MemDbCs);
}


VOID
MemDbDeleteTreeA (
    IN  PCSTR KeyStr
    )
{
    PCWSTR p;

    p = ConvertAtoW (KeyStr);
    if (p) {
        MemDbDeleteTreeW (p);
        FreeConvertedStr (p);
    }
}

VOID
MemDbDeleteTreeW (
    IN  PCWSTR KeyStr
    )
{
    PCWSTR SubKey;

    EnterCriticalSection (&g_MemDbCs);

    SubKey = SelectHive (KeyStr);
    DeleteKey (SubKey, &g_db->FirstLevelRoot, FALSE);

    LeaveCriticalSection (&g_MemDbCs);
}


//
// Enum functions
//

BOOL
MemDbEnumFirstValueA (
    OUT     PMEMDB_ENUMA EnumPtr,
    IN      PCSTR PatternStr,
    IN      INT Depth,
    IN      DWORD Flags
    )
{
    BOOL b = FALSE;
    PCWSTR p;
    PCSTR str;
    MEMDB_ENUMW enumw;

    p = ConvertAtoW (PatternStr);
    if (p) {
        b = MemDbEnumFirstValueW (&enumw, p, Depth, Flags);
        FreeConvertedStr (p);
    } else {
        b = FALSE;
    }

    if (b) {
        str = ConvertWtoA (enumw.szName);
        if (str) {
            // ANSI struct is padded to match UNICODE
            MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
            CopyMemory (EnumPtr, &enumw, sizeof (MEMDB_ENUMW));

            // Only the output key name needs to be converted
            StringCopyA (EnumPtr->szName, str);
            FreeConvertedStr (str);
        } else {
            b = FALSE;
        }
    }

    return b;
}

BOOL
MemDbEnumFirstValueW (
    OUT     PMEMDB_ENUMW EnumPtr,
    IN      PCWSTR PatternStr,
    IN      INT Depth,
    IN      DWORD Flags
    )
{
    PCWSTR Start;
    PCWSTR wstrLastWack;
    PCWSTR SubPatternStr;

    SubPatternStr = SelectHive (PatternStr);

    //
    // Init the EnumPtr struct
    //

    ZeroMemory (EnumPtr, sizeof (MEMDB_ENUM));

    if (!Depth) {
        Depth = MAX_ENUM_POS;
    }

    EnumPtr->Depth = Depth;
    EnumPtr->Flags = Flags;

    //
    // If pattern has wack, locate the starting level by
    // counting the number of parts that do not have
    // wildcard characters.
    //

    Start = SubPatternStr;
    while (wstrLastWack = wcschr (Start, L'\\')) {

        // See if part has a wildcard character
        while (Start < wstrLastWack) {
            if (*Start == L'*' || *Start == L'?')
                break;
            Start++;
        }

        // If a wildcard character was found, we have to stop here
        if (Start < wstrLastWack)
            break;

        // Otherwise, look at next part of the pattern
        Start = wstrLastWack + 1;
        EnumPtr->Start++;
    }

    EnumPtr->PosCount = 1;
    EnumPtr->LastPos[0] = INVALID_OFFSET;
    StringCopyW (EnumPtr->PatternStr, PatternStr);

    return MemDbEnumNextValueW (EnumPtr);
}


BOOL
MemDbEnumNextValueA (
    IN OUT  PMEMDB_ENUMA EnumPtr
    )
{
    BOOL b = FALSE;
    PCSTR str;
    MEMDB_ENUMW enumw;

    // ANSI struct is padded to match UNICODE
    MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
    CopyMemory (&enumw, EnumPtr, sizeof (MEMDB_ENUMW));

    // ANSI output members are ignored (i.e. EnumPtr->szName)
    b = MemDbEnumNextValueW (&enumw);

    if (b) {
        str = ConvertWtoA (enumw.szName);
        if (str) {
            // ANSI struct is padded to match UNICODE
            MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
            CopyMemory (EnumPtr, &enumw, sizeof (MEMDB_ENUMW));

            // Only the output key name needs to be converted
            StringCopyA (EnumPtr->szName, str);
            FreeConvertedStr (str);
        } else {
            b = FALSE;
        }
    }

    return b;
}

BOOL
MemDbEnumNextValueW (
    IN OUT  PMEMDB_ENUMW EnumPtr
    )
{
    // no init allowed in declarations
    PKEYSTRUCT KeyStruct = NULL;
    int Count;
    int Level;
    WCHAR PartBuf[MEMDB_MAX];
    PWSTR PartStr;
    PWSTR Src, Dest;
    int Pos;
    BOOL Wildcard;
    BOOL MatchNotFound;
    PCWSTR SubPatternStr;

    EnterCriticalSection (&g_MemDbCs);

    SubPatternStr = SelectHive (EnumPtr->PatternStr);

    MatchNotFound = TRUE;

    do {

        Wildcard = FALSE;

        //
        // The following states exist upon entry:
        //
        //   STATE                        DESCRIPTION
        // First time through   PosCount == 1, LastPos[0] == INVALID_OFFSET
        //
        // Not first time       LastPos[PosCount - 1] == INVALID_OFFSET
        // through
        //
        // Not first time       LastPos[PosCount - 1] != INVALID_OFFSET
        // through, last match
        // hit the depth
        // ceiling
        //
        // PosCount points to the current unprocessed level, or when the
        // depth ceiling is reached, it points to the level of the last
        // match.
        //

        do {
            //
            // Build PartStr
            //

            Pos = EnumPtr->PosCount - 1;
            Count = Pos + 1;

            // Locate start of pattern part (if it is long enough)
            PartStr = PartBuf;
            for (Src = (PWSTR) SubPatternStr ; Count > 1 ; Count--) {

                Src = wcschr (Src, L'\\');

                if (!Src) {
                    break;
                }

                Src++;
            }

            // Copy part from pattern to buffer
            if (Src) {
                Dest = PartStr;
                while (*Src && *Src != L'\\') {
                    *Dest = *Src;
                    Wildcard = Wildcard || (*Dest == L'*') || (*Dest == L'?');
                    Dest++;
                    Src++;
                }

                // Truncate
                *Dest = 0;
            }

            // Use asterisk when pattern is shorter than current level
            else {
                PartStr = L"*";
                Wildcard = TRUE;
            }

            //
            // If current level is set to invalid offset, we have not yet
            // tried it.
            //

            if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {

                //
                // Initialize the level
                //

                if (Pos == 0) {
                    EnumPtr->LastPos[0] = g_db->FirstLevelRoot;
                } else {
                    KeyStruct = GetKeyStruct (EnumPtr->LastPos[Pos - 1]);
                    EnumPtr->LastPos[Pos] = KeyStruct->NextLevelRoot;
                }

                //
                // If still invalid, the level is complete, and we need to
                // go back.
                //

                if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                    EnumPtr->PosCount--;
                    continue;
                }

                //
                // Level ready to be processed
                //

                if (!Wildcard) {
                    //
                    // Use binary tree to locate this item.  If no match, the pattern
                    // will not match anything.  Otherwise, we found something to
                    // return.
                    //

                    EnumPtr->LastPos[Pos] = FindKeyStruct (EnumPtr->LastPos[Pos], PartStr);
                    if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                        //
                        // Non-wildcard ot found.  We can try going back because
                        // there might be a pattern at a higher level.
                        //
                        if (Pos > 0) {
                            PCWSTR p;
                            INT ParentLevel = 0;
                            INT LastParentLevel;

                            LastParentLevel = 0;

                            // Locate the previous pattern level
                            p = SubPatternStr;
                            while (*p && ParentLevel < Pos) {
                                // Locate wack, pattern or nul
                                while (*p && *p != L'\\') {
                                    if (*p == L'?' || *p == L'*') {
                                        break;
                                    }
                                    p++;
                                }

                                // If pattern or nul, set last pattern level
                                if (*p != L'\\') {
                                    LastParentLevel = ParentLevel + 1;

                                    // Jump to wack if not at nul
                                    while (*p && *p != L'\\') {
                                        p++;
                                    }
                                }

                                // If more pattern exists, skip wack
                                if (p[0] && p[1]) {
                                    MYASSERT (p[0] == L'\\');
                                    p++;
                                }
                                ParentLevel++;
                            }

                            // Default: when no pattern, last pattern level is parent
                            // (Pos is zero-based while LastParentLevel is one-based)
                            if (!(*p)) {
                                LastParentLevel = Pos;
                            }

                            if (LastParentLevel) {
                                // Yes, a pattern does exist at a higher level
                                EnumPtr->PosCount = LastParentLevel;
                                continue;
                            }
                        }

                        // Pattern not found, we have exhausted all possibilities
                        LeaveCriticalSection (&g_MemDbCs);
                        return FALSE;
                    }

                    // If level is before start, keep searching forward instead
                    // of reporting a result.

                    if (EnumPtr->PosCount <= EnumPtr->Start) {
                        EnumPtr->PosCount++;
                        EnumPtr->LastPos[Pos + 1] = INVALID_OFFSET;
                        continue;
                    }

                    // Break out of last nested loop
                    break;
                } else {
                    //
                    // Because of pattern, each item in the level must be examined.
                    // Set the pos to the first item and fall through to the pattern
                    // search code.
                    //

                    EnumPtr->LastPos[Pos] = GetFirstOffset (EnumPtr->LastPos[Pos]);
                }

            //
            // Else if current level is not invalid, last time through we had a
            // match and we need to increment the offset (wildcard patterns only).
            //

            } else {

                if (Wildcard) {
                    EnumPtr->LastPos[Pos] = GetNextOffset (EnumPtr->LastPos[Pos]);

                    // If there are no more items, go back a level
                    if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                        EnumPtr->PosCount--;
                        continue;
                    }
                }
            }

            //
            // If we are here, it is because we are looking at a level, trying
            // to find a pattern match.  Loop until either a match is found,
            // or we run out of items.
            //
            // The only exception is when the last match hit the depth ceiling
            // and PartStr does not have a wildcard.  In this case, we must
            // reset the last pos and go back one level.
            //

            if (Wildcard) {
                do  {
                    // Get current key, advance, then check current key against pattern
                    KeyStruct = GetKeyStruct (EnumPtr->LastPos[Pos]);
                    if (IsPatternMatch (PartStr, GetKeyToken (KeyStruct->KeyToken)))
                        break;

                    EnumPtr->LastPos[Pos] = GetNextOffset (EnumPtr->LastPos[Pos]);
                } while (EnumPtr->LastPos[Pos] != INVALID_OFFSET);

                // Match found so break out of last nested loop
                if (EnumPtr->LastPos[Pos] != INVALID_OFFSET)
                    break;
            } else {
                EnumPtr->LastPos[Pos] = INVALID_OFFSET;
            }

            //
            // We ran out of items before finding a match, so it is time to
            // go back up a level.
            //

            EnumPtr->PosCount--;
        } while (EnumPtr->PosCount);

        // Return if no items found
        if (!EnumPtr->PosCount) {
            LeaveCriticalSection (&g_MemDbCs);
            return FALSE;
        }

        //
        // A match was found.  Build output string and prepare position for
        // next level.
        //

        // Build the name of the item and get the value
        EnumPtr->szName[0] = 0;
        for (Level = EnumPtr->Start ; Level < EnumPtr->PosCount ; Level++) {
            PWSTR namePointer = EnumPtr->szName;
            KeyStruct = GetKeyStruct (EnumPtr->LastPos[Level]);
            if (Level > EnumPtr  -> Start) {
                namePointer = _wcsappend(namePointer,L"\\");
            }
            _wcsappend (namePointer, GetKeyToken (KeyStruct->KeyToken));
        }

        MYASSERT (KeyStruct);
        EnumPtr->bEndpoint = (KeyStruct->Flags & KSF_ENDPOINT) != 0;
        EnumPtr->bBinary   = (KeyStruct->Flags & KSF_BINARY) != 0;
        EnumPtr->bProxy = (KeyStruct->Flags & KSF_PROXY_NODE) != 0;
        EnumPtr->UserFlags = (KeyStruct->Flags & KSF_USERFLAG_MASK);
        EnumPtr->BinaryPtr = GetKeyStructBinaryData (KeyStruct);
        EnumPtr->BinarySize = GetKeyStructBinarySize (KeyStruct);
        if (EnumPtr->bBinary) {
            EnumPtr->dwValue = 0;
        } else {
            EnumPtr->dwValue   = KeyStruct->dwValue;
        }

        EnumPtr->Offset = EnumPtr->LastPos[Pos] | (g_SelectedDatabase << RESERVED_BITS);

        // Prepare position for next level
        if ((EnumPtr->PosCount + 1) <= (EnumPtr->Depth + EnumPtr->Start)) {
            EnumPtr->LastPos[Pos + 1] = INVALID_OFFSET;
            EnumPtr->PosCount++;
        }

        switch (EnumPtr->Flags) {

        case MEMDB_ALL_MATCHES:
            MatchNotFound = FALSE;
            break;

        case MEMDB_ENDPOINTS_ONLY:
            MatchNotFound = (KeyStruct->Flags & (KSF_ENDPOINT|KSF_PROXY_NODE)) != KSF_ENDPOINT;
            break;

        case MEMDB_BINARY_NODES_ONLY:
            MatchNotFound = (KeyStruct->Flags & KSF_BINARY) == 0;
            break;

        case MEMDB_PROXY_NODES_ONLY:
            MatchNotFound = (KeyStruct->Flags & KSF_PROXY_NODE) == 0;
            break;

        case MEMDB_ALL_BUT_PROXY:
            MatchNotFound = (KeyStruct->Flags & KSF_PROXY_NODE) != 0;
            break;
        }

    // Loop until flag match is found
    } while (MatchNotFound);

    LeaveCriticalSection (&g_MemDbCs);
    return TRUE;
}


//
// Save and restore functions
//

BOOL
pPrivateMemDbSave (
    PCWSTR FileName,
    BOOL bUnicode
    )
{
    HANDLE FileHandle;
    BOOL b = FALSE;
    DWORD BytesWritten;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SelectDatabase(0);

        if (bUnicode) {
            FileHandle = CreateFileW (FileName, GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        } else {
            FileHandle = CreateFileA ((PCSTR) FileName, GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        }

        if (FileHandle == INVALID_HANDLE_VALUE) {
            if (bUnicode) {
                DEBUGMSGW ((DBG_ERROR, "Can't open %s", FileName));
            } else {
                DEBUGMSGA ((DBG_ERROR, "Can't open %s", FileName));
            }
            __leave;
        }

        // entire file written in UNICODE char set
        b = WriteFile (FileHandle, FILE_SIGNATURE, sizeof(FILE_SIGNATURE), &BytesWritten, NULL);

        if (b) {
            b = WriteFile (FileHandle, g_db, sizeof (DATABASE), &BytesWritten, NULL);
        }

        if (b) {
            b = WriteFile (FileHandle, g_db->Buf, g_db->AllocSize, &BytesWritten, NULL);
            if (BytesWritten != g_db->AllocSize)
                b = FALSE;
        }

        if (b) {
            b = SaveHashBlock (FileHandle);
        }

        if (b) {
            b = SaveBinaryBlocks (FileHandle);
        }

        PushError();
        CloseHandle (FileHandle);
        PopError();

        if (!b) {
            if (bUnicode) {
                DEBUGMSGW ((DBG_ERROR, "Error writing %s", FileName));
                DeleteFileW (FileName);
            } else {
                DEBUGMSGA ((DBG_ERROR, "Error writing %s", FileName));
                DeleteFileA ((PCSTR) FileName);
            }
            __leave;
        }

        MYASSERT (b == TRUE);
    }
    __finally {
        PushError();
        LeaveCriticalSection (&g_MemDbCs);
        PopError();
    }

    return b;
}

BOOL
MemDbSaveA (
    PCSTR FileName
    )
{
    return pPrivateMemDbSave ((PCWSTR) FileName, FALSE);        // FALSE=ANSI
}


BOOL
MemDbSaveW (
    PCWSTR FileName
    )
{
    return pPrivateMemDbSave (FileName, TRUE);                   // TRUE=UNICODE
}


BOOL
pPrivateMemDbLoad (
    IN      PCWSTR FileName,
    IN      BOOL bUnicode,
    OUT     PMEMDB_VERSION Version,                 OPTIONAL
    IN      BOOL QueryVersionOnly
    )
{
    HANDLE FileHandle;
    BOOL b;
    DWORD BytesRead;
    WCHAR Buf[sizeof(FILE_SIGNATURE)];
    PBYTE TempBuf = NULL;
    PCWSTR VerPtr;

    EnterCriticalSection (&g_MemDbCs);

    if (Version) {
        ZeroMemory (Version, sizeof (MEMDB_VERSION));
    }

    //
    // Blow away existing resources
    //

    if (!QueryVersionOnly) {
        pFreeAllDatabases();
    }

    //
    // Load in file
    //

    if (*FileName && FileName) {
        if (bUnicode) {
            FileHandle = CreateFileW (FileName, GENERIC_READ, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        } else {
            FileHandle = CreateFileA ((PCSTR) FileName, GENERIC_READ, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }
    } else {
        FileHandle = INVALID_HANDLE_VALUE;
    }

    b = (FileHandle != INVALID_HANDLE_VALUE);

    __try {
        //
        // Obtain the file signature
        //
        // NOTE: Entire file read is in UNICODE char set
        //

        if (b) {
            b = ReadFile (FileHandle, Buf, sizeof(FILE_SIGNATURE), &BytesRead, NULL);

            if (Version) {
                if (StringMatchByteCountW (
                        VERSION_BASE_SIGNATURE,
                        Buf,
                        sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR)
                        )) {

                    Version->Valid = TRUE;

                    //
                    // Identify version number
                    //

                    VerPtr = (PCWSTR) ((PBYTE) Buf + sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR));

                    if (StringMatchByteCountW (
                            MEMDB_VERSION,
                            VerPtr,
                            sizeof (MEMDB_VERSION) - sizeof (WCHAR)
                            )) {
                        Version->CurrentVersion = TRUE;
                    }

                    Version->Version = (UINT) _wtoi (VerPtr + 1);

                    //
                    // Identify checked or free build
                    //

                    VerPtr += (sizeof (MEMDB_VERSION) / sizeof (WCHAR)) - 1;

                    if (StringMatchByteCountW (
                            MEMDB_DEBUG_SIGNATURE,
                            VerPtr,
                            sizeof (MEMDB_DEBUG_SIGNATURE) - sizeof (WCHAR)
                            )) {

                        Version->Debug = TRUE;

                    } else if (!StringMatchByteCountW (
                                    VerPtr,
                                    MEMDB_NODBG_SIGNATURE,
                                    sizeof (MEMDB_NODBG_SIGNATURE) - sizeof (WCHAR)
                                    )) {
                        Version->Valid = FALSE;
                    }
                }
            }
        }

        if (QueryVersionOnly) {
            b = FALSE;
        }

        if (b) {
            b = StringMatchW (Buf, FILE_SIGNATURE);

    #ifdef DEBUG
            //
            // This code allows a debug build of memdb to work with both
            // debug and retail versions of the DAT file
            //

            if (!b) {
                if (StringMatchW (Buf, DEBUG_FILE_SIGNATURE)) {
                    g_UseDebugStructs = TRUE;
                    b = TRUE;
                } else if (StringMatchW (Buf, RETAIL_FILE_SIGNATURE)) {
                    DEBUGMSG ((DBG_ERROR, "memdb dat file is from free build; checked version expected"));
                    g_UseDebugStructs = FALSE;
                    b = TRUE;
                }
            }
    #else
            if (!b) {
                SetLastError (ERROR_BAD_FORMAT);
                LOG ((LOG_WARNING, "Warning: data file could be from checked build; free version expected"));
            }
    #endif
        }

        //
        // Obtain the database struct
        //

        if (b) {
            b = ReadFile (FileHandle, (PBYTE) g_db, sizeof (DATABASE), &BytesRead, NULL);
            if (BytesRead != sizeof (DATABASE)) {
                b = FALSE;
                SetLastError (ERROR_BAD_FORMAT);
            }
        }

        //
        // Allocate the memory block
        //

        if (b) {
            TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_db->AllocSize);
            if (TempBuf) {
                g_db->Buf = TempBuf;
                TempBuf = NULL;
            } else {
                b = FALSE;
            }
        }

        //
        // Read the memory block
        //

        if (b) {
            b = ReadFile (FileHandle, g_db->Buf, g_db->AllocSize, &BytesRead, NULL);
            if (BytesRead != g_db->AllocSize) {
                b = FALSE;
                SetLastError (ERROR_BAD_FORMAT);
            }
        }

        //
        // Read the hash table
        //

        if (b) {
            b = LoadHashBlock (FileHandle);
        }

        //
        // Read binary blocks
        //

        if (b) {
            b = LoadBinaryBlocks (FileHandle);
        }
    }

    __except (TRUE) {
        b = FALSE;
        PushError();
        LOG ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", FileName));

        FreeAllBinaryBlocks();
        PopError();
    }

    PushError();
    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (FileHandle);
    }

    if (!b && !QueryVersionOnly) {
        pFreeAllDatabases();
        pInitializeMemDb();
    }

    LeaveCriticalSection (&g_MemDbCs);
    PopError();

    if (QueryVersionOnly) {
        return TRUE;
    }

    return b;
}


BOOL
MemDbLoadA (
    IN PCSTR FileName
    )
{
    return pPrivateMemDbLoad ((PCWSTR) FileName, FALSE, NULL, FALSE);
}

BOOL
MemDbLoadW (
    IN PCWSTR FileName
    )
{
    return pPrivateMemDbLoad (FileName, TRUE, NULL, FALSE);
}


BOOL
MemDbValidateDatabase (
    VOID
    )
{
    MEMDB_ENUMW e;

    if (MemDbEnumFirstValueW (&e, L"*", 0, MEMDB_ENDPOINTS_ONLY)) {

        do {
            if (!pPrivateMemDbGetValueW (e.szName, NULL, NULL)) {
                return FALSE;
            }
        } while (MemDbEnumNextValueW (&e));
    }

    return TRUE;
}



BOOL
MemDbCreateTemporaryKeyA (
    IN      PCSTR KeyName
    )
{
    PCWSTR KeyNameW;
    BOOL b = FALSE;

    KeyNameW = ConvertAtoW (KeyName);

    if (KeyNameW) {
        b = MemDbCreateTemporaryKeyW (KeyNameW);
        FreeConvertedStr (KeyNameW);
    }

    return b;
}


BOOL
MemDbCreateTemporaryKeyW (
    IN      PCWSTR KeyName
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        if (wcslen (KeyName) >= MAX_HIVE_NAME) {
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        SubKey = SelectHive (KeyName);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            __leave;
        }

        Count = GrowListGetSize (&g_DatabaseList);
        for (Index = 1 ; Index < Count ; Index++) {
            Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

            if (Database && StringIMatchW (Database->Hive, KeyName)) {
                SetLastError (ERROR_ALREADY_EXISTS);
                __leave;
            }
        }

        b = pCreateDatabase (KeyName);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


/*++

Routine Description:

  MemDbMakeNonPrintableKey converts the double-backslashe pairs in a string
  to ASCII 1, a non-printable character.  This allows the caller to store
  properly escaped strings in MemDb.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakeNonPrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == '\\' &&
                _mbsnextc (_mbsinc (KeyName)) == '\\'
                ) {
                _setmbchar (KeyName, 1);
                KeyName = _mbsinc (KeyName);
                MYASSERT (_mbsnextc (KeyName) == '\\');
                _setmbchar (KeyName, 1);
            }

            DEBUGMSG_IF ((
                _mbsnextc (KeyName) == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == '*') {
                _setmbchar (KeyName, 2);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == '?') {
                _setmbchar (KeyName, 3);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakeNonPrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == L'\\' && KeyName[1] == L'\\') {
                KeyName[0] = 1;
                KeyName[1] = 1;
                KeyName++;
            }

            DEBUGMSG_IF ((
                KeyName[0] == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 2;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 3;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName++;
    }
}


/*++

Routine Description:

  MemDbMakePrintableKey converts the ASCII 1 characters to backslashes,
  restoring the string converted by MemDbMakeNonPrintableKey.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakePrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == 1) {
                _setmbchar (KeyName, '\\');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == 2) {
                _setmbchar (KeyName, '*');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == 3) {
                _setmbchar (KeyName, '?');
            }
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakePrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == 1) {
                KeyName[0] = L'\\';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == 2) {
                KeyName[0] = L'*';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == 3) {
                KeyName[0] = L'?';
            }
        }
        KeyName++;
    }
}


VOID
GetFixedUserNameA (
    IN OUT  PSTR SrcUserBuf
    )

/*++

Routine Description:

  GetFixedUserName looks in memdb for the user specified in SrcUserBuf,
  and if found, returns the changed name.

Arguments:

  SrcUserBuf - Specifies the user to look up as returned from the Win9x
               registry.  Receives the user name to create on NT.

Return Value:

  None.

--*/

{
    CHAR EncodedName[MEMDB_MAX];
    CHAR FixedName[MEMDB_MAX];

    StringCopyA (EncodedName, SrcUserBuf);
    MemDbMakeNonPrintableKeyA (
        EncodedName,
        MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1|
            MEMDB_CONVERT_WILD_STAR_TO_ASCII_2|
            MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3
        );

    if (MemDbGetEndpointValueExA (
            MEMDB_CATEGORY_FIXEDUSERNAMESA,
            EncodedName,
            NULL,
            FixedName
            )) {
        StringCopyA (SrcUserBuf, FixedName);
    }
}


VOID
GetFixedUserNameW (
    IN OUT  PWSTR SrcUserBuf
    )

/*++

Routine Description:

  GetFixedUserName looks in memdb for the user specified in SrcUserBuf,
  and if found, returns the changed name.

Arguments:

  SrcUserBuf - Specifies the user to look up as returned from the Win9x
               registry.  Receives the user name to create on NT.

Return Value:

  None.

--*/

{
    WCHAR EncodedName[MEMDB_MAX];
    WCHAR FixedName[MEMDB_MAX];

    StringCopyW (EncodedName, SrcUserBuf);
    MemDbMakeNonPrintableKeyW (
        EncodedName,
        MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1|
            MEMDB_CONVERT_WILD_STAR_TO_ASCII_2|
            MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3
        );

    if (MemDbGetEndpointValueExW (
            MEMDB_CATEGORY_FIXEDUSERNAMESW,
            EncodedName,
            NULL,
            FixedName
            )) {
        StringCopyW (SrcUserBuf, FixedName);
    }
}

/*
    The format of the binary file for MemDb export

    DWORD Signature

    DWORD Version

    DWORD GlobalFlags// 0x00000001 mask for Ansi format
                     // 0x00000002 mask for Temporary key

    BYTE Root[];     // The root of the tree (zero terminated).

    struct _KEY {

        WORD Flags;  // 0xF000 mask for accessing the entry flags
                     //     - 0x1000 - Mask for Key name (0 - root relative, 1 - previous key relative)
                     //     - 0x2000 - Mask for existing data (0 - no data, 1 - some data)
                     //     - 0x4000 - Mast for data type (0 - DWORD, 1 - binary data)
                     //     - 0x8000 - Mast for key flags (0 - nonexistent, 1 - existent)
                     // 0x0FFF mask for accessing size of the entry (except the data)

        BYTE Key[];  // Should be PCSTR or PCWSTR (not zero terminated)

        DWORD KeyFlags; //optional (dependant on Flags).

        BYTE Data[]; // optional (dependant on Flags).
                     // if BLOB first DWORD is the size of the BLOB
                     // if DWORD then has exactly 4 bytes
    }
    ...
*/

#define MEMDB_EXPORT_SIGNATURE              0x42444D4D
#define MEMDB_EXPORT_VERSION                0x00000001
#define MEMDB_EXPORT_FLAGS_ANSI             0x00000001
#define MEMDB_EXPORT_FLAGS_TEMP_KEY         0x00000002
#define MEMDB_EXPORT_FLAGS_PREV_RELATIVE    0x1000
#define MEMDB_EXPORT_FLAGS_DATA_PRESENT     0x2000
#define MEMDB_EXPORT_FLAGS_BINARY_DATA      0x4000
#define MEMDB_EXPORT_FLAGS_FLAGS_PRESENT    0x8000
#define MEMDB_EXPORT_FLAGS_SIZE_MASK        0x0FFF

BOOL
pMemDbExportWorkerA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCWSTR uRootTree;
    PCSTR lastWackPtr;
    DWORD globalFlags;
    WORD localFlags;
    CHAR key[MEMDB_MAX];
    DWORD keySize;
    DWORD copySize;
    MEMDB_ENUMA e;
    WORD blobSize;
    DWORD written;

    fileHandle = CreateFileA (FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    globalFlags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_VERSION;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_FLAGS_ANSI;

    // get the information if this key is a temporary key and set the flags if true
    uRootTree = ConvertAtoW (RootTree);
    if (IsTemporaryKey (uRootTree)) {
        globalFlags |= MEMDB_EXPORT_FLAGS_TEMP_KEY;
    }
    FreeConvertedStr (uRootTree);

    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // now write the root tree
    WriteFile (fileHandle, RootTree, SizeOfStringA (RootTree), &written, NULL);

    MemDbBuildKeyA (key, RootTree, "*", NULL, NULL);

    if (MemDbEnumFirstValueA (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        key [0] = 0;
        keySize = 0;
        do {
            // initialize the flags
            localFlags = 0;
            if (e.bBinary) {
                localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                localFlags |= MEMDB_EXPORT_FLAGS_BINARY_DATA;
            } else {
                if (e.dwValue) {
                    localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                }
            }
            if (e.UserFlags) {
                localFlags |= MEMDB_EXPORT_FLAGS_FLAGS_PRESENT;
            }

            // let's compute the size for this blob
            blobSize = sizeof (WORD); // Flags

            if (keySize &&
                StringIMatchByteCountA (key, e.szName, keySize - sizeof (CHAR)) &&
                (e.szName [keySize - 1] == '\\')
                ) {
                localFlags |= MEMDB_EXPORT_FLAGS_PREV_RELATIVE;
                copySize = SizeOfStringA (e.szName) - keySize - sizeof (CHAR);
            } else {
                copySize = SizeOfStringA (e.szName) - sizeof (CHAR);
                keySize = 0;
            }
            MYASSERT (copySize < 4096);
            blobSize += (WORD) copySize;

            localFlags |= blobSize;

            // write the flags
            WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

            // write the key
            WriteFile (fileHandle, ((PBYTE) e.szName) + keySize, copySize, &written, NULL);

            // write the key flags if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {
                WriteFile (fileHandle, &e.UserFlags, sizeof (DWORD), &written, NULL);
            }

            // write the data if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
                if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                    WriteFile (fileHandle, &e.BinarySize, sizeof (DWORD), &written, NULL);
                    WriteFile (fileHandle, e.BinaryPtr, e.BinarySize, &written, NULL);
                } else {
                    WriteFile (fileHandle, &e.dwValue, sizeof (DWORD), &written, NULL);
                }
            }
            lastWackPtr = _mbsrchr (e.szName, '\\');
            if (lastWackPtr) {
                keySize = ByteCountABA (e.szName, lastWackPtr) + sizeof (CHAR);
                StringCopyByteCountA (key, e.szName, keySize);
            } else {
                keySize = 0;
            }

        } while (MemDbEnumNextValueA (&e));
    }

    localFlags = 0;

    // finally write the zero terminator
    WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
pMemDbExportWorkerW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCWSTR lastWackPtr;
    DWORD globalFlags;
    WORD localFlags;
    WCHAR key[MEMDB_MAX];
    DWORD keySize;
    DWORD copySize;
    MEMDB_ENUMW e;
    WORD blobSize;
    DWORD written;

    fileHandle = CreateFileW (FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    globalFlags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_VERSION;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // get the information if this key is a temporary key and set the flags if true
    if (IsTemporaryKey (RootTree)) {
        globalFlags |= MEMDB_EXPORT_FLAGS_TEMP_KEY;
    }

    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // now write the root tree
    WriteFile (fileHandle, RootTree, SizeOfStringW (RootTree), &written, NULL);

    MemDbBuildKeyW (key, RootTree, L"*", NULL, NULL);

    if (MemDbEnumFirstValueW (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        key [0] = 0;
        keySize = 0;
        do {
            // initialize the flags
            localFlags = 0;
            if (e.bBinary) {
                localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                localFlags |= MEMDB_EXPORT_FLAGS_BINARY_DATA;
            } else {
                if (e.dwValue) {
                    localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                }
            }
            if (e.UserFlags) {
                localFlags |= MEMDB_EXPORT_FLAGS_FLAGS_PRESENT;
            }

            // let's compute the size for this blob
            blobSize = sizeof (WORD); // Flags

            if (keySize &&
                StringIMatchByteCountW (key, e.szName, keySize - sizeof (WCHAR)) &&
                (e.szName [keySize - 1] == L'\\')
                ) {
                localFlags |= MEMDB_EXPORT_FLAGS_PREV_RELATIVE;
                copySize = SizeOfStringW (e.szName) - keySize - sizeof (WCHAR);
            } else {
                copySize = SizeOfStringW (e.szName) - sizeof (WCHAR);
                keySize = 0;
            }
            MYASSERT (copySize < 4096);
            blobSize += (WORD) copySize;

            localFlags |= blobSize;

            // write the flags
            WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

            // write the key
            WriteFile (fileHandle, ((PBYTE) e.szName) + keySize, copySize, &written, NULL);

            // write the key flags if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {
                WriteFile (fileHandle, &e.UserFlags, sizeof (DWORD), &written, NULL);
            }

            // write the data if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
                if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                    WriteFile (fileHandle, &e.BinarySize, sizeof (DWORD), &written, NULL);
                    WriteFile (fileHandle, e.BinaryPtr, e.BinarySize, &written, NULL);
                } else {
                    WriteFile (fileHandle, &e.dwValue, sizeof (DWORD), &written, NULL);
                }
            }
            lastWackPtr = wcsrchr (e.szName, L'\\');
            if (lastWackPtr) {
                keySize = ByteCountABW (e.szName, lastWackPtr) + sizeof (WCHAR);
                StringCopyByteCountW (key, e.szName, keySize);
            } else {
                keySize = 0;
            }

        } while (MemDbEnumNextValueW (&e));
    }

    localFlags = 0;

    // finally write the zero terminator
    WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )

/*++

Routine Description:

  MemDbExportA exports a tree in a private binary format. The format is described above.

Arguments:

  RootTree - Specifies the tree to be exported
  FileName - Name of the binary format file to export to.
  AnsiFormat - Keys should be written in ANSI rather than in Unicode.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PCWSTR uRootTree, uFileName;
    BOOL result = TRUE;

    if (AnsiFormat) {
        result = pMemDbExportWorkerA (RootTree, FileName);
    } else {
        uRootTree = ConvertAtoW (RootTree);
        uFileName = ConvertAtoW (FileName);
        result = pMemDbExportWorkerW (uRootTree, uFileName);
        FreeConvertedStr (uFileName);
        FreeConvertedStr (uRootTree);
    }
    return result;
}

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    )

/*++

Routine Description:

  MemDbExportW exports a tree in a private binary format. The format is described above.

Arguments:

  RootTree - Specifies the tree to be exported
  FileName - Name of the binary format file to export to.
  AnsiFormat - Keys should be written in ANSI rather than in Unicode.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PCSTR aRootTree, aFileName;
    BOOL result = TRUE;

    if (!AnsiFormat) {
        result = pMemDbExportWorkerW (RootTree, FileName);
    } else {
        aRootTree = ConvertWtoA (RootTree);
        aFileName = ConvertWtoA (FileName);
        result = pMemDbExportWorkerA (aRootTree, aFileName);
        FreeConvertedStr (aFileName);
        FreeConvertedStr (aRootTree);
    }
    return result;
}

BOOL
pMemDbImportWorkerA (
    IN      PBYTE FileBuffer
    )
{
    DWORD globalFlags;
    WORD localFlags;
    PCSTR rootTree;
    CHAR lastKey [MEMDB_MAX];
    PSTR lastKeyPtr;
    CHAR node [MEMDB_MAX];
    CHAR localKey [MEMDB_MAX];
    DWORD flags = 0;

    globalFlags = *((PDWORD) FileBuffer);

    // FileBuffer will point to the tree that's imported
    FileBuffer += sizeof (DWORD);
    rootTree = (PCSTR) FileBuffer;

    if (globalFlags & MEMDB_EXPORT_FLAGS_TEMP_KEY) {
        // a temporary key was exported
        MemDbCreateTemporaryKeyA ((PCSTR) FileBuffer);
    }

    // let's pass the string
    FileBuffer = GetEndOfStringA ((PCSTR) FileBuffer) + sizeof (CHAR);

    // ok from this point on we read and add all keys
    lastKey [0] = 0;
    localFlags = *((PWORD) FileBuffer);

    while (localFlags) {

        localKey [0] = 0;

        StringCopyByteCountA (localKey, (PSTR)(FileBuffer + sizeof (WORD)), (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK) - sizeof (WORD) + sizeof (CHAR));

        MemDbBuildKeyA (node, rootTree, (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE)?lastKey:NULL, localKey, NULL);

        FileBuffer += (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK);

        MYASSERT (!((localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) && (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT)));

        if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {

            flags = *(PDWORD)FileBuffer;
            FileBuffer += sizeof (DWORD);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
            if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                MemDbSetBinaryValueA (node, FileBuffer + sizeof (DWORD), *(PDWORD)FileBuffer);
                FileBuffer += (*(PDWORD)FileBuffer + sizeof (DWORD));
            } else {
                MemDbSetValueAndFlagsA (node, *(PDWORD)FileBuffer, flags, 0);
                FileBuffer += sizeof (DWORD);
            }
        } else {
            MemDbSetValueA (node, 0);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE) {

            StringCatA (lastKey, "\\");
            StringCatA (lastKey, localKey);
            lastKeyPtr = _mbsrchr (lastKey, '\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        } else {

            StringCopyA (lastKey, localKey);
            lastKeyPtr = _mbsrchr (lastKey, '\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        }
        localFlags = *((PWORD) FileBuffer);
    }

    return TRUE;
}

BOOL
pMemDbImportWorkerW (
    IN      PBYTE FileBuffer
    )
{
    DWORD globalFlags;
    WORD localFlags;
    PCWSTR rootTree;
    WCHAR lastKey [MEMDB_MAX];
    PWSTR lastKeyPtr;
    WCHAR node [MEMDB_MAX];
    WCHAR localKey [MEMDB_MAX];
    DWORD flags = 0;

    globalFlags = *((PDWORD) FileBuffer);

    // FileBuffer will point to the tree that's imported
    FileBuffer += sizeof (DWORD);
    rootTree = (PCWSTR) FileBuffer;

    if (globalFlags & MEMDB_EXPORT_FLAGS_TEMP_KEY) {
        // a temporary key was exported
        MemDbCreateTemporaryKeyW ((PCWSTR) FileBuffer);
    }

    // let's pass the string
    FileBuffer = (PBYTE)GetEndOfStringW ((PCWSTR) FileBuffer) + sizeof (WCHAR);

    // ok from this point on we read and add all keys
    lastKey [0] = 0;
    localFlags = *((PWORD) FileBuffer);

    while (localFlags) {

        localKey [0] = 0;

        StringCopyByteCountW (localKey, (PWSTR)(FileBuffer + sizeof (WORD)), (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK) - sizeof (WORD) + sizeof (WCHAR));

        MemDbBuildKeyW (node, rootTree, (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE)?lastKey:NULL, localKey, NULL);

        FileBuffer += (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK);

        MYASSERT (!((localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) && (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT)));

        if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {

            flags = *(PDWORD)FileBuffer;
            FileBuffer += sizeof (DWORD);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
            if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                MemDbSetBinaryValueW (node, FileBuffer + sizeof (DWORD), *(PDWORD)FileBuffer);
                FileBuffer += (*(PDWORD)FileBuffer + sizeof (DWORD));
            } else {
                MemDbSetValueAndFlagsW (node, *(PDWORD)FileBuffer, flags, 0);
                FileBuffer += sizeof (DWORD);
            }
        } else {
            MemDbSetValueW (node, 0);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE) {

            StringCatW (lastKey, L"\\");
            StringCatW (lastKey, localKey);
            lastKeyPtr = wcsrchr (lastKey, L'\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        } else {

            StringCopyW (lastKey, localKey);
            lastKeyPtr = wcsrchr (lastKey, L'\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        }
        localFlags = *((PWORD) FileBuffer);
    }

    return TRUE;
}

BOOL
MemDbImportA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  MemDbImportA imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PBYTE fileBuff;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL result = TRUE;

    fileBuff = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGA ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        if (*((PDWORD) fileBuff) != MEMDB_EXPORT_SIGNATURE) {
            DEBUGMSGA ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            result = FALSE;
        } else {

            fileBuff += sizeof (DWORD);

            if (*((PDWORD) fileBuff) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGA ((DBG_ERROR, "Unknown version for file to import: %s", FileName));
                result = FALSE;

            } else {

                fileBuff += sizeof (DWORD);

                if (*((PDWORD) fileBuff) & MEMDB_EXPORT_FLAGS_ANSI) {
                    result = pMemDbImportWorkerA (fileBuff);
                } else {
                    result = pMemDbImportWorkerW (fileBuff);
                }
            }
        }
    }
    __except (1) {
        DEBUGMSGA ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return result;
}

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  MemDbImportW imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PBYTE fileBuff;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL result;

    fileBuff = MapFileIntoMemoryW (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGW ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        if (*((PDWORD) fileBuff) != MEMDB_EXPORT_SIGNATURE) {

            DEBUGMSGW ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            result = FALSE;

        } else {

            fileBuff += sizeof (DWORD);

            if (*((PDWORD) fileBuff) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGW ((DBG_ERROR, "Unknown version for file to import: %s", FileName));
                result = FALSE;

            } else {

                fileBuff += sizeof (DWORD);

                if (*((PDWORD) fileBuff) & MEMDB_EXPORT_FLAGS_ANSI) {
                    result = pMemDbImportWorkerA (fileBuff);
                } else {
                    result = pMemDbImportWorkerW (fileBuff);
                }
            }
        }
    }
    __except (1) {
        DEBUGMSGW ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return result;
}


BOOL
MemDbQueryVersionA (
    PCSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad ((PCWSTR) FileName, FALSE, Version, TRUE);

    return Version->Valid;
}


BOOL
MemDbQueryVersionW (
    PCWSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad (FileName, TRUE, Version, TRUE);

    return Version->Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\hash.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hashing routines used to speed lookup of memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif

#define DBG_MEMDB       "MemDb"

//
// Globals
//

DWORD g_HashSize;
DWORD g_HashEnd;
DWORD g_HashFreeHead;
PBYTE g_HashBuf;


//
// #defines
//

// see memdbp.h for bit restrictions
#define INVALID_OFFSET_MASKED (INVALID_OFFSET & OFFSET_MASK)
#define ASSERT_OFFSET_ONLY(x) MYASSERT(((x) & RESERVED_MASK) == 0 || (x) == INVALID_OFFSET)
#define UNMASK_OFFSET(x) ((x)==INVALID_OFFSET_MASKED ? INVALID_OFFSET : (x))
#define MASK_OFFSET(x) ((x) & OFFSET_MASK)

#define MASK_4BIT       0x0000000f
#define INVALID_OFFSET_4BIT (INVALID_OFFSET & MASK_4BIT)
#define ASSERT_4BIT(x) MYASSERT(((x) & (~MASK_4BIT)) == 0 || (x) == INVALID_OFFSET)
#define CONVERT_4TO8(x) ((BYTE) ((x)==INVALID_OFFSET_4BIT ? INVALID_OFFSET : (x)))
#define CONVERT_8TO4(x) ((x) & MASK_4BIT)

#define HASH_BUCKETS    39989
#define HASH_BLOCK_SIZE (HASH_BUCKETS * sizeof (BUCKETSTRUCT))
#define HASHBUFPTR(offset) ((PBUCKETSTRUCT) (g_HashBuf + offset))

//
// Local privates
//

VOID
pResetHashBlock (
    VOID
    );


//
// Implementation
//

BOOL
InitializeHashBlock (
    VOID
    )
{
    g_HashSize = HASH_BLOCK_SIZE * 2;

    g_HashBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_HashSize);
    pResetHashBlock();

    return TRUE;
}


VOID
pResetHashBlock (
    VOID
    )
{
    PBUCKETSTRUCT BucketPtr;
    INT i;

    g_HashEnd = HASH_BLOCK_SIZE;
    g_HashFreeHead = INVALID_OFFSET;

    BucketPtr = (PBUCKETSTRUCT) g_HashBuf;
    for (i = 0 ; i < HASH_BUCKETS ; i++) {
        BucketPtr->Offset = INVALID_OFFSET;
        BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;
        BucketPtr->Info.Hive = 0;
        BucketPtr++;
    }
}


VOID
FreeHashBlock (
    VOID
    )
{
    if (g_HashBuf) {
        MemFree (g_hHeap, 0, g_HashBuf);
        g_HashBuf = NULL;
    }

    g_HashSize = 0;
    g_HashEnd = 0;
    g_HashFreeHead = INVALID_OFFSET;
}


BOOL
EnumFirstHashEntry (
    OUT     PHASHENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (HASHENUM));

    return EnumNextHashEntry (EnumPtr);
}


BOOL
EnumNextHashEntry (
    IN OUT  PHASHENUM EnumPtr
    )
{
    for (;;) {
        if (EnumPtr->Bucket == HASH_BUCKETS) {
            //
            // The completion case
            //

            return FALSE;
        }

        if (!EnumPtr->BucketPtr) {
            //
            // This case occurs when we are begining to enumerate a bucket
            //

            EnumPtr->BucketPtr = (PBUCKETSTRUCT) g_HashBuf + EnumPtr->Bucket;
            if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Return this first item in the bucket
            //

            EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
            return TRUE;
        }

        //
        // This case occurs when we are continuing enumeration of a bucket
        //

        if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
            //
            // Current bucket item (and also the last bucket item) may have
            // been deleted -- check that now
            //

            if (!EnumPtr->PrevBucketPtr) {
                //
                // Last item has been deleted; continue to next bucket
                //

                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Previous bucket item is valid; use it.
            //

            EnumPtr->BucketPtr = EnumPtr->PrevBucketPtr;

        } else {
            //
            // Current bucket item may have been deleted, but another item was
            // moved to its place -- check that now
            //

            if (EnumPtr->BucketPtr->Offset != EnumPtr->LastOffset) {
                EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
                return TRUE;
            }
        }

        //
        // We now know that the current bucket item was not changed, so it
        // becomes our previous item and we move on to the next item (if
        // one exists)
        //

        if (UNMASK_OFFSET (EnumPtr->BucketPtr->Info.NextItem) == INVALID_OFFSET) {
            //
            // End of bucket reached
            //

            EnumPtr->BucketPtr = NULL;
            EnumPtr->Bucket += 1;
            continue;
        }

        EnumPtr->PrevBucketPtr = EnumPtr->BucketPtr;
        EnumPtr->BucketPtr = HASHBUFPTR (UNMASK_OFFSET (EnumPtr->BucketPtr->Info.NextItem));


        EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
        MYASSERT(EnumPtr->LastOffset != INVALID_OFFSET);
        break;
    }

    return TRUE;
}


typedef struct {
    BYTE Hive;
    DWORD Offset;
} HASH_ITEM, *PHASH_ITEM;

BOOL
SaveHashBlock (
    HANDLE File
    )
{
    BOOL b;
    DWORD Written;
    PBYTE BackupBlock;
    UINT OrgEnd, OrgSize, OrgFreeHead;
    PBYTE OrgBlock;
    WCHAR TempStr[MEMDB_MAX];
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    HASHENUM e;
    PHASH_ITEM ItemPtr;
    UINT u;

    //
    // Back up the hash block
    //

    BackupBlock = MemAlloc (g_hHeap, 0, g_HashEnd);
    CopyMemory (BackupBlock, g_HashBuf, g_HashEnd);

    OrgEnd = g_HashEnd;
    OrgSize = g_HashSize;
    OrgFreeHead = g_HashFreeHead;
    OrgBlock = g_HashBuf;

    g_HashBuf = BackupBlock;

    //
    // Delete all hash entries that do not belong to the root database.
    // Do this by queueing the hash entry removal, so the EnumNextHashEntry
    // function will continue to work.
    //

    if (EnumFirstHashEntry (&e)) {
        do {

            if (e.BucketPtr->Info.Hive) {
                ItemPtr = (PHASH_ITEM) GrowBuffer (&GrowBuf, sizeof (HASH_ITEM));
                ItemPtr->Hive   = (BYTE) (e.BucketPtr->Info.Hive);
                ItemPtr->Offset = e.BucketPtr->Offset;
            }

        } while (EnumNextHashEntry (&e));
    }

    ItemPtr = (PHASH_ITEM) GrowBuf.Buf;

    for (u = 0 ; u < GrowBuf.End ; u += sizeof (HASH_ITEM), ItemPtr++) {

        SelectDatabase (ItemPtr->Hive);

        if (PrivateBuildKeyFromOffset (
                0,
                ItemPtr->Offset,
                TempStr,
                NULL,
                NULL,
                NULL
                )) {

            RemoveHashTableEntry (TempStr);
        }
    }


    //
    // Write the hash block end and deleted pointer
    //

    b = WriteFile (File, &g_HashEnd, sizeof (DWORD), &Written, NULL);

    if (b) {
        b = WriteFile (File, &g_HashFreeHead, sizeof (DWORD), &Written, NULL);
    }

    //
    // Write the hash block
    //

    if (b) {
        b = WriteFile (File, g_HashBuf, g_HashEnd, &Written, NULL);
        if (Written != g_HashEnd) {
            b = FALSE;
        }
    }

    //
    // Restore the hash block
    //

    PushError();

    g_HashEnd = OrgEnd;
    g_HashSize = OrgSize;
    g_HashFreeHead = OrgFreeHead;
    g_HashBuf = OrgBlock;

    SelectDatabase (0);

    MemFree (g_hHeap, 0, BackupBlock);

    PopError();

    return b;
}


BOOL
LoadHashBlock (
    HANDLE File
    )
{
    BOOL b;
    DWORD Read;
    PBYTE TempBuf = NULL;

    //
    // Read the hash block end and deleted pointer; allocate memory for block.
    //

    b = ReadFile (File, &g_HashEnd, sizeof (DWORD), &Read, NULL);

    if (b) {
        b = ReadFile (File, &g_HashFreeHead, sizeof (DWORD), &Read, NULL);
    }

    if (b) {
        g_HashSize = g_HashEnd;

        TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_HashSize);
        if (TempBuf) {
            if (g_HashBuf) {
                MemFree (g_hHeap, 0, g_HashBuf);
            }

            g_HashBuf = TempBuf;
            TempBuf = NULL;
        } else {
            b = FALSE;
        }
    }

    //
    // Read the hash block
    //

    if (b) {
        b = ReadFile (File, g_HashBuf, g_HashSize, &Read, NULL);
        if (Read != g_HashSize) {
            b = FALSE;
            SetLastError (ERROR_BAD_FORMAT);
        }
    }

    return b;
}


DWORD
pCalculateHashVal (
    IN      PCWSTR String
    )
{
    DWORD Hash = 0;

    while (*String) {
        Hash = (Hash << 3) | (Hash >> 29);
        Hash += towlower (*String);
        String++;
    }

    Hash %= HASH_BUCKETS;

    return Hash;
}

DWORD
pAllocBucket (
    VOID
    )
{
    DWORD rBucketOffset;
    PBYTE TempBuf;
    PBUCKETSTRUCT BucketPtr;

    if (g_HashFreeHead != INVALID_OFFSET) {
        rBucketOffset = g_HashFreeHead;
        BucketPtr = HASHBUFPTR (rBucketOffset);
        g_HashFreeHead = UNMASK_OFFSET (BucketPtr->Info.NextItem);

        MYASSERT (rBucketOffset < g_HashEnd);
    } else {

        if (g_HashEnd + sizeof (BUCKETSTRUCT) > g_HashSize) {
            g_HashSize += HASH_BLOCK_SIZE;
            TempBuf = MemReAlloc (g_hHeap, 0, g_HashBuf, g_HashSize);
            DEBUGMSG ((DBG_NAUSEA, "Realloc'd memdb hash table"));

            if (!TempBuf) {
                DEBUGMSG ((DBG_ERROR, "Out of memory!"));
                g_HashSize -= HASH_BLOCK_SIZE;
                return INVALID_OFFSET;
            }

            g_HashBuf = TempBuf;
        }

        rBucketOffset = g_HashEnd;
        g_HashEnd += sizeof (BUCKETSTRUCT);

        BucketPtr = HASHBUFPTR (rBucketOffset);
    }

    BucketPtr->Offset = INVALID_OFFSET;
    BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;

    ASSERT_4BIT (g_SelectedDatabase);
    BucketPtr->Info.Hive = CONVERT_8TO4 (g_SelectedDatabase);

    return rBucketOffset;
}


BOOL
AddHashTableEntry (
    IN      PCWSTR FullString,
    IN      DWORD Offset
    )
{
    DWORD Bucket;
    PBUCKETSTRUCT BucketPtr, PrevBucketPtr;
    DWORD BucketOffset;
    DWORD NewOffset;
    DWORD PrevBucketOffset;

    Bucket = pCalculateHashVal (FullString);
    BucketPtr = (PBUCKETSTRUCT) g_HashBuf + Bucket;

    //
    // See if root bucket item has been used or not
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        //
        // Yes - add to end of the chain
        //

        BucketOffset = Bucket * sizeof (BUCKETSTRUCT);
        do {
            BucketPtr = HASHBUFPTR (BucketOffset);
            PrevBucketOffset = BucketOffset;
            BucketOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);
        } while (BucketOffset != INVALID_OFFSET);


        //
        // Add to the chain
        //

        NewOffset = pAllocBucket();
        PrevBucketPtr = HASHBUFPTR (PrevBucketOffset);
        ASSERT_OFFSET_ONLY (NewOffset);
        PrevBucketPtr->Info.NextItem = MASK_OFFSET (NewOffset);

        if (NewOffset == INVALID_OFFSET) {
            return FALSE;
        }

        BucketPtr = HASHBUFPTR (NewOffset);
        MYASSERT (BucketPtr->Info.NextItem == INVALID_OFFSET_MASKED);
    }

    BucketPtr->Offset = Offset;
    ASSERT_4BIT (g_SelectedDatabase);
    BucketPtr->Info.Hive = CONVERT_8TO4 (g_SelectedDatabase);

#ifdef DEBUG
    {
        DWORD HashOffset;

        HashOffset = FindStringInHashTable (FullString, NULL);
        MYASSERT (HashOffset != INVALID_OFFSET);
        DEBUGMSG_IF ((HashOffset != Offset, DBG_MEMDB, "Duplicate in hash table: %s", FullString));
    }
#endif

    return TRUE;
}


PBUCKETSTRUCT
pFindBucketItemInHashTable (
    IN      PCWSTR FullString,
    OUT     PBUCKETSTRUCT *PrevBucketPtr,       OPTIONAL
    OUT     DWORD *HashOffsetPtr                OPTIONAL
    )
{
    DWORD Bucket;
    DWORD BucketOffset;
    PBUCKETSTRUCT BucketPtr = NULL;
    WCHAR TempStr[MEMDB_MAX];

    Bucket = pCalculateHashVal (FullString);
    BucketOffset = Bucket * sizeof (BUCKETSTRUCT);

#ifdef MEMORY_TRACKING
    {
        //
        // Circular link check
        //

        DWORD Prev, Next;
        DWORD Turtle, Rabbit;
        BOOL Even = FALSE;

        Rabbit = BucketOffset;
        Turtle = Rabbit;
        while (Rabbit != INVALID_OFFSET) {
            // Make rabbit point to next item in chain
            Prev = Rabbit;
            BucketPtr = HASHBUFPTR (Rabbit);
            Rabbit = UNMASK_OFFSET (BucketPtr->Info.NextItem);

            // We should always be ahead of the turtle
            if (Rabbit == Turtle) {
                BucketPtr = HASHBUFPTR (Rabbit);
                Next = UNMASK_OFFSET (BucketPtr->Info.NextItem);
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Circular link detected in memdb hash table!  Turtle=%u, Rabbit=%u, Next=%u, Prev=%u",
                    Turtle,
                    Rabbit,
                    Next,
                    Prev
                    ));

                return NULL;
            }

            // Make turtle point to next item in chain (1 of every 2 passes)
            if (Even) {
                BucketPtr = HASHBUFPTR (Turtle);
                Turtle = UNMASK_OFFSET (BucketPtr->Info.NextItem);
            }

            Even = !Even;
        }
    }
#endif

    BucketPtr = HASHBUFPTR (BucketOffset);

    if (PrevBucketPtr) {
        *PrevBucketPtr = BucketPtr;
    }

    //
    // If root bucket is not empty, scan bucket for FullString
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        do  {

            BucketPtr = HASHBUFPTR (BucketOffset);
            ASSERT_4BIT (g_SelectedDatabase);

            if (BucketPtr->Info.Hive == g_SelectedDatabase) {
                //
                // Build string using offset
                //

                PrivateBuildKeyFromOffset (
                    0,
                    BucketPtr->Offset,
                    TempStr,
                    NULL,
                    NULL,
                    NULL
                    );

                //
                // Do compare and return if match is found
                //

                if (StringIMatchW (FullString, TempStr)) {
                    if (HashOffsetPtr) {
                        *HashOffsetPtr = BucketOffset;
                    }
                    return BucketPtr;
                }

            }

            if (PrevBucketPtr) {
                *PrevBucketPtr = BucketPtr;
            }

            BucketOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);

        } while (BucketOffset != INVALID_OFFSET);
    }

    return NULL;
}


DWORD
FindStringInHashTable (
    IN      PCWSTR FullString,
    OUT     PBYTE DatabaseId        OPTIONAL
    )
{
    PBUCKETSTRUCT BucketPtr;

    BucketPtr = pFindBucketItemInHashTable (FullString, NULL, NULL);
    if (BucketPtr) {
        if (DatabaseId) {
            *DatabaseId = (BYTE) (BucketPtr->Info.Hive);
        }

        return BucketPtr->Offset;
    }

    return INVALID_OFFSET;
}


BOOL
RemoveHashTableEntry (
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    DWORD NextOffset;
    PBUCKETSTRUCT NextBucketPtr;
    DWORD BucketOffset;

    BucketPtr = pFindBucketItemInHashTable (FullString, &PrevBucketPtr, &BucketOffset);
    if (!BucketPtr) {
        return FALSE;
    }

    if (PrevBucketPtr != BucketPtr) {
        //
        // If not at the first level (prev != current), give the block
        // to free space.
        //

        PrevBucketPtr->Info.NextItem = BucketPtr->Info.NextItem;
        ASSERT_OFFSET_ONLY (g_HashFreeHead);
        BucketPtr->Info.NextItem = MASK_OFFSET (g_HashFreeHead);
        BucketPtr->Offset = INVALID_OFFSET;
        g_HashFreeHead = BucketOffset;

    } else {

        //
        // Invalidate next item pointer if at the first level
        //

        if (UNMASK_OFFSET (BucketPtr->Info.NextItem) != INVALID_OFFSET) {
            //
            // Copy next item to root array
            //

            NextOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);
            NextBucketPtr = HASHBUFPTR (NextOffset);
            CopyMemory (BucketPtr, NextBucketPtr, sizeof (BUCKETSTRUCT));

            //
            // Donate next item to free space
            //

            ASSERT_OFFSET_ONLY (g_HashFreeHead);
            NextBucketPtr->Info.NextItem = MASK_OFFSET (g_HashFreeHead);
            NextBucketPtr->Offset = INVALID_OFFSET;
            g_HashFreeHead = NextOffset;


        } else {
            //
            // Delete of last item in bucket -- invalidate the root array item
            //

            BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;
            BucketPtr->Offset = INVALID_OFFSET;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\fileops.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  fileops.c

Abstract:

  This file implements routines that manage the operations on files.  Callers
  can set and remove operations on any path.  The operations can have optional
  properties.  The operation combinations and the number of properties are
  well-defined, so that potential collisions can be found during testing.

Author:

  Jim Schmidt (jimschm) 18-Jul-1997

Revision History:

  jimschm   26-Aug-1998   Redesigned!!  Consolidated functionality into generic
                          linkage: path<->operation(s)->attrib(s)
  jimschm   24-Aug-1998   Added shell folder support
  jimschm   01-May-1998   Added handled directory to GetFileStatusOnNt
  calinn    21-Apr-1998   added AddCompatibleShell, AddCompatibleRunKey and AddCompatibleDos
  calinn    02-Apr-1998   added DeclareTemporaryFile
  calinn    18-Jan-1998   added MigrationPhase_AddCompatibleFile
                          turned off warning in MigrationPhase_CreateFile
                          modified MigrationPhase_DeleteFile and MigrationPhase_MoveFile
                          modified GetFileInfoOnNt for short file names
  calinn    05-Jan-1998   added IsFileMarkedForAnnounce, AnnounceFileInReport,
                          GetFileInfoOnNt, GetFileStatusOnNt, GetPathStringOnNt

--*/

#include "pch.h"

#define DBG_MEMDB       "MemDb"

#define FO_ENUM_BEGIN               0
#define FO_ENUM_BEGIN_PATH_ENUM     1
#define FO_ENUM_BEGIN_PROP_ENUM     2
#define FO_ENUM_RETURN_PATH         3
#define FO_ENUM_RETURN_DATA         4
#define FO_ENUM_NEXT_PROP           5
#define FO_ENUM_NEXT_PATH           6
#define FO_ENUM_END                 7

//
//140 - header for compresion file, 10 + 2 timestamp +
//MAX_PATH file name in Unicode
//
#define STARTUP_INFORMATION_BYTES_NUMBER    (140 + (sizeof(WCHAR) * MAX_PATH) + 26)
#define COMPRESSION_RATE_DEFAULT            70
#define BACKUP_DISK_SPACE_PADDING_DEFAULT   (5<<20)
#define UNKNOWN_DRIVE                       '?'



PCWSTR g_CurrentUser = NULL;

BOOL
pGetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    );

BOOL
pIsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );

UINT
pAddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      BOOL Force,
    IN      BOOL AlreadyLong
    );

VOID
pFileOpsSetPathTypeW (
    IN      PCWSTR LongFileSpec
    )
{
    WCHAR ShortFileSpec[MAX_WCHAR_PATH];
    WCHAR LongFileSpecCopy[MAX_WCHAR_PATH];
    WCHAR MixedFileSpec[MAX_WCHAR_PATH];
    PWSTR p;
    PWSTR LongStart, LongEnd;
    PWSTR ShortStart, ShortEnd;
    PWSTR MixedFileName;
    WCHAR ch;

    //
    // Make sure the file spec is marked as a long path
    //

    if (!pIsFileMarkedForOperationW (LongFileSpec, OPERATION_LONG_FILE_NAME)) {
        pAddOperationToPathW (LongFileSpec, OPERATION_LONG_FILE_NAME, FALSE, TRUE);

        //
        // Obtain the short path, and if it is different than the
        // long path, add an operation for it.
        //

        if (OurGetShortPathNameW (LongFileSpec, ShortFileSpec, MAX_WCHAR_PATH)) {

            if (!StringIMatchW (LongFileSpec, ShortFileSpec)) {
                //
                // The short and long paths differ, so record the short path.
                //

                if (!pIsFileMarkedForOperationW (ShortFileSpec, OPERATION_SHORT_FILE_NAME)) {
                    AssociatePropertyWithPathW (
                        ShortFileSpec,
                        OPERATION_SHORT_FILE_NAME,
                        LongFileSpec
                        );
                }

                //
                // Make sure each short piece of the file spec is added.  This
                // allows us to support mixed short and long paths.  It is
                // critical that we have the long path with a short file name.
                //

                _wcssafecpy (LongFileSpecCopy, LongFileSpec, sizeof (LongFileSpecCopy));

                LongStart = LongFileSpecCopy;
                ShortStart = ShortFileSpec;
                MixedFileName = MixedFileSpec;

                while (*LongStart && *ShortStart) {

                    LongEnd = wcschr (LongStart, L'\\');
                    if (!LongEnd) {
                        LongEnd = GetEndOfStringW (LongStart);
                    }

                    ShortEnd = wcschr (ShortStart, L'\\');
                    if (!ShortEnd) {
                        ShortEnd = GetEndOfStringW (ShortStart);
                    }

                    StringCopyABW (MixedFileName, ShortStart, ShortEnd);

                    if (!StringIMatchABW (MixedFileName, LongStart, LongEnd)) {

                        if (!pIsFileMarkedForOperationW (MixedFileSpec, OPERATION_SHORT_FILE_NAME)) {
                            ch = *LongEnd;
                            *LongEnd = 0;

                            AssociatePropertyWithPathW (
                                MixedFileSpec,
                                OPERATION_SHORT_FILE_NAME,
                                LongFileSpecCopy
                                );

                            *LongEnd = ch;
                        }

                        StringCopyABW (MixedFileName, LongStart, LongEnd);
                    }

                    p = MixedFileName + (LongEnd - LongStart);
                    *p = L'\\';
                    MixedFileName = p + 1;

                    LongStart = LongEnd;
                    if (*LongStart) {
                        LongStart++;
                    }

                    // skip paths that have double-wacks
                    while (*LongStart == L'\\') {
                        LongStart++;
                    }

                    ShortStart = ShortEnd;
                    if (*ShortStart) {
                        ShortStart++;
                    }
                }

                MYASSERT (!*LongStart && !*ShortStart);
            }
        }
    }
}


VOID
pFileOpsGetLongPathW (
    IN      PCWSTR FileSpec,
    OUT     PWSTR LongFileSpec
    )
{
    WCHAR Replacement[MEMDB_MAX];
    PCWSTR MixedStart, MixedEnd;
    PWSTR OutStr;
    UINT u;

    //
    // Get the short property from the long property
    //

    if (!pIsFileMarkedForOperationW (FileSpec, OPERATION_LONG_FILE_NAME)) {

        if (!pGetPathPropertyW (FileSpec, OPERATION_SHORT_FILE_NAME, 0, LongFileSpec)) {

            //
            // The short and long properties aren't there.  Try each piece.
            //

            MixedStart = FileSpec;
            OutStr = LongFileSpec;

            while (*MixedStart) {

                MixedEnd = wcschr (MixedStart, L'\\');
                if (!MixedEnd) {
                    MixedEnd = GetEndOfStringW (MixedStart);
                }

                if (OutStr != LongFileSpec) {
                    *OutStr++ = L'\\';
                }

                StringCopyABW (OutStr, MixedStart, MixedEnd);

                if (pGetPathPropertyW (LongFileSpec, OPERATION_SHORT_FILE_NAME, 0, Replacement)) {

                    u = OutStr - LongFileSpec;
                    MYASSERT (StringIMatchTcharCountW (LongFileSpec, Replacement, u));

                    StringCopyW (LongFileSpec + u, Replacement + u);
                }

                OutStr = GetEndOfStringW (OutStr);

                MixedStart = MixedEnd;
                if (*MixedStart) {
                    MixedStart++;
                }
            }

            *OutStr = 0;
        }

    } else {
        StringCopyW (LongFileSpec, FileSpec);
    }
}

PCSTR
GetSourceFileLongNameA (
    IN      PCSTR ShortName
    )
{
    PCWSTR UShortName;
    PCWSTR ULongName;
    PCSTR ALongName;
    PCSTR LongName;

    UShortName = ConvertAtoW (ShortName);
    ULongName = GetSourceFileLongNameW (UShortName);
    ALongName = ConvertWtoA (ULongName);
    LongName = DuplicatePathStringA (ALongName, 0);
    FreeConvertedStr (ALongName);
    FreePathString (ULongName);
    FreeConvertedStr (UShortName);

    return LongName;
}

PCWSTR
GetSourceFileLongNameW (
    IN      PCWSTR ShortName
    )
{
    WCHAR LongName[MEMDB_MAX];
    pFileOpsGetLongPathW (ShortName, LongName);
    return (DuplicatePathStringW (LongName, 0));
}

PCWSTR
SetCurrentUserW (
    PCWSTR User
    )
{
    PCWSTR tempUser = g_CurrentUser;
    g_CurrentUser = User;
    return tempUser;
}




DWORD g_MasterSequencer = 0;


#define ONEBITSET(x)    ((x) && !((x) & ((x) - 1)))



typedef struct {
    DWORD Bit;
    PCSTR Name;
    DWORD SharedOps;
    UINT MaxProps;
} OPERATIONFLAGS, *POPERATIONFLAGS;

#define UNLIMITED   0xffffffff

#define DEFMAC(bit,name,memdbname,maxattribs)   {bit,#memdbname,0,maxattribs},

OPERATIONFLAGS g_OperationFlags[] = {
    PATH_OPERATIONS /* , */
    {0, NULL, 0, 0}
};

#undef DEFMAC



UINT
pWhichBitIsSet (
    OPERATION Value
    )
{
    UINT Bit = 0;

    MYASSERT (ONEBITSET(Value));

    while (Value /= 2) {
        Bit++;
    }

    MYASSERT (Bit < 24);

    return Bit;
}


VOID
pProhibitOperationCombination (
    IN      DWORD SourceOperations,
    IN      DWORD ProhibitedOperations
    )
{
    DWORD w1, w2;
    OPERATION OperationA;
    OPERATION OperationB;

    for (w1 = SourceOperations ; w1 ; w1 ^= OperationA) {
        OperationA = w1 & (~(w1 - 1));

        g_OperationFlags[pWhichBitIsSet (OperationA)].SharedOps &= ~ProhibitedOperations;

        for (w2 = ProhibitedOperations ; w2 ; w2 ^= OperationB) {
            OperationB = w2 & (~(w2 - 1));
            g_OperationFlags[pWhichBitIsSet (OperationB)].SharedOps &= ~OperationA;
        }
    }
}


VOID
InitOperationTable (
    VOID
    )

/*++

Routine Description:

  InitOperationsTable sets the prohibited operation mask for each operation.
  When an operation combination is prohibited, both operations involved have
  the corresponding bit cleared.

Arguments:

  None.

Return Value:

  None.

--*/

{
    POPERATIONFLAGS p;

    for (p = g_OperationFlags ; p->Name ; p++) {
        p->SharedOps = ALL_OPERATIONS;
    }

    //
    // Please try to keep this in the same order as the
    // macro expansion list in fileops.h.  The list of
    // prohibited operations should get smaller as
    // we go.
    //

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE,
        OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_COPY|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE_EXTERNAL,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_COPY|
            OPERATION_CLEANUP|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_COPY|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_COPY,
            OPERATION_FILE_COPY|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_EXTERNAL,
        OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_SHELL_FOLDER,
        OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_BY_NT,
        OPERATION_FILE_MOVE_BY_NT
        );

    pProhibitOperationCombination (
        OPERATION_CLEANUP,
        OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_MIGDLL_HANDLED,
        OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_LINK_EDIT,
        OPERATION_LINK_EDIT
        );

    pProhibitOperationCombination (
        OPERATION_LINK_STUB,
        OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_SHELL_FOLDER,
        OPERATION_SHELL_FOLDER
        );

    pProhibitOperationCombination (
        OPERATION_SHORT_FILE_NAME,
        OPERATION_SHORT_FILE_NAME
        );

}


VOID
pBuildOperationCategory (
    IN      PWSTR Node,
    IN      UINT OperationNum
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    swprintf (Node, L"%hs", g_OperationFlags[OperationNum].Name);
}


VOID
pBuildOperationKey (
    IN      PWSTR Node,
    IN      UINT OperationNum,
    IN      UINT Sequencer
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    swprintf (Node, L"%hs\\%x", g_OperationFlags[OperationNum].Name, Sequencer);
}


VOID
pBuildPropertyKey (
    IN      PWSTR Node,
    IN      UINT OperationNum,
    IN      UINT Sequencer,
    IN      DWORD Property
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    swprintf (Node, L"%hs\\%x\\%x", g_OperationFlags[OperationNum].Name, Sequencer, Property);
}

BOOL
CanSetOperationA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL result;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    result = CanSetOperationW (UnicodeFileSpec, Operation);

    FreeConvertedStr (UnicodeFileSpec);

    return result;
}

BOOL
CanSetOperationW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )
{
    WCHAR LongFileSpec[MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    DWORD Flags;
    UINT SetBitNum;

    MYASSERT (ONEBITSET (Operation));

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    //
    // Get existing sequencer and flags, if they exist
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (!MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return TRUE;
    }

    SetBitNum = pWhichBitIsSet (Operation);

    return ((Flags & g_OperationFlags[SetBitNum].SharedOps) == Flags);
}

BOOL
pSetPathOperationW (
    IN      PCWSTR FileSpec,
    OUT     PDWORD Offset,
    OUT     PUINT SequencerPtr,
    IN      OPERATION SetBit,
    IN      OPERATION ClrBit,
    IN      BOOL Force
    )

/*++

Routine Description:

  pSetPathOperation adds the operation bit to the specified path.  It also
  verifies that the operation combination is legal.

Arguments:

  FileSpec    - Specifies the path the operation applies to.
  Offset      - Receives the offset of the memdb key created for the path.
  SequencePtr - Receives the operation sequence number, used for property
                linkage.
  SetBit      - Specifies one operation bit to set.
  ClrBit      - Specifies one operation bit to clear.  Either SetBit or
                ClrBit can be used, but not both.

Return Value:

  TRUE if the operation was set, FALSE otherwise.

--*/

{
    DWORD Sequencer;
    WCHAR Node[MEMDB_MAX];
    DWORD Flags;
    UINT SetBitNum;

    MYASSERT ((SetBit && !ClrBit) || (ClrBit && !SetBit));
    MYASSERT (ONEBITSET (SetBit | ClrBit));

    //
    // Get existing sequencer and flags, if they exist
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);

    if (!MemDbGetValueAndFlagsW (Node, &Sequencer, &Flags) || !Flags) {
        Flags = 0;
        if (!g_MasterSequencer && ISNT()) {
            if (!MemDbGetValue (
                    MEMDB_CATEGORY_STATE TEXT("\\") MEMDB_ITEM_MASTER_SEQUENCER,
                    &g_MasterSequencer
                    )) {
                g_MasterSequencer = 1 << 24;
            }
        }
        g_MasterSequencer++;
        Sequencer = g_MasterSequencer;

        MYASSERT (Sequencer);
    }

    //
    // Is bit adjustment legal?
    //

    if (SetBit) {

        SetBitNum = pWhichBitIsSet (SetBit);

#ifdef DEBUG

        {
            PSTR p;
            PCSTR DebugInfPath;
            CHAR DbgBuf[32];
            BOOL Break = FALSE;
            PCSTR AnsiFileSpec;

            DebugInfPath = JoinPathsA (g_BootDrivePathA, "debug.inf");

            AnsiFileSpec = ConvertWtoA (FileSpec);
            p = _mbsrchr (AnsiFileSpec, L'\\');
            p++;

            if (GetPrivateProfileStringA ("FileOps", AnsiFileSpec, "", DbgBuf, 32, DebugInfPath)) {
                Break = TRUE;
            } else if (GetPrivateProfileStringA ("FileOps", p, "", DbgBuf, 32, DebugInfPath)) {
                Break = TRUE;
            }

            if (Break) {
                if ((SetBit & strtoul (DbgBuf, NULL, 16)) == 0) {
                    Break = FALSE;
                }
            }

            if (Break) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "File %ls now being marked for operation %hs",
                    FileSpec,
                    g_OperationFlags[SetBitNum].Name
                    ));
            }

            FreePathStringA (DebugInfPath);
            FreeConvertedStr (AnsiFileSpec);
        }

#endif

        if (!Force) {
            if ((Flags & g_OperationFlags[SetBitNum].SharedOps) != Flags) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "File %ls already marked, %hs cannot be combined with 0x%04X",
                    FileSpec,
                    g_OperationFlags[SetBitNum].Name,
                    Flags
                    ));

                return FALSE;
            }
        }
    }

    //
    // Adjust the bits
    //

    Flags |= SetBit;
    Flags &= ~ClrBit;

    //
    // Save
    //

    MemDbSetValueAndFlagsW (Node, Sequencer, Flags, 0);

    MemDbGetOffsetW (Node, Offset);
    *SequencerPtr = Sequencer;

    return TRUE;
}


UINT
pAddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      BOOL Force,
    IN      BOOL AlreadyLong
    )

/*++

Routine Description:

  pAddOperationToPath adds an operation to a path.  The caller receives a
  sequencer so additional properties can be added.

Arguments:

  FileSpec    - Specifies the path to add the operation to
  Operation   - Specifies the operation to add
  Force       - Specifies TRUE if the operation combinations should be
                ignored.  This is only for special-case use.
  AlreadyLong - Specifies TRUE if FileSpec is a long path, FALSE otherwise.

Return Value:

  A sequencer that can be used to add properties, or INVALID_SEQUENCER if an
  error occured.

--*/

{
    UINT OperationNum;
    UINT Sequencer;
    WCHAR Node[MEMDB_MAX];
    DWORD Offset;
    WCHAR LongFileSpec[MAX_WCHAR_PATH];

    if (!FileSpec || FileSpec[0] == 0) {
        return INVALID_SEQUENCER;
    }

    //
    // Make sure FileSpec is in long format and is recorded in memdb
    //

    if (Operation != OPERATION_SHORT_FILE_NAME &&
        Operation != OPERATION_LONG_FILE_NAME
        ) {
        if (!AlreadyLong) {
            MYASSERT (ISNT());

            if (FileSpec[0] && (FileSpec[1]==L':')) {
                if (OurGetLongPathNameW (FileSpec, LongFileSpec, MAX_WCHAR_PATH)) {

                    FileSpec = LongFileSpec;
                }
            }
        }

        pFileOpsSetPathTypeW (FileSpec);
    }

    //
    // Create the path sequencer and set the operation bit
    //

    MYASSERT (ONEBITSET(Operation));

#ifdef DEBUG
    Offset = INVALID_OFFSET;
#endif

    if (!pSetPathOperationW (FileSpec, &Offset, &Sequencer, Operation, 0, Force)) {
        return INVALID_SEQUENCER;
    }

    MYASSERT (Offset != INVALID_OFFSET);

    //
    // Add the opereration
    //

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);

    if (!MemDbGetValueW (Node, NULL)) {
        MemDbSetValueW (Node, Offset);
    }

    return Sequencer;
}


UINT
AddOperationToPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);
    UnicodeFileSpec = ConvertAtoW (longFileSpec);

    u = pAddOperationToPathW (UnicodeFileSpec, Operation, FALSE, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    return u;
}


UINT
AddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )
{
    if (!ISNT()) {

#ifdef DEBUG
        //
        // If we are calling the W version on Win9x, then we know
        // that the path is long. Otherwise the caller must call
        // the A version.
        //

        {
            PCSTR ansiFileSpec;
            CHAR longFileSpec[MAX_MBCHAR_PATH];
            PCWSTR unicodeFileSpec;

            ansiFileSpec = ConvertWtoA (FileSpec);
            CopyFileSpecToLongA (ansiFileSpec, longFileSpec);
            FreeConvertedStr (ansiFileSpec);

            unicodeFileSpec = ConvertAtoW (longFileSpec);
            MYASSERT (StringIMatchW (FileSpec, unicodeFileSpec));
            FreeConvertedStr (unicodeFileSpec);
        }
#endif

        return pAddOperationToPathW (FileSpec, Operation, FALSE, TRUE);
    }

    return pAddOperationToPathW (FileSpec, Operation, FALSE, FALSE);
}


UINT
ForceOperationOnPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);
    UnicodeFileSpec = ConvertAtoW (longFileSpec);

    u = pAddOperationToPathW (UnicodeFileSpec, Operation, TRUE, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    return u;
}


UINT
ForceOperationOnPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  ForceOperationOnPath is used only in special cases where the caller knows
  that a normally prohibited operation combination is OK.  This is usually
  because Path was somehow changed from its original state, yet the
  operations cannot be removed via RemoveOperationsFromPath.

  This function should only be used if absolutely necessary.

Arguments:

  FileSpec  - Specifies the path to add the operation to.
  Operation - Specifies the single operation to add to the path.

Return Value:

  A sequencer that can be used to add properties to the path.

--*/

{
    return pAddOperationToPathW (FileSpec, Operation, TRUE, FALSE);
}


BOOL
AddPropertyToPathExA (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCSTR Property,
    IN      PCSTR AlternateDataSection      OPTIONAL
    )
{
    PCWSTR UnicodeProperty;
    PCWSTR UnicodeAlternateDataSection;
    BOOL b;

    UnicodeProperty = ConvertAtoW (Property);
    UnicodeAlternateDataSection = ConvertAtoW (AlternateDataSection);

    b = AddPropertyToPathExW (
            Sequencer,
            Operation,
            UnicodeProperty,
            UnicodeAlternateDataSection
            );

    FreeConvertedStr (UnicodeProperty);
    FreeConvertedStr (UnicodeAlternateDataSection);

    return b;
}


BOOL
AddPropertyToPathExW (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      PCWSTR AlternateDataSection     OPTIONAL
    )
{

/*++

Routine Description:

  AddPropertyToPathEx adds an operation to a path, and then adds a property.
  The caller can also specify an alternate data section (for special-case
  uses).

Arguments:

  Sequencer            - Specifies the sequencer of the path to add
                         operations and properties to
  Operation            - Specifies the operation to add
  Property             - Specfieis the property data to add
  AlternateDataSection - Specifies an alternate memdb root for the property
                         data

Return Value:

  TRUE if the operation was added, FALSE otherwise.

--*/

    DWORD DataOffset;
    WCHAR Node[MEMDB_MAX];
    UINT OperationNum;
    DWORD UniqueId;
    DWORD PathOffset;
    DWORD DataValue;
    DWORD DataFlags;

    //
    // Verify the sequencer and operation are valid
    //

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);

    if (!MemDbGetValueAndFlagsW (Node, &PathOffset, &UniqueId)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't set property on non-existent operation"));
        return FALSE;
    }

    //
    // Can this operation have another property?
    //

    if (UniqueId == g_OperationFlags[OperationNum].MaxProps) {
        DEBUGMSG ((
            DBG_WHOOPS,
            "Maximum properties specified for %hs (property %ls)",
            g_OperationFlags[OperationNum].Name,
            Property
            ));

        return FALSE;
    }

    //
    // Increment the unique ID
    //

    MemDbSetValueAndFlagsW (Node, PathOffset, (DWORD) (UniqueId + 1), 0);

    //
    // Get the existing data value and flags, preserving them
    // if they exist
    //

    if (!AlternateDataSection) {
        AlternateDataSection = MEMDB_CATEGORY_DATAW;
    }

    swprintf (Node, L"%s\\%s", AlternateDataSection, Property);

    if (!MemDbGetValueAndFlagsW (Node, &DataValue, &DataFlags)) {
        DataValue = 0;
        DataFlags = 0;
    }

    //
    // Write the data section node and get the offset
    //

    MemDbSetValueAndFlagsW (Node, DataValue, DataFlags, 0);
    MemDbGetOffsetW (Node, &DataOffset);

    //
    // Write the operation node
    //

    pBuildPropertyKey (Node, OperationNum, Sequencer, UniqueId);
    MemDbSetValueW (Node, DataOffset);

    return TRUE;
}


BOOL
pAssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      BOOL AlreadyLong
    )

/*++

Routine Description:

  AssociatePropertyWithPath adds a property to a path operation.  The maximum
  property count is enforced.

Arguments:

  FileSpec    - Specifies the path to add an operation and property
  Operation   - Specifies the operation to add
  Property    - Specifies the property data to associate with FileSpec
  AlreadyLong - Specifies TRUE if FileSpec is a long path name, FALSE otherwise

Return Value:

  TRUE if the operation and property was added, FALSE otherwise.  It is possible
  that the operation will be added but the property will not.

--*/

{
    UINT Sequencer;

    Sequencer = pAddOperationToPathW (FileSpec, Operation, FALSE, AlreadyLong);
    if (Sequencer == INVALID_SEQUENCER) {
        DEBUGMSG ((DBG_WHOOPS, "Can't associate %s with %s", Property, FileSpec));
        return FALSE;
    }

    //
    // BUGBUG - When the below fails, we need to reverse the pAddOperationToPathW
    //          call above
    //

    return AddPropertyToPathExW (Sequencer, Operation, Property, NULL);
}


BOOL
AssociatePropertyWithPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCSTR Property
    )
{
    PCWSTR UnicodeFileSpec;
    PCWSTR UnicodeProperty;
    BOOL b;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);

    UnicodeFileSpec = ConvertAtoW (longFileSpec);
    UnicodeProperty = ConvertAtoW (Property);

    b = pAssociatePropertyWithPathW (UnicodeFileSpec, Operation, UnicodeProperty, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    FreeConvertedStr (UnicodeProperty);

    return b;
}


BOOL
AssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property
    )
{
    return pAssociatePropertyWithPathW (FileSpec, Operation, Property, FALSE);
}


UINT
GetSequencerFromPathA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    u = GetSequencerFromPathW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return u;
}


UINT
GetSequencerFromPathW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  GetSequencerFromPath returns the sequencer for a particular path.  The path
  must have at least one operation.

Arguments:

  FileSpec - Specifies the path to get the sequencer for.

Return Value:

  The sequencer for the path, or INVALID_SEQUENCER if there are no operationf
  for the path.

--*/

{
    WCHAR LongFileSpec[MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    DWORD Sequencer;

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (!MemDbGetValueW (Node, &Sequencer)) {
        return INVALID_SEQUENCER;
    }

    return (UINT) Sequencer;
}


BOOL
GetPathFromSequencerA (
    IN      UINT Sequencer,
    OUT     PSTR PathBuf
    )
{
    WCHAR UnicodePathBuf[MAX_WCHAR_PATH];
    BOOL b;

    b = GetPathFromSequencerW (Sequencer, UnicodePathBuf);

    if (b) {
        KnownSizeWtoA (PathBuf, UnicodePathBuf);
    }

    return b;

}


BOOL
GetPathFromSequencerW (
    IN      UINT Sequencer,
    OUT     PWSTR PathBuf
    )

/*++

Routine Description:

  GetPathFromSequencer returns the path from the specified sequencer.

Arguments:

  Sequencer - Specifies the sequencer of the path.
  PathBuf   - Receives the path.  The caller must make sure the buffer is big
              enough for the path.

Return Value:

  TRUE if the path was copied to PathBuf, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD PathOffset = 0;
    DWORD w;
    UINT u;
    BOOL b = FALSE;

    //
    // Search all operations for sequencer
    //

    for (w = 1, u = 0 ; g_OperationFlags[u].Name ; w <<= 1, u++) {
        pBuildOperationKey (Node, u, Sequencer);
        if (MemDbGetValueW (Node, &PathOffset)) {
            break;
        }
    }

    //
    // For the first match found, use the offset to find the path
    //

    if (w) {
        b = MemDbBuildKeyFromOffsetW (PathOffset, PathBuf, 1, NULL);
    }

    return b;
}


VOID
RemoveOperationsFromSequencer (
    IN      UINT Sequencer,
    IN      DWORD Operations
    )

/*++

Routine Description:

  RemoveOperationsFromSequencer removes all operation bits from the specified
  path.  It does not however remove the properties; they become abandoned.

Arguments:

  Sequencer  - Specifies the sequencer for the path to remove operations from
  Operations - Specifies one or more operations to remove

Return Value:

  None.

--*/

{
    WCHAR Node[MEMDB_MAX];
    UINT u;
    DWORD PathOffset;
    DWORD PathSequencer;

    for (u = 0 ; g_OperationFlags[u].Name ; u++) {

        if (!(Operations & g_OperationFlags[u].Bit)) {
            continue;
        }

        pBuildOperationKey (Node, u, Sequencer);

        if (MemDbGetValueW (Node, &PathOffset)) {
            //
            // Delete linkage from operation to properties
            //

            MemDbDeleteTreeW (Node);

            //
            // Remove operation bits
            //

            MemDbBuildKeyFromOffsetExW (
                PathOffset,
                Node,
                NULL,
                0,
                &PathSequencer,
                NULL
                );

            MYASSERT (PathSequencer == Sequencer);

            MemDbSetValueAndFlagsW (Node, PathSequencer, 0, Operations);
        }
    }
}


VOID
RemoveOperationsFromPathA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    )
{
    PCWSTR UnicodeFileSpec;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    RemoveOperationsFromPathW (UnicodeFileSpec, Operations);

    FreeConvertedStr (UnicodeFileSpec);
}


VOID
RemoveOperationsFromPathW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )
{
    UINT Sequencer;

    Sequencer = GetSequencerFromPathW (FileSpec);

    if (Sequencer != INVALID_SEQUENCER) {
        RemoveOperationsFromSequencer (Sequencer, Operations);
    }
}


BOOL
IsFileMarkedForOperationA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = IsFileMarkedForOperationW (UnicodeFileSpec, Operations);

    FreeConvertedStr (UnicodeFileSpec);

    return b;
}


BOOL
IsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )

/*++

Routine Description:

  IsFileMarkedForOperation tests a path for one or more operations.

Arguments:

  FileSpec   - Specifies the path to test
  Operations - Specifies one or more operations to test for.

Return Value:

  TRUE if at least one operation from Operations is set on FileSpec, FALSE
  otherwise.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    DWORD Flags;
    WCHAR Node[MEMDB_MAX];

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return (Flags & Operations) != 0;
    }

    return FALSE;
}


BOOL
pIsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )

/*++

Routine Description:

  pIsFileMarkedForOperation tests a path for one or more operations.
  It does not convert short paths to long paths

Arguments:

  FileSpec   - Specifies the path to test
  Operations - Specifies one or more operations to test for.

Return Value:

  TRUE if at least one operation from Operations is set on FileSpec, FALSE
  otherwise.

--*/

{
    DWORD Flags;
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return (Flags & Operations) != 0;
    }

    return FALSE;
}


BOOL
IsFileMarkedInDataA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = IsFileMarkedInDataW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return b;
}


BOOL
IsFileMarkedInDataW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  IsFileMarkedInData tests the common property data section for FileSpec.

Arguments:

  FileSpec - Specifies the path to test.  This may also be any arbitrary
             property value.

Return Value:

  TRUE if FileSpec is a property of some operation, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_DATAW, FileSpec, NULL, NULL);

    return MemDbGetValueW (Node, NULL);
}


DWORD
GetPathPropertyOffset (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      DWORD Property
    )

/*++

Routine Description:

  GetPathPropertyOffset returns the MemDb offset to the specified property.

Arguments:

  Sequencer - Specifies the path sequencer
  Operation - Specifies the operation the property is associated with
  Property  - Specifies the property index

Return Value:

  The MemDb offset to the property data, or INVALID_OFFSET.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD Offset;
    UINT OperationNum;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildPropertyKey (Node, OperationNum, Sequencer, Property);

    if (MemDbGetValueW (Node, &Offset)) {
        return Offset;
    }

    return INVALID_OFFSET;
}


DWORD
GetOperationsOnPathA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    DWORD w;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    w = GetOperationsOnPathW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return w;
}


DWORD
GetOperationsOnPathW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  GetOperationsOnPath returns the operation flags for a path.

Arguments:

  FileSpec - Specifies the path to return operations for

Return Value:

  The operation bits for FileSpec

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    DWORD Operations;
    WCHAR Node[MEMDB_MAX];

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Operations)) {
        return Operations;
    }

    return 0;
}


BOOL
GetPathPropertyA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PSTR PropertyBuf           OPTIONAL
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;
    WCHAR UnicodeProperty[MEMDB_MAX];

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = GetPathPropertyW (
            UnicodeFileSpec,
            Operations,
            Property,
            PropertyBuf ? UnicodeProperty : NULL
            );

    FreeConvertedStr (UnicodeFileSpec);

    if (b && PropertyBuf) {
        KnownSizeWtoA (PropertyBuf, UnicodeProperty);
    }

    return b;
}


BOOL
pGetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    )

/*++

Routine Description:

  pGetPathProperty obtains a specific property for a path.

Arguments:

  FileSpec   - Specifies the path the property is associated with
  Operations - Specifies the operation flags to search.  The function will
               return the first property to match.
  Property   - Specifies the property index
  ProperyBuf - Receives the property data

Return Value:

  TRUE if a property was copied to PropertyBuf, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD Sequencer;
    DWORD Flags;
    DWORD Operation;
    DWORD PropertyOffset;
    BOOL b = FALSE;

    //
    // Make sure operation is specified for FileSpec, then return
    // the property requested.
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);
    if (MemDbGetValueAndFlagsW (Node, &Sequencer, &Flags)) {
        Flags &= Operations;

        if (Flags) {
            Operation = Flags & (~(Flags - 1));

            MYASSERT (ONEBITSET (Operation));

            PropertyOffset = GetPathPropertyOffset (Sequencer, Operation, Property);

            if (PropertyOffset != INVALID_OFFSET) {
                if (PropertyBuf) {
                    b = MemDbBuildKeyFromOffsetW (PropertyOffset, PropertyBuf, 1, NULL);
                } else {
                    b = TRUE;
                }
            }
        }
    }

    return b;
}


BOOL
GetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    )

/*++

Routine Description:

  GetPathProperty obtains a specific property for a path.

Arguments:

  FileSpec   - Specifies the path the property is associated with
  Operations - Specifies the operation flags to search.  The function will
               return the first property to match.
  Property   - Specifies the property index
  ProperyBuf - Receives the property data

Return Value:

  TRUE if a property was copied to PropertyBuf, FALSE otherwise.

--*/

{
    WCHAR LongFileSpec[MEMDB_MAX];

    MYASSERT (!(Operations & OPERATION_SHORT_FILE_NAME));

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    return pGetPathPropertyW (LongFileSpec, Operations, Property, PropertyBuf);
}


BOOL
pEnumFirstPathInOperationWorker (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumPath,
    OUT     PDWORD Sequencer,
    IN      OPERATION Operation
    )
{
    WCHAR Node[MEMDB_MAX];
    UINT OperationNum;
    BOOL b;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationCategory (Node, OperationNum);
    StringCopyW (AppendWack (Node), L"*");

    b = MemDbEnumFirstValueW (EnumPtr, Node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY);

    if (b) {
        MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, EnumPath, 1, Sequencer);
    }

    return b;
}


BOOL
pEnumNextFileOpOrProperty (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumPathOrData,
    OUT     PWSTR PropertyName,         OPTIONAL
    OUT     PDWORD Sequencer            OPTIONAL
    )
{
    BOOL b;
    WCHAR Temp[MEMDB_MAX];
    PWSTR p;

    b = MemDbEnumNextValueW (EnumPtr);

    if (b) {
        if (PropertyName) {
            MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, Temp, 0, Sequencer);

            p = wcschr (Temp, L'\\');
            if (!p) {
                p = GetEndOfStringW (Temp);
            }

            StringCopyABW (PropertyName, Temp, p);

            if (*p) {
                p++;
            }

            StringCopyW (EnumPathOrData, p);

        } else {
            MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, EnumPathOrData, 1, Sequencer);
        }
    }

    return b;
}



BOOL
EnumFirstPathInOperationA (
    OUT     PFILEOP_ENUMA EnumPtr,
    IN      OPERATION Operation
    )
{
    BOOL b;
    WCHAR EnumPath[MAX_WCHAR_PATH];

    ZeroMemory (EnumPtr, sizeof (FILEOP_ENUMA));

    b = pEnumFirstPathInOperationWorker (
            &EnumPtr->MemDbEnum,
            EnumPath,
            &EnumPtr->Sequencer,
            Operation
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Path, EnumPath);
    }

    return b;
}


BOOL
EnumFirstPathInOperationW (
    OUT     PFILEOP_ENUMW EnumPtr,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  EnumFirstPathInOperation begins an enumeration of all paths for a
  particular operation.

Arguments:

  EnumPtr   - Receives the first enumerated item.
  Operation - Specifies the operation to enumerate.

Return Value:

  TRUE if a path was enumerated, or FALSE if the operation is not applied to
  any path.

--*/

{
    ZeroMemory (EnumPtr, sizeof (FILEOP_ENUMW));

    return pEnumFirstPathInOperationWorker (
                &EnumPtr->MemDbEnum,
                EnumPtr->Path,
                &EnumPtr->Sequencer,
                Operation
                );
}


BOOL
EnumNextPathInOperationA (
    IN OUT  PFILEOP_ENUMA EnumPtr
    )
{
    BOOL b;
    WCHAR EnumPath[MAX_WCHAR_PATH];

    b = pEnumNextFileOpOrProperty (
            &EnumPtr->MemDbEnum,
            EnumPath,
            NULL,
            &EnumPtr->Sequencer
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Path, EnumPath);
    }

    return b;
}


BOOL
EnumNextPathInOperationW (
    IN OUT  PFILEOP_ENUMW EnumPtr
    )
{
    return pEnumNextFileOpOrProperty (
                &EnumPtr->MemDbEnum,
                EnumPtr->Path,
                NULL,
                &EnumPtr->Sequencer
                );
}


BOOL
pEnumFirstPropertyWorker (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumData,
    OUT     PWSTR PropertyName,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )
{
    WCHAR Node[MEMDB_MAX];
    PWSTR p;
    UINT OperationNum;
    BOOL b;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);
    StringCopyW (AppendWack (Node), L"*");

    b = MemDbEnumFirstValueW (EnumPtr, Node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY);

    if (b) {
        MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, Node, 0, NULL);

        p = wcschr (Node, L'\\');
        if (!p) {
            p = GetEndOfStringW (Node);
        }

        StringCopyABW (PropertyName, Node, p);

        if (*p) {
            p++;
        }

        StringCopyW (EnumData, p);
    }

    return b;
}


BOOL
EnumFirstFileOpPropertyA (
    OUT     PFILEOP_PROP_ENUMA EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )
{
    BOOL b;
    WCHAR EnumData[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    ZeroMemory (EnumPtr, sizeof (FILEOP_PROP_ENUMA));

    b = pEnumFirstPropertyWorker (
            &EnumPtr->MemDbEnum,
            EnumData,
            PropertyName,
            Sequencer,
            Operation
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Property, EnumData);
        KnownSizeWtoA (EnumPtr->PropertyName, PropertyName);
    }

    return b;
}


BOOL
EnumFirstFileOpPropertyW (
    OUT     PFILEOP_PROP_ENUMW EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  EnumFirstFileOpProperty enumerates the first property associated with an
  operation on a specific path.

Arguments:

  EnumPtr   - Receives the enumerated item data
  Sequencer - Specifies the sequencer of the path to enumerate
  Operation - Specifies the operation to enumerate

Return Value:

  TRUE if a property was enumerated, or FALSE if the path and operation does
  not have any properties.

--*/

{
    ZeroMemory (EnumPtr, sizeof (FILEOP_PROP_ENUMW));

    return pEnumFirstPropertyWorker (
                &EnumPtr->MemDbEnum,
                EnumPtr->Property,
                EnumPtr->PropertyName,
                Sequencer,
                Operation
                );
}


BOOL
EnumNextFileOpPropertyA (
    IN OUT  PFILEOP_PROP_ENUMA EnumPtr
    )
{
    BOOL b;
    WCHAR EnumData[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    b = pEnumNextFileOpOrProperty (
            &EnumPtr->MemDbEnum,
            EnumData,
            PropertyName,
            NULL
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Property, EnumData);
        KnownSizeWtoA (EnumPtr->PropertyName, PropertyName);
    }

    return b;
}


BOOL
EnumNextFileOpPropertyW (
    IN OUT  PFILEOP_PROP_ENUMW EnumPtr
    )
{

    return pEnumNextFileOpOrProperty (
                &EnumPtr->MemDbEnum,
                EnumPtr->Property,
                EnumPtr->PropertyName,
                NULL
                );
}


BOOL
pEnumFileOpWorkerA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    )
{
    //
    // Transfer UNICODE results to enum struct
    //

    KnownSizeWtoA (EnumPtr->Path, EnumPtr->Enum.Path);
    KnownSizeWtoA (EnumPtr->Property, EnumPtr->Enum.Property);

    EnumPtr->Sequencer = EnumPtr->Enum.Sequencer;
    EnumPtr->PropertyNum = EnumPtr->Enum.PropertyNum;
    EnumPtr->CurrentOperation = EnumPtr->Enum.CurrentOperation;
    EnumPtr->PropertyValid = EnumPtr->Enum.PropertyValid;

    return TRUE;
}


BOOL
EnumFirstFileOpA (
    OUT     PALL_FILEOPS_ENUMA EnumPtr,
    IN      DWORD Operations,
    IN      PCSTR FileSpec                      OPTIONAL
    )
{
    BOOL b;
    PCWSTR UnicodeFileSpec;

    if (FileSpec) {
        UnicodeFileSpec = ConvertAtoW (FileSpec);
    } else {
        UnicodeFileSpec = NULL;
    }

    b = EnumFirstFileOpW (&EnumPtr->Enum, Operations, UnicodeFileSpec);

    if (UnicodeFileSpec) {
        FreeConvertedStr (UnicodeFileSpec);
    }

    if (b) {
        return pEnumFileOpWorkerA (EnumPtr);
    }

    return FALSE;
}


BOOL
EnumFirstFileOpW (
    OUT     PALL_FILEOPS_ENUMW EnumPtr,
    IN      DWORD Operations,
    IN      PCWSTR FileSpec                     OPTIONAL
    )

/*++

Routine Description:

  EnumFirstFileOp is a general-purpose enumerator.  It enumerates the paths
  and all properties from a set of operations.

Arguments:

  EnumPtr    - Receives the enumerated item data
  Operations - Specifies one or more operations to enumerate
  FileSpec   - Specifies a specific path to enumerate, or NULL to enumerate
               all paths that have the specified operation(s)

Return Value:

  TRUE if data was enuemrated, or FALSE if no data matches the specified
  operations and file spec.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];

    ZeroMemory (EnumPtr, sizeof (ALL_FILEOPS_ENUMW));

    EnumPtr->State = FO_ENUM_BEGIN;
    EnumPtr->Operations = Operations;
    EnumPtr->Path = EnumPtr->OpEnum.Path;
    EnumPtr->Property = EnumPtr->PropEnum.Property;

    if (FileSpec) {

        pFileOpsGetLongPathW (FileSpec, LongFileSpec);

        _wcssafecpy (EnumPtr->FileSpec, LongFileSpec, MAX_WCHAR_PATH);

    } else {
        StringCopyW (EnumPtr->FileSpec, L"*");
    }

    return EnumNextFileOpW (EnumPtr);
}


BOOL
EnumNextFileOpA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    )
{
    BOOL b;

    b = EnumNextFileOpW (&EnumPtr->Enum);

    if (b) {
        return pEnumFileOpWorkerA (EnumPtr);
    }

    return FALSE;
}


BOOL
EnumNextFileOpW (
    IN OUT  PALL_FILEOPS_ENUMW EnumPtr
    )
{
    DWORD w;

    while (EnumPtr->State != FO_ENUM_END) {

        switch (EnumPtr->State) {

        case FO_ENUM_BEGIN:
            //
            // Find the next operation
            //

            if (!EnumPtr->Operations) {
                EnumPtr->State = FO_ENUM_END;
                break;
            }

            w = EnumPtr->Operations & (~(EnumPtr->Operations - 1));
            MYASSERT (ONEBITSET (w));

            EnumPtr->CurrentOperation = w;
            EnumPtr->OperationNum = pWhichBitIsSet (w);
            EnumPtr->Operations ^= w;

            EnumPtr->State = FO_ENUM_BEGIN_PATH_ENUM;
            break;

        case FO_ENUM_BEGIN_PATH_ENUM:
            if (EnumFirstPathInOperationW (&EnumPtr->OpEnum, EnumPtr->CurrentOperation)) {
                EnumPtr->State = FO_ENUM_BEGIN_PROP_ENUM;
            } else {
                EnumPtr->State = FO_ENUM_BEGIN;
            }

            break;

        case FO_ENUM_BEGIN_PROP_ENUM:
            if (!IsPatternMatchW (EnumPtr->FileSpec, EnumPtr->Path)) {
                EnumPtr->State = FO_ENUM_NEXT_PATH;
                break;
            }

            EnumPtr->Sequencer = EnumPtr->OpEnum.Sequencer;
            EnumPtr->PropertyNum = 0;

            if (EnumFirstFileOpPropertyW (
                    &EnumPtr->PropEnum,
                    EnumPtr->Sequencer,
                    EnumPtr->CurrentOperation
                    )) {
                EnumPtr->State = FO_ENUM_RETURN_DATA;
                break;
            }

            EnumPtr->State = FO_ENUM_RETURN_PATH;
            break;

        case FO_ENUM_RETURN_PATH:
            EnumPtr->State = FO_ENUM_NEXT_PATH;
            EnumPtr->PropertyValid = FALSE;
            return TRUE;

        case FO_ENUM_RETURN_DATA:
            EnumPtr->State = FO_ENUM_NEXT_PROP;
            EnumPtr->PropertyValid = TRUE;
            return TRUE;

        case FO_ENUM_NEXT_PROP:
            EnumPtr->PropertyNum++;

            if (EnumNextFileOpPropertyW (&EnumPtr->PropEnum)) {
                EnumPtr->State = FO_ENUM_RETURN_DATA;
            } else {
                EnumPtr->State = FO_ENUM_NEXT_PATH;
            }

            break;

        case FO_ENUM_NEXT_PATH:
            if (EnumNextPathInOperationW (&EnumPtr->OpEnum)) {
                EnumPtr->State = FO_ENUM_BEGIN_PROP_ENUM;
            } else {
                EnumPtr->State = FO_ENUM_BEGIN;
            }

            break;
        }
    }

    return FALSE;
}


BOOL
TestPathsForOperationsA (
    IN      PCSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    )
{
    BOOL b;
    PCWSTR UnicodeBaseFileSpec;

    UnicodeBaseFileSpec = ConvertAtoW (BaseFileSpec);

    b = TestPathsForOperationsW (UnicodeBaseFileSpec, OperationsToFind);

    FreeConvertedStr (UnicodeBaseFileSpec);

    return b;
}


BOOL
TestPathsForOperationsW (
    IN      PCWSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    )

/*++

Routine Description:

  TestPathsForOperations scans all subpaths of the given base for a specific
  operation.  This function is typically used to test a directory for an
  operation on one of its files or subdirectories.

Arguments:

  BaseFileSpec     - Specifies the base path to scan
  OperationsToFind - Specifies one or more operations to look for

Return Value:

  TRUE if one of the operations was found within BaseFileSpec, or FALSE if no
  subpath of BaseFileSpec has one of the operations.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    MEMDB_ENUMW e;
    DWORD Operation;

    if (MemDbGetValueAndFlagsW (BaseFileSpec, NULL, &Operation)) {
        if (Operation & OperationsToFind) {
            return TRUE;
        }
    }

    pFileOpsGetLongPathW (BaseFileSpec, LongFileSpec);

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_PATHROOTW,
        LongFileSpec,
        L"*",
        NULL
        );

    if (MemDbEnumFirstValueW (&e, Node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (e.Flags & OperationsToFind) {
                return TRUE;
            }
        } while (MemDbEnumNextValueW (&e));
    }

    return FALSE;
}


BOOL
IsFileMarkedAsKnownGoodA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_KNOWN_GOODA,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueA (Node, NULL);
}



/*++

Routine Description:

  IsFileMarkedForAnnounce determines if a file is listed in DeferredAnnounce category.

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  TRUE if the file is listed or FALSE if it is not.

--*/

BOOL
IsFileMarkedForAnnounceA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueA (Node, NULL);
}

BOOL
IsFileMarkedForAnnounceW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueW (Node, NULL);
}

/*++

Routine Description:

  GetFileAnnouncement returnes the announcement value for a particular file.
  The possible values are ACT_... values in fileops.h

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  The announcement value.

--*/

DWORD
GetFileAnnouncementA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];
    DWORD result = ACT_UNKNOWN;

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsA (Node, NULL, &result);
    return result;
}

DWORD
GetFileAnnouncementW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD result = ACT_UNKNOWN;

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsW (Node, NULL, &result);
    return result;
}

/*++

Routine Description:

  GetFileAnnouncementContext returnes the context of a file that is
  marked for announcement.

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  The announcement context.

--*/

DWORD
GetFileAnnouncementContextA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];
    DWORD result = 0;

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsA (Node, &result, NULL);
    return result;
}

DWORD
GetFileAnnouncementContextW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD result = 0;

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsW (Node, &result, NULL);
    return result;
}

/*++

Routine Description:

  IsFileProvidedByNt checks to see if a specific file is going to
  be installed by standard NT setup.  This list was generated from
  calls to FileIsProviedByNt.

Arguments:

  FileName - Specifies the name of the file in long filename format

Return Value:

  TRUE if the file will be installed by standard NT installation, or
  FALSE if it will not.

--*/

BOOL
IsFileProvidedByNtA (
    IN      PCSTR FileName
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (Node, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
    return MemDbGetValueA (Node, NULL);
}

BOOL
IsFileProvidedByNtW (
    IN      PCWSTR FileName
    )
{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_NT_FILESW, FileName, NULL, NULL);
    return MemDbGetValueW (Node, NULL);
}




/*++

Routine Description:

  GetNewPathForFile copies the move path to the caller-supplied buffer
  if the file is marked to be moved.

Arguments:

  SrcFileSpec - Specifies the src file to query in long filename format

  NewPath - Receives a copy of the new location, or if the file is not
            being moved, receives a copy of the original file.

Return Value:

  TRUE if the file is marked to be moved and the destination was copied
  to NewPath, or FALSE if the file is not makred to be moved and
  SrcFileSpec was copied to NewPath.

--*/

BOOL
GetNewPathForFileA (
    IN      PCSTR SrcFileSpec,
    OUT     PSTR NewPath
    )
{
    BOOL b;
    PCWSTR UnicodeSrcFileSpec;
    WCHAR UnicodeNewPath[MAX_WCHAR_PATH];

    UnicodeSrcFileSpec = ConvertAtoW (SrcFileSpec);

    b = GetNewPathForFileW (UnicodeSrcFileSpec, UnicodeNewPath);

    FreeConvertedStr (UnicodeSrcFileSpec);

    if (b) {
        KnownSizeWtoA (NewPath, UnicodeNewPath);
    }

    return b;
}

BOOL
GetNewPathForFileW (
    IN      PCWSTR SrcFileSpec,
    OUT     PWSTR NewPath
    )
{
    DWORD Offset = INVALID_OFFSET;
    DWORD w;
    OPERATION Operation;
    UINT Sequencer;

    Sequencer = GetSequencerFromPathW (SrcFileSpec);

    StringCopyW (NewPath, SrcFileSpec);

    w = ALL_MOVE_OPERATIONS;
    while (w && Offset == INVALID_OFFSET) {
        Operation = w & (~(w - 1));
        w ^= Operation;
        Offset = GetPathPropertyOffset (Sequencer, Operation, 0);
    }

    if (Offset != INVALID_OFFSET) {
        return MemDbBuildKeyFromOffsetW (Offset, NewPath, 1, NULL);
    }

    return FALSE;
}


BOOL
AnnounceFileInReportA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr,
    IN      DWORD Action
    )

/*++

Routine Description:

  Adds a file to the memdb DeferredAnnounce category.

Arguments:

  FileSpec - Specifies the file to delete in long name format

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_DEFERREDANNOUNCEA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, Action, 0);

}


BOOL
MarkFileAsKnownGoodA (
    IN      PCSTR FileSpec
    )

/*++

Routine Description:

  Adds a file to the memdb KnownGood category.

Arguments:

  FileSpec - Specifies the file name

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    return MemDbSetValueExA (MEMDB_CATEGORY_KNOWN_GOODA, FileSpec, NULL, NULL, 0, NULL);
}


BOOL
AddCompatibleShellA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr                OPTIONAL
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleShell category.

Arguments:

  FileSpec - Specifies the file to delete in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_SHELLA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleRunKeyA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleRunKey category.

Arguments:

  FileSpec - Specifies the file to delete in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_RUNKEYA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleDosA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr                OPTIONAL
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleDos category.

Arguments:

  FileSpec - Specifies the file in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_DOSA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleHlpA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleHlp category.

Arguments:

  FileSpec - Specifies the file in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_HLPA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


//
// Compute the number of CHARs allowed for the normal and long temp
// locations. MAX_PATH includes the nul terminator, and we subtract
// that terminator via sizeof.
//
// NORMAL_MAX is the number of chars left after the subdir c:\user~tmp.@01\,
// including the nul
//
// LONG_MAX is the number of chars left after the subdir
// c:\user~tmp.@02\12345\, including the nul. 12345 is a %05X sequencer.
//

#define NORMAL_MAX      (MAX_PATH - (sizeof(S_SHELL_TEMP_NORMAL_PATHA)/sizeof(CHAR)) + 2)
#define LONG_MAX        (MAX_PATH - (sizeof(S_SHELL_TEMP_LONG_PATHA)/sizeof(CHAR)) - 6)

VOID
ComputeTemporaryPathA (
    IN      PCSTR SourcePath,
    IN      PCSTR SourcePrefix,     OPTIONAL
    IN      PCSTR TempPrefix,       OPTIONAL
    IN      PCSTR SetupTempDir,
    OUT     PSTR TempPath
    )

/*++

Routine Description:

  ComputeTemporaryPath builds a temporary path rooted in
  S_SHELL_TEMP_NORMAL_PATH for a path that fits within MAX_PATH, or
  S_SHELL_TEMP_LONG_PATH for a longer path. It attempts to use the original
  subpath name in the "normal" path subdirectory. If that doesn't fit, then a
  unique "long" subdirectory is created, and a subpath is computed by taking
  the longest possible subpath (the right side).

Arguments:

  SourcePath - Specifies the full file or directory path of the source

  SourcePrefix - Specifies a prefix that will be stripped from SourcePath

  TempPrefix - Specifies a prefix that will be inserted at the start of
               TempPath

  SetupTempDir - Specifies the setup temp dir, typically %windir%\setup,
                 to be used when no suitable path can be computed. (Unlikely
                 case.)

  TempPath - Receives the temp path string. This buffer will receive up to
             MAX_PATH characters (includes the nul).

Return Value:

  None.

--*/

{
    PCSTR subPath = NULL;
    PCSTR smallerSubPath;
    PSTR pathCopy = NULL;
    PSTR lastWack;
    static UINT dirSequencer = 0;
    UINT prefixLen;
    MBCHAR ch;
    UINT normalMax = NORMAL_MAX;

    //
    // Build a temporary file name using the inbound file as a suggestion.
    //

    StringCopyA (TempPath, S_SHELL_TEMP_NORMAL_PATHA);
    TempPath[0] = SourcePath[0];

    if (SourcePrefix) {
        prefixLen = TcharCountA (SourcePrefix);
        if (StringIMatchTcharCountA (SourcePath, SourcePrefix, prefixLen)) {
            ch = _mbsnextc (SourcePath + prefixLen);
            if (!ch || ch == '\\') {
                subPath = SourcePath + prefixLen;
                if (*subPath) {
                    subPath++;
                }
            }
        }
    }

    if (!subPath) {
        subPath = _mbschr (SourcePath, '\\');
        if (!subPath) {
            subPath = SourcePath;
        } else {
            subPath++;
        }
    }

    DEBUGMSGA_IF ((_mbschr (subPath, ':') != NULL, DBG_WHOOPS, "Bad temp path: %s", SourcePath));

    if (TempPrefix) {
        StringCopyA (AppendWackA (TempPath), TempPrefix);
        normalMax = MAX_PATH - TcharCountA (TempPath);
    }

    if (TcharCountA (subPath) < normalMax) {
        //
        // typical case: source path fits within MAX_PATH; use it
        //
        if (*subPath) {
            StringCopyA (AppendWackA (TempPath), subPath);
        }

    } else {
        //
        // subpath is too big, just take the right side of the src
        //

        dirSequencer++;
        wsprintfA (TempPath, S_SHELL_TEMP_LONG_PATHA "\\%05x", dirSequencer);
        TempPath[0] = SourcePath[0];

        // compute end of string + nul terminator - backslash - (MAX_PATH - TcharCount of TempPath)
        subPath = GetEndOfStringA (SourcePath) - LONG_MAX;

        //
        // try to eliminate a truncated subdirectory on the left
        //

        smallerSubPath = _mbschr (subPath, '\\');
        if (smallerSubPath && smallerSubPath[1]) {
            subPath = smallerSubPath + 1;
        } else {

            //
            // still no subpath, try just the file name
            //

            subPath = _mbsrchr (subPath, '\\');
            if (subPath) {
                subPath++;
                if (!(*subPath)) {
                    //
                    // file spec ends in backslash
                    //
                    pathCopy = DuplicateTextA (SourcePath);
                    if (!pathCopy) {
                        subPath = NULL;
                    } else {

                        for (;;) {
                            lastWack = _mbsrchr (pathCopy, '\\');
                            if (!lastWack || lastWack[1]) {
                                break;
                            }

                            *lastWack = 0;
                        }

                        subPath = lastWack;
                    }

                } else if (TcharCountA (subPath) > LONG_MAX) {
                    //
                    // very long file name; truncate it
                    //
                    subPath = GetEndOfStringA (subPath) - LONG_MAX;
                }
            }
        }

        if (subPath) {
            StringCopyA (AppendWackA (TempPath), subPath);
        } else {
            dirSequencer++;
            wsprintfA (TempPath, "%s\\tmp%05x", SetupTempDir, dirSequencer);
        }

        if (pathCopy) {
            FreeTextA (pathCopy);
        }
    }

}


BOOL
pMarkFileForTemporaryMoveA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile,
    IN      PCSTR TempFileIn,           OPTIONAL
    OUT     PSTR TempFileOut            OPTIONAL
    )

/*++

Routine Description:

  This routine adds operations to move a file to a temporary location in
  text mode, and optionally move it to a final destination.

Arguments:

  SrcFileSpec   - Specifies the file that is to be moved to a safe place (out
                  of the way of normal NT installation), and then moved back
                  after NT is installed.

  FinalDest     - Specifies the final destination for FileSpec.  If NULL, file
                  is moved to a temporary location but is not copied to a final
                  location in GUI mode.

  TempSpec      - Specifies the temp dir or file to relocate the file to.  The temp dir
                  must be on the same drive as SrcFileSpec.

  TempSpecIsFile - Specifies TRUE if the prev param is a file

  TempFileIn    - If non-NULL, specifies the temporary file to use instead of
                  automatically generated name.  Provided only for
                  MarkHiveForTemporaryMove.

  TempFileOut   - If non-NULL, receives the path to the temporary file location.

Return Value:

  TRUE if the operation was recorded, or FALSE otherwise.

--*/

{
    BOOL b = TRUE;
    CHAR TempFileSpec[MAX_MBCHAR_PATH];
    static DWORD FileSequencer = 0;

    //
    // Move the file from source to temporary location
    //

    if (!CanSetOperationA (SrcFileSpec, OPERATION_TEMP_PATH)) {
        return FALSE;
    }

    if (TempFileIn) {
        MYASSERT (!TempSpecIsFile);
        wsprintfA (TempFileSpec, "%s\\%s", TempSpec, TempFileIn);
    } else if (TempSpecIsFile) {
        StringCopyA (TempFileSpec, TempSpec);
    } else {
        FileSequencer++;
        wsprintfA (TempFileSpec, "%s\\tmp%05x", TempSpec, FileSequencer);
    }

    DEBUGMSGA ((DBG_MEMDB, "MarkFileForTemporaryMove: %s -> %s", SrcFileSpec, TempFileSpec));

    if (TempFileOut) {
        StringCopyA (TempFileOut, TempFileSpec);
    }

    RemoveOperationsFromPathA (SrcFileSpec, OPERATION_TEMP_PATH | OPERATION_FILE_DELETE_EXTERNAL | OPERATION_FILE_MOVE_EXTERNAL);

    b = AssociatePropertyWithPathA (SrcFileSpec, OPERATION_TEMP_PATH, TempFileSpec);

    //
    // Optionally move the file from temporary location to final dest
    //

    if (FinalDest) {
        //
        // We are adding additional properties to the temp path operation that
        // already exists.  So the properties are defined as zero being the temp
        // path, and one and higher being destinations. That's how we achieve
        // a one-to-many capability.
        //

        b = b && AssociatePropertyWithPathA (SrcFileSpec, OPERATION_TEMP_PATH, FinalDest);

        //
        // Now we add an external move operation, so the registry is updated
        // correctly.
        //

        b = b && MarkFileForMoveExternalA (SrcFileSpec, FinalDest);

    } else {
        //
        // Because the source file is going to be moved to a temporary location
        // and never moved back, it is effectively going to be deleted.
        //

        b = b && MarkFileForExternalDeleteA (SrcFileSpec);
    }

    return b;
}


BOOL
MarkFileForTemporaryMoveExA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile
    )
{
    return pMarkFileForTemporaryMoveA (SrcFileSpec, FinalDest, TempSpec, TempSpecIsFile, NULL, NULL);
}

PCSTR
GetTemporaryLocationForFileA (
    IN      PCSTR SourceFile
    )
{
    UINT sequencer;
    PCSTR result = NULL;
    FILEOP_PROP_ENUMA eOpProp;

    sequencer = GetSequencerFromPathA (SourceFile);

    if (sequencer) {
        if (EnumFirstFileOpPropertyA (&eOpProp, sequencer, OPERATION_TEMP_PATH)) {
            result = DuplicatePathStringA (eOpProp.Property, 0);
        }
    }
    return result;
}

PCWSTR
GetTemporaryLocationForFileW (
    IN      PCWSTR SourceFile
    )
{
    UINT sequencer;
    PCWSTR result = NULL;
    FILEOP_PROP_ENUMW eOpProp;

    sequencer = GetSequencerFromPathW (SourceFile);

    if (sequencer) {
        if (EnumFirstFileOpPropertyW (&eOpProp, sequencer, OPERATION_TEMP_PATH)) {
            result = DuplicatePathStringW (eOpProp.Property, 0);
        }
    }
    return result;
}


BOOL
MarkHiveForTemporaryMoveA (
    IN      PCSTR HivePath,
    IN      PCSTR TempDir,
    IN      PCSTR UserName,
    IN      BOOL DefaultHives,
    IN      BOOL CreateOnly
    )

/*++

Routine Description:

  Adds a file or directory path to the TempReloc memdb category.  The file or
  dir is moved during text mode and is never moved back.  If the file name is
  user.dat, the destination location is written to the UserDatLoc category.

  All hives are deleted at the end of setup.

Arguments:

  HivePath - Specifies the Win9x path to a user.dat or system.dat file

  TempDir - Specifies the path to the setup temporary dir on the same drive
            as HivePath

  UserName - Specifies the current user or NULL if default user or no user

  DefaultHives - Specifies TRUE if the HivePath is a system default path, or
                 FALSE if the HivePath is specific to a user profile.

  CreateOnly - Specifies TRUE if this account is create-only (such as
               Administrator), or FALSE if this account gets full migration.

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    BOOL b = TRUE;
    CHAR OurTempFileSpec[MAX_MBCHAR_PATH];
    CHAR RealTempFileSpec[MAX_MBCHAR_PATH];
    static DWORD Sequencer = 0;
    PSTR p, q;

    if (!UserName || !UserName[0]) {
        UserName = S_DOT_DEFAULTA;
    }

    //
    // Has hive already been moved?  If so, point two or more users to
    // the same hive.
    //

    RealTempFileSpec[0] = 0;
    p = (PSTR) GetFileNameFromPathA (HivePath);

    GetPathPropertyA (HivePath, OPERATION_TEMP_PATH, 0, RealTempFileSpec);

    if (!(RealTempFileSpec[0])) {
        //
        // Hive has not been moved yet -- move it now
        //

        if (!DefaultHives) {
            Sequencer++;
            wsprintfA (OurTempFileSpec, "hive%04u\\%s", Sequencer, p);
        } else {
            wsprintfA (OurTempFileSpec, "defhives\\%s", p);
        }

        b = pMarkFileForTemporaryMoveA (
                HivePath,
                NULL,
                TempDir,
                FALSE,
                OurTempFileSpec,
                RealTempFileSpec
                );

        if (b && DefaultHives) {
            //
            // Save defhives location in Paths\RelocWinDir
            //

            q = _mbsrchr (RealTempFileSpec, '\\');
            MYASSERT(q);
            *q = 0;

            b = MemDbSetValueExA (
                    MEMDB_CATEGORY_PATHSA,      // "Paths"
                    MEMDB_ITEM_RELOC_WINDIRA,   // "RelocWinDir"
                    RealTempFileSpec,           // Path to default hives
                    NULL,
                    0,
                    NULL
                    );

            *q = '\\';
        }
    }

    if (b && StringIMatchA (p, "USER.DAT")) {
        //
        // Save location to all user.dat files in UserDatLoc
        //

        b = MemDbSetValueExA (
                MEMDB_CATEGORY_USER_DAT_LOCA,
                UserName,
                NULL,
                RealTempFileSpec,
                (DWORD) CreateOnly,
                NULL
                );
    }

    if (b) {
        DEBUGMSGA ((DBG_NAUSEA, "%s -> %s", HivePath, RealTempFileSpec));
    }

    return b;
}


VOID
MarkShellFolderForMoveA (
    IN      PCSTR SrcPath,
    IN      PCSTR TempPath
    )
{
    DWORD Offset;

    //
    // Add an entry so the specified source file or directory
    // is moved to the temp path.
    //

    MemDbSetValueExA (
        MEMDB_CATEGORY_SHELL_FOLDERS_PATHA,
        SrcPath,
        NULL,
        NULL,
        0,
        &Offset
        );

    MemDbSetValueExA (
        MEMDB_CATEGORY_SF_TEMPA,
        TempPath,
        NULL,
        NULL,
        Offset,
        NULL
        );
}


BOOL
EnumFirstFileRelocA (
    OUT     PFILERELOC_ENUMA EnumPtr,
    IN      PCSTR FileSpec             OPTIONAL
    )
{
    if (EnumFirstFileOpA (&EnumPtr->e, ALL_DEST_CHANGE_OPERATIONS, FileSpec)) {
        if (!EnumPtr->e.PropertyValid) {
            return EnumNextFileRelocA (EnumPtr);
        } else {
            StringCopyA (EnumPtr->SrcFile, EnumPtr->e.Path);
            StringCopyA (EnumPtr->DestFile, EnumPtr->e.Property);

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnumNextFileRelocA (
    IN OUT  PFILERELOC_ENUMA EnumPtr
    )
{
    do {
        if (!EnumNextFileOpA (&EnumPtr->e)) {
            return FALSE;
        }
    } while (!EnumPtr->e.PropertyValid);

    StringCopyA (EnumPtr->SrcFile, EnumPtr->e.Path);
    StringCopyA (EnumPtr->DestFile, EnumPtr->e.Property);

    return TRUE;
}


/*++

Routine Description:

  DeclareTemporaryFile adds a file to the memdb FileDel and CancelFileDel
  category. That means the file will get deleted if the user hits CANCEL
  or at the end of GUI mode setup.

Arguments:

  FileSpec - Specifies the file to declare in long name format

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

BOOL
DeclareTemporaryFileA (
    IN      PCSTR FileSpec
    )

{
    return MarkFileForCleanUpA (FileSpec) &&
           MemDbSetValueExA (MEMDB_CATEGORY_CANCELFILEDELA, FileSpec, NULL, NULL, 0, NULL);

}


BOOL
DeclareTemporaryFileW (
    IN      PCWSTR FileSpec
    )

{
    return MarkFileForCleanUpW (FileSpec) &&
           MemDbSetValueExW (MEMDB_CATEGORY_CANCELFILEDELW, FileSpec, NULL, NULL, 0, NULL);

}



/*++

Routine Description:

  FileIsProvidedByNt identifies a file as being installed by Windows NT.
  An entry is made in the NtFiles category for the file name, and the file
  name is linked to the full path in NtDirs.

  This funciton is implemented as an A version only because the list is
  created on the Win9x side of the upgrade.

Arguments:

  FullPath - Specifies the full path, including the file name.

  FileName - Specifiles the file name only

  UserFlags - Specifies if the existence of NT file should be verified very first
              thing on NT side.

Return Value:

  TRUE if memdb was updated, or FALSE if an error occurred.

--*/

BOOL
FileIsProvidedByNtA (
    IN      PCSTR FullPath,
    IN      PCSTR FileName,
    IN      DWORD UserFlags
    )
{
    DWORD Offset;
    PSTR DirOnly;
    CHAR Key[MEMDB_MAX];
    PSTR p;
    BOOL b;

    DirOnly = DuplicatePathStringA (FullPath, 0);
    p = _mbsrchr (DirOnly, '\\');
    if (p) {
        *p = 0;
    }

    b = MemDbSetValueExA (
            MEMDB_CATEGORY_NT_DIRSA,
            DirOnly,
            NULL,
            NULL,
            0,
            &Offset
            );

    if (b) {
        MemDbBuildKeyA (Key, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
        b = MemDbSetValueAndFlagsA (Key, Offset, UserFlags, 0);
    }

    FreePathStringA (DirOnly);

    return b;
}



/*++

Routine Description:

  GetNtFilePath looks in the NtFiles category for the specified file,
  and if found builds the complete path.

Arguments:

  FileName - Specifies the file that may be installed by NT

  FullPath - Receives the full path to the file as it will be installed

Return Value:

  TRUE if the file exists and there were no errors building the path,
  or FALSE if the file does not exist or the path could not be built.

--*/

BOOL
GetNtFilePathA (
    IN      PCSTR FileName,
    OUT     PSTR FullPath
    )
{
    DWORD Offset;
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (Node, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
    if (MemDbGetValueA (Node, &Offset)) {
        if (MemDbBuildKeyFromOffsetA (Offset, FullPath, 1, NULL)) {
            StringCopyA (AppendPathWackA (FullPath), FileName);
            return TRUE;
        }

        DEBUGMSG ((DBG_WHOOPS, "GetNtFilePath: Could not build path from offset"));
    }

    return FALSE;
}


BOOL
GetNtFilePathW (
    IN      PCWSTR FileName,
    OUT     PWSTR FullPath
    )
{
    DWORD Offset;
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_NT_FILESW, FileName, NULL, NULL);
    if (MemDbGetValueW (Node, &Offset)) {
        if (MemDbBuildKeyFromOffsetW (Offset, FullPath, 1, NULL)) {
            StringCopyW (AppendPathWackW (FullPath), FileName);
            return TRUE;
        }

        DEBUGMSG ((DBG_WHOOPS, "GetNtFilePath: Could not build path from offset"));
    }

    return FALSE;
}


DWORD
GetFileInfoOnNtW (
    IN      PCWSTR FileSpec,
    OUT     PWSTR  NewFileSpec,   // OPTIONAL
    IN      UINT   BufferChars    // Required if NewFileSpec is specified
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD Operations;
    DWORD Offset;
    WCHAR NtFilePath[MEMDB_MAX];
    WCHAR DestPath[MEMDB_MAX];
    PCWSTR InboundPath;
    BOOL UserFile = FALSE;
    DWORD status = FILESTATUS_UNCHANGED;
    BOOL ShortFileNameFlag;
    PCWSTR UltimateDestiny;
    BOOL NtProvidesThisFile;
    WCHAR LongFileSpec[MAX_WCHAR_PATH];
    PCWSTR SanitizedPath;
    PCSTR ansiPath;
    CHAR ansiOutput[MAX_MBCHAR_PATH];
    PWSTR lastWack;

    //
    // Require FileSpec to be a local path and less than MAX_WCHAR_PATH
    //

    if (lstrlen (FileSpec) >= MAX_WCHAR_PATH) {
        if (NewFileSpec) {
            _wcssafecpy (NewFileSpec, FileSpec, BufferChars * sizeof (WCHAR));
        }

        return 0;
    }

    //
    // Now get the file status of an actual path
    //

    SanitizedPath = SanitizePathW (FileSpec);
    if (!SanitizedPath) {
        SanitizedPath = DuplicatePathStringW (FileSpec, 0);
    }

    lastWack = wcsrchr (SanitizedPath, L'\\');
    if (lastWack) {
        if (lastWack[1] != 0 || lastWack == wcschr (SanitizedPath, L'\\')) {
            lastWack = NULL;
        } else {
            *lastWack = 0;
        }
    }

    pFileOpsGetLongPathW (SanitizedPath, LongFileSpec);
    if (!StringIMatchW (SanitizedPath, LongFileSpec)) {
        InboundPath = LongFileSpec;
        ShortFileNameFlag = TRUE;
    } else {
        InboundPath = SanitizedPath;
        ShortFileNameFlag = FALSE;
    }

    DestPath[0] = 0;
    UltimateDestiny = InboundPath;

    //
    // Get all operations set on the file
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, InboundPath, NULL, NULL);
    if (!MemDbGetValueAndFlagsW (Node, NULL, &Operations)) {
        Operations = 0;
    }

    //
    // Migration DLLs have priority over all other operations
    //

    if (Operations & OPERATION_MIGDLL_HANDLED) {

        if (Operations & OPERATION_FILE_DELETE_EXTERNAL) {
            status = FILESTATUS_DELETED;
        } else {
            status = FILESTATUS_REPLACED;
            if (Operations & OPERATION_FILE_MOVE_EXTERNAL) {
                status |= FILESTATUS_MOVED;
                GetNewPathForFileW (InboundPath, DestPath);
                UltimateDestiny = DestPath;
            }
        }

    } else {
        //
        // Check for per-user move
        //

        if (g_CurrentUser) {
            MemDbBuildKeyW (
                Node,
                MEMDB_CATEGORY_USERFILEMOVE_SRCW,
                InboundPath,
                g_CurrentUser,
                NULL
                );

            if (MemDbGetValueW (Node, &Offset)) {
                if (MemDbBuildKeyFromOffsetW (Offset, DestPath, 1, NULL)) {
                    status = FILESTATUS_MOVED;
                    UltimateDestiny = DestPath;
                }

                UserFile = TRUE;
            }
        }

        //
        // Check for move or delete
        //

        if (!UserFile) {
            if (Operations & ALL_MOVE_OPERATIONS) {
                status = FILESTATUS_MOVED;
                GetNewPathForFileW (InboundPath, DestPath);
                UltimateDestiny = DestPath;
                if (Operations & OPERATION_FILE_MOVE_EXTERNAL) {
                    status |= FILESTATUS_REPLACED;
                }
            } else if (Operations & ALL_DELETE_OPERATIONS) {
                status = FILESTATUS_DELETED;
            }
        }

        //
        // Check if the file (or the new destination) is an NT file
        //

        NtProvidesThisFile = GetNtFilePathW (GetFileNameFromPathW (UltimateDestiny), NtFilePath);

        if (status != FILESTATUS_UNCHANGED && NtProvidesThisFile) {

            //
            // Status may be either FILESTATUS_MOVED or FILESTATUS_DELETED.
            //

            if (StringIMatchW (UltimateDestiny, NtFilePath)) {

                //
                // NT installs the same file, so now we know that the ultimate
                // destiny isn't deleted.
                //

                status &= ~FILESTATUS_DELETED;
                status |= FILESTATUS_REPLACED|FILESTATUS_NTINSTALLED;

            } else if (Operations & ALL_DELETE_OPERATIONS) {

                //
                // NT installs the same file but in a different location
                // and the original file was to be deleted.  The
                // ultimate destiny is the NT location, and we know that the
                // file is moved.
                //

                status = FILESTATUS_MOVED|FILESTATUS_REPLACED|FILESTATUS_NTINSTALLED;
                UltimateDestiny = NtFilePath;

            } else {

                status |= FILESTATUS_NTINSTALLED;

            }

        } else if (NtProvidesThisFile) {

            //
            // Status is FILESTATUS_UNCHANGED
            //

            status = FILESTATUS_NTINSTALLED;

            if (StringIMatchW (UltimateDestiny, NtFilePath)) {
                status |= FILESTATUS_REPLACED;
            }
        }

        if (!ShortFileNameFlag && (status == FILESTATUS_UNCHANGED)) {
            //
            // let's check for this case: undetected short file name query, NT installs this file in the same path
            //
            if (ISNT()) {
                OurGetLongPathNameW (SanitizedPath, LongFileSpec, MAX_WCHAR_PATH);

                if (!StringMatchW (UltimateDestiny, LongFileSpec)) {
                    //
                    // this was an undetected short file name query
                    //
                    NtProvidesThisFile = GetNtFilePathW (GetFileNameFromPathW (UltimateDestiny), NtFilePath);

                    if (StringIMatchW (UltimateDestiny, NtFilePath)) {
                        status |= FILESTATUS_REPLACED;
                    }
                }
            }
        }
    }

    //
    // Return the new path to the caller
    //

    if (NewFileSpec) {
        if (lastWack) {
            //
            // BUGBUG - ugly truncation can happen here
            //

            BufferChars -= sizeof (WCHAR);
        }

        if (status & FILESTATUS_MOVED) {

            if (ShortFileNameFlag) {
                if (ISNT()) {
                    if (!OurGetShortPathNameW (UltimateDestiny, NewFileSpec, MAX_WCHAR_PATH)) {
                        _wcssafecpy (NewFileSpec, UltimateDestiny, BufferChars * sizeof (WCHAR));
                    }
                } else {
                    ansiPath = ConvertWtoA (UltimateDestiny);
                    if (!OurGetShortPathNameA (ansiPath, ansiOutput, ARRAYSIZE(ansiOutput))) {
                        _mbssafecpy (ansiOutput, ansiPath, BufferChars);
                    }
                    FreeConvertedStr (ansiPath);

                    KnownSizeAtoW (NewFileSpec, ansiOutput);
                }
            } else {
                _wcssafecpy (NewFileSpec, UltimateDestiny, BufferChars * sizeof (WCHAR));
            }
        } else {
            _wcssafecpy (NewFileSpec, SanitizedPath, BufferChars * sizeof (WCHAR));
        }

        if (lastWack) {
            AppendWackW (NewFileSpec);
        }
    }

    if (Operations & ALL_CONTENT_CHANGE_OPERATIONS) {
        status |= FILESTATUS_BACKUP;
    }

    FreePathStringW (SanitizedPath);

    return status;
}


DWORD
GetFileStatusOnNtW (
    IN      PCWSTR FileName
    )
{
    return GetFileInfoOnNtW (FileName, NULL, 0);
}


PWSTR
GetPathStringOnNtW (
    IN      PCWSTR FileName
    )
{
    PWSTR newFileName;

    newFileName = AllocPathStringW (MEMDB_MAX);

    GetFileInfoOnNtW (FileName, newFileName, MEMDB_MAX);

    return newFileName;
}


DWORD
GetFileInfoOnNtA (
    IN      PCSTR FileName,
    OUT     PSTR  NewFileName,   // OPTIONAL
    IN      UINT  BufferChars    // Required if NewFileSpec is specified
    )
{
    PCWSTR UnicodeFileName;
    PWSTR UnicodeNewFileName = NULL;
    DWORD fileStatus;

    if (NewFileName && BufferChars) {
        UnicodeNewFileName = AllocPathStringW (BufferChars);
    }

    UnicodeFileName = ConvertAtoW (FileName);

    fileStatus = GetFileInfoOnNtW (UnicodeFileName, UnicodeNewFileName, BufferChars);

    FreeConvertedStr (UnicodeFileName);

    if (NewFileName && BufferChars) {

        KnownSizeWtoA (NewFileName, UnicodeNewFileName);

        FreePathStringW (UnicodeNewFileName);
    }

    return fileStatus;
}


DWORD
GetFileStatusOnNtA (
    IN      PCSTR FileName
    )
{
    return GetFileInfoOnNtA (FileName, NULL, 0);
}


PSTR
GetPathStringOnNtA (
    IN      PCSTR FileName
    )
{
    PSTR newFileName;

    newFileName = AllocPathStringA (MEMDB_MAX);

    GetFileInfoOnNtA (FileName, newFileName, MEMDB_MAX);

    return newFileName;
}



/*++

Routine Description:

  ExtractArgZero locates the first argument in a command line and copies
  it to Buffer.  Assumes the break is the first space character, the ending
  quote of a quoted argument, or the nul terminator.

Arguments:

  CmdLine - Specifies the full command line that has zero or more arguments

  Buffer - Receives the  first argument on the command line if it exists, or
           an empty string if it does not exist.  Must hold MAX_TCHAR_PATH
           bytes.

  TerminatingChars - Specifies character set that terminates the command line arg.
                     If NULL, the set " ,;"

Return Value:

  none

--*/

PCSTR
ExtractArgZeroExA (
    IN      PCSTR CmdLine,
    OUT     PSTR Buffer,
    IN      PCSTR TerminatingChars,     OPTIONAL
    IN      BOOL KeepQuotes
    )
{
    CHAR cmdLine1 [MAX_CMDLINE];
    CHAR cmdLine2 [MAX_CMDLINE];
    PSTR spacePtr1 [MAX_PATH];
    PSTR spacePtr2 [MAX_PATH];
    UINT spaceIdx = 0;
    PSTR ptr1 = cmdLine1;
    PSTR ptr2 = cmdLine2;
    PSTR end;
    CHAR saved;
    PCSTR s = CmdLine;
    BOOL inQuote = FALSE;
    BOOL skipQuotes = FALSE;
    MBCHAR ch;
    BOOL fullPath = FALSE;
    WIN32_FIND_DATAA FindData;

    ch = _mbsnextc (CmdLine);
    fullPath = (isalpha (ch) && *(_mbsinc (CmdLine)) == ':');

    for (;;) {

        ch = _mbsnextc (s);

        if (ch == 0) {
            break;
        }

        if (ch == '\"') {
            skipQuotes = TRUE;
            inQuote = !inQuote;
        }
        else {
            if (!inQuote) {
                if (TerminatingChars && _mbschr (TerminatingChars, ch)) {
                    break;
                }
                if (isspace (ch)) {
                    if (spaceIdx < MAX_PATH) {
                        spacePtr1 [spaceIdx] = ptr1;
                        spacePtr2 [spaceIdx] = ptr2;
                        spaceIdx ++;
                    }
                    else {
                        // too many spaces. We better stop now.
                        break;
                    }
                }
            }

        }
        if (KeepQuotes && skipQuotes) {
            _copymbchar (ptr2, s);
            ptr2 = _mbsinc (ptr2);
        }
        if (skipQuotes) {
            skipQuotes = FALSE;
        }
        else {
            _copymbchar (ptr1, s);
            ptr1 = _mbsinc (ptr1);
            _copymbchar (ptr2, s);
            ptr2 = _mbsinc (ptr2);
        }
        s = _mbsinc(s);
    }

    saved = 0;
    *ptr1 = 0;
    *ptr2 = 0;
    end = ptr2;
    for (;;) {
        if (fullPath && DoesFileExistExA (cmdLine1, &FindData)) {
            break;
        }

        if (ISNT()) {
            if (GetOperationsOnPathA (cmdLine1)) {
                break;
            }
        }

        if (spaceIdx) {
            spaceIdx --;
            *ptr2 = saved;
            ptr1 = spacePtr1 [spaceIdx];
            ptr2 = spacePtr2 [spaceIdx];
            if (fullPath) {
                saved = *ptr2;
            }
            *ptr1 = 0;
            *ptr2 = 0;
        }
        else {
            *ptr2 = saved;
            break;
        }
    }

    StringCopyA (Buffer, cmdLine2);

    if (*ptr2) {
        return (CmdLine + (end - cmdLine2));
    }
    else {
        return (CmdLine + (ptr2 - cmdLine2));
    }
}


PCWSTR
ExtractArgZeroExW (
    IN      PCWSTR CmdLine,
    OUT     PWSTR Buffer,
    IN      PCWSTR TerminatingChars,    OPTIONAL
    IN      BOOL KeepQuotes
    )
{
    WCHAR cmdLine1 [MAX_CMDLINE];
    WCHAR cmdLine2 [MAX_CMDLINE];
    PWSTR spacePtr1 [MAX_PATH];
    PWSTR spacePtr2 [MAX_PATH];
    UINT spaceIdx = 0;
    PWSTR ptr1 = cmdLine1;
    PWSTR ptr2 = cmdLine2;
    PWSTR end;
    WCHAR saved;
    PCWSTR s = CmdLine;
    BOOL inQuote = FALSE;
    BOOL skipQuotes = FALSE;
    BOOL fullPath = FALSE;
    WIN32_FIND_DATAW FindData;

    fullPath = (iswalpha (CmdLine[0]) && (CmdLine[1] == L':'));

    for (;;) {

        if (*s == 0) {
            break;
        }

        if (*s == '\"') {
            skipQuotes = TRUE;
            inQuote = !inQuote;
        }
        else {
            if (!inQuote) {
                if (TerminatingChars && wcschr (TerminatingChars, *s)) {
                    break;
                }
                if (iswspace (*s)) {
                    if (spaceIdx < MAX_PATH) {
                        spacePtr1 [spaceIdx] = ptr1;
                        spacePtr2 [spaceIdx] = ptr2;
                        spaceIdx ++;
                    }
                    else {
                        // too many spaces. We better stop now.
                        break;
                    }
                }
            }

        }
        if (KeepQuotes && skipQuotes) {
            *ptr2 = *s;
            ptr2 ++;
        }
        if (skipQuotes) {
            skipQuotes = FALSE;
        }
        else {
            *ptr1 = *s;
            ptr1 ++;
            *ptr2 = *s;
            ptr2 ++;
        }
        s ++;
    }

    saved = 0;
    *ptr1 = 0;
    *ptr2 = 0;
    end = ptr2;
    for (;;) {
        if (fullPath && DoesFileExistExW (cmdLine1, &FindData)) {
            break;
        }
        if (ISNT()) {
            if (GetOperationsOnPathW (cmdLine1)) {
                break;
            }
        }

        if (spaceIdx) {
            spaceIdx --;
            *ptr2 = saved;
            ptr1 = spacePtr1 [spaceIdx];
            ptr2 = spacePtr2 [spaceIdx];
            if (fullPath) {
                saved = *ptr2;
            }
            *ptr1 = 0;
            *ptr2 = 0;
        }
        else {
            *ptr2 = saved;
            break;
        }
    }

    StringCopyW (Buffer, cmdLine2);

    if (*ptr2) {
        return (CmdLine + (end - cmdLine2));
    }
    else {
        return (CmdLine + (ptr2 - cmdLine2));
    }
}


BOOL
pIsExcludedFromBackupW (
    IN      PCWSTR Path,
    IN      PCWSTR TempDir      OPTIONAL
    )
{
    PCWSTR fileName;

    fileName = GetFileNameFromPathW (Path);
    if (!fileName) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"win386.swp")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"backup.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"moved.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"delfiles.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"deldirs.txt")) {
        return TRUE;
    }

    if (StringIMatchW (Path, L"c:\\boot.ini")) {
        return TRUE;
    }

    if (TempDir) {
        if (StringIPrefixW (Path, TempDir)) {
            fileName = Path + TcharCountW (TempDir) + 1;
            if (wcschr (fileName, L'\\')) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

HANDLE
pCreateFileList (
    IN      PCSTR TempDir,
    IN      PCSTR FileName,
    IN      BOOL InUninstallSubDir
    )
{
    HANDLE file;
    PCSTR fileString;
    DWORD bytesWritten;
    CHAR decoratedFile[MAX_PATH];
    PCSTR fileToUse;

    if (!InUninstallSubDir) {
        fileToUse = FileName;
    } else {
        wsprintfA (decoratedFile, "uninstall\\%s", FileName);
        fileToUse = decoratedFile;
    }
    fileString = JoinPathsA (TempDir, fileToUse);

    file = CreateFileA (
                fileString,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        LOGA ((LOG_ERROR,"Error creating file %s.", fileString));
        FreePathStringA (fileString);
        return INVALID_HANDLE_VALUE;
    }

    DeclareTemporaryFileA (fileString);
    FreePathStringA (fileString);

    //
    // Write UNICODE signature
    //
    // Do not write as a string. FE is a lead byte.
    //
    if ((!WriteFile (file, "\xff\xfe", 2, &bytesWritten, NULL)) ||
        (bytesWritten != 2)
        ) {
        LOG ((LOG_ERROR,"Unable to write unicode header."));
        CloseHandle (file);
        return INVALID_HANDLE_VALUE;
    }

    return file;
}


BOOL
WriteHashTableToFileW (
    IN HANDLE File,
    IN HASHTABLE FileTable
    )
{

    UINT unused;
    HASHTABLE_ENUMW e;
    BOOL result = TRUE;

    if (!FileTable || File == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    if (EnumFirstHashTableStringW (&e, FileTable)) {
        do {

            if (!WriteFile (File, e.String, ByteCountW (e.String), &unused, NULL)) {
                result = FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &unused, NULL)) {
                result = FALSE;
            }

        } while (result && EnumNextHashTableStringW (&e));
    }

    return result;
}

PWSTR
pGetParentDirPathFromFilePathW(
    IN      PCWSTR FilePath,
    OUT     PWSTR DirPath
    )
{
    PWSTR ptr;

    if(!FilePath || !DirPath){
        MYASSERT(FALSE);
        return NULL;
    }

    StringCopyW(DirPath, FilePath);
    ptr = wcsrchr(DirPath, '\\');
    if(ptr){
        *ptr = '\0';
    }

    return DirPath;
}

PSTR
pGetParentDirPathFromFilePathA(
    IN      PCSTR FilePath,
    OUT     PSTR DirPath
    )
{
    PSTR ptr;

    if(!FilePath || !DirPath){
        MYASSERT(FALSE);
        return NULL;
    }

    StringCopyA(DirPath, FilePath);
    ptr = _mbsrchr(DirPath, '\\');
    if(ptr){
        *ptr = '\0';
    }

    return DirPath;
}

BOOL
IsDirEmptyA(
     IN      PCSTR DirPathPtr
     )
{
    TREE_ENUMA e;
    BOOL result;

    if (!EnumFirstFileInTreeExA (
        &e,
        DirPathPtr,
        NULL,
        FALSE,
        FALSE,
        FILE_ENUM_ALL_LEVELS
        )) {
        result = TRUE;
    }
    else{
        AbortEnumFileInTreeA(&e);
        result = FALSE;
    }

    return result;
}

BOOL
IsDirEmptyW(
     IN      PCWSTR DirPathPtr
     )
{
    TREE_ENUMW e;
    BOOL result;

    if (!EnumFirstFileInTreeExW (
        &e,
        DirPathPtr,
        NULL,
        FALSE,
        FALSE,
        FILE_ENUM_ALL_LEVELS
        )) {
        result = TRUE;
    }
    else{
        AbortEnumFileInTreeW(&e);
        result = FALSE;
    }

    return result;
}

VOID
pAddDirWorkerW (
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist,   OPTIONAL
    IN      DWORD InitialAttributes
    )
{
    DWORD fileAttributes;
    BOOL addToCategory;
    WCHAR parentDirPath[MAX_WCHAR_PATH];
    PCWSTR parentDirPathPtr;
    FILE_ENUMW e;

    //
    // We are adding to the empty dirs category, which once held
    // empty dirs, but now holds all kinds of dirs and their attributes
    //

    if (!DirPathPtr) {
        MYASSERT(FALSE);
        return;
    }

    //
    // Ignore root dir
    //

    if (!DirPathPtr[0] ||           // C
        !DirPathPtr[1] ||           // :
        !DirPathPtr[2] ||           // backslash
        !DirPathPtr[3]
        ) {
        return;
    }

    addToCategory = FALSE;

    fileAttributes = InitialAttributes;
    if (fileAttributes == INVALID_ATTRIBUTES) {
        fileAttributes = GetFileAttributesW (DirPathPtr);
    }

    if (fileAttributes != INVALID_ATTRIBUTES){
        if (!(fileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // Ignore files. If caller wants the parent dir, then
            // process it now.
            //

            if (AddParentDirIfFile) {
                parentDirPathPtr = pGetParentDirPathFromFilePathW (DirPathPtr, parentDirPath);
                if (parentDirPathPtr) {
                    AddDirPathToEmptyDirsCategoryW (parentDirPathPtr, FALSE, FALSE);
                }
            }

            return;
        }

        //
        // This is a dir, add it to memdb, and add attributes if they aren't normal
        //

        addToCategory = TRUE;
        if (fileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
            fileAttributes = 0;
        }

    } else {

        //
        // This file does not exist. If it is a dir spec, then
        // add it with no attributes.
        //

        if (!AddParentDirIfFile || !AddParentDirIfFileExist) {
            fileAttributes = 0;
            addToCategory = TRUE;
        }
    }

    if (addToCategory) {
        //
        // Add only if fileAttributes are non normal or
        // dir is empty
        //

        if (!fileAttributes) {
            if (EnumFirstFileW (&e, DirPathPtr, NULL)) {
                addToCategory = FALSE;
                AbortFileEnumW (&e);
            }
        }
    }

    if (addToCategory) {
        MemDbSetValueExW (
            MEMDB_CATEGORY_EMPTY_DIRSW,
            DirPathPtr,
            NULL,
            NULL,
            fileAttributes,
            NULL
            );
    }
}


VOID
AddDirPathToEmptyDirsCategoryW (
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    )
{
    pAddDirWorkerW (
        DirPathPtr,
        AddParentDirIfFile,
        AddParentDirIfFileExist,
        INVALID_ATTRIBUTES
        );
}


VOID
pAddDirWorkerA (
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist,   OPTIONAL
    IN      DWORD InitialAttributes
    )
{
    DWORD fileAttributes;
    BOOL addToCategory;
    CHAR parentDirPath[MAX_MBCHAR_PATH];
    PCSTR parentDirPathPtr;
    FILE_ENUMA e;

    //
    // We are adding to the empty dirs category, which once held
    // empty dirs, but now holds all kinds of dirs and their attributes
    //

    if (!DirPathPtr) {
        MYASSERT(FALSE);
        return;
    }

    addToCategory = FALSE;

    fileAttributes = InitialAttributes;
    if (fileAttributes == INVALID_ATTRIBUTES) {
        fileAttributes = GetFileAttributesA (DirPathPtr);
    }

    if (fileAttributes != INVALID_ATTRIBUTES){
        if (!(fileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // Ignore files. If caller wants the parent dir, then
            // process it now.
            //

            if (AddParentDirIfFile) {
                parentDirPathPtr = pGetParentDirPathFromFilePathA (DirPathPtr, parentDirPath);
                if (parentDirPathPtr) {
                    AddDirPathToEmptyDirsCategoryA (parentDirPathPtr, FALSE, FALSE);
                }
            }

            return;
        }

        //
        // This is a dir, add it to memdb, and add attributes if they aren't normal
        //

        addToCategory = TRUE;
        if (fileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
            fileAttributes = 0;
        }

    } else {

        //
        // This file does not exist. If it is a dir spec, then
        // add it with no attributes.
        //

        if (!AddParentDirIfFile || !AddParentDirIfFileExist) {
            fileAttributes = 0;
            addToCategory = TRUE;
        }
    }

    if (addToCategory) {
        //
        // Add only if fileAttributes are non normal or
        // dir is empty
        //

        if (!fileAttributes) {
            if (EnumFirstFileA (&e, DirPathPtr, NULL)) {
                addToCategory = FALSE;
                AbortFileEnumA (&e);
            }
        }
    }

    if (addToCategory) {
        MemDbSetValueExA (
            MEMDB_CATEGORY_EMPTY_DIRSA,
            DirPathPtr,
            NULL,
            NULL,
            fileAttributes,
            NULL
            );
    }
}


VOID
AddDirPathToEmptyDirsCategoryA(
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    )
{
    pAddDirWorkerA (
        DirPathPtr,
        AddParentDirIfFile,
        AddParentDirIfFileExist,
        INVALID_ATTRIBUTES
        );
}

BOOL
GetDiskSpaceForFilesList (
    IN      HASHTABLE FileTable,
    OUT     ULARGE_INTEGER * AmountOfSpace,                 OPTIONAL
    OUT     ULARGE_INTEGER * AmountOfSpaceIfCompressed,     OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    IN      BOOL ProcessDirs,                               OPTIONAL
    OUT     ULARGE_INTEGER * AmountOfSpaceClusterAligned    OPTIONAL
    )
/*++

Routine Description:

  GetDiskSpaceForFilesList calculate amount of space to store all files
  from FileTable hashtable.

Arguments:

  FileTable - Specifies container for paths of files.

  AmountOfSpace - Receives the amount of space required to store files.

  AmountOfSpaceIfCompressed - Receives the amount of space required to store
                              files, if compression will apply on files.

  CompressionFactor - Receives the compression factor in 0..100 range.

  BootCabImagePadding - Receives the backup disk space padding for
                           additional files like boot.cab.

Return Value:

  TRUE if IN parameters is correct, FALSE otherwise

--*/
{
    HASHTABLE_ENUMW e;
    WIN32_FIND_DATAA fileAttributeData;
    HANDLE h;
    ULARGE_INTEGER sizeOfFiles;
    ULARGE_INTEGER fileSize;
    unsigned int numberOfFiles = 0;
    char filePathNameA[MAX_PATH * 2];
    ULARGE_INTEGER BootCabImagePaddingInBytes;
    TCHAR DirPath[MAX_PATH * 2];
    ULARGE_INTEGER clusterSize = {512, 0};
    char drive[_MAX_DRIVE] = "?:";
    DWORD sectorsPerCluster;
    DWORD bytesPerSector;

    if (!FileTable) {
        return FALSE;
    }

    sizeOfFiles.QuadPart = 0;

    if (EnumFirstHashTableStringW (&e, FileTable)) {
        do {
            KnownSizeUnicodeToDbcsN(filePathNameA, e.String, wcslen(e.String) + 1);

            h = FindFirstFileA (filePathNameA, &fileAttributeData);
            if(h != INVALID_HANDLE_VALUE) {
                FindClose (h);
                if(!(fileAttributeData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)){
                    fileSize.LowPart = fileAttributeData.nFileSizeLow;
                    fileSize.HighPart = fileAttributeData.nFileSizeHigh;

                    sizeOfFiles.QuadPart += fileSize.QuadPart;
                    numberOfFiles++;

                    if(AmountOfSpaceClusterAligned){
                        if(UNKNOWN_DRIVE == drive[0]){

                            drive[0] = filePathNameA[0];

                            if(GetDiskFreeSpaceA(drive, &sectorsPerCluster, &bytesPerSector, NULL, NULL)){
                                clusterSize.QuadPart = sectorsPerCluster * bytesPerSector;
                                AmountOfSpaceClusterAligned->QuadPart = 0;
                            }
                            else{
                                DEBUGMSG((DBG_VERBOSE, "GetDiskFreeSpace failed in GetDiskSpaceForFilesList"));
                                AmountOfSpaceClusterAligned = NULL;
                                continue;
                            }
                        }

                        AmountOfSpaceClusterAligned->QuadPart +=
                            fileSize.QuadPart % clusterSize.QuadPart? // || sizeOfFiles.QuadPart == NULL
                                ((fileSize.QuadPart / clusterSize.QuadPart) + 1) * clusterSize.QuadPart:
                                fileSize.QuadPart;
                    }
                }

                if(ProcessDirs){
                    AddDirPathToEmptyDirsCategoryA(filePathNameA, TRUE, TRUE);
                }

                MYASSERT(DirPath);
            }
            else {
                //DEBUGMSGA((DBG_VERBOSE, "SETUP: GetDiskSpaceForFilesList - file does not exist: %s", filePathNameA));
            }
        } while (EnumNextHashTableStringW (&e));
    }

    if(!BootCabImagePadding) {
        BootCabImagePaddingInBytes.QuadPart = BACKUP_DISK_SPACE_PADDING_DEFAULT;
        DEBUGMSG ((DBG_VERBOSE, "Disk space padding for backup image: %i MB (DEFAULT)", BootCabImagePadding));
    }
    else{
        BootCabImagePaddingInBytes.QuadPart = BootCabImagePadding;
        BootCabImagePaddingInBytes.QuadPart <<= 20;
        DEBUGMSG ((DBG_VERBOSE, "Disk space padding for backup image: %i MB", BootCabImagePadding));
    }

    if(AmountOfSpaceClusterAligned){
        AmountOfSpaceClusterAligned->QuadPart += BootCabImagePaddingInBytes.QuadPart;
    }

    if(AmountOfSpace) {
        AmountOfSpace->QuadPart = sizeOfFiles.QuadPart + BootCabImagePaddingInBytes.QuadPart;
    }

    if(AmountOfSpaceIfCompressed) {
        if(!CompressionFactor) {
            CompressionFactor = COMPRESSION_RATE_DEFAULT;
            DEBUGMSG ((DBG_VERBOSE, "Compression factor: %i (DEFAULT)", CompressionFactor));
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "Compression factor: %i", CompressionFactor));

        AmountOfSpaceIfCompressed->QuadPart =
            (sizeOfFiles.QuadPart * CompressionFactor) / 100 +
            STARTUP_INFORMATION_BYTES_NUMBER * numberOfFiles + BootCabImagePaddingInBytes.QuadPart;//boot.cab
    }

    return TRUE;
}


#if 0
BOOL
pGetTruePathName (
    IN      PCWSTR InPath,
    OUT     PWSTR OutPath
    )
{
    PCSTR start;
    PCSTR end;
    WIN32_FIND_DATAA fd;
    PCSTR ansiInPath;
    CHAR ansiOutPath[MAX_MBCHAR_PATH];
    HANDLE findHandle;
    PSTR p;

    //
    // If not a local path, ignore it. If longer than MAX_PATH, ignore it.
    //

    if (!InPath[0] || InPath[1] != L':' || InPath[2] != L'\\') {
        StringCopyW (OutPath, InPath);
        return;
    }

    if (TcharCount (InPath) >= MAX_PATH) {
        StringCopyW (OutPath, InPath);
        return;
    }

    //
    // Convert down to ANSI because Win9x API requirements
    //

    ansiInPath = ConvertWtoA (InPath);

    //
    // Copy the drive spec
    //

    start = ansiInPath;
    end = start + 2;
    MYASSERT (*end == '\\');

    p = ansiOutPath;

    StringCopyABA (p, start, end);
    p = GetEndOfStringA (p);

    //
    // Walk the path, and for each segment, get the full name via
    // FindFirstFile
    //

    start = end + 1;
    end = _mbschr (start, '\\');
    if (!end) {
        end = GetEndOfStringA (start);
    }

    for (;;) {
        if (end > start + 1) {
            *p++ = '\\';
            StringCopyABA (p, start, end);

            findHandle = FindFirstFileA (ansiOutPath, &fd);

            if (findHandle == INVALID_HANDLE_VALUE) {
                //
                // File/directory does not exist. Use the remaining
                // string as passed in.
                //

                StringCopyA (p, start);

                DEBUGMSGA ((DBG_ERROR, "File %s not found", ansiInPath));

                KnownSizeAtoW (OutPath, ansiOutPath);
                FreeConvertedStr (ansiInPath);
                return FALSE;
            }

            //
            // Copy the file system's value to the out buffer
            //

            StringCopyA (p, fd.cFileName);
            p = GetEndOfStringA (p);

            FindClose (findHandle);
        }

        //
        // Advance to the next segment
        //

        if (*end) {
            start = end + 1;
            end = _mbschr (start, '\\');
            if (!end) {
                end = GetEndOfStringA (start);
            }
        } else {
            break;
        }
    }

    KnownSizeAtoW (OutPath, ansiOutPath);
    FreeConvertedStr (ansiInPath);
    return TRUE;
}
#endif

VOID
pPutInBackupTable (
    IN      HASHTABLE BackupTable,
    IN      HASHTABLE SourceTable,
    IN      PCWSTR Path
    )
{
    if (pIsExcludedFromBackupW (Path, NULL)) {
        return;
    }

    if (!HtFindStringW (SourceTable, Path)) {
        HtAddStringW (SourceTable, Path);
        MarkFileForBackupW (Path);
        HtAddStringW (BackupTable, Path);
    }
}


VOID
pPutInDelFileTable (
    IN      HASHTABLE DelFileTable,
    IN      HASHTABLE DestTable,
    IN      PCWSTR Path
    )
{
    if (!HtFindStringW (DestTable, Path)) {
        HtAddStringW (DestTable, Path);
        HtAddStringW (DelFileTable, Path);
    }
}


BOOL
pIsWinDirProfilesPath (
    IN      PCWSTR PathToTest
    )
{
    static WCHAR winDirProfiles[MAX_PATH];
    CHAR winDirProfilesA[MAX_PATH];

    if (!(winDirProfiles[0])) {
        GetWindowsDirectoryA (winDirProfilesA, MAX_PATH - 9);
        KnownSizeAtoW (winDirProfiles, winDirProfilesA);
        StringCatW (winDirProfiles, L"\\Profiles");
    }

    return StringIMatchW (PathToTest, winDirProfiles);
}


BOOL
WriteBackupFilesA (
    IN      BOOL Win9xSide,
    IN      PCSTR TempDir,
    OUT     ULARGE_INTEGER * OutAmountOfSpaceIfCompressed,  OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpace,              OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceForDelFiles,   OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceClusterAligned OPTIONAL
    )

/*++

Routine Description:

  WriteBackupFiles outputs the files needed by the text mode backup engine
  to create a backup image. This includes:

    backup.txt      - Lists all files that need to be backed up, either
                      because they are Win9x-specific, or are replaced
                      during the upgrade.

    moved.txt       - Lists all files that were moved from a Win9x location
                      to a temporary or NT location

    delfiles.txt    - Lists all files that are new to the upgraded OS

    deldirs.txt     - Lists subdirectories that are new to the upgraded OS

Arguments:

  Win9xSide - Specifies TRUE if setup is running on Win9x. This causes the
              files to be generated for the rollback of an incomplete setup.

              Specifies FALSE if setup is running on NT. This causes the
              files to be generated for the rollback of the final NT OS.

  TempDir - Specifies the setup temporary directory (%windir%\setup).

  OutAmountOfSpaceIfCompressed - return amount of space for backup files, if
                                 compression will apply.

  OutAmountOfSpace - return amount of space for backup files, if compression
                     will not apply.

  CompressionFactor - receives the compression factor in 0..100 range.

  BootCabImagePadding - receives the backup disk space padding for
                           additional files.

Return Value:

  TRUE if the files were created successfully, FALSE otherwise.

--*/

{
    MEMDB_ENUMW e;
    TREE_ENUMA treeEnumA;
    PCSTR ansiRoot;
    PCSTR ansiFullPath;
    PCWSTR unicodeFullPath;
    PCWSTR unicodeTempDir = NULL;
    PBYTE bufferRoot;
    PWSTR buffer;
    WCHAR pattern[MAX_PATH];
    DWORD  bytesWritten;
    DWORD Count = 0;
    PWSTR srcFile = NULL;
    PWSTR destFile = NULL;
    DWORD status;
    HANDLE backupFileList = INVALID_HANDLE_VALUE;
    HANDLE movedOutput = INVALID_HANDLE_VALUE;
    HANDLE delDirsList = INVALID_HANDLE_VALUE;
    HANDLE mkDirsList = INVALID_HANDLE_VALUE;
    HANDLE delFilesList = INVALID_HANDLE_VALUE;
    HASHTABLE backupTable = NULL;
    HASHTABLE delFileTable = NULL;
    HASHTABLE delDirTable = NULL;
    HASHTABLE mkDirsTable = NULL;
    HASHTABLE srcTable = HtAllocExW (FALSE, 0, 41911);
    HASHTABLE destTable = HtAllocExW (FALSE, 0, 41911);
    UINT type;
    ULARGE_INTEGER AmountOfSpace;
    ULARGE_INTEGER AmountOfSpaceIfCompressed;
    ULARGE_INTEGER AmountOfSpaceClusterAligned;
    ULARGE_INTEGER FreeBytesAvailableUser;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER FreeBytesAvailable;
    DWORD attribs;
    PCSTR ansiFile;
    PWSTR entryName;
    DWORD fileAttributes;
    PCSTR dirName;
    BOOL IsDirExist;
    UINT depth;
    POOLHANDLE moveListPool;
    MOVELISTW moveList;
    BOOL result = FALSE;
    HASHTABLE_ENUM htEnum;
    PWSTR thisDir;
    PWSTR lastDir;
    PWSTR p;
    FILEOP_ENUMW OpEnum;
    ALL_FILEOPS_ENUMW allOpEnum;

    __try {
        bufferRoot = MemAllocUninit ((MEMDB_MAX * 6) * sizeof (WCHAR));
        if (!bufferRoot) {
            __leave;
        }

        srcFile = (PWSTR) bufferRoot;
        destFile = srcFile + MEMDB_MAX;
        buffer = destFile + MEMDB_MAX;
        thisDir = buffer + MEMDB_MAX;
        lastDir = thisDir + MEMDB_MAX;
        entryName = lastDir + MEMDB_MAX;

        //
        // Open the output files
        //
        backupTable = HtAllocExW(TRUE, 0, 31013);
        delFileTable = HtAllocExW(TRUE, 0, 10973);
        delDirTable = HtAllocExW(TRUE, 0, 23);

        delFilesList = pCreateFileList (TempDir, "delfiles.txt", TRUE);
        delDirsList = pCreateFileList (TempDir, "deldirs.txt", TRUE);

        moveListPool = PoolMemInitNamedPool ("Reverse Move List");
        if (!moveListPool) {
            DEBUGMSG ((DBG_ERROR, "Can't create move list pool"));
            __leave;
        }

        moveList = AllocateMoveListW (moveListPool);
        if (!moveList) {
            DEBUGMSG ((DBG_ERROR, "Can't create move list"));
            __leave;
        }

        if (delFilesList == INVALID_HANDLE_VALUE ||
            delDirsList == INVALID_HANDLE_VALUE
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't open one of the backup files"));
            __leave;
        }

        if (Win9xSide) {
            mkDirsTable = HtAllocExW(TRUE, 0, 0);

            backupFileList = pCreateFileList (TempDir, "backup.txt", FALSE);
            mkDirsList = pCreateFileList (TempDir, "mkdirs.txt", TRUE);

            if (backupFileList == INVALID_HANDLE_VALUE ||
                mkDirsList == INVALID_HANDLE_VALUE
                ) {
                DEBUGMSG ((DBG_ERROR, "Can't open one of the backup files"));
                __leave;
            }

        }

        unicodeTempDir = ConvertAtoW (TempDir);

        //
        // Go through the registered operations and put the reverse action
        // in the undo hash tables. As files are processed here, they are
        // recorded in the source and dest hash tables, so they don't end
        // up in multiple hash tables.
        //

        if (EnumFirstPathInOperationW (&OpEnum, OPERATION_LONG_FILE_NAME)) {
            do {
                //
                // Ignore excluded files
                // Ignore already processed files
                //

                // we fix this with case-insensitive srcTable and rely on
                // the first entry being the proper case
                //pGetTruePathName (OpEnum.Path, caseCorrectName);

                if (pIsExcludedFromBackupW (OpEnum.Path, unicodeTempDir)) {
                    continue;
                }

                if (HtFindStringW (srcTable, OpEnum.Path)) {
                    continue;
                }

                //
                // If this is a preserved dir, then put it in mkdirs.txt
                //

                if (mkDirsTable) {
                    MYASSERT (Win9xSide);

                    if (IsDirectoryMarkedAsEmptyW (OpEnum.Path)) {

                        ansiFile = ConvertWtoA (OpEnum.Path);

                        if (ansiFile) {
                            attribs = GetFileAttributesA (ansiFile);

                            if (attribs != INVALID_ATTRIBUTES) {
                                if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                                    HtAddStringW (mkDirsTable, OpEnum.Path);
                                }
                            }

                            FreeConvertedStr (ansiFile);
                        }

                    }
                }

                //
                // Process the source file given in OpEnum.Path
                //

                status = GetFileInfoOnNtW (OpEnum.Path, destFile, MEMDB_MAX);

                if (status & FILESTATUS_BACKUP) {
                    //
                    // This file is going to change -- back it up
                    //

                    if (backupFileList != INVALID_HANDLE_VALUE) {
                        //
                        // If this file is a directory, then back up the whole tree
                        //

                        ansiFile = ConvertWtoA (OpEnum.Path);
                        attribs = GetFileAttributesA (ansiFile);

                        if (attribs != INVALID_ATTRIBUTES &&
                            (attribs & FILE_ATTRIBUTE_DIRECTORY)
                            ) {
                            if (EnumFirstFileInTreeA (&treeEnumA, ansiFile, NULL, FALSE)) {
                                do {

                                    unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);
                                    pPutInBackupTable (backupTable, srcTable, unicodeFullPath);
                                    FreeConvertedStr (unicodeFullPath);

                                } while (EnumNextFileInTreeA (&treeEnumA));
                            }

                        } else if (attribs != INVALID_ATTRIBUTES) {
                            pPutInBackupTable (backupTable, srcTable, OpEnum.Path);
                        }

                        FreeConvertedStr (ansiFile);
                    }

                    //
                    // If the file is also going to be moved, remove the dest copy
                    //

                    if (status & FILESTATUS_MOVED) {
                        HtAddStringW (delFileTable, destFile);
                    }

                    //
                    // Keep track that we're done for good with the source
                    // file and dest file
                    //

                    HtAddStringW (srcTable, OpEnum.Path);
                    HtAddStringW (destTable, destFile);

                } else if (!Win9xSide && (status & FILESTATUS_MOVED)) {

                    if (!pIsWinDirProfilesPath (OpEnum.Path)) {
                        //
                        // This file isn't going to change, but it will be moved
                        //

                        InsertMoveIntoListW (
                            moveList,
                            destFile,
                            OpEnum.Path
                            );

                        //
                        // Keep track that we're done for good with the source
                        // file and dest file
                        //

                        HtAddStringW (srcTable, OpEnum.Path);
                        HtAddStringW (destTable, destFile);
                    }
                }

                //
                // Update UI
                //

                Count++;
                if (!(Count % 128)) {
                    if (!TickProgressBar ()) {
                        __leave;
                    }
                }

            } while (EnumNextPathInOperationW (&OpEnum));
        }

        //
        // On the Win9x side, put the temp file moves in the move hash table, so
        // that they are returned back to their original locations.
        //

        if (Win9xSide) {
            if (EnumFirstFileOpW (&allOpEnum, OPERATION_FILE_MOVE|OPERATION_TEMP_PATH, NULL)) {
                do {

                    //
                    // only take into account the first destination of a file
                    // (when allOpEnum.PropertyNum == 0)
                    // all other destinations are not relevant for textmode move
                    //
                    if (allOpEnum.PropertyValid && allOpEnum.PropertyNum == 0) {

                        if (!pIsWinDirProfilesPath (allOpEnum.Path)) {
                            InsertMoveIntoListW (
                                moveList,
                                allOpEnum.Property,
                                allOpEnum.Path
                                );
                        }

                        Count++;
                        if (!(Count % 256)) {
                            if (!TickProgressBar ()) {
                                __leave;
                            }
                        }
                    }

                } while (EnumNextFileOpW (&allOpEnum));
            }

            //
            // Enumerate all the SfTemp values and add them to the list of things to move.
            //

            if (MemDbGetValueExW (&e, MEMDB_CATEGORY_SF_TEMPW, NULL, NULL)) {
                do {

                    if (MemDbBuildKeyFromOffsetW (e.dwValue, srcFile, 1, NULL)) {

                        if (!pIsWinDirProfilesPath (srcFile)) {
                            InsertMoveIntoListW (
                                moveList,
                                e.szName,
                                srcFile
                                );
                        }

                        Count++;
                        if (!(Count % 256)) {
                            if (!TickProgressBar ()) {
                                __leave;
                            }
                        }
                    }

                } while (MemDbEnumNextValueW (&e));
            }

            //
            // Enumerate all DirsCollision values and add them to the list of things to move.
            //

            if (MemDbGetValueExW (&e, MEMDB_CATEGORY_DIRS_COLLISIONW, NULL, NULL)) {
                do {
                    if (EnumFirstFileOpW (&allOpEnum, OPERATION_FILE_MOVE, e.szName)) {

                        if (!pIsWinDirProfilesPath (allOpEnum.Path)) {
                            InsertMoveIntoListW (
                                moveList,
                                allOpEnum.Property,
                                e.szName
                                );
                        }
                    }
                } while (MemDbEnumNextValueW (&e));
            }
        }

        //
        // Process the NT file list, adding files specific to NT to the delete hash table
        //

        if (delFilesList != INVALID_HANDLE_VALUE) {

            MemDbBuildKeyW (pattern, MEMDB_CATEGORY_NT_FILESW, L"*", NULL, NULL);

            if (MemDbEnumFirstValueW (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

                do {
                    if (MemDbBuildKeyFromOffsetW (e.dwValue, buffer, 1, NULL)) {
                        StringCopyW (AppendWackW (buffer), e.szName);
                        pPutInDelFileTable (delFileTable, destTable, buffer);
                    }

                    Count++;
                    if (!(Count % 128)) {
                        if (!TickProgressBar ()) {
                            __leave;
                        }
                    }

                } while (MemDbEnumNextValueW (&e));
            }
        }

        //
        // Append the remaining files to the backup (Win9xSide) or delete
        // (!Win9xSide) lists by scanning the current file system. These specs
        // mostly come from win95upg.inf's [Backup] section. This INF is
        // parsed during WINNT32 and converted into memdb operations. The
        // memdb operations persist to the GUI mode side automatically, as
        // memdb is saved before reboot to text mode and is reloaded in GUI
        // mode.
        //

        if (MemDbEnumFirstValueW (
                &e,
                MEMDB_CATEGORY_CLEAN_OUTW L"\\*",
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {

                type = e.dwValue;

                //
                // If on Win9x, and if type is BACKUP_SUBDIRECTORY_TREE, then
                // back up the entire tree as well as putting it in the
                // deldirs.txt file.
                //
                if (Win9xSide) {
                    if (type == BACKUP_SUBDIRECTORY_TREE) {
                        type = BACKUP_AND_CLEAN_TREE;
                    } else if (type == BACKUP_AND_CLEAN_SUBDIR) {
                        type = BACKUP_SUBDIRECTORY_FILES;
                    }
                }

                if (type == BACKUP_FILE) {
                    //
                    // file
                    //

                    if (Win9xSide) {
                        //
                        // This is a single file or directory specification.
                        // - If it exists as a file, then back it up.
                        // - If it exists as a directory, then back up its
                        //   contents (if any).
                        // - If it does not exist, put it in the delete list.
                        //

                        ansiFile = ConvertWtoA (e.szName);
                        attribs = GetFileAttributesA (ansiFile);

                        if (attribs != INVALID_ATTRIBUTES) {
                            if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                                if (EnumFirstFileInTreeA (&treeEnumA, ansiFile, NULL, FALSE)) {
                                    do {
                                        unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);
                                        pPutInBackupTable (backupTable, srcTable, unicodeFullPath);
                                        FreeConvertedStr (unicodeFullPath);

                                    } while (EnumNextFileInTreeA (&treeEnumA));
                                }
                            } else {
                                pPutInBackupTable (backupTable, srcTable, e.szName);
                            }
                        } else {
                            pPutInDelFileTable (delFileTable, destTable, e.szName);
                        }

                        FreeConvertedStr (ansiFile);

                    } else {

                        //
                        // Put this file/subdirectory in the delete list
                        // unless it was either backed up or is the
                        // destination of a move. Note we rely on the fact
                        // that every time a file was put in the backup table
                        // on Win9xSide, it was also marked for explicit
                        // backup. This causes the loop at the top of this
                        // function to put the proper file spec in destTable.
                        //

                        GetNewPathForFileW (e.szName, buffer);
                        pPutInDelFileTable (delFileTable, destTable, buffer);
                    }

                } else {
                    //
                    // directory or tree
                    //

                    if (Win9xSide || type != BACKUP_AND_CLEAN_TREE) {
                        //
                        // Record backup or single dir cleanup
                        //

                        if (!Win9xSide) {
                            GetNewPathForFileW (e.szName, buffer);
                            ansiRoot = ConvertWtoA (buffer);
                        } else {
                            ansiRoot = ConvertWtoA (e.szName);
                        }

                        if (type == BACKUP_SUBDIRECTORY_FILES ||
                            type == BACKUP_AND_CLEAN_SUBDIR
                            ) {
                            depth = 1;
                        } else {
                            depth = FILE_ENUM_ALL_LEVELS;
                        }

                        if (EnumFirstFileInTreeExA (
                                &treeEnumA,
                                ansiRoot,
                                NULL,
                                FALSE,
                                FALSE,
                                depth
                                )) {

                            do {
                                if (treeEnumA.Directory) {
                                    continue;
                                }

                                unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);

                                if (Win9xSide) {
                                    //
                                    // Mark this file for backup and put it in the txt file.
                                    //

                                    pPutInBackupTable (backupTable, srcTable, unicodeFullPath);

                                } else {
                                    //
                                    // Put this file in the delete list unless it was either
                                    // backed up or is the destination of a move. This is
                                    // the same logic as the call to pPutInDelFileTable above.
                                    //

                                    pPutInDelFileTable (delFileTable, destTable, unicodeFullPath);
                                }

                                FreeConvertedStr (unicodeFullPath);

                            } while (EnumNextFileInTreeA (&treeEnumA));
                        }

                        FreeConvertedStr (ansiRoot);
                    }

                    //
                    // Write deldirs entry if subdir should be blown away on
                    // rollback. (Backup files might be restored after the
                    // subdir is blown away.)
                    //
                    // For backups of type BACKUP_SUBDIRECTORY_TREE, put
                    // this subdirectory in the deldirs.txt file on the Win9x
                    // side. Deldirs.txt will be re-written in GUI mode
                    // without it.
                    //

                    if (type == BACKUP_AND_CLEAN_TREE) {
                        //
                        // Record tree deletes
                        //

                        GetNewPathForFileW (e.szName, buffer);
                        HtAddStringW (delDirTable, buffer);

                        if (Win9xSide) {
                            ansiFullPath = ConvertWtoA (e.szName);
                            AddDirPathToEmptyDirsCategoryA(ansiFullPath, TRUE, TRUE);
                            FreeConvertedStr (ansiFullPath);
                        }
                    }
                }

            } while (MemDbEnumNextValue (&e));
        }

        //
        // Disk Space calculation and check for availability
        //
        if(OutAmountOfSpaceIfCompressed || OutAmountOfSpace || OutAmountOfSpaceClusterAligned) {
            AmountOfSpace.QuadPart = 0;
            AmountOfSpaceIfCompressed.QuadPart = 0;
            AmountOfSpaceClusterAligned.QuadPart = 0;

            if(!GetDiskSpaceForFilesList(
                    backupTable,
                    &AmountOfSpace,
                    &AmountOfSpaceIfCompressed,
                    CompressionFactor,
                    BootCabImagePadding,
                    FALSE,
                    &AmountOfSpaceClusterAligned
                    )) {
                DEBUGMSG((DBG_WHOOPS, "Can't calculate disk space for files. GetDiskSpaceForFilesList - failed.\n"));
            } else {
                //
                // The disk space numbers include the padding necessary to ensure
                // a user's hard disk does not get filled completely
                //

                if (OutAmountOfSpaceIfCompressed) {
                    OutAmountOfSpaceIfCompressed->QuadPart = AmountOfSpaceIfCompressed.QuadPart;
                }

                if (OutAmountOfSpace) {
                    OutAmountOfSpace->QuadPart = AmountOfSpace.QuadPart;
                }

                if(OutAmountOfSpaceClusterAligned){
                    OutAmountOfSpaceClusterAligned->QuadPart = AmountOfSpaceClusterAligned.QuadPart;
                }

                DEBUGMSG((DBG_VERBOSE, "AmountOfSpace: %dMB\nAmountOfSpaceIfCompressed: %dMB\nAmountOfSpaceClusterAligned: %dMB", (UINT)(AmountOfSpace.QuadPart>>20), (UINT)(AmountOfSpaceIfCompressed.QuadPart>>20), (UINT)(AmountOfSpaceClusterAligned.QuadPart>>20)));
            }
        }

        //
        // Disk Space calculation for deldirs
        //
        if(OutAmountOfSpaceForDelFiles) {
            if(!GetDiskSpaceForFilesList(
                    delFileTable,
                    NULL,
                    NULL,
                    0,
                    1,
                    FALSE,
                    OutAmountOfSpaceForDelFiles
                    )) {
                DEBUGMSG((DBG_WHOOPS, "Can't calculate disk space for del files. GetDiskSpaceForFilesList - failed.\n"));
            } else {
                DEBUGMSG((DBG_VERBOSE, "AmountOfSpaceForDelFiles: %d MB", (UINT)(OutAmountOfSpaceForDelFiles->QuadPart>>20)));
            }
        }

        //
        // preserve attributes of all the backup file parent dirs
        //

        if (Win9xSide) {

            lastDir[0] = 0;

            if (EnumFirstHashTableStringW (&htEnum, backupTable)) {
                do {
                    //
                    // Put the dir attributes or file's parent attributes in
                    // memdb. Optimize for the case where there are several
                    // files in a row all from the same parent.
                    //

                    ansiFullPath = ConvertWtoA (htEnum.String);
                    attribs = GetFileAttributesA (ansiFullPath);

                    if (attribs != INVALID_ATTRIBUTES &&
                        !(attribs & FILE_ATTRIBUTE_DIRECTORY)
                        ) {

                        StringCopyTcharCountW (thisDir, htEnum.String, MEMDB_MAX);
                        p = wcsrchr (thisDir, L'\\');
                        if (p) {
                            *p = 0;
                        }

                        _wcslwr (thisDir);
                        MYASSERT (thisDir[0]);

                    } else {
                        thisDir[0] = 0;
                        lastDir[0] = 0;
                        if (attribs != INVALID_ATTRIBUTES) {
                            //
                            // Optimize for case where dir is normal
                            //

                            if (attribs == FILE_ATTRIBUTE_DIRECTORY) {
                                attribs = INVALID_ATTRIBUTES;
                            }
                        }
                    }

                    //
                    // record attributes in memdb
                    //

                    if (attribs != INVALID_ATTRIBUTES) {
                        if ((!thisDir[0]) || (!StringMatchW (lastDir, thisDir))) {
                            pAddDirWorkerA (ansiFullPath, TRUE, TRUE, attribs);
                            StringCopyW (lastDir, thisDir);
                        }
                    }

                    //
                    // continue with loop, remembering current dir
                    //

                    FreeConvertedStr (ansiFullPath);

                    Count++;
                    if (!(Count % 256)) {
                        if (!TickProgressBar ()) {
                            __leave;
                        }
                    }
                } while (EnumNextHashTableStringW (&htEnum));
            }
        }

        //
        // Transfer the empty dirs to a hash table. We could just output the
        // file now but to be consistent at the expense of a few milliseconds
        // we'll use the hash table.
        //

        if (mkDirsTable && MemDbEnumFirstValueW (
                                &e,
                                MEMDB_CATEGORY_EMPTY_DIRSW L"\\*",
                                MEMDB_ALL_SUBLEVELS,
                                MEMDB_ENDPOINTS_ONLY
                                )) {
            do {
                if (!e.szName[0] ||
                    e.szName[1] != L':' ||
                    e.szName[2] != L'\\' ||
                    !e.szName[3]
                    ) {
                    //
                    // Ignore roots & malformed entries
                    //
                    continue;
                }

                swprintf(
                    entryName,
                    e.dwValue? L"%s,%u": L"%s",
                    e.szName,
                    e.dwValue
                    );

                ansiFile = ConvertWtoA (e.szName);

                if (ansiFile) {
                    attribs = GetFileAttributesA (ansiFile);

                    if (attribs != INVALID_ATTRIBUTES) {
                        if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                            HtAddStringW (mkDirsTable, entryName);
                        }
                    }

                    FreeConvertedStr (ansiFile);
                }

            } while (MemDbEnumNextValue (&e));
        }

        //
        // blast the lists to disk
        //
        if (!WriteHashTableToFileW (backupFileList, backupTable)) {
            LOG ((LOG_ERROR, "Unable to write to backup.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (delFilesList, delFileTable)) {
            LOG ((LOG_ERROR, "Unable to write to delfiles.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (delDirsList, delDirTable)) {
            LOG ((LOG_ERROR, "Unable to write to deldirs.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (mkDirsList, mkDirsTable)) {
            LOG ((LOG_ERROR, "Unable to write to mkdirs.txt"));
            __leave;
        }

        //
        // Finalize move list processing. If we are on the Win9x side, then
        // allow nesting collisions (the second arg).
        //

        moveList = RemoveMoveListOverlapW (moveList);

        ansiFullPath = JoinPathsA (TempDir, "uninstall\\moved.txt");
        if (!ansiFullPath) {
            __leave;
        }

        movedOutput = CreateFileA (
                            ansiFullPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        FreePathStringA (ansiFullPath);

        if (!OutputMoveListW (movedOutput, moveList, !Win9xSide)) {
            LOG ((LOG_ERROR,"Unable to write to moved.txt."));
            __leave;
        }

        //
        // Success
        //

        result = TRUE;

    }
    __finally {

        if (backupFileList != INVALID_HANDLE_VALUE) {
            CloseHandle (backupFileList);
        }

        if (movedOutput != INVALID_HANDLE_VALUE) {
            CloseHandle (movedOutput);
        }

        if (delDirsList != INVALID_HANDLE_VALUE) {
            CloseHandle (delDirsList);
        }

        if (mkDirsList != INVALID_HANDLE_VALUE) {
            CloseHandle (mkDirsList);
        }

        if (delFilesList != INVALID_HANDLE_VALUE) {
            CloseHandle (delFilesList);
        }

        HtFree (backupTable);
        HtFree (delFileTable);
        HtFree (delDirTable);
        HtFree (mkDirsTable);
        HtFree (destTable);
        HtFree (srcTable);

        PoolMemDestroyPool (moveListPool);

        FreeConvertedStr (unicodeTempDir);

        if (bufferRoot) {
            FreeMem (bufferRoot);
        }

    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\memdbex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbex.c

Abstract:

    Extensions to use the memdb tree like a relational database

Author:

    Jim Schmidt (jimschm) 2-Dec-1996

Revision History:

    jimschm     23-Sep-1998 Expanded user flags to 24 bits (from
                            12 bits), removed AnsiFromUnicode
    jimschm     21-Oct-1997 Cleaned up a little
    marcw       09-Apr-1997 Added MemDbGetOffset* functions.
    jimschm     17-Jan-1997 All string params can be NULL now
    jimschm     18-Dec-1996 Added GetEndpointValue functions

--*/

#include "pch.h"
#include "memdbp.h"

VOID
MemDbBuildKeyA (
    OUT     PSTR Buffer,
    IN      PCSTR Category,
    IN      PCSTR Item,
    IN      PCSTR Field,
    IN      PCSTR Data
    )
{
    PSTR p;
    static CHAR Wack[] = "\\";

    p = Buffer;
    *p = 0;

    if (Category)
        p = _mbsappend (p, Category);
    if (Item) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Item);
    }
    if (Field) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Field);
    }
    if (Data) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Data);
    }

}


VOID
MemDbBuildKeyW (
    OUT     PWSTR Buffer,
    IN      PCWSTR Category,
    IN      PCWSTR Item,
    IN      PCWSTR Field,
    IN      PCWSTR Data
    )
{
    PWSTR p;
    static WCHAR Wack[] = L"\\";

    p = Buffer;
    *p = 0;

    if (Category)
        p = _wcsappend (p, Category);
    if (Item) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Item);
    }
    if (Field) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Field);
    }
    if (Data) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Data);
    }
}


BOOL
MemDbSetValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,         OPTIONAL
    IN      PCSTR Field,        OPTIONAL
    IN      PCSTR Data,         OPTIONAL
    IN      DWORD  Val,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, Category, Item, Field, Data);

    return PrivateMemDbSetValueA (Key, Val, 0, 0, Offset);
}


BOOL
MemDbSetValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,        OPTIONAL
    IN      PCWSTR Field,       OPTIONAL
    IN      PCWSTR Data,        OPTIONAL
    IN      DWORD   Val,
    OUT     PDWORD  Offset      OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW (Key, Category, Item, Field, Data);

    return PrivateMemDbSetValueW (Key, Val, 0, 0, Offset);
}


BOOL
MemDbSetBinaryValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,         OPTIONAL
    IN      PCSTR Field,        OPTIONAL
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, Category, Item, Field, NULL);

    return PrivateMemDbSetBinaryValueA (Key, BinaryData, DataSize, Offset);
}


BOOL
MemDbSetBinaryValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,        OPTIONAL
    IN      PCWSTR Field,       OPTIONAL
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW (Key, Category, Item, Field, NULL);

    return PrivateMemDbSetBinaryValueW (Key, BinaryData, DataSize, Offset);
}



/*++

Routine Description:

  MemDbBuildKeyFromOffset and MemDbBuildKeyFromOffsetEx create a key
  string given the offset to the key, copying the string into the
  supplied buffer.  If a value pointer or user flag pointer is
  provided, it is filled with the value or flag stored at the offset.

  These functions also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if an offset points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar in Buffer.

Arguments:

  Offset     - Specifies the offset to the key as returned by MemDbSetValueEx.

  Buffer     - Specifies a MEMDB_MAX buffer.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  ValPtr     - Specifies a variable that receives the value stored for the key

Return Value:

  TRUE if the offset is valid and the function completed successfully, or
  FALSE if the offset is not valid or an internal memory corruption was detected.

--*/

BOOL
MemDbBuildKeyFromOffsetA (
    IN      DWORD Offset,
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr           OPTIONAL
    )
{
    WCHAR WideBuffer[MEMDB_MAX];
    BOOL b;

    b = MemDbBuildKeyFromOffsetW (
            Offset,
            WideBuffer,
            StartLevel,
            ValPtr
            );

    if (b) {
        KnownSizeWtoA (Buffer, WideBuffer);
    }

    return b;
}

BOOL
MemDbBuildKeyFromOffsetW (
    IN      DWORD Offset,
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr           OPTIONAL
    )
{
    return MemDbBuildKeyFromOffsetExW (
                Offset,
                Buffer,
                NULL,
                StartLevel,
                ValPtr,
                NULL
                );
}


/*++

Routine Description:

  MemDbBuildKeyFromOffset and MemDbBuildKeyFromOffsetEx create a key
  string given the offset to the key, copying the string into the
  supplied buffer.  If a value pointer or user flag pointer is
  provided, it is filled with the value or flag stored at the offset.

  These functions also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if an offset points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar in Buffer.

Arguments:

  Offset      - Specifies the offset to the key as returned by MemDbSetValueEx.

  Buffer      - Specifies a MEMDB_MAX buffer.

  BufferLen   - Receives the length of the string in characters, excluding the
                terminating nul.  If caller is using this for buffer allocation
                size, double BufferLen.

  StartLevel  - Specifies a zero-based starting level, where zero represents
                the complete string, one represents the string starting after
                the first backslash, and so on.

  ValPtr      - Specifies a variable that receives the value stored for the key

  UserFlagPtr - Specifies a variable that receives the user flags stored for the
                key

Return Value:

  TRUE if the offset is valid and the function completed successfully, or
  FALSE if the offset is not valid or an internal memory corruption was detected.

--*/

BOOL
MemDbBuildKeyFromOffsetExA (
    IN      DWORD Offset,
    OUT     PSTR Buffer,            OPTIONAL
    OUT     PDWORD BufferLen,       OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr,          OPTIONAL
    OUT     PDWORD UserFlagPtr      OPTIONAL
    )
{
    WCHAR WideBuffer[MEMDB_MAX];
    BOOL b;

    b = MemDbBuildKeyFromOffsetExW (
            Offset,
            WideBuffer,
            BufferLen,
            StartLevel,
            ValPtr,
            UserFlagPtr
            );

    if (b) {
        KnownSizeWtoA (Buffer, WideBuffer);
    }

    return b;
}

BOOL
MemDbBuildKeyFromOffsetExW (
    IN      DWORD Offset,
    OUT     PWSTR Buffer,           OPTIONAL
    OUT     PDWORD BufferLen,       OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr,          OPTIONAL
    OUT     PDWORD UserFlagPtr      OPTIONAL
    )
{
    PWSTR p,s;
    BYTE newDb = (BYTE) (Offset >> RESERVED_BITS);

    if (Offset == INVALID_OFFSET) {
        return FALSE;
    }

    SelectDatabase (newDb);

    p = Buffer;

    if (newDb != 0) {
        if (StartLevel == 0) {

            if (Buffer) {
                s = g_db->Hive;
                while (*s) {
                    *p++ = *s++;
                }
                *p++ = L'\\';
            }
        }
        else {
            StartLevel --;
        }
    }

    return PrivateBuildKeyFromOffset (
                StartLevel,
                Offset & OFFSET_MASK,
                p,
                ValPtr,
                UserFlagPtr,
                BufferLen
                );
}


BOOL
MemDbEnumItemsA  (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR  Category
    )
{
    CHAR Pattern[MEMDB_MAX];

    if (!Category)
        return FALSE;

    wsprintfA (Pattern, "%s\\*", Category);
    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumItemsW  (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category
    )
{
    WCHAR Pattern[MEMDB_MAX];

    if (!Category)
        return FALSE;

    wsprintfW (Pattern, L"%s\\*", Category);
    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumFieldsA (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR  Category,
    IN      PCSTR  Item             OPTIONAL
    )
{
    CHAR Pattern[MEMDB_MAX];

    if (!Category)
        return MemDbEnumItemsA (pEnum, Item);

    if (!Item)
        return MemDbEnumItemsA (pEnum, Category);

    wsprintfA (Pattern, "%s\\%s\\*", Category, Item);
    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumFieldsW (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category,
    IN      PCWSTR Item             OPTIONAL
    )
{
    WCHAR Pattern[MEMDB_MAX];

    if (!Category)
        return MemDbEnumItemsW (pEnum, Item);

    if (!Item)
        return MemDbEnumItemsW (pEnum, Category);

    wsprintfW (Pattern, L"%s\\%s\\*", Category, Item);
    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbGetValueExA (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field             OPTIONAL
    )
{
    CHAR Pattern[MEMDB_MAX];

    MemDbBuildKeyA (Pattern, Category, Item, Field, NULL);
    if (*Pattern) {
        AppendWackA (Pattern);
    }
    StringCatA (Pattern, "*");

    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);
}


BOOL
MemDbGetValueExW (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field            OPTIONAL
    )
{
    WCHAR Pattern[MEMDB_MAX];

    MemDbBuildKeyW (Pattern, Category, Item, Field, NULL);
    if (*Pattern) {
        AppendWackW (Pattern);
    }
    StringCatW (Pattern, L"*");

    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);
}



BOOL
MemDbGetEndpointValueA (
    IN      PCSTR Pattern,
    IN      PCSTR Item,             OPTIONAL        // used as the first variable arg to wsprintfA
    OUT     PSTR Buffer
    )
{
    CHAR Path[MEMDB_MAX];
    MEMDB_ENUMA memdb_enum;

    if (!Pattern) {
        if (!Item)
            return FALSE;

        StringCopyA (Path, Item);
    }
    else {
        if (!Item)
            StringCopyA (Path, Pattern);
        else
            wsprintfA (Path, Pattern, Item);
    }

    if (!MemDbEnumFirstValueA (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyA (Buffer, memdb_enum.szName);
    return TRUE;


}


BOOL
MemDbGetEndpointValueW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Item,            OPTIONAL
    OUT     PWSTR Buffer
    )
{
    WCHAR Path[MEMDB_MAX];
    MEMDB_ENUMW memdb_enum;

    if (!Pattern) {
        if (!Item)
            return FALSE;

        StringCopyW (Path, Item);
    }
    else {
        if (!Item)
            StringCopyW (Path, Pattern);
        else
            wsprintfW (Path, Pattern, Item);
    }

    if (!MemDbEnumFirstValueW (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyW (Buffer, memdb_enum.szName);
    return TRUE;

}


BOOL
MemDbGetEndpointValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field,            OPTIONAL
    OUT     PSTR Buffer
    )
{
    CHAR Path[MEMDB_MAX];
    MEMDB_ENUMA memdb_enum;

    MemDbBuildKeyA (Path, Category, Item, Field, NULL);
    if (*Path) {
        AppendWackA (Path);
    }
    StringCatA (Path, "*");


    if (!MemDbEnumFirstValueA (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    strcpy (Buffer, memdb_enum.szName);
    return TRUE;

}

BOOL
MemDbGetEndpointValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field,           OPTIONAL
    OUT     PWSTR Buffer
    )
{
    WCHAR Path[MEMDB_MAX];
    MEMDB_ENUMW memdb_enum;

    MemDbBuildKeyW (Path, Category, Item, Field, NULL);
    if (*Path) {
        AppendWackW (Path);
    }
    StringCatW (Path, L"*");

    if (!MemDbEnumFirstValueW (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyW (Buffer, memdb_enum.szName);
    return TRUE;

}


BOOL
MemDbGetOffsetW(
    IN      PCWSTR Key,
    OUT     PDWORD Offset
    )
{
    BOOL b;
    DWORD keyOffset;

    keyOffset = FindKey (Key);
    if (keyOffset == INVALID_OFFSET) {
        b = FALSE;
    }
    else {
        b = TRUE;
        *Offset = keyOffset;
    }

    return b;
}


BOOL
MemDbGetOffsetA (
    IN      PCSTR Key,
    OUT     PDWORD Offset
    )
{

    PCWSTR wstr;
    BOOL b;

    wstr = ConvertAtoW (Key);
    if (wstr) {
        b = MemDbGetOffsetW (wstr,Offset);
        FreeConvertedStr (wstr);
    }
    else {
        b = FALSE;
    }

    return b;
}


BOOL
MemDbGetOffsetExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field,           OPTIONAL
    IN      PCWSTR Data,            OPTIONAL
    OUT     PDWORD Offset           OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW(Key,Category,Item,Field,Data);

    return MemDbGetOffsetW(Key,Offset);
}


BOOL
MemDbGetOffsetExA (
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field,            OPTIONAL
    IN      PCSTR Data,             OPTIONAL
    OUT     PDWORD Offset           OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA(Key,Category,Item,Field,Data);

    return MemDbGetOffsetA(Key,Offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\memdbp.h ===
//
// #defines
//

//
// This is our version stamp.  Change MEMDB_VERSION only.
//

#define MEMDB_VERSION L"v9 "

#define VERSION_BASE_SIGNATURE L"memdb dat file "
#define MEMDB_DEBUG_SIGNATURE   L"debug"
#define MEMDB_NODBG_SIGNATURE   L"nodbg"

#define VERSION_SIGNATURE VERSION_BASE_SIGNATURE MEMDB_VERSION
#define DEBUG_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_DEBUG_SIGNATURE
#define RETAIL_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_NODBG_SIGNATURE

#define SIGNATURE 0xab12e87d


//
// We must reserve 5 bits. In a KEYSTRUCT node, 2 bits are used for AVL
// balancing, 1 bit for endpoint, 1 bit for proxy nodes, and 1 bit for binary
// nodes. In a hash table entry, the top 5 bits provide the hive index.
//

#define RESERVED_BITS       27
#define RESERVED_MASK       0xf8000000
#define OFFSET_MASK         (~RESERVED_MASK)

//
// KEYSTRUCT flags
//

#define KSF_ENDPOINT        0x08000000
#define KSF_BINARY          0x40000000
#define KSF_PROXY_NODE      0x80000000
#define KSF_BALANCE_MASK    0x30000000
#define KSF_BALANCE_SHIFT   28              // bit pos of KSF_RIGHT_HEAVY
#define KSF_RIGHT_HEAVY     0x10000000
#define KSF_LEFT_HEAVY      0x20000000
#define KSF_USERFLAG_MASK   OFFSET_MASK

//
// Binary tree allocation parameters
//

#define ALLOC_TOLERANCE 32
#define BLOCK_SIZE      0x00010000

#define MAX_HIVE_NAME       64

#define TOKENBUCKETS    511


//
// Typedefs
//

//
// The DATABASE structure holds all pieces of information necessary
// to maintain a portion of the overall memory database.  There is a
// root DATABASE structure that always exists (its index is zero),
// and there are additional DATABASE structures for each database
// the caller creates via the MemDbCreateDatabase call.  Callers create
// additional databases when a node is needed for temporary processing.
//

typedef struct {
    DWORD AllocSize;
    DWORD End;
    DWORD FirstLevelRoot;
    DWORD FirstDeleted;
    DWORD TokenBuckets[TOKENBUCKETS];
    PBYTE Buf;
    WCHAR Hive[MAX_HIVE_NAME];
} DATABASE, *PDATABASE;

//
// Hive struct (for KSF_HIVE type)
//

typedef struct {
    DATABASE DatabaseInfo;
} HIVE, *PHIVE;

//
// Binary block struct (for KSF_BINARY type of the key struct)
//

typedef struct _tagBINARYBLOCK {
#ifdef DEBUG
    DWORD Signature;
#endif

    DWORD Size;
    struct _tagBINARYBLOCK *NextPtr, *PrevPtr;
    DWORD OwningKey;
    BYTE Data[];
} BINARYBLOCK, *PBINARYBLOCK;


//
// KEYSTRUCT holds each piece of memdb entries.  A single KEYSTRUCT
// holds a portion of a key (delimited by a backslash), and the
// KEYSTRUCTs are organized into a binary tree.  Each KEYSTRUCT
// can also contain additional binary trees.  This is what makes
// memdb so versitle--many relationships can be established by
// formatting key strings in various ways.
//

typedef struct {
    DWORD Signature;

    // Offsets for data struct
    DWORD Left, Right;
    DWORD Parent;

    union {
        struct {
            union {
                DWORD dwValue;
                PBINARYBLOCK BinaryPtr;
            };
            DWORD Flags;
            // Other properties here
        };

        DWORD NextDeleted;        // for deleted items, we keep a list of free blocks
    };

    DWORD NextLevelRoot;
    DWORD PrevLevelNode;

    DWORD KeyToken;
} KEYSTRUCT_DEBUG, *PKEYSTRUCT_DEBUG;


typedef struct {
    // Offsets for data struct
    DWORD Left, Right;
    DWORD Parent;

    union {
        struct {
            union {
                DWORD dwValue;
                PBINARYBLOCK BinaryPtr;
            };
            DWORD Flags;
            // Other properties here
        };

        DWORD NextDeleted;        // for deleted items, we keep a list of free blocks
    };

    DWORD NextLevelRoot;
    DWORD PrevLevelNode;

    DWORD KeyToken;
} KEYSTRUCT_RETAIL, *PKEYSTRUCT_RETAIL;

typedef struct {
    DWORD Right;
    WCHAR String[];
} TOKENSTRUCT, *PTOKENSTRUCT;

#ifdef DEBUG
#define KEYSTRUCT       KEYSTRUCT_DEBUG
#define PKEYSTRUCT      PKEYSTRUCT_DEBUG
#else
#define KEYSTRUCT       KEYSTRUCT_RETAIL
#define PKEYSTRUCT      PKEYSTRUCT_RETAIL
#endif



//
// Globals
//

extern PDATABASE g_db;
extern BYTE g_SelectedDatabase;        // current index of active database
extern PHIVE g_HeadHive;
extern CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG
extern BOOL g_UseDebugStructs;
#endif

//
// memdb.c routines
//

PCWSTR
SelectHive (
    PCWSTR FullKeyStr
    );

BOOL
PrivateMemDbSetValueA (
    IN      PCSTR Key,
    IN      DWORD Val,
    IN      DWORD SetFlags,
    IN      DWORD ClearFlags,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetValueW (
    IN      PCWSTR Key,
    IN      DWORD Val,
    IN      DWORD SetFlags,
    IN      DWORD ClearFlags,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetBinaryValueA (
    IN      PCSTR Key,
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetBinaryValueW (
    IN      PCWSTR Key,
    IN      PCBYTE  BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset           OPTIONAL
    );

//
// hash.c routines
//

BOOL
InitializeHashBlock (
    VOID
    );

VOID
FreeHashBlock (
    VOID
    );


BOOL
SaveHashBlock (
    HANDLE File
    );

BOOL
LoadHashBlock (
    HANDLE File
    );

BOOL
AddHashTableEntry (
    IN      PCWSTR FullString,
    IN      DWORD Offset
    );

DWORD
FindStringInHashTable (
    IN      PCWSTR FullString,
    OUT     PBYTE DatabaseId        OPTIONAL
    );

BOOL
RemoveHashTableEntry (
    IN      PCWSTR FullString
    );

//
// binval.c
//

PCBYTE
GetKeyStructBinaryData (
    PKEYSTRUCT KeyStruct
    );

DWORD
GetKeyStructBinarySize (
    PKEYSTRUCT KeyStruct
    );

PBINARYBLOCK
AllocBinaryBlock (
    IN      PCBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD OwningKey
    );

VOID
FreeKeyStructBinaryBlock (
    PKEYSTRUCT KeyStruct
    );

VOID
FreeAllBinaryBlocks (
    VOID
    );

BOOL
LoadBinaryBlocks (
    HANDLE File
    );

BOOL
SaveBinaryBlocks (
    HANDLE File
    );


//
// bintree.c
//

PKEYSTRUCT
GetKeyStruct (
    DWORD Offset
    );

DWORD
FindKeyStruct (
    IN DWORD RootOffset,
    IN PCWSTR KeyName
    );


DWORD
GetFirstOffset (
    DWORD RootOffset
    );

DWORD
GetNextOffset (
    DWORD NodeOffset
    );

DWORD
FindKey (
    IN  PCWSTR FullKeyPath
    );

DWORD
FindPatternKey (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath,
    IN  BOOL EndPatternAllowed
    );

DWORD
FindKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    );

DWORD
FindPatternKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    );

DWORD
NewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive
    );

VOID
DeleteKey (
    IN      PCWSTR KeyStr,
    IN OUT  PDWORD RootPtr,
    IN      BOOL MustMatch
    );

VOID
CopyValToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    );

VOID
CopyFlagsToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    );

BOOL
PrivateBuildKeyFromOffset (
    IN      DWORD StartLevel,               // zero-based
    IN      DWORD TailOffset,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PDWORD ValPtr,                  OPTIONAL
    OUT     PDWORD UserFlagsPtr,            OPTIONAL
    OUT     PDWORD CharCount                OPTIONAL
    );

BOOL
SelectDatabase (
    IN      BYTE DatabaseId
    );

#ifdef DEBUG

VOID
DumpBinTreeStats (
    VOID
    );

#else

#define DumpBinTreeStats()

#endif

PCWSTR
GetKeyToken (
    IN      DWORD Token
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\memdb\regops.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regops.c

Abstract:

  Routines that manage the merging of registry keys. Given a key
  and a value, these functions allow the user to perform the same
  types of actions as those specified in usermig.inf and wkstamig.inf
  (i.e.: Copying, Suppressing, and Forcing various registry keys to be
  merged into the NT registry.)


Routines:


Author:

    Marc R. Whitten (marcw) 01-Aug-1997

Revision History:

    Jim Schmidt (jimschm)   25-Mar-1998     Updated to properly support
                                            tree notation, fixed value suppression
                                            bug.


--*/

#include "pch.h"
#include "memdbp.h"
#include "merge.h"

#define DBG_REGOPS "RegOps"




/*++

Routine Description:

  IsRegObjectMarkedForOperation builds an encoded key, escaping multi-byte
  characters and syntax characters, and then performs a MemDb lookup to see
  if the object is marked with the bit specified by OperationMask.  A set of
  macros are built on top of this routine in regops.h.

Arguments:

  Key           - Specifies the unencoded registry key, with abriviated roots
                  (i.e., HKLM\Software\Foo)
  Value         - Specifies the registry key value name
  TreeState     - Specifies KEY_ONLY to query against the key and optional
                  value, KEY_TREE to query against the key with a star at the
                  end, or TREE_OPTIONAL to query both.
  OperationMask - Specifies an operation mask.  See merge.h.

Return Value:

  TRUE if the key is in MemDb, or FALSE if it is not.

--*/

BOOL
IsRegObjectMarkedForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,                OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    )
{
    PCSTR regObject;
    BOOL rIsMarked = FALSE;
    DWORD value;

    MYASSERT (TreeState != KEY_TREE || !Value);

    if (TreeState == KEY_ONLY || TreeState == TREE_OPTIONAL) {
        regObject = CreateEncodedRegistryStringExA(Key,Value,FALSE);

        if (MemDbGetStoredEndPatternValueA(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringA(regObject);
    }

    if (!rIsMarked && TreeState == KEY_TREE || TreeState == TREE_OPTIONAL && !Value) {
        regObject = CreateEncodedRegistryStringExA(Key,Value,TRUE);

        if (MemDbGetStoredEndPatternValueA(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringA(regObject);
    }

    return rIsMarked;
}

BOOL
IsRegObjectMarkedForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,               OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    )
{
    PCWSTR regObject;
    BOOL rIsMarked = FALSE;
    DWORD value;

    MYASSERT (TreeState != KEY_TREE || !Value);

    if (TreeState == KEY_ONLY || TreeState == TREE_OPTIONAL) {
        regObject = CreateEncodedRegistryStringExW(Key,Value,FALSE);

        if (MemDbGetStoredEndPatternValueW(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringW(regObject);
    }

    if (!rIsMarked && TreeState == KEY_TREE || TreeState == TREE_OPTIONAL && !Value) {
        regObject = CreateEncodedRegistryStringExW(Key,Value,TRUE);

        if (MemDbGetStoredEndPatternValueW(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringW(regObject);
    }

    return rIsMarked;
}



/*++

Routine Description:

  MarkRegObjectForOperation creates an encoded string and sets the operation
  bit in memdb.  This routine is used to suppress operations from occurring
  on a registry key, registry value, or registry key tree.

Arguments:

  Key           - Specifies an unencoded registry key, with abriviated root
                  (i.e., HKLM\Software\Foo).
  Value         - Specifies the registry key value name.
  Tree          - Specifies TRUE if Key specifies an entire registry key tree
                  (in which case Value must be NULL), or FALSE if Key
                  specifies a key that has different behavior for its subkeys.
  OperationMask - Specifies the suppression operation.  See merge.h.

Return Value:

  TRUE if the set was successful.

--*/

BOOL
MarkRegObjectForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    )
{

    PCSTR regObject;
    BOOL rSuccess = TRUE;

    if (Tree && Value) {
        Tree = FALSE;
    }

    regObject = CreateEncodedRegistryStringExA(Key,Value,Tree);

    rSuccess = MarkObjectForOperationA (regObject, OperationMask);

    FreeEncodedRegistryStringA(regObject);

    return rSuccess;
}

BOOL
MarkRegObjectForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    )
{

    PCWSTR regObject;
    BOOL rSuccess = TRUE;

    if (Tree && Value) {
        Tree = FALSE;
    }

    regObject = CreateEncodedRegistryStringExW(Key,Value,Tree);

    rSuccess = MarkObjectForOperationW (regObject, OperationMask);

    FreeEncodedRegistryStringW(regObject);

    return rSuccess;
}


/*++

Routine Description:

  MarkObjectForOperation sets operation bits on a specified registry object,
  unless operation bits have already been specified.

Arguments:

  Object        - Specifies the encoded registry object.  See memdbdef.h for
                  syntax (the HKLM or HKR categories).
  OperationMask - Specifies the suppression operation for the particular
                  object.

Return Value:

  TRUE if the set operation was successful, or FALSE if an operation was
  already specified.

--*/


BOOL
MarkObjectForOperationA (
    IN      PCSTR Object,
    IN      DWORD OperationMask
    )
{
    DWORD Value;

    if (MemDbGetValueA (Object, &Value)) {
        DEBUGMSG_IF ((
            Value == OperationMask,
            DBG_REGOPS,
            "%hs is already in memdb.",
            Object
            ));

        DEBUGMSG_IF ((
            Value != OperationMask,
            DBG_REGOPS,
            "%hs is already in memdb with different flags %u. New flags ignored: %u.",
            Object,
            Value,
            OperationMask
            ));

        return FALSE;
    }

    return MemDbSetValueA (Object, OperationMask);
}

BOOL
MarkObjectForOperationW (
    IN      PCWSTR Object,
    IN      DWORD OperationMask
    )
{
    DWORD Value;

    if (MemDbGetValueW (Object, &Value)) {
        DEBUGMSG_IF ((
            Value == OperationMask,
            DBG_REGOPS,
            "%ls is already in memdb.",
            Object
            ));

        DEBUGMSG_IF ((
            Value != OperationMask,
            DBG_REGOPS,
            "%ls is already in memdb with different flags %u. New flags ignored: %u.",
            Object,
            Value,
            OperationMask
            ));

        return FALSE;
    }

    return MemDbSetValueW (Object, OperationMask);
}

BOOL
ForceWin9xSettingA (
    IN      PCSTR SourceKey,
    IN      PCSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCSTR DestinationKey,
    IN      PCSTR DestinationValue,
    IN      BOOL DestinationTree
    )
{
    PCSTR regSource;
    CHAR keySource[MEMDB_MAX];
    PCSTR regDestination;
    CHAR keyDestination[MEMDB_MAX];
    DWORD offset = 0;
    BOOL rSuccess = TRUE;

    regSource = CreateEncodedRegistryStringExA (SourceKey, SourceValue, SourceTree);
    MemDbBuildKeyA (keySource, MEMDB_CATEGORY_FORCECOPYA, regSource, NULL, NULL);

    regDestination = CreateEncodedRegistryStringExA (DestinationKey, DestinationValue, DestinationTree);
    MemDbBuildKeyA (keyDestination, MEMDB_CATEGORY_FORCECOPYA, regDestination, NULL, NULL);

    rSuccess = MemDbSetValueExA (keyDestination, NULL, NULL, NULL, 0, &offset);

    if (rSuccess) {
        rSuccess = MemDbSetValueA (keySource, offset);
    }

    FreeEncodedRegistryStringA (regDestination);

    FreeEncodedRegistryStringA (regSource);

    return rSuccess;
}

BOOL
ForceWin9xSettingW (
    IN      PCWSTR SourceKey,
    IN      PCWSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCWSTR DestinationKey,
    IN      PCWSTR DestinationValue,
    IN      BOOL DestinationTree
    )
{
    PCWSTR regSource;
    WCHAR keySource[MEMDB_MAX];
    PCWSTR regDestination;
    WCHAR keyDestination[MEMDB_MAX];
    DWORD offset = 0;
    BOOL rSuccess = TRUE;

    regSource = CreateEncodedRegistryStringExW (SourceKey, SourceValue, SourceTree);
    MemDbBuildKeyW (keySource, MEMDB_CATEGORY_FORCECOPYW, regSource, NULL, NULL);

    regDestination = CreateEncodedRegistryStringExW (DestinationKey, DestinationValue, DestinationTree);
    MemDbBuildKeyW (keyDestination, MEMDB_CATEGORY_FORCECOPYW, regDestination, NULL, NULL);

    rSuccess = MemDbSetValueExW (keyDestination, NULL, NULL, NULL, 0, &offset);

    if (rSuccess) {
        rSuccess = MemDbSetValueW (keySource, offset);
    }

    FreeEncodedRegistryStringW (regDestination);

    FreeEncodedRegistryStringW (regSource);

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\app.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    app.cpp

Abstract:

    Source file for dealing with registered apps.

Author:

    Jim Schmidt (jimschm)   06-Mar-2001

Revision History:

    <alias> <date> <description>

--*/

#include "pch.h"
#include "shappmgrp.h"


ULONGLONG
pComputeWstrChecksum (
    IN      ULONGLONG Checksum,
    IN      PCWSTR String
    )
{
    Checksum = (Checksum << 2) | (Checksum >> 62);
    if (String) {
        while (*String) {
            Checksum = (Checksum << 17) | (Checksum >> 47);
            Checksum ^= (ULONGLONG) (*String);
            String++;
        }
    }

    return Checksum;
}

PINSTALLEDAPPW
GetInstalledAppsW (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT Count             OPTIONAL
    )
{
    IShellAppManager *appManager = NULL;
    IEnumInstalledApps *enumApps = NULL;
    IInstalledApp *installedApp = NULL;
    APPINFODATA appInfoData;
    HRESULT hr;
    PINSTALLEDAPPW instApp;
    UINT orgEnd = Buffer->End;

    if (Count) {
        *Count = 0;
    }

    __try {

        //
        // Create shell manager interface
        //

        hr = CoCreateInstance (
                __uuidof(ShellAppManager),
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(IShellAppManager),
                (void**) &appManager
                );

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, "Can't create ShellAppManager interface. hr=%X", hr));
            __leave;
        }

        //
        // Create installed apps enum interface
        //

        hr = appManager->EnumInstalledApps (&enumApps);

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, "Can't create EnumInstalledApps interface. hr=%X", hr));
            __leave;
        }

        //
        // Enumerate the apps
        //

        hr = enumApps->Next (&installedApp);

        while (hr == S_OK) {
            ZeroMemory (&appInfoData, sizeof (APPINFODATA));
            appInfoData.cbSize = sizeof(APPINFODATA);
            appInfoData.dwMask = AIM_DISPLAYNAME|
                                 AIM_VERSION|
                                 AIM_PUBLISHER|
                                 AIM_PRODUCTID|
                                 AIM_REGISTEREDOWNER|
                                 AIM_REGISTEREDCOMPANY|
                                 AIM_LANGUAGE|
                                 AIM_SUPPORTURL|
                                 AIM_SUPPORTTELEPHONE|
                                 AIM_HELPLINK|
                                 AIM_INSTALLLOCATION|
                                 AIM_INSTALLSOURCE|
                                 AIM_INSTALLDATE|
                                 AIM_CONTACT|
                                 AIM_COMMENTS|
                                 AIM_IMAGE|
                                 AIM_READMEURL|
                                 AIM_UPDATEINFOURL;

            hr = installedApp->GetAppInfo (&appInfoData);

            if (hr == S_OK) {
                instApp = (PINSTALLEDAPPW) GrowBuffer (Buffer, sizeof (INSTALLEDAPPW));
                StringCopyByteCountW (instApp->DisplayName, appInfoData.pszDisplayName, sizeof (instApp->DisplayName));

                if (appInfoData.pszVersion) {
                    StringCopyByteCountW (instApp->Version, appInfoData.pszVersion, sizeof (instApp->Version));
                } else {
                    instApp->Version[0] = 0;
                }

                if (appInfoData.pszPublisher) {
                    StringCopyByteCountW (instApp->Publisher, appInfoData.pszPublisher, sizeof (instApp->Publisher));
                } else {
                    instApp->Publisher[0] = 0;
                }

                if (appInfoData.pszProductID) {
                    StringCopyByteCountW (instApp->ProductID, appInfoData.pszProductID, sizeof (instApp->ProductID));
                } else {
                    instApp->ProductID[0] = 0;
                }

                if (appInfoData.pszRegisteredOwner) {
                    StringCopyByteCountW (instApp->RegisteredOwner, appInfoData.pszRegisteredOwner, sizeof (instApp->RegisteredOwner));
                } else {
                    instApp->RegisteredOwner[0] = 0;
                }

                if (appInfoData.pszRegisteredCompany) {
                    StringCopyByteCountW (instApp->RegisteredCompany, appInfoData.pszRegisteredCompany, sizeof (instApp->RegisteredCompany));
                } else {
                    instApp->RegisteredCompany[0] = 0;
                }

                if (appInfoData.pszLanguage) {
                    StringCopyByteCountW (instApp->Language, appInfoData.pszLanguage, sizeof (instApp->Language));
                } else {
                    instApp->Language[0] = 0;
                }

                if (appInfoData.pszSupportUrl) {
                    StringCopyByteCountW (instApp->SupportUrl, appInfoData.pszSupportUrl, sizeof (instApp->SupportUrl));
                } else {
                    instApp->SupportUrl[0] = 0;
                }

                if (appInfoData.pszSupportTelephone) {
                    StringCopyByteCountW (instApp->SupportTelephone, appInfoData.pszSupportTelephone, sizeof (instApp->SupportTelephone));
                } else {
                    instApp->SupportTelephone[0] = 0;
                }

                if (appInfoData.pszHelpLink) {
                    StringCopyByteCountW (instApp->HelpLink, appInfoData.pszHelpLink, sizeof (instApp->HelpLink));
                } else {
                    instApp->HelpLink[0] = 0;
                }

                if (appInfoData.pszInstallLocation) {
                    StringCopyByteCountW (instApp->InstallLocation, appInfoData.pszInstallLocation, sizeof (instApp->InstallLocation));
                } else {
                    instApp->InstallLocation[0] = 0;
                }

                if (appInfoData.pszInstallSource) {
                    StringCopyByteCountW (instApp->InstallSource, appInfoData.pszInstallSource, sizeof (instApp->InstallSource));
                } else {
                    instApp->InstallSource[0] = 0;
                }

                if (appInfoData.pszInstallDate) {
                    StringCopyByteCountW (instApp->InstallDate, appInfoData.pszInstallDate, sizeof (instApp->InstallDate));
                } else {
                    instApp->InstallDate[0] = 0;
                }

                if (appInfoData.pszContact) {
                    StringCopyByteCountW (instApp->Contact, appInfoData.pszContact, sizeof (instApp->Contact));
                } else {
                    instApp->Contact[0] = 0;
                }

                if (appInfoData.pszComments) {
                    StringCopyByteCountW (instApp->Comments, appInfoData.pszComments, sizeof (instApp->Comments));
                } else {
                    instApp->Comments[0] = 0;
                }

                if (appInfoData.pszImage) {
                    StringCopyByteCountW (instApp->Image, appInfoData.pszImage, sizeof (instApp->Image));
                } else {
                    instApp->Image[0] = 0;
                }

                if (appInfoData.pszReadmeUrl) {
                    StringCopyByteCountW (instApp->ReadmeUrl, appInfoData.pszReadmeUrl, sizeof (instApp->ReadmeUrl));
                } else {
                    instApp->ReadmeUrl[0] = 0;
                }

                if (appInfoData.pszUpdateInfoUrl) {
                    StringCopyByteCountW (instApp->UpdateInfoUrl, appInfoData.pszUpdateInfoUrl, sizeof (instApp->UpdateInfoUrl));
                } else {
                    instApp->UpdateInfoUrl[0] = 0;
                }

                instApp->Checksum = pComputeWstrChecksum (0, appInfoData.pszVersion);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszPublisher);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszProductID);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszLanguage);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszInstallLocation);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszInstallDate);

                if (Count) {
                    *Count += 1;
                }
            }

            installedApp->Release();
            hr = enumApps->Next (&installedApp);
        }

        //
        // Done
        //

        hr = S_OK;

    }
    __finally {

        if (appManager) {
            appManager->Release();
        }

        if (enumApps) {
            enumApps->Release();
        }
    }

    return hr == S_OK ? (PINSTALLEDAPPW) (Buffer->Buf + orgEnd) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\cablib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.c

Abstract:

    Implements wrappers for cabinet APIs

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include <cablib.h>
#include <fci.h>
#include <fdi.h>
#include <fcntl.h>
#include <crt\sys\stat.h>

//
// Includes
//

// None

#define DBG_CABLIB  "CabLib"

//
// Strings
//

// None

//
// Constants
//

#define VERIFY_HANDLE   ((HANDLE) (-2))

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR CabPath;
    PCSTR CabFileFormat;
    PCSTR CabDiskFormat;
    PCABGETCABINETNAMESA CabGetCabinetNames;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFileFormat;
    PCWSTR CabDiskFormat;
    PCABGETCABINETNAMESW CabGetCabinetNames;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW;

typedef struct {
    PCSTR CabPath;
    PCSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW;

typedef struct {
    PCSTR ExtractPath;
    PCABNOTIFICATIONA CabNotificationA;
} CAB_DATAA, *PCAB_DATAA;

typedef struct {
    PCWSTR ExtractPath;
    PCABNOTIFICATIONW CabNotificationW;
    BOOL VerifyMode;
} CAB_DATAW, *PCAB_DATAW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

INT
DIAMONDAPI
pCabFilePlacedA (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


INT
DIAMONDAPI
pCabFilePlacedW (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}

VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MemFree (g_hHeap, 0, Memory);
}

INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    MYASSERT (pMode == (_S_IREAD | _S_IWRITE));

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return bytesRead;
}

UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    DWORD dontCare;

    if (FileHandle == (INT_PTR) VERIFY_HANDLE) {
        return Size;
    }

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &dontCare, NULL);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return Size;
}

UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    DWORD dontCare;

    if (FileHandle == (INT_PTR) VERIFY_HANDLE) {
        return Size;
    }

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &dontCare, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return Size;
}

INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    *Error = 0;
    return 0;
}

INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return ((LONG)(result));
}

LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    if (!DeleteFileA (FileName)) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CHAR tempPath[MAX_PATH];
    PSTR p;

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = _mbsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (!DoesFileExistA (tempPath)) {
        CreateDirectoryA (tempPath, NULL);
    }

    if (!GetTempFileNameA (tempPath, "cab", 0, FileName)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        return cabHandle->CabGetCabinetNames (
                            FciCabParams->szCabPath,
                            CB_MAX_CAB_PATH,
                            FciCabParams->szCab,
                            CB_MAX_CABINET_NAME,
                            FciCabParams->szDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfA (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            StringCopyByteCountA (FciCabParams->szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfA (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            StringCopyByteCountA (FciCabParams->szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
        }
    }
    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];
    BOOL result;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        result = cabHandle->CabGetCabinetNames (
                            cabPath,
                            CB_MAX_CAB_PATH,
                            cabFile,
                            CB_MAX_CABINET_NAME,
                            cabDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
        if (result) {
            KnownSizeUnicodeToDbcs (FciCabParams->szCabPath, cabPath);
            KnownSizeUnicodeToDbcs (FciCabParams->szCab, cabFile);
            KnownSizeUnicodeToDbcs (FciCabParams->szDisk, cabDisk);
            return TRUE;
        }
        return FALSE;
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfW (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            KnownSizeUnicodeToDbcs (FciCabParams->szCab, cabFile);
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfW (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            KnownSizeUnicodeToDbcs (FciCabParams->szDisk, cabDisk);
        }
    }
    return TRUE;
}

LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEA) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEW) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    WIN32_FIND_DATAA findData;
    FILETIME fileTime;
    HANDLE fileHandle;

    if (DoesFileExistExA (FileName, &findData)) {

        FileTimeToLocalFileTime (&findData.ftLastWriteTime, &fileTime);
        FileTimeToDosDateTime (&fileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (findData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (fileHandle == INVALID_HANDLE_VALUE) {
            *Error = GetLastError ();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)fileHandle;
    } else {
        *Error = GetLastError ();
        return -1;
    }
}


BOOL
pIsFullPathA (
    IN      PCSTR PathToTest
    )
{
    MBCHAR ch1;
    MBCHAR ch2;

    ch1 = _mbsnextc (PathToTest);
    _mbsinc (PathToTest);
    ch2 = _mbsnextc (PathToTest);

    if ((ch1 == '\\' && ch2 == '\\') ||
        (isalpha (ch1) && ch2 == '\\')
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsFullPathW (
    IN      PCWSTR PathToTest
    )
{
    WCHAR ch1;
    WCHAR ch2;

    ch1 = *PathToTest++;
    ch2 = *PathToTest;

    if ((ch1 == '\\' && ch2 == '\\') ||
        (isalpha (ch1) && ch2 == '\\')
        ) {
        return TRUE;
    }

    return FALSE;
}


PCSTR
pComputeDestPathA (
    IN      PCSTR ExtractPath,          OPTIONAL
    IN      PCSTR PathStoredInCab
    )
{
    PCSTR destFile;

    //
    // If ExtractPath is NULL, then use the path stored in the cab.
    // If the path stored in the cab is a full path, use only the file name.
    // Otherwise join ExtractPath with PathStoredInCab.
    //

    if (!ExtractPath) {

        destFile = DuplicatePathStringA (PathStoredInCab, 0);

    } else if (pIsFullPathA (PathStoredInCab)) {

        destFile = JoinPathsA (ExtractPath, GetFileNameFromPathA (PathStoredInCab));

    } else {

        destFile = JoinPathsA (ExtractPath, PathStoredInCab);

    }

    return destFile;
}


PCWSTR
pComputeDestPathW (
    IN      PCWSTR ExtractPath,         OPTIONAL
    IN      PCWSTR PathStoredInCab
    )
{
    PCWSTR destFile;

    //
    // If ExtractPath is NULL, then use the path stored in the cab.
    // If the path stored in the cab is a full path, use only the file name.
    // Otherwise join ExtractPath with PathStoredInCab.
    //

    if (!ExtractPath) {

        destFile = DuplicatePathStringW (PathStoredInCab, 0);

    } else if (pIsFullPathW (PathStoredInCab)) {

        destFile = JoinPathsW (ExtractPath, GetFileNameFromPathW (PathStoredInCab));

    } else {

        destFile = JoinPathsW (ExtractPath, PathStoredInCab);

    }

    return destFile;
}


INT_PTR
DIAMONDAPI
pCabNotificationA (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAA cabData;
    INT createFlag;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied

        cabData = (PCAB_DATAA)FdiNotification->pv;

        destFile = pComputeDestPathA (cabData->ExtractPath, FdiNotification->psz1);
        createFlag = TRUE;

        if (cabData->CabNotificationA) {
            createFlag = cabData->CabNotificationA (destFile);
        }

        if(-1 == createFlag){
            FreePathStringA (destFile);
            return -1;
        }

        if (createFlag) {
            MakeSurePathExistsA (FdiNotification->psz1, FALSE);

            SetFileAttributesA (destFile, FILE_ATTRIBUTE_NORMAL);
            destHandle = CreateFileA (
                            destFile,
                            GENERIC_READ|GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        }
        FreePathStringA (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAA)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }

        destFile = pComputeDestPathA (cabData->ExtractPath, FdiNotification->psz1);

        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesA (destFile, attributes);
        FreePathStringA (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        return 0;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabNotificationW (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCWSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAW cabData;
    INT createFlag;
    PCWSTR cabFileSpecW;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied

        cabFileSpecW = ConvertAtoW (FdiNotification->psz1);
        cabData = (PCAB_DATAW)FdiNotification->pv;

        destFile = pComputeDestPathW (cabData->ExtractPath, cabFileSpecW);

        FreeConvertedStr (cabFileSpecW);
        createFlag = TRUE;

        if (cabData->CabNotificationW) {
            createFlag = cabData->CabNotificationW (destFile);
        }

        if(-1 == createFlag){
            FreePathStringW (destFile);
            return -1;
        }

        if (createFlag) {
            if (!cabData->VerifyMode) {
                MakeSurePathExistsW (cabFileSpecW, FALSE);

                SetFileAttributesW (destFile, FILE_ATTRIBUTE_NORMAL);
                destHandle = CreateFileW (
                                destFile,
                                GENERIC_READ|GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            } else {
                destHandle = VERIFY_HANDLE;
            }
        }

        FreePathStringW (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAW)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }

        cabFileSpecW = ConvertAtoW (FdiNotification->psz1);
        destFile = pComputeDestPathW (cabData->ExtractPath, cabFileSpecW);
        FreeConvertedStr (cabFileSpecW);

        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesW (destFile, attributes);
        FreePathStringW (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        return 0;
    }
    return 0;
}

CCABHANDLE
CabCreateCabinetA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringA (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringA (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringA (CabDiskFormat, 0);
    }

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        StringCopyByteCountA (cabHandle->FciCabParams.szCabPath, CabPath, CB_MAX_CAB_PATH - 1);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfA (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        StringCopyByteCountA (cabHandle->FciCabParams.szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
    }
    wsprintfA (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    StringCopyByteCountA (cabHandle->FciCabParams.szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringW (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringW (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringW (CabDiskFormat, 0);
    }

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCabPath, CabPath);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfW (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szDisk, cabDisk);
    }
    wsprintfW (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCab, cabFile);

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabHandle->FciCabParams.szCabPath,
            CB_MAX_CAB_PATH,
            cabHandle->FciCabParams.szCab,
            CB_MAX_CABINET_NAME,
            cabHandle->FciCabParams.szDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabPath,
            CB_MAX_CAB_PATH,
            cabFile,
            CB_MAX_CABINET_NAME,
            cabDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCabPath, cabPath);
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCab, cabFile);
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szDisk, cabDisk);
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }

    return FCIAddFile (
                cabHandle->FciHandle,
                (PSTR)FileName,
                (PSTR)StoredName,
                FALSE,
                pCabGetNextCabinetA,
                pCabStatusA,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    CHAR ansiFileName [1024];
    CHAR ansiStoredName [1024];

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    KnownSizeUnicodeToDbcs (ansiFileName, FileName);
    KnownSizeUnicodeToDbcs (ansiStoredName, StoredName);

    return FCIAddFile (
                cabHandle->FciHandle,
                ansiFileName,
                ansiStoredName,
                FALSE,
                pCabGetNextCabinetW,
                pCabStatusW,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetA,
            pCabStatusA
            )) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }

    return result;
}

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetW,
            pCabStatusW
            )) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }
    return result;
}

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    PSTR filePtr;
    HANDLE fileHandle;
    PCSTR fileName;

    cabHandle = (PFDI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEA));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringA (FileName, 0);
    fileHandle = CreateFileA (
                    fileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringA (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PSTR)GetFileNameFromPathA (fileName);
    if (!filePtr) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringA (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringA (fileName, 0);
    FreePathStringA (fileName);
    return ((CCABHANDLE)(cabHandle));
}

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PWSTR filePtr;
    HANDLE fileHandle;
    PCWSTR fileName;

    cabHandle = (PFDI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEW));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringW (FileName, 0);
    fileHandle = CreateFileW (
                    fileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringW (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PWSTR)GetFileNameFromPathW (fileName);
    if (!filePtr) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringW (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringW (fileName, 0);
    FreePathStringW (fileName);
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,                      OPTIONAL
    IN      PCABNOTIFICATIONA CabNotification       OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    CAB_DATAA cabData;

    cabHandle = (PFDI_CAB_HANDLEA)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotificationA = CabNotification;

    return FDICopy (
                cabHandle->FdiHandle,
                (PSTR)cabHandle->CabFile,
                (PSTR)cabHandle->CabPath,
                0,
                pCabNotificationA,
                NULL,
                (PVOID)(&cabData)
                );
}


BOOL
pCabExtractAllFilesExWorkerW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,                     OPTIONAL
    IN      PCABNOTIFICATIONW CabNotificationW,     OPTIONAL
    IN      BOOL VerifyMode
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

  CabNotification - Specifies the notification callback function that is
        called for every file in the cab

  VerifyMode - Specifies TRUE if the cab should be verified, FALSE if it
        should be extracted

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    CAB_DATAW cabData;
    BOOL result;
    PCSTR cabFileAnsi;
    PCSTR cabPathAnsi;

    cabHandle = (PFDI_CAB_HANDLEW)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotificationW = CabNotificationW;
    cabData.VerifyMode = VerifyMode;

    cabFileAnsi = ConvertWtoA (cabHandle->CabFile);
    cabPathAnsi = ConvertWtoA (cabHandle->CabPath);

    result = FDICopy (
                cabHandle->FdiHandle,
                (PSTR) cabFileAnsi,
                (PSTR) cabPathAnsi,
                0,
                pCabNotificationW,
                NULL,
                (PVOID)(&cabData)
                );

    FreeConvertedStr (cabFileAnsi);
    FreeConvertedStr (cabPathAnsi);

    return result;
}


BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,                     OPTIONAL
    IN      PCABNOTIFICATIONW CabNotificationW      OPTIONAL
    )
{
    return pCabExtractAllFilesExWorkerW (CabHandle, ExtractPath, CabNotificationW, FALSE);
}

BOOL
CabVerifyCabinet (
    IN      OCABHANDLE CabHandle
    )
{
    return pCabExtractAllFilesExWorkerW (CabHandle, NULL, NULL, TRUE);

}

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;

    cabHandle = (PFDI_CAB_HANDLEA) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringA (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;

    cabHandle = (PFDI_CAB_HANDLEW) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringW (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\expandit.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    expandit.c

Abstract:

    Expandit provides routines to expand a given file as much as possible.
    It is useful for expanding cabinet files and executable files that may
    themselves contain cabinet files.

Author:

    Marc R. Whitten (marcw) 30-Jul-1998

Revision History:




--*/

#include "pch.h"
#include "migutilp.h"

UINT g_DirSequencer = 0;

BOOL
ExpandAllFilesW (
    IN PCWSTR FileDir,
    IN PCWSTR TempDir
    );

BOOL
ExpandFileW (
    IN PCWSTR FullPath,
    IN PCWSTR TempDir
    );

PWSTR
pGetExpandName (
    VOID
    )
{
    static WCHAR rName[MAX_WCHAR_PATH];

    g_DirSequencer++;
    swprintf (rName, L"EXP%04x", g_DirSequencer);

    return rName;
}

BOOL
pIsFileType (
    IN      PCWSTR FullPath,
    IN      PCWSTR TypePattern
    )
{
    PCWSTR p;

    p = GetFileExtensionFromPathW (FullPath);

    return p && IsPatternMatchW (TypePattern, p);
}


BOOL CALLBACK
pResNameCallback (
    IN      HANDLE hModule,   // module handle
    IN      LPCWSTR lpszType,  // pointer to resource type
    IN      LPWSTR lpszName,  // pointer to resource name
    IN      LONG lParam       // application-defined parameter
    )
{
    HRSRC hResource;
    DWORD size;
    HGLOBAL hGlobal;
    HANDLE hFile;
    PWSTR fileName;
    PWSTR dirName;
    PVOID srcBytes;
    UINT dontCare;
    BOOL rSuccess=TRUE;

    hResource = FindResourceW (hModule, lpszName, lpszType);

    if (hResource) {

        size = SizeofResource (hModule, hResource);

        if (size) {

            hGlobal = LoadResource (hModule, hResource);

            if (hGlobal) {

                srcBytes = LockResource (hGlobal);
                if (srcBytes) {

                    //
                    // Ok, lets see if this is a cabinet file..
                    //
                    if (size < 4 || *((PDWORD)srcBytes) != 0x4643534D) {
                        //
                        // Not a cabinet file.
                        //
                        return TRUE;
                    }

                    dirName = JoinPathsW ((PWSTR) lParam, pGetExpandName ());
                    fileName = JoinPathsW (dirName, L"temp.cab");

                    hFile = CreateFileW (
                        fileName,
                        GENERIC_READ | GENERIC_WRITE,
                        0, NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

                    if (hFile == INVALID_HANDLE_VALUE) {
                        DEBUGMSGW ((DBG_ERROR, "Unable to create file %s.", fileName));
                        return FALSE;
                    }

                    if (!WriteFile (hFile, srcBytes, size, &dontCare, NULL)) {
                        DEBUGMSGW ((DBG_ERROR, "Cannot write to file %s", fileName));
                        return FALSE;
                    }

                    CloseHandle (hFile);

                    //
                    // Expand this file.
                    //
                    rSuccess = ExpandFileW (fileName, dirName);
                    FreePathStringW (dirName);
                    FreePathStringW (fileName);

                }
            }
        }
    }

    return rSuccess;
}


BOOL CALLBACK
pResTypeCallback (
    IN      HANDLE hModule,  // resource-module handle
    IN      PWSTR lpszType,  // pointer to resource type
    IN      LONG lParam      // application-defined parameter
    )
{

    //
    // Oh what a pain. All of the RT types are #defined without A/Ws.
    // We need to converte the string to ansi, just to do this comparison.
    //

    PCSTR aString = ConvertWtoA (lpszType);


    if ((aString != RT_ACCELERATOR  ) &&
        (aString != RT_ANICURSOR    ) &&
        (aString != RT_ANIICON      ) &&
        (aString != RT_BITMAP       ) &&
        (aString != RT_CURSOR       ) &&
        (aString != RT_DIALOG       ) &&
        (aString != RT_FONT         ) &&
        (aString != RT_FONTDIR      ) &&
        (aString != RT_GROUP_CURSOR ) &&
        (aString != RT_GROUP_ICON   ) &&
        (aString != RT_HTML         ) &&
        (aString != RT_ICON         ) &&
        (aString != RT_MENU         ) &&
        (aString != RT_MESSAGETABLE ) &&
        (aString != RT_PLUGPLAY     ) &&
        (aString != RT_STRING       ) &&
        (aString != RT_VERSION      ) &&
        (aString != RT_VXD          ) &&
        (aString != RT_HTML         )
        ) {

        //
        // Unknown type. We assume it is a cabinet file and try to extract it.
        // Since it may not be a cabinet file, we eat the error.
        //
        if (!EnumResourceNamesW (hModule, lpszType, pResNameCallback, lParam)) {
            DEBUGMSGW ((DBG_ERROR, "Error enumerating resource names."));
        }
    }

    FreeConvertedStr (aString);

    return TRUE;
}




UINT CALLBACK
pCabFileCallback (
    IN      PVOID Context,          //context used by the callback routine
    IN      UINT Notification,      //notification sent to callback routine
    IN      UINT Param1,            //additional notification information
    IN      UINT Param2             //additional notification information
    )
{
    PCWSTR tempDir  = Context;
    PCWSTR fileName = (PCWSTR)Param2 ;
    PFILE_IN_CABINET_INFO_W fileInfo = (PFILE_IN_CABINET_INFO_W)Param1;
    PCWSTR fromPtr, toPtr;
    WCHAR tempStr [MEMDB_MAX];

    if (Notification == SPFILENOTIFY_FILEINCABINET) {

        if (toPtr = wcschr (fileInfo->NameInCabinet, L'\\')) {

            StringCopyW (fileInfo->FullTargetName, tempDir);
            fromPtr = fileInfo->NameInCabinet;

            while (toPtr) {

                StringCopyABW (tempStr, fromPtr, toPtr);
                StringCatW (fileInfo->FullTargetName, L"\\");
                StringCatW (fileInfo->FullTargetName, tempStr);
                CreateDirectoryW (fileInfo->FullTargetName, NULL);
                toPtr++;
                fromPtr = toPtr;
                toPtr   = wcschr (toPtr, L'\\');
            }
        }

        swprintf (fileInfo->FullTargetName, L"%ws\\%ws", tempDir, fileInfo->NameInCabinet);
        return FILEOP_DOIT;
    }

    return NO_ERROR;
}

BOOL
ExpandFileW (
    IN PCWSTR FullPath,
    IN PCWSTR TempDir
    )
{
    BOOL rSuccess = TRUE;
    PWSTR dirName = NULL;
    PWSTR fileName = NULL;
    HANDLE exeModule = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CHAR aName[MAX_MBCHAR_PATH];
    PCWSTR uName = NULL;
    UINT bytesRead = 0;


    if (pIsFileType (FullPath, L"CAB")) {
        //
        // Expand this cabinet file and recursively handle all of its files.
        //
        dirName = JoinPathsW (TempDir, pGetExpandName());
        __try {

            if (!CreateDirectoryW (dirName, NULL)) {
                DEBUGMSGW ((DBG_ERROR, "ExpandFile: Cannot create directory %s", dirName));
                rSuccess = FALSE;
                __leave;
            }

            //
            // Expand the cabinet file into the temporary directory.
            //
            SetLastError (ERROR_SUCCESS);
            if (!SetupIterateCabinetW (FullPath, 0, pCabFileCallback, dirName)) {
                DEBUGMSGW ((DBG_ERROR, "ExpandFile: SetupIterateCabinet failed for file %s.", FullPath));
                rSuccess = FALSE;
                __leave;
            }

            //
            // Now, make sure all of the files in this SubDirectory are expanded.
            //
            rSuccess = ExpandAllFilesW (dirName, dirName);
        }
        __finally {

            FreePathStringW (dirName);
        }

    } else if (pIsFileType (FullPath, L"EXE")) {

        //
        // This is an executable file. Check to make sure that they aren't any cabinet files hanging out
        // inside of it.
        //
        exeModule = LoadLibraryExW (FullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (!exeModule) {
            DEBUGMSGW ((DBG_ERROR, "ExpandFile: LoadLibraryEx failed for %s.", FullPath));
            return FALSE;
        }

        if (!EnumResourceTypesW (exeModule, pResTypeCallback, (LONG) TempDir)) {
            DEBUGMSGW ((DBG_ERROR, "ExpandFile: EnumResourceTypes failed for %s.", FullPath));
            FreeLibrary (exeModule);
            return FALSE;
        }



    } else if (pIsFileType (FullPath, L"*_")) {

        //
        // Compressed file. Decompress it.
        //
        hFile = CreateFileW (
            FullPath,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );


        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUGMSGW ((DBG_ERROR, "ExpandFile: Unable to open file %s.", FullPath));
            return FALSE;
        }

        __try {

            //
            // The real file name is stored at 0x3c.
            //
            if (0xffffffff == SetFilePointer (hFile, 0x3c, NULL, FILE_BEGIN)) {
                DEBUGMSGW ((DBG_ERROR, "ExpandFile: Cannot get real file name for compressed file %s.", FullPath));
               rSuccess = FALSE;
               __leave;
            }

            if (!ReadFile (hFile, aName, sizeof(aName), &bytesRead, NULL)) {
                DEBUGMSG ((DBG_ERROR, "ExpandFile: Cannot read real file name for compressed file %s.", FullPath));
                rSuccess = FALSE;
                __leave;
            }

            if (bytesRead >= ByteCountW (FullPath)) {

                uName = ConvertAtoW (aName);

                if (StringIMatchTcharCountW (FullPath, uName, TcharCountW (FullPath) - 1)) {

                    dirName = JoinPathsW (TempDir, pGetExpandName());
                    fileName = JoinPathsW (dirName, uName);

                    //
                    // Create directory for this file and decompress it.
                    //
                    if (!CreateDirectoryW (dirName, NULL)) {
                        DEBUGMSGW ((DBG_ERROR, "ExpandFile: Cannot create directory %s", dirName));
                        rSuccess = FALSE;
                        __leave;
                    }

                    if (SetupDecompressOrCopyFileW (FullPath, fileName, NULL) != ERROR_SUCCESS) {
                        DEBUGMSGW ((DBG_ERROR, "ExpandFile: Cannot decompreses %s => %s.", FullPath, fileName));
                        rSuccess = FALSE;
                        __leave;
                    }

                    //
                    // Now, run expand recursively on the decompressed file. Could be a CAB or an EXE.
                    //
                    rSuccess = ExpandFileW (fileName, dirName);
                }

            }

        }
        __finally {

            CloseHandle (hFile);
            FreePathStringW (dirName);
            FreePathStringW (fileName);

        }

    }

    return rSuccess;
}

BOOL
ExpandAllFilesW (
    IN PCWSTR FileDir,
    IN PCWSTR TempDir
    )
{
    BOOL rSuccess = TRUE;
    TREE_ENUMW e;

    if (EnumFirstFileInTreeW (&e, FileDir, L"*", FALSE)) {
        do {

            if (!e.Directory) {
                rSuccess &= ExpandFileW (e.FullPath, TempDir);
            }

        } while (EnumNextFileInTreeW (&e));
    }

    DEBUGMSGW_IF ((!rSuccess,DBG_ERROR, "ExpandAllFilesW: One or more errors occurred while expanding all files in %s.", FileDir));

    return rSuccess;
}


BOOL
ExpandFileA (
    IN PCSTR FullPath,
    IN PCSTR TempDir
    )
{

    PCWSTR wFullPath = NULL;
    PCWSTR wTempDir = NULL;
    BOOL rSuccess = TRUE;

    MYASSERT(FullPath && TempDir);

    //
    // Convert args and call W version.
    //

    wFullPath = ConvertAtoW (FullPath);
    wTempDir = ConvertAtoW (TempDir);

    MYASSERT (wFullPath && wTempDir);

    rSuccess = ExpandFileW (wFullPath, wTempDir);

    FreeConvertedStr (wFullPath);
    FreeConvertedStr (wTempDir);

    return rSuccess;
}


BOOL
ExpandAllFilesA (
    IN PCSTR FileDir,
    IN PCSTR TempDir
    )
{

    PCWSTR wFileDir = NULL;
    PCWSTR wTempDir = NULL;
    BOOL rSuccess = TRUE;

    MYASSERT(FileDir && TempDir);

    //
    // Convert args and call W version.
    //

    wFileDir = ConvertAtoW (FileDir);
    wTempDir = ConvertAtoW (TempDir);

    MYASSERT (wFileDir && wTempDir);

    rSuccess = ExpandAllFilesW (wFileDir, wTempDir);

    FreeConvertedStr (wFileDir);
    FreeConvertedStr (wTempDir);

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\cache.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    Implements a cache mechanism to speed up OpenRegKeyStr.

Author:

    Jim Schmidt (jimschm)  11-Sep-2000

Revisions:

    <alias>     <date>      <comments>

--*/

#include "pch.h"
#include "regp.h"

#define DBG_REG     "Reg"

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    BYTE KeyString[];
} REGKEYCACHE, *PREGKEYCACHE;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    CHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMA, *PWORKITEMA;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    WCHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMW, *PWORKITEMW;

GROWLIST g_KeyCache = GROWLIST_INIT;
UINT g_MaxCacheCount = 0;
UINT g_CacheAddPos;
CHAR g_LastParent[MAX_REGISTRY_KEY];
UINT g_LastParentBytes;
UINT g_LastParentUse;
WCHAR g_LastParentW[MAX_REGISTRY_KEY];
UINT g_LastParentBytesW;
UINT g_LastParentUseW;

BOOL
pRemoveItemFromCache (
    IN      UINT Item
    );

//
// Implementation
//

VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    )
{
    if (InitialCacheSize > 64) {
        InitialCacheSize = 64;
    }

    g_MaxCacheCount = InitialCacheSize;
    g_CacheAddPos = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


VOID
RegTerminateCache (
    VOID
    )
{
    UINT u;
    UINT count;

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        pRemoveItemFromCache (u);
    }

    FreeGrowList (&g_KeyCache);
    g_MaxCacheCount = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


BOOL
pRemoveItemFromCache (
    IN      UINT Item
    )
{
    PREGKEYCACHE cacheItem;

    cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, Item);

    if (!cacheItem) {
        return TRUE;
    }

    if (cacheItem->RefCount == 0) {

        while (cacheItem->ClosesNeeded) {
            CloseRegKeyWorker (cacheItem->Key);
            cacheItem->ClosesNeeded--;
        }

        return TRUE;

    } else {
        return FALSE;
    }
}


VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (CHAR))) {
        return;
    }

    if (g_LastParentUse && g_LastParentUse < 3 && g_LastParentBytes == byteCount) {

        StringCopyABA (lowerStr, KeyString, StringEnd);
        CharLowerA (lowerStr);

        if (StringMatchA (g_LastParent, lowerStr)) {
            g_LastParentUse++;

            if (g_LastParentUse == 3) {
                //
                // Stimulate the cache
                //
                rootKey = ConvertRootStringToKeyA (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {
#ifdef DEBUG
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheA (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABA (g_LastParent, KeyString, StringEnd);
    CharLowerA (g_LastParent);
    g_LastParentBytes = byteCount;

    g_LastParentUse = 1;
}


HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR KeyEnd,       OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCSTR end;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    count = GrowListGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyA (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABA (lowerStr, KeyString, KeyEnd);
    }

    CharLowerA (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (!cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchA ((PCSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMA workItem;
    PCSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && !cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                DEBUGMSG ((DBG_REG, "Updating empty-named key %s", KeyString));

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyA (workItem.KeyString, KeyString);
                CharLowerA (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (CHAR);
                GrowListSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = FALSE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyA (workItem.KeyString, KeyString);
    CharLowerA (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (CHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixA ((PCSTR) lastAddItem->KeyString, (PCSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GrowListSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}


BOOL
RegDecrementRefCount (
    IN      HKEY Key
    )
{
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    if (!g_MaxCacheCount) {
        return FALSE;
    }

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);
        if (cacheItem->Key == Key) {
            if (cacheItem->RefCount == 0) {

                //
                // The caller is tried to close the key more times than what
                // it was opened.
                //

                if (cacheItem->Unicode) {
                    DEBUGMSGW ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                } else {
                    DEBUGMSGA ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                }
            } else {
                cacheItem->RefCount--;
            }

            //
            // Return TRUE to postpone the close
            //

            return TRUE;
        }
    }

    return FALSE;
}


VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (WCHAR))) {
        return;
    }

    if (g_LastParentUseW && g_LastParentUseW < 3 && g_LastParentBytesW == byteCount) {

        StringCopyABW (lowerStr, KeyString, StringEnd);
        CharLowerW (lowerStr);

        if (StringMatchW (g_LastParentW, lowerStr)) {
            g_LastParentUseW++;

            if (g_LastParentUseW == 3) {
                //
                // Stimulate the cache
                //

                rootKey = ConvertRootStringToKeyW (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {

#ifdef DEBUG
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheW (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABW (g_LastParentW, KeyString, StringEnd);
    CharLowerW (g_LastParentW);
    g_LastParentBytesW = byteCount;

    g_LastParentUseW = 1;
}


HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR KeyEnd,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCWSTR end;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    count = GrowListGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyW (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABW (lowerStr, KeyString, KeyEnd);
    }

    CharLowerW (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchW ((PCWSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMW workItem;
    PCWSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyW (workItem.KeyString, KeyString);
                CharLowerW (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (WCHAR);
                GrowListSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = TRUE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyW (workItem.KeyString, KeyString);
    CharLowerW (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (WCHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (!cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixW ((PCWSTR) lastAddItem->KeyString, (PCWSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GrowListSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\beta.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    beta.c

Abstract:

    Logging for beta data gathering.

Author:

    Jim Schmidt (jimschm) 10-Jun-1998

Revision History:

    Jim Schmidt (jimschm)   04-Aug-1998     Config log options

--*/

#include "pch.h"
#include "migutilp.h"
#include "beta.h"


#define BETA_INDENT        12

static HANDLE g_BetaLog = INVALID_HANDLE_VALUE;
static HANDLE g_BetaLogHandle = INVALID_HANDLE_VALUE;
static HANDLE g_ConfigLogHandle = INVALID_HANDLE_VALUE;
static BOOL g_Direct = FALSE;


PCSTR
pBetaFindEndOfLine (
    PCSTR Line,
    INT Indent
    )
{
    int Col = 0;
    PCSTR LastSpace = NULL;

    Indent = 79 - Indent;

    while (*Line && Col < Indent) {
        if (*Line == ' ') {
            LastSpace = Line;
        }

        if (*Line == '\n') {
            LastSpace = Line;
            break;
        }

        Col++;
        Line++;
    }

    if (*Line && !LastSpace) {
        LastSpace = Line;
    }

    if (!(*Line)) {
        return Line;
    }

    return LastSpace + 1;
}


VOID
pBetaPadTitle (
    PSTR  Title,
    INT   Indent
    )
{
    INT i;
    PSTR p;

    p = strchr (Title, 0);
    i = strlen (Title);
    while (i < Indent) {
        *p = ' ';
        p++;
        i++;
    }

    *p = 0;
}


VOID
pBetaHangingIndent (
    IN      PCSTR UnindentedText,
    IN      PSTR Buffer,
    IN      INT Indent,
    OUT     BOOL *Multiline             OPTIONAL
    )
{
    CHAR IndentedStr[4096];
    PCSTR p, s;
    PSTR d;
    INT i;

    if (Multiline) {
        *Multiline = FALSE;
    }

    p = pBetaFindEndOfLine (UnindentedText, Indent);

    s = UnindentedText;
    d = IndentedStr;

    while (TRUE) {
        // Copy line from source to dest
        while (s < p) {
            if (*s == '\r' && *(s + 1) == '\n') {
                s++;
            }

            if (*s == '\n') {
                *d++ = '\r';
            }

            *d++ = *s++;
        }

        // If another line, prepare an indent
        if (*p) {

            if (Multiline) {
                *Multiline = TRUE;
            }

            if (*(p - 1) != '\n') {
                *d++ = '\r';
                *d++ = '\n';
            }

            for (i = 0 ; i < Indent ; i++) {
                *d = ' ';
                d++;
            }
        } else {
            break;
        }

        // Find end of next line
        p = pBetaFindEndOfLine (p, Indent);
    }

    *d = 0;

    strcpy (Buffer, IndentedStr);
}


VOID
pSaveMessageToBetaLog (
    IN      PCSTR Category,
    IN      PCSTR Text
    )
{
    CHAR PaddedCategory[256];
    CHAR IndentedText[4096];
    BOOL Multiline;

    if (g_Direct) {
        WriteFileStringA (g_BetaLog, "\r\n");
        g_Direct = FALSE;
    }

    strcpy (PaddedCategory, Category);

    pBetaPadTitle (PaddedCategory, BETA_INDENT);
    WriteFileStringA (g_BetaLog, PaddedCategory);

    pBetaHangingIndent (Text, IndentedText, BETA_INDENT, &Multiline);
    WriteFileStringA (g_BetaLog, IndentedText);

    if (Multiline) {
        WriteFileStringA (g_BetaLog, "\r\n\r\n");
    } else {
        WriteFileStringA (g_BetaLog, "\r\n");
    }

    DEBUGMSGA ((Category, "%s", Text));
}


VOID
_cdecl
BetaMessageA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    )

/*++

Routine Description:

  BetaMessageA formats the specified string and saves the message to the file
  beta.log.  The message is formatted with a category in the left column and
  text in the right.

Arguments:

  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to ANSI.

Return Value:

  none

--*/

{
    va_list args;
    CHAR Message[4096];

    PushError();
    va_start (args, FormatStr);

    vsprintf (Message, FormatStr, args);
    pSaveMessageToBetaLog (Category, Message);

    va_end (args);
    PopError();
}


VOID
_cdecl
BetaCondMessageA (
    IN      BOOL Expr,
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    )

/*++

Routine Description:

  BetaCondMessageA formats the specified string and saves the message to the
  file beta.log, if Expr is TRUE.  The message is formatted with a category
  in the left column and text in the right.

Arguments:

  Expr      - Specifies non-zero if the message is to be added to the log, or
              zero if not.
  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to ANSI.

Return Value:

  none

--*/

{
    va_list args;
    CHAR Message[4096];

    if (!Expr) {
        return;
    }

    PushError();
    va_start (args, FormatStr);

    vsprintf (Message, FormatStr, args);
    pSaveMessageToBetaLog (Category, Message);

    va_end (args);
    PopError();
}


VOID
_cdecl
BetaErrorMessageA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    )

/*++

Routine Description:

  BetaErrorMessageA formats the specified string and saves the message to the
  file beta.log.  The message is formatted with a category in the left column
  and text in the right.

  In addition to the message, the current error code is recorded.

Arguments:

  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to ANSI.

Return Value:

  none

--*/

{
    va_list args;
    CHAR Message[4096];
    LONG rc;

    rc = GetLastError();
    va_start (args, FormatStr);

    vsprintf (Message, FormatStr, args);
    if (rc < 10) {
        sprintf (strchr (Message, 0), " [GLE=%u]", rc);
    } else {
        sprintf (strchr (Message, 0), " [GLE=%u (0%Xh)]", rc, rc);
    }

    pSaveMessageToBetaLog (Category, Message);

    va_end (args);
    SetLastError (rc);
}


VOID
_cdecl
BetaMessageW (
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    )

/*++

Routine Description:

  BetaMessageW formats the specified string and saves the message to the file
  beta.log.  The message is formatted with a category in the left column and
  text in the right.

Arguments:

  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to UNICODE.

Return Value:

  none

--*/

{
    va_list args;
    WCHAR UnicodeMessage[4096];
    PCWSTR UnicodeFormatStr;
    PCSTR AnsiMessage;

    PushError();

    UnicodeFormatStr = ConvertAtoW (AnsiFormatStr);

    va_start (args, AnsiFormatStr);

    vswprintf (UnicodeMessage, UnicodeFormatStr, args);
    FreeConvertedStr (UnicodeFormatStr);

    AnsiMessage = ConvertWtoA (UnicodeMessage);
    pSaveMessageToBetaLog (AnsiCategory, AnsiMessage);

    FreeConvertedStr (AnsiMessage);

    va_end (args);
    PopError();
}


VOID
_cdecl
BetaCondMessageW (
    IN      BOOL Expr,
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    )

/*++

Routine Description:

  BetaCondMessageW formats the specified string and saves the message to the
  file beta.log, if Expr is TRUE.  The message is formatted with a category
  in the left column and text in the right.

Arguments:

  Expr      - Specifies non-zero if the message is to be added to the log, or
              zero if not.
  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to UNICODE.

Return Value:

  none

--*/

{
    va_list args;
    WCHAR UnicodeMessage[4096];
    PCWSTR UnicodeFormatStr;
    PCSTR AnsiMessage;

    if (!Expr) {
        return;
    }

    PushError();

    UnicodeFormatStr = ConvertAtoW (AnsiFormatStr);

    va_start (args, AnsiFormatStr);

    vswprintf (UnicodeMessage, UnicodeFormatStr, args);
    FreeConvertedStr (UnicodeFormatStr);

    AnsiMessage = ConvertWtoA (UnicodeMessage);
    pSaveMessageToBetaLog (AnsiCategory, AnsiMessage);

    FreeConvertedStr (AnsiMessage);

    va_end (args);
    PopError();
}


VOID
_cdecl
BetaErrorMessageW (
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    )

/*++

Routine Description:

  BetaErrorMessageW formats the specified string and saves the message to the
  file beta.log.  The message is formatted with a category in the left column
  and text in the right.

  In addition to the message, the current error code is recorded.

Arguments:

  Category  - Specifies the short text classifying the message
  FormatStr - Specifies the sprintf-style format string, in ANSI.
  ...       - Specifies args for the format string, strings default to UNICODE.

Return Value:

  none

--*/

{
    va_list args;
    WCHAR UnicodeMessage[4096];
    PCWSTR UnicodeFormatStr;
    PCSTR AnsiMessage;
    LONG rc;

    rc = GetLastError();

    UnicodeFormatStr = ConvertAtoW (AnsiFormatStr);

    va_start (args, AnsiFormatStr);

    vswprintf (UnicodeMessage, UnicodeFormatStr, args);
    if (rc < 10) {
        swprintf (wcschr (UnicodeMessage, 0), L" [GLE=%u]", rc);
    } else {
        swprintf (wcschr (UnicodeMessage, 0), L" [GLE=%u (0%Xh)]", rc, rc);
    }

    FreeConvertedStr (UnicodeFormatStr);

    AnsiMessage = ConvertWtoA (UnicodeMessage);
    pSaveMessageToBetaLog (AnsiCategory, AnsiMessage);

    FreeConvertedStr (AnsiMessage);

    va_end (args);
    SetLastError (rc);
}


VOID
BetaCategory (
    IN      PCSTR Category
    )
{
    WriteFileStringA (g_BetaLog, "\r\n");
    g_Direct = FALSE;

    WriteFileStringA (g_BetaLog, Category);
    WriteFileStringA (g_BetaLog, ":\r\n\r\n");
}


VOID
BetaLogDirectA (
    IN      PCSTR Text
    )
{
    g_Direct = TRUE;
    WriteFileStringA (g_BetaLog, Text);
}


VOID
BetaLogDirectW (
    IN      PCWSTR Text
    )
{
    PCSTR AnsiText;

    AnsiText = ConvertWtoA (Text);
    if (AnsiText) {
        g_Direct = TRUE;
        WriteFileStringA (g_BetaLog, AnsiText);

        FreeConvertedStr (AnsiText);
    }
}


VOID
BetaLogLineA (
    IN      PCSTR FormatStr,
            ...                             // ANSI args
    )
{
    va_list args;
    CHAR Message[4096];

    PushError();

    __try {
        va_start (args, FormatStr);

        vsprintf (Message, FormatStr, args);

        g_Direct = TRUE;
        WriteFileStringA (g_BetaLog, Message);
        WriteFileStringA (g_BetaLog, "\r\n");

        va_end (args);
    }
    __except (TRUE) {
    }

    PopError();
}


VOID
BetaLogLineW (
    IN      PCSTR AnsiFormatStr,
            ...                             // UNICODE args
    )
{
    va_list args;
    WCHAR UnicodeMessage[4096];
    PCWSTR UnicodeFormatStr;
    PCSTR AnsiMessage;

    PushError();

    __try {
        UnicodeFormatStr = ConvertAtoW (AnsiFormatStr);

        va_start (args, AnsiFormatStr);

        vswprintf (UnicodeMessage, UnicodeFormatStr, args);
        FreeConvertedStr (UnicodeFormatStr);

        AnsiMessage = ConvertWtoA (UnicodeMessage);

        g_Direct = TRUE;
        WriteFileStringA (g_BetaLog, AnsiMessage);
        WriteFileStringA (g_BetaLog, "\r\n");

        FreeConvertedStr (AnsiMessage);

        va_end (args);
    }
    __except (TRUE) {
    }

    PopError();
}


VOID
BetaNoWrapA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...
    )
{
    va_list args;
    CHAR Message[4096];

    PushError();

    BetaCategory (Category);

    va_start (args, FormatStr);

    vsprintf (Message, FormatStr, args);

    g_Direct = TRUE;
    WriteFileStringA (g_BetaLog, Message);
    WriteFileStringA (g_BetaLog, "\r\n");

    va_end (args);
    PopError();
}


VOID
BetaNoWrapW (
    IN      PCSTR Category,
    IN      PCSTR AnsiFormatStr,
            ...
    )
{
    va_list args;
    WCHAR UnicodeMessage[4096];
    PCWSTR UnicodeFormatStr;
    PCSTR AnsiMessage;

    PushError();

    BetaCategory (Category);

    UnicodeFormatStr = ConvertAtoW (AnsiFormatStr);

    va_start (args, AnsiFormatStr);

    vswprintf (UnicodeMessage, UnicodeFormatStr, args);
    FreeConvertedStr (UnicodeFormatStr);

    AnsiMessage = ConvertWtoA (UnicodeMessage);

    g_Direct = TRUE;
    WriteFileStringA (g_BetaLog, AnsiMessage);
    WriteFileStringA (g_BetaLog, "\r\n");

    FreeConvertedStr (AnsiMessage);

    va_end (args);
    PopError();
}


VOID
InitBetaLog (
    BOOL EraseExistingLog
    )
{
    CHAR LogPath[MAX_PATH];

    CloseBetaLog();

    GetWindowsDirectory (LogPath, MAX_PATH);
    strcat (LogPath, "\\beta-upg.log");

    g_BetaLogHandle = CreateFile (
                            LogPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            EraseExistingLog ? CREATE_ALWAYS : OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if (g_BetaLogHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WHOOPS, "Can't open %s", LogPath));
    } else {
        SetFilePointer (g_BetaLogHandle, 0, NULL, FILE_END);
    }

    GetWindowsDirectory (LogPath, MAX_PATH);
    strcat (LogPath, "\\config.dmp");

    g_ConfigLogHandle = CreateFile (
                            LogPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            EraseExistingLog ? CREATE_ALWAYS : OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if (g_ConfigLogHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WHOOPS, "Can't open %s", LogPath));
    } else {
        SetFilePointer (g_ConfigLogHandle, 0, NULL, FILE_END);
    }

    g_BetaLog = g_BetaLogHandle;
}


VOID
SelectBetaLog (
    BOOL UseBetaLog
    )
{
    if (!UseBetaLog) {
        g_BetaLog = g_ConfigLogHandle;
    } else {
        g_BetaLog = g_BetaLogHandle;
    }
}


VOID
CloseBetaLog (
    VOID
    )
{
    if (g_BetaLogHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (g_BetaLogHandle);
        g_BetaLogHandle = INVALID_HANDLE_VALUE;
    }

    if (g_ConfigLogHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (g_ConfigLogHandle);
        g_ConfigLogHandle = INVALID_HANDLE_VALUE;
    }

    g_BetaLog = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\debug.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug helpers and memory allocation wrappers

Author:

    Jim Schmidt (jimschm) 13-Aug-1996

Revision History:

    Marc R. Whitten (marcw) 27-May-1997
        Added DEBUGLOGTIME() functions and support for the /#U:DOLOG cmd line option.
    Ovidiu Temereanca (ovidiut) 06-Nov-1998
        Took out log related functions and put them in log.c file
--*/

#include "pch.h"
#include "migutilp.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")

#define PCVOID LPCVOID

typedef DWORD ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

#define TRACK_BUCKETS   1501

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];

#define BUCKET_ITEMS_PER_POOL   8192

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;

PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

typedef struct _tagTRACKSTRUCT {
    DWORD Signature;
    PCSTR File;
    DWORD Line;
    DWORD Size;
    PSTR Comment;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;
} TRACKSTRUCT, *PTRACKSTRUCT;

PTRACKSTRUCT TrackHead = NULL;
#define TRACK_SIGNATURE     0x30405060

DWORD
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );





//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//

PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
INT g_UseCount;
UINT g_DisableTrackComment = 0;

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}

DWORD
SetTrackComment (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];
    static CHAR FileCopy[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s (%s line %u)", Msg, File, Line);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    StringCopyA (FileCopy, File);
    g_TrackFile = FileCopy;
    g_TrackLine = Line;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}

DWORD
ClrTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment=NULL;
    }

    return 0;
}


VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    DWORD Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    p->File      = File;
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = TrackHead;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (TrackHead) {
        TrackHead->PrevAlloc = p;
    }

    TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
}

VOID
pWriteTrackLog (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "c:\\memtrack.log";

    if (!TrackHead) {
        return;
    }

    if (ISPC98()) {
        GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
        memtrackLogPath[0] = TempPath[0];
    }
    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {
        Count = 0;
        __try {
            for (p = TrackHead ; p ; p = p->NextAlloc) {
                Count++;
                __try {
                    if (p->Comment) {
                        wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                    } else {
                        wsprintfA (LineBuf, "%s line %u\r\n\r\n", p->File, p->Line);
                    }
                }
                __except (TRUE) {
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", p);
                    BadMem = TRUE;
                }
                WriteFile (File, LineBuf, ByteCountA (LineBuf), &DontCare, NULL);

                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }

        wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n", Count, Count == 1 ? "":"s");
        WriteFile (File, LineBuf, ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}

typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;

GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;

VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}

VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = GROWBUF_INIT;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);

        p = (PSTR) RealGrowBuffer (&Msg, Bytes);
        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) RealGrowBuffer (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        FreeGrowBuffer (&Msg);
    }

    FreeGrowBuffer (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    DWORD Hash;

    Hash = (DWORD) (Type << 16) ^ (DWORD) Ptr;
    return Hash % TRACK_BUCKETS;
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) RealGrowBuffer (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;

        pTrackHashTableInsert (g_AllocationList.Buf, (PBYTE) Item - g_AllocationList.Buf);
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        Item->FileName = NULL;
        Item->Type = -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}



//
// File and Line settings
//

static PCSTR g_File;
static DWORD  g_Line;

void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    strcat (Msg2, Msg);
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}


#define INVALID_PTR     0xffffffff


DWORD
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    DWORD rc;

    EnterCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveCriticalSection (&g_MemAllocCs);

    return rc;
}


DWORD
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    DWORD dwSize;
    PCVOID RealPtr;
    DWORD SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x.  This address is not valid.",
            CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return INVALID_PTR;
    }

    dwSize = HeapSize (hHeap, 0, RealPtr);
    if (dwSize == 0xffffffff) {
        CHAR BadPtrMsg[256];

        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x.  "
                "This address is not the start of a memory block.",
            CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return INVALID_PTR;
    }

    return dwSize;
}



//
// Heap debug statistics
//

static DWORD g_dwTotalBytesAllocated = 0;
static DWORD g_dwMaxBytesInUse = 0;
static DWORD g_dwHeapAllocs = 0;
static DWORD g_dwHeapReAllocs = 0;
static DWORD g_dwHeapFrees = 0;
static DWORD g_dwHeapAllocFails = 0;
static DWORD g_dwHeapReAllocFails = 0;
static DWORD g_dwHeapFreeFails = 0;
#define TRAIL_SIG       0x708aa210

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    DWORD BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD TrackStructSize;
    DWORD OrgError;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapAllocFails++;
            __leave;
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_dwHeapAllocs++;
            g_dwTotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_dwMaxBytesInUse = max (g_dwMaxBytesInUse, g_dwTotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_dwHeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    DWORD BytesToAlloc
    )
{
    DWORD dwLastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD OrgError;
    DWORD TrackStructSize;
    DWORD OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapReAllocFails++;
            __leave;
        }

        dwLastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (dwLastSize == INVALID_PTR) {
            g_dwHeapReAllocFails++;
            __leave;
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_dwHeapReAllocs++;
            g_dwTotalBytesAllocated -= dwLastSize;
            g_dwTotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_dwMaxBytesInUse = max (g_dwMaxBytesInUse, g_dwTotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_dwHeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    DWORD dwSize;
    PCVOID RealPtr;
    DWORD SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapFreeFails++;
            __leave;
        }

        dwSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (dwSize == INVALID_PTR) {
            g_dwHeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            wsprintf (BadPtrMsg,
                      "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                      "HeapFree() failed.",
                      CallerPtr, Flags);

            HeapCallFailed (BadPtrMsg, File, Line);
            g_dwHeapFreeFails++;
            __leave;
        }

        g_dwHeapFrees++;
        if (g_dwTotalBytesAllocated < dwSize) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_dwTotalBytesAllocated = 0;
        } else {
            g_dwTotalBytesAllocated -= dwSize;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return Result;

}


VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    pWriteTrackLog();

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_dwTotalBytesAllocated,
               g_dwMaxBytesInUse,
               g_dwHeapAllocs,
               g_dwHeapReAllocs,
               g_dwHeapFrees
               );

    if (g_dwHeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_dwHeapAllocFails);
    }
    if (g_dwHeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_dwHeapReAllocFails);
    }
    if (g_dwHeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_dwHeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#else  // i.e. ifndef CONSOLE

#if 0
    if (0) {
        PROCESS_HEAP_ENTRY he;
        CHAR FlagMsg[256];

        ZeroMemory (&he, sizeof (he));

        while (HeapWalk (g_hHeap, &he)) {
            FlagMsg[0] = 0;
            if (he.wFlags & PROCESS_HEAP_REGION) {
                strcpy (FlagMsg, "PROCESS_HEAP_REGION");
            }
            if (he.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_UNCOMMITTED_RANGE");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_BUSY");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_MOVEABLE");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_DDESHARE");
            }

            wsprintfA (OutputMsg,
                       "Address of Data: %Xh\n"
                       "Size of Data: %u byte%s\n"
                       "OS Overhead: %u byte%s\n"
                       "Region index: %u\n"
                       "Flags: %s\n\n"
                       "Examine Data?",
                       he.lpData,
                       he.cbData, he.cbData == 1 ? "" : "s",
                       he.cbOverhead, he.cbOverhead == 1 ? "" : "s",
                       he.iRegionIndex,
                       FlagMsg
                       );

            rc = MessageBoxA (GetFocus(), OutputMsg, "Memory Allocation Statistics", MB_YESNOCANCEL|MB_APPLMODAL|MB_SETFOREGROUND);

            if (rc == IDCANCEL) {
                break;
            }

            if (rc == IDYES) {
                int i, j, k, l;
                PBYTE p;
                PSTR p2;
                OutputMsg[0] = 0;

                p = he.lpData;
                p2 = OutputMsg;
                j = min (256, he.cbData);
                for (i = 0 ; i < j ; i += 16) {
                    l = i + 16;
                    for (k = i ; k < l ; k++) {
                        if (k < j) {
                            wsprintfA (p2, "%02X ", (DWORD) (p[k]));
                        } else {
                            wsprintfA (p2, "   ");
                        }

                        p2 = strchr (p2, 0);
                    }

                    l = min (l, j);
                    for (k = i ; k < l ; k++) {
                        if (isprint (p[k])) {
                            *p2 = (CHAR) p[k];
                        } else {
                            *p2 = '.';
                        }
                        p2++;
                    }

                    *p2 = '\n';
                    p2++;
                    *p2 = 0;
                }

                MessageBoxA (GetFocus(), OutputMsg, "Memory Allocation Statistics", MB_OK|MB_APPLMODAL|MB_SETFOREGROUND);
            }
        }
    }
#endif // #if 0

#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveCriticalSection (&g_MemAllocCs);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\file.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    file.c

Abstract:

    General file-related functions.

Author:

    Mike Condra 16-Aug-1996

Revision History:

    calinn      23-Sep-1998 Additional options to file enum
    jimschm     05-Feb-1998 File enumeration code
    jimschm     30-Sep-1997 WriteFileString routines

--*/

#include "pch.h"

//
// Function accepts paths within the limit of our stack variable size
//
BOOL
IsPathLengthOkA (
    IN      PCSTR FileSpec
    )
{
    return SizeOfStringA(FileSpec) < MAX_MBCHAR_PATH;
}

BOOL
IsPathLengthOkW (
    IN      PCWSTR FileSpec
    )
{
    return SizeOfStringW(FileSpec) < (MAX_WCHAR_PATH * sizeof (WCHAR));
}


BOOL
IsPathOnFixedDriveA (
    IN      PCSTR FileSpec          OPTIONAL
    )
{
    static CHAR root[] = "?:\\";
    UINT type;
    static BOOL lastResult;

    if (!FileSpec) {
        return FALSE;
    }

    if (!FileSpec[0]) {
        return FALSE;
    }

    if (FileSpec[1] != ':' || FileSpec[2] != '\\') {
        return FALSE;
    }

    if (root[0] == FileSpec[0]) {
        return lastResult;
    }

    root[0] = FileSpec[0];
    type = GetDriveTypeA (root);

    if (type != DRIVE_FIXED && type != DRIVE_REMOTE) {
        DEBUGMSGA_IF ((
            type != DRIVE_REMOVABLE && type != DRIVE_NO_ROOT_DIR,
            DBG_VERBOSE,
            "Path %s is on unexpected drive type %u",
            FileSpec,
            type
            ));

        lastResult = FALSE;
    } else {
        lastResult = TRUE;
    }

    return lastResult;
}


BOOL
IsPathOnFixedDriveW (
    IN      PCWSTR FileSpec         OPTIONAL
    )
{
    static WCHAR root[] = L"?:\\";
    UINT type;
    static BOOL lastResult;
    PCWSTR p;

    if (!FileSpec) {
        return FALSE;
    }

    p = FileSpec;
    if (p[0] == L'\\' && p[1] == L'\\' && p[2] == L'?' && p[3] == L'\\') {
        p += 4;
    }

    MYASSERT (ISNT());

    if (!p[0]) {
        return FALSE;
    }

    if (p[1] != L':' || p[2] != L'\\') {
        return FALSE;
    }

    if (root[0] == p[0]) {
        return lastResult;
    }

    root[0] = p[0];
    type = GetDriveTypeW (root);

    if (type != DRIVE_FIXED && type != DRIVE_REMOTE) {
        DEBUGMSGW_IF ((
            type != DRIVE_REMOVABLE && type != DRIVE_NO_ROOT_DIR,
            DBG_VERBOSE,
            "Path %s is on unexpected drive type %u",
            FileSpec,
            type
            ));

        lastResult = FALSE;
    } else {
        lastResult = TRUE;
    }

    return lastResult;
}


BOOL
CopyFileSpecToLongA (
    IN      PCSTR FullFileSpecIn,
    OUT     PSTR OutPath
    )
{
    CHAR fullFileSpec[MAX_MBCHAR_PATH];
    WIN32_FIND_DATAA findData;
    HANDLE findHandle;
    PSTR end;
    PSTR currentIn;
    PSTR currentOut;
    PSTR outEnd;
    PSTR maxOutPath = OutPath + MAX_PATH - 1;
    BOOL result = FALSE;
    UINT oldMode;
    BOOL forceCopy = FALSE;

    oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    __try {
        //
        // Limit length
        //
        if (!IsPathLengthOkA (FullFileSpecIn)) {
            DEBUGMSGA ((DBG_ERROR, "Inbound file spec is too long: %s", FullFileSpecIn));
            __leave;
        }

        //
        // If path is on removable media, don't touch the disk
        //

        if (!IsPathOnFixedDriveA (FullFileSpecIn)) {
            forceCopy = TRUE;
            __leave;
        }

        //
        // Make a copy of the file spec so we can truncate it at the wacks
        //

        StringCopyA (fullFileSpec, FullFileSpecIn);

        //
        // Begin building the path
        //

        OutPath[0] = fullFileSpec[0];
        OutPath[1] = fullFileSpec[1];
        OutPath[2] = fullFileSpec[2];
        OutPath[3] = 0;

        currentIn = fullFileSpec + 3;
        currentOut = OutPath + 3;

        for (;;) {

            end = _mbschr (currentIn, '\\');

            if (end == (currentIn + 1)) {
                currentIn++;
                continue;
            }

            if (end) {
                *end = 0;
            }

            findHandle = FindFirstFileA (fullFileSpec, &findData);

            if (findHandle != INVALID_HANDLE_VALUE) {
                FindClose (findHandle);

                //
                // Copy long file name obtained from FindFirstFile
                //

                outEnd = currentOut + TcharCountA (findData.cFileName);
                if (outEnd > maxOutPath) {

#ifdef DEBUG
                    *currentOut = 0;
                    DEBUGMSGA ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        findData.cFileName,
                        OutPath
                        ));
#endif

                    __leave;
                }

                StringCopyA (currentOut, findData.cFileName);
                currentOut = outEnd;

            } else {
                //
                // Copy the rest of the path since it doesn't exist
                //

                if (end) {
                    *end = '\\';
                }

                outEnd = currentOut + TcharCountA (currentIn);

                if (outEnd > maxOutPath) {

#ifdef DEBUG
                    DEBUGMSGA ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        currentIn,
                        OutPath
                        ));
#endif

                    __leave;
                }

                StringCopyA (currentOut, currentIn);
                break;      // done with path
            }

            if (!end) {
                MYASSERT (*currentOut == 0);
                break;      // done with path
            }

            *currentOut++ = '\\';
            *currentOut = 0;
            *end = '\\';

            currentIn = end + 1;
        }

        result = TRUE;
    }
    __finally {
        SetErrorMode (oldMode);
    }

    if (forceCopy) {
        StringCopyA (OutPath, FullFileSpecIn);
        return TRUE;
    }

    if (!result) {
        StringCopyTcharCountA (OutPath, FullFileSpecIn, MAX_PATH);
    }

    return result;
}


BOOL
CopyFileSpecToLongW (
    IN      PCWSTR FullFileSpecIn,
    OUT     PWSTR OutPath
    )
{
    WCHAR fullFileSpec[MAX_WCHAR_PATH];
    WIN32_FIND_DATAW findData;
    HANDLE findHandle;
    PWSTR end;
    PWSTR currentIn;
    PWSTR currentOut;
    PWSTR outEnd;
    PWSTR maxOutPath = OutPath + MAX_PATH - 1;
    BOOL result = FALSE;
    UINT oldMode;
    BOOL forceCopy = FALSE;

    MYASSERT (ISNT());

    oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    __try {
        //
        // Limit length
        //
        if (!IsPathLengthOkW (FullFileSpecIn)) {
            DEBUGMSGW ((DBG_ERROR, "Inbound file spec is too long: %s", FullFileSpecIn));
            __leave;
        }

        //
        // If path is on removable media, don't touch the disk
        //

        if (!IsPathOnFixedDriveW (FullFileSpecIn)) {
            forceCopy = TRUE;
            __leave;
        }

        //
        // Make a copy of the file spec so we can truncate it at the wacks
        //

        StringCopyW (fullFileSpec, FullFileSpecIn);

        //
        // Begin building the path
        //

        OutPath[0] = fullFileSpec[0];
        OutPath[1] = fullFileSpec[1];
        OutPath[2] = fullFileSpec[2];
        OutPath[3] = 0;

        currentIn = fullFileSpec + 3;
        currentOut = OutPath + 3;

        for (;;) {

            end = wcschr (currentIn, L'\\');

            if (end == (currentIn + 1)) {
                currentIn++;
                continue;
            }

            if (end) {
                *end = 0;
            }

            findHandle = FindFirstFileW (fullFileSpec, &findData);

            if (findHandle != INVALID_HANDLE_VALUE) {
                FindClose (findHandle);

                //
                // Copy long file name obtained from FindFirstFile
                //

                outEnd = currentOut + TcharCountW (findData.cFileName);
                if (outEnd > maxOutPath) {

                    DEBUGMSGW ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        findData.cFileName,
                        OutPath
                        ));

                    __leave;
                }

                StringCopyW (currentOut, findData.cFileName);
                currentOut = outEnd;

            } else {
                //
                // Copy the rest of the path since it doesn't exist
                //

                if (end) {
                    *end = L'\\';
                }

                outEnd = currentOut + TcharCountW (currentIn);

                if (outEnd > maxOutPath) {

                    DEBUGMSGW ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        currentIn,
                        OutPath
                        ));

                    __leave;
                }

                StringCopyW (currentOut, currentIn);
                break;      // done with path
            }

            if (!end) {
                MYASSERT (*currentOut == 0);
                break;      // done with path
            }

            *currentOut++ = L'\\';
            *currentOut = 0;
            *end = L'\\';

            currentIn = end + 1;
        }

        result = TRUE;
    }
    __finally {
        SetErrorMode (oldMode);
    }

    if (forceCopy) {
        StringCopyW (OutPath, FullFileSpecIn);
        return TRUE;
    }

    if (!result) {
        StringCopyTcharCountW (OutPath, FullFileSpecIn, MAX_PATH);
    }

    return result;
}



BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        return GetFileAttributesA (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error = NO_ERROR;
    UINT length;
    BOOL result = FALSE;
    PCWSTR longFileName = NULL;

    __try {
        if (FileName[0] != TEXT('\\')) {
            length = TcharCountW (FileName);
            if (length >= MAX_PATH) {
                longFileName = JoinPathsW (L"\\\\?", FileName);
                MYASSERT (longFileName);
                FileName = longFileName;
            }
        }

        if (!FindData) {
            result = (GetLongPathAttributesW (FileName) != 0xffffffff);
            __leave;
        }

        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        FindHandle = FindFirstFileW(FileName,&ourFindData);

        if (FindHandle == INVALID_HANDLE_VALUE) {
            Error = GetLastError();
        } else {
            FindClose(FindHandle);
            *FindData = ourFindData;
        }

        SetErrorMode(OldMode);
        SetLastError(Error);

        result = (Error == NO_ERROR);
    }
    __finally {
        if (longFileName) {
            FreePathStringW (longFileName);
        }
    }

    return result;
}


DWORD
MakeSurePathExistsA(
    IN      PCSTR FullFileSpec,
    IN      BOOL PathOnly
    )
{
    CHAR Buffer[MAX_MBCHAR_PATH];
    PCHAR p,q;
    BOOL Done;
    BOOL isUnc;
    DWORD d;
    WIN32_FIND_DATAA FindData;

    isUnc = (FullFileSpec[0] == '\\') && (FullFileSpec[1] == '\\');

    //
    // Locate and strip off the final component
    //

    _mbssafecpy(Buffer,FullFileSpec,sizeof(Buffer));

    p = _mbsrchr(Buffer, '\\');

    if (p) {
        if (!PathOnly) {
            *p = 0;
        }
        //
        // If it's a drive root, nothing to do.
        //
        if(Buffer[0] && (Buffer[1] == ':') && !Buffer[2]) {
            return(NO_ERROR);
        }
    } else {
        //
        // Just a relative filename, nothing to do.
        //
        return(NO_ERROR);
    }

    //
    // If it already exists do nothing.
    //
    if (DoesFileExistExA (Buffer,&FindData)) {
        return NO_ERROR;
    }

    p = Buffer;

    //
    // Compensate for drive spec.
    //
    if(p[0] && (p[1] == ':')) {
        p += 2;
    }

    //
    // Compensate for UNC paths.
    //
    if (isUnc) {

        //
        // Skip the initial wack wack before machine name.
        //
        p += 2;


        //
        // Skip to the share.
        //
        p = _mbschr(p, '\\');
        if (p==NULL) {
            return ERROR_BAD_PATHNAME;
        }

        //
        // Skip past the share.
        //
        p = _mbschr(p, '\\');
        if (p==NULL) {
            return ERROR_BAD_PATHNAME;
        }
    }

    Done = FALSE;
    do {
        //
        // Skip path sep char.
        //
        while(*p == '\\') {
            p++;
        }

        //
        // Locate next path sep char or terminating nul.
        //
        if(q = _mbschr(p, '\\')) {
            *q = 0;
        } else {
            q = GetEndOfStringA(p);
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(!CreateDirectoryA(Buffer,NULL)) {
            d = GetLastError();
            if(d != ERROR_ALREADY_EXISTS) {
                return(d);
            }
        }

        if(!Done) {
            *q = '\\';
            p = q+1;
        }

    } while(!Done);

    return(NO_ERROR);
}


VOID
DestPathCopyW (
    OUT     PWSTR DestPath,
    IN      PCWSTR SrcPath
    )
{
    PCWSTR p;
    PWSTR q;
    PCWSTR end;
    PCWSTR maxStart;
    UINT len;
    UINT count;

    len = TcharCountW (SrcPath);

    if (len < MAX_PATH) {
        StringCopyW (DestPath, SrcPath);
        return;
    }

    //
    // Path is too long -- try to truncate it
    //

    wsprintfW (DestPath, L"%c:\\Long", SrcPath[0]);
    CreateDirectoryW (DestPath, NULL);

    p = SrcPath;
    end = SrcPath + len;
    maxStart = end - 220;

    while (p < end) {
        if (*p == '\\') {
            if (p >= maxStart) {
                break;
            }
        }

        p++;
    }

    if (p == end) {
        p = maxStart;
    }

    MYASSERT (TcharCountW (p) <= 220);

    StringCopyW (AppendWackW (DestPath), p);
    q = (PWSTR) GetEndOfStringW (DestPath);

    //
    // Verify there is no collision
    //

    for (count = 1 ; count < 1000000 ; count++) {
        if (GetFileAttributesW (DestPath) == INVALID_ATTRIBUTES) {
            break;
        }

        wsprintfW (q, L" (%u)", count);
    }
}


DWORD
MakeSurePathExistsW(
    IN LPCWSTR FullFileSpec,
    IN BOOL    PathOnly
    )
{
    PWSTR buffer;
    WCHAR *p, *q;
    BOOL Done;
    DWORD d;
    WIN32_FIND_DATAW FindData;
    DWORD result = NO_ERROR;

    if (FullFileSpec[0] != L'\\') {
        if (TcharCountW (FullFileSpec) >= MAX_PATH) {
            if (PathOnly || ((wcsrchr (FullFileSpec, L'\\') - FullFileSpec) >= MAX_PATH)) {
                LOGW ((LOG_ERROR, "Can't create path %s because it is too long", FullFileSpec));
                return ERROR_FILENAME_EXCED_RANGE;
            }
        }
    }

    //
    // Locate and strip off the final component
    //
    buffer = DuplicatePathStringW (FullFileSpec, 0);
    __try {

        p = wcsrchr(buffer, L'\\');

        if (p) {
            if (!PathOnly) {
                *p = 0;
            }
        } else {
            //
            // Just a relative filename, nothing to do.
            //
            __leave;
        }

        //
        // If it already exists do nothing.
        //
        if (DoesFileExistExW (buffer, &FindData)) {
            result = ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
            __leave;
        }

        p = buffer;

        //
        // Compensate for drive spec.
        //
        if (p[0] == L'\\' && p[1] == L'\\' && p[2] == L'?' && p[3] == L'\\') {
            p += 4;
        }

        if (p[0] && (p[1] == L':')) {
            p += 2;
        }

        if ((p[0] == 0) || (p[0] == L'\\' && p[1] == 0)) {
            //
            // Root -- leave
            //

            __leave;
        }

        Done = FALSE;
        do {
            //
            // Skip path sep char.
            //
            while(*p == L'\\') {
                p++;
            }

            //
            // Locate next path sep char or terminating nul.
            //
            q = wcschr(p, L'\\');

            if(q) {
                *q = 0;
            } else {
                q = GetEndOfStringW (p);
                Done = TRUE;
            }

            //
            // Create this portion of the path.
            //
            if(!CreateDirectoryW(buffer,NULL)) {
                d = GetLastError();
                if(d != ERROR_ALREADY_EXISTS) {
                    result = d;
                    __leave;
                }
            }

            if(!Done) {
                *q = L'\\';
                p = q+1;
            }

        } while(!Done);
    }
    __finally {
        FreePathStringW (buffer);
    }

    return result;
}


//
// ...PACKFILE HANDLING...
//

#define PACKFILE_BUFFERSIZE 2048



BOOL
pFillEnumStructureA (
    IN PPACKFILEENUMA Enum
    )
{

    BOOL                rSuccess = TRUE;
    DWORD               numBytesRead;
    HANDLE              savedHandle;

    MYASSERT(Enum && Enum -> Handle != INVALID_HANDLE_VALUE && Enum -> Handle != NULL);

    //
    // Save this away.. The read below blows it away.
    //
    savedHandle = Enum -> Handle;

    //
    // Read the header information from the current position in the file.
    //
    rSuccess = ReadFile(
        Enum -> Handle,
        Enum,
        sizeof(PACKFILEENUMA),
        &numBytesRead,
        NULL
        );

    //
    // Restore the handle member.
    //
    Enum -> Handle = savedHandle;

    return rSuccess && numBytesRead == sizeof(PACKFILEENUMA);
}


BOOL
PackedFile_ExtractFileUsingEnumA (
    IN PPACKFILEENUMA Enum,
    IN LPCSTR         FileName OPTIONAL
    )
{
    BOOL        rSuccess = TRUE;
    HANDLE      newFileHandle;
    LONGLONG    numberOfBytesToExtract;
    LONGLONG    numberOfBytesExtracted;
    DWORD       numberOfBytesToRead;
    DWORD       numberOfBytesRead;
    BYTE        buffer[PACKFILE_BUFFERSIZE];
    DWORD       fileHigh;
    DWORD       fileLow;

    MYASSERT(Enum && Enum -> Handle != INVALID_HANDLE_VALUE && Enum -> Handle != NULL);

    //
    // First, attempt to create the new file. If FileName was not specified, we'll use the
    // Identifier name in the enum struct.
    //
    if (!FileName) {
        FileName = Enum -> Identifier;
    }

    newFileHandle = CreateFileA (
        FileName,
        GENERIC_WRITE,
        0,                              // No sharing.
        NULL,                           // No inheritance.
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL                            // No template file.
        );

    if (newFileHandle == INVALID_HANDLE_VALUE) {

        rSuccess = FALSE;
        DEBUGMSG((DBG_ERROR,"PackedFile_ExtractFromEnum: Could not open file %s. FileName"));

    }
    else {

        //
        // File was successfully opened. Extract the data starting from the current file position
        //

        //
        // Create a LONGLONG value out of the size of the file.
        //
        numberOfBytesToExtract = ((LONGLONG)Enum -> SizeHigh) << 32 | ((LONGLONG) Enum -> SizeLow);
        numberOfBytesExtracted = 0;

        do {

            //
            // Figure out how much to read from the file.
            //
            if (numberOfBytesToExtract - numberOfBytesExtracted > PACKFILE_BUFFERSIZE) {
                numberOfBytesToRead = PACKFILE_BUFFERSIZE;
            }
            else {
                numberOfBytesToRead = (DWORD) (numberOfBytesToExtract - numberOfBytesExtracted);
            }

            if (!ReadFile(
                    Enum -> Handle,
                    buffer,
                    numberOfBytesToRead,
                    &numberOfBytesRead,
                    NULL
                    ) ||
                !WriteFile(
                    newFileHandle,
                    buffer,
                    numberOfBytesRead,
                    &numberOfBytesRead,
                    NULL
                    )) {

                numberOfBytesExtracted += (LONGLONG) numberOfBytesRead;
                break;
            }

            //
            // Update the count of bytes extracted.
            //
            numberOfBytesExtracted += (LONGLONG) numberOfBytesRead;

        } while (numberOfBytesExtracted < numberOfBytesToExtract);

        //
        // Close the handle to the new file we created.
        //
        CloseHandle(newFileHandle);

        //
        // Reset the file pointer.
        //
        fileHigh = (DWORD) (numberOfBytesExtracted >> 32);
        fileLow  = (DWORD) (numberOfBytesExtracted & 0xffffffff);
        SetFilePointer(Enum -> Handle,fileLow,&fileHigh,FILE_CURRENT);

        if (numberOfBytesExtracted != numberOfBytesToExtract) {
            rSuccess = FALSE;
            DEBUGMSG((DBG_ERROR,"PackedFile_ExtractFromEnum: Could not extract file."));
        }
    }

    return rSuccess;
}


VOID
PackedFile_AbortEnum (
    IN OUT PPACKFILEENUMA Enum
    )
{
    MYASSERT(Enum -> Handle != INVALID_HANDLE_VALUE && Enum -> Handle != NULL);
    //
    // Nothing to do except close the handle.
    //
    CloseHandle(Enum -> Handle);
}

BOOL
PackedFile_EnumNextA (
    IN PPACKFILEENUMA Enum
    )
{
    BOOL rSuccess = TRUE;

    MYASSERT(Enum && Enum -> Handle != INVALID_HANDLE_VALUE && Enum -> Handle != NULL);

    //
    // Move the file pointer ahead by the size contained in the current enum structure.
    //
    if (SetFilePointer(Enum -> Handle,Enum -> SizeLow,&Enum -> SizeHigh,FILE_CURRENT) == 0xffffffff &&
        GetLastError() != NO_ERROR) {

        rSuccess = FALSE;
    }
    else {

        //
        // Fill in the enum structure with the fresh data.
        //
        rSuccess = pFillEnumStructureA(Enum);
    }

    if (!rSuccess) {
        PackedFile_AbortEnum(Enum);
    }

    return rSuccess;
}




BOOL
PackedFile_EnumFirstA (
    IN  LPCSTR        PackFile,
    OUT PPACKFILEENUMA Enum
    )
{
    BOOL rSuccess = FALSE;

    MYASSERT(Enum && PackFile);

    //
    // Clean out the Enum structure.
    //
    ZeroMemory(Enum,sizeof(PACKFILEENUMA));

    //
    // Open a handle to the PackFile.
    //
    Enum -> Handle = CreateFileA (
            PackFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                           // No inheritance.
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                            // No template file.
            );


    //
    // If that succeeds, trust EnumNext to handle the dirty work.
    //
    if (Enum -> Handle != INVALID_HANDLE_VALUE) {
        rSuccess = pFillEnumStructureA(Enum);
    }

    return rSuccess;
}

BOOL
PackedFile_ExtractFileA (
    IN LPCSTR   PackFile,
    IN LPCSTR   FileIdentifier,
    IN LPCSTR   FileName        OPTIONAL
    )
{

    PACKFILEENUMA e;
    BOOL          rSuccess = FALSE;

    MYASSERT(PackFile && FileIdentifier);

    if (PackedFile_EnumFirstA(PackFile,&e)) {

        do {
            if (StringIMatchA (e.Identifier,FileIdentifier)) {
                //
                // We found the one they were looking for..
                //
                rSuccess = PackedFile_ExtractFileUsingEnumA(&e,FileName);
                PackedFile_AbortEnum(&e);
                break;
            }

        } while (PackedFile_EnumNextA(&e));
    }

    return rSuccess;

}



BOOL
PackedFile_AddFileA (
    IN LPCSTR PackFile,
    IN LPCSTR NewFile,
    IN LPCSTR Identifier   OPTIONAL
    )
{
    HANDLE              packFileHandle       = INVALID_HANDLE_VALUE;
    HANDLE              newFileHandle        = INVALID_HANDLE_VALUE;
    BOOL                rSuccess             = TRUE;
    PACKFILEENUMA       fileHeader;
    DWORD               numBytes;
    BYTE                buffer[PACKFILE_BUFFERSIZE];

    //
    //  Now, attempt to open the new file.
    //
    newFileHandle = CreateFileA (
        NewFile,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (newFileHandle == INVALID_HANDLE_VALUE) {

        DEBUGMSG((DBG_ERROR,"PackedFile_AddFile could not open %s and therefore cannot add it.",NewFile));
        return FALSE;
    }

    //
    // Open or create the packfile. If it does not already exist, then it will be created.
    //
    packFileHandle = CreateFileA (
        PackFile,
        GENERIC_READ | GENERIC_WRITE,
        0,                              // No sharing.
        NULL,                           // No inheritance.
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL                            // No template file.
        );

    if (packFileHandle == INVALID_HANDLE_VALUE) {
        rSuccess = FALSE;
        DEBUGMSG((DBG_ERROR,"PackedFile_AddFile Could not open or create the packed file %s.",PackFile));

    } else {

        //
        // Both files have been successfully opened. Add the new file to the packfile.
        //

        //
        // First, we need to set the file pointer to the end of the packed file.
        //
        SetFilePointer(packFileHandle,0,NULL,FILE_END);

        //
        // Ok, Fill in a header structure for this file. It is a simple header. All it contains
        // is the Identifier (or the file path if Identifier is NULL) and the size of the file.
        // There is another parameter (Handle) in the structure, but this is only used
        // for enumeration purposes and is always NULL when written into the file.
        //
        if (!Identifier) {
            Identifier = NewFile;
        }

        fileHeader.Handle = NULL; // This member is only used in enumeration.

        _mbssafecpy(fileHeader.Identifier,Identifier,MAX_MBCHAR_PATH);

        fileHeader.SizeLow = GetFileSize(newFileHandle,&fileHeader.SizeHigh);

        if (fileHeader.SizeLow == 0xffffffff && GetLastError() != NO_ERROR) {
            rSuccess = FALSE;
            DEBUGMSG((DBG_ERROR,"PackedFile_AddFile Could not get the file size for %s.",NewFile));
        }
        else {

            //
            // Now, write the header into the packed file.
            //
            if (!WriteFile(
                packFileHandle,
                &fileHeader,
                sizeof(PACKFILEENUMA),
                &numBytes,
                NULL                        // Not overlapped.
                )) {

                DEBUGMSG((DBG_ERROR,"PackedFile_AddFile Could not write a file header to the pack file %s.",PackFile));
                rSuccess = FALSE;
            }
            else {

                //
                // At this point, all that is left to do is to write the bits from the packed file into
                // the packed file.
                //
                do {

                    if (!ReadFile(
                            newFileHandle,
                            buffer,
                            PACKFILE_BUFFERSIZE,
                            &numBytes,
                            NULL
                            ) ||
                        !WriteFile(
                            packFileHandle,
                            buffer,
                            numBytes,
                            &numBytes,
                            NULL
                            )) {

                        rSuccess = FALSE;
                        DEBUGMSG((DBG_ERROR,"PackedFile_AddFile encountered an error writing the file %s to the packed file %s.",NewFile,PackFile));
                        break;
                    }
                } while (numBytes == PACKFILE_BUFFERSIZE);
            }
        }

        //
        // Close the handles to both files. We are done with them.
        //
        CloseHandle(packFileHandle);
    }

    CloseHandle(newFileHandle);

    return rSuccess;
}





//
// The W versions of these files are unimplemented.
//
BOOL
PackedFile_AddFileW (
    IN LPCSTR PackFile,
    IN LPCSTR NewFile,
    IN LPCSTR Identifier   OPTIONAL
    )
{
    return FALSE;
}

BOOL
PackedFile_ExtractFileW (
    IN LPCSTR   PackFile,
    IN LPCSTR   FileIdentifier,
    IN LPCSTR   FileName        OPTIONAL
    )
{
    return FALSE;
}

BOOL
PackedFile_EnumFirstW (
    IN  LPCSTR        PackFile,
    OUT PPACKFILEENUMA Enum
    )
{
    return FALSE;
}

BOOL
PackedFile_EnumNextW (
    IN PPACKFILEENUMA Enum
    )
{
    return FALSE;
}

BOOL
PackedFile_ExtractFileUsingEnumW (
    IN PPACKFILEENUMA Enum,
    IN LPCSTR         FileName OPTIONAL
    )
{
    return FALSE;
}



BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}


/*++

Routine Description:

  pFindShortNameA is a helper function for OurGetLongPathName.  It
  obtains the short file name, if it exists, using FindFirstFile.

Arguments:

  WhatToFind - Specifies the short or long name of a file to locate

  Buffer - Receives the matching file name

Return Value:

  TRUE if the file was found and Buffer was updated, or FALSE if the
  file was not found and Buffer was not updated.

--*/

BOOL
pFindShortNameA (
    IN      PCSTR WhatToFind,
    OUT     PSTR Buffer,
    OUT     INT *BufferSizeInBytes
    )
{
    WIN32_FIND_DATAA fd;
    HANDLE hFind;

    hFind = FindFirstFileA (WhatToFind, &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FindClose (hFind);

    *BufferSizeInBytes -= ByteCountA (fd.cFileName);
    if (*BufferSizeInBytes >= sizeof (CHAR)) {
        StringCopyA (Buffer, fd.cFileName);
    }

    return TRUE;
}


BOOL
pFindShortNameW (
    IN      PCWSTR WhatToFind,
    OUT     PWSTR Buffer,
    OUT     INT *BufferSizeInBytes
    )
{
    WIN32_FIND_DATAA fdA;
    WIN32_FIND_DATAW fdW;
    PCWSTR UnicodeVersion;
    PCSTR AnsiVersion;
    HANDLE hFind;

    if (ISNT ()) {
        hFind = FindFirstFileW (WhatToFind, &fdW);
        if (hFind == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        FindClose (hFind);
    } else {
        AnsiVersion = ConvertWtoA (WhatToFind);
        hFind = FindFirstFileA (AnsiVersion, &fdA);
        FreeConvertedStr (AnsiVersion);
        if (hFind == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        FindClose (hFind);
        fdW.dwFileAttributes = fdA.dwFileAttributes;
        fdW.ftCreationTime = fdA.ftCreationTime;
        fdW.ftLastAccessTime = fdA.ftLastAccessTime;
        fdW.ftLastWriteTime = fdA.ftLastWriteTime;
        fdW.nFileSizeHigh = fdA.nFileSizeHigh;
        fdW.nFileSizeLow = fdA.nFileSizeLow;
        fdW.dwReserved0 = fdA.dwReserved0;
        fdW.dwReserved1 = fdA.dwReserved1;
        UnicodeVersion = ConvertAtoW (fdA.cFileName);
        StringCopyTcharCountW (fdW.cFileName, UnicodeVersion, MAX_PATH);
        FreeConvertedStr (UnicodeVersion);
        UnicodeVersion = ConvertAtoW (fdA.cAlternateFileName);
        StringCopyTcharCountW (fdW.cAlternateFileName, UnicodeVersion, 14);
        FreeConvertedStr (UnicodeVersion);
    }

    *BufferSizeInBytes -= ByteCountW (fdW.cFileName);
    if (*BufferSizeInBytes >= sizeof (WCHAR)) {
        StringCopyW (Buffer, fdW.cFileName);
    }

    return TRUE;
}


/*++

Routine Description:

  OurGetLongPathName locates the long name for a file.  It first locates the
  full path if a path is not explicitly provided, and then uses FindFirstFile
  to get the long file name.  NOTE: This is exactly what the Win32 function
  GetLongPathName does, but unfortunately the Win32 API is not available on Win95.

  This routine resolves each piece of a short path name using recursion.

Arguments:

  ShortPath  - Specifies the file name or full file path to locate

  Buffer - Receives the full file path.  This buffer must be big enough to
           handle the maximum file name size.

Return Value:

  TRUE if the file is found and Buffer contains the long name, or FALSE
  if the file is not found and Buffer is not modified.

--*/

BOOL
OurGetLongPathNameA (
    IN      PCSTR ShortPath,
    OUT     PSTR Buffer,
    IN      INT BufferSizeInBytes
    )
{
    CHAR FullPath[MAX_MBCHAR_PATH];
    PCSTR SanitizedPath;
    PSTR FilePart;
    PSTR BufferEnd;
    PSTR p, p2;
    MBCHAR c;
    BOOL result = TRUE;

    MYASSERT (BufferSizeInBytes >= MAX_MBCHAR_PATH);

    if (ShortPath[0] == 0) {
        return FALSE;
    }

    __try {

        SanitizedPath = SanitizePathA (ShortPath);
        if (!SanitizedPath) {
            SanitizedPath = DuplicatePathStringA (ShortPath, 0);
        }

        if (!_mbschr (SanitizedPath, '\\')) {
            if (!SearchPathA (NULL, SanitizedPath, NULL, sizeof (FullPath), FullPath, &FilePart)) {

                result = FALSE;
                __leave;
            }
        } else {
            GetFullPathNameA (SanitizedPath, sizeof (FullPath), FullPath, &FilePart);
        }

        //
        // Convert short paths to long paths
        //

        p = FullPath;

        if (!IsPathOnFixedDriveA (FullPath)) {
            _mbssafecpy (Buffer, FullPath, BufferSizeInBytes);
            __leave;
        }

        p += 3;

        // Copy drive letter to buffer
        StringCopyABA (Buffer, FullPath, p);
        BufferEnd = GetEndOfStringA (Buffer);
        BufferSizeInBytes -= p - FullPath;

        // Convert each portion of the path
        do {
            // Locate end of this file or dir
            p2 = _mbschr (p, '\\');
            if (!p2) {
                p = GetEndOfStringA (p);
            } else {
                p = p2;
            }

            // Look up file
            c = *p;
            *p = 0;
            if (!pFindShortNameA (FullPath, BufferEnd, &BufferSizeInBytes)) {
                DEBUGMSG ((DBG_VERBOSE, "OurGetLongPathNameA: %s does not exist", FullPath));
                result = FALSE;
                __leave;
            }
            *p = (CHAR)c;

            // Move on to next part of path
            if (*p) {
                p = _mbsinc (p);
                if (BufferSizeInBytes >= sizeof (CHAR) * 2) {
                    BufferEnd = _mbsappend (BufferEnd, "\\");
                    BufferSizeInBytes -= sizeof (CHAR);
                }
            }
        } while (*p);
    }
    __finally {
        FreePathStringA (SanitizedPath);
    }

    return result;
}

DWORD
OurGetShortPathNameW (
    IN      PCWSTR LongPath,
    OUT     PWSTR ShortPath,
    IN      DWORD CharSize
    )
{
    PCSTR LongPathA;
    PSTR ShortPathA;
    PCWSTR ShortPathW;
    DWORD result;

    if (ISNT()) {
        return GetShortPathNameW (LongPath, ShortPath, CharSize);
    } else {
        LongPathA = ConvertWtoA (LongPath);

        if (!IsPathOnFixedDriveA (LongPathA)) {
            StringCopyTcharCountW (ShortPath, LongPath, CharSize);
            FreeConvertedStr (LongPathA);
            return TcharCountW (ShortPath);
        }

        ShortPathA = AllocPathStringA (CharSize);
        result = GetShortPathNameA (LongPathA, ShortPathA, CharSize);
        if (result) {
            ShortPathW = ConvertAtoW (ShortPathA);
            StringCopyTcharCountW (ShortPath, ShortPathW, CharSize);
            FreeConvertedStr (ShortPathW);
        } else {
            StringCopyTcharCountW (ShortPath, LongPath, CharSize);
        }
        FreePathStringA (ShortPathA);
        FreeConvertedStr (LongPathA);
        return result;
    }
}

DWORD
OurGetFullPathNameW (
    PCWSTR FileName,
    DWORD CharSize,
    PWSTR FullPath,
    PWSTR *FilePtr
    )
{
    PCSTR FileNameA;
    PSTR FullPathA;
    PSTR FilePtrA;
    PCWSTR FullPathW;
    DWORD result;
    DWORD err;

    if (ISNT()) {
        return GetFullPathNameW (FileName, CharSize, FullPath, FilePtr);
    } else {
        FileNameA = ConvertWtoA (FileName);
        FullPathA = AllocPathStringA (CharSize);
        result = GetFullPathNameA (FileNameA, CharSize, FullPathA, &FilePtrA);
        FullPathW = ConvertAtoW (FullPathA);
        StringCopyTcharCountW (FullPath, FullPathW, CharSize);
        err = GetLastError ();
        *FilePtr = (PWSTR)GetFileNameFromPathW (FullPath);
        FreeConvertedStr (FullPathW);
        FreePathStringA (FullPathA);
        FreeConvertedStr (FileNameA);
        return result;
    }
}

BOOL
OurGetLongPathNameW (
    IN      PCWSTR ShortPath,
    OUT     PWSTR Buffer,
    IN      INT BufferSizeInChars
    )
{
    WCHAR FullPath[MAX_WCHAR_PATH];
    PWSTR FilePart;
    PWSTR BufferEnd;
    PWSTR p, p2;
    WCHAR c;
    INT BufferSizeInBytes;

    MYASSERT (BufferSizeInChars >= MAX_WCHAR_PATH);

    if (ShortPath[0] == 0) {
        return FALSE;
    }

    BufferSizeInBytes = BufferSizeInChars * sizeof (WCHAR);

    if (!wcschr (ShortPath, L'\\')) {
        if (!SearchPathW (NULL, ShortPath, NULL, MAX_WCHAR_PATH, FullPath, &FilePart)) {
            return FALSE;
        }
    } else {
        if (OurGetFullPathNameW (ShortPath, MAX_WCHAR_PATH, FullPath, &FilePart) == 0) {
            return FALSE;
        }
    }

    //
    // Convert short paths to long paths
    //

    p = FullPath;

    if (!IsPathOnFixedDriveW (FullPath)) {
        StringCopyTcharCountW (Buffer, FullPath, BufferSizeInChars);
        return TRUE;
    }

    p += 3;

    // Copy drive letter to buffer
    StringCopyABW (Buffer, FullPath, p);
    BufferEnd = GetEndOfStringW (Buffer);
    BufferSizeInBytes -= sizeof (WCHAR) * 3;

    // Convert each portion of the path
    do {
        // Locate end of this file or dir
        p2 = wcschr (p, L'\\');
        if (!p2) {
            p = GetEndOfStringW (p);
        } else {
            p = p2;
        }

        // Look up file
        c = *p;
        *p = 0;
        if (!pFindShortNameW (FullPath, BufferEnd, &BufferSizeInBytes)) {
            DEBUGMSG ((DBG_VERBOSE, "OurGetLongPathNameW: %ls does not exist", FullPath));
            return FALSE;
        }
        *p = c;

        // Move on to next part of path
        if (*p) {
            p++;
            if (BufferSizeInBytes >= sizeof (WCHAR) * 2) {
                BufferEnd = _wcsappend (BufferEnd, L"\\");
                BufferSizeInBytes -= sizeof (WCHAR);
            }
        }
    } while (*p);

    return TRUE;
}


#ifdef DEBUG
UINT g_FileEnumResourcesInUse;
#endif

VOID
pTrackedFindClose (
    HANDLE FindHandle
    )
{
#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    FindClose (FindHandle);
}

BOOL
EnumFirstFileInTreeExA (
    OUT     PTREE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    )

/*++

Routine Description:

  EnumFirstFileInTree begins an enumeration of a directory tree.  The
  caller supplies an uninitialized enum structure, a directory path to
  enumerate, and an optional file pattern.  On return, the caller
  receives all files and directories that match the pattern.

  If a file pattern is supplied, directories that do not match the
  file pattern are enumerated anyway.

Arguments:

  EnumPtr - Receives the enumerated file or directory

  RootPath - Specifies the full path of the directory to enumerate

  FilePattern - Specifies a pattern of files to limit the search to

  EnumDirsFirst - Specifies TRUE if the directories should be enumerated
                  before the files, or FALSE if the directories should
                  be enumerated after the files.

Return Value:

  TRUE if a file or directory was enumerated, or FALSE if enumeration is complete
  or an error occurred.  (Use GetLastError to determine the result.)

--*/

{
    ZeroMemory (EnumPtr, sizeof (TREE_ENUMA));

    EnumPtr->State = TREE_ENUM_INIT;

    _mbssafecpy (EnumPtr->RootPath, RootPath, MAX_MBCHAR_PATH);

    if (FilePattern) {
        _mbssafecpy (EnumPtr->FilePattern, FilePattern, MAX_MBCHAR_PATH);
    } else {
        StringCopyA (EnumPtr->FilePattern, "*.*");
    }

    EnumPtr->EnumDirsFirst = EnumDirsFirst;
    EnumPtr->EnumDepthFirst = EnumDepthFirst;

    EnumPtr->Level    = 1;
    EnumPtr->MaxLevel = MaxLevel;

    return EnumNextFileInTreeA (EnumPtr);
}


BOOL
EnumFirstFileInTreeExW (
    OUT     PTREE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern,         OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    )
{
    ZeroMemory (EnumPtr, sizeof (TREE_ENUMW));

    EnumPtr->State = TREE_ENUM_INIT;

    _wcssafecpy (EnumPtr->RootPath, RootPath, MAX_PATH);

    if (FilePattern) {
        _wcssafecpy (EnumPtr->FilePattern, FilePattern, MAX_PATH);
    } else {
        StringCopyW (EnumPtr->FilePattern, L"*.*");
    }

    EnumPtr->EnumDirsFirst = EnumDirsFirst;
    EnumPtr->EnumDepthFirst = EnumDepthFirst;

    EnumPtr->Level    = 1;
    EnumPtr->MaxLevel = MaxLevel;

    return EnumNextFileInTreeW (EnumPtr);
}


BOOL
EnumNextFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextFileInTree continues an enumeration of a directory tree,
  returning the files that match the pattern specified in EnumFirstFileInTree,
  and also returning all directories.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives the enumerated file
            or directory

Return Value:

  TRUE if a file or directory was enumerated, or FALSE if enumeration is complete
  or an error occurred.  (Use GetLastError to determine the result.)

--*/

{
    PSTR p;

    for (;;) {
        switch (EnumPtr->State) {

        case TREE_ENUM_INIT:
            //
            // Get rid of wack at the end of root path, if it exists
            //

            p = GetEndOfStringA (EnumPtr->RootPath);
            p = _mbsdec2 (EnumPtr->RootPath, p);
            if (!p) {
                DEBUGMSGA ((DBG_ERROR, "Path spec %s is incomplete", EnumPtr->RootPath));
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            if (_mbsnextc (p) == '\\') {
                *p = 0;
            }

            //
            // Initialize enumeration structure
            //

            EnumPtr->FilePatternSize = SizeOfStringA (EnumPtr->FilePattern);

            StringCopyA (EnumPtr->FileBuffer, EnumPtr->RootPath);
            EnumPtr->EndOfFileBuffer = GetEndOfStringA (EnumPtr->FileBuffer);

            StringCopyA (EnumPtr->Pattern, EnumPtr->RootPath);
            EnumPtr->EndOfPattern = GetEndOfStringA (EnumPtr->Pattern);

            EnumPtr->FullPath = EnumPtr->FileBuffer;

            EnumPtr->RootPathSize = ByteCountA (EnumPtr->RootPath);

            //
            // Allocate first find data sturct
            //

            EnumPtr->Current = (PFIND_DATAA) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAA)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

#ifdef DEBUG
            g_FileEnumResourcesInUse++;        // account for grow buffer
#endif

            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_BEGIN:
            //
            // Initialize current find data struct
            //

            EnumPtr->Current->SavedEndOfFileBuffer = EnumPtr->EndOfFileBuffer;
            EnumPtr->Current->SavedEndOfPattern = EnumPtr->EndOfPattern;

            //
            // Limit the length of the pattern string
            //

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) +
                    EnumPtr->FilePatternSize >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->FilePattern));

                EnumPtr->State = TREE_ENUM_POP;

                break;
            }

            //
            // Enuemrate the files or directories
            //

            if (EnumPtr->EnumDirsFirst) {
                EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
            } else {
                EnumPtr->State = TREE_ENUM_FILES_BEGIN;
            }
            break;

        case TREE_ENUM_FILES_BEGIN:
            //
            // Begin enumeration of files
            //

            StringCopyA (EnumPtr->EndOfPattern, "\\");
            StringCopyA (EnumPtr->EndOfPattern + 1, EnumPtr->FilePattern);

            EnumPtr->Current->FindHandle = FindFirstFileA (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                if (EnumPtr->EnumDirsFirst) {
                    EnumPtr->State = TREE_ENUM_POP;
                } else {
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                }
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif
                //
                // Skip directories
                //

                if (EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            }

            break;

        case TREE_ENUM_RETURN_ITEM:
            //
            // Update pointers to current item
            //

            EnumPtr->FindData = &EnumPtr->Current->FindData;
            EnumPtr->Name = EnumPtr->FindData->cFileName;
            EnumPtr->Directory = (EnumPtr->FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

            //
            // Limit the length of the resulting full path
            //

            if ((EnumPtr->EndOfFileBuffer - EnumPtr->FileBuffer) +
                    SizeOfStringA (EnumPtr->Name) >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                if (EnumPtr->Directory) {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                }

                break;
            }

            //
            // Generate the full path
            //

            StringCopyA (EnumPtr->EndOfFileBuffer, "\\");
            StringCopyA (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Name);

            if (EnumPtr->Directory) {
                if ((EnumPtr->MaxLevel == FILE_ENUM_ALL_LEVELS) ||
                    (EnumPtr->Level < EnumPtr->MaxLevel)
                    ) {
                    if (EnumPtr->EnumDepthFirst) {
                        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                    }
                    else {
                        EnumPtr->State = TREE_ENUM_PUSH;
                    }
                }
                else {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                }
            } else {
                EnumPtr->State = TREE_ENUM_FILES_NEXT;
            }

            EnumPtr->SubPath = (PCSTR) ((PBYTE) EnumPtr->FileBuffer + EnumPtr->RootPathSize);
            if (*EnumPtr->SubPath) {
                EnumPtr->SubPath++;
            }

            return TRUE;

        case TREE_ENUM_FILES_NEXT:
            if (FindNextFileA (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return files only
                //

                if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            } else {
                if (!EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_DIRS_FILTER:
            if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else if (StringMatchA (EnumPtr->Current->FindData.cFileName, ".") ||
                StringMatchA (EnumPtr->Current->FindData.cFileName, "..")
                ) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else {

                if (EnumPtr->EnumDepthFirst) {
                    EnumPtr->State = TREE_ENUM_PUSH;
                }
                else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }

            }
            break;

        case TREE_ENUM_DIRS_BEGIN:
            //
            // Begin enumeration of directories
            //

            StringCopyA (EnumPtr->EndOfPattern, "\\");
            StringCopyA (EnumPtr->EndOfPattern + 1, "*.*");

            EnumPtr->Current->FindHandle = FindFirstFileA (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                EnumPtr->State = TREE_ENUM_POP;
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;
            }

            break;

        case TREE_ENUM_DIRS_NEXT:
            if (FindNextFileA (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return directories only, then recurse into directory
                //

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;

            } else {
                //
                // Directory enumeration complete.
                //

                if (EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_FILES_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_PUSH:

            //
            // Limit the length of the resulting full path
            //

            if ((EnumPtr->EndOfFileBuffer - EnumPtr->FileBuffer) +
                    SizeOfStringA (EnumPtr->Current->FindData.cFileName) >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            //
            // Tack on directory name to strings and recalcuate end pointers
            //

            StringCopyA (EnumPtr->EndOfPattern + 1, EnumPtr->Current->FindData.cFileName);
            StringCopyA (EnumPtr->EndOfFileBuffer, "\\");
            StringCopyA (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Current->FindData.cFileName);

            EnumPtr->EndOfPattern = GetEndOfStringA (EnumPtr->EndOfPattern);
            EnumPtr->EndOfFileBuffer = GetEndOfStringA (EnumPtr->EndOfFileBuffer);

            //
            // Allocate another find data struct
            //

            EnumPtr->Current = (PFIND_DATAA) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAA)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            EnumPtr->Level++;
            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_POP:
            //
            // Free the current resources
            //

            pTrackedFindClose (EnumPtr->Current->FindHandle);
            EnumPtr->Level--;

            //
            // Get the previous find data struct
            //

            MYASSERT (EnumPtr->FindDataArray.End >= sizeof (FIND_DATAA));
            EnumPtr->FindDataArray.End -= sizeof (FIND_DATAA);
            if (!EnumPtr->FindDataArray.End) {
                EnumPtr->State = TREE_ENUM_DONE;
                break;
            }

            EnumPtr->Current = (PFIND_DATAA) (EnumPtr->FindDataArray.Buf +
                                              (EnumPtr->FindDataArray.End - sizeof (FIND_DATAA)));

            //
            // Restore the settings of the parent directory
            //

            EnumPtr->EndOfPattern = EnumPtr->Current->SavedEndOfPattern;
            EnumPtr->EndOfFileBuffer = EnumPtr->Current->SavedEndOfFileBuffer;

            if (EnumPtr->EnumDepthFirst) {
                EnumPtr->State = TREE_ENUM_RETURN_ITEM;
            }
            else {
                EnumPtr->State = TREE_ENUM_DIRS_NEXT;
            }
            break;

        case TREE_ENUM_DONE:
            AbortEnumFileInTreeA (EnumPtr);
            SetLastError (ERROR_SUCCESS);
            return FALSE;

        case TREE_ENUM_FAILED:
            PushError();
            AbortEnumFileInTreeA (EnumPtr);
            PopError();
            return FALSE;

        case TREE_ENUM_CLEANED_UP:
            return FALSE;
        }
    }
}


BOOL
EnumNextFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    )
{
    PWSTR p;

    for (;;) {
        switch (EnumPtr->State) {

        case TREE_ENUM_INIT:

            //
            // Get rid of wack at the end of root path, if it exists
            //

            p = GetEndOfStringW (EnumPtr->RootPath);
            p = _wcsdec2 (EnumPtr->RootPath, p);
            if (!p) {
                DEBUGMSG ((DBG_ERROR, "Path spec %ls is incomplete", EnumPtr->RootPath));
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            if (*p == L'\\') {
                *p = 0;
            }

            //
            // Initialize enumeration structure
            //

            EnumPtr->FilePatternSize = SizeOfStringW (EnumPtr->FilePattern);

            StringCopyW (EnumPtr->FileBuffer, EnumPtr->RootPath);
            EnumPtr->EndOfFileBuffer = GetEndOfStringW (EnumPtr->FileBuffer);

            StringCopyW (EnumPtr->Pattern, EnumPtr->RootPath);
            EnumPtr->EndOfPattern = GetEndOfStringW (EnumPtr->Pattern);

            EnumPtr->FullPath = EnumPtr->FileBuffer;

            EnumPtr->RootPathSize = ByteCountW (EnumPtr->RootPath);

            //
            // Allocate first find data sturct
            //

            EnumPtr->Current = (PFIND_DATAW) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAW)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

#ifdef DEBUG
            g_FileEnumResourcesInUse++;        // account for grow buffer
#endif

            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_BEGIN:
            //
            // Initialize current find data struct
            //

            EnumPtr->Current->SavedEndOfFileBuffer = EnumPtr->EndOfFileBuffer;
            EnumPtr->Current->SavedEndOfPattern = EnumPtr->EndOfPattern;

            //
            // Limit the length of the pattern string
            //

            if (((PBYTE) EnumPtr->EndOfPattern - (PBYTE) EnumPtr->Pattern) +
                    EnumPtr->FilePatternSize >= (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->FilePattern));

                EnumPtr->State = TREE_ENUM_POP;

                break;
            }

            //
            // Enuemrate the files or directories
            //

            if (EnumPtr->EnumDirsFirst) {
                EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
            } else {
                EnumPtr->State = TREE_ENUM_FILES_BEGIN;
            }
            break;

        case TREE_ENUM_FILES_BEGIN:
            //
            // Begin enumeration of files
            //

            StringCopyW (EnumPtr->EndOfPattern, L"\\");
            StringCopyW (EnumPtr->EndOfPattern + 1, EnumPtr->FilePattern);

            EnumPtr->Current->FindHandle = FindFirstFileW (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                if (EnumPtr->EnumDirsFirst) {
                    EnumPtr->State = TREE_ENUM_POP;
                } else {
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                }
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif
                //
                // Skip directories
                //

                if (EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            }

            break;

        case TREE_ENUM_RETURN_ITEM:
            //
            // Update pointers to current item
            //

            EnumPtr->FindData = &EnumPtr->Current->FindData;
            EnumPtr->Name = EnumPtr->FindData->cFileName;
            EnumPtr->Directory = (EnumPtr->FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

            //
            // Limit the length of the resulting full path
            //

            if (((PBYTE) EnumPtr->EndOfFileBuffer - (PBYTE) EnumPtr->FileBuffer) +
                    SizeOfStringW (EnumPtr->Name) >= (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                if (EnumPtr->Directory) {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                }

                break;
            }

            //
            // Generate the full path
            //

            StringCopyW (EnumPtr->EndOfFileBuffer, L"\\");
            StringCopyW (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Name);

            if (EnumPtr->Directory) {
                if ((EnumPtr->MaxLevel == FILE_ENUM_ALL_LEVELS) ||
                    (EnumPtr->Level < EnumPtr->MaxLevel)
                    ) {
                    if (EnumPtr->EnumDepthFirst) {
                        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                    }
                    else {
                        EnumPtr->State = TREE_ENUM_PUSH;
                    }
                }
                else {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                }
            } else {
                EnumPtr->State = TREE_ENUM_FILES_NEXT;
            }

            EnumPtr->SubPath = (PCWSTR) ((PBYTE) EnumPtr->FileBuffer + EnumPtr->RootPathSize);
            if (*EnumPtr->SubPath) {
                EnumPtr->SubPath++;
            }

            return TRUE;

        case TREE_ENUM_FILES_NEXT:
            if (FindNextFileW (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return files only
                //

                if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            } else {
                if (!EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_DIRS_FILTER:
            if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else if (StringMatchW (EnumPtr->Current->FindData.cFileName, L".") ||
                       StringMatchW (EnumPtr->Current->FindData.cFileName, L"..")
                       ) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else {

                if (EnumPtr->EnumDepthFirst) {
                    EnumPtr->State = TREE_ENUM_PUSH;
                }
                else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }

            }
            break;

        case TREE_ENUM_DIRS_BEGIN:
            //
            // Begin enumeration of directories
            //

            StringCopyW (EnumPtr->EndOfPattern, L"\\*.*");

            EnumPtr->Current->FindHandle = FindFirstFileW (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                EnumPtr->State = TREE_ENUM_POP;
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;
            }

            break;

        case TREE_ENUM_DIRS_NEXT:
            if (FindNextFileW (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return directories only, then recurse into directory
                //

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;

            } else {
                //
                // Directory enumeration complete.
                //

                if (EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_FILES_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_PUSH:

            //
            // Limit the length of the resulting full path
            //

            if (((PBYTE) EnumPtr->EndOfFileBuffer - (PBYTE) EnumPtr->FileBuffer) +
                    SizeOfStringW (EnumPtr->Current->FindData.cFileName) >= (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            //
            // Tack on directory name to strings and recalcuate end pointers
            //

            StringCopyW (EnumPtr->EndOfPattern + 1, EnumPtr->Current->FindData.cFileName);
            StringCopyW (EnumPtr->EndOfFileBuffer, L"\\");
            StringCopyW (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Current->FindData.cFileName);

            EnumPtr->EndOfPattern = GetEndOfStringW (EnumPtr->EndOfPattern);
            EnumPtr->EndOfFileBuffer = GetEndOfStringW (EnumPtr->EndOfFileBuffer);

            //
            // Allocate another find data struct
            //

            EnumPtr->Current = (PFIND_DATAW) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAW)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            EnumPtr->Level++;
            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_POP:
            //
            // Free the current resources
            //

            pTrackedFindClose (EnumPtr->Current->FindHandle);
            EnumPtr->Level--;

            //
            // Get the previous find data struct
            //

            MYASSERT (EnumPtr->FindDataArray.End >= sizeof (FIND_DATAW));
            EnumPtr->FindDataArray.End -= sizeof (FIND_DATAW);
            if (!EnumPtr->FindDataArray.End) {
                EnumPtr->State = TREE_ENUM_DONE;
                break;
            }

            EnumPtr->Current = (PFIND_DATAW) (EnumPtr->FindDataArray.Buf +
                                              (EnumPtr->FindDataArray.End - sizeof (FIND_DATAW)));

            //
            // Restore the settings of the parent directory
            //

            EnumPtr->EndOfPattern = EnumPtr->Current->SavedEndOfPattern;
            EnumPtr->EndOfFileBuffer = EnumPtr->Current->SavedEndOfFileBuffer;

            if (EnumPtr->EnumDepthFirst) {
                EnumPtr->State = TREE_ENUM_RETURN_ITEM;
            }
            else {
                EnumPtr->State = TREE_ENUM_DIRS_NEXT;
            }
            break;

        case TREE_ENUM_DONE:
            AbortEnumFileInTreeW (EnumPtr);
            SetLastError (ERROR_SUCCESS);
            return FALSE;

        case TREE_ENUM_FAILED:
            PushError();
            AbortEnumFileInTreeW (EnumPtr);
            PopError();
            return FALSE;

        case TREE_ENUM_CLEANED_UP:
            return FALSE;
        }
    }
}


VOID
AbortEnumFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    )

/*++

Routine Description:

  AbortEnumFileInTree cleans up all resources used by an enumeration started
  by EnumFirstFileInTree.  This routine must be called if file enumeration
  will not be completed by calling EnumNextFileInTree until it returns FALSE.

  If EnumNextFileInTree returns FALSE, it is unnecessary to call this
  function.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives the enumerated file
            or directory

Return Value:

  none

--*/

{
    UINT Pos;
    PGROWBUFFER g;
    PFIND_DATAA Current;

    if (EnumPtr->State == TREE_ENUM_CLEANED_UP) {
        return;
    }

    //
    // Close any currently open handles
    //

    g = &EnumPtr->FindDataArray;
    for (Pos = 0 ; Pos < g->End ; Pos += sizeof (FIND_DATAA)) {
        Current = (PFIND_DATAA) (g->Buf + Pos);
        pTrackedFindClose (Current->FindHandle);
    }

    FreeGrowBuffer (&EnumPtr->FindDataArray);

#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    EnumPtr->State = TREE_ENUM_CLEANED_UP;
}


VOID
AbortEnumFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    )
{
    UINT Pos;
    PGROWBUFFER g;
    PFIND_DATAW Current;

    if (EnumPtr->State == TREE_ENUM_CLEANED_UP) {
        return;
    }

    //
    // Close any currently open handles
    //

    g = &EnumPtr->FindDataArray;
    for (Pos = 0 ; Pos < g->End ; Pos += sizeof (FIND_DATAW)) {
        Current = (PFIND_DATAW) (g->Buf + Pos);
        pTrackedFindClose (Current->FindHandle);
    }

    FreeGrowBuffer (&EnumPtr->FindDataArray);

#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    EnumPtr->State = TREE_ENUM_CLEANED_UP;
}


VOID
AbortEnumCurrentDirA (
    IN OUT  PTREE_ENUMA EnumPtr
    )
{
    if (EnumPtr->State == TREE_ENUM_PUSH) {
        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
    }
}


VOID
AbortEnumCurrentDirW (
    IN OUT  PTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == TREE_ENUM_PUSH) {
        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
    }
}


BOOL
EnumFirstFileA (
    OUT     PFILE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern           OPTIONAL
    )
{
    ZeroMemory (EnumPtr, sizeof (FILE_ENUMA));

    EnumPtr->FileName = EnumPtr->fd.cFileName;
    EnumPtr->FullPath = EnumPtr->RootPath;

    StringCopyA (EnumPtr->RootPath, RootPath);
    EnumPtr->EndOfRoot = AppendWackA (EnumPtr->RootPath);
    StringCopyA (EnumPtr->EndOfRoot, FilePattern ? FilePattern : "*.*");

    EnumPtr->Handle = FindFirstFileA (EnumPtr->RootPath, &EnumPtr->fd);

    if (EnumPtr->Handle != INVALID_HANDLE_VALUE) {

        if (StringMatchA (EnumPtr->FileName, ".") ||
            StringMatchA (EnumPtr->FileName, "..")
            ) {
            return EnumNextFileA (EnumPtr);
        }

        StringCopyA (EnumPtr->EndOfRoot, EnumPtr->FileName);
        EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        return TRUE;
    }

    return FALSE;
}


BOOL
EnumFirstFileW (
    OUT     PFILE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern           OPTIONAL
    )
{
    ZeroMemory (EnumPtr, sizeof (FILE_ENUMW));

    EnumPtr->FileName = EnumPtr->fd.cFileName;
    EnumPtr->FullPath = EnumPtr->RootPath;

    StringCopyW (EnumPtr->RootPath, RootPath);
    EnumPtr->EndOfRoot = AppendWackW (EnumPtr->RootPath);
    StringCopyW (EnumPtr->EndOfRoot, FilePattern ? FilePattern : L"*.*");

    EnumPtr->Handle = FindFirstFileW (EnumPtr->RootPath, &EnumPtr->fd);

    if (EnumPtr->Handle != INVALID_HANDLE_VALUE) {

        if (StringMatchW (EnumPtr->FileName, L".") ||
            StringMatchW (EnumPtr->FileName, L"..")
            ) {
            return EnumNextFileW (EnumPtr);
        }

        StringCopyW (EnumPtr->EndOfRoot, EnumPtr->FileName);
        EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        return TRUE;
    }

    return FALSE;
}


BOOL
EnumNextFileA (
    IN OUT  PFILE_ENUMA EnumPtr
    )
{
    do {
        if (!FindNextFileA (EnumPtr->Handle, &EnumPtr->fd)) {
            AbortFileEnumA (EnumPtr);
            return FALSE;
        }
    } while (StringMatchA (EnumPtr->FileName, ".") ||
             StringMatchA (EnumPtr->FileName, "..")
             );

    StringCopyA (EnumPtr->EndOfRoot, EnumPtr->FileName);
    EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    return TRUE;
}


BOOL
EnumNextFileW (
    IN OUT  PFILE_ENUMW EnumPtr
    )
{
    do {
        if (!FindNextFileW (EnumPtr->Handle, &EnumPtr->fd)) {
            AbortFileEnumW (EnumPtr);
            return FALSE;
        }
    } while (StringMatchW (EnumPtr->FileName, L".") ||
             StringMatchW (EnumPtr->FileName, L"..")
             );

    if (!FindNextFileW (EnumPtr->Handle, &EnumPtr->fd)) {
        AbortFileEnumW (EnumPtr);
        return FALSE;
    }

    StringCopyW (EnumPtr->EndOfRoot, EnumPtr->FileName);
    EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    return TRUE;
}


VOID
AbortFileEnumA (
    IN OUT  PFILE_ENUMA EnumPtr
    )
{
    if (EnumPtr->Handle && EnumPtr->Handle != INVALID_HANDLE_VALUE) {
        FindClose (EnumPtr->Handle);
        ZeroMemory (EnumPtr, sizeof (FILE_ENUMA));
    }
}


VOID
AbortFileEnumW (
    IN OUT  PFILE_ENUMW EnumPtr
    )
{
    if (EnumPtr->Handle && EnumPtr->Handle != INVALID_HANDLE_VALUE) {
        FindClose (EnumPtr->Handle);
        ZeroMemory (EnumPtr, sizeof (FILE_ENUMW));
    }
}






/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )
{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingA (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )
{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingW (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - image of the mapped file as returned by MapFileIntoMemory
  MapHandle - handle of the mapping object as returned by MapFileIntoMemory
  FileHandle - handle of the file as returned by MapFileIntoMemory

Return Value:

  TRUE if successfull, FALSE if not

--*/

BOOL
UnmapFile (
    IN PVOID  FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )
{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}


BOOL
RemoveCompleteDirectoryA (
    IN      PCSTR Dir
    )
{
    TREE_ENUMA e;
    BOOL b = TRUE;
    CHAR CurDir[MAX_MBCHAR_PATH];
    CHAR NewDir[MAX_MBCHAR_PATH];
    LONG rc = ERROR_SUCCESS;
    DWORD Attribs;

    Attribs = GetFileAttributesA (Dir);

    if (Attribs == INVALID_ATTRIBUTES) {
        return TRUE;
    }

    if (!(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
        SetFileAttributesA (Dir, FILE_ATTRIBUTE_NORMAL);
        return DeleteFileA (Dir);
    }

    GetCurrentDirectoryA (MAX_MBCHAR_PATH, CurDir);
    SetCurrentDirectoryA (Dir);
    GetCurrentDirectoryA (MAX_MBCHAR_PATH, NewDir);

    if (EnumFirstFileInTreeA (&e, NewDir, NULL, FALSE)) {
        do {
            if (!e.Directory) {
                SetFileAttributesA (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFileA (e.FullPath)) {
                    DEBUGMSGA ((DBG_ERROR, "Can't delete %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (EnumFirstFileInTreeExA (&e, NewDir, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {
        do {
            if (e.Directory) {
                SetFileAttributesA (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!RemoveDirectoryA (e.FullPath)) {
                    DEBUGMSGA ((DBG_ERROR, "Can't remove %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (b) {
        SetFileAttributesA (NewDir, FILE_ATTRIBUTE_NORMAL);
        SetCurrentDirectoryA ("..");
        b = RemoveDirectoryA (NewDir);
    }

    if (!b && rc == ERROR_SUCCESS) {
        rc = GetLastError();
    }

    SetCurrentDirectoryA (CurDir);

    SetLastError (rc);
    return b;
}


BOOL
RemoveCompleteDirectoryW (
    IN      PCWSTR Dir
    )
{
    TREE_ENUMW e;
    BOOL b = TRUE;
    WCHAR CurDir[MAX_WCHAR_PATH];
    WCHAR NewDir[MAX_WCHAR_PATH];
    LONG rc = ERROR_SUCCESS;
    DWORD Attribs;

    Attribs = GetLongPathAttributesW (Dir);

    if (Attribs == INVALID_ATTRIBUTES) {
        return TRUE;
    }

    if (!(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
        SetLongPathAttributesW (Dir, FILE_ATTRIBUTE_NORMAL);
        return DeleteLongPathW (Dir);
    }

    GetCurrentDirectoryW (MAX_WCHAR_PATH, CurDir);
    SetCurrentDirectoryW (Dir);
    GetCurrentDirectoryW (MAX_WCHAR_PATH, NewDir);

    if (EnumFirstFileInTreeW (&e, NewDir, NULL, FALSE)) {
        do {
            if (!e.Directory) {
                SetLongPathAttributesW (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteLongPathW (e.FullPath)) {
                    DEBUGMSGW ((DBG_ERROR, "Can't delete %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (EnumFirstFileInTreeExW (&e, NewDir, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {
        do {
            if (e.Directory) {
                SetLongPathAttributesW (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!RemoveDirectoryW (e.FullPath)) {
                    DEBUGMSGW ((DBG_ERROR, "Can't remove %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (b) {
        SetLongPathAttributesW (NewDir, FILE_ATTRIBUTE_NORMAL);
        SetCurrentDirectoryW (L"..");
        b = RemoveDirectoryW (NewDir);
    }

    if (!b && rc == ERROR_SUCCESS) {
        rc = GetLastError();
    }

    SetCurrentDirectoryW (CurDir);

    SetLastError (rc);
    return b;
}


PCMDLINEA
ParseCmdLineA (
    IN      PCSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    )
{
    GROWBUFFER SpacePtrs = GROWBUF_INIT;
    PCSTR p;
    PSTR q;
    INT Count;
    INT i;
    INT j;
    PSTR *Array;
    PCSTR Start;
    CHAR OldChar = 0;
    GROWBUFFER StringBuf = GROWBUF_INIT;
    PBYTE CopyBuf;
    PCMDLINEA CmdLineTable;
    PCMDLINEARGA CmdLineArg;
    UINT Base;
    CHAR Path[MAX_MBCHAR_PATH];
    CHAR UnquotedPath[MAX_MBCHAR_PATH];
    CHAR FixedFileName[MAX_MBCHAR_PATH];
    PCSTR FullPath = NULL;
    DWORD Attribs = INVALID_ATTRIBUTES;
    PSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PSTR DontCare;
    CHAR FirstArgPath[MAX_MBCHAR_PATH];
    PSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PSTR End;

    CmdLineCopy = DuplicateTextA (CmdLine);

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p = _mbsinc (p)) {

        if (_mbsnextc (p) == '\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode && (_mbsnextc (p) == ' ' || _mbsnextc (p) == '=')) {

            //
            // Remove excess spaces
            //

            q = (PSTR) p + 1;
            while (_mbsnextc (q) == ' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (CHAR), q, SizeOfStringA (q));
            }

            GrowBufAppendDword (&SpacePtrs, (DWORD) p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEA) GrowBuffer (Buffer, sizeof (CMDLINEA));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCSTR) StringBuf.End;
    MultiSzAppendA (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (DWORD);
    Array = (PSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (_mbsnextc (Start) != '/') {

            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (_mbsnextc (Start) == '\"') {

                    StringCopyByteCountA (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                    q = _mbschr (UnquotedPath, '\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    Attribs = GetFileAttributesA (FullPath);

                    if (Attribs == INVALID_ATTRIBUTES && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountA (
                            EndOfFirstArg,
                            FullPath,
                            sizeof (FirstArgPath) - ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        Attribs = GetFileAttributesA (FullPath);
                    }

                    if (Attribs == INVALID_ATTRIBUTES && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountA (
                            FixedFileName,
                            FullPath,
                            sizeof (FixedFileName) - sizeof (".exe")
                            );

                        q = GetEndOfStringA (FixedFileName);
                        q = _mbsdec (FixedFileName, q);
                        MYASSERT (q);

                        if (_mbsnextc (q) != '.') {
                            q = _mbsinc (q);
                        }

                        StringCopyA (q, ".exe");

                        FullPath = FixedFileName;
                        Attribs = GetFileAttributesA (FullPath);
                    }

                    if (Attribs != INVALID_ATTRIBUTES) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        MultiSzAppendA (&StringBuf, Start);

                        if (!StringMatchA (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            MultiSzAppendA (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (_mbschr (Start, '\\')) {
#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGA ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // SearchPath.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (_mbsnextc (Start) == '\"') {

                            StringCopyByteCountA (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                            q = _mbschr (UnquotedPath, '\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (SearchPathA (
                                    NULL,
                                    FullPath,
                                    NULL,
                                    sizeof (Path) / sizeof (Path[0]),
                                    Path,
                                    &DontCare
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountA (
                                    FixedFileName,
                                    FullPath,
                                    sizeof (FixedFileName) - sizeof (".exe")
                                    );

                                q = GetEndOfStringA (FixedFileName);
                                q = _mbsdec (FixedFileName, q);
                                MYASSERT (q);

                                if (_mbsnextc (q) != '.') {
                                    q = _mbsinc (q);
                                }

                                StringCopyA (q, ".exe");

                                if (SearchPathA (
                                        NULL,
                                        FixedFileName,
                                        NULL,
                                        sizeof (Path) / sizeof (Path[0]),
                                        Path,
                                        &DontCare
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }

                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            Attribs = GetFileAttributesA (FullPath);
                            MYASSERT (Attribs != INVALID_ATTRIBUTES);

                            OriginalArgOffset = StringBuf.End;
                            MultiSzAppendA (&StringBuf, Start);

                            if (!StringMatchA (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                MultiSzAppendA (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGA) GrowBuffer (Buffer, sizeof (CMDLINEARGA));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its attributes
            // are in Attribs, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCSTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCSTR) CleanedUpArgOffset;
            CmdLineArg->Attributes = Attribs;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountA (FirstArgPath, (PCSTR) (StringBuf.Buf + (UINT) CmdLineArg->CleanedUpArg), sizeof (FirstArgPath));
                q = (PSTR) GetFileNameFromPathA (FirstArgPath);
                if (q) {
                    q = _mbsdec (FirstArgPath, q);
                    if (q) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackA (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCSTR) StringBuf.End;
                MultiSzAppendA (&StringBuf, Start);

                Quoted = FALSE;

                if (_mbschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PSTR) ((PBYTE) UnquotedPath + sizeof (UnquotedPath) - sizeof (CHAR));

                    while (*p && q < End) {
                        if (IsLeadByte (*p)) {
                            *q++ = *p++;
                            *q++ = *p++;
                        } else {
                            if (*p == '\"') {
                                p++;
                            } else {
                                *q++ = *p++;
                            }
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCSTR) StringBuf.End;
                    MultiSzAppendA (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Attributes = INVALID_ATTRIBUTES;
                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GrowBuffer (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (UINT) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    CmdLineTable->CmdLine = (PCSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    FreeGrowBuffer (&StringBuf);
    FreeGrowBuffer (&SpacePtrs);

    return (PCMDLINEA) Buffer->Buf;
}


PCMDLINEW
ParseCmdLineW (
    IN      PCWSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    )
{
    GROWBUFFER SpacePtrs = GROWBUF_INIT;
    PCWSTR p;
    PWSTR q;
    INT Count;
    INT i;
    INT j;
    PWSTR *Array;
    PCWSTR Start;
    WCHAR OldChar = 0;
    GROWBUFFER StringBuf = GROWBUF_INIT;
    PBYTE CopyBuf;
    PCMDLINEW CmdLineTable;
    PCMDLINEARGW CmdLineArg;
    UINT Base;
    WCHAR Path[MAX_WCHAR_PATH];
    WCHAR UnquotedPath[MAX_WCHAR_PATH];
    WCHAR FixedFileName[MAX_WCHAR_PATH];
    PCWSTR FullPath = NULL;
    DWORD Attribs = INVALID_ATTRIBUTES;
    PWSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PWSTR DontCare;
    WCHAR FirstArgPath[MAX_MBCHAR_PATH];
    PWSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PWSTR End;

    CmdLineCopy = DuplicateTextW (CmdLine);

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p++) {
        if (*p == L'\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode && (*p == L' ' || *p == L'=')) {

            //
            // Remove excess spaces
            //

            q = (PWSTR) p + 1;
            while (*q == L' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (WCHAR), q, SizeOfStringW (q));
            }

            GrowBufAppendDword (&SpacePtrs, (DWORD) p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEW) GrowBuffer (Buffer, sizeof (CMDLINEW));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCWSTR) StringBuf.End;
    MultiSzAppendW (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (DWORD);
    Array = (PWSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (*Start != L'/') {
            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (*Start == L'\"') {

                    StringCopyByteCountW (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                    q = wcschr (UnquotedPath, L'\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    Attribs = GetLongPathAttributesW (FullPath);

                    if (Attribs == INVALID_ATTRIBUTES && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountW (
                            EndOfFirstArg,
                            FullPath,
                            sizeof (FirstArgPath) - ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        Attribs = GetLongPathAttributesW (FullPath);
                    }

                    if (Attribs == INVALID_ATTRIBUTES && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountW (
                            FixedFileName,
                            FullPath,
                            sizeof (FixedFileName) - sizeof (L".exe")
                            );

                        q = GetEndOfStringW (FixedFileName);
                        q--;
                        MYASSERT (q >= FixedFileName);

                        if (*q != L'.') {
                            q++;
                        }

                        StringCopyW (q, L".exe");

                        FullPath = FixedFileName;
                        Attribs = GetLongPathAttributesW (FullPath);
                    }

                    if (Attribs != INVALID_ATTRIBUTES) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        MultiSzAppendW (&StringBuf, Start);

                        if (!StringMatchW (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            MultiSzAppendW (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (wcschr (Start, L'\\')) {

#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGW ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // SearchPath.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (*Start == L'\"') {

                            StringCopyByteCountW (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                            q = wcschr (UnquotedPath, L'\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (SearchPathW (
                                    NULL,
                                    FullPath,
                                    NULL,
                                    sizeof (Path) / sizeof (Path[0]),
                                    Path,
                                    &DontCare
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountW (
                                    FixedFileName,
                                    FullPath,
                                    sizeof (FixedFileName) - sizeof (L".exe")
                                    );

                                q = GetEndOfStringW (FixedFileName);
                                q--;
                                MYASSERT (q >= FixedFileName);

                                if (*q != L'.') {
                                    q++;
                                }

                                StringCopyW (q, L".exe");

                                if (SearchPathW (
                                        NULL,
                                        FixedFileName,
                                        NULL,
                                        sizeof (Path) / sizeof (Path[0]),
                                        Path,
                                        &DontCare
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }
                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            Attribs = GetLongPathAttributesW (FullPath);
                            MYASSERT (Attribs != INVALID_ATTRIBUTES);

                            OriginalArgOffset = StringBuf.End;
                            MultiSzAppendW (&StringBuf, Start);

                            if (!StringMatchW (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                MultiSzAppendW (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGW) GrowBuffer (Buffer, sizeof (CMDLINEARGW));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its attributes
            // are in Attribs, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCWSTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCWSTR) CleanedUpArgOffset;
            CmdLineArg->Attributes = Attribs;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountW (FirstArgPath, (PCWSTR) (StringBuf.Buf + (UINT) CmdLineArg->CleanedUpArg), sizeof (FirstArgPath));
                q = (PWSTR) GetFileNameFromPathW (FirstArgPath);
                if (q) {
                    q--;
                    if (q >= FirstArgPath) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackW (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCWSTR) StringBuf.End;
                MultiSzAppendW (&StringBuf, Start);

                Quoted = FALSE;
                if (wcschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PWSTR) ((PBYTE) UnquotedPath + sizeof (UnquotedPath) - sizeof (WCHAR));

                    while (*p && q < End) {
                        if (*p == L'\"') {
                            p++;
                        } else {
                            *q++ = *p++;
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCWSTR) StringBuf.End;
                    MultiSzAppendW (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Attributes = INVALID_ATTRIBUTES;
                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GrowBuffer (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (UINT) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    CmdLineTable->CmdLine = (PCWSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCWSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCWSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    FreeGrowBuffer (&StringBuf);
    FreeGrowBuffer (&SpacePtrs);

    return (PCMDLINEW) Buffer->Buf;
}

BOOL
GetFileSizeFromFilePathA(
    IN  PCSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    )
{
    WIN32_FILE_ATTRIBUTE_DATA fileDataAttributes;

    if(!FilePath || !FileSize){
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!IsPathOnFixedDriveA (FilePath)) {
        FileSize->QuadPart = 0;
        MYASSERT(FALSE);
        return FALSE;
    }

    if(!GetFileAttributesExA(FilePath, GetFileExInfoStandard, &fileDataAttributes) ||
       fileDataAttributes.dwFileAttributes == INVALID_ATTRIBUTES ||
       (fileDataAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
        MYASSERT(FALSE);
        return FALSE;
    }

    FileSize->LowPart = fileDataAttributes.nFileSizeLow;
    FileSize->HighPart = fileDataAttributes.nFileSizeHigh;

    return TRUE;
}

BOOL
GetFileSizeFromFilePathW(
    IN  PCWSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    )
{
    WIN32_FILE_ATTRIBUTE_DATA fileDataAttributes;

    if(!FilePath || !FileSize){
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!IsPathOnFixedDriveW (FilePath)) {
        FileSize->QuadPart = 0;
        MYASSERT(FALSE);
        return FALSE;
    }

    if(!GetFileAttributesExW(FilePath, GetFileExInfoStandard, &fileDataAttributes) ||
       fileDataAttributes.dwFileAttributes == INVALID_ATTRIBUTES ||
       (fileDataAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
        MYASSERT(FALSE);
        return FALSE;
    }

    FileSize->LowPart = fileDataAttributes.nFileSizeLow;
    FileSize->HighPart = fileDataAttributes.nFileSizeHigh;

    return TRUE;
}


VOID
InitializeDriveLetterStructureA (
    OUT     PDRIVELETTERSA DriveLetters
    )
{
    BYTE bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    CHAR rootPath[] = "?:\\";
    BOOL driveExists;
    UINT type;

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize this drive
        //

        DriveLetters->ExistsOnSystem[bitPosition] = FALSE;
        DriveLetters->Type[bitPosition] = 0;
        DriveLetters->IdentifierString[bitPosition][0] = 0;

        rootPath[0] = 'A' + bitPosition;
        DriveLetters->Letter[bitPosition] = rootPath[0];

        //
        // Determine if there is a drive in this spot.
        //
        driveExists = GetLogicalDrives() & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            type = GetDriveTypeA(rootPath);

            if (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                DriveLetters->ExistsOnSystem[bitPosition] = TRUE;
                DriveLetters->Type[bitPosition] = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }
}



VOID
InitializeDriveLetterStructureW (
    OUT     PDRIVELETTERSW DriveLetters
    )
{
    BYTE bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    WCHAR rootPath[] = L"?:\\";
    BOOL driveExists;
    UINT type;

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize this drive
        //

        DriveLetters->ExistsOnSystem[bitPosition] = FALSE;
        DriveLetters->Type[bitPosition] = 0;
        DriveLetters->IdentifierString[bitPosition][0] = 0;

        rootPath[0] = L'A' + bitPosition;
        DriveLetters->Letter[bitPosition] = rootPath[0];

        //
        // Determine if there is a drive in this spot.
        //
        driveExists = GetLogicalDrives() & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            type = GetDriveTypeW(rootPath);

            if (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                DriveLetters->ExistsOnSystem[bitPosition] = TRUE;
                DriveLetters->Type[bitPosition] = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }
}

typedef BOOL (WINAPI * GETDISKFREESPACEEXA)(
  PCSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

typedef BOOL (WINAPI * GETDISKFREESPACEEXW)(
  PCWSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

BOOL
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  On Win9x GetDiskFreeSpace never return free/total space more than 2048MB.
  GetDiskFreeSpaceNew use GetDiskFreeSpaceEx to calculate real number of free/total clusters.
  Has same  declaration as GetDiskFreeSpaceA.

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXA pGetDiskFreeSpaceExA;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceA(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DEBUGMSG((DBG_ERROR,"GetDiskFreeSpaceNewA: GetDiskFreeSpaceA failed on drive %s", DriveName));
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExA = (GETDISKFREESPACEEXA)GetProcAddress(hKernel32, "GetDiskFreeSpaceExA");
    if(pGetDiskFreeSpaceExA &&
       pGetDiskFreeSpaceExA(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DEBUGMSG((DBG_WARNING,
                  pGetDiskFreeSpaceExA?
                    "GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA is failed":
                    "GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA function is not in kernel32.dll"));
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    DEBUGMSG((DBG_VERBOSE,
              "GetDiskFreeSpaceNewA: \n\t"
                "SectorsPerCluster = %d\n\t"
                "BytesPerSector = %d\n\t"
                "NumberOfFreeClusters = %I64u\n\t"
                "TotalNumberOfClusters = %I64u",
                SectorsPerCluster,
                BytesPerSector,
                NumberOfFreeClusters.QuadPart,
                TotalNumberOfClusters.QuadPart));

    return TRUE;
}

BOOL
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  Correct NumberOfFreeClusters and TotalNumberOfClusters out parameters
  with using GetDiskFreeSpace and GetDiskFreeSpaceEx

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXW pGetDiskFreeSpaceExW;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceW(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DEBUGMSG((DBG_ERROR,"GetDiskFreeSpaceNewW: GetDiskFreeSpaceW failed on drive %s", DriveName));
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExW = (GETDISKFREESPACEEXW)GetProcAddress(hKernel32, "GetDiskFreeSpaceExW");
    if(pGetDiskFreeSpaceExW &&
       pGetDiskFreeSpaceExW(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DEBUGMSG((DBG_WARNING,
                  pGetDiskFreeSpaceExW?
                    "GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW is failed":
                    "GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW function is not in kernel32.dll"));
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    DEBUGMSG((DBG_VERBOSE,
              "GetDiskFreeSpaceNewW: \n\t"
                "SectorsPerCluster = %d\n\t"
                "BytesPerSector = %d\n\t"
                "NumberOfFreeClusters = %I64u\n\t"
                "TotalNumberOfClusters = %I64u",
                SectorsPerCluster,
                BytesPerSector,
                NumberOfFreeClusters.QuadPart,
                TotalNumberOfClusters.QuadPart));

    return TRUE;
}

DWORD
QuietGetFileAttributesA (
    IN      PCSTR FilePath
    )
{
    if (!IsPathOnFixedDriveA (FilePath)) {
        return INVALID_ATTRIBUTES;
    }

    return GetFileAttributesA (FilePath);
}

DWORD
QuietGetFileAttributesW (
    IN      PCWSTR FilePath
    )
{
    MYASSERT (ISNT());

    if (!IsPathOnFixedDriveW (FilePath)) {
        return INVALID_ATTRIBUTES;
    }

    return GetLongPathAttributesW (FilePath);
}


DWORD
MakeSureLongPathExistsW (
    IN      PCWSTR Path,
    IN      BOOL PathOnly
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = MakeSurePathExistsW (Path, PathOnly);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = MakeSurePathExistsW (tmp, PathOnly);
        FreePathStringW (tmp);
    }

    return result;
}


DWORD
SetLongPathAttributesW (
    IN      PCWSTR Path,
    IN      DWORD Attributes
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = SetFileAttributesW (Path, Attributes);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = SetFileAttributesW (tmp, Attributes);
        FreePathStringW (tmp);
    }

    return result;
}


DWORD
GetLongPathAttributesW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = GetFileAttributesW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = GetFileAttributesW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}


BOOL
DeleteLongPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    BOOL result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = DeleteFileW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = DeleteFileW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}


BOOL
RemoveLongDirectoryPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    BOOL result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = RemoveDirectoryW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = RemoveDirectoryW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    BOOL CaseSensitive;
    POOLHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    PBUCKETITEM DelayedDelete;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
HtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  if all strings should be stored and compared in lower-case
                  only

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    POOLHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PoolMemInitNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    PoolMemDisableTracking (pool);

    hashTable = (PHASHTABLESTRUCT) PoolMemGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->CaseSensitive = CaseSensitive;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PoolMemEmptyPool (table->Pool);
        PoolMemDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is already lower case
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.
  PrevBucketItem    - Receives the previous bucket item

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        (void) CharLowerA (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        (void) _wcslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  BufferEnd        - Specifies the end of the string buffer, which may be longer
                     than all entries in the hash table, or it may be shorter.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is in lower-case, FALSE otherwise.
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.  If pHtFindPrefix does not find a match,
                     this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
        CharLowerA (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = _mbsdec2 (String, BufferEnd);
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
        _wcslwr (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable        - Specifies the handle to the hash table, as returned from
                     AllocateHashTable.
  String           - Specifies the string to add to the table
  ExtraData        - Specifies the source binary data to be copied to the hash
                     table entry
  AlreadyLowercase - Specifies TRUE String is in all lowercase

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return 0;
        }

        CharLowerA (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add UNICODE string to ANSI table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return 0;
        }

        _wcslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


VOID
pRemoveHashItem (
    IN      PHASHTABLESTRUCT Table,
    IN      UINT BucketNum,
    IN      PBUCKETITEM PrevItem,
    IN      PBUCKETITEM ItemToDelete
    )
{
    if (!PrevItem) {
        MYASSERT (Table->Bucket[BucketNum] == ItemToDelete);
        Table->Bucket[BucketNum] = ItemToDelete->Next;
    } else {
        PrevItem->Next = ItemToDelete->Next;
    }

    if (ItemToDelete->PrevLink) {
        ItemToDelete->PrevLink->NextLink = ItemToDelete->NextLink;
    } else {
        Table->FirstLink = ItemToDelete->Next;
    }

    if (ItemToDelete->NextLink) {
        ItemToDelete->NextLink->PrevLink = ItemToDelete->PrevLink;
    } else {
        Table->LastLink = ItemToDelete->PrevLink;
    }

    if (ItemToDelete->Locked) {
        ItemToDelete->Next = Table->DelayedDelete;
        Table->DelayedDelete = ItemToDelete;
    } else {
        PoolMemReleaseMemory (Table->Pool, ItemToDelete);
    }
}


BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    if (!Item) {
        return FALSE;
    }

    //
    // Find prev bucket item
    //

    if (table->Unicode) {
        unicodeStr = HtGetStringFromItemW (Item);
        MYASSERT (unicodeStr);

        thisItem = pHtFindStringW (
                        HashTable,
                        unicodeStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    } else {
        ansiStr = HtGetStringFromItemA (Item);
        MYASSERT (ansiStr);

        thisItem = pHtFindStringA (
                        HashTable,
                        ansiStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    }

    MYASSERT (Item == thisItem);

    if (Item != thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}


BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete UNICODE table with ANSI api"));
        return FALSE;
    }

    thisItem = pHtFindStringA (
                    HashTable,
                    AnsiString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete ANSI table with UNICODE api"));
        return FALSE;
    }

    thisItem = pHtFindStringW (
                    HashTable,
                    UnicodeString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if the String is in lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringA (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringW (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  BufferEnd        - Specifies the end of the buffer for String
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if String is in all lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetExtraData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraDataBuffer
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable       - Specifies the handle to the hash table
  Index           - Specifies the offset as returned from HtFindStringEx or
                    HtAddStringEx
  ExtraDataBuffer - Receives the extra data

Return Value:

  TRUE if ExtraDataBuffer was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraDataBuffer,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


VOID
AbortHashTableEnumA (
    IN      PHASHTABLE_ENUMA EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM nextItem;
    PBUCKETITEM prevItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PoolMemReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));
}


VOID
AbortHashTableEnumW (
    IN      PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM prevItem;
    PBUCKETITEM nextItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PoolMemReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumA (&e);
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumW (&e);
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


BOOL
HtIsEmpty (
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    return (table->FirstLink == NULL);
}


BOOL
HtWriteToFile (
    IN      HASHTABLE HashTable,
    IN      HANDLE OutputFile,
    IN      HASHTABLEOUTPUTFLAGS Flags
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    BOOL result = FALSE;
    DWORD bytesWritten;
    PBUCKETITEM item;
    PCWSTR unicodeStr;
    PCSTR ansiStr;
    DWORD dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    __try {
        if (Flags & WRITE_UNICODE_HEADER) {
            if (table->Unicode) {
                if ((!WriteFile (OutputFile, "\xff\xfe", 2, &bytesWritten, NULL)) ||
                    (bytesWritten != 2)
                    ) {
                    DEBUGMSG ((DBG_ERROR, "Error writing hash table to output file"));
                    __leave;
                }
            }
        }

        if (Flags & REVERSE_ORDER) {
            item = table->LastLink;
        } else {
            item = table->FirstLink;
        }

        while (item) {

            if (table->Unicode) {

                unicodeStr = HtGetStringFromItemW (item);

                if (!WriteFile (OutputFile, unicodeStr, ByteCountW (unicodeStr), &dontCare, NULL)) {
                    __leave;
                }

                if (!WriteFile (OutputFile, L"\r\n", 4, &dontCare, NULL)) {
                    __leave;
                }

            } else {

                ansiStr = HtGetStringFromItemA (item);

                if (!WriteFile (OutputFile, ansiStr, ByteCountA (ansiStr), &dontCare, NULL)) {
                    __leave;
                }

                if (!WriteFile (OutputFile, "\r\n", 2, &dontCare, NULL)) {
                    __leave;
                }

            }

            if (Flags & REVERSE_ORDER) {
                item = item->PrevLink;
            } else {
                item = item->NextLink;
            }
        }

        result = TRUE;
    }
    __finally {
    }

    return result;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of
    binary objects.

Author:

    08-Aug-1997   jimschm     Created

Revision History:

--*/

#include "pch.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGrowListAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGrowListAdd allocates memory for a binary block by using a pool, and
  then expands an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PoolMemInitNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PoolMemDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GrowBuffer (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PoolMemGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GrowListGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  FreeGrowList frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    FreeGrowBuffer (&GrowList->ListArray);
    if (GrowList->ListData) {
        PoolMemDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListGetItem returns a pointer to the block of data
  for item specified by Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    MYASSERT(ItemPtr);

    return ItemPtr[Index];
}


UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GrowListGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item and
  appends two zero bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGrowListInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend inserts a black of data as a new list item,
  before the specified Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGrowListAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGrowListInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend inserts a block of data as a new list item,
  before the specified Index.  Two zero bytes are appended to
  the block of data (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGrowListAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GrowListDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    GrowList->ListArray.End = Size * sizeof (PBYTE);

    return TRUE;
}


BOOL
GrowListResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListResetItem sets the list pointer of the specified item
  to NULL, freeing the memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGrowListSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GrowListSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PoolMemGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\icons.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icons.c

Abstract:

    Icon extraction and manipulation routines

Author:

    Jim Schmidt (jimschm)   04-May-1998

Revision History:

    jimschm     23-Sep-1998 String icon ID bug fixes, error path bug fixes

--*/

#include "pch.h"
#include "migutilp.h"

#define MAX_RESOLUTIONS     32      // 8 sizes times 4 color palettes

#pragma pack(push)
#pragma pack(2)

typedef struct {
    BYTE        Width;          // Width, in pixels, of the image
    BYTE        Height;         // Height, in pixels, of the image
    BYTE        ColorCount;     // Number of colors in image (0 if >=8bpp)
    BYTE        Reserved;       // Reserved ( must be 0)
    WORD        Planes;         // Color Planes
    WORD        BitCount;       // Bits per pixel
    DWORD       BytesInRes;     // How many bytes in this resource?
    DWORD       ImageOffset;    // Where in the file is this image?
} ICONDIRENTRY, *PICONDIRENTRY;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
    ICONDIRENTRY   Entries[1]; // An entry for each image (idCount of 'em)
} ICONDIR, *PICONDIR;

typedef struct {
    BYTE   Width;               // Width, in pixels, of the image
    BYTE   Height;              // Height, in pixels, of the image
    BYTE   ColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE   Reserved;            // Reserved
    WORD   Planes;              // Color Planes
    WORD   BitCount;            // Bits per pixel
    DWORD  BytesInRes;          // how many bytes in this resource?
    WORD   ID;                  // the ID
} GRPICONDIRENTRY, *PGRPICONDIRENTRY;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
    GRPICONDIRENTRY  Entries[1]; // The entries for each image
} GRPICONDIR, *PGRPICONDIR;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
} GRPICONDIRBASE, *PGRPICONDIRBASE;

#pragma pack( pop )

#define PICONIMAGE PBYTE


BOOL
ReadBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    )
{
    DWORD BytesRead;

    if (!ReadFile (File, Buffer, Size, &BytesRead, NULL)) {
        return FALSE;
    }

    return Size == BytesRead;
}


BOOL
pWriteBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    )
{
    DWORD BytesWritten;

    if (!WriteFile (File, Buffer, Size, &BytesWritten, NULL)) {
        return FALSE;
    }

    return Size == BytesWritten;
}



UINT
Power (
    UINT x,
    UINT e
    )
{
    UINT r;

    r = 1;

    while (e > 0) {
        r = r * x;
        e--;
    }

    return r;
}


UINT
pComputeSizeOfIconImage (
    IN      PICONIMAGE IconImage
    )
{
    PBITMAPINFOHEADER Header;
    UINT Size;
    UINT Bits;
    UINT Colors;
    UINT BytesInImage;

    Header = (PBITMAPINFOHEADER) IconImage;

    Size = Header->biSize;

    Bits = Header->biBitCount * Header->biPlanes;
    if (Bits > 32) {
        Bits = 4;
    }

    Colors = Power (2, Bits);

    if (Bits < 24) {
        Size += Colors * sizeof (RGBQUAD);
    }

    BytesInImage = (Header->biWidth + 7) / 8 * (Header->biHeight / 2);
    Size += BytesInImage * Bits;     // XOR mask

    //
    // The following computation is very strange, but it was added based on
    // test comparisons.
    //

    if (Header->biWidth == 32) {
        Size += BytesInImage;     // AND mask
    } else {
        Size += BytesInImage + Header->biHeight;     // AND mask plus who knows what
    }

    MYASSERT (Size);

    return Size;
}


BOOL
pAddIconImagesToGrowBuffer (
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PICONDIRENTRY IconDirEntryBase,
    IN      WORD Count,
    IN      DWORD Pos,
    IN      DWORD Size
    )
{
    WORD w;
    PICONDIRENTRY IconDirEntry;
    PBYTE Dest;
    DWORD Offset;

    for (w = 0 ; w < Count ; w++) {
        IconDirEntry = &IconDirEntryBase[w];

        Offset = IconDirEntry->ImageOffset & 0x0fffffff;

        if (Offset < Pos || Offset >= Size) {
            return FALSE;
        }

        SetFilePointer (File, Offset, NULL, FILE_BEGIN);

        Dest = GrowBuffer (Buffer, IconDirEntry->BytesInRes);
        if (!Dest) {
            return FALSE;
        }

        if (!ReadBinaryBlock (File, Dest, IconDirEntry->BytesInRes)) {
            return FALSE;
        }

        if (IconDirEntry->BytesInRes != pComputeSizeOfIconImage (Dest)) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
pGetIconImageArrayFromIcoFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    BOOL b = FALSE;
    ICONDIR IconDir;
    PICONDIRENTRY IconDirEntryBase = NULL;
    DWORD Size;
    DWORD Pos;
    UINT IconDirEntrySize;

    Size = GetFileSize (File, NULL);
    SetFilePointer (File, 0, NULL, FILE_BEGIN);

    Buffer->End = 0;

    __try {
        if (!ReadBinaryBlock (File, &IconDir, sizeof (WORD) * 3)) {
            __leave;
        }

        IconDirEntrySize = (UINT) IconDir.Count * sizeof (ICONDIRENTRY);

        if (IconDirEntrySize > (UINT) Size) {
            __leave;
        }

        IconDirEntryBase = (PICONDIRENTRY) MemAlloc (g_hHeap, 0, IconDirEntrySize);
        if (!IconDirEntryBase) {
            __leave;
        }

        if (!ReadBinaryBlock (File, IconDirEntryBase, IconDirEntrySize)) {
            __leave;
        }

        Pos = SetFilePointer (File, 0, NULL, FILE_CURRENT);

        if (!pAddIconImagesToGrowBuffer (Buffer, File, IconDirEntryBase, IconDir.Count, Pos, Size)) {
            DEBUGMSG ((DBG_WARNING, "Icon file %ls has a bogus offset", ModuleContainingIcon));
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (IconDirEntryBase) {
            MemFree (g_hHeap, 0, IconDirEntryBase);
        }
    }

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    PCWSTR UnicodeFileName;
    BOOL b;

    UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
    if (!UnicodeFileName) {
        return FALSE;
    }

    b = pGetIconImageArrayFromIcoFileExW (UnicodeFileName, Buffer, File);

    PushError();
    FreeConvertedStr (UnicodeFileName);
    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    File = CreateFileW (ModuleContainingIcon, GENERIC_READ, 0, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%ls could not be opened", ModuleContainingIcon));
        return FALSE;
    }

    __try {

        b = pGetIconImageArrayFromIcoFileExW (ModuleContainingIcon, Buffer, File);

    }
    __finally {
        CloseHandle (File);
    }

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileA (
    IN      PCSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer
    )
{
    PCWSTR UnicodeFileName;
    BOOL b;

    UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
    if (!UnicodeFileName) {
        return FALSE;
    }

    b = pGetIconImageArrayFromIcoFileW (UnicodeFileName, Buffer);

    PushError();
    FreeConvertedStr (UnicodeFileName);
    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromBinaryExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE Library,
    IN      HANDLE Library16
    )
{
    HRSRC ResourceHandle;
    HGLOBAL ResourceBlock;
    PBYTE ResourceData;
    DWORD ResourceSize;
    PBYTE Dest;
    BOOL b = FALSE;
    PGRPICONDIR GroupIconDir;
    WORD w;

    if (!GroupIconId) {
        return FALSE;
    }

    __try {

        Buffer->End = 0;

        if (Library) {

            //
            // Get icon from PE file
            //

            ResourceHandle = FindResourceW (Library, GroupIconId, (PCWSTR) RT_GROUP_ICON);
            if (!ResourceHandle) {
                __leave;
            }

            ResourceBlock = LoadResource (Library, ResourceHandle);
            if (!ResourceBlock) {
                __leave;
            }

            GroupIconDir = (PGRPICONDIR) LockResource (ResourceBlock);
            if (!GroupIconDir) {
                __leave;
            }

            if (GroupIconDir->Type != 1) {
                DEBUGMSGW_IF ((
                    (UINT_PTR) GroupIconId < 0x10000,
                    DBG_ERROR,
                    "icon type for resource %u is not 1 in %s",
                    GroupIconId,
                    ModuleContainingIcon
                    ));
                DEBUGMSGW_IF ((
                    (UINT_PTR) GroupIconId >= 0x10000,
                    DBG_ERROR,
                    "icon type for resource %s is not 1 in %s",
                    GroupIconId,
                    ModuleContainingIcon
                    ));
                __leave;
            }

            if (GroupIconDir->Count > MAX_RESOLUTIONS) {
                DEBUGMSGW ((DBG_ERROR, "%u resolutions found in %s", GroupIconDir->Count, ModuleContainingIcon));
                __leave;
            }

            //
            // Add the ICONIMAGE array to the grow buffer
            //

            for (w = 0 ; w < GroupIconDir->Count ; w++) {

                ResourceHandle = FindResourceW (
                                     Library,
                                     (PCWSTR) (GroupIconDir->Entries[w].ID),
                                     (PCWSTR) RT_ICON
                                     );

                if (ResourceHandle) {
                    ResourceBlock = LoadResource (Library, ResourceHandle);
                    if (!ResourceBlock) {
                        continue;
                    }

                    ResourceData = (PBYTE) LockResource (ResourceBlock);
                    if (!ResourceData) {
                        continue;
                    }

                    ResourceSize = pComputeSizeOfIconImage ((PICONIMAGE) ResourceData);
                    if (!ResourceSize) {
                        DEBUGMSG ((DBG_WARNING, "Zero-length icon in %s", ModuleContainingIcon));
                        continue;
                    }


                    if (ResourceSize > 0x10000) {
                        // too big for an icon
                        __leave;
                    }

                    Dest = GrowBuffer (Buffer, ResourceSize);
                    if (!Dest) {
                        __leave;
                    }

                    CopyMemory (Dest, ResourceData, ResourceSize);
                }
                ELSE_DEBUGMSG ((DBG_WARNING, "Indexed icon could not be loaded from resource"));
            }
        }

        else if (Library16) {
            //
            // Get icon from NE file
            //

            GroupIconDir = (PGRPICONDIR) FindNeResourceExW (Library16, (PCWSTR) RT_GROUP_ICON, GroupIconId);
            if (!GroupIconDir) {
                DEBUGMSG ((DBG_WHOOPS, "NE group icon %u not found", GroupIconId));
                __leave;
            }

            DEBUGMSG_IF ((GroupIconDir->Count > MAX_RESOLUTIONS, DBG_WHOOPS, "%u resolutions found in %hs", GroupIconDir->Count, ModuleContainingIcon));

            //
            // Add the ICONIMAGE array to the grow buffer
            //

            for (w = 0 ; w < GroupIconDir->Count ; w++) {

                ResourceData = FindNeResourceExA (
                                     Library16,
                                     (PCSTR) RT_ICON,
                                     (PCSTR) GroupIconDir->Entries[w].ID
                                     );

                if (!ResourceData) {
                    DEBUGMSG ((DBG_WHOOPS, "NE Icon ID %u not found", GroupIconDir->Entries[w].ID));
                    __leave;
                }

                ResourceSize = pComputeSizeOfIconImage ((PICONIMAGE) ResourceData);
                if (!ResourceSize) {
                    DEBUGMSG ((DBG_WARNING, "Zero-length icon in %s", ModuleContainingIcon));
                    continue;
                }

                if (ResourceSize > 0x10000) {
                    // too big for an icon
                    __leave;
                }

                Dest = GrowBuffer (Buffer, ResourceSize);
                if (!Dest) {
                    __leave;
                }

                CopyMemory (Dest, ResourceData, ResourceSize);
            }
        }

        b = TRUE;
    }
    __finally {
        // empty
    }

    return b;
}


BOOL
pGenerateUnicodeArgs (
    IN      PCSTR ModuleContainingIcon,         OPTIONAL
    IN      PCSTR GroupIconId,                  OPTIONAL
    OUT     PCWSTR *UnicodeFileName,            OPTIONAL
    OUT     PCWSTR *UnicodeGroupIconId          OPTIONAL
    )
{
    if (UnicodeFileName) {
        if (ModuleContainingIcon) {
            *UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
            if (!(*UnicodeFileName)) {
                return FALSE;
            }
        } else {
            *UnicodeFileName = NULL;
        }
    }

    if (UnicodeGroupIconId) {
        if (GroupIconId) {

            if ((DWORD) GroupIconId & 0xffff0000) {

                *UnicodeGroupIconId = ConvertAtoW (GroupIconId);

                if (!(*UnicodeGroupIconId)) {
                    if (UnicodeFileName && *UnicodeFileName) {
                        FreeConvertedStr (*UnicodeFileName);
                    }
                    return FALSE;
                }

            } else {
                *UnicodeGroupIconId = (PCWSTR) GroupIconId;
            }

        } else {
            *UnicodeGroupIconId = NULL;
        }
    }

    return TRUE;
}



VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    )
{
    if (HIWORD (AnsiId)) {
        FreeConvertedStr (AnsiId);
    }
}


VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    )
{
    if (HIWORD (UnicodeId)) {
        FreeConvertedStr (UnicodeId);
    }
}


BOOL
pGetIconImageArrayFromBinaryExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE Library,
    IN      HANDLE Library16
    )
{
    PCWSTR UnicodeFileName;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    if (!pGenerateUnicodeArgs (
            ModuleContainingIcon,
            GroupIconId,
            &UnicodeFileName,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = pGetIconImageArrayFromBinaryExW (UnicodeFileName, UnicodeGroupIconId, Buffer, Library, Library16);

    PushError();

    FreeConvertedStr (UnicodeFileName);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromBinaryW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE Library;
    HANDLE Library16 = NULL;
    BOOL b = FALSE;

    Library = LoadLibraryExW (ModuleContainingIcon, NULL, LOAD_LIBRARY_AS_DATAFILE);

    __try {
        if (!Library) {

            Library16 = OpenNeFileW (ModuleContainingIcon);
            if (!Library16) {
                return FALSE;
            }
        }

        b = pGetIconImageArrayFromBinaryExW (ModuleContainingIcon, GroupIconId, Buffer, Library, Library16);

    }
    __finally {
        if (Library) {
            FreeLibrary (Library);
        }

        if (Library16) {
            CloseNeFile (Library16);
        }
    }

    return b;
}


BOOL
pGetIconImageArrayFromBinaryA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE Library;
    HANDLE Library16 = NULL;
    BOOL b = FALSE;

    Library = LoadLibraryExA (ModuleContainingIcon, NULL, LOAD_LIBRARY_AS_DATAFILE);

    __try {
        if (!Library) {

            Library16 = OpenNeFileA (ModuleContainingIcon);
            if (!Library16) {
                return FALSE;
            }
        }

        b = pGetIconImageArrayFromBinaryExA (ModuleContainingIcon, GroupIconId, Buffer, Library, Library16);

    }
    __finally {
        if (Library) {
            FreeLibrary (Library);
        }

        if (Library16) {
            CloseNeFile (Library16);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileEx (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    WORD w;
    BOOL b = FALSE;
    PICONIMAGE IconImage, IconImageEnd;
    PICONIMAGE p;
    INT ImageCount;
    ICONDIRENTRY Entry;
    PBITMAPINFOHEADER Header;
    UINT ColorCount;
    DWORD Offset;

    if (!Buffer->End) {
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);

        //
        // Count the images
        //

        IconImage    = (PICONIMAGE) Buffer->Buf;
        IconImageEnd = (PICONIMAGE) (Buffer->Buf + Buffer->End);

        p = IconImage;
        ImageCount = 0;

        while (p < IconImageEnd) {
            ImageCount++;
            p = (PICONIMAGE) ((PBYTE) p + pComputeSizeOfIconImage (p));
        }

        //
        // Write the icon header
        //

        w = 0;      // reserved
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        w = 1;      // type (1 == icon)
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        w = (WORD) ImageCount;
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        //
        // For each icon image, write the directory entry
        //

        p = IconImage;
        Offset = 0;

        while (p < IconImageEnd) {

            ZeroMemory (&Entry, sizeof (Entry));

            Header = (PBITMAPINFOHEADER) p;
            Entry.Width = (BYTE) Header->biWidth;
            Entry.Height = (BYTE) Header->biHeight / 2;

            ColorCount = Header->biPlanes * Header->biBitCount;
            if (ColorCount >= 8) {
                Entry.ColorCount = 0;
            } else {
                Entry.ColorCount = (BYTE) Power (2, ColorCount);
            }

            Entry.Planes = Header->biPlanes;
            Entry.BitCount = Header->biBitCount;
            Entry.BytesInRes = pComputeSizeOfIconImage (p);
            Entry.ImageOffset = sizeof (WORD) * 3 + sizeof (Entry) * ImageCount + Offset;

            if (!pWriteBinaryBlock (File, &Entry, sizeof (Entry))) {
                __leave;
            }

            Offset += Entry.BytesInRes;

            p = (PICONIMAGE) ((PBYTE) p + Entry.BytesInRes);
        }

        //
        // Write the image array
        //

        if (!pWriteBinaryBlock (File, IconImage, Buffer->End)) {
            __leave;
        }

        b = TRUE;

    }
    __finally {
        // empty
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    if (!Buffer->End) {
        return FALSE;
    }

    File = CreateFileW (DestinationFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%ls could not be created", DestinationFile));
        return FALSE;
    }

    __try {
        b = WriteIconImageArrayToIcoFileEx (Buffer, File);
    }
    __finally {
        CloseHandle (File);
        if (!b) {
            DeleteFileW (DestinationFile);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    if (!Buffer->End) {
        return FALSE;
    }

    File = CreateFileA (DestinationFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%hs could not be created", DestinationFile));
        return FALSE;
    }

    __try {
        b = WriteIconImageArrayToIcoFileEx (Buffer, File);
    }
    __finally {
        CloseHandle (File);
        if (!b) {
            DeleteFileA (DestinationFile);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileExW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    )
{
    BOOL b = FALSE;
    GROWBUFFER GroupIcon = GROWBUF_INIT;
    PGRPICONDIRBASE IconDir;
    PGRPICONDIRENTRY Entry;
    PICONIMAGE IconImage, IconImageEnd;
    PICONIMAGE p;
    PBITMAPINFOHEADER Header;
    UINT ColorCount;

    if (!Buffer->End) {
        return TRUE;
    }

    __try {
        //
        // Make a group icon directory for all icon images in Buffer
        //

        IconDir = (PGRPICONDIRBASE) GrowBuffer (&GroupIcon, sizeof (GRPICONDIRBASE));
        if (!IconDir) {
            __leave;
        }

        IconDir->Reserved = 0;
        IconDir->Type = 1;
        IconDir->Count = 0;

        IconImage    = (PICONIMAGE) Buffer->Buf;
        IconImageEnd = (PICONIMAGE) (Buffer->Buf + Buffer->End);

        p = IconImage;
        while (p < IconImageEnd) {

            Entry = (PGRPICONDIRENTRY) GrowBuffer (&GroupIcon, sizeof (GRPICONDIRENTRY));
            if (!Entry) {
                __leave;
            }

            Header = (PBITMAPINFOHEADER) p;

            Entry->Width = (BYTE) Header->biWidth;
            Entry->Height = (BYTE) Header->biHeight / 2;

            ColorCount = Header->biPlanes * Header->biBitCount;
            if (ColorCount >= 8) {
                Entry->ColorCount = 0;
            } else {
                Entry->ColorCount = (BYTE) Power (2, ColorCount);
            }

            Entry->Planes = Header->biPlanes;
            Entry->BitCount = Header->biBitCount;
            Entry->BytesInRes = pComputeSizeOfIconImage (p);

            if (!NextIconId) {
                Entry->ID = 1 + (WORD) ((DWORD) GroupIconId & (0xffff / MAX_RESOLUTIONS)) * MAX_RESOLUTIONS + IconDir->Count;
            } else {
                Entry->ID = *NextIconId;
            }

            //
            // Add icon to the PE file
            //

            b = UpdateResourceA (
                    UpdateHandle,
                    RT_ICON,
                    MAKEINTRESOURCE(Entry->ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    p,
                    Entry->BytesInRes
                    );

            if (!b) {
                LOGA ((LOG_ERROR, "Could not add icon to %s", DestinationFile));
                __leave;
            }

            IconDir->Count += 1;
            if (NextIconId) {
                *NextIconId += 1;
            }

            p = (PICONIMAGE) ((PBYTE) p + Entry->BytesInRes);
        }

        //
        // Add the group icon to the PE
        //

        b = UpdateResourceW (
                UpdateHandle,
                (PCWSTR) RT_GROUP_ICON,
                GroupIconId,
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                GroupIcon.Buf,
                GroupIcon.End
                );

        if (!b) {
            LOGA ((LOG_ERROR, "Unable to add icon to %s", DestinationFile));
            __leave;
        }

        b = TRUE;
    }
    __finally {
        FreeGrowBuffer (&GroupIcon);
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileExA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    )
{
    PCWSTR UnicodeDestinationFile;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    if (!pGenerateUnicodeArgs (
            DestinationFile,
            GroupIconId,
            &UnicodeDestinationFile,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = WriteIconImageArrayToPeFileExW (
            UnicodeDestinationFile,
            Buffer,
            UnicodeGroupIconId,
            NextIconId,
            UpdateHandle
            );

    PushError();

    FreeConvertedStr (UnicodeDestinationFile);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}


BOOL
WriteIconImageArrayToPeFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId
    )
{
    HANDLE UpdateHandle = NULL;
    BOOL b = FALSE;

    if (!Buffer->End) {
        return TRUE;
    }

    __try {
        //
        // Open PE file for update
        //

        UpdateHandle = BeginUpdateResourceW (DestinationFile, FALSE);

        if (!UpdateHandle) {
            LOGW ((LOG_ERROR, "Unable to begin resource update of %s", DestinationFile));
            __leave;
        }

        //
        // Update the PE file
        //

        b = WriteIconImageArrayToPeFileExW (DestinationFile, Buffer, (PCWSTR) GroupIconId, NULL, UpdateHandle);
    }
    __finally {
        EndUpdateResource (UpdateHandle, !b);
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId
    )
{
    PCWSTR UnicodeDestinationFile;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    if (!pGenerateUnicodeArgs (
            DestinationFile,
            GroupIconId,
            &UnicodeDestinationFile,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = WriteIconImageArrayToPeFileW (
            UnicodeDestinationFile,
            Buffer,
            UnicodeGroupIconId
            );

    PushError();

    FreeConvertedStr (UnicodeDestinationFile);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}

BOOL
IsFileAnIcoW (
    IN      PCWSTR FileInQuestion
    )
{
    PCWSTR p;
    DWORD magic;
    DWORD bytesRead;
    HANDLE icoFileHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    p = wcsrchr (FileInQuestion, L'.');

    if (p) {
        if (StringIMatchW (p, L".ico")) {
            return TRUE;
        }
    }

    icoFileHandle = CreateFileW (
                        FileInQuestion,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if (icoFileHandle != INVALID_HANDLE_VALUE) {

        if (ReadFile (icoFileHandle, (PBYTE)(&magic), sizeof (magic), &bytesRead, NULL)) {
            if (bytesRead == sizeof (magic)) {
                if (magic != IMAGE_DOS_SIGNATURE) {
                    result = TRUE;
                }
            }
        }

        CloseHandle (icoFileHandle);
    }

    return result;
}


BOOL
IsFileAnIcoA (
    IN      PCSTR FileInQuestion
    )
{
    PCSTR p;
    WORD magic;
    DWORD bytesRead;
    HANDLE icoFileHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    p = _mbsrchr (FileInQuestion, '.');

    if (p) {
        if (StringIMatchA (p, ".ico")) {
            return TRUE;
        }
    }

    icoFileHandle = CreateFileA (
                        FileInQuestion,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if (icoFileHandle != INVALID_HANDLE_VALUE) {

        if (ReadFile (icoFileHandle, (PBYTE)(&magic), sizeof (magic), &bytesRead, NULL)) {
            if (bytesRead == sizeof (magic)) {
                if (magic != IMAGE_DOS_SIGNATURE) {
                    result = TRUE;
                }
            }
        }

        CloseHandle (icoFileHandle);
    }

    return result;
}


BOOL
ExtractIconImageFromFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    )
{
    if (IsFileAnIcoW (ModuleContainingIcon)) {
        if (IcoFileHandle) {
            return pGetIconImageArrayFromIcoFileExW (ModuleContainingIcon, Buffer, IcoFileHandle);
        } else {
            return pGetIconImageArrayFromIcoFileW (ModuleContainingIcon, Buffer);
        }
    }

    if (PeModuleHandle) {
        return pGetIconImageArrayFromBinaryExW (
                    ModuleContainingIcon,
                    GroupIconId,
                    Buffer,
                    PeModuleHandle,
                    NeModuleHandle
                    );
    } else {
        return pGetIconImageArrayFromBinaryW (ModuleContainingIcon, GroupIconId, Buffer);
    }
}


BOOL
ExtractIconImageFromFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    )
{
    if (IsFileAnIcoA (ModuleContainingIcon)) {
        if (IcoFileHandle) {
            return pGetIconImageArrayFromIcoFileExA (ModuleContainingIcon, Buffer, IcoFileHandle);
        } else {
            return pGetIconImageArrayFromIcoFileA (ModuleContainingIcon, Buffer);
        }
    }

    if (PeModuleHandle) {
        return pGetIconImageArrayFromBinaryExA (
                    ModuleContainingIcon,
                    GroupIconId,
                    Buffer,
                    PeModuleHandle,
                    NeModuleHandle
                    );
    } else {
        return pGetIconImageArrayFromBinaryA (ModuleContainingIcon, GroupIconId, Buffer);
    }
}


BOOL
ExtractIconImageFromFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    return ExtractIconImageFromFileExW (
                ModuleContainingIcon,
                GroupIconId,
                Buffer,
                NULL,
                NULL,
                NULL
                );
}


BOOL
ExtractIconImageFromFileA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    return ExtractIconImageFromFileExA (
                ModuleContainingIcon,
                GroupIconId,
                Buffer,
                NULL,
                NULL,
                NULL
                );
}


BOOL
CALLBACK
pEnumIconNameProcA (
    HANDLE Module,
    PCSTR Type,
    PSTR Name,
    LONG lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((DWORD) Name & 0xffff0000) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", Name);
    }

    MultiSzAppendA (Buf, Num);
    return TRUE;
}


BOOL
CALLBACK
pEnumIconNameProcW (
    HANDLE Module,
    PCWSTR Type,
    PWSTR Name,
    LONG lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((DWORD) Name & 0xffff0000) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", Name);
    }

    MultiSzAppendW (Buf, Num);
    return TRUE;
}


PCSTR
ExtractIconNamesFromFileExA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    )
{
    PCSTR ReturnBuf;

    NameBuf->End = 0;

    if (Module) {
        if (!EnumResourceNamesA (Module, RT_GROUP_ICON, pEnumIconNameProcA, (LONG) NameBuf)) {
            return NULL;
        }
    } else if (Module16) {
        if (!EnumNeResourceNamesA (Module16, RT_GROUP_ICON, pEnumIconNameProcA, (LONG) NameBuf)) {
            return NULL;
        }
    } else {
        return NULL;
    }

    MultiSzAppendA (NameBuf, "");
    ReturnBuf = (PCSTR) NameBuf->Buf;

    return ReturnBuf;
}


PCWSTR
ExtractIconNamesFromFileExW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    )
{
    PCWSTR ReturnBuf;

    NameBuf->End = 0;

    if (Module) {
        if (!EnumResourceNamesW (Module, (PCWSTR) RT_GROUP_ICON, pEnumIconNameProcW, (LONG) NameBuf)) {
            return NULL;
        }
    } else if (Module16) {
        if (!EnumNeResourceNamesW (Module16, (PWSTR) RT_GROUP_ICON, pEnumIconNameProcW, (LONG) NameBuf)) {
            return NULL;
        }
    } else {
        return NULL;
    }

    MultiSzAppendW (NameBuf, L"");
    ReturnBuf = (PCWSTR) NameBuf->Buf;

    return ReturnBuf;
}


PCSTR
ExtractIconNamesFromFileA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    )
{
    HANDLE Module = NULL;
    HANDLE Module16 = NULL;
    PCSTR ReturnBuf = NULL;

    __try {
        Module = LoadLibraryExA (ModuleContainingIcons, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (!Module) {

            Module16 = OpenNeFileA (ModuleContainingIcons);
            if (!Module16) {
                DEBUGMSGA ((DBG_WARNING, "Can't load %s, error %u", ModuleContainingIcons, GetLastError()));
                __leave;
            }
        }

        ReturnBuf = ExtractIconNamesFromFileExA (ModuleContainingIcons, NameBuf, Module, Module16);

    }
    __finally {
        if (Module) {
            FreeLibrary (Module);
        }

        if (Module16) {
            CloseNeFile (Module16);
        }
    }

    return ReturnBuf;
}


PCWSTR
ExtractIconNamesFromFileW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    )
{
    HANDLE Module = NULL;
    HANDLE Module16 = NULL;
    PCWSTR ReturnBuf = NULL;

    __try {
        Module = LoadLibraryExW (ModuleContainingIcons, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (!Module) {

            Module16 = OpenNeFileW (ModuleContainingIcons);
            if (!Module16) {
                DEBUGMSGW ((DBG_WARNING, "Can't load %s, error %u", ModuleContainingIcons, GetLastError()));
                __leave;
            }
        }

        ReturnBuf = ExtractIconNamesFromFileExW (ModuleContainingIcons, NameBuf, Module, Module16);

    }
    __finally {
        if (Module) {
            FreeLibrary (Module);
        }

        if (Module16) {
            CloseNeFile (Module16);
        }
    }

    return ReturnBuf;
}


VOID
pInitContextA (
    PICON_EXTRACT_CONTEXTA Context
    )
{
    ZeroMemory (Context, sizeof (ICON_EXTRACT_CONTEXTA));
    Context->GroupId = 1;
    Context->IconId = 1;
    Context->IconImageFile = INVALID_HANDLE_VALUE;
}


VOID
pInitContextW (
    PICON_EXTRACT_CONTEXTW Context
    )
{
    ZeroMemory (Context, sizeof (ICON_EXTRACT_CONTEXTW));
    Context->GroupId = 1;
    Context->IconId = 1;
    Context->IconImageFile = INVALID_HANDLE_VALUE;
}


BOOL
BeginIconExtractionA (
    OUT     PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR DestFile                          OPTIONAL
    )
{
    pInitContextA (Context);

    if (DestFile) {
        Context->Update = BeginUpdateResourceA (DestFile, FALSE);

        if (!Context->Update) {
            LOGA ((LOG_ERROR, "Unable to begin resource update of %s", DestFile));
            return FALSE;
        }

        StringCopyA (Context->DestFile, DestFile);
    }

    return TRUE;
}


BOOL
BeginIconExtractionW (
    OUT     PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR DestFile                         OPTIONAL
    )
{
    pInitContextW (Context);

    if (DestFile) {
        Context->Update = BeginUpdateResourceW (DestFile, FALSE);

        if (!Context->Update) {
            LOGW ((LOG_ERROR, "Unable to begin resource update of %s", DestFile));
            return FALSE;
        }

        StringCopyW (Context->DestFile, DestFile);
    }

    return TRUE;
}


BOOL
pLoadBinaryImageA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR IconFile
    )
{
    if (Context->Module || Context->Module16) {
        if (StringIMatchA (Context->ModuleName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
        Context->Module = NULL;
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
        Context->Module16 = NULL;
    }

    Context->Module = LoadLibraryExA (IconFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Context->Module) {
        StringCopyA (Context->ModuleName, IconFile);
    } else {
        Context->Module16 = OpenNeFileA (IconFile);
        if (Context->Module16) {
            StringCopyA (Context->ModuleName, IconFile);
        } else {
            Context->ModuleName[0] = 0;
        }
    }

    return Context->Module != NULL || Context->Module16 != NULL;
}


BOOL
pLoadBinaryImageW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR IconFile
    )
{
    if (Context->Module || Context->Module16) {
        if (StringIMatchW (Context->ModuleName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
        Context->Module16 = NULL;
    }

    Context->Module = LoadLibraryExW (IconFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Context->Module) {
        StringCopyW (Context->ModuleName, IconFile);
    } else {
        Context->Module16 = OpenNeFileW (IconFile);
        if (Context->Module16) {
            StringCopyW (Context->ModuleName, IconFile);
        } else {
            Context->ModuleName[0] = 0;
        }
    }

    return Context->Module != NULL || Context->Module16 != NULL;
}


BOOL
pOpenIcoFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR IconFile
    )
{
    if (Context->IcoFile) {
        if (StringIMatchA (Context->IcoFileName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->IcoFile) {
        CloseHandle (Context->IcoFile);
    }

    Context->IcoFile = CreateFileA (IconFile, GENERIC_READ, 0, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (Context->IcoFile == INVALID_HANDLE_VALUE) {
        Context->IcoFile = NULL;
        Context->IcoFileName[0] = 0;
    } else {
        StringCopyA (Context->IcoFileName, IconFile);
    }

    return Context->IcoFile != NULL;
}


BOOL
pOpenIcoFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR IconFile
    )
{
    if (Context->IcoFile) {
        if (StringIMatchW (Context->IcoFileName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->IcoFile) {
        CloseHandle (Context->IcoFile);
    }

    Context->IcoFile = CreateFileW (IconFile, GENERIC_READ, 0, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (Context->IcoFile == INVALID_HANDLE_VALUE) {
        Context->IcoFile = NULL;
        Context->IcoFileName[0] = 0;
    } else {
        StringCopyW (Context->IcoFileName, IconFile);
    }

    return Context->IcoFile != NULL;
}


BOOL
pOpenIconImageA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    )
{
    if (Is16Bit) {
        *Is16Bit = FALSE;
    }

    if (IsFileAnIcoA (FileToOpen)) {
        if (IsIco) {
            *IsIco = TRUE;
        }

        return pOpenIcoFileA (Context, FileToOpen);
    }

    if (IsIco) {
        *IsIco = FALSE;
    }

    if (pLoadBinaryImageA (Context, FileToOpen)) {
        if (Context->Module16 && Is16Bit) {
            *Is16Bit = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
pOpenIconImageW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    )
{
    if (Is16Bit) {
        *Is16Bit = FALSE;
    }

    if (IsFileAnIcoW (FileToOpen)) {
        if (IsIco) {
            *IsIco = TRUE;
        }

        return pOpenIcoFileW (Context, FileToOpen);
    }

    if (IsIco) {
        *IsIco = FALSE;
    }

    if (pLoadBinaryImageW (Context, FileToOpen)) {
        if (Context->Module16 && Is16Bit) {
            *Is16Bit = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
OpenIconImageFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileName,
    IN      BOOL SaveMode
    )
{
    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
        Context->IconImageFileName[0] = 0;
    }

    if (SaveMode) {
        Context->IconImageFile = CreateFileA (
                                    FileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    } else {
        Context->IconImageFile = CreateFileA (
                                    FileName,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        StringCopyA (Context->IconImageFileName, FileName);
        Context->SaveMode = SaveMode;
        return TRUE;
    }

    return FALSE;
}


BOOL
OpenIconImageFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileName,
    IN      BOOL SaveMode
    )
{
    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
        Context->IconImageFileName[0] = 0;
    }

    if (SaveMode) {
        Context->IconImageFile = CreateFileW (
                                    FileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    } else {
        Context->IconImageFile = CreateFileW (
                                    FileName,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        StringCopyW (Context->IconImageFileName, FileName);
        Context->SaveMode = SaveMode;
        return TRUE;
    }

    return FALSE;
}


BOOL
pGetIconImageArrayFromFileA (
    IN      PICON_EXTRACT_CONTEXTA Context
    )
{
    DWORD Size;
    PBYTE Dest;
    HANDLE File;

    File = Context->IconImageFile;

    if (!ReadBinaryBlock (File, &Size, sizeof (DWORD))) {
        return FALSE;
    }

    Context->IconImages.End = 0;

    Dest = GrowBuffer (&Context->IconImages, Size);
    if (!Dest) {
        return FALSE;
    }

    return ReadBinaryBlock (File, Dest, Size);
}


BOOL
pGetIconImageArrayFromFileW (
    IN      PICON_EXTRACT_CONTEXTW Context
    )
{
    DWORD Size;
    PBYTE Dest;
    HANDLE File;

    File = Context->IconImageFile;

    if (!ReadBinaryBlock (File, &Size, sizeof (DWORD))) {
        return FALSE;
    }

    Context->IconImages.End = 0;

    Dest = GrowBuffer (&Context->IconImages, Size);
    if (!Dest) {
        return FALSE;
    }

    return ReadBinaryBlock (File, Dest, Size);
}


BOOL
pPutIconImageArrayInFileA (
    IN      PICON_EXTRACT_CONTEXTA Context
    )
{
    HANDLE File;

    File = Context->IconImageFile;

    if (!Context->IconImages.End) {

        DEBUGMSGA_IF ((
            Context->ModuleName[0],
            DBG_WARNING,
            "Ignoring empty icon in %s",
            Context->ModuleName
            ));

        return TRUE;
    }

    if (!pWriteBinaryBlock (File, &Context->IconImages.End, sizeof (DWORD))) {
        return FALSE;
    }

    return pWriteBinaryBlock (File, Context->IconImages.Buf, Context->IconImages.End);
}


BOOL
pPutIconImageArrayInFileW (
    IN      PICON_EXTRACT_CONTEXTW Context
    )
{
    HANDLE File;

    File = Context->IconImageFile;

    if (!Context->IconImages.End) {

        DEBUGMSGW_IF ((
            Context->ModuleName[0],
            DBG_WARNING,
            "Ignoring empty icon in %s",
            Context->ModuleName
            ));

        return TRUE;
    }


    if (!pWriteBinaryBlock (File, &Context->IconImages.End, sizeof (DWORD))) {
        return FALSE;
    }

    return pWriteBinaryBlock (File, Context->IconImages.Buf, Context->IconImages.End);
}


PCSTR
pFindResourceIdFromIndexA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,
    IN      INT ResourceIndex,
    OUT     PSTR Buffer
    )
{
    PCSTR ImageList;

    if (!pLoadBinaryImageA (Context, FileContainingIcon)) {
        return NULL;
    }

    if (ResourceIndex < 0) {
        wsprintfA (Buffer, "#%i", -ResourceIndex);
        return Buffer;
    } else {
        *Buffer = 0;
    }

    ImageList = ExtractIconNamesFromFileExA (
                    FileContainingIcon,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    while (ImageList) {
        if (!ResourceIndex) {
            StringCopyA (Buffer, ImageList);
            break;
        }

        ResourceIndex--;
    }

    return *Buffer ? Buffer : NULL;
}


PCWSTR
pFindResourceIdFromIndexW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,
    IN      INT ResourceIndex,
    OUT     PWSTR Buffer
    )
{
    PCWSTR ImageList;

    if (!pLoadBinaryImageW (Context, FileContainingIcon)) {
        return NULL;
    }

    if (ResourceIndex < 0) {
        wsprintfW (Buffer, L"#%i", -ResourceIndex);
        return Buffer;
    } else {
        *Buffer = 0;
    }

    ImageList = ExtractIconNamesFromFileExW (
                    FileContainingIcon,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    while (ImageList) {
        if (!ResourceIndex) {
            StringCopyW (Buffer, ImageList);
            break;
        }

        ResourceIndex--;
    }

    return *Buffer ? Buffer : NULL;
}


BOOL
CopyIconA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,           OPTIONAL
    IN      PCSTR ResourceId,                   OPTIONAL
    IN      INT ResourceIndex                   OPTIONAL
    )
{
    BOOL IsIco;
    BOOL b;
    CHAR Buffer[256];

    if (Context->Error) {
        return FALSE;
    }

    if (!ResourceId && FileContainingIcon) {
        if (!IsFileAnIco (FileContainingIcon)) {
            ResourceId = pFindResourceIdFromIndexA (
                                Context,
                                FileContainingIcon,
                                ResourceIndex,
                                Buffer
                                );

            if (!ResourceId) {
                return FALSE;
            }
        }
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
        !Context->SaveMode
        ) {
        //
        // Get icon image from the icon image array file
        //

        b =  pGetIconImageArrayFromFileA (Context);

    } else {
        //
        // Get icon image from source file
        //

        if (!pOpenIconImageA (Context, FileContainingIcon, &IsIco, NULL)) {
            return FALSE;
        }

        if (IsIco) {
            b = pGetIconImageArrayFromIcoFileExA (
                    Context->IcoFileName,
                    &Context->IconImages,
                    Context->IcoFile
                    );
        } else {

            b = pGetIconImageArrayFromBinaryExA (
                    Context->ModuleName,
                    ResourceId,
                    &Context->IconImages,
                    Context->Module,
                    Context->Module16
                    );
        }
    }

    if (b) {
        if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
            Context->SaveMode
            ) {

            //
            // Save icon to icon image array file
            //

            b = pPutIconImageArrayInFileA (Context);

        } else {

            //
            // Save icon to PE file
            //

            b = WriteIconImageArrayToPeFileExA (
                    Context->DestFile,
                    &Context->IconImages,
                    (PCSTR) Context->GroupId,
                    &Context->IconId,
                    Context->Update
                    );
        }

        if (!b) {
            Context->Error = TRUE;
        } else {
            Context->GroupId++;
        }
    }

    return b;
}


BOOL
CopyIconW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,           // OPTIONAL if using an icon image file
    IN      PCWSTR ResourceId,                   // OPTIONAL if FileContainingIcon is an ico
    IN      INT ResourceIndex                   OPTIONAL
    )
{
    BOOL IsIco;
    BOOL b;
    WCHAR Buffer[256];

    if (Context->Error) {
        return FALSE;
    }

    if (!ResourceId && FileContainingIcon) {
        if (!IsFileAnIcoW (FileContainingIcon)) {

            ResourceId = pFindResourceIdFromIndexW (
                                Context,
                                FileContainingIcon,
                                ResourceIndex,
                                Buffer
                                );

            if (!ResourceId) {
                return FALSE;
            }
        }
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
        !Context->SaveMode
        ) {
        //
        // Get icon image from the icon image array file
        //

        b =  pGetIconImageArrayFromFileW (Context);

    } else {
        //
        // Get icon image from source file
        //

        if (!pOpenIconImageW (Context, FileContainingIcon, &IsIco, NULL)) {
            return FALSE;
        }

        if (IsIco) {
            b = pGetIconImageArrayFromIcoFileExW (
                    Context->IcoFileName,
                    &Context->IconImages,
                    Context->IcoFile
                    );
        } else {

            b = pGetIconImageArrayFromBinaryExW (
                    Context->ModuleName,
                    ResourceId,
                    &Context->IconImages,
                    Context->Module,
                    Context->Module16
                    );
        }
    }

    if (b) {
        if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
            Context->SaveMode
            ) {

            //
            // Save icon to icon image array file
            //

            b = pPutIconImageArrayInFileW (Context);

        } else {

            //
            // Save icon to PE file
            //

            b = WriteIconImageArrayToPeFileExW (
                    Context->DestFile,
                    &Context->IconImages,
                    (PCWSTR) Context->GroupId,
                    &Context->IconId,
                    Context->Update
                    );
        }

        if (!b) {
            Context->Error = TRUE;
        } else {
            Context->GroupId++;
        }
    }

    return b;
}


BOOL
CopyAllIconsA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcons
    )
{
    MULTISZ_ENUMA e;
    BOOL IsIco;
    PCSTR IconList;
    BOOL b = TRUE;

    if (Context->Error) {
        return FALSE;
    }

    if (!pOpenIconImageA (Context, FileContainingIcons, &IsIco, NULL)) {
        return FALSE;
    }

    if (IsIco) {
        return CopyIconA (Context, FileContainingIcons, NULL, 0);
    }

    IconList = ExtractIconNamesFromFileExA (
                    FileContainingIcons,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    if (!IconList) {
        return FALSE;
    }

    if (EnumFirstMultiSzA (&e, IconList)) {
        do {
            b = CopyIconA (Context, FileContainingIcons, e.CurrentString, 0);
            if (!b) {
                break;
            }

        } while (EnumNextMultiSzA (&e));
    }

    return b;
}


BOOL
CopyAllIconsW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcons
    )
{
    MULTISZ_ENUMW e;
    BOOL IsIco;
    PCWSTR IconList;
    BOOL b = TRUE;

    if (Context->Error) {
        return FALSE;
    }

    if (!pOpenIconImageW (Context, FileContainingIcons, &IsIco, NULL)) {
        return FALSE;
    }

    if (IsIco) {
        return CopyIconW (Context, FileContainingIcons, NULL, 0);
    }

    IconList = ExtractIconNamesFromFileExW (
                    FileContainingIcons,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    if (!IconList) {
        return FALSE;
    }

    if (EnumFirstMultiSzW (&e, IconList)) {
        do {
            b = CopyIconW (Context, FileContainingIcons, e.CurrentString, 0);
            if (!b) {
                break;
            }

        } while (EnumNextMultiSzW (&e));
    }

    return b;
}


BOOL
EndIconExtractionA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context
    )
{
    BOOL b = FALSE;

    if (Context->Update) {
        b = EndUpdateResource (Context->Update, Context->Error);
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
    }

    if (Context->IcoFile) {
        FreeLibrary (Context->IcoFile);
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
    }

    FreeGrowBuffer (&Context->IconImages);
    FreeGrowBuffer (&Context->IconList);

    pInitContextA (Context);

    return b;
}


BOOL
EndIconExtractionW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context
    )
{
    BOOL b = FALSE;

    if (Context->Update) {
        b = EndUpdateResource (Context->Update, Context->Error);
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
    }

    if (Context->IcoFile) {
        FreeLibrary (Context->IcoFile);
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
    }

    FreeGrowBuffer (&Context->IconImages);
    FreeGrowBuffer (&Context->IconList);

    pInitContextW (Context);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"

#define DEFAULT_GROW_SIZE 8192

PBYTE
RealGrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GrowBuffer: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GrowBuffer: Realloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return NewBuffer;
}


PBYTE
RealGrowBufferReserve (
    IN  PGROWBUFFER GrowBuf,
    IN  DWORD BytesToReserve
    )
{
    DWORD end;
    PBYTE result;

    end = GrowBuf->End;
    result = GrowBuffer (GrowBuf, BytesToReserve);
    GrowBuf->End = end;

    return result;
}


VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GrowBuffer (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return MultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return MultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GrowBuffer (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return MultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return MultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGrowBufAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GrowBuffer (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGrowBufAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGrowBufAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGrowBufAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (PBYTE) EndPlusOne - (PBYTE) Start;

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGrowBufAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (PBYTE) EndPlusOne - (PBYTE) Start;

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGrowBufCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGrowBuffer (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGrowBufCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGrowBuffer (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\inf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Provides wrappers for commonly used INF file handling routines. The wrappers provide, amount
    other things, easy memory allocation using a user supplied GROWBUFFER or POOLHANDLE

Author:

    09-Jul-1997 Marc R. Whitten (marcw) - File creation.

Revision History:

    07-Feb-2001  ovidiut  Revised the replace/append capability.
    22-Oct-1998  marcw    Added capability to replace/append inf files.
    08-Oct-1997  jimschm  OEM version of SetupGetStringField

--*/

#include "pch.h"

#define INF_REPLACE 1
#define INF_APPEND  2

#define S_VERSION_A     "Version"
#define S_TARGETINF_A   "TargetInf"
#define S_VERSION_W     L"Version"
#define S_LANGUAGE_W    L"Language"
#define S_STRINGS_W     L"Strings"
#define S_INFDIR_A      "inf"
#define S_TAG_A         "Tag"


#define INF_INVALID_VERSION 0xffff
#define INF_ANY_LANGUAGE 0

VOID InitInfReplaceTable (VOID);
UINT pGetLanguage (IN PCSTR File);


typedef struct _tagINFMOD {
    struct _tagINFMOD *Next;
    PCSTR TargetInf;
    DWORD Language;
    DWORD Version;
    PCSTR Tag;
    BOOL ReplacementFile;
    PCSTR PatchInf;
} INFMOD, *PINFMOD;


PINFMOD g_RootInfMod;
POOLHANDLE g_InfModPool;
PBOOL g_UpginfsUpdated;

VOID
InfGlobalInit (
    IN  BOOL Terminate
    )
{
    if (!Terminate) {
        g_InfModPool = PoolMemInitNamedPool ("INF Modifications");
    } else {
        PoolMemDestroyPool (g_InfModPool);
        g_RootInfMod = NULL;
    }
}


/*++

Routine Description:

    pAllocateSpace is a private function that allocates space using the user specified allocator.

Arguments:

    Context - A valid INFSTRUCT which has been initialized either by a call to InitInfStruct or
              by using one of the static initializers (INITINFSTRUCT_GROWBUFFER or
              INITINFSTRUCT_POOLHANDLE)

    Size    - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

PBYTE
pAllocateSpaceA (
    IN PINFSTRUCTA  Context,
    IN UINT         Size
    )
{

    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
        //
        // Allocate space using Poolmem.
        //
        rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GrowBuffer(&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_POOLHANDLE:
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PoolMemInitNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        }
        break;
    }

    return rBytes;
}

PBYTE
pAllocateSpaceW (
    IN PINFSTRUCTW  Context,
    IN UINT         Size
    )
{
    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
        //
        // Allocate space using Poolmem.
        //
        rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GrowBuffer(&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_POOLHANDLE:
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PoolMemInitNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        }
        break;
    }

    return rBytes;
}


/*++

Routine Description:

    This function initializes an INFSTRUCT with the user supplied allocator. It is used when
    user of the INF wrapper routines wishes to manage his own memory (i.e. such as when he
    already has a suitable allocator with sufficient scope created, etc.)

    There is no need to call this function if the user wishes to have the INF wrapper routines
    manage there own memory. Initialize your Init structure with one of either

    INITINFSTRUCT_POOLMEM or INITINFSTRUCT_GROWBUFFER, depending on your preference and needs
    for an allocator.



Arguments:

    Context      - Recieves the initialized INFSTRUCT.
    GrowBuffer   - An optional parameter containing a user supplied and initialized GROWBUFFER.
                   If this parameter is non-NULL, then PoolHandle should be NULL.
    PoolHandle   - An optional parameter containing a user supplied and initialized POOLHANDLE.
                   If this parameter is non-NULL, then GrowBuffer should be NULL.

    One of either GrowBuffer or PoolHandle *must* be specified.

Return Value:

    None.

--*/

VOID
InitInfStructA (
    OUT PINFSTRUCTA Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle   OPTIONAL
    )
{
    ZeroMemory(Context,sizeof(INFSTRUCTA));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_POOLHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_POOLHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}

VOID
InitInfStructW (
    OUT PINFSTRUCTW Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle   OPTIONAL
    )
{
    ZeroMemory(Context,sizeof(INFSTRUCTW));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_POOLHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_POOLHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}


/*++

Routine Description:

    InfCleanupInfStruct is responsible for cleaning up the data associated
    with an INFSTRUCT.  This is a mandatory call, unless the INFSTRUCT
    was initialized with InitInfStruct, called with a non-NULL grow buffer or
    pool handle.

    This routine can be called no matter how the INFSTRUCT was initialized.
    However, it will NOT free caller-owned grow buffers or pools.

Arguments:

    Context - Receives the properly cleaned up INFSTRUCT, ready to be
              reused.


Return Value:

     none

--*/

VOID
InfCleanUpInfStructA (
    IN OUT PINFSTRUCTA Context
    )
{
    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        FreeGrowBuffer (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_POOLHANDLE && Context -> PoolHandle) {
        PoolMemDestroyPool(Context -> PoolHandle);
    }

    InitInfStructA (Context, NULL, NULL);
}

VOID
InfCleanUpInfStructW (
    IN OUT PINFSTRUCTW Context
    )
{
    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        FreeGrowBuffer (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_POOLHANDLE && Context -> PoolHandle) {
        PoolMemDestroyPool(Context -> PoolHandle);
    }

    InitInfStructW (Context, NULL, NULL);
}


/*++

Routine Description:

  InfResetInfStruct resets the pool so memory can be recycled.  The intent is
  to allow a caller to reset the INFSTRUCT in order to release the memory
  obtained from getting INF fields.  This is useful in a loop of InfFindFirstLine/
  InfFindNextLine, where two or more fields are processed for each line.

  If only one field is processed in an InfFindFirstLine/InfFindNextLine loop,
  a grow buffer should be used instead.

  This routine empties the active pool block, a block that is 8K by default.  If
  more than the block size has been allocated, other memory blocks besides the
  active block will exist.  Because only the active block is reset, the pool will
  grow.

  If the caller expects more than the block size during one iteration, it should call
  InfCleanupInfStruct to free the pool completely.

Arguments:

  Context - Specifies the struct to reset


Return Value:

  none

--*/

VOID
InfResetInfStructA (
    IN OUT PINFSTRUCTA Context
    )
{
    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
    case INF_USE_PRIVATE_POOLHANDLE:
        if (Context->PoolHandle) {
            PoolMemEmptyPool (Context->PoolHandle);
        }
        break;
    }
}

VOID
InfResetInfStructW (
    IN OUT PINFSTRUCTW Context
    )
{
    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
    case INF_USE_PRIVATE_POOLHANDLE:
        if (Context->PoolHandle) {
            PoolMemEmptyPool (Context->PoolHandle);
        }
        break;
    }
}


VOID
pDeleteNode (
    IN      PINFMOD Node
    )
{
    if (Node) {
        if (Node->TargetInf) {
            PoolMemReleaseMemory (g_InfModPool, (PVOID)Node->TargetInf);
        }
        if (Node->PatchInf) {
            PoolMemReleaseMemory (g_InfModPool, (PVOID)Node->PatchInf);
        }
        PoolMemReleaseMemory (g_InfModPool, Node);
    }
}


PINFMOD
pCreateInfMod (
    IN      PCSTR TargetInf,
    IN      DWORD Language,
    IN      DWORD Version,
    IN      PCSTR Tag,                              OPTIONAL
    IN      BOOL ReplacementFile,
    IN      PCSTR PatchInf
    )
{
    PINFMOD node;

    node = (PINFMOD) PoolMemGetAlignedMemory (g_InfModPool, sizeof (INFMOD));
    if (node) {
        node->Next = NULL;
        node->TargetInf = PoolMemDuplicateString (g_InfModPool, TargetInf);
        node->Language = Language;
        node->Version = Version;
        node->Tag = Tag ? PoolMemDuplicateString (g_InfModPool, Tag) : NULL;
        node->ReplacementFile = ReplacementFile;
        node->PatchInf = PoolMemDuplicateString (g_InfModPool, PatchInf);
    }
    return node;
}


BOOL
pAddReplacementInfToTable (
    IN PSTR InfToPatch,
    IN UINT Version,
    IN UINT Language,
    IN PCSTR Tag,                              OPTIONAL
    IN DWORD Operation,
    IN PCSTR PatchInf
    )
{
    PINFMOD node;

    node = pCreateInfMod (InfToPatch, Language, Version, Tag, Operation & INF_REPLACE, PatchInf);

    if (!node) {
        return FALSE;
    }

    node->Next = g_RootInfMod;
    g_RootInfMod = node;

    return TRUE;
}


BOOL
pGetInfModificationList (
    IN      PCSTR TargetInf,
    IN      UINT TargetLanguage,
    IN      UINT TargetVersion,
    IN      PCSTR Tag,                              OPTIONAL
    OUT     PCSTR* TargetReplacementFile,           OPTIONAL
    OUT     PGROWBUFFER TargetAppendList            OPTIONAL
    )
{
    PINFMOD node;
    UINT version;
    PCSTR patchInf;
    BOOL b = FALSE;

    if (TargetReplacementFile) {
        *TargetReplacementFile = NULL;
    }
    if (TargetAppendList) {
        TargetAppendList->End = 0;
    }

    if (TargetVersion == INF_INVALID_VERSION) {
        return FALSE;
    }

    version = TargetVersion;
    patchInf = NULL;

    for (node = g_RootInfMod; node; node = node->Next) {

        if (node->Version > version &&
            (node->Language == TargetLanguage || node->Language == INF_ANY_LANGUAGE) &&
            (!Tag || !node->Tag || StringIMatchA (node->Tag, Tag)) &&
            StringIMatchA (node->TargetInf, TargetInf)
            ) {

            if (node->ReplacementFile) {
                //
                // rev the version#; new minimum version will be that of the replacement file
                //
                version = node->Version;
                patchInf = node->PatchInf;
                b = TRUE;
            }
        }
    }

    if (TargetReplacementFile) {
        *TargetReplacementFile = patchInf;
    }

    //
    // for append nodes, add to the list only those that have a higher version than the
    // target or the replacement file
    //
    for (node = g_RootInfMod; node; node = node->Next) {

        if (node->Version > version &&
            (node->Language == TargetLanguage || node->Language == INF_ANY_LANGUAGE) &&
            (!Tag || !node->Tag || StringIMatchA (node->Tag, Tag)) &&
            StringIMatchA (node->TargetInf, TargetInf) &&
            !node->ReplacementFile
            ) {

            if (TargetAppendList) {
                MultiSzAppendA (TargetAppendList, node->PatchInf);
            }
            b = TRUE;
        }
    }
    if (TargetAppendList && TargetAppendList->End) {
        MultiSzAppendA (TargetAppendList, "");
    }

    return b;
}


VOID
pDestroyInfModList (
    IN      PINFMOD List
    )
{
    PINFMOD node, next;

    node = List;
    while (node) {
        next = node->Next;
        pDeleteNode (node);
        node = next;
    }
}


/*++

Routine Description:

    InfOpenInfFileA and InfOpenInfFileW are wrappers for the SetupOpenInfFile function.
    They cut down the number of parameters necessary to open an INF file by supplying
    the most common options for non-user specified parameters.

    A call to one of these functions is equivelant to
    SetupOpenInfFile(<FileName>,NULL,INF_STYLE_WIN4,NULL)

Arguments:

    FileName - Contains the name of the INF file to open. See the help for SetupOpenInfFile
               for special details concerning this parameter.

Return Value:

    If the INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
RealInfOpenInfFileA (
    IN PCSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )


{
    PCSTR p;
    HINF rInf;
    UINT language;
    static BOOL firstCall = TRUE;
    GROWBUFFER AppendList = GROWBUF_INIT;
    MULTISZ_ENUM e;
    UINT version;
    PCSTR replacementFile;
    CHAR windir[MAX_MBCHAR_PATH];
    CHAR buf[MAX_MBCHAR_PATH];
    PCSTR tag;
    PCSTR fullPath = NULL;

    MYASSERT(FileSpec);

    if (firstCall || (g_UpginfsUpdated != NULL && *g_UpginfsUpdated)) {

        //
        // Generate the necessary memdb sections for the replace/adds.
        //
        InitInfReplaceTable ();
        firstCall = FALSE;
        if (g_UpginfsUpdated) {
            *g_UpginfsUpdated = FALSE;
        }
    }

    //
    // if FileSpec is incomplete, make the full path first
    //
    if (!_mbschr (FileSpec, '\\')) {
        if (GetWindowsDirectoryA (windir, MAX_MBCHAR_PATH)) {
            WIN32_FIND_DATAA fd;
            p = JoinPathsA (windir, S_INFDIR_A);
            fullPath = JoinPathsA (p, FileSpec);
            FreePathStringA (p);
            if (!DoesFileExistExA (fullPath, &fd) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                ) {
                FreePathStringA (fullPath);
                if (GetSystemDirectoryA (windir, MAX_MBCHAR_PATH)) {
                    fullPath = JoinPathsA (windir, FileSpec);
                    if (!DoesFileExistExA (fullPath, &fd) ||
                        (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                        ) {
                        FreePathStringA (fullPath);
                        fullPath = NULL;
                    }
                }
            }
        }
        if (fullPath) {
            FileSpec = fullPath;
        }
    }

    //
    // gather info we'll need to determine if there are infs to replace/append
    // this inf.
    //
    p = GetFileNameFromPathA (FileSpec);

    language = pGetLanguage (FileSpec);
    version = GetPrivateProfileIntA (
                    S_VERSION_A,
                    S_VERSION_A,
                    INF_INVALID_VERSION,
                    FileSpec
                    );

    if (GetPrivateProfileStringA (
                    S_VERSION_A,
                    S_TAG_A,
                    TEXT(""),
                    buf,
                    MAX_MBCHAR_PATH,
                    FileSpec
                    )) {
        tag = buf;
    } else {
        tag = NULL;
    }

    if (!pGetInfModificationList (p, language, version, tag, &replacementFile, &AppendList)) {
        replacementFile = FileSpec;
    } else {
        if (replacementFile) {
            LOGA ((LOG_INFORMATION, "Using replacement file %s for %s", replacementFile, FileSpec));
        } else {
            replacementFile = FileSpec;
        }
    }

    //
    // Open the main inf.
    //
    rInf = SetupOpenInfFileA (
                replacementFile,
                NULL,
                INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                NULL
                );

    //
    // Append language and non-language-specific .add files.
    //
    if (rInf != INVALID_HANDLE_VALUE) {
        if (EnumFirstMultiSzA (&e, (PCSTR) AppendList.Buf)) {
            do {

                if (!SetupOpenAppendInfFileA (e.CurrentString, rInf, NULL)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Unable to append %s to %s.",
                        e.CurrentString,
                        FileSpec
                        ));
                } else {
                    LOGA ((LOG_INFORMATION, "Using append file %s for %s", e.CurrentString, FileSpec));
                }

            } while (EnumNextMultiSzA (&e));
        }
    }

    FreeGrowBuffer (&AppendList);

    if (rInf != INVALID_HANDLE_VALUE) {
        DebugRegisterAllocation (INF_HANDLE, (PVOID) rInf, File, Line);
    }
    if (fullPath) {
        FreePathStringA (fullPath);
    }

    return rInf;
}


HINF
RealInfOpenInfFileW (
    IN PCWSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR AnsiFileSpec;
    HINF rInf;

    AnsiFileSpec = ConvertWtoA (FileSpec);

    MYASSERT (AnsiFileSpec);

    rInf = InfOpenInfFileA (AnsiFileSpec);

    FreeConvertedStr (AnsiFileSpec);

    return rInf;
}


VOID
InfCloseInfFile (
    HINF Inf
    )
{

    DebugUnregisterAllocation (INF_HANDLE, Inf);


    SetupCloseInfFile (Inf);
}



/*++

Routine Description:

    InfOpenInfInAllSourcesA and InfOpenInfInAllSourcesW are special inf open routines that
    are capable of opening multiple versions of the same inf file that may be spread out across
    installation directories. The first INF file found will be opened with a call to
    SetupOpenInfFile. Additional files will be opened with SetupOpenAppendInfFile.

Arguments:

    InfSpecifier - Contains the source directory indepent portion of the path to a particular inf file.
                   For files located in the root of the source directory, this will simply be the name
                   of the file. For files located in a sub-directory of the source directory, this will
                   be a partial path.

    SourceCount  - Contains the number of source directories

    SourceDirectories - Contains an array of all the source directories.


Return Value:

    If any INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    )
{
    DWORD           index;
    HINF            rInf = INVALID_HANDLE_VALUE;
    PSTR            curPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsA(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistA (curPath)) {

            //
            // Open the INF file.
            //
            rInf = InfOpenInfFileA(curPath);
            if (rInf == INVALID_HANDLE_VALUE) {
                LOGA ((LOG_ERROR, "Error opening INF %s.", curPath));
            }
        }

        //
        // Free this string.
        //
        FreePathStringA(curPath);

        if (rInf != INVALID_HANDLE_VALUE) {
            //
            // done
            //
            break;
        }
    }

    return rInf;
}



HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    )
{
    DWORD index;
    HINF rInf = INVALID_HANDLE_VALUE;
    PWSTR curPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsW(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistW (curPath)) {

            //
            // Open the INF file.
            //
            rInf = InfOpenInfFileW(curPath);
            if (rInf == INVALID_HANDLE_VALUE) {
                LOGW ((LOG_ERROR, "OpenInfInAllSources: Error opening INF %s.", curPath));
            }
        }

        //
        // Free this string.
        //
        FreePathStringW(curPath);

        if (rInf != INVALID_HANDLE_VALUE) {
            //
            // done
            //
            break;
        }
    }

    return rInf;
}



/*++

Routine Description:

    InfGetLineTextA and InfGetLineTextW are wrappers for the SetupGetLineText function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCTA Context
    )
{
    PSTR    rLine = NULL;
    UINT   requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextA(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextA(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetLineTextA: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}

PWSTR
InfGetLineTextW (
    IN OUT PINFSTRUCTW Context
    )
{
    PWSTR rLine = NULL;
    UINT requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextW(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextW(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetLineTextW: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}


/*++

Routine Description:

    InfGetMultiSzFieldA and InfGetMultiSzFieldW are wrappers for the SetupGetMultiSzField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated fields or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCTA     Context,
    IN     UINT            FieldIndex
    )
{

    UINT   requiredSize;
    PSTR    rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldA(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetMultiSzFieldA: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCTW     Context,
    IN     UINT            FieldIndex
    )
{

    UINT   requiredSize;
    PWSTR   rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldW(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetMultiSzFieldW: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

/*++

Routine Description:

    InfGetStringFieldA and InfGetStringFieldW are wrappers for the SetupGetStringField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetStringFieldA (
    IN OUT  PINFSTRUCTA Context,
    IN      UINT FieldIndex
    )
{

    UINT   requiredSize;
    PSTR    rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldA(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetStringFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCTW  Context,
    IN     UINT         FieldIndex
    )
{

    UINT requiredSize;
    PWSTR rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldW(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetStringFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


/*++

Routine Description:

    InfGetIntField is a wrapper for SetupGetIntField. It is virtually identical to this function
    except that it takes care of getting the INFCONTEXT out of the INFSTRUCT structure.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line from which to retrieve the field.

    Value   - Recieves the value of the requested Int field.

Return Value:

     TRUE if the field was successfully retrieved, FALSE otherwise. Use GetLastError() To receive
     extended error information.

--*/

BOOL
InfGetIntFieldA (
    IN PINFSTRUCTA  Context,
    IN UINT         FieldIndex,
    IN PINT         Value
    )
{
    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}

BOOL
InfGetIntFieldW (
    IN PINFSTRUCTW  Context,
    IN UINT         FieldIndex,
    IN PINT         Value
    )
{
    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}


/*++

Routine Description:

    InfGetBinaryField is a wrapper for the SetupGetBinaryField function. It reduces
    the number of parameters required to get the line text and takes care of
    allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.
    FieldIndex - the index within the line of the desired binary information.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PBYTE
InfGetBinaryFieldA (
    IN  PINFSTRUCTA     Context,
    IN  UINT            FieldIndex
    )
{

    UINT requiredSize;
    PBYTE rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpaceA(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetBinaryFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PBYTE
InfGetBinaryFieldW (
    IN  PINFSTRUCTW     Context,
    IN  UINT            FieldIndex
    )
{

    UINT requiredSize;
    PBYTE rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpaceW(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetBinaryFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


/*++

Routine Description:

  InfGetIndexByLine is a straight wrapper for SetupGetLineByIndex. The only
  difference is the use of an PINFSTRUCT instead of a PINFCONTEXT.

Arguments:

  InfHandle - Contains a valid HINF.

  Section   - Contains the name of the section within the InfFile.

  Index     - Contains the index within the section of the line in question.

  Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

  TRUE if the function was called successfully, FALSE otherwise.

--*/


BOOL
InfGetLineByIndexA (
    IN HINF         InfHandle,
    IN PCSTR        Section,
    IN DWORD        Index,
    OUT PINFSTRUCTA Context
    )
{
    return SetupGetLineByIndexA(InfHandle,Section,Index,&(Context -> Context));
}

BOOL
InfGetLineByIndexW (
    IN HINF         InfHandle,
    IN PCWSTR       Section,
    IN DWORD        Index,
    OUT PINFSTRUCTW Context
    )
{
    return SetupGetLineByIndexW(InfHandle,Section,Index,&(Context -> Context));
}


/*++

Routine Description:

    InfFindFirstLineA and InfFindFirstLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS.

Arguments:


    InfHandle - Contains a valid HINF.

    Section   - Contains the name of the section within the InfFile.

    Key       - An optional parameter containing the name of the key within the section to find.
                If NULL, these routines will return the first line in the section.

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if lines exist in the section, FALSE otherwise.

--*/

BOOL
InfFindFirstLineA (
    IN  HINF         InfHandle,
    IN  PCSTR        Section,
    IN  PCSTR        Key,       OPTIONAL
    OUT PINFSTRUCTA  Context
    )
{
    if (Key) {
        Context->KeyName = (PCSTR) pAllocateSpaceA (Context, SizeOfStringA (Key));
        StringCopyA ((PSTR)Context->KeyName, Key);
    } else {
        Context->KeyName = NULL;
    }
    return SetupFindFirstLineA (
        InfHandle,
        Section,
        Context->KeyName,
        &(Context -> Context)
        );
}

BOOL
InfFindFirstLineW (
    IN HINF         InfHandle,
    IN PCWSTR       Section,
    IN PCWSTR       Key,        OPTIONAL
    OUT PINFSTRUCTW Context
    )
{
    if (Key) {
        Context->KeyName = (PCWSTR) pAllocateSpaceW (Context, SizeOfStringW (Key));
        StringCopyW ((PWSTR)Context->KeyName, Key);
    } else {
        Context->KeyName = NULL;
    }
    return SetupFindFirstLineW (
        InfHandle,
        Section,
        Context->KeyName,
        &(Context -> Context)
        );
}


/*++

Routine Description:

    InfFindNextLineA and InfFindNextLineW are wrappers for the SetupFindNextMatchLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS and
    need only one INFSTRUCT parameter.

Arguments:

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if there is another line in the section, FALSE otherwise.

--*/

BOOL
InfFindNextLineA (
    IN OUT PINFSTRUCTA    Context
    )
{
    return SetupFindNextMatchLineA (&(Context -> Context), Context->KeyName, &(Context -> Context));
}

BOOL
InfFindNextLineW (
    IN OUT PINFSTRUCTW    Context
    )
{
    return SetupFindNextMatchLineW (&(Context -> Context), Context->KeyName, &(Context -> Context));
}


UINT
InfGetFieldCountA (
    IN PINFSTRUCTA Context
    )
{
    return SetupGetFieldCount(&(Context  -> Context));
}

UINT
InfGetFieldCountW (
    IN PINFSTRUCTW Context
    )
{
    return SetupGetFieldCount(&(Context  -> Context));
}


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCTA Context,
    IN      UINT        Field
    )

/*++

Routine Description:

  InfGetOemStringField returns a string field in the OEM character set.
  This routine is used when accessing txtsetup.sif.  It is implemented
  only in the A version because UNICODE does not have a concept of OEM
  characters.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Field - Specifies the field number

Return Value:

  A pointer to the OEM string, or NULL if an error occurred.

--*/

{
    PCSTR Text;
    PSTR OemText;
    INT Size;

    Text = InfGetStringFieldA (Context, Field);
    if (!Text) {
        return NULL;
    }

    Size = SizeOfStringA (Text);

    OemText = (PSTR) pAllocateSpaceA (Context, Size);
    if (!OemText) {
        return NULL;
    }

    //
    // We leave Text allocated because the caller will free everything
    // when they clean up Context.  Note the assumption that the conversion
    // doesn't change string length.
    //

    OemToCharBuffA (Text, OemText, Size);

    return OemText;
}


BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,                 OPTIONAL
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize                 OPTIONAL
    )

/*++

Routine Description:

  SetupGetOemStringFieldA is a SetupGetStringField that converts the
  return text to the OEM character set.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Index - Specifies the field number

  ReturnBuffer - Specifies the buffer to fill the text into

  ReturnBufferSize - Specifies the size of ReturnBuffer in bytes

  RequiredSize - Receives the size of the buffer needed

Return Value:

  TRUE if successful, FALSE if failure.

--*/

{
    PSTR OemBuf;

    INT Size;

    if (!SetupGetStringFieldA (
            Context,
            Index,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            )) {
        return FALSE;
    }

    if (!ReturnBuffer) {
        return TRUE;
    }

    Size = SizeOfStringA (ReturnBuffer);

    OemBuf = (PSTR) MemAlloc (g_hHeap, 0, Size);

    OemToCharBuffA (ReturnBuffer, OemBuf, Size);
    StringCopyA (ReturnBuffer, OemBuf);
    MemFree (g_hHeap, 0, OemBuf);

    return TRUE;
}


UINT
pGetLanguage (
    IN PCSTR File
    )
{

    HINF inf = INVALID_HANDLE_VALUE;
    PINFSECTION section;
    PINFLINE line;
    PWSTR start, end;
    UINT rLanguage = INF_INVALID_VERSION;
    WCHAR envvar[MAX_MBCHAR_PATH];

    *envvar = 0;

    //
    // Use the infparse rourtines to get this information. They
    // are more reliable than the *privateprofile* apis.
    //

    inf = OpenInfFileExA (File, "version, strings", FALSE);
    if (inf == INVALID_HANDLE_VALUE) {
        return rLanguage;
    }
    section = FindInfSectionInTableW (inf, S_VERSION_W);

    if (section) {
        line = FindLineInInfSectionW (inf, section, S_LANGUAGE_W);

        if (line && line->Data) {

            start = wcschr (line->Data, L'%');
            if (start) {
                end = wcschr (start + 1, L'%');

                if (end) {
                    StringCopyABW(envvar, start+1, end);
                }
            }
            else {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (*envvar) {
        //
        // Get the data from the strings section.
        //
        section = FindInfSectionInTableW (inf, S_STRINGS_W);
        if (section) {

            line = FindLineInInfSectionW (inf, section, envvar);

            if (line && line->Data) {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (inf != INVALID_HANDLE_VALUE) {
        CloseInfFile (inf);
    }
    return rLanguage;
}



VOID
InitInfReplaceTable (
    VOID
    )
{
    CHAR systemPath[MAX_MBCHAR_PATH];
    CHAR buffer[MAX_MBCHAR_PATH];
    PSTR upginfsDir;
    BOOL validFile;
    TREE_ENUMA e;
    INT version;
    INT language;
    DWORD operation;
    BOOL bReplace, bAdd;
    CHAR buf[MAX_MBCHAR_PATH];
    PCSTR tag;

//  pDestroyInfModList (g_RootInfMod);
    PoolMemEmptyPool (g_InfModPool);
    g_RootInfMod = NULL;

    //
    // Look in the special directory %windir%\upginfs for anything to add
    // to our list.
    //
    if (GetWindowsDirectoryA (systemPath, MAX_MBCHAR_PATH)) {

        upginfsDir = JoinPathsA (systemPath, S_UPGINFSDIR);

        if (EnumFirstFileInTreeA (&e, upginfsDir, NULL, FALSE)) {

            do {

                //
                // we only care about *.rep and *.add files. Ignore everything
                // else.
                //
                if (e.Directory) {
                    continue;
                }

                bReplace = IsPatternMatchA ("*.rep", e.Name);
                bAdd = IsPatternMatchA ("*.add", e.Name);
                if (bAdd || bReplace) {

                    __try {

                        validFile = FALSE;

                        operation = bReplace ? INF_REPLACE : INF_APPEND;

                        GetPrivateProfileStringA (
                            S_VERSION_A,
                            S_TARGETINF_A,
                            "",
                            buffer,
                            MAX_MBCHAR_PATH,
                            e.FullPath
                            );

                        if (!*buffer) {
                            __leave;
                        }

                        version = GetPrivateProfileIntA (
                                        S_VERSION_A,
                                        S_VERSION_A,
                                        INF_INVALID_VERSION,
                                        e.FullPath
                                        );


                        //
                        // version is ALWAYS needed
                        //
                        if (version == INF_INVALID_VERSION) {
                            __leave;
                        }

                        language = pGetLanguage (e.FullPath);

                        if (language == INF_INVALID_VERSION) {
                            __leave;
                        }

                        if (GetPrivateProfileStringA (
                                        S_VERSION_A,
                                        S_TAG_A,
                                        TEXT(""),
                                        buf,
                                        MAX_MBCHAR_PATH,
                                        e.FullPath
                                        )) {
                            tag = buf;
                        } else {
                            tag = NULL;
                        }

                        validFile = TRUE;
                    }
                    __finally {

                        if (!validFile || !pAddReplacementInfToTable (buffer, version, language, tag, operation, e.FullPath)) {
                            DEBUGMSGA ((DBG_WARNING,"Invalid Replace or Add file found in %s.",upginfsDir));
                        }
                    }
                } else {
                    DEBUGMSGA ((
                        DBG_WARNING,
                        "Non .rep or .add file found in %s directory! Unexpected.",
                        upginfsDir
                        ));
                }

            } while (EnumNextFileInTreeA (&e));
        }
        ELSE_DEBUGMSGA ((DBG_VERBOSE, "InfInitialize: No infs in %s directory.", upginfsDir));

        FreePathStringA (upginfsDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be manipulated.

  The entry points are:

  OpenInfFile - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"


//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


typedef struct {
    HANDLE SourceInfFile;
    HANDLE DestInfFile;
    POOLHANDLE InfPool;             // A pool for appended INF data
    PINFSECTION FirstInfSection;    // The first section of the parsed INF
    PINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} INFFILE, *PINFFILE;



BOOL
pReadInfIntoTable (
    IN OUT  PINFFILE InfFile,
    IN PWSTR SectionList,
    IN BOOL KeepComments
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.

Arguments:

  InfFile - Specifies the structure initilized with the INF file handle.
            Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = GROWBUF_INIT;
    PCWSTR Text;
    DWORD Pos;
    PCWSTR Key, Data;
    PWSTR p, q;
    DWORD i;
    PINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;
    HASHTABLE ht = NULL;
    BOOL neededSection = FALSE;
    PWSTR list;


    Section = AddInfSectionToTableW (InfFile, L"");
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }


    //
    // If we have a list of sections to fill, add them to a ht, for faster retrieval.
    //
    if (SectionList) {
        list = PoolMemDuplicateStringW (InfFile->InfPool, SectionList);
        ht = HtAllocW ();
        if (ht) {
            while (list) {

                p = wcschr (list, L',');

                if (p) {
                    *p = 0;
                }

                HtAddStringW (ht, SkipSpaceW(list));

                if (p) {
                    *p = L',';
                    list = p + 1;
                }
                else {
                    list = p;
                }
            }
        }
        else {

            LOG ((LOG_ERROR, "Read Inf Into Table: Could not allocate section hash table."));
            return FALSE;
        }

    }


    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pGetInfFileWchar (InfFile->SourceInfFile, 0, &Error);
        InfFile->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        for (;;) {
            //
            // Get the line
            //

            Text = pGetNextInfLine (
                        InfFile->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        InfFile->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PWSTR) SkipSpaceW (Text);
            if (!p[0] || p[0] == L';') {
                if (KeepComments && !AddInfLineToTableW (InfFile, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (p[0] == L'[') {
                p++;
                q = wcschr (p, L']');
                if (!q) {
                    q = GetEndOfStringW (p);
                } else {
                    *q = 0;
                }

                if (!ht || HtFindStringW (ht, p)) {

                    Section = AddInfSectionToTableW (InfFile, p);
                    neededSection = TRUE;
                    if (!Section) {
                        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                        __leave;
                    }
                }
                else {

                    //
                    // We must not care about this section. Make sure we don't add any lines.
                    //
                    neededSection = FALSE;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                if (!neededSection) {
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (q[0] == L'\"') {
                    q = wcschr (q + 1, L'\"');
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q++;
                    }
                }

                i = (DWORD)wcscspn (q, L"\"=");

                if (q[i] == L'=') {
                    q += i;

                    Data = SkipSpaceW (q + 1);
                    *q = 0;
                    q = (PWSTR) SkipSpaceRW (Text, q);
                    if (q && *q) {
                        q++;
                        *q = 0;
                    }

                    Key = p;

                    if (Key[0] == L'\"') {

                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key++;

                        p = GetEndOfStringW (Key);
                        p = (PWSTR) SkipSpaceRW (Key, p);

                        if (p && *p) {
                            if (p[0] != L'\"') {
                                p++;
                            }

                            *p = 0;
                        }
                    }
                }

                if (!AddInfLineToTableW (InfFile, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (InfFile->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        FreeGrowBuffer (&LineBuf);
        if (ht) {
            HtFree (ht);
        }
    }

    return Result;
}


VOID
CloseInfFile (
    HINF InfFile
    )
{
    PINFFILE inf = (PINFFILE) InfFile;

    PoolMemEmptyPool (inf->InfPool);
    PoolMemDestroyPool (inf->InfPool);
    MemFree (g_hHeap, 0, inf);

}


HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;
    PWSTR wSectionList = NULL;


    if (SectionList) {
        wSectionList = (PWSTR) ConvertAtoW (SectionList);
    }



    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileA (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PoolMemInitNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, wSectionList, KeepComments);
    }

    if (wSectionList) {
        FreeConvertedStr (wSectionList);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PoolMemDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;

    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileW (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PoolMemInitNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, SectionList, KeepComments);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PoolMemDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


BOOL
pWriteFileStringBufferedA (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PCSTR String
    )
{
    UINT stringBytes;
    PBYTE byteBuf;
    DWORD bytesWritten;

    if (!String) {
        if (Buffer->End) {
            if (!WriteFile (File, Buffer->Buf, Buffer->End, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != Buffer->End) {
                return FALSE;
            }

            Buffer->End = 0;
        }

        return TRUE;
    }

    stringBytes = ByteCountA (String);
    if (!stringBytes) {
        return TRUE;
    }

    if (stringBytes + Buffer->End > Buffer->Size) {
        //
        // Flush buffer by calling ourselves with a NULL String
        //

        if (!pWriteFileStringBufferedA (Buffer, File, NULL)) {
            return FALSE;
        }

        //
        // If string is huge, just write it directly
        //

        if (stringBytes > Buffer->Size) {
            if (!WriteFile (File, String, stringBytes, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != stringBytes) {
                return FALSE;
            }

            return TRUE;
        }
    }

    //
    // Put string in buffer
    //

    byteBuf = GrowBuffer (Buffer, stringBytes);
    CopyMemory (byteBuf, String, stringBytes);

    return TRUE;
}


BOOL
pWriteFileStringBufferedW (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PCWSTR String
    )
{
    UINT stringBytes;
    PBYTE byteBuf;
    DWORD bytesWritten;

    if (!String) {
        if (Buffer->End) {
            if (!WriteFile (File, Buffer->Buf, Buffer->End, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != Buffer->End) {
                return FALSE;
            }

            Buffer->End = 0;
        }

        return TRUE;
    }

    stringBytes = ByteCountW (String);

    if (stringBytes + Buffer->End > Buffer->Size) {
        //
        // Flush buffer by calling ourselves with a NULL String
        //

        if (!pWriteFileStringBufferedW (Buffer, File, NULL)) {
            return FALSE;
        }

        //
        // If string is huge, just write it directly
        //

        if (stringBytes > Buffer->Size) {
            if (!WriteFile (File, String, stringBytes, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != stringBytes) {
                return FALSE;
            }

            return TRUE;
        }
    }

    //
    // Put string in buffer
    //

    byteBuf = GrowBuffer (Buffer, stringBytes);
    CopyMemory (byteBuf, String, stringBytes);

    return TRUE;
}


BOOL
pSaveInfToFile (
    IN      PINFFILE InfFile
    )

/*++

Routine Description:

  pSaveInfToFile writes the INF represented by the given memory image to disk.
  This is done by enumerating the INF data structures in the INF.

Arguments:

  InfFile - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PINFSECTION Section;
    PINFLINE Line;
    BYTE UnicodeHeader[] = { 0xff, 0xfe };
    DWORD DontCare;
    BOOL b = FALSE;
    GROWBUFFER outputBuf = GROWBUF_INIT;
    GROWBUFFER conversionBuf = GROWBUF_INIT;
    UINT maxBytes;

    MYASSERT (InfFile->SourceInfFile == INVALID_HANDLE_VALUE);
    MYASSERT (InfFile->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    __try {
        //
        // Write the unicode indicator. We rely on the fact that this is first--
        // the output buffer is not in use yet.
        //

        if (InfFile->InfIsUnicode) {
            if (!WriteFile (InfFile->DestInfFile, UnicodeHeader, sizeof (UnicodeHeader), &DontCare, NULL)) {
                __leave;
            }
        }

        //
        // Initialize the output buffer. It will never grow larger than what
        // we specify here.
        //

        GrowBuffer (&outputBuf, 16384);
        outputBuf.End = 0;

        //
        // Loop through all the sections
        //

        Section = InfFile->FirstInfSection;

        while (Section) {

            //
            // If a section name exists, write it in brackets. Section names
            // can be empty when comments appear at the top of the file.
            //

            if (Section->Name[0]) {

                if (InfFile->InfIsUnicode) {

                    if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"[") ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Section->Name) ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"]\r\n")
                        ) {
                        __leave;
                    }
                } else {

                    maxBytes = SizeOfStringW (Section->Name);
                    conversionBuf.End = 0;
                    GrowBuffer (&conversionBuf, maxBytes);

                    DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Section->Name, maxBytes);

                    if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "[") ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf) ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "]\r\n")
                        ) {
                        __leave;
                    }
                }
            }

            //
            // Write all the lines within the section
            //

            Line = Section->FirstLine;

            while (Line) {
                //
                // Write the key if it is present. Quote it if necessary.
                //

                if (Line->Key) {
                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (InfFile->InfIsUnicode) {
                            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\"")) {
                                __leave;
                            }
                        } else {
                            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\"")) {
                                __leave;
                            }
                        }
                    }

                    if (InfFile->InfIsUnicode) {

                        if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Line->Key)) {
                            __leave;
                        }

                    } else {

                        maxBytes = SizeOfStringW (Line->Key);
                        conversionBuf.End = 0;
                        GrowBuffer (&conversionBuf, maxBytes);

                        DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Line->Key, maxBytes);

                        if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf)) {
                            __leave;
                        }
                    }

                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (InfFile->InfIsUnicode) {
                            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\"")) {
                                __leave;
                            }
                        } else {
                            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\"")) {
                                __leave;
                            }
                        }
                    }

                    //
                    // Note that when we write equals, we might add some
                    // space. Since space is trimmed by the INF parser, we say
                    // this is acceptable because it improves readability.
                    //

                    if (InfFile->InfIsUnicode) {

                        if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L" = ")) {
                            __leave;
                        }

                    } else {

                        if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, " = ")) {
                            __leave;
                        }
                    }
                }

                //
                // Write the rest of the line
                //

                if (InfFile->InfIsUnicode) {

                    if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Line->Data) ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\r\n")
                        ) {

                        __leave;
                    }

                } else {

                    maxBytes = SizeOfStringW (Line->Data);
                    conversionBuf.End = 0;
                    GrowBuffer (&conversionBuf, maxBytes);

                    DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Line->Data, maxBytes);

                    if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf) ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\r\n")
                        ) {
                        __leave;
                    }
                }

                Line = Line->Next;
            }

            Section = Section->Next;
        }

        //
        // Flush output buffer
        //

        if (InfFile->InfIsUnicode) {
            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, NULL)) {
                __leave;
            }
        } else {
            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, NULL)) {
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {
        FreeGrowBuffer (&outputBuf);
        FreeGrowBuffer (&conversionBuf);

        DEBUGMSG_IF((!b, DBG_ERROR, "Write Inf To Disk: Cannot write INF"));
    }

    return b;
}


BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileA (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileA (SaveToFileSpec);
    }

    return b;
}


BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileW (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileW (SaveToFileSpec);
    }

    return b;
}


PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION SectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    SectionPtr = AddInfSectionToTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (SectionName);

    return SectionPtr;
}


PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  Inf - Specifies the INF to add the section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PINFSECTION NewSection;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Return early if this section already exists
    //

    NewSection = FindInfSectionInTableW (InfFile, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PINFSECTION) PoolMemGetAlignedMemory (
                                    InfFile->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PoolMemDuplicateStringW (
                            InfFile->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = InfFile->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        InfFile->FirstInfSection = NewSection;
    }

    //
    // Add a blank line to LastInfSection to make things tidy
    //

    if (InfFile->LastInfSection) {
        AddInfLineToTableW (Inf, InfFile->LastInfSection, NULL, L"", 0);
    }

    //
    // Finalize linkage
    //

    InfFile->LastInfSection = NewSection;

    return NewSection;
}


PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    )
{
    PCWSTR UnicodeKey;
    PCWSTR UnicodeData;
    PINFLINE Line;

    if (Key) {
        UnicodeKey = ConvertAtoW (Key);
    } else {
        UnicodeKey = NULL;
    }

    UnicodeData = ConvertAtoW (Data);

    Line = AddInfLineToTableW (Inf, SectionPtr, UnicodeKey, UnicodeData, LineFlags);

    if (Key) {
        FreeConvertedStr (UnicodeKey);
    }

    FreeConvertedStr (UnicodeData);

    return Line;
}


PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  InfFile - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PINFLINE NewLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Allocate line struct
    //

    NewLine = (PINFLINE) PoolMemGetAlignedMemory (
                              InfFile->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link. We insert the line at the end
    // of the section but before all blank space.
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PoolMemDuplicateStringW (
                            InfFile->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PoolMemDuplicateStringW (
                        InfFile->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    while (NewLine->Prev) {
        if (NewLine->Prev->Key || *NewLine->Prev->Data) {
            break;
        }

        NewLine->Next = NewLine->Prev;
        NewLine->Prev = NewLine->Prev->Prev;
    }

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    if (NewLine->Next) {
        NewLine->Next->Prev = NewLine;
    } else {
        SectionPtr->LastLine = NewLine;
    }

    SectionPtr->LineCount++;

    return NewLine;
}


PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION InfSectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    InfSectionPtr = FindInfSectionInTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return InfSectionPtr;
}


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PINFSECTION Section;
    PINFFILE InfFile = (PINFFILE) Inf;

    Section = InfFile->FirstInfSection;
    while (Section) {
        if (StringIMatchW (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    )
{

    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfFile) {
        return InfFile->FirstInfSection;
    }

    return NULL;
}

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    )
{

    if (Section) {
        return Section->Next;
    }

    return NULL;
}




PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    )

{
    PCWSTR UnicodeKey;
    PINFLINE LinePtr;

    UnicodeKey = ConvertAtoW (Key);

    LinePtr = FindLineInInfSectionW (Inf, Section, UnicodeKey);

    FreeConvertedStr (UnicodeKey);

    return LinePtr;
}


PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatchW (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return GetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PCWSTR UnicodeSection;
    PINFLINE LinePtr;

    UnicodeSection = ConvertAtoW (Section);

    LinePtr = GetFirstLineInSectionStrW (Inf, UnicodeSection);

    FreeConvertedStr (UnicodeSection);

    return LinePtr;
}


PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PINFSECTION SectionPtr;
    PINFFILE Table = (PINFFILE) Inf;

    SectionPtr = FindInfSectionInTableW (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return GetFirstLineInSectionStruct (SectionPtr);
}


INT
pGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, (LONG)g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return (WORD) c;
    }

    ch = (WORD) c;

    c = pGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    // pGetInfFileByte return a byte value or -1.
    // Since we checked for -1 the next cast is valid.
    ch += (WORD)(c * 256);
    *Error = FALSE;

    return ch;
}


PCSTR
pGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == L'\r' || ch == L'\n') {
            EndPos += 2;
            if (ch == L'\r') {
                ch = pGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a string supplying the line.  This string can be any length and
  is nul-terminated.  It does not include the \r or \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCWSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = MultiSzAppendW (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCWSTR) LineBuf->Buf;
}


BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  Inf - Specifies the INF to modify

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine);
    return TRUE;
}


BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  InfFile - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFLINE InfLine;
    PINFLINE DelInfLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!DeleteLineInInfSection (InfFile, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        InfFile->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        InfFile->LastInfSection = Section->Prev;
    }

    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) Section->Name);
    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\linkpif.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    linkpif.c

Abstract:

    Functions to query and modify LNK and PIF files.

Author:

    Calin Negreanu (calinn) 07-Sep-1998

Revision History:

--*/


#include "pch.h"

#include <pif.h>        // private\windows\inc


BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    hres = CoInitialize (NULL);
    if (!SUCCEEDED (hres)) {
        return FALSE;
    }

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkA, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    hres = CoInitialize (NULL);
    if (!SUCCEEDED (hres)) {
        return FALSE;
    }

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkW, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}


BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}


PVOID
FindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    )

/*++

Routine Description:

  FindEnhPifSignature finds a certain PIF structure inside a PIF file (if it exists)
  based on a signature.

Arguments:

  FileImage - image of the PIF file mapped into memory

  Signature - structure signature

Return Value:

  address of the PIF structure, or NULL if non existent

--*/

{
    PBYTE tempPtr;
    PBYTE lastPtr;
    PVOID result = NULL;
    BOOL finished = FALSE;

    PPIFEXTHDR pifExtHdr;

    lastPtr = (PBYTE) FileImage;
    tempPtr = (PBYTE) FileImage;
    tempPtr += sizeof (STDPIF);

    pifExtHdr = (PPIFEXTHDR) tempPtr;
    __try {
        do {
            if (tempPtr < lastPtr) {
                result = NULL;
                break;
            } else {
                lastPtr = tempPtr;
            }
            finished = pifExtHdr->extnxthdrfloff == LASTHDRPTR;
            if (StringMatchA (pifExtHdr->extsig, Signature)) {
                result = tempPtr + sizeof (PIFEXTHDR);
                break;
            }
            else {
                tempPtr = (PBYTE)FileImage + pifExtHdr->extnxthdrfloff;
                pifExtHdr = (PPIFEXTHDR) tempPtr;
            }

        } while (!finished);
    }
    __except (1) {
        // something went wrong trying to access PIF file. Let's exit with NULL
        return NULL;
    }
    return result;
}


BOOL
ExtractPifInfoA(
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     BOOL  *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      PCSTR FileName
    )
{
    PVOID  fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    CHAR   tempStr [MEMDB_MAX];
    PSTR   strPtr;
    PSTR   dontCare;

    PSTDPIF    stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    BOOL result = TRUE;

    *Target = *Params = *WorkDir = *IconPath = 0;
    *IconNumber = 0;
    *MsDosMode = FALSE;

    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof(LNK_EXTRA_DATA));
    }

    __try {
        fileImage = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;


            //
            // getting working directory
            //
            _mbsncpy (tempStr, stdPif->defpath, PIFDEFPATHSIZE);

            // we might have a path terminated with a wack, we don't want that
            strPtr = _mbsdec (tempStr, GetEndOfStringA (tempStr));
            if (strPtr) {
                if (_mbsnextc (strPtr) == '\\') {
                    *strPtr = 0;
                }
            }
            // now get the long path.
            CopyFileSpecToLongA (tempStr, WorkDir);


            //
            // getting PIFs target
            //
            _mbsncpy (Target, stdPif->startfile, PIFSTARTLOCSIZE);

            // in most cases, the target is without a path. We try to build the path, either
            // by using WorkDir or by calling SearchPath to look for this file.
            if (*Target) {//non empty target
                if (!DoesFileExist (Target)) {
                    if (*WorkDir) {
                        StringCopyA (tempStr, WorkDir);
                        StringCatA  (tempStr, "\\");
                        StringCatA  (tempStr, Target);
                    }
                    if (!DoesFileExist (tempStr)) {
                        StringCopyA (tempStr, FileName);
                        strPtr = _mbsrchr (tempStr, '\\');
                        if (strPtr) {
                            strPtr = _mbsinc (strPtr);
                            if (strPtr) {
                                StringCopyA (strPtr, Target);
                            }
                        }
                    }
                    if (!DoesFileExist (tempStr)) {
                        strPtr = (PSTR)GetFileNameFromPathA (Target);
                        if (!strPtr) {
                            strPtr = Target;
                        }
                        if (!SearchPathA (NULL, Target, NULL, MEMDB_MAX, tempStr, &dontCare)) {
                            DEBUGMSG ((DBG_WARNING, "Could not find path for PIF target: %s", FileName));
                            StringCopyA (tempStr, Target);
                        }
                    }
                } else {
                    StringCopyA (tempStr, Target);
                }

                // now get the long path
                CopyFileSpecToLongA (tempStr, Target);
            }


            //
            // getting PIFs arguments
            //
            _mbsncpy (Params, stdPif->params, PIFPARAMSSIZE);


            //
            // let's try to read the WENHPIF40 structure
            //
            wenhPif40 = FindEnhPifSignature (fileImage, WENHHDRSIG40);
            if (wenhPif40) {
                CopyFileSpecToLongA (wenhPif40->achIconFileProp, IconPath);
                *IconNumber = wenhPif40->wIconIndexProp;
                if (ExtraData) {
                    ExtraData->xSize = 80;
                    ExtraData->ySize = wenhPif40->vidProp.cScreenLines;
                    if (ExtraData->ySize < 25) {
                        ExtraData->ySize = 25;
                    }
                    ExtraData->QuickEdit = !(wenhPif40->mseProp.flMse & MSE_WINDOWENABLE);
                    ExtraData->CurrentCodePage = wenhPif40->fntProp.wCurrentCP;
                    // now let's do some crazy things trying to get the font used
                    {
                        LOGFONTA logFont;
                        HDC dc;
                        HFONT font;
                        HGDIOBJ oldObject;
                        TEXTMETRIC tm;

                        ZeroMemory (&logFont, sizeof (LOGFONTA));
                        logFont.lfHeight = wenhPif40->fntProp.cyFontActual;
                        logFont.lfWidth = wenhPif40->fntProp.cxFontActual;
                        logFont.lfEscapement = 0;
                        logFont.lfOrientation = 0;
                        logFont.lfWeight = FW_DONTCARE;
                        logFont.lfItalic = FALSE;
                        logFont.lfUnderline = FALSE;
                        logFont.lfStrikeOut = FALSE;
                        logFont.lfCharSet = DEFAULT_CHARSET;
                        logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
                        logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                        logFont.lfQuality = DEFAULT_QUALITY;
                        logFont.lfPitchAndFamily = DEFAULT_PITCH;
                        if (wenhPif40->fntProp.flFnt & FNT_TT) {
                            _mbsncpy (logFont.lfFaceName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                            _mbsncpy (ExtraData->FontName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                        } else {
                            _mbsncpy (logFont.lfFaceName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                            _mbsncpy (ExtraData->FontName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                        }
                        dc = CreateDCA ("DISPLAY", NULL, NULL, NULL);
                        if (dc) {
                            font = CreateFontIndirectA (&logFont);
                            if (font) {
                                oldObject = SelectObject (dc, font);

                                if (GetTextMetrics (dc, &tm)) {
                                    ExtraData->xFontSize = tm.tmAveCharWidth;
                                    ExtraData->yFontSize = tm.tmHeight;
                                    ExtraData->FontWeight = tm.tmWeight;
                                    ExtraData->FontFamily = tm.tmPitchAndFamily;
                                }
                                SelectObject (dc, oldObject);
                                DeleteObject (font);
                            }
                            DeleteDC (dc);
                        }
                    }
                }
            }
            w386ext30 = FindEnhPifSignature (fileImage, W386HDRSIG30);
            if (w386ext30) {
                if (((w386ext30->PfW386Flags & fRealMode      ) == fRealMode      ) ||
                    ((w386ext30->PfW386Flags & fRealModeSilent) == fRealModeSilent)
                    ) {
                    *MsDosMode = TRUE;
                }
                if (ExtraData) {
                    ExtraData->FullScreen = (w386ext30->PfW386Flags & fFullScreen) != 0;
                }
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            result = FALSE;
        }
    }
    __finally {
        UnmapFile (fileImage, mapHandle, fileHandle);
    }
    return result;
}


BOOL
ExtractPifInfoW(
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     BOOL   *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      PCWSTR FileName
    )
{
    CHAR   aTarget   [MEMDB_MAX];
    CHAR   aParams   [MEMDB_MAX];
    CHAR   aWorkDir  [MEMDB_MAX];
    CHAR   aIconPath [MEMDB_MAX];
    PCSTR  aFileName;
    PCWSTR tempStrW;
    BOOL   result;
    LNK_EXTRA_DATAA extraDataA;

    aFileName = ConvertWtoA (FileName);

    result = ExtractPifInfoA (
                aTarget,
                aParams,
                aWorkDir,
                aIconPath,
                IconNumber,
                MsDosMode,
                ExtraData?&extraDataA:NULL,
                aFileName
                );
    FreeConvertedStr (aFileName);

    tempStrW = ConvertAtoW (aTarget);
    StringCopyW (Target, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aParams);
    StringCopyW (Params, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aWorkDir);
    StringCopyW (WorkDir, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aIconPath);
    StringCopyW (IconPath, tempStrW);
    FreeConvertedStr (tempStrW);

    if (ExtraData) {
        ExtraData->FullScreen = extraDataA.FullScreen;
        ExtraData->xSize = extraDataA.xSize;
        ExtraData->ySize = extraDataA.ySize;
        ExtraData->QuickEdit = extraDataA.QuickEdit;
        tempStrW = ConvertAtoW (extraDataA.FontName);
        StringCopyW (ExtraData->FontName, tempStrW);
        FreeConvertedStr (tempStrW);
        ExtraData->xFontSize = extraDataA.xFontSize;
        ExtraData->yFontSize = extraDataA.yFontSize;
        ExtraData->FontWeight = extraDataA.FontWeight;
        ExtraData->FontFamily = extraDataA.FontFamily;
        ExtraData->CurrentCodePage = extraDataA.CurrentCodePage;
    }

    return result;
}


BOOL
ExtractShellLinkInfoA (
    OUT     PSTR Target,
    OUT     PSTR Params,
    OUT     PSTR WorkDir,
    OUT     PSTR IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     PINT ShowMode,                      OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    CHAR tempStr [MEMDB_MAX];
    PCSTR expandedStr;
    PCWSTR fileNameW;
    PSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAA fd;

    fileNameW = ConvertAtoW (FileName);
    hres = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
    FreeConvertedStr (fileNameW);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    expandedStr = ExpandEnvironmentTextA (tempStr);
    CopyFileSpecToLongA (expandedStr, Target);
    FreeTextA (expandedStr);

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    strPtr = GetEndOfStringA (tempStr);
    if (strPtr) {
        strPtr = _mbsdec (tempStr, strPtr);
        if (strPtr) {
            if (_mbsnextc (strPtr) == '\\') {
                *strPtr = 0;
            }
        }
    }
    CopyFileSpecToLongA (tempStr, WorkDir);

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                Params,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    CopyFileSpecToLongA (tempStr, IconPath);

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (ShellLink, HotKey);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    //
    // Get show command
    //
    if (ShowMode) {
        hres = ShellLink->lpVtbl->GetShowCmd (ShellLink, ShowMode);

        if (!SUCCEEDED(hres)) {
            DEBUGMSGA((DBG_WARNING, "Cannot read show mode for link %s", FileName));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ExtractShellLinkInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    WCHAR tempStr [MEMDB_MAX];
    PCWSTR expandedStr;
    PWSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAW fd;

    hres = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    expandedStr = ExpandEnvironmentTextW (tempStr);
    CopyFileSpecToLongW (expandedStr, Target);
    FreeTextW (expandedStr);

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    strPtr = GetEndOfStringW (tempStr) - 1;
    if (strPtr >= tempStr) {
        if (*strPtr == '\\') {
            *strPtr = 0;
        }
    }
    CopyFileSpecToLongW (tempStr, WorkDir);

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                Params,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }

    CopyFileSpecToLongW (tempStr, IconPath);

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (ShellLink, HotKey);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    //
    // Get show command
    //
    if (ShowMode) {
        hres = ShellLink->lpVtbl->GetShowCmd (ShellLink, ShowMode);

        if (!SUCCEEDED(hres)) {
            DEBUGMSGW((DBG_WARNING, "Cannot read show mode for link %s", FileName));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ExtractShortcutInfoA (
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL  *DosApp,
    OUT     BOOL  *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAA ExtraData,     OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    if (ShowMode) {
        *ShowMode = SW_NORMAL;
    }

    shortcutExt = GetFileExtensionFromPathA (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchA (shortcutExt, "LNK")) {
            return ExtractShellLinkInfoA (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShowMode,
                        FileName,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchA (shortcutExt, "PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoA (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData,
                        FileName
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}


BOOL
ExtractShortcutInfoW (
    OUT     PWSTR Target,
    OUT     PWSTR Params,
    OUT     PWSTR WorkDir,
    OUT     PWSTR IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAW ExtraData,     OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    if (ShowMode) {
        *ShowMode = SW_NORMAL;
    }

    shortcutExt = GetFileExtensionFromPathW (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchW (shortcutExt, L"LNK")) {
            return ExtractShellLinkInfoW (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShowMode,
                        FileName,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchW (shortcutExt, L"PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoW (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData,
                        FileName
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\migutilp.h ===
#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

extern POOLHANDLE g_RegistryApiPool;
extern POOLHANDLE g_PathsPool;
extern CRITICAL_SECTION g_PoolMemCs;
extern CRITICAL_SECTION g_MemAllocCs;

VOID
RegTrackTerminate (
    VOID
    );


BOOL
ReadBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    );

VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    );

VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    );


VOID
InfGlobalInit (
    BOOL Terminate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\ipc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ipc.c

Abstract:

  The routines in this source file implement an interprocess communication
  mechanism to allow migration DLLs to be isolated into a separate process
  ("sandboxing").  This is done so that no DLL can affect the results of
  any other DLL or Setup.

  The IPC mechanism used here is memory mapped files.  Writes to the
  memory mapped file are synchronized by two events, one for the receiver
  and one by the host.

Author:

    Jim Schmidt (jimschm) 22-Mar-1997

Revision History:

    jimschm     19-Mar-2001 Removed DVD check (now in migration dll)
    jimschm     02-Jun-1999 Added IPC-based DVD check
    jimschm     21-Sep-1998 Converted from mailslots to memory mapped files.
                            (There are bugs in both Win9x and NT mailslots
                            that broke the original design.)
    jimschm     19-Jan-1998  Added beginings of WinVerifyTrust calls

    jimschm     15-Jul-1997  Added many workarounds for Win95 bugs.

--*/


#include "pch.h"
#include "migutilp.h"

#include <softpub.h>

#ifdef UNICODE
#error Build must be ANSI
#endif

#define DBG_IPC "Ipc"




typedef struct {
    HANDLE Mapping;
    HANDLE DoCommand;
    HANDLE GetResults;
} IPCDATA, *PIPCDATA;

static PCTSTR g_Mode;
static HANDLE g_ProcessHandle;
static BOOL g_Host;
static IPCDATA g_IpcData;

VOID
pCloseIpcData (
    VOID
    );

BOOL
pOpenIpcData (
    VOID
    );

BOOL
pCreateIpcData (
    IN      PSECURITY_ATTRIBUTES psa
    );

typedef struct {
    DWORD   Command;
    DWORD   Result;
    DWORD   TechnicalLogId;
    DWORD   GuiLogId;
    DWORD   DataSize;
    BYTE    Data[];
} MAPDATA, *PMAPDATA;



BOOL
OpenIpcA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR RemoteArg,                OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    )

/*++

Routine Description:

  OpenIpc has two modes of operation, depending on who the caller is.  If the
  caller is w95upg.dll or w95upgnt.dll, then the IPC mode is called "host mode."
  If the caller is migisol.exe, then the IPC mode is called "remote mode."

  In host mode, OpenIpc creates all of the objects necessary to implement
  the IPC.  This includes two events, DoCommand and GetResults, and a
  file mapping.  After creating the objects, the remote process is launched.

  In remote mode, OpenIpc opens the existing objects that have already
  been created.

Arguments:

  Win95Side - Used in host mode only.  Specifies that w95upg.dll is running
              when TRUE, or that w95upgnt.dll is running when FALSE.

  ExePath   - Specifies the command line for migisol.exe.  Specifies NULL
              to indicate remote mode.

  RemoteArg - Used in host mode only.  Specifies the migration DLL
              path.  Ignored in remote mode.

  WorkingDir - Used in host mode only.  Specifies the working directory path
               for the migration DLL.  Ignored in remote mode.

Return value:

  TRUE if the IPC channel was opened.  If host mode, TRUE indicates that
  migisol.exe is up and running.  If remote mode, TRUE indicates that
  migisol is ready for commands.

--*/

{
    CHAR CmdLine[MAX_CMDLINE];
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL ProcessResult;
    HANDLE SyncEvent = NULL;
    HANDLE ObjectArray[2];
    DWORD rc;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL Result = FALSE;

#ifdef DEBUG
    g_Mode = ExePath ? TEXT("host") : TEXT("remote");
#endif

    __try {

        g_ProcessHandle = NULL;

        g_Host = (ExePath != NULL);

        if (ISNT()) {
            //
            // Create nul DACL for NT
            //

            ZeroMemory (&sa, sizeof (sa));

            psd = (PSECURITY_DESCRIPTOR) MemAlloc (g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION)) {
                __leave;
            }

            if (!SetSecurityDescriptorDacl (psd, TRUE, (PACL) NULL, FALSE)) {
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        if (g_Host) {
            //
            // Create the IPC objects
            //

            if (!pCreateIpcData (psa)) {
                DEBUGMSG ((DBG_ERROR, "Cannot create IPC channel"));
                __leave;
            }

            MYASSERT (RemoteArg);

            SyncEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("win9xupg"));
            MYASSERT (SyncEvent);

            //
            // Create the child process
            //

            wsprintfA (
                CmdLine,
                "\"%s\" %s \"%s\"",
                ExePath,
                Win95Side ? "-r" : "-m",
                RemoteArg
                );

            ZeroMemory (&si, sizeof (si));
            si.cb = sizeof (si);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            ProcessResult = CreateProcessA (
                                NULL,
                                CmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_DEFAULT_ERROR_MODE,
                                NULL,
                                WorkingDir,
                                &si,
                                &pi
                                );

            if (ProcessResult) {
                CloseHandle (pi.hThread);
            } else {
                LOG ((LOG_ERROR, "Cannot start %s", CmdLine));
                __leave;
            }

            //
            // Wait for process to fail or wait for it to set the win95upg event
            //

            ObjectArray[0] = SyncEvent;
            ObjectArray[1] = pi.hProcess;
            rc = WaitForMultipleObjects (2, ObjectArray, FALSE, 60000);
            g_ProcessHandle = pi.hProcess;

            if (rc != WAIT_OBJECT_0) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Process %x did not signal 'ready'. Wait timed out. (%s)",
                    g_ProcessHandle,
                    g_Mode
                    ));

                LOG ((LOG_ERROR, "Upgrade pack failed during process creation."));

                __leave;
            }

            DEBUGMSG ((DBG_IPC, "Process %s is running (%s)", CmdLine, g_Mode));

        } else {        // !g_Host
            //
            // Open the IPC objects
            //

            if (!pOpenIpcData()) {
                DEBUGMSG ((DBG_ERROR, "Cannot open IPC channel"));
                __leave;
            }

            //
            // Set event notifying setup that we've created our mailslot
            //

            SyncEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("win9xupg"));
            if (!SyncEvent) {
                __leave;
            }
            SetEvent (SyncEvent);
        }

        Result = TRUE;
    }

    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!Result) {
            CloseIpc();
        }

        if (SyncEvent) {
            CloseHandle (SyncEvent);
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }

        PopError();
    }

    return Result;

}


BOOL
OpenIpcW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR RemoteArg,               OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    )
{
    PCSTR AnsiExePath, AnsiRemoteArg, AnsiWorkingDir;
    BOOL b;

    if (ExePath) {
        AnsiExePath = ConvertWtoA (ExePath);
    } else {
        AnsiExePath = NULL;
    }

    if (RemoteArg) {
        AnsiRemoteArg = ConvertWtoA (RemoteArg);
    } else {
        AnsiRemoteArg = NULL;
    }

    if (WorkingDir) {
        AnsiWorkingDir = ConvertWtoA (WorkingDir);
    } else {
        AnsiWorkingDir = NULL;
    }

    b = OpenIpcA (Win95Side, AnsiExePath, AnsiRemoteArg, AnsiWorkingDir);

    FreeConvertedStr (AnsiExePath);
    FreeConvertedStr (AnsiRemoteArg);
    FreeConvertedStr (AnsiWorkingDir);

    return b;
}


VOID
CloseIpc (
    VOID
    )

/*++

  Routine Description:

    Tells migisol.exe process to terminate, and then cleans up all resources
    opened by OpenIpc.

  Arguments:

    none

  Return Value:

    none

--*/

{
    if (g_Host) {
        //
        // Tell migisol.exe to terminate
        // if the communications channel is up
        //
        if (g_IpcData.Mapping && !SendIpcCommand (IPC_TERMINATE, NULL, 0)) {
            KillIpcProcess();
        }

        if (g_ProcessHandle) {
            WaitForSingleObject (g_ProcessHandle, 10000);
        }
    }

    pCloseIpcData();

    if (g_ProcessHandle) {
        CloseHandle (g_ProcessHandle);
        g_ProcessHandle = NULL;
    }
}


VOID
pCloseIpcData (
    VOID
    )
{
    if (g_IpcData.DoCommand) {
        CloseHandle (g_IpcData.DoCommand);
        g_IpcData.DoCommand = NULL;
    }

    if (g_IpcData.GetResults) {
        CloseHandle (g_IpcData.GetResults);
        g_IpcData.GetResults = NULL;
    }

    if (g_IpcData.Mapping) {
        CloseHandle (g_IpcData.Mapping);
        g_IpcData.Mapping = NULL;
    }
}


BOOL
pCreateIpcData (
    IN      PSECURITY_ATTRIBUTES psa
    )

/*++

Routine Description:

  pCreateIpcData creates the objects necessary to transfer data between
  migisol.exe and w95upg*.dll.  This function is called in host mode (i.e.,
  from w95upg.dll or w95upgnt.dll).

Arguments:

  psa - Specifies NT nul DACL, or NULL on Win9x

Return Value:

  TRUE if the objects were created properly, or FALSE if not.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = CreateFileMapping (
                            INVALID_HANDLE_VALUE,
                            psa,
                            PAGE_READWRITE,
                            0,
                            0x10000,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pCloseIpcData();
        return FALSE;
    }

    return TRUE;
}


BOOL
pOpenIpcData (
    VOID
    )

/*++

Routine Description:

  pOpenIpcData opens objects necessary to transfer data between migisol.exe
  and w95upg*.dll.  This funciton is called in remote mode (i.e., by
  migisol.exe).  This function must be called after the host has created the
  objects with pCreateIpcData.

Arguments:

  None.

Return Value:

  TRUE of the objects were opened successfully, FALSE otherwise.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = OpenFileMapping (
                            FILE_MAP_READ|FILE_MAP_WRITE,
                            FALSE,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pCloseIpcData();
        return FALSE;
    }

    return TRUE;
}


BOOL
IsIpcProcessAlive (
    VOID
    )

/*++

Routine Description:

  IsIpcProcessAlive checks for the presense of migisol.exe.  This function is
  intended only for host mode.

Arguments:

  None.

Return Value:

  TRUE if migisol.exe is still running, FALSE otherwise.

--*/

{
    if (!g_ProcessHandle) {
        return FALSE;
    }

    if (WaitForSingleObject (g_ProcessHandle, 0) == WAIT_OBJECT_0) {
        return FALSE;
    }

    return TRUE;
}


VOID
KillIpcProcess (
    VOID
    )

/*++

Routine Description:

  KillIpcProcess forcefully terminates an open migisol.exe process.  This is
  used in GUI mode when the DLL refuses to die.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PushError();

    if (IsIpcProcessAlive()) {
        TerminateProcess (g_ProcessHandle, 0);
    }

    PopError();
}


DWORD
CheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    )

/*++

Routine Description:

  CheckForWaitingData waits for data to be received by a mailslot.

  If the data does not arrive within the specified timeout, then zero is
  returned, and ERROR_SEM_TIMEOUT is set as the last error.

  If the data arrives within the specified timeout, then the number of
  waiting bytes are returned to the caller.

  This routine works around a Win95 bug with GetMailslotInfo.  Please
  change with caution.

Arguments:

  Slot - Specifies handle to inbound mailslot

  MinimumSize - Specifies the number of bytes that must be available before
                the routine considers the data to be available.  NOTE: If
                a message smaller than MinimumSize is waiting, this
                routine will be blocked until the timeout expires.
                This parameter must be greater than zero.

  Timeout - Specifies the number of milliseconds to wait for the message.

Return value:

  The number of bytes waiting in the mailslot, or 0 if the timeout was
  reached.

--*/

{
    DWORD WaitingSize;
    DWORD UnreliableTimeout;
    DWORD End;

    MYASSERT (MinimumSize > 0);

    End = GetTickCount() + Timeout;

    //
    // The wrap case -- this is really rare (once every 27 days),
    // so just let the tick count go back to zero
    //

    if (End < GetTickCount()) {
        while (End < GetTickCount()) {
            Sleep (100);
        }
        End = GetTickCount() + Timeout;
    }

    do {
        if (!GetMailslotInfo (Slot, NULL, &WaitingSize, NULL, &UnreliableTimeout)) {
            DEBUGMSG ((DBG_ERROR, "CheckForWaitingData: GetMailslotInfo failed (%s)", g_Mode));
            return 0;
        }

        //
        // WARNING: Win95 doesn't always return 0xffffffff when there is no data
        // available.  On some machines, Win9x has returned 0xc0ffffff.
        //

        WaitingSize = LOWORD(WaitingSize);

        if (WaitingSize < 0xffff && WaitingSize >= MinimumSize) {
            return WaitingSize;
        }
    } while (GetTickCount() < End);

    SetLastError (ERROR_SEM_TIMEOUT);
    return 0;
}



BOOL
pWriteIpcData (
    IN      HANDLE Mapping,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize,
    IN      DWORD Command,
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId
    )

/*++

Routine Description:

  pWriteIpcData puts data in the memory mapped block that migisol.exe and
  w95upg*.dll share.  The OS takes care of the synchronization for us.

Arguments:

  Mapping        - Specifies the open mapping object

  Data           - Specifies binary data to write

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

  Command        - Specifies a command DWORD, or 0 if not required

  ResultCode     - Specifies the result code of the last command, or 0 if not
                   applicable

  TechnicalLogId - Specifies the message constant ID (MSG_*) to be added to
                   setupact.log, or 0 if not applicable

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented via a popup, or 0 if not applicable

Return Value:

  TRUE if the data was written, FALSE if a sharing violation or other error
  occurs

--*/

{
    PMAPDATA MapData;

    MYASSERT (Mapping);
    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_WRITE, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    if (!Data) {
        DataSize = 0;
    }

    MapData->Command        = Command;
    MapData->Result         = ResultCode;
    MapData->TechnicalLogId = TechnicalLogId;
    MapData->GuiLogId       = GuiLogId;
    MapData->DataSize       = DataSize;

    if (DataSize) {
        CopyMemory (MapData->Data, Data, DataSize);
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
pReadIpcData (
    IN      HANDLE Mapping,
    OUT     PBYTE *Data,            OPTIONAL
    OUT     PDWORD DataSize,        OPTIONAL
    OUT     PDWORD Command,         OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  pReadIpcData retrieves data put in the shared memory block.  The OS takes
  care of synchronization for us.

Arguments:

  Mapping        - Specifies the memory mapping object

  Data           - Receives the inbound binary data, if any is available, or
                   NULL if no data is available.  The caller must free this
                   data with MemFree.

  DataSize       - Receives the number of bytes in Data

  Command        - Receives the inbound command, or 0 if no command was
                   specified

  ResultCode     - Receives the command result code, or 0 if not applicable

  TechnicalLogId - Receives the message constant (MSG_*) of the message to be
                   logged to setupact.log, or 0 if no message is to be logged

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if data was read, or FALSE if a sharing violation or other error occurs

--*/

{
    PMAPDATA MapData;

    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    if (Data) {
        if (MapData->DataSize) {
            *Data = MemAlloc (g_hHeap, 0, MapData->DataSize);
            MYASSERT (*Data);
            CopyMemory (*Data, MapData->Data, MapData->DataSize);
        } else {
            *Data = NULL;
        }
    }

    if (DataSize) {
        *DataSize = MapData->DataSize;
    }

    if (Command) {
        *Command = MapData->Command;
    }

    if (ResultCode) {
        *ResultCode = MapData->Result;
    }

    if (TechnicalLogId) {
        *TechnicalLogId = MapData->TechnicalLogId;
    }

    if (GuiLogId) {
        *GuiLogId = MapData->GuiLogId;
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
SendIpcCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  SendIpcCommand puts a command and optional binary data in the shared memory
  block.  It then sets the DoCommand event, triggering the other process to
  read the shared memory.  It is required that a command result is sent
  before the next SendIpcCommand.  See SendIpcCommandResult.

Arguments:

  Command  - Specifies the command to be executed by migisol.exe

  Data     - Specifies the data associated with the command

  DataSize - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command was placed in the shared memory block, FALSE otherwise

--*/

{
    if (!pWriteIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            0,
            0,
            0
            )) {
        DEBUGMSG ((DBG_ERROR, "SendIpcCommand: Can't send the command to the remote process"));
        return FALSE;
    }

    SetEvent (g_IpcData.DoCommand);

    return TRUE;
}


BOOL
GetIpcCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  GetIpcCommandResults reads the shared memory block and returns the
  available data.

Arguments:

  Timeout        - Specifies the amount of time to wait for a command result
                   (in ms), or INFINITE to wait forever.

  ReturnData     - Receives the binary data associated with the command
                   result, or NULL if no data is associated with the result.
                   The caller must free this data with MemFree.

  ReturnDataSize - Receives the number of bytes in ReturnData, or 0 if
                   ReturnData is NULL.

  ResultCode     - Receives the command result code

  TechnicalLogId - Receives the message constant (MSG_*) to be logged in
                   setupact.log, or 0 if no message is specified

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if command results were obtained, or FALSE if the wait timed out or
  the IPC connection crashed

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.GetResults, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pReadIpcData (
            g_IpcData.Mapping,
            ReturnData,
            ReturnDataSize,
            NULL,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    return b;
}


BOOL
GetIpcCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    )

/*++

Routine Description:

  GetIpcCommand obtains the command that needs to be processed.  This routine
  is called by migisol.exe (the remote process).

Arguments:

  Timeout  - Specifies the amount of time (in ms) to wait for a command, or
             INFINITE to wait forever

  Command  - Receives the command that needs to be executed

  Data     - Receives the data associated with the command.  The caller must
             free this block with MemFree.

  DataSize - Receives the number of bytes in Data, or 0 if Data is NULL.

Return Value:

  TRUE if a command was received, FALSE otherwise.

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.DoCommand, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pReadIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            NULL,
            NULL,
            NULL
            );

    return b;
}


BOOL
SendIpcCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  SendIpcCommandResults puts the command results in the shared memory block.
  This routine is called by migisol.exe (the remote process).

Arguments:

  ResultCode     - Specifies the result code of the command.

  TechnicalLogId - Specifies the message constant (MSG_*) of the message to
                   be logged in setupact.log, or 0 if no message is to be
                   logged

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented in a popup to the user, or 0 if no message
                   needs to be presented

  Data           - Specifies the binary data to pass as command results, or
                   NULL of no binary data is required

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command results were placed in shared memory, FALSE otherwise.

--*/

{
    BOOL b;

    b = pWriteIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            0,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    if (!b) {
        DEBUGMSG ((DBG_ERROR, "Can't write command results to IPC buffer"));
        return FALSE;
    }

    SetEvent (g_IpcData.GetResults);

    return TRUE;
}


BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    )
{
    PCWSTR UnicodeStr;
    BOOL b;

    UnicodeStr = CreateUnicode (DllSpec);
    if (!UnicodeStr) {
        return FALSE;
    }

    b = IsDllSignedW (WinVerifyTrustApi, UnicodeStr);

    DestroyUnicode (UnicodeStr);

    return b;
}


BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    )
{
    GUID VerifyGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA WinTrustData;
    WINTRUST_FILE_INFO WinTrustFileInfo;
    LONG rc;

    if (!WinVerifyTrustApi) {
        return TRUE;
    }

    ZeroMemory (&WinTrustData, sizeof (WinTrustData));
    ZeroMemory (&WinTrustFileInfo, sizeof (WinTrustFileInfo));

    WinTrustData.cbStruct       = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice     = WTD_UI_NONE;
    WinTrustData.dwUnionChoice  = WTD_CHOICE_FILE;
    WinTrustData.pFile          = &WinTrustFileInfo;

    WinTrustFileInfo.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    WinTrustFileInfo.hFile         = INVALID_HANDLE_VALUE;
    WinTrustFileInfo.pcwszFilePath = DllSpec;

    rc = WinVerifyTrustApi (
            INVALID_HANDLE_VALUE,
            &VerifyGuid,
            &WinTrustData
            );

    return rc == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\pch.h ===
#include "master.h"
#include "migutilp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\movelist.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    movelist.c

Abstract:

    Implements APIs to order nested renames

Author:

    03-Jun-2001 Jim Schmidt (jimschm)

Revision History:

    jimschm     03-Jun-2001     Moved from buildinf.c

--*/

#include "pch.h"

#ifdef DEBUG
//#define MOVE_TEST
#endif

//
// Declare structures
//

#define MOVE_LIST_HASH_BUCKETS       11

struct TAG_MOVE_LIST_NODEW;

typedef struct {
    struct TAG_MOVE_LIST_NODEW *Left;
    struct TAG_MOVE_LIST_NODEW *Right;
    struct TAG_MOVE_LIST_NODEW *Parent;
} BINTREE_LINKAGE, *PBINTREE_LINKAGE;

#define SOURCE_LINKAGE          0
#define DESTINATION_LINKAGE     1

typedef struct TAG_MOVE_LIST_NODEW {
    BINTREE_LINKAGE Linkage[2];
    PCWSTR Source;
    PCWSTR Destination;
    PCWSTR FixedSource;
    PCWSTR FixedDestination;
} MOVE_LIST_NODEW, *PMOVE_LIST_NODEW;

typedef struct TAG_MOVE_LIST_GROUPW {
    PMOVE_LIST_NODEW SourceTreeRoot;
    struct TAG_MOVE_LIST_GROUPW *Next, *NextHash;
    UINT SourceLength;

#ifdef MOVE_TEST
    UINT ItemCount;
#endif

} MOVE_LIST_GROUPW, *PMOVE_LIST_GROUPW;

typedef struct TAG_MOVE_LISTW {
    PMOVE_LIST_GROUPW HeadGroup;
    PMOVE_LIST_GROUPW Buckets[MOVE_LIST_HASH_BUCKETS];
    struct TAG_MOVE_LISTW *NextChainedList;
    POOLHANDLE Pool;
    PMOVE_LIST_NODEW DestinationTreeRoot;

#ifdef MOVE_TEST
    UINT DestItemCount;
    UINT GroupCount;
#endif

} MOVE_LISTW, *PMOVE_LISTW;


typedef enum {
    BEGIN_LIST,
    BEGIN_LENGTH_GROUP,
    ENUM_RETURN_ITEM,
    ENUM_NEXT_ITEM,
    ENUM_NEXT_LENGTH_GROUP,
    ENUM_NEXT_LIST
} MOVE_ENUM_STATE;

typedef struct {
    // enum output
    PMOVE_LIST_NODEW Item;

    // private members
    MOVE_ENUM_STATE State;
    PMOVE_LIST_GROUPW LengthGroup;
    PMOVE_LISTW ThisList;
    PMOVE_LIST_NODEW StartFrom;
} MOVE_LIST_ENUMW, *PMOVE_LIST_ENUMW;



#ifdef MOVE_TEST

VOID
pTestList (
    IN      PMOVE_LISTW List
    );

INT
pCountTreeNodes (
    IN      PMOVE_LIST_GROUPW LengthGroup
    );

INT
pCountList (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_NODEW FromItem       OPTIONAL
    );

#endif


BOOL
pEnumFirstMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr,
    IN      PMOVE_LISTW List
    );

BOOL
pEnumNextMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr
    );




PMOVE_LISTW
pAllocateMoveList (
    IN      POOLHANDLE Pool
    )
{
    PMOVE_LISTW moveList;

    moveList = (PMOVE_LISTW) PoolMemGetMemory (Pool, sizeof (MOVE_LISTW));
    if (!moveList) {
        return NULL;
    }

    ZeroMemory (moveList, sizeof (MOVE_LISTW));
    moveList->Pool = Pool;

    return moveList;
}


MOVELISTW
AllocateMoveListW (
    IN      POOLHANDLE Pool
    )
{
    return (MOVELISTW) pAllocateMoveList (Pool);
}


PMOVE_LIST_GROUPW
pGetMoveListGroup (
    IN OUT  PMOVE_LISTW List,
    IN      UINT SourceLength
    )

/*++

Routine Description:

  pGetMoveListGroup searches the move list for the structure that represents
  the specified length. If no structure is found, then a new structure is
  allocated and inserted in the reverse-length-sorted list.

Arguments:

  List - Specifies the move list to search (as returned from pAllocateMoveList),
         receives updated pointers if an allocation occurred.

  SourceLength - Specifies the length of the source path, in WCHARs.

Return Value:

  A pointer to the move list group.

--*/

{
    PMOVE_LIST_GROUPW thisGroup;
    PMOVE_LIST_GROUPW insertAfter;
    PMOVE_LIST_GROUPW insertBefore = NULL;
    UINT hash;

    //
    // Search the current list for SourceLength. List is sorted from biggest
    // to smallest.
    //

    hash = SourceLength % MOVE_LIST_HASH_BUCKETS;
    thisGroup = List->Buckets[hash];

    while (thisGroup) {
        if (thisGroup->SourceLength == SourceLength) {
            return thisGroup;
        }

        thisGroup = thisGroup->NextHash;
    }

    //
    // Not in hash table; locate insert position
    //

    thisGroup = List->HeadGroup;

    while (thisGroup) {

        if (thisGroup->SourceLength < SourceLength) {
            break;
        }

        insertBefore = thisGroup;
        thisGroup = thisGroup->Next;
    }

    insertAfter = insertBefore;
    insertBefore = thisGroup;

    MYASSERT (!insertAfter || (insertAfter->Next == insertBefore));

    //
    // Allocate a new item
    //

    thisGroup = (PMOVE_LIST_GROUPW) PoolMemGetMemory (List->Pool, sizeof (MOVE_LISTW));
    if (thisGroup) {
        //
        // Insert it into the linked list, then the hash table
        //

        thisGroup->SourceLength = SourceLength;
        thisGroup->SourceTreeRoot = NULL;
        thisGroup->Next = insertBefore;         // insertBefore is on the right side

        if (insertAfter) {
            insertAfter->Next = thisGroup;
        } else {
            List->HeadGroup = thisGroup;
        }

        thisGroup->NextHash = List->Buckets[hash];
        List->Buckets[hash] = thisGroup;

#ifdef MOVE_TEST

        thisGroup->ItemCount = 0;
        List->GroupCount += 1;

#endif
    }

    return thisGroup;
}


INT
pCompareBackwards (
    IN      UINT Length,
    IN      PCWSTR LeftString,
    IN      PCWSTR RightString
    )
{
    INT result = 0;
    PCWSTR start = LeftString;

    LeftString += Length;
    RightString += Length;

    MYASSERT (*LeftString == 0);
    MYASSERT (*RightString == 0);

    while (LeftString > start) {
        LeftString--;
        RightString--;

        result = (INT) towlower (*RightString) - (INT) towlower (*LeftString);
        if (result) {
            break;
        }
    }

    return result;
}


PMOVE_LIST_NODEW
pFindNodeInTree (
    IN      PMOVE_LIST_NODEW Root,
    IN      UINT KeyLength,
    IN      PCWSTR Key,
    OUT     PMOVE_LIST_NODEW *Parent,
    OUT     PINT WhichChild
    )

/*++

Routine Description:

  pFindNodeInTree searches the binary tree for the specified source or
  destination path.

  In the case of a source path, KeyLength is non-zero, and Key specifies the
  source path. All elements in the binary tree have equal length.

  In the case of a destination path, KeyLength is zero, and Key specifies the
  destination path. All destination paths are in the same binary tree,
  regardless of length.

Arguments:

  Root - Specifies the root of the tree to search

  KeyLength - Specifies a non-zero wchar count of the characters in Key,
        excluding the terminator, or specifies zero for a destination path

  Key - Specifies the source or destination path to find

  Parent - Receives the pointer to the found node's parent, or NULL if the
        found node is the root of the tree. Receives an undefined value when a
        node is not found.

  WhichChild - Receives an indicator as to which child in Parent a new node
        should be inserted into.

        If the return value is non-NULL (a node was found), then WhichChild is
        set to zero.

        If the return value is NULL (a node was not found), then WhichChild is
        set to one of the following:

            < 0 - New node should be linked via Parent->Left
            > 0 - New node should be linked via Parent->Right
              0 - New node is the root of the tree

Return Value:

  A pointer to the found node, or NULL if the search key is not in the tree.

--*/

{
    PMOVE_LIST_NODEW thisNode;
    UINT linkageIndex;

    thisNode = Root;
    *Parent = NULL;
    *WhichChild = 0;

    linkageIndex = KeyLength ? SOURCE_LINKAGE : DESTINATION_LINKAGE;

    while (thisNode) {
        if (KeyLength) {
            *WhichChild = pCompareBackwards (KeyLength, thisNode->Source, Key);
        } else {
            *WhichChild = StringICompareW (Key, thisNode->Destination);
        }

        if (!(*WhichChild)) {
            return thisNode;
        }

        *Parent = thisNode;
        if (*WhichChild < 0) {
            thisNode = thisNode->Linkage[linkageIndex].Left;
        } else {
            thisNode = thisNode->Linkage[linkageIndex].Right;
        }
    }

    return NULL;
}


PMOVE_LIST_NODEW
pFindDestination (
    IN      PMOVE_LISTW List,
    IN      PCWSTR Destination
    )
{
    PMOVE_LIST_NODEW parent;
    INT compareResults;

    return pFindNodeInTree (
                List->DestinationTreeRoot,
                0,
                Destination,
                &parent,
                &compareResults
                );
}


BOOL
pInsertMovePairIntoEnabledGroup (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )
{
    PMOVE_LIST_NODEW node;
    PMOVE_LIST_NODEW srcParent;
    INT srcCompareResults;
    PMOVE_LIST_NODEW destNode;
    PMOVE_LIST_NODEW destParent;
    INT destCompareResults;

#ifdef MOVE_TEST
    INT count = pCountTreeNodes (LengthGroup);
#endif

    //
    // Check for duplicate dest
    //

    destNode = pFindNodeInTree (
                    List->DestinationTreeRoot,
                    0,
                    Destination,
                    &destParent,
                    &destCompareResults
                    );

    if (destNode) {
        DEBUGMSGW_IF ((
            !StringIMatchW (Source, destNode->Source),
            DBG_WARNING,
            "Destination %s is already in the moved list for %s; ignoring duplicate",
            Destination,
            destNode->Source
            ));

        return FALSE;
    }

    //
    // Search the tree for an existing source/dest pair
    //

    MYASSERT (TcharCountW (Source) == LengthGroup->SourceLength);
    MYASSERT (LengthGroup->SourceLength > 0);

    node = pFindNodeInTree (
                LengthGroup->SourceTreeRoot,
                LengthGroup->SourceLength,
                Source,
                &srcParent,
                &srcCompareResults
                );

    if (node) {
        DEBUGMSGW ((
            DBG_WARNING,
            "Ignoring move of %s to %s because source is already moved to %s",
            Source,
            Destination,
            node->Destination
            ));
        return FALSE;
    }

    //
    // Not in the tree; add it
    //

    node = (PMOVE_LIST_NODEW) PoolMemGetMemory (List->Pool, sizeof (MOVE_LIST_NODEW));
    if (!node) {
        return FALSE;
    }

    node->Source = PoolMemDuplicateStringW (List->Pool, Source);
    node->Destination = PoolMemDuplicateStringW (List->Pool, Destination);
    node->FixedSource = node->Source;
    node->FixedDestination = node->Destination;

    //
    // Put source in binary tree
    //

    node->Linkage[SOURCE_LINKAGE].Left = NULL;
    node->Linkage[SOURCE_LINKAGE].Right = NULL;
    node->Linkage[SOURCE_LINKAGE].Parent = srcParent;

    if (!srcParent) {

        LengthGroup->SourceTreeRoot = node;

    } else if (srcCompareResults < 0) {

        MYASSERT (srcParent->Linkage[SOURCE_LINKAGE].Left == NULL);
        srcParent->Linkage[SOURCE_LINKAGE].Left = node;

    } else {

        MYASSERT (srcParent->Linkage[SOURCE_LINKAGE].Right == NULL);
        srcParent->Linkage[SOURCE_LINKAGE].Right = node;
    }

    //
    // Put dest in binary tree
    //

    node->Linkage[DESTINATION_LINKAGE].Left = NULL;
    node->Linkage[DESTINATION_LINKAGE].Right = NULL;
    node->Linkage[DESTINATION_LINKAGE].Parent = destParent;

    if (!destParent) {

        List->DestinationTreeRoot = node;

    } else if (destCompareResults < 0) {

        MYASSERT (destParent->Linkage[DESTINATION_LINKAGE].Left == NULL);
        destParent->Linkage[DESTINATION_LINKAGE].Left = node;

    } else {

        MYASSERT (destParent->Linkage[DESTINATION_LINKAGE].Right == NULL);
        destParent->Linkage[DESTINATION_LINKAGE].Right = node;
    }


#ifdef MOVE_TEST
    //
    // Verify the sanity of the data structures
    //

    LengthGroup->ItemCount += 1;
    List->DestItemCount += 1;

    pTestList (List);

    if (count + 1 != pCountTreeNodes (LengthGroup)) {
        DebugBreak();
    }

#endif

    return TRUE;
}


PMOVE_LIST_NODEW
pFindLeftmostNode (
    IN      PMOVE_LIST_NODEW Node,
    IN      UINT LinkageIndex
    )
{
    if (!Node) {
        return NULL;
    }

    while (Node->Linkage[LinkageIndex].Left) {
        Node = Node->Linkage[LinkageIndex].Left;
    }

    return Node;
}


PMOVE_LIST_NODEW
pFindRightmostNode (
    IN      PMOVE_LIST_NODEW Node,
    IN      UINT LinkageIndex
    )
{
    if (!Node) {
        return NULL;
    }

    while (Node->Linkage[LinkageIndex].Right) {
        Node = Node->Linkage[LinkageIndex].Right;
    }

    return Node;
}


PMOVE_LIST_NODEW
pEnumFirstItemInTree (
    IN      PMOVE_LIST_NODEW Root,
    IN      UINT LinkageIndex
    )
{
    if (!Root) {
        return NULL;
    }

    return pFindLeftmostNode (Root, LinkageIndex);
}


PMOVE_LIST_NODEW
pEnumNextItemInTree (
    IN      PMOVE_LIST_NODEW LastItem,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW nextItem;

    if (!LastItem) {
        return NULL;
    }

    if (LastItem->Linkage[LinkageIndex].Right) {
        return pFindLeftmostNode (
                    LastItem->Linkage[LinkageIndex].Right,
                    LinkageIndex
                    );
    }

    //
    // Go up the tree. If the parent's left pointer is not the last
    // item, then we are going up from the right side, and we need
    // to continue going up. It is important to note that the test
    // is not (nextItem->Right == LastItem) because we need to
    // support continuation from a deleted node. A deleted node
    // will not match any of the parent's children. If the deleted
    // node has no right pointer, then we need to keep going up.
    //
    // If the enum item was deleted, then left and parent point
    // to the next node.
    //

    nextItem = LastItem->Linkage[LinkageIndex].Parent;

    if (nextItem != LastItem->Linkage[LinkageIndex].Left) {

        while (nextItem && nextItem->Linkage[LinkageIndex].Left != LastItem) {
            LastItem = nextItem;
            nextItem = LastItem->Linkage[LinkageIndex].Parent;
        }

    }

    return nextItem;
}


#ifdef MOVE_TEST

INT
pCountList (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_NODEW FromItem       OPTIONAL
    )
{
    MOVE_LIST_ENUMW e;
    INT count = 0;
    BOOL startCounting;
    BOOL next = TRUE;
    INT debug = 2;

    if (!FromItem) {
        startCounting = TRUE;
    } else {
        startCounting = FALSE;
    }

    //
    // Count items in the binary tree
    //

    if (pEnumFirstMoveListItem (&e, List)) {

        do {
            if (FromItem == e.Item) {
                startCounting = TRUE;
            }

            if (startCounting) {
                if (debug) {
                    debug--;
                    DEBUGMSGW ((DBG_VERBOSE, "%i: %s", debug, e.Item->Source));
                }
                count++;
            }
        } while (pEnumNextMoveListItem (&e));
    }

    return count;
}


INT
pCountTreeNodes (
    IN      PMOVE_LIST_GROUPW LengthGroup
    )
{
    INT itemCount;
    PMOVE_LIST_NODEW thisNode;

    //
    // Count items in the binary tree
    //

    itemCount = 0;
    thisNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, SOURCE_LINKAGE);
    }

    return itemCount;
}


VOID
pTestDeleteAndEnum (
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PMOVE_LIST_NODEW DeletedNode
    )
{
    BOOL startCounting = FALSE;
    INT nodes;
    INT nodes2;
    PMOVE_LIST_NODEW nextNode;
    PMOVE_LIST_NODEW firstNodeAfterDeletion;

    //
    // Count # of nodes after DeletedNode
    //

    firstNodeAfterDeletion = pEnumNextItemInTree (DeletedNode, SOURCE_LINKAGE);
    nextNode = firstNodeAfterDeletion;
    nodes = 0;

    while (nextNode) {
        nodes++;
        nextNode = pEnumNextItemInTree (nextNode, SOURCE_LINKAGE);
    }

    //
    // Reenumerate the whole tree and verify the same # of nodes remain
    //

    nodes2 = 0;
    nextNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);

    while (nextNode) {
        if (nextNode == firstNodeAfterDeletion) {
            startCounting = TRUE;
        }

        if (startCounting) {
            nodes2++;
        }

        nextNode = pEnumNextItemInTree (nextNode, SOURCE_LINKAGE);
    }

    if (nodes != nodes2) {
        DebugBreak();
    }
}



VOID
pTestLengthGroup (
    IN      PMOVE_LIST_GROUPW LengthGroup
    )
{
    UINT itemCount;
    PMOVE_LIST_NODEW thisNode;

    //
    // Count items in the binary tree
    //

    itemCount = 0;
    thisNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, SOURCE_LINKAGE);
    }

    MYASSERT (itemCount == LengthGroup->ItemCount);
}

VOID
pTestList (
    IN      PMOVE_LISTW List
    )
{
    UINT itemCount;
    UINT groupCount;
    PMOVE_LIST_NODEW thisNode;
    PMOVE_LIST_GROUPW lengthGroup;

    groupCount = 0;
    lengthGroup = List->HeadGroup;

    while (lengthGroup) {
        groupCount++;
        MYASSERT (pGetMoveListGroup (List, lengthGroup->SourceLength) == lengthGroup);

        pTestLengthGroup (lengthGroup);
        lengthGroup = lengthGroup->Next;
    }

    MYASSERT (groupCount == List->GroupCount);

    itemCount = 0;

    thisNode = pEnumFirstItemInTree (List->DestinationTreeRoot, DESTINATION_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, DESTINATION_LINKAGE);
    }

    MYASSERT (itemCount == List->DestItemCount);
}

#endif


PMOVE_LIST_NODEW *
pFindParentChildLinkage (
    IN      PMOVE_LIST_NODEW Child,
    IN      PMOVE_LIST_NODEW *RootPointer,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW parent = Child->Linkage[LinkageIndex].Parent;

    if (!parent) {
        return RootPointer;
    }

    if (parent->Linkage[LinkageIndex].Left == Child) {
        return &(parent->Linkage[LinkageIndex].Left);
    }

    MYASSERT (parent->Linkage[LinkageIndex].Right == Child);
    return &(parent->Linkage[LinkageIndex].Right);
}


VOID
pDeleteNodeFromBinaryTree (
    OUT     PMOVE_LIST_NODEW *RootPointer,
    IN      PMOVE_LIST_NODEW ItemToDelete,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW *parentChildLinkage;
    PMOVE_LIST_NODEW *swapNodeParentChildLinkage;
    PMOVE_LIST_NODEW swapNode;
    PMOVE_LIST_NODEW leftmostNode;
    PMOVE_LIST_NODEW nextEnumNode = NULL;
    PBINTREE_LINKAGE deleteItemLinkage;
    PBINTREE_LINKAGE leftLinkage;
    PBINTREE_LINKAGE rightLinkage;
    PBINTREE_LINKAGE swapLinkage;
    PBINTREE_LINKAGE leftmostLinkage;

    nextEnumNode = pEnumNextItemInTree (ItemToDelete, LinkageIndex);

    //
    // A node structure has multiple binary trees. We use the convention
    // of fooNode to represent the entire node structure, and fooLinkage
    // to represent just the left/right/parent structure for the tree
    // we are interested in. Kind of ugly, but necessary. A generalized
    // tree would not provide the optimum relationships.
    //

    //
    // Get the parent's link to the child, or the root pointer
    //

    parentChildLinkage = pFindParentChildLinkage (
                                ItemToDelete,
                                RootPointer,
                                LinkageIndex
                                );

    //
    // Remove the node from the tree. The complicated case is when we have a
    // node with two children. We attempt to move the children up as best as
    // we can.
    //

    deleteItemLinkage = &(ItemToDelete->Linkage[LinkageIndex]);

    if (deleteItemLinkage->Left && deleteItemLinkage->Right) {

        leftLinkage = &((deleteItemLinkage->Left)->Linkage[LinkageIndex]);
        rightLinkage = &((deleteItemLinkage->Right)->Linkage[LinkageIndex]);

        //
        // Node has left & right children. Search for a leaf node
        // that we can swap. We try to move items up as high as possible.
        //

        swapNode = pFindLeftmostNode (deleteItemLinkage->Right, LinkageIndex);
        swapLinkage = &(swapNode->Linkage[LinkageIndex]);

        if (swapLinkage->Right == NULL) {
            //
            // Found swapable node on the right side of ItemToDelete
            //

            MYASSERT (swapLinkage->Left == NULL);
            swapLinkage->Left = deleteItemLinkage->Left;
            leftLinkage->Parent = swapNode;

            if (swapNode != deleteItemLinkage->Right) {
                swapLinkage->Right = deleteItemLinkage->Right;
                rightLinkage->Parent = swapNode;
            }

        } else {
            //
            // Try to get a swapable node on the left side. If that
            // isn't possible, rechain the tree.
            //

            swapNode = pFindRightmostNode (deleteItemLinkage->Left, LinkageIndex);
            swapLinkage = &(swapNode->Linkage[LinkageIndex]);

            MYASSERT (swapLinkage->Right == NULL);

            swapLinkage->Right = deleteItemLinkage->Right;
            rightLinkage->Parent = swapNode;

            leftmostNode = pFindLeftmostNode (swapLinkage->Left, LinkageIndex);

            if (leftmostNode && leftmostNode != deleteItemLinkage->Left) {

                leftmostLinkage = &(leftmostNode->Linkage[LinkageIndex]);

                MYASSERT (leftmostLinkage->Left == NULL);

                leftmostLinkage->Left = deleteItemLinkage->Left;
                leftLinkage->Parent = leftmostNode;

            } else if (!leftmostNode) {
                MYASSERT (swapLinkage->Left == NULL);

                swapLinkage->Left = deleteItemLinkage->Left;
                leftLinkage->Parent = swapNode;
            }
        }

        swapNodeParentChildLinkage = pFindParentChildLinkage (
                                            swapNode,
                                            RootPointer,
                                            LinkageIndex
                                            );

        *swapNodeParentChildLinkage = NULL;

    } else if (deleteItemLinkage->Left) {
        //
        // Node has only a left child. Replace ItemToDelete with left child.
        //

        swapNode = deleteItemLinkage->Left;

    } else {
        //
        // Node has a right child or no children. Replace ItemToDelete
        // with right child if it is present.
        //

        swapNode = deleteItemLinkage->Right;
    }

    *parentChildLinkage = swapNode;

    if (swapNode) {
        swapLinkage = &(swapNode->Linkage[LinkageIndex]);
        swapLinkage->Parent = deleteItemLinkage->Parent;
    }

    //
    // Fix delete node pointers so enumeration can continue without interruption.
    // If nextEnumNode is NULL, enumeration will end.
    //

    deleteItemLinkage->Parent = nextEnumNode;
    deleteItemLinkage->Right = NULL;
    deleteItemLinkage->Left = nextEnumNode;
}


VOID
pDeleteMovePairFromGroup (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PMOVE_LIST_NODEW ItemToDelete
    )
{
    pDeleteNodeFromBinaryTree (
        &(LengthGroup->SourceTreeRoot),
        ItemToDelete,
        SOURCE_LINKAGE
        );

    pDeleteNodeFromBinaryTree (
        &(List->DestinationTreeRoot),
        ItemToDelete,
        DESTINATION_LINKAGE
        );

#ifdef MOVE_TEST

    LengthGroup->ItemCount -= 1;
    List->DestItemCount -= 1;

    pTestList (List);

#endif
}

BOOL
pEnumNextMoveListItem (
    IN OUT  PMOVE_LIST_ENUMW EnumPtr
    )
{
    for (;;) {

        switch (EnumPtr->State) {

        case BEGIN_LIST:
            if (!EnumPtr->ThisList) {
                return FALSE;
            }

            EnumPtr->LengthGroup = (EnumPtr->ThisList)->HeadGroup;
            EnumPtr->State = BEGIN_LENGTH_GROUP;

            break;

        case BEGIN_LENGTH_GROUP:
            if (!EnumPtr->LengthGroup) {

                EnumPtr->State = ENUM_NEXT_LIST;

            } else {

                EnumPtr->Item = pEnumFirstItemInTree (
                                    EnumPtr->LengthGroup->SourceTreeRoot,
                                    SOURCE_LINKAGE
                                    );

                EnumPtr->State = ENUM_RETURN_ITEM;
            }

            break;

        case ENUM_NEXT_ITEM:
            MYASSERT (EnumPtr->LengthGroup);
            MYASSERT (EnumPtr->Item);

            EnumPtr->Item = pEnumNextItemInTree (
                                EnumPtr->Item,
                                SOURCE_LINKAGE
                                );

            EnumPtr->State = ENUM_RETURN_ITEM;
            break;

        case ENUM_RETURN_ITEM:
            if (EnumPtr->Item) {
                EnumPtr->State = ENUM_NEXT_ITEM;
                return TRUE;
            }

            EnumPtr->State = ENUM_NEXT_LENGTH_GROUP;
            break;

        case ENUM_NEXT_LENGTH_GROUP:
            MYASSERT (EnumPtr->LengthGroup);
            EnumPtr->LengthGroup = (EnumPtr->LengthGroup)->Next;

            EnumPtr->State = BEGIN_LENGTH_GROUP;
            break;

        case ENUM_NEXT_LIST:
            MYASSERT (EnumPtr->ThisList);
            EnumPtr->ThisList = (EnumPtr->ThisList)->NextChainedList;

            EnumPtr->State = BEGIN_LIST;
            break;
        }
    }
}

BOOL
pEnumFirstMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr,
    IN      PMOVE_LISTW List
    )
{
    if (!List) {
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (MOVE_LIST_ENUMW));
    EnumPtr->ThisList = List;
    EnumPtr->State = BEGIN_LIST;

    return pEnumNextMoveListItem (EnumPtr);
}


BOOL
pInsertMoveIntoListWorker (
    IN      PMOVE_LISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )

/*++

Routine Description:

  pInsertMoveIntoListWorker adds a source/dest move pair to a list and orders
  the list by the length of source (from biggest to smallest). This ensures
  nesting is taken care of properly.

  The move list is stored in the caller-owned pool. Before calling
  InsertMoveIntoList for the first time, the caller must first create a pool,
  and allocate a list from AllocateMoveListW.

  After the list is no longer needed, the caller frees all resources of the
  list by simply destroying the pool.

Arguments:

  List - Specifies the list to insert into

  Source - Specifies the source path

  Destination - Specifies the destination path

Return Value:

  TRUE if successful, FALSE if memory allocation failed, or if source is already
  in the list.

--*/

{
    PMOVE_LIST_GROUPW lengthGroup;
    UINT sourceLen;
    MOVE_LIST_ENUMW e;

    sourceLen = TcharCountW (Source);

    lengthGroup = pGetMoveListGroup (List, sourceLen);
    if (!lengthGroup) {
        return FALSE;
    }

    //
    // Insert pair into the list
    //

    if (!pInsertMovePairIntoEnabledGroup (
            List,
            lengthGroup,
            Source,
            Destination
            )) {
        return FALSE;
    }

    return TRUE;
}

BOOL
InsertMoveIntoListW (
    IN      MOVELISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )
{
    return pInsertMoveIntoListWorker ((PMOVE_LISTW) List, Source, Destination);
}


VOID
pChainLists (
    IN      PMOVE_LISTW LeftList,
    IN      PMOVE_LISTW RightList
    )
{
    while (LeftList->NextChainedList) {
        LeftList = LeftList->NextChainedList;
    }

    LeftList->NextChainedList = RightList;
}


PMOVE_LISTW
pRemoveMoveListOverlapWorker (
    IN      PMOVE_LISTW List,
    IN      BOOL SkipPrePostLists
    )

/*++

Routine Description:

  pRemoveMoveListOverlapWorker searches the length-sorted move list and
  discards moves that are taken care of through moves of a parent. For
  example, consider the following moves:

  1. c:\a\b\c -> c:\x\c
  2. c:\a\b   -> c:\x

  In this case, line (1) is not needed, because it is implicit in line (2),
  even if line (1) is a file but line (2) is a subdirectory.

  This routine relies on the enumeration order. An item within that order
  is compared against items further down in the order.

  If there is a case such as:

  1. c:\a\b\c -> c:\x\q
  2. c:\a\b   -> c:\x

  This will produce an error, because the move cannot be executed. Line (1)
  would have to be moved first, but because it creates the destination of
  line (2), the second move will fail.

Arguments:

  List - Specifies the move list to check

  SkipPrePostLists - Specifies TRUE if the temp move algorithm should be
                     skipped; FALSE normally.

Return Value:

  The new move list that has overlaps removed. The caller must use the return
  value instead of the input List.

--*/

{
    PMOVE_LIST_NODEW currentNode;
    PMOVE_LIST_NODEW checkNode;
    PMOVE_LIST_NODEW collisionNode;
    UINT destLength;
    UINT collisionSrcLength = 0;
    BOOL disableThisPath;
    BOOL done;
    PCWSTR srcSubPath;
    PCWSTR destSubPath;
    PMOVE_LISTW preMoveList = NULL;
    PMOVE_LISTW postMoveList = NULL;
    WCHAR tempPathRoot[] = L"?:\\$tmp$dir.@xx";
    PCWSTR tempPath;
    PCWSTR subDir;
    PCWSTR collisionSrc;
    MOVE_LIST_ENUMW listEnum;
    PWSTR tempDest;
    PWSTR p;
    UINT currentNodeSrcLen;
    INT compareResult;
    PMOVE_LIST_GROUPW lengthGroup;
    BOOL currentMovedFirst;

    //
    // PASS 1: Minimize the list by eliminating nested moves
    //

    if (pEnumFirstMoveListItem (&listEnum, List)) {

        do {
            currentNode = listEnum.Item;
            currentNodeSrcLen = listEnum.LengthGroup->SourceLength;

            collisionNode = NULL;

            //
            // Locate a node that is further down the list but is
            // actually a parent of currentNode's destination
            //
            // That is, search for the following case:
            //
            //  collisionNode: c:\a -> c:\x
            //  currentNode:   c:\b -> c:\x\y
            //
            // collisionNode is moved ahead of currentNode.
            //

            disableThisPath = FALSE;
            done = FALSE;
            tempDest = DuplicatePathStringW (currentNode->Destination, 0);

            p = wcschr (tempDest + 3, L'\\');
            while (p) {
                *p = 0;

                __try {
                    checkNode = pFindDestination (List, tempDest);
                    if (!checkNode || (checkNode == currentNode)) {
                        __leave;
                    }

                    currentMovedFirst = TRUE;

                    collisionSrcLength = TcharCountW (checkNode->Source);

                    if (collisionSrcLength > currentNodeSrcLen) {
                        //
                        // checkNode is moved before currentNode
                        //

                        currentMovedFirst = FALSE;

                    } else if (currentNodeSrcLen == collisionSrcLength) {
                        //
                        // Need to compare source paths to see which one comes
                        // first. If the currentNode is alphabetically ahead of
                        // the collision, then its move will happen first.
                        //

                        compareResult = pCompareBackwards (
                                            collisionSrcLength,
                                            currentNode->Source,
                                            checkNode->Source
                                            );

                        if (compareResult < 0) {
                            currentMovedFirst = FALSE;
                        }
                    }

                    //
                    // currentNode's destination is a child of checkNode. We
                    // need to make sure currentNode's destination is not going
                    // to exist, or we need to ignore currentNode if it is
                    // implicitly handled by checkNode.
                    //

                    if (currentMovedFirst) {
                        //
                        // Record collision.
                        //
                        // currentNode->Source is moved ahead of checkNode->Source
                        // currentNode->Destination is a child of checkNode->Destination
                        //

                        if (!collisionNode) {
                            collisionNode = checkNode;
                        }

                        MYASSERT (TcharCountW (checkNode->Source) <= TcharCountW (currentNode->Source));

                        //
                        // If the subpath of currentNode's source is the same as its
                        // dest, and the base source path is the same for both,
                        // then remove currentNode. That is, we are testing for this case:
                        //
                        //  currentNode:    c:\a\y -> c:\x\y
                        //  checkNode:      c:\a   -> c:\x
                        //

                        MYASSERT (currentNodeSrcLen == TcharCountW (currentNode->Source));
                        MYASSERT (collisionSrcLength == TcharCountW (checkNode->Source));

                        if (StringIMatchTcharCountW (
                                currentNode->Source,
                                checkNode->Source,
                                collisionSrcLength
                                )) {

                            if (currentNode->Source[collisionSrcLength] == L'\\') {

                                //
                                // Now we know currentNode->Source is a child of
                                // checkNode->Source.
                                //

                                destLength = TcharCountW (checkNode->Destination);

                                srcSubPath = currentNode->Source + collisionSrcLength;
                                destSubPath = currentNode->Destination + destLength;

                                if (StringIMatchW (srcSubPath, destSubPath)) {
                                    //
                                    // Now we know that the sub path is identical.
                                    // The move in currentNode is handled implicitly
                                    // by checkNode, so we'll skip currentNode.
                                    //

                                    disableThisPath = TRUE;
                                    done = TRUE;
                                    __leave;
                                }
                            }
                        }
                    } else if (!SkipPrePostLists) {

                        MYASSERT (!currentMovedFirst);

                        if (!StringIPrefixW (currentNode->Source + 3, L"user~tmp.@0") &&
                            !StringIPrefixW (currentNode->Destination + 3, L"user~tmp.@0")
                            ) {

                            //
                            // We need to fix the case where the second destination is
                            // nested under the first. That is, currentNode->Destination
                            // is a subdir of checkNode->Destination.
                            //
                            // This is used for the case where:
                            //
                            //  checkNode:     c:\a -> c:\x
                            //  currentNode:   c:\b -> c:\x\y
                            //
                            // We must ensure that c:\a\y is not present for move 2.
                            // Therefore, we add 2 additional move operations:
                            //
                            // c:\a\y   -> c:\t\a\y
                            // c:\t\a\y -> c:\a\y
                            //
                            // This moves the collision out of the way, so that the parent
                            // can be moved, and then moves the folder back to its original
                            // location.
                            //
                            // The temp subdirectories for shell folders (user~tmp.@0?) are
                            // deliberatly ignored, because by definition they don't have
                            // collisions.
                            //

                            DEBUGMSGW ((
                                DBG_WARNING,
                                "Destination order collision:\n"
                                    "  Source: %s\n"
                                    "  Dest: %s\n"
                                    "  Collides with src: %s\n"
                                    "  Collides with dest: %s",
                                currentNode->Source,
                                currentNode->Destination,
                                checkNode->Source,
                                checkNode->Destination
                                ));

                            //
                            // compute pointer to subdir 'y' from c:\x\y
                            //

                            destLength = TcharCountW (checkNode->Destination);

                            destSubPath = currentNode->Destination + destLength;
                            MYASSERT (*destSubPath == L'\\');   // this is because we tested by cutting at wacks above
                            destSubPath++;
                            MYASSERT (*destSubPath);

                            //
                            // build the path c:\a\y
                            //

                            collisionSrc = JoinPathsW (checkNode->Source, destSubPath);

                            //
                            // build the path c:\t\a\y
                            //

                            tempPathRoot[0] = currentNode->Destination[0];
                            subDir = wcschr (collisionSrc, L'\\');
                            MYASSERT (subDir);
                            subDir++;
                            MYASSERT (*subDir);     // we should not ever move a root dir

                            tempPath = JoinPathsW (tempPathRoot, subDir);

                            //
                            // move c:\a\y (might not exist) to c:\t\a\y, then
                            // reverse the move
                            //

                            DEBUGMSGW ((
                                DBG_WARNING,
                                "Avoiding collision problems by deliberately not moving %s",
                                collisionSrc
                                ));

                            if (!preMoveList) {
                                preMoveList = pAllocateMoveList (List->Pool);
                                postMoveList = pAllocateMoveList (List->Pool);
                            }

                            if (preMoveList) {
                                pInsertMoveIntoListWorker (
                                    preMoveList,
                                    collisionSrc,
                                    tempPath
                                    );

                                pInsertMoveIntoListWorker (
                                    postMoveList,
                                    tempPath,
                                    collisionSrc
                                    );
                            }

                            FreePathStringW (collisionSrc);
                            FreePathStringW (tempPath);
                        }
                    }
                }
                __finally {
                    MYASSERT (TRUE);        // workaround for debugging
                }

                if (done) {
                    break;
                }

                *p = L'\\';
                p = wcschr (p + 1, L'\\');
            }

            FreePathStringW (tempDest);

            if (disableThisPath) {
                //
                // Remove currentNode from the list
                //

                MYASSERT (collisionNode);

                DEBUGMSGW ((
                    DBG_VERBOSE,
                    "Ignoring contained move:\n"
                        "  Source: %s\n"
                        "  Dest: %s\n"
                        "  Contained src: %s\n"
                        "  Contained dest: %s",
                    currentNode->Source,
                    currentNode->Destination,
                    collisionNode->Source,
                    collisionNode->Destination
                    ));

                lengthGroup = pGetMoveListGroup (List, currentNodeSrcLen);
                pDeleteMovePairFromGroup (List, lengthGroup, currentNode);
            }

        } while (pEnumNextMoveListItem (&listEnum));
    }

    //
    // PASS 2: After list is minimized, correct order issues, so that
    //         all moves can succeed.
    //

    if (pEnumFirstMoveListItem (&listEnum, List)) {

        do {
            currentNode = listEnum.Item;
            currentNodeSrcLen = TcharCountW (currentNode->FixedSource);

            destLength = TcharCountW (currentNode->FixedDestination);

            //
            // Locate a node that is further down the list but is actually a
            // parent of currentNode's destination
            //
            // That is, search for the following case:
            //
            //  checkNode:      c:\a -> c:\x
            //  currentNode:    c:\b -> c:\x\y
            //
            // checkNode is moved ahead of currentNode.
            //

            done = FALSE;
            tempDest = DuplicatePathStringW (currentNode->FixedDestination, 0);

            p = wcschr (tempDest + 3, L'\\');
            while (p) {
                *p = 0;

                __try {
                    //
                    // Find destination that is created ahead of currentNode's dest
                    //

                    checkNode = pFindDestination (List, tempDest);
                    if (!checkNode || (checkNode == currentNode)) {
                        __leave;
                    }

                    if (destLength <= TcharCountW (checkNode->FixedDestination)) {
                        __leave;
                    }

                    currentMovedFirst = TRUE;

                    collisionSrcLength = TcharCountW (checkNode->FixedSource);

                    if (collisionSrcLength > currentNodeSrcLen) {
                        currentMovedFirst = FALSE;

                    } else if (currentNodeSrcLen == collisionSrcLength) {

                        compareResult = pCompareBackwards (
                                            collisionSrcLength,
                                            currentNode->FixedSource,
                                            checkNode->FixedSource
                                            );

                        if (compareResult < 0) {
                            currentMovedFirst = FALSE;
                        }
                    }

                    if (currentMovedFirst) {

                        MYASSERT (TcharCountW (checkNode->FixedSource) <= TcharCountW (currentNode->FixedSource));

                        //
                        // We found a move contradiction, such as the following...
                        //
                        //  currentNode:    c:\a    -> c:\x\y
                        //  checkNode:      c:\b    -> c:\x
                        //
                        // or
                        //
                        //  currentNode:    c:\b\a  -> c:\x\y
                        //  checkNode:      c:\b    -> c:\x
                        //
                        // ...so we must reverse the order of the moves. This is done
                        // by swapping the strings. We have a separate set of pointers,
                        // so that the binary tree properties are not disturbed.
                        //

                        currentNode->FixedSource = checkNode->Source;
                        currentNode->FixedDestination = checkNode->Destination;

                        checkNode->FixedSource = currentNode->Source;
                        checkNode->FixedDestination = currentNode->Destination;

                        DEBUGMSGW ((
                            DBG_WARNING,
                            "Source order and dest order contradict each other. Fixing by reversing the order to:\n\n"
                                "%s -> %s\n"
                                "- before -\n"
                                "%s -> %s",
                            currentNode->FixedSource,
                            currentNode->FixedDestination,
                            checkNode->FixedSource,
                            checkNode->FixedDestination
                            ));

                        currentNodeSrcLen = collisionSrcLength;

                        FreePathStringW (tempDest);
                        tempDest = DuplicatePathStringW (currentNode->FixedDestination, 0);

                        destLength = TcharCountW (currentNode->FixedDestination);

                        p = wcschr (tempDest, L'\\');
                        if (!p) {
                            MYASSERT (FALSE);
                            done = TRUE;
                            __leave;
                        }
                    }
                }
                __finally {
                }

                if (done) {
                    break;
                }

                *p = L'\\';
                p = wcschr (p + 1, L'\\');
            }

            FreePathStringW (tempDest);

        } while (pEnumNextMoveListItem (&listEnum));
    }

    //
    // If we have a collision list, put the pre-moves at the head, and the
    // post-moves at the tail. This leaves the list out of order from the
    // point of view of longest to shortest source, so no additional
    // add/removes should be done.
    //

    if (preMoveList) {
        MYASSERT (postMoveList);

        preMoveList = pRemoveMoveListOverlapWorker (preMoveList, TRUE);

        postMoveList = pRemoveMoveListOverlapWorker (postMoveList, TRUE);

        pChainLists (preMoveList, List);
        pChainLists (List, postMoveList);

        List = preMoveList;
    }

    return List;
}


MOVELISTW
RemoveMoveListOverlapW (
    IN      MOVELISTW List
    )
{
    return (MOVELISTW) pRemoveMoveListOverlapWorker ((PMOVE_LISTW) List, FALSE);
}


BOOL
pOutputMoveListWorker (
    IN      HANDLE File,
    IN      PMOVE_LISTW List,            OPTIONAL
    IN      BOOL AddNestedMoves
    )

/*++

Routine Description:

  OutputMoveList writes every move pair in the specified list to the file
  handle specified. The output is a UNICODE text file.

Arguments:

  File - Specifies the file handle to write to

  List - Specifies the list to output

  AddNestedMoves - Specifies TRUE if the move list should contain extra
                   entries to ensure the move list records all subdirectories,
                   or FALSE if the move list should be the minimum list.

Return Value:

  TRUE if the file was written, FALSE if an error occurred.

--*/

{
    MOVE_LIST_ENUMW e;
    DWORD dontCare;
    HASHTABLE sourceMoveTable = NULL;
    PCWSTR src;
    PCWSTR dest;
    TREE_ENUMW unicodeEnum;
    PMOVE_LIST_NODEW node;

    if (pEnumFirstMoveListItem (&e, List)) {

        if (AddNestedMoves) {
            sourceMoveTable = HtAllocW();
        }

        //
        // Write UNICODE signature
        //
        // Do not write as a string. FE is a lead byte.
        //

        if (!WriteFile (File, "\xff\xfe", 2, &dontCare, NULL)) {
            return FALSE;
        }

        do {
            node = e.Item;

            if (!WriteFile (File, node->FixedSource, ByteCountW (node->FixedSource), &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, node->FixedDestination, ByteCountW (node->FixedDestination), &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                return FALSE;
            }

            if (sourceMoveTable) {
                HtAddStringW (sourceMoveTable, node->FixedSource);
            }

            if (AddNestedMoves) {
                //
                // We assume by implementation that this is only used on NT.
                // If Win9x support is needed, this code would have to use
                // the ANSI file enumeration APIs.
                //

                MYASSERT (ISNT());

                if (EnumFirstFileInTreeW (&unicodeEnum, node->FixedSource, NULL, FALSE)) {
                    do {
                        src = unicodeEnum.FullPath;

                        if (unicodeEnum.Directory) {

                            //
                            // Skip previously processed trees
                            //

                            if (HtFindStringW (sourceMoveTable, src)) {
                                AbortEnumCurrentDirW (&unicodeEnum);
                                continue;
                            }
                        }

                        //
                        // Move subdirectory and files
                        //

                        dest = JoinPathsW (node->FixedDestination, unicodeEnum.SubPath);

                        if (!WriteFile (File, src, ByteCountW (src), &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, dest, ByteCountW (dest), &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                            return FALSE;
                        }

                        FreePathStringW (dest);

                    } while (EnumNextFileInTreeW (&unicodeEnum));
                }

                //
                // NOTE: We do not record the nested moves in sourceMoveTable,
                //       because it is a waste of time & memory. All nesting
                //       should be taken care of by the sort order of the list.
                //
            }

        } while (pEnumNextMoveListItem (&e));
    }

    HtFree (sourceMoveTable);

    return TRUE;
}


BOOL
OutputMoveListW (
    IN      HANDLE File,
    IN      MOVELISTW List,                 OPTIONAL
    IN      BOOL AddNestedMoves
    )
{
    return pOutputMoveListWorker (File, (PMOVE_LISTW) List, AddNestedMoves);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    Ovidiu Temereanca (ovidiut)  23-Oct-1998
        Implemented a new log mechanism and added new logging capabilities

--*/


#include "pch.h"

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/


#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG|OD_NOFORMAT)                               \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_DEBUGLOG|OD_LOGFILE|OD_DEBUGGER)                 \
        DEFMAC(DBG_VERBOSE, OD_DEBUGLOG|OD_DEBUGGER)                            \
        DEFMAC(DBG_NAUSEA, OD_DEBUGLOG)                                         \
        DEFMAC(DBG_ASSERT, DEFAULT_ERROR_FLAGS)                                 \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG|OD_NOFORMAT)                               \
        DEFMAC("PoolMem", OD_SUPPRESS)                                          \

#endif





//
// This constant sets the default output
//

#ifndef DEBUG
#define NORMAL_DEFAULT      OD_LOGFILE
#else
#define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

//
// Constants and types
//

#define OUTPUT_BUFSIZE_LARGE  8192
#define OUTPUT_BUFSIZE_SMALL  128
#define MAX_MSGTITLE_LEN  14
#define MSGBODY_INDENT  12
#define SCREEN_WIDTH  80
#define MAX_TYPE  64

#define S_COLUMNDOUBLELINEA  ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW  L":\r\n\r\n"
#define S_NEWLINEA  "\r\n"
#define S_NEWLINEW  L"\r\n"

#define NEWLINE_CHAR_COUNT  (sizeof (S_NEWLINEA) - 1)


#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)
#define OUT_CONFIG(OutDest)         ((OutDest & OD_CONFIG) != 0)
#define OUT_NOFORMAT(OutDest)       ((OutDest & OD_NOFORMAT) != 0)

#ifdef DEBUG
#define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
#define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#else
#define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
#define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)  ((buf) + (sizeof(buf) / sizeof(buf[0])) - 1)

#define DEBUG_SECTION  "Debug"
#define ENTRY_ALL  "All"
#define ENTRY_DEFAULTOVERRIDE  "DefaultOverride"


#define LOGSEVERITY LogSeverity

#define LOGSEV_FATAL_ERROR  LogSevFatalError
#define LOGSEV_ERROR  LogSevError
#define LOGSEV_WARNING  LogSevWarning
#define LOGSEV_INFORMATION  LogSevInformation



typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
    OD_CONFIG = 0x1000,             // output to config.dmp
    OD_NOFORMAT = 0x2000            // no format on output string
} OUTPUT_DESTINATION;

#define OUTPUTDEST      DWORD

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;


const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};


const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

//
// a window handle for popup parent
//
HWND g_LogPopupParentWnd = NULL;

//
// thread id that set this window handle
//
DWORD g_InitThreadId = 0;


static OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
static OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
static PVOID g_TypeSt = NULL;
static BOOL g_HasTitle = FALSE;
static CHAR g_LastType [MAX_TYPE];
static BOOL g_SuppressAllPopups = FALSE;

CHAR g_ConfigDmpPathBufA[MAX_MBCHAR_PATH];
BOOL g_ResetLog = FALSE;

#ifdef PROGRESS_BAR

HANDLE g_ProgressBarLog = INVALID_HANDLE_VALUE;

#endif //PROGRESS_BAR


#ifdef DEBUG

CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
WCHAR g_DebugInfPathBufW[] = L"C:\\debug.inf";
CHAR g_Debug9xLogPathBufA[] = "C:\\debug9x.log";
CHAR g_DebugNtLogPathBufA[] = "C:\\debugnt.log";
PCSTR g_DebugLogPathA = NULL;

//
// If g_DoLog is TRUE, then, debug logging is enabled in the
// checked build even if there is no debug.inf.
// This variable can be enabled via the /#U:DOLOG command line directive...

BOOL g_DoLog = FALSE;

#define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);

#else

#define PRIVATE_ASSERT(expr)

#endif // DEBUG


#define DEFMAC(typestr, flags)      {typestr, flags},

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;

DEFAULT_DESTINATION g_DefaultDest[] = {TYPE_DEFAULTS /* , */ {NULL, 0}};

#undef DEFMAC



#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR Buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (Buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBox (NULL, Buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    INT i;

    for(i = 0; i < sizeof (g_IgnoreKeys) / sizeof (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    INT i;

    for(i = 0; i < sizeof (g_String2Binary) / sizeof (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST OutDest;

    if (g_TypeSt == NULL) {
        //
        // sorry, log is closed
        //
        return OD_UNDEFINED;
    }

    if (-1 != pSetupStringTableLookUpStringEx (
                    g_TypeSt,
                    (PSTR)Type, // remove const, however string will not be modified
                    STRTAB_CASE_INSENSITIVE,
                    &OutDest,
                    sizeof (OutDest)
                    )) {

#ifdef DEBUG
        if (g_DoLog) {
            OutDest |= OD_DEBUGLOG;
        }
#endif
        return OutDest;

    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST OutDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        OutDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        OutDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (OutDest)) {

            //
            // just return the default
            //

            OutDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        OutDest |= OD_DEBUGLOG;
    }
#endif


    return OutDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST OutDest;

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    OutDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (OutDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LogSevInformation.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LogSevError;
    }

    return LogSevInformation;
}


BOOL
pTableAddType (
    IN      PCSTR Type,
    IN      OUTPUTDEST OutDest
    )

/*++

Routine Description:

  pTableAddType adds a <Type, OutDest> association
  to the table g_TypeSt. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    PRIVATE_ASSERT (g_TypeSt != NULL);

    return -1 != pSetupStringTableAddStringEx(
                    g_TypeSt,
                    (PSTR)Type, // remove const, however string will not be modified
                    STRTAB_CASE_INSENSITIVE | STRTAB_NEW_EXTRADATA,
                    &OutDest,
                    sizeof(OutDest)
                    );
}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST OutDest = OD_UNDEFINED;
    CHAR Value[OUTPUT_BUFSIZE_SMALL];
    INT Field;

    for(Field = SetupGetFieldCount (InfContext); Field > 0; Field--) {
        if (SetupGetStringFieldA (
                InfContext,
                Field,
                Value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            OutDest |= pConvertToOutputType(Value);
        }
    }

    return OutDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_TypeSt table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT InfContext;
    OUTPUTDEST OutDest;
    CHAR Key[OUTPUT_BUFSIZE_SMALL];

    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &InfContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &InfContext,
                    0,
                    Key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }

            if (pIgnoreKey (Key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (Key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&InfContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (Key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&InfContext);
                } else {
                    OutDest = pGetAttributes(&InfContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (OutDest)) {
                        if (!pTableAddType (Key, OutDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&InfContext, &InfContext));
    }

    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      INT  Indent
    )

{
    INT i;
    PSTR p;

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' ';
    }

    *p = 0;
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      INT   Indent
    )
{
    INT i;
    PWSTR p;

    for (i = TcharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';
    }

    *p = 0;
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      INT Indent,
    IN      PBOOL TrimLeadingSpace
    )

{
    INT Col = 0;
    INT MaxCol = SCREEN_WIDTH - 1 - Indent;
    PCSTR LastSpace = NULL;
    PCSTR PrevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && Col < MaxCol) {

        if (ch == '\n') {
            LastSpace = Line;
            break;
        }

        if (ch > 255) {
            LastSpace = Line;
            Col++;
        } else {
            if (_ismbcspace (ch)) {
                LastSpace = Line;
            }
        }

        Col++;
        PrevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (LastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        LastSpace = PrevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (LastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      INT Indent,
    IN      PBOOL TrimLeadingSpace
    )
{
    INT Col = 0;
    INT MaxCol = SCREEN_WIDTH - 1 - Indent;
    PCWSTR LastSpace = NULL;
    PCWSTR PrevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && Col < MaxCol) {

        if (ch == L'\n') {
            LastSpace = Line;
            break;
        }

        if (ch > 255) {
            LastSpace = Line;
        } else {
            if (iswspace (ch)) {
                LastSpace = Line;
            }
        }

        Col++;
        PrevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (LastSpace == NULL) {
        // we must cut this even if no white space was found
        LastSpace = PrevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return LastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in Buffer, which is no larger than Size.

Arguments:

  Buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR Buffer,
    IN      DWORD Size,
    IN      INT Indent
    )

{
    CHAR IndentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR NextLine;
    PCSTR s;
    PSTR d;
    INT i;
    BOOL TrimLeadingSpace;
    PCSTR EndOfBuf;
    BOOL AppendNewLine = FALSE;

    NextLine = Buffer;
    s = Buffer;
    d = IndentBuffer;

    EndOfBuf = END_OF_BUFFER(IndentBuffer) - 3;

    while (*s && d < EndOfBuf) {

        //
        // Find end of next line
        //

        NextLine = (PSTR)pFindNextLineA (s, Indent, &TrimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < NextLine && d < EndOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (isleadbyte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (TrimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            AppendNewLine = TRUE;

            if (d < EndOfBuf && TrimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < EndOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (AppendNewLine && d < EndOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(IndentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (Buffer, IndentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR Buffer,
    IN      DWORD Size,
    IN      INT Indent
    )
{
    WCHAR IndentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR NextLine;
    PCWSTR s;
    PWSTR d;
    INT i;
    BOOL TrimLeadingSpace;
    PCWSTR EndOfBuf;
    BOOL AppendNewLine = FALSE;

    NextLine = Buffer;
    s = Buffer;
    d = IndentBuffer;

    EndOfBuf = END_OF_BUFFER(IndentBuffer) - 1;

    while (*s && d < EndOfBuf) {

        //
        // Find end of next line
        //

        NextLine = (PWSTR)pFindNextLineW (s, Indent, &TrimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < NextLine && d < EndOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (TrimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            AppendNewLine = TRUE;

            if (d < EndOfBuf && TrimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < EndOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (AppendNewLine && d < EndOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(IndentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyTcharCountW (Buffer, IndentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      LONG LastError
    )
{
    PSTR Append;
    DWORD ErrMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    Append = GetEndOfStringA (MsgWithErr);
    ErrMsgLen = MsgWithErr + BufferSize - Append;

    if (ErrMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (Append, ErrMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (Append, ErrMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      LONG LastError
    )
{
    PWSTR Append;
    DWORD ErrMsgLen;

    StringCopyTcharCountW (MsgWithErr, Message, BufferSize / sizeof(WCHAR));
    Append = GetEndOfStringW (MsgWithErr);
    ErrMsgLen = MsgWithErr + (BufferSize / sizeof(WCHAR)) - Append;

    if (ErrMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (Append, ErrMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (Append, ErrMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  FormattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR FormattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      INT Indent,
    IN      LONG LastError
    )
{
    CHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR MyMsgBody;
    PSTR Current;
    DWORD Remaining;

    MyMsgBody = Body;
    Remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        MyMsgBody = BodyWithErr;

        pAppendLastErrorA (BodyWithErr, sizeof (BodyWithErr), Body, LastError);
    }

    StringCopyByteCountA (FormattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (FormattedMsg, Indent);

    Current = FormattedMsg + Indent;
    StringCopyByteCountA (Current, MyMsgBody, Remaining);
    pHangingIndentA (Current, Remaining, Indent);

    // append a new line if space left
    Current = GetEndOfStringA (Current);
    if (Current + NEWLINE_CHAR_COUNT + 1 < FormattedMsg + BufferSize) {
        *Current++ = '\r';
        *Current++ = '\n';
        *Current = 0;
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR FormattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      INT Indent,
    IN      LONG LastError
    )
{
    WCHAR TypeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR MyMsgBody;
    PWSTR Current;
    DWORD Remaining;

    MyMsgBody = Body;
    Remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        MyMsgBody = BodyWithErr;

        pAppendLastErrorW (BodyWithErr, sizeof (BodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (TypeW, Type);

    StringCopyTcharCountW (FormattedMsg, TypeW, MAX_MSGTITLE_LEN);
    pPadTitleW (FormattedMsg, Indent);

    Current = FormattedMsg + Indent;
    StringCopyTcharCountW (Current, MyMsgBody, Remaining);
    pHangingIndentW (Current, Remaining, Indent);

    // append a new line if space left
    Current = GetEndOfStringW (Current);
    if (Current + NEWLINE_CHAR_COUNT + 1 < FormattedMsg + BufferSize) {
        *Current++ = L'\r';
        *Current++ = L'\n';
        *Current = 0;
    }
}


/*++

Routine Description:

  pWriteToSetupLogA and pWriteToSetupLogW log the specified message
  to the setup log using Setup API functions.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  FormattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToSetupLogA (
    IN      LOGSEVERITY Severity,
    IN      PCSTR FormattedMsg
    )
{
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }
    if (!SetupLogErrorA (FormattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    SetupCloseLog();
}


VOID
pWriteToSetupLogW (
    IN      LOGSEVERITY Severity,
    IN      PCWSTR FormattedMsg
    )
{
    if (!SetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }

    if (!SetupLogErrorW (FormattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    SetupCloseLog();
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      LONG LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR Buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR Current = Buffer;
#endif
    UINT MBStyle;
    LONG rc;
    OUTPUTDEST OutDest;
    HWND ParentWnd;
    PCSTR DisplayMessage = Msg;
    LOGSEVERITY Severity = pGetSeverityFromType (Type);

    OutDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                Current += wsprintfA (Buffer, " [ERROR=%u]", LastError);
            } else {
                Current += wsprintfA (Buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (OutDest)) {
            Current += wsprintfA (
                            Current,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            Current += wsprintfA (
                            Current,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (Current > Buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            DisplayMessage = FormattedMsg;
            StringCopyByteCountA (
                FormattedMsg,
                Msg,
                sizeof (FormattedMsg) / sizeof (CHAR) - (Current - Buffer)
                );
            StringCatA (FormattedMsg, Buffer);
        }
#endif

        switch (Severity) {

        case LOGSEV_FATAL_ERROR:
            MBStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            MBStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            MBStyle = MB_ICONEXCLAMATION;
            break;

        default:
            MBStyle = MB_ICONINFORMATION;

        }
        MBStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (OutDest)) {
            MBStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            MBStyle |= MB_OKCANCEL;
        }
#else
        MBStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            ParentWnd = g_LogPopupParentWnd;

        } else {

            ParentWnd = NULL;

        }

        rc = MessageBoxA (ParentWnd, DisplayMessage, Type, MBStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            pTableAddType (Type, OutDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      LONG LastError,
    IN      BOOL Forced
    )
{
    PCSTR MsgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    MsgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, MsgA, LastError, Forced);
    FreeConvertedStr (MsgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR FormattedMsg
    )
{
    OUTPUTDEST OutDest;
    HANDLE Handle;
    LONG LastError;
    CHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR LogMessage;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (OutDest)) {
        return;
    }

    if (OUT_LOGFILE (OutDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (OutDest)) {

            if (Message) {

                LogMessage = Message;

                LastError = GetLastError ();

                if (LastError != ERROR_SUCCESS) {

                    pAppendLastErrorA (BodyWithErr, sizeof (BodyWithErr), Message, LastError);

                    LogMessage = BodyWithErr;
                }

                pWriteToSetupLogA (LOGSEV_INFORMATION, "Error:\r\n");
                pWriteToSetupLogA (LOGSEV_ERROR, LogMessage);
                pWriteToSetupLogA (LOGSEV_INFORMATION, "\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogA (LOGSEV_INFORMATION, FormattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(OutDest)) {
        OutputDebugStringA (FormattedMsg);
    }

    if (OUT_CONSOLE(OutDest)) {
        fprintf (stderr, "%s", FormattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (OutDest)) {

        Handle = CreateFileA (
                            g_DebugLogPathA,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringA (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
#endif

    if (OUT_CONFIG (OutDest)) {

        Handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringA (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR FormattedMsg
    )
{
    OUTPUTDEST OutDest;
    HANDLE Handle;
    LONG LastError;
    WCHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR LogMessage;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (OutDest)) {
        return;
    }

    if (OUT_LOGFILE (OutDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (OutDest)) {

            if (Message) {

                LogMessage = Message;

                LastError = GetLastError ();

                if (LastError != ERROR_SUCCESS) {

                    pAppendLastErrorW (BodyWithErr, sizeof (BodyWithErr), Message, LastError);

                    LogMessage = BodyWithErr;
                }
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"Error:\r\n");
                pWriteToSetupLogW (LOGSEV_ERROR, LogMessage);
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogW (LOGSEV_INFORMATION, FormattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(OutDest)) {
        OutputDebugStringW (FormattedMsg);
    }

    if (OUT_CONSOLE(OutDest)) {
        fwprintf (stderr, L"%s", FormattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (OutDest)) {

        Handle = CreateFileA (
                        g_DebugLogPathA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringW (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
#endif

    if (OUT_CONFIG (OutDest)) {

        Handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringW (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR Output[OUTPUT_BUFSIZE_LARGE];
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST OutDest;
    LONG LastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(OutDest)) {
        return;
    }

    if (OUT_ERROR (OutDest)) {
        LastError = GetLastError();
    } else {
        LastError = ERROR_SUCCESS;
    }

    // format output string
    if (HIWORD(Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) Output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(Output, OUTPUT_BUFSIZE_LARGE, Format, args);
    }

    if (OUT_NOFORMAT (OutDest)) {
        _tcssafecpy (FormattedMsg, Output, sizeof(FormattedMsg) - (NEWLINE_CHAR_COUNT + 1) * sizeof (CHAR));
        StringCatA (FormattedMsg, S_NEWLINEA);
    } else {
        pIndentMessageA (
            FormattedMsg,
            OUTPUT_BUFSIZE_LARGE,
            Type,
            Output,
            MSGBODY_INDENT,
            LastError
            );
    }

    pRawWriteLogOutputA (Type, Output, FormattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (OutDest)) {
            PRIVATE_ASSERT (HIWORD (Format) == 0);
        }

        pDisplayPopupA (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));

#else
        if (HIWORD (Format) == 0) {
            pDisplayPopupA (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR FormatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR Output[OUTPUT_BUFSIZE_LARGE];
    WCHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST OutDest;
    LONG LastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(OutDest)) {
        return;
    }

    if (OUT_ERROR (OutDest)) {
        LastError = GetLastError();
    } else {
        LastError = ERROR_SUCCESS;
    }

    // format output string
    if (HIWORD(Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) Output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {
        KnownSizeAtoW (FormatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(Output, OUTPUT_BUFSIZE_LARGE, FormatW, args);
    }

    if (OUT_NOFORMAT (OutDest)) {
        _wcssafecpy (FormattedMsg, Output, sizeof(FormattedMsg) - (NEWLINE_CHAR_COUNT + 1) * sizeof (WCHAR));
        StringCatW (FormattedMsg, S_NEWLINEW);
    } else {
        pIndentMessageW (
            FormattedMsg,
            OUTPUT_BUFSIZE_LARGE,
            Type,
            Output,
            MSGBODY_INDENT,
            LastError
            );
    }

    pRawWriteLogOutputW (Type, Output, FormattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (OutDest)) {
            PRIVATE_ASSERT (HIWORD (Format) == 0);
        }

        pDisplayPopupW (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));

#else
        if (HIWORD (Format) == 0) {
            pDisplayPopupW (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));
        }
#endif

    }
}


BOOL
pLogInit (
    IN      HWND *LogPopupParentWnd,    OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      BOOL FirstTimeInit
    )

/*++

Routine Description:

  pLogInit actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is optional only if FirstTimeInit
                       is FALSE.

  OrgPopupParentWnd  - Receives the original parent window.

  FirstTimeInit  - Specifies TRUE for the first log initialization,
                   or FALSE for reinitialization

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF Inf = INVALID_HANDLE_VALUE;
    BOOL Result = FALSE;
    PDEFAULT_DESTINATION Dest;
#ifdef DEBUG
    CHAR TempPath[MAX_MBCHAR_PATH];
#endif

    PRIVATE_ASSERT (!FirstTimeInit || LogPopupParentWnd);

    __try {

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_TypeSt);
            g_TypeSt = pSetupStringTableInitializeEx(sizeof (OUTPUTDEST), 0);

            if (!g_TypeSt) {
                __leave;
            }

            Dest = g_DefaultDest;

            while (Dest->Type) {
                pTableAddType (Dest->Type, Dest->Flags);
                Dest++;
            }

            if (!GetWindowsDirectoryA (g_ConfigDmpPathBufA, MAX_MBCHAR_PATH)) {
                __leave;
            }
            StringCopyA (AppendWackA (g_ConfigDmpPathBufA), TEXT("config.dmp"));

#ifdef PROGRESS_BAR
            PRIVATE_ASSERT (g_ProgressBarLog == INVALID_HANDLE_VALUE);
            g_ProgressBarLog = CreateFile (
                                ISNT() ? TEXT("C:\\pbnt.txt") : TEXT("C:\\pb9x.txt"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                SetFilePointer (g_ProgressBarLog, 0, NULL, FILE_END);
            }
#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_ConfigDmpPathBufA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_ConfigDmpPathBufA);
        }

#ifdef DEBUG
        if (FirstTimeInit) {
            if (ISPC98()) {
                GetSystemDirectoryA (TempPath, ARRAYSIZE (TempPath));
                // replace C with the actual sys drive letter
                g_DebugNtLogPathBufA[0] = g_Debug9xLogPathBufA[0] = TempPath[0];
                g_DebugInfPathBufA[0] = TempPath[0];
                //
                // only the first byte is important because drive letters are not double-byte chars
                //
                g_DebugInfPathBufW[0] = (WCHAR)TempPath[0];
            }

            //
            // now get user's preferences
            //

            Inf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            if (INVALID_HANDLE_VALUE != Inf && pGetUserPreferences(Inf)) {
                g_DoLog = TRUE;
            }
        }

        if (g_DebugLogPathA == NULL) {

            g_DebugLogPathA = ISNT() ? g_DebugNtLogPathBufA : g_Debug9xLogPathBufA;
        }

        if (g_ResetLog) {

            SetFileAttributesA (g_DebugLogPathA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogPathA);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = *LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        Result = TRUE;
    }
    __finally {

        if (Inf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (Inf);
        }

        if (!Result) {

            if (g_TypeSt) {
                pSetupStringTableDestroy(g_TypeSt);
                g_TypeSt = NULL;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif

#ifdef PROGRESS_BAR
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                CloseHandle (g_ProgressBarLog);
                g_ProgressBarLog = INVALID_HANDLE_VALUE;
            }
#endif
        }
    }

    return Result;
}


BOOL
LogInit (
    HWND Parent
    )

/*++

Routine Description:

  LogInit initializes the log system calling the worker pLogInit. This function
  should be only called once

Arguments:

  Parent  - Specifies the initial parent window for all popups.  If NULL,
            the popups are suppressed.  Callers can use LogReInit to change
            the parent window handle at any time.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    return pLogInit (&Parent, NULL, TRUE);
}


BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    )

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pLogInit.
  This function may be called any number of times, but only after LogInit

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

Return Value:

  TRUE if log system was successfully re-initialized

--*/

{
    return pLogInit (NewParent, OrgParent, FALSE);
}


VOID
LogExit (
    VOID
    )

/*++

Routine Description:

  LogExit cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{

#ifdef DEBUG

    if (g_DebugLogPathA) {
        g_DebugLogPathA = NULL;
    }

#endif

#ifdef PROGRESS_BAR
    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        CloseHandle (g_ProgressBarLog);
        g_ProgressBarLog = INVALID_HANDLE_VALUE;
    }
#endif

    if (g_TypeSt) {
        pSetupStringTableDestroy(g_TypeSt);
        g_TypeSt = NULL;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCopyByteCountA (FormattedMsg, Title, sizeof (FormattedMsg) - sizeof (S_COLUMNDOUBLELINEA));
    StringCatA (FormattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, FormattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR TypeW[OUTPUT_BUFSIZE_SMALL];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        KnownSizeAtoW (TypeW, Type);
        Title = TypeW;
    }

    StringCopyByteCountW (FormattedMsg, Title, sizeof (FormattedMsg) - sizeof (S_COLUMNDOUBLELINEW));
    StringCatW (FormattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, FormattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR Output[OUTPUT_BUFSIZE_LARGE];
    BOOL HasNewLine = FALSE;
    PCSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (Output, Line, sizeof (Output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (Output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNT, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNT] == 0) {

            //
            // the line ends with a newline
            //

            HasNewLine = TRUE;
            break;
        }
    }

    if (!HasNewLine) {
        StringCatA (Output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, Output);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR Output[OUTPUT_BUFSIZE_LARGE];
    BOOL HasNewLine = FALSE;
    PCWSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyTcharCountW (Output, Line, sizeof (Output) / sizeof (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (Output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNT, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNT] == 0) {

            //
            // the line ends with a newline
            //

            HasNewLine = TRUE;
            break;
        }
    }

    if (!HasNewLine) {
        StringCatW (Output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, Output);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text);
}


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCount = 0;
    static DWORD LastTickCount  = 0;
    DWORD CurrentTickCount;
    CHAR Msg[OUTPUT_BUFSIZE_LARGE];
    PSTR AppendPos;
    va_list args;

    PushError();

    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCount) {
        FirstTickCount = CurrentTickCount;
        LastTickCount  = CurrentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    AppendPos = Msg + vsprintf (Msg, Format, args);
    va_end (args);
    sprintf (
        AppendPos,
        "\t%lu\t%lu\r\n",
        CurrentTickCount - LastTickCount,
        CurrentTickCount - FirstTickCount
        );

    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        WriteFileStringA (g_ProgressBarLog, Msg);
    }

    LastTickCount = CurrentTickCount;

    PopError();
}

#else // !PROGRESS_BAR

#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCountA = 0;
    static DWORD LastTickCountA  = 0;
    CHAR Msg[OUTPUT_BUFSIZE_LARGE];
    CHAR Date[OUTPUT_BUFSIZE_SMALL];
    CHAR Time[OUTPUT_BUFSIZE_SMALL];
    PSTR AppendPos, End;
    DWORD CurrentTickCount;
    va_list args;

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            Date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (Date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            Time,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (Time,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCountA) {
        FirstTickCountA = CurrentTickCount;
        LastTickCountA  = CurrentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    AppendPos = Msg + _vsnprintf (Msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    End = Msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        AppendPos,
        End - AppendPos,
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        Date,
        Time,
        CurrentTickCount - LastTickCountA,
        CurrentTickCount - FirstTickCountA
        );

    LastTickCountA = CurrentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", Msg);

    PopError();
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCountW = 0;
    static DWORD LastTickCountW  = 0;
    WCHAR MsgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR DateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR TimeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR FormatW;
    PWSTR AppendPosW, EndW;
    DWORD CurrentTickCount;
    va_list args;

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            DateW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (DateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            TimeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (TimeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCountW) {
        FirstTickCountW = CurrentTickCount;
        LastTickCountW  = CurrentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    FormatW = ConvertAtoW (Format);
    AppendPosW = MsgW + _vsnwprintf (MsgW, OUTPUT_BUFSIZE_LARGE, FormatW, args);
    FreeConvertedStr (FormatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    EndW = MsgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        AppendPosW,
        EndW - AppendPosW,
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        DateW,
        TimeW,
        CurrentTickCount - LastTickCountW,
        CurrentTickCount - FirstTickCountW
        );

    LastTickCountW = CurrentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", MsgW);

    PopError();
}

#endif // DEBUG

#endif // PROGRESS_BAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "migutilp.h"
#include "locale.h"

//#define DEBUG_ALL_FILES

OSVERSIONINFOA g_OsInfo;
extern OUR_CRITICAL_SECTION g_DebugMsgCs;

#define TEXT_GROWTH_SIZE    65536

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
PCSTR g_ErrorString = NULL;
HWND g_OutOfMemoryParentWnd;

//
// OS-dependent flags for MultiByteToWideChar
//
DWORD g_MigutilWCToMBFlags = 0;

//
// A dynamic string. Among other things, this list can hold lists of imports
// as they are read out Win32 executables.
//
//DYNSTRING dynImp;

//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_LastAllocTable is a temporary holder for the wrapper APIs that
// do not require the caller to supply the alloc table.  DO NOT ALTER!
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_LastAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;
BOOL fInitedMessageCs = FALSE;

//
// The PoolMem routines must also be thread-safe
//

CRITICAL_SECTION g_PoolMemCs;
BOOL fInitedPoolMemCs = FALSE;

//
// MemAlloc critical section
//

CRITICAL_SECTION g_MemAllocCs;
BOOL fInitedMemAllocCs = FALSE;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//

POOLHANDLE g_RegistryApiPool;
POOLHANDLE g_PathsPool;
POOLHANDLE g_TextPool;

//
// PC98 settings
//

BOOL g_IsPc98;

static CHAR g_BootDrivePathBufA[8];
static WCHAR g_BootDrivePathBufW[4];
PCSTR g_BootDrivePathA;
PCWSTR g_BootDrivePathW;
static CHAR g_BootDriveBufA[6];
static WCHAR g_BootDriveBufW[3];
PCSTR g_BootDriveA;
PCWSTR g_BootDriveW;
CHAR g_BootDriveLetterA;
WCHAR g_BootDriveLetterW;



//
// Implementation
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{


    switch (dwReason) {

    case DLL_PROCESS_ATTACH:

        //
        // NOTE: If FALSE is returned, none of the executables will run.
        //       Every project executable links to this library.
        //

        if(!pSetupInitializeUtils()) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize SpUtils"));
            return FALSE;
        }

        //
        // Load in OSVERSION info.
        //
        g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        // this function only fails if we specify an invalid value
        // for the dwOSVersionInfoSize member (which we don't)
        if(!GetVersionExA(&g_OsInfo))
            MYASSERT(FALSE);

        //g_IsPc98 = (GetKeyboardType (0) == 7) && ((GetKeyboardType (1) & 0xff00) == 0x0d00);
        g_IsPc98 = FALSE;

        g_BootDrivePathA = g_BootDrivePathBufA;
        g_BootDrivePathW = g_BootDrivePathBufW;
        g_BootDriveA     = g_BootDriveBufA;
        g_BootDriveW     = g_BootDriveBufW;

        if (g_IsPc98) {
            StringCopyA ((PSTR) g_BootDrivePathA, "A:\\");
            StringCopyW ((PWSTR) g_BootDrivePathW, L"A:\\");
            StringCopyA ((PSTR) g_BootDriveA, "A:");
            StringCopyW ((PWSTR) g_BootDriveW, L"A:");
            g_BootDriveLetterA = 'A';
            g_BootDriveLetterW = L'A';
        } else {
            StringCopyA ((PSTR) g_BootDrivePathA, "C:\\");
            StringCopyW ((PWSTR) g_BootDrivePathW, L"C:\\");
            StringCopyA ((PSTR) g_BootDriveA, "C:");
            StringCopyW ((PWSTR) g_BootDriveW, L"C:");
            g_BootDriveLetterA = 'C';
            g_BootDriveLetterW = L'C';
        }

        // initialize log
        if (!LogInit (NULL)) {
            return FALSE;
        }

        // MemAlloc critical section
        InitializeCriticalSection (&g_MemAllocCs);
        fInitedMemAllocCs = TRUE;

        // Now that MemAlloc will work, initialize allocation tracking
        InitAllocationTracking();

        // PoolMem critical section
        InitializeCriticalSection (&g_PoolMemCs);
        fInitedPoolMemCs = TRUE;

        // The short-term alloc table for string resource utils
        g_ShortTermAllocTable = CreateAllocTable();
        if (!g_ShortTermAllocTable) {
            DEBUGMSG ((DBG_ERROR, "Cannot create short-term AllocTable"));
            return FALSE;
        }


        //
        // MultiByteToWideChar has desirable flags that only function on NT
        //
        g_MigutilWCToMBFlags = (ISNT()) ? WC_NO_BEST_FIT_CHARS : 0;


        // The critical section that guards ParseMessage/GetStringResource
        if (!InitializeOurCriticalSection (&g_MessageCs)) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize critical section"));
            DestroyAllocTable (g_ShortTermAllocTable);
            g_ShortTermAllocTable = NULL;
        }
        else
        {
            fInitedMessageCs = TRUE;
        }

        // A pool for APIs in reg.c
        g_RegistryApiPool = PoolMemInitNamedPool ("Registry API");
        g_PathsPool = PoolMemInitNamedPool ("Paths");
        g_TextPool = PoolMemInitNamedPool ("Text");

        if (!g_RegistryApiPool || !g_PathsPool || !g_TextPool) {
            return FALSE;
        }

        PoolMemSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

        // The "out of memory" message
        g_OutOfMemoryTable = CreateAllocTable();
        if (!g_OutOfMemoryTable) {
            DEBUGMSG ((DBG_ERROR, "Cannot create out of memory AllocTable"));
            return FALSE;
        }

        g_OutOfMemoryRetry  = GetStringResourceExA (g_OutOfMemoryTable, 10001 /* MSG_OUT_OF_MEMORY_RETRY */);
        g_OutOfMemoryString = GetStringResourceExA (g_OutOfMemoryTable, 10002 /* MSG_OUT_OF_MEMORY */);
        if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
            DEBUGMSG ((DBG_WARNING, "Cannot load out of memory messages"));
        }

        g_ErrorString = GetStringResourceExA (g_OutOfMemoryTable, 10003 /* MSG_ERROR */);
        if (!g_ErrorString || g_ErrorString[0] == 0) {
            g_ErrorString = "Error";
        }

        //
        // set the locale to the system locale. Not doing this can cause isspace to Av in certain MBSCHR circumstances.
        //
        setlocale(LC_ALL,"");

        InfGlobalInit (FALSE);

        RegInitialize();

        break;

    case DLL_PROCESS_DETACH:

#ifdef DEBUG
        DumpOpenKeys();
        RegTerminate();
#endif
        InfGlobalInit (TRUE);

        if (g_RegistryApiPool) {
            PoolMemDestroyPool (g_RegistryApiPool);
        }
        if (g_PathsPool) {
            PoolMemDestroyPool (g_PathsPool);
        }
        if (g_TextPool) {
            PoolMemDestroyPool (g_TextPool);
        }

        if (g_ShortTermAllocTable) {
            DestroyAllocTable (g_ShortTermAllocTable);
        }

        if (g_OutOfMemoryTable) {
            DestroyAllocTable (g_OutOfMemoryTable);
        }

        FreeAllocationTracking();

        //
        // VERY LAST CODE TO RUN
        //

        DumpHeapStats();
        LogExit();
        pSetupUninitializeUtils();

        if (fInitedMessageCs) {
            DeleteOurCriticalSection (&g_MessageCs);
        }

        if (fInitedPoolMemCs) {
            DeleteCriticalSection (&g_PoolMemCs);
        }

        if (fInitedMemAllocCs) {
            DeleteCriticalSection (&g_MemAllocCs);
        }

        break;
    }
    return TRUE;
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}


#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is bad, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    MessageBoxA (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        g_ErrorString,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    TerminateProcess (GetModuleHandle (NULL), 0);
}


VOID
pValidateBlock (
    PVOID Block,
    DWORD Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBoxA (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    g_ErrorString,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    }
}


PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    DWORD Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}



PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    DWORD Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}



HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\ne.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ne.c

Abstract:

    New-Executable parsing routines

Author:

    Jim Schmidt (jimschm)   04-May-1998

Revision History:

    jimschm     23-Sep-1998 Named icon ID bug fix, error path fixes

--*/

#include "pch.h"
#include "migutilp.h"

//
// NE code
//

typedef struct {
    HANDLE File;
    DWORD HeaderOffset;
    NE_INFO_BLOCK Header;
    NE_RESOURCES Resources;
    BOOL ResourcesLoaded;
    POOLHANDLE ResourcePool;
} NE_HANDLE, *PNE_HANDLE;




typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);


typedef struct {
    PCSTR TypeToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    BOOL Found;
} TYPESEARCHDATAA, *PTYPESEARCHDATAA;

typedef struct {
    PCSTR NameToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    PNE_RES_NAMEINFO OutboundNameInfo;
    BOOL Found;
} NAMESEARCHDATAA, *PNAMESEARCHDATAA;




BOOL
LoadNeHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    )
{
    DOS_HEADER dh;
    LONG rc = ERROR_BAD_FORMAT;
    BOOL b = FALSE;

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);
        if (!ReadBinaryBlock (File, &dh, sizeof (DOS_HEADER))) {
            __leave;
        }

        if (dh.e_magic != ('M' + 'Z' * 256)) {
            __leave;
        }

        SetFilePointer (File, dh.e_lfanew, NULL, FILE_BEGIN);
        if (!ReadBinaryBlock (File, Header, sizeof (NE_INFO_BLOCK))) {
            __leave;
        }

        if (Header->Signature != ('N' + 'E' * 256) &&
            Header->Signature != ('L' + 'E' * 256)
            ) {
            if (Header->Signature == ('P' + 'E' * 256)) {
                rc = ERROR_BAD_EXE_FORMAT;
            } else {
                rc = ERROR_INVALID_EXE_SIGNATURE;
            }

            DEBUGMSG ((DBG_NAUSEA, "Header signature is %c%c", Header->Signature & 0xff, Header->Signature >> 8));
            __leave;
        }

        SetFilePointer (File, (DWORD) dh.e_lfanew, NULL, FILE_BEGIN);

        b = TRUE;
    }
    __finally {
        if (!b) {
            SetLastError (rc);
        }
    }

    return b;
}


DWORD
pComputeSizeOfTypeInfo (
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    return sizeof (NE_RES_TYPEINFO) + TypeInfo->ResourceCount * sizeof (NE_RES_NAMEINFO);
}


PNE_RES_TYPEINFO
pReadNextTypeInfoStruct (
    IN      HANDLE File,
    IN      POOLHANDLE Pool
    )
{
    WORD Type;
    WORD ResCount;
    NE_RES_TYPEINFO TypeInfo;
    PNE_RES_TYPEINFO ReturnInfo = NULL;
    DWORD Size;

    if (!ReadBinaryBlock (File, &Type, sizeof (WORD))) {
        return NULL;
    }

    if (!Type) {
        return NULL;
    }

    if (!ReadBinaryBlock (File, &ResCount, sizeof (WORD))) {
        return NULL;
    }

    TypeInfo.TypeId = Type;
    TypeInfo.ResourceCount = ResCount;

    if (!ReadBinaryBlock (File, &TypeInfo.Reserved, sizeof (DWORD))) {
        return NULL;
    }

    Size = sizeof (NE_RES_NAMEINFO) * ResCount;

    ReturnInfo  = (PNE_RES_TYPEINFO) PoolMemGetMemory (Pool, Size + sizeof (TypeInfo));
    if (!ReturnInfo) {
        return NULL;
    }

    CopyMemory (ReturnInfo, &TypeInfo, sizeof (TypeInfo));

    if (!ReadBinaryBlock (File, (PBYTE) ReturnInfo + sizeof (TypeInfo), Size)) {
        return NULL;
    }

    return ReturnInfo;
}


BOOL
pReadTypeInfoArray (
    IN      HANDLE File,
    IN OUT  PGROWLIST TypeInfoList
    )
{
    PNE_RES_TYPEINFO TypeInfo;
    DWORD Size;
    POOLHANDLE TempPool;
    BOOL b = FALSE;

    TempPool = PoolMemInitPool();
    if (!TempPool) {
        return FALSE;
    }

    __try {

        TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        while (TypeInfo) {
            Size = pComputeSizeOfTypeInfo (TypeInfo);
            if (!GrowListAppend (TypeInfoList, (PBYTE) TypeInfo, Size)) {
                __leave;
            }

            TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        }

        b = TRUE;
    }
    __finally {

        PoolMemDestroyPool (TempPool);
    }

    return b;
}


BOOL
pReadStringArrayA (
    IN      HANDLE File,
    IN OUT  PGROWLIST GrowList
    )
{
    BYTE Size;
    CHAR Name[256];

    if (!ReadBinaryBlock (File, &Size, sizeof (BYTE))) {
        return FALSE;
    }

    while (Size) {

        if (!ReadBinaryBlock (File, Name, (DWORD) Size)) {
            return FALSE;
        }

        Name[Size] = 0;

        GrowListAppendString (GrowList, Name);

        if (!ReadBinaryBlock (File, &Size, sizeof (BYTE))) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
LoadNeResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    )
{
    NE_INFO_BLOCK Header;

    ZeroMemory (Resources, sizeof (NE_RESOURCES));

    if (!LoadNeHeader (File, &Header)) {
        return FALSE;
    }

    //
    // Read in NE_RESOURCES struct
    //

    SetFilePointer (File, (DWORD) Header.OffsetToResourceTable, NULL, FILE_CURRENT);

    if (!ReadBinaryBlock (File, &Resources->AlignShift, sizeof (WORD))) {
        return FALSE;
    }

    // Array of NE_RES_TYPEINFO structs
    if (!pReadTypeInfoArray (File, &Resources->TypeInfoArray)) {
        return FALSE;
    }

    // Resource names
    if (!pReadStringArrayA (File, &Resources->ResourceNames)) {
        return FALSE;
    }

    return TRUE;
}


VOID
FreeNeResources (
    PNE_RESOURCES Resources
    )
{
    FreeGrowList (&Resources->TypeInfoArray);
    FreeGrowList (&Resources->ResourceNames);

    ZeroMemory (Resources, sizeof (NE_RESOURCES));
}


BOOL
LoadNeIcon (
    HANDLE File,
    INT IconIndex
    )
{
    NE_RESOURCES Resources;
    INT Count;
    INT i;
    PNE_RES_TYPEINFO TypeInfo = NULL;
    BOOL b = FALSE;
    DWORD Offset;
    WORD w;
    PNE_RES_NAMEINFO NameInfo;
    DWORD Length;

    PBYTE Data;

    if (!LoadNeResources (File, &Resources)) {
        return FALSE;
    }

    __try {
        //
        // Search resources for RT_GROUPICON
        //

        Count = GrowListGetSize (&Resources.TypeInfoArray);
        for (i = 0 ; i < Count ; i++) {
            TypeInfo = (PNE_RES_TYPEINFO) GrowListGetItem (&Resources.TypeInfoArray, i);

            if (TypeInfo->TypeId == (WORD) RT_GROUP_ICON) {
                break;
            }
        }

        if (i == Count) {
            __leave;
        }

        //
        // Identify which group icon
        //

        NameInfo = TypeInfo->NameInfo;

        for (w = 0 ; w < TypeInfo->ResourceCount ; w++) {

            if (IconIndex > 0) {
                IconIndex--;
            } else if (!IconIndex) {
                break;
            } else if (-IconIndex == (INT) NameInfo->Id) {
                break;
            }

            NameInfo++;
        }

        if (w == TypeInfo->ResourceCount) {
            __leave;
        }

        //
        // Load the group icon resource
        //

        Offset = (DWORD) NameInfo->Offset << (DWORD) Resources.AlignShift;
        Length = (DWORD) NameInfo->Length << (DWORD) Resources.AlignShift;

        Data = MemAlloc (g_hHeap, 0, Length);
        if (!Data) {
            __leave;
        }

        SetFilePointer (File, Offset, NULL, FILE_BEGIN);
        ReadBinaryBlock (File, Data, Length);

        MemFree (g_hHeap, 0, Data);

        b = TRUE;
    }
    __finally {
        FreeNeResources (&Resources);
    }

    return b;
}


BOOL
LoadNeIconFromFileA (
    PCSTR FileName,
    INT IconIndex
    )
{
    HANDLE File;
    BOOL b;

    File = OpenNeFileA (FileName);

    if (!File) {
        return FALSE;
    }

    b = LoadNeIcon (File, IconIndex);

    CloseNeFile (File);

    return b;
}


HANDLE
OpenNeFileA (
    PCSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PoolMemInitPool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileA (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!LoadNeHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PoolMemDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}


HANDLE
OpenNeFileW (
    PCWSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PoolMemInitPool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileW (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!LoadNeHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PoolMemDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}


VOID
CloseNeFile (
    HANDLE Handle
    )
{
    PNE_HANDLE NeHandle;

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle) {
        return;
    }

    if (NeHandle->File != INVALID_HANDLE_VALUE) {
        CloseHandle (NeHandle->File);
    }

    if (NeHandle->ResourcesLoaded) {
        FreeNeResources (&NeHandle->Resources);
    }

    PoolMemDestroyPool (NeHandle->ResourcePool);

    MemFree (g_hHeap, 0, NeHandle);
}


PCSTR
pConvertUnicodeResourceId (
    IN      PCWSTR ResId
    )
{
    if (HIWORD (ResId)) {
        return ConvertWtoA (ResId);
    }

    return (PCSTR) ResId;
}


PCSTR
pDecodeIdReferenceInString (
    IN      PCSTR ResName
    )
{
    if (HIWORD (ResName) && ResName[0] == '#') {
        return (PCSTR) atoi (&ResName[1]);
    }

    return ResName;
}



BOOL
pLoadNeResourcesFromHandle (
    IN      PNE_HANDLE NeHandle
    )
{
    if (NeHandle->ResourcesLoaded) {
        return TRUE;
    }

    if (!LoadNeResources (NeHandle->File, &NeHandle->Resources)) {
        return FALSE;
    }

    NeHandle->ResourcesLoaded = TRUE;
    return TRUE;
}


BOOL
pLoadNeResourceName (
    OUT     PSTR ResName,
    IN      HANDLE File,
    IN      DWORD StringOffset
    )
{
    BYTE ResNameSize;

    SetFilePointer (File, StringOffset, NULL, FILE_BEGIN);
    if (!ReadBinaryBlock (File, &ResNameSize, 1)) {
        return FALSE;
    }

    ResName[ResNameSize] = 0;

    return ReadBinaryBlock (File, ResName, ResNameSize);
}


BOOL
pEnumNeResourceTypesEx (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCEXA EnumFunc,
    IN      LONG lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    INT Count;
    INT i;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESTYPEPROCA EnumFunc2 = (ENUMRESTYPEPROCA) EnumFunc;
    ENUMRESTYPEPROCEXW EnumFuncW = (ENUMRESTYPEPROCEXW) EnumFunc;
    ENUMRESTYPEPROCW EnumFunc2W = (ENUMRESTYPEPROCW) EnumFunc;
    PWSTR UnicodeResName = NULL;

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Enumerate all resource types
    //

    Count = GrowListGetSize (&NeHandle->Resources.TypeInfoArray);
    for (i = 0 ; i < Count ; i++) {
        TypeInfo = (PNE_RES_TYPEINFO) GrowListGetItem (&NeHandle->Resources.TypeInfoArray, i);

        if (TypeInfo->TypeId & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, (PWSTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, (PSTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, (PWSTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, (PSTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + TypeInfo->TypeId;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = (PWSTR) ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeResName, lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, ResName, lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, ResName, lParam)) {
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}


BOOL
EnumNeResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG lParam
    )
{
    return pEnumNeResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                FALSE           // ANSI enum proc
                );
}


BOOL
EnumNeResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG lParam
    )
{
    return pEnumNeResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                TRUE            // UNICODE enum proc
                );
}


BOOL
pEnumTypeForNameSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      LONG lParam,
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    PTYPESEARCHDATAA Data;

    Data = (PTYPESEARCHDATAA) lParam;

    //
    // Compare type
    //

    if (HIWORD (Data->TypeToFind) == 0) {
        if (Type != Data->TypeToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Type) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Type, Data->TypeToFind)) {
            return TRUE;
        }
    }

    //
    // Type found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->Found = TRUE;

    return FALSE;
}



BOOL
pEnumNeResourceNamesEx (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCEXA EnumFunc,
    IN      LONG lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    PNE_RES_NAMEINFO NameInfo;
    TYPESEARCHDATAA Data;
    WORD w;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESNAMEPROCA EnumFunc2 = (ENUMRESNAMEPROCA) EnumFunc;
    ENUMRESNAMEPROCEXW EnumFuncW = (ENUMRESNAMEPROCEXW) EnumFunc;
    ENUMRESNAMEPROCW EnumFunc2W = (ENUMRESNAMEPROCW) EnumFunc;
    PCWSTR UnicodeType = NULL;
    PCWSTR UnicodeResName = NULL;

    Type = pDecodeIdReferenceInString (Type);

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Locate type
    //

    ZeroMemory (&Data, sizeof (Data));

    Data.TypeToFind = Type;

    if (!pEnumNeResourceTypesEx (
            Handle,
            pEnumTypeForNameSearchProcA,
            (LONG) &Data,
            TRUE,           // ex functionality
            FALSE           // ANSI enum proc
            )) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    TypeInfo = Data.OutboundTypeInfo;

    if (UnicodeProc) {
        if (HIWORD (Type)) {
            UnicodeType = ConvertAtoW (Type);
        } else {
            UnicodeType = (PCWSTR) Type;
        }
    }

    //
    // Enumerate the resource names
    //

    NameInfo = TypeInfo->NameInfo;

    for (w = 0 ; w < TypeInfo->ResourceCount ; w++) {

        if (NameInfo->Id & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) (NameInfo->Id & 0x7fff), lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, (PSTR) (NameInfo->Id & 0x7fff), lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) (NameInfo->Id & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, (PSTR) (NameInfo->Id & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + NameInfo->Id;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, ResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, ResName, lParam)) {
                        break;
                    }
                }
            }

            if (UnicodeProc) {
                FreeConvertedStr (UnicodeResName);
            }
        }

        NameInfo++;
    }

    if (UnicodeProc) {
       DestroyUnicodeResourceId (UnicodeType);
    }

    return TRUE;
}


BOOL
EnumNeResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG lParam
    )
{
    return pEnumNeResourceNamesEx (
                Handle,
                Type,
                (ENUMRESNAMEPROCEXA) EnumFunc,
                lParam,
                FALSE,      // no ex functionality
                FALSE       // ANSI enum proc
                );
}


BOOL
EnumNeResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG lParam
    )
{
    BOOL b;
    PCSTR AnsiType;

    AnsiType = pConvertUnicodeResourceId (Type);

    b = pEnumNeResourceNamesEx (
            Handle,
            AnsiType,
            (ENUMRESNAMEPROCEXA) EnumFunc,
            lParam,
            FALSE,          // no ex functionality
            TRUE            // UNICODE enum proc
            );

    PushError();
    DestroyAnsiResourceId (AnsiType);
    PopError();

    return b;
}


BOOL
pEnumTypeForResSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam,
    IN      PNE_RES_TYPEINFO TypeInfo,
    IN      PNE_RES_NAMEINFO NameInfo
    )
{
    PNAMESEARCHDATAA Data;

    Data = (PNAMESEARCHDATAA) lParam;

    //
    // Compare name
    //

    if (HIWORD (Data->NameToFind) == 0) {
        if (Name != Data->NameToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Name) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Name, Data->NameToFind)) {
            return TRUE;
        }
    }

    //
    // Name found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->OutboundNameInfo = NameInfo;
    Data->Found = TRUE;

    return FALSE;
}


PBYTE
FindNeResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD Offset;
    DWORD Length;
    PNE_RES_NAMEINFO NameInfo;
    PBYTE ReturnData;

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return NULL;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pEnumNeResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    NameInfo = Data.OutboundNameInfo;

    Offset = (DWORD) NameInfo->Offset << (DWORD) NeHandle->Resources.AlignShift;
    Length = (DWORD) NameInfo->Length << (DWORD) NeHandle->Resources.AlignShift;

    ReturnData = PoolMemGetMemory (NeHandle->ResourcePool, Length);
    if (!ReturnData) {
        return NULL;
    }

    SetFilePointer (NeHandle->File, Offset, NULL, FILE_BEGIN);

    if (!ReadBinaryBlock (NeHandle->File, ReturnData, Length)) {
        PushError();
        MemFree (g_hHeap, 0, ReturnData);
        PopError();
        return NULL;
    }

    return ReturnData;
}


PBYTE
FindNeResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    PBYTE Resource;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Resource = FindNeResourceExA (
                    Handle,
                    AnsiType,
                    AnsiName
                    );

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Resource;
}



DWORD
SizeofNeResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;

    SetLastError (ERROR_SUCCESS);

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return 0;
    }

    //
    // Find resource
    //

    if (!pEnumNeResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    return Data.OutboundNameInfo->Length;
}


DWORD
SizeofNeResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    DWORD Size;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Size = SizeofNeResourceA (Handle, AnsiType, AnsiName);

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\persist.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    persist.c

Abstract:

    General structure persistence functions.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

--*/

#include "pch.h"
#include "persist.h"

BOOL MayExtraMemRequire(
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    FIELD_DESCRIPTION * FieldPtr;
    
    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(!FieldPtr->FieldDescription && FieldPtr->ArraySizeFieldOffset && FieldPtr->byValue){
            return TRUE;
        }
    }

    return FALSE;
}

UINT 
GetExtraMemRequirements(
    IN      BYTE * StructurePtr, 
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
/*
    This function provide additional memory requirements, 
    only in case when structure has variable size.
    And have to be declared by PERSIST_FIELD_BY_VALUE_NESTED_TYPE_CYCLE
    For example:
    struct VariableSizeStruct{
        ......
        UINT    uiNumberOfItem;
        ITEM    items[1];
    };
    PERSIST_FIELD_BY_VALUE_NESTED_TYPE_CYCLE(VariableSizeStruct, ITEM, items, uiNumberOfItem)
*/
{
    UINT Len;
    FIELD_DESCRIPTION * FieldPtr;
    UINT ExtraBytes = 0;
    UINT uiItemCount;

    MYASSERT(StructurePtr);
    
    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(!FieldPtr->FieldDescription && 
           FieldPtr->ArraySizeFieldOffset && 
           FieldPtr->byValue &&
           FieldPtr->Size){
            uiItemCount = *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset));
            ExtraBytes += uiItemCount? FieldPtr->Size * (uiItemCount - FieldPtr->InitialNumberOfItem): 0;
        }
    }

    return ExtraBytes;
}

BOOL 
SerializeStore(
    IN OUT  BYTE * BufferMain, 
    IN      BYTE * StructurePtr, 
    IN      PFIELD_DESCRIPTION FieldsDescription, 
    IN OUT  UINT * uiHowUsed
    )
{
    UINT i;
    UINT iLen;
    UINT Size = 0;
    BYTE * SubStruct;
    FIELD_DESCRIPTION * FieldPtr;
    
    if(!uiHowUsed){
        uiHowUsed = &Size;
    }

    MYASSERT(StructurePtr);

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription)
        {
            iLen = FieldPtr->ArraySizeFieldOffset? 
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)): 
                    1;

            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                MYASSERT(SubStruct);
            }
            else{
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                if(BufferMain){
                    *(BufferMain + *uiHowUsed) = (SubStruct && iLen);
                }
                ++*uiHowUsed;
                if(!SubStruct || !iLen){
                    continue;
                }
            }

            for(i = 0; i < iLen; 
                i++, SubStruct += FieldPtr->Size + GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription))
            {
                if(!SerializeStore(BufferMain, 
                                   SubStruct, 
                                   FieldPtr->FieldDescription, 
                                   uiHowUsed)){
                    MYASSERT(FALSE);
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr)
            {
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                if(!SubStruct){
                    SubStruct = (BYTE*)(FieldPtr->IsString == AnsiStr? "": (char*)L"");
                }

                if(FieldPtr->IsString == AnsiStr){
                    iLen = (strlen((PCSTR)SubStruct) + 1) * sizeof(CHAR);
                }
                else{
                    iLen = (wcslen((PWSTR)SubStruct) + 1) * sizeof(WCHAR);
                }

                if(BufferMain){
                    memcpy((BYTE *)(BufferMain + *uiHowUsed), SubStruct, iLen);
                }

                *uiHowUsed += iLen;
            }
            else
            {
                if(FieldPtr->Size)
                {
                    iLen = FieldPtr->ArraySizeFieldOffset? 
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)): 
                            1;
                    if(BufferMain){
                        memcpy((char *)(BufferMain + *uiHowUsed), 
                               GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset), 
                               iLen * FieldPtr->Size);
                    }
                    *uiHowUsed += iLen * FieldPtr->Size;
                }
            }
        }
    }

    return TRUE;
}

DWORD 
CalcSignature(
    IN      BYTE * BufferPtr, 
    IN      UINT Lenght
    )
{
    UINT i;
    UINT iLen = Lenght >> 2;
    UINT iRest = Lenght & 3;
    UINT uiSignature = 0;

    for(i = 0; i < iLen; i++){
        uiSignature ^= ((DWORD *)BufferPtr)[i];
    }
    
    if(iRest){
        uiSignature ^= (((DWORD *)BufferPtr)[iLen]) & (0xffffffff >> ((sizeof(DWORD) - iRest) << 3));
    }

    return uiSignature;
}

PersistResultsEnum 
PersistStore(
    OUT     BYTE ** BufferPtr, 
    OUT     UINT *Size, 
    IN      BYTE * StructurePtr, 
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    )
{
    BYTE * buffer = NULL;
    BYTE * memBlock = NULL;
    UINT uiBufferSize = 0;
    PPERSIST_HEADER pPersistHeader;
    PFIELD_DESCRIPTION FieldsDescription;
    PersistResultsEnum result = Persist_Success;

    if(!BufferPtr || !Size || !StructurePtr || !StructDefinitionPtr){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }
    
    FieldsDescription = StructDefinitionPtr->FieldDescriptions;
    if(!FieldsDescription){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }
    
    __try{
        uiBufferSize = sizeof(PERSIST_HEADER);
        if(!SerializeStore(NULL, StructurePtr, FieldsDescription, &uiBufferSize)){
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }

        memBlock = (BYTE *)MemAllocUninit(uiBufferSize);

        if(!memBlock){
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            MYASSERT(FALSE);
            return Persist_Fail;
        }
        
        buffer = memBlock;
        *BufferPtr = memBlock;
        *Size = uiBufferSize;
    
        pPersistHeader = (PPERSIST_HEADER)memBlock;
        buffer += sizeof(PERSIST_HEADER);
    
        pPersistHeader->dwVersion = StructDefinitionPtr->dwVersion;
        pPersistHeader->dwReserved = 0;

        uiBufferSize = 0;
        if(!SerializeStore(buffer, StructurePtr, FieldsDescription, &uiBufferSize)){
            FreeMem(memBlock);
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }
    
        pPersistHeader->dwSignature = CalcSignature(buffer, uiBufferSize);
    
        SetLastError(ERROR_SUCCESS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        if(memBlock){
            FreeMem(memBlock);
        }
        result = Persist_Fail;
        SetLastError(ERROR_ACCESS_DENIED);
    }


    return result;
}

BOOL 
SerializeLoad(
    IN      BYTE * BufferMain, 
    IN OUT  BYTE * StructurePtr, 
    IN      PFIELD_DESCRIPTION FieldsDescription, 
    IN OUT  UINT * uiHowUsed, 
    IN      BOOL   bRestoreOnlyByValue
    )
{
    FIELD_DESCRIPTION * FieldPtr;
    UINT i;
    UINT iLen;
    UINT Size = 0;
    BYTE * SubStruct;
    BYTE * OriginalBuffer;
    UINT sizeValue;
    UINT uiPrevValue;
    
    if(!uiHowUsed){
        uiHowUsed = &Size;
    }

    MYASSERT(StructurePtr);

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription)
        {
            iLen = FieldPtr->ArraySizeFieldOffset? 
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)): 
                    1;

            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }
            else{
                if(bRestoreOnlyByValue){
                    continue;
                }
                
                if(!*(BufferMain + (*uiHowUsed)++)){
                    *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(DWORD*, StructurePtr, FieldPtr->Offset) = 
                            (DWORD)NULL;
                    continue;
                }
                
                MYASSERT(FieldPtr->Size && iLen);

                sizeValue = FieldPtr->Size * iLen;

                SubStruct = (BYTE *)MemAllocUninit(sizeValue);
                if(!SubStruct){
                    return FALSE;
                }

                if(MayExtraMemRequire(FieldPtr->FieldDescription)){
                    OriginalBuffer = SubStruct;
                    uiPrevValue = *uiHowUsed;
                    for(i = 0; i < iLen; i++, SubStruct += FieldPtr->Size)
                    {
                        if(!SerializeLoad(BufferMain, 
                                          SubStruct, 
                                          FieldPtr->FieldDescription, 
                                          &uiPrevValue, 
                                          TRUE)){
                            return FALSE;
                        }
                        sizeValue += GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription);
                    }
                    FreeMem(OriginalBuffer);
                
                    SubStruct = (BYTE *)MemAllocZeroed(sizeValue);
                    if(!SubStruct){
                        return FALSE;
                    }
                }
                
                *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(DWORD*, StructurePtr, FieldPtr->Offset) = 
                        (DWORD)SubStruct;
            }

            for(i = 0; i < iLen; 
                i++, SubStruct += FieldPtr->Size + GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription))
            {
                if(!SerializeLoad(BufferMain, 
                                  SubStruct, 
                                  FieldPtr->FieldDescription, 
                                  uiHowUsed, 
                                  FALSE)){
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr){
                if(bRestoreOnlyByValue){
                    continue;
                }

                if(FieldPtr->IsString == AnsiStr){
                    iLen = strlen((char *)(BufferMain + *uiHowUsed)) + sizeof(CHAR);
                }
                else{
                    iLen = (wcslen((WCHAR *)(BufferMain + *uiHowUsed)) + 1) * sizeof(WCHAR);
                }
                MYASSERT(iLen);
                
                if(iLen != (FieldPtr->IsString == AnsiStr? sizeof(CHAR): sizeof(WCHAR)))
                {
                    SubStruct = (BYTE *)MemAllocUninit(iLen);
                    if(!SubStruct){
                        return FALSE;
                    }
                    memcpy((BYTE *)SubStruct, (BYTE *)(BufferMain + *uiHowUsed), iLen);
                }
                else{
                    SubStruct = NULL;
                }
                
                *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(DWORD *, StructurePtr, FieldPtr->Offset) = (DWORD)SubStruct;
                
                *uiHowUsed += iLen;
            }
            else
            {
                if(FieldPtr->Size)
                {
                    iLen = FieldPtr->ArraySizeFieldOffset? 
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)): 
                            1;
                    sizeValue = iLen * FieldPtr->Size;
                    if(iLen > 1 && bRestoreOnlyByValue){
                        continue;
                    }

                    memcpy(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset), 
                           (char *)(BufferMain + *uiHowUsed), 
                           sizeValue);
                    *uiHowUsed += sizeValue;
                }
            }
        }
    }

    return TRUE;
}

PersistResultsEnum 
PersistLoad(
    IN      BYTE * BufferPtr, 
    IN      UINT Size, 
    OUT     BYTE * StructurePtr, 
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    )
{
    UINT uiBufferSize = 0;
    PPERSIST_HEADER pPersistHeader;
    PFIELD_DESCRIPTION FieldsDescription;
    PersistResultsEnum result = Persist_Success;
    
    if(!BufferPtr || !Size || !StructurePtr || !StructDefinitionPtr){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }
    
    FieldsDescription = StructDefinitionPtr->FieldDescriptions;
    if(!FieldsDescription){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }

    __try{
        pPersistHeader = (PPERSIST_HEADER)BufferPtr;
        
        if(pPersistHeader->dwVersion != StructDefinitionPtr->dwVersion){
            SetLastError(ERROR_ACCESS_DENIED);
            MYASSERT(FALSE);
            return Persist_WrongVersion;
        }

        BufferPtr += sizeof(PERSIST_HEADER);
        Size -= sizeof(PERSIST_HEADER);
        if(pPersistHeader->dwSignature != CalcSignature(BufferPtr, Size)){
            SetLastError(ERROR_CRC);
            return Persist_WrongSignature;
        }

        uiBufferSize = 0;
        //Top structure cannot be variable size
        if(!SerializeLoad(BufferPtr, StructurePtr, FieldsDescription, &uiBufferSize, FALSE)){
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }

        SetLastError(ERROR_SUCCESS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        result = Persist_Fail;
        SetLastError(ERROR_ACCESS_DENIED);
    }

    return result;
}

VOID 
PersistReleaseMemory(
    IN      BYTE * StructurePtr, 
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    UINT i;
    UINT iLen;
    FIELD_DESCRIPTION * FieldPtr;
    BYTE * SubStruct;

    if(!StructurePtr || !FieldsDescription){
        return;
    }
    
    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription){
            iLen = FieldPtr->ArraySizeFieldOffset? 
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)): 
                    1;

            if(!iLen){
                continue;
            }
            
            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }
            else{
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }

            if(!SubStruct){
                continue;
            }

            for(i = 0; i < iLen; i++, SubStruct += FieldPtr->Size){
                PersistReleaseMemory(SubStruct, FieldPtr->FieldDescription);
            }
            
            if(!FieldPtr->byValue){
                FreeMem(GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset));
            }
        }
        else{
            if(FieldPtr->IsString != NoStr){
                SubStruct = (BYTE *)GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(PCSTR, StructurePtr, FieldPtr->Offset);
                if(SubStruct){
                    FreeMem(SubStruct);
                }
            }
        }
    }
}

BOOL 
CompareStructures(
    IN      BYTE * pStructure1, 
    IN      BYTE * pStructure2, 
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    UINT i;
    UINT iLen1;
    UINT iLen2;
    FIELD_DESCRIPTION * FieldPtr;
    BYTE * pSubStruct1;
    BYTE * pSubStruct2;

    if(!pStructure1 || !pStructure2 || !FieldsDescription){
        return FALSE;
    }
    
    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription){
            iLen1 = FieldPtr->ArraySizeFieldOffset? 
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure1, FieldPtr->ArraySizeFieldOffset)): 
                    1;
                    
            iLen2 = FieldPtr->ArraySizeFieldOffset? 
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure2, FieldPtr->ArraySizeFieldOffset)): 
                    1;
            
            if(iLen1 != iLen2){
                MYASSERT(FALSE);
                return FALSE;
            }
            
            if(!iLen1){
                continue;
            }
            
            if(FieldPtr->byValue){
                pSubStruct1 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
            }
            else{
                pSubStruct1 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
            }

            if(!pSubStruct1 || !pSubStruct2){
                if(pSubStruct1 != pSubStruct2){
                    MYASSERT(FALSE);
                    return FALSE;
                }
                continue;
            }

            for(i = 0; i < iLen1; 
                i++, 
                pSubStruct1 += FieldPtr->Size + GetExtraMemRequirements(pSubStruct1, FieldPtr->FieldDescription), 
                pSubStruct2 += FieldPtr->Size + GetExtraMemRequirements(pSubStruct2, FieldPtr->FieldDescription)){
                if(!CompareStructures(pSubStruct1, pSubStruct2, FieldPtr->FieldDescription)){
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr)
            {
                pSubStruct1 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
                if(!pSubStruct1 || !pSubStruct2){
                    if(pSubStruct1 != pSubStruct2){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                    continue;
                }
                    
                if(FieldPtr->IsString == AnsiStr){
                    if(strcmp((LPCSTR)pSubStruct1, (LPCSTR)pSubStruct1)){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                }
                else{
                    if(wcscmp((LPCWSTR)pSubStruct1, (LPCWSTR)pSubStruct1)){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                }
            }
            else{
                iLen1 = FieldPtr->ArraySizeFieldOffset? 
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure1, FieldPtr->ArraySizeFieldOffset)): 
                            1;
                iLen2 = FieldPtr->ArraySizeFieldOffset? 
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure2, FieldPtr->ArraySizeFieldOffset)): 
                            1;
                
                if(iLen1 != iLen2){
                    MYASSERT(FALSE);
                    return FALSE;
                }
                
                pSubStruct1 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
                if(memcmp(pSubStruct1, pSubStruct2, iLen1 * FieldPtr->Size)){
                    MYASSERT(FALSE);
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"
#include "migutilp.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif

#define DBG_POOLMEM "Poolmem"

// Tree Memory Allocation structure.


#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD                 Index;            // Tracks into RawMemory.
    DWORD                 Size;             // the size in bytes of RawMemory.
    PPOOLMEMORYBLOCK      NextBlock;        // A pointer to the next block in the pool chain.
    PPOOLMEMORYBLOCK      PrevBlock;        // A pointer to the prev block in the pool chain.
    DWORD                 UseCount;         // The number of allocations currently referring
                                            // to this block.
    PBYTE                 RawMemory;        // The actual bytes of allocable memory in this block.
};


typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD               DogTag;             // A signature to ensure validity.
    PALLOCATION         Next;               // The next allocation in the list.
    PALLOCATION         Prev;               // The previous allocation in the list.
#endif

    PPOOLMEMORYBLOCK    ParentBlock;        // A reference to the block from which this allocation
                                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;              // The active memory block in this pool.
    DWORD            MinimumBlockSize;      // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR             Name[MAX_POOL_NAME];
    DWORD            TotalAllocationRequestBytes;
    DWORD            MaxAllocationSize;
    DWORD            CurrentlyAllocatedMemory;
    DWORD            MaximumAllocatedMemory;
    DWORD            NumAllocationRequests;
    DWORD            NumFreeRequests;
    DWORD            NumBlockFrees;
    DWORD            NumBlockClears;
    DWORD            NumBlockAllocations;

    PALLOCATION      AllocationList;        // A linked list of all of the allocations active in the
                                            // pool.

    FREESTATE        FreeCalled;            // A state variable indicating that PoolMemReleaseMemory()
                                            // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;


#ifdef DEBUG

DWORD g_PoolMemDisplayed;
DWORD g_PoolMemNotDisplayed;



#endif

BOOL
pPoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD       Size
    )
/*++

Routine Description:

    pPoolMemAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PoolMemInitPool and PoolMemGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD               sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > poolHeader -> MinimumBlockSize) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = poolHeader -> MinimumBlockSize;
    }
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
        newBlock -> UseCount    = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader -> CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader -> MaximumAllocatedMemory    =
            max(poolHeader -> MaximumAllocatedMemory,poolHeader -> CurrentlyAllocatedMemory);

        poolHeader -> NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


POOLHANDLE
PoolMemInitPool (
    VOID
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid POOLHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> MinimumBlockSize = POOLMEMORYBLOCKSIZE;
        header -> PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header -> TotalAllocationRequestBytes   = 0;
        header -> MaxAllocationSize             = 0;
        header -> CurrentlyAllocatedMemory      = 0;
        header -> MaximumAllocatedMemory        = 0;
        header -> NumAllocationRequests         = 0;
        header -> NumFreeRequests               = 0;
        header -> NumBlockFrees                 = 0;
        header -> NumBlockClears                = 0;
        header -> NumBlockAllocations           = 0;
        header -> Name[0]                       = 0;


#endif
        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);
            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PoolMemNotDisplayed =  12;
        g_PoolMemDisplayed =     24;

        if (ableToAddMemory) {
            header -> AllocationList = NULL;
            header -> FreeCalled = FREE_NOT_CALLED;
        }
#endif

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

    return (POOLHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION      p,cur;

    if (PoolHeader -> FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader -> AllocationList;

    while (p) {

        cur = p;
        p = p -> Next;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader -> AllocationList = NULL;
#endif
}


VOID
PoolMemEmptyPool (
    IN      POOLHANDLE Handle
    )

/*++

Routine Description:

    PoolMemEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        poolHeader -> PoolHead -> UseCount = 0;
        poolHeader -> PoolHead -> Index = 0;

#ifdef DEBUG
        poolHeader -> NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

}



VOID
PoolMemSetMinimumGrowthSize (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid POOLHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader -> MinimumBlockSize = max(Size,0);
}


VOID
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
/*++

Routine Description:

    PoolMemDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid POOLHANDLE.

Return Value:

    None.

--*/
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree;
    PPOOLHEADER      poolHeader;


    MYASSERT(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader -> TotalAllocationRequestBytes)) / poolHeader -> NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader -> Name[0] ? poolHeader -> Name : TEXT("[Unnamed Pool]"),
            FloatWorkaround,
            poolHeader -> MaxAllocationSize,
            poolHeader -> CurrentlyAllocatedMemory,
            poolHeader -> MaximumAllocatedMemory,
            poolHeader -> NumAllocationRequests,
            poolHeader -> NumBlockAllocations,
            poolHeader -> NumFreeRequests,
            poolHeader -> NumBlockFrees,
            poolHeader -> NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }


    //
    // Free all allocations that have not yet been freed.
    //

    pDeregisterPoolAllocations(poolHeader);

#endif


    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;
        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    MemFree(g_hHeap,0,poolHeader);

}

PVOID
PoolMemRealGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size,
    IN DWORD      AlignSize /*,*/
    ALLOCATION_TRACKING_DEF
    )

/*++

Routine Description:

    PoolMemRealGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    (File) - The File from whence the call orignated. This is used for memory tracking and checking
             in the debug version.
    (Line) - The Line from whence the call orignated.

    Handle - A valid POOLHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    PALLOCATION         allocation;
    DWORD               sizeNeeded;
    DWORD               padLength;

    MYASSERT(poolHeader != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader -> PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader -> MaxAllocationSize =
            max(poolHeader -> MaxAllocationSize,Size);
        poolHeader -> NumAllocationRequests++;
        poolHeader -> TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader -> PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (DWORD) currentBlock + sizeof(POOLMEMORYBLOCK)
                    + currentBlock -> Index + sizeof(ALLOCATION);
                currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            (PBYTE) allocation = &(currentBlock -> RawMemory[currentBlock -> Index]);
            allocation -> ParentBlock = currentBlock;


#ifdef DEBUG

            //
            // Track this memory.
            //
            allocation -> DogTag = VALIDDOGTAG;
            allocation -> Next = poolHeader -> AllocationList;
            allocation -> Prev = NULL;

            if (poolHeader -> AllocationList) {
                poolHeader -> AllocationList -> Prev = allocation;
            }

            poolHeader -> AllocationList = allocation;

            if (poolHeader -> FreeCalled != WHO_CARES) {

                DebugRegisterAllocation(POOLMEM_POINTER, allocation, File, Line);

            }


#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock -> Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

    return rMemory;
}

VOID
PoolMemReleaseMemory (
    IN POOLHANDLE Handle,
    IN LPVOID     Memory
    )
/*++

Routine Description:

    PoolMemReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION         allocation;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterCriticalSection (&g_PoolMemCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader -> NumFreeRequests++;

#endif




#ifdef DEBUG

        if (poolHeader -> FreeCalled == FREE_NOT_CALLED) {
            poolHeader -> FreeCalled = FREE_CALLED;
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation -> DogTag != VALIDDOGTAG) {
            if (allocation -> DogTag == FREEDOGTAG) {
                DEBUGMSG((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);
            }

            __leave;

        } else {
            allocation -> DogTag = FREEDOGTAG;
        }

        if (allocation -> Next) {
            allocation -> Next -> Prev = allocation -> Prev;
        }

        if (poolHeader -> AllocationList == allocation) {
            poolHeader -> AllocationList = allocation -> Next;
        } else {

            allocation -> Prev -> Next = allocation -> Next;
        }


        if (poolHeader -> FreeCalled != WHO_CARES) {
            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation -> ParentBlock == NULL) {
            DEBUGMSG((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation -> ParentBlock -> UseCount--;




        if (allocation -> ParentBlock -> UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation -> ParentBlock != poolHeader -> PoolHead) {
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader -> NumBlockFrees++;
                poolHeader -> CurrentlyAllocatedMemory -=
                    allocation -> ParentBlock -> Size + sizeof(POOLMEMORYBLOCK);


#endif

                if (allocation -> ParentBlock -> NextBlock) {
                    allocation -> ParentBlock -> NextBlock -> PrevBlock =
                        allocation -> ParentBlock -> PrevBlock;
                }
                allocation -> ParentBlock -> PrevBlock -> NextBlock =
                    allocation -> ParentBlock -> NextBlock;
                MemFree(g_hHeap,0,allocation -> ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation -> ParentBlock -> Index = 0;
                allocation -> ParentBlock = NULL;

#ifdef DEBUG
                poolHeader -> NumBlockClears++;
#endif

            }
        }
        else {
            allocation -> ParentBlock = NULL;

        }

    } __finally {

        LeaveCriticalSection (&g_PoolMemCs);
    }

}


#ifdef DEBUG

POOLHANDLE
PoolMemInitNamedPool (
    IN      PCSTR Name
    )
{
    POOLHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = PoolMemInitPool();
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        _mbssafecpy (poolHeader->Name, Name, MAX_POOL_NAME);
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PoolMemDuplicateMultiSzA (
    IN POOLHANDLE    Handle,
    IN PCSTR         MultiSzToCopy
    )
{
    PSTR tmpString = (PSTR)MultiSzToCopy;
    DWORD size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (tmpString [0] != 0) {
        tmpString = GetEndOfStringA (tmpString) + 1;
    }
    size = tmpString - MultiSzToCopy + 1;
    tmpString = PoolMemGetAlignedMemory(Handle, size);
    memcpy (tmpString, MultiSzToCopy, size);

    return tmpString;
}

PWSTR
PoolMemDuplicateMultiSzW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        MultiSzToCopy
    )
{
    PWSTR tmpString = (PWSTR)MultiSzToCopy;
    DWORD size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (tmpString [0] != 0) {
        tmpString = GetEndOfStringW (tmpString) + 1;
    }
    size = (tmpString - MultiSzToCopy + 1) * sizeof(WCHAR);
    tmpString = PoolMemGetAlignedMemory(Handle, size);
    memcpy (tmpString, MultiSzToCopy, size);

    return tmpString;
}



#ifdef DEBUG

VOID
PoolMemDisableTracking (
    IN POOLHANDLE Handle
    )

/*++

Routine Description:

    PoolMemDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);

    poolHeader -> FreeCalled = WHO_CARES;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are three groups of APIs in this
    source file: query functions, open and create functions, and registry
    string parsing functions.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    jimschm     18-Sep-2000 Added cache
    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"
#include "regp.h"

#ifdef DEBUG
#undef RegCloseKey
#endif

HKEY g_Root = HKEY_ROOT;
REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;
INT g_RegRefs;

#define DBG_REG     "Reg"

//
// Implementation
//


BOOL
RegInitialize (
    VOID
    )
{
    BOOL b = TRUE;

    MYASSERT (g_RegRefs >= 0);

    g_RegRefs++;

    if (g_RegRefs == 1) {

        RegInitializeCache (0);
    }

    return b;
}


VOID
RegTerminate (
    VOID
    )
{
    MYASSERT (g_RegRefs > 0);

    g_RegRefs--;

    if (!g_RegRefs) {
        RegTerminateCache ();
    }

#ifdef DEBUG
    RegTrackTerminate();
#endif
}


VOID
SetRegRoot (
    IN      HKEY Root
    )
{
    g_Root = Root;
}

HKEY
GetRegRoot (
    VOID
    )
{
    return g_Root;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheA (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYA (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (RegKey, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGA ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyA (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerA (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheA (RegKey, lastWack);
    }

    return Key;
}


HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCWSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheW (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYW (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (RegKey, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGW ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyW (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerW (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheW (RegKey, lastWack);
    }

    return Key;
}

HKEY
RealOpenRegKeyStrW1 (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStrA (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyA (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyW (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyA (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyA (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyW (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyW (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteEmptyRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
MemFreeWrapper (
    IN      PCVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  FreeRoutine  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }


    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  AllocRoutine - Specifies the allocation routine, called to allocate the return data.

  FreeRoutine - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    switch (MustBeType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        if (Type == REG_SZ) {
            break;
        }
        if (Type == REG_EXPAND_SZ) {
            break;
        }
        return NULL;

    default:
        if (Type == MustBeType) {
            break;
        }
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (WORD));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWORD) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size = 0;

    rc = RegQueryValueExA (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  AllocRoutine  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  FreeRoutine   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyA (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2A (SubKeyHandle, "", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  AllocRoutine - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  FreeRoutine  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrA (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2A (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
pCreateRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExA (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerA (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_CreateSam);

    return result;
}

HKEY
pCreateRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerW (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_CreateSam);

    return result;
}

/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    CHAR RegKey[MAX_REGISTRY_KEYA];
    PCSTR Start;
    PCSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheA (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYA (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (NewKeyName, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyA (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyA (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = _mbschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringA (Start);
        }

        StringCopyABA (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) { //lint !e613
            rc = OurRegOpenKeyExA (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExA (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) { //lint !e613
            Start = _mbsinc (Start);
        }

    } while (*Start);   //lint !e613

    if (Parent) {
        RegAddKeyToCacheA (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheA (NewKeyName, lastWack);
    }

    return Parent;
}


HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_REGISTRY_KEYW];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCWSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheW (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYW (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (NewKeyName, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyW (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = OurRegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    if (Parent) {
        RegAddKeyToCacheW (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheW (NewKeyName, lastWack);
    }

    return Parent;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyExA (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerA (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_OpenSam);

    return result;
}


HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen           OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerW (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_OpenSam);

    return result;
}


LONG
CloseRegKeyWorker (
    IN      HKEY Key
    )
{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "RegCloseKey threw an exception!"));
    }

    MYASSERT (rc == ERROR_SUCCESS);

    return rc;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (RegDecrementRefCount (Key)) {
        //
        // Key is in the cache; don't call CloseRegKeyWorker. This will
        // be done by the cache code.
        //

        return ERROR_SUCCESS;
    }

    return CloseRegKeyWorker (Key);
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    UINT    TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKR",                     L"HKR",                     3, HKEY_ROOT,
    "HKEY_ROOT",               L"HKEY_ROOT",               9, HKEY_ROOT,
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringA (
    IN      PCSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    MBCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (StringIMatchCharCountA (
                RootString,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength
                )) {

            c = _mbsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != '\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = _wcsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    if (RootKey == g_Root) {
        return 1;
    }

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    HKEY Ret;

    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    Ret = g_RegRoots[i - 1].RootKey;
    if (Ret == HKEY_ROOT) {
        Ret = g_Root;
    }

    return Ret;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyA (
    PCSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringA (RegPath, LengthPtr));
}

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCSTR
ConvertKeyToRootStringA (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetA (GetOffsetOfRootKey (RegRoot));
}

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}



/*++

Routine Description:

  CreateEncodedRegistryStringEx is used to create a registry string in the format commonly
  expected by w95upg reg routines. This format is:

    EncodedKey\[EncodedValue]

  Encoding is used to safely represent "special" characters
    (such as MBS chars and certain punctuation marks.)

  The [EncodedValue] part will exist only if Value is non null.

Arguments:

    Key - Contains an unencoded registry key.
    Value - Optionally contains an unencoded registry value.
    Tree - Specifies that the registry key refers to the entire key

Return Value:

    Returns a pointer to the encoded registry string, or NULL if there was an error.

--*/

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    )
{
    PSTR    rEncodedString = NULL;
    DWORD   requiredSize;
    PSTR    end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringA(Key)*6 + (Value ? SizeOfStringA(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringA(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsA(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form. If a value does not exist,
    // then add an '*' to the line.
    //
    if (Value) {

        StringCopyA (AppendWackA (rEncodedString), "[");
        end = GetEndOfStringA (rEncodedString);
        EncodeRuleCharsA(end, Value);
        StringCatA(end, "]");

    } else if (Tree) {
        StringCopyA (AppendWackA (rEncodedString), "*");
    }

    return rEncodedString;
}


PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    )
{
    PWSTR   rEncodedString = NULL;
    DWORD   requiredSize;
    PWSTR   end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringW(Key)*6 + (Value ? SizeOfStringW(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringW(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsW(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form.
    // If a value doesn't exist, add na '*' to the line.
    //
    if (Value) {

        StringCopyW (AppendWackW (rEncodedString), L"[");
        end = GetEndOfStringW (rEncodedString);
        EncodeRuleCharsW(end, Value);
        StringCatW(end, L"]");
    } else if (Tree) {
        StringCopyW (AppendWackW (rEncodedString), L"*");
    }

    return rEncodedString;
}


/*++

Routine Description:

    FreeEncodedRegistryString frees the memory allocated by a call to CreateEncodedRegistryString.

Arguments:

    None.


Return Value:

    None.

--*/
VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    )
{
    FreePathStringA(RegString);
}


VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    )
{
    FreePathStringW(RegString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\regp.h ===
HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    );

HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
CloseRegKeyWorker (
    IN      HKEY Key
    );

#ifdef DEBUG

VOID
RegTrackTerminate (
    VOID
    );

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#define TRACK_KEYA(handle,keystr) AddKeyReferenceA(handle,keystr,__FILE__,__LINE__)
#define TRACK_KEYW(handle,keystr) AddKeyReferenceW(handle,keystr,__FILE__,__LINE__)

#else

#define TRACK_KEYA(handle,keystr)
#define TRACK_KEYW(handle,keystr)

#endif


//
// Cache apis
//

VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    );

HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    );

HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

BOOL
RegDecrementRefCount (
    IN      HKEY Key
    );

VOID
RegIncrementRefCount (
    IN      HKEY Key
    );

extern REGSAM g_OpenSam;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:


--*/


#include "pch.h"
#include "migutilp.h"
#include "regp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = GROWLIST_INIT;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    AddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\regenum.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    regenum.c

Abstract:

    Implements utilties to enumerate the registry.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    <alias> <date> <comment>

--*/

#include "pch.h"
#include "regp.h"

#define DBG_REG     "Reg"

//
// Private prototypes
//

BOOL
pPopRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr
    );

BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    );

/*++

Routine Description:

  EnumFirstRegKeyA and EnumFirstRegKeyW begin an enumeration of registry
  subkeys.  They initialize the registy enumeration structure and
  call the registry APIs to enumerate subkeys of the specified key handle.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  Key       - Specifies the handle of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegKeyA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKeyA (EnumPtr);
}


BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKeyW (EnumPtr);
}


/*++

Routine Description:

  EnumFirstRegKeyStrA and EnumFirstRegKeyStrW start an enumeration of
  subkeys within the given key.  In these functions, the key is specified
  via a string instead of an HKEY value.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  RegKey    - Specifies the full path of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
RealEnumFirstRegKeyStrA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStrA (RegKey /* , */ DEBUG_TRACKING_ARGS);

    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKeyA (EnumPtr, Key);
    if (!b) {
        CloseRegKey (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


BOOL
RealEnumFirstRegKeyStrW (
    IN      PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStrW (RegKey /* , */ DEBUG_TRACKING_ARGS);
    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKeyW (EnumPtr, Key);
    if (!b) {
        CloseRegKey (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


/*++

Routine Description:

  AbortRegKeyEnumA and AbortRegKeyEnumW release all resources associated
  with a registry subkey enumeration.  Call this function to stop the
  enumeration before it completes by itself.

Arguments:

  EnumPtr   - Specifies the enumeration to stop.  Receives the updated
              state of enumeration.

Return Value:


  none

--*/

VOID
AbortRegKeyEnumA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


/*++

Routine Description:

  EnumNextRegKeyA and EnumNextRegKeyW continue an enumeration started by
  one of the subkey enumeration routines above.  If all items have been
  enumerated, this function cleans up all resources and returns FALSE.

Arguments:

  EnumPtr   - Specifies the enumeration to continue.  Receives the updated
              state of enumeration.  The structure can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegKeyA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    LONG rc;

    rc = RegEnumKeyA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYA
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    LONG rc;

    rc = RegEnumKeyW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYW
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
pPushRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr,
    IN      PCSTR KeyName
    )
{
    PREGKEYINFOA RetVal;
    PSTR p;

    RetVal = (PREGKEYINFOA) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOA)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOA));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyA (p, "\\");
        EnumPtr->FullKeyNameBytes += ByteCountA (p);
        p = _mbsinc (p);
    }

    _mbssafecpy (p, KeyName, MAX_REGISTRY_KEYA - EnumPtr->FullKeyNameBytes);
    EnumPtr->FullKeyNameBytes += ByteCountA (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _mbssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYA);
    RetVal->KeyHandle = OpenRegKeyStrA (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfoA (EnumPtr);
        return FALSE;
    }

    return TRUE;
}


BOOL
pPushRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR KeyName
    )
{
    PREGKEYINFOW RetVal;
    PWSTR p;

    RetVal = (PREGKEYINFOW) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOW)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOW));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyW (p, L"\\");
        EnumPtr->FullKeyNameBytes += ByteCountW (p);
        p++;
    }

    _wcssafecpy (p, KeyName, MAX_REGISTRY_KEYW - (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)));
    EnumPtr->FullKeyNameBytes += ByteCountW (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _wcssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYW);
    RetVal->KeyHandle = OpenRegKeyStrW (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfoW (EnumPtr);
        return FALSE;
    }

    return TRUE;
}



BOOL
pPopRegKeyInfoA (
    IN      PREGTREE_ENUMA EnumPtr
    )
{
    PREGKEYINFOA FreeMe;
    PSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey (FreeMe->KeyHandle);
    }

    AbortRegKeyEnumA (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    )
{
    PREGKEYINFOW FreeMe;
    PWSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey (FreeMe->KeyHandle);
    }

    AbortRegKeyEnumW (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
RealEnumFirstRegKeyInTreeA (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMA));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTreeA");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfoA (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REG, "EnumFirstRegKeyInTreeA failed to push base key"));
        AbortRegKeyTreeEnumA (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountA (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMW));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTreeW");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfoW (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REG, "EnumFirstRegKeyInTreeW failed to push base key"));
        AbortRegKeyTreeEnumW (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountW (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumNextRegKeyInTreeA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    for (;;) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKeyA (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKeyA (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfoA (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnumA (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfoA (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGA ((
                    DBG_REG,
                    "RealEnumNextRegKeyInTreeA failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (CHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    for (;;) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKeyW (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKeyW (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfoW (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnumW (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfoW (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGW ((
                    DBG_REG,
                    "RealEnumNextRegKeyInTreeW failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (WCHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


VOID
AbortRegKeyTreeEnumA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfoA (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}


VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfoW (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}



/*++

Routine Description:

  EnumFirstRegValueA and EnumerateFirstRegvalueW enumerate the first registry
  value name in the specified subkey.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  hKey      - Specifies handle of registry subkey to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegValueA (
    IN      PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValueA (EnumPtr);
}


BOOL
EnumFirstRegValueW (
    IN      PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValueW (EnumPtr);
}


/*++

Routine Description:

  EnumNextRegValueA and EnumNextRegValueW continue the enumeration started
  by EnumFirstRegValueA/W.  The enumeration structure is updated to
  reflect the next value name in the subkey being enumerated.

Arguments:

  EnumPtr   - Specifies the registry subkey and enumeration position.
              Receives the updated state of enumeration.  The structure
              can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegValueA (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEA;

    rc = RegEnumValueA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEW;

    rc = RegEnumValueW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


/*++

Routine Description:

  DecodeRegistryString turns an encoded string back into a key, value name
  and tree flag.

  The caller must pass in buffers at least as big as MAX_REGISTRY_KEY and
  MAX_REGISTRY_VALUE_NAME.

Arguments:

  RegString - Specifies the encoded registry string that contains a key name,
              and an optional value name or tree flag.
  KeyBuf    - Receives the key name
  ValueBuf  - Receives the value name
  TreeFlag  - Receives the tree flag, TRUE if the encoded string indicates a
              registry key tree, FALSE otherwise.

Return Value:

  TRUE if the encoded string contained a value, FALSE if it contained just a
  key or key tree.

--*/

BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    )
{
    CHAR TempKeyBuf[MAX_REGISTRY_KEY];
    PSTR End;
    CHAR TempValueNameBuf[MAX_REGISTRY_VALUE_NAME];
    BOOL TempTreeFlag = FALSE;
    MBCHAR ch;
    PSTR p;
    BOOL b = FALSE;

    //
    // Walk through encoded string, pulling out key name
    //

    TempKeyBuf[0] = 0;
    TempValueNameBuf[0] = 0;

    End = TempKeyBuf + ARRAYSIZE(TempKeyBuf) - 2;
    p = TempKeyBuf;

    while (*RegString && *RegString != '*' && *RegString != '[') {
        ch = GetNextRuleCharA (&RegString, NULL);

        *((PWORD) p) = (WORD)ch;
        p = _mbsinc (p);

        if (p >= End) {
            RegString = GetEndOfStringA (RegString);
            break;
        }
    }

    *p = 0;
    p = (PSTR) SkipSpaceRA (TempKeyBuf, p);
    *(_mbsinc (p)) = 0;

    if (*RegString == '*' && _mbsnextc (p) == '\\') {
        //
        // If a tree, stop here
        //

        TempTreeFlag = TRUE;
        *p = 0;

    } else if (*RegString == '[') {
        //
        // If a value name, parse it
        //

        RegString++;

        End = TempValueNameBuf + ARRAYSIZE(TempValueNameBuf) - 2;
        p = TempValueNameBuf;

        while (*RegString && *RegString != ']') {

            ch = GetNextRuleCharA (&RegString, NULL);

            *((PWORD) p) = (WORD)ch;
            p = _mbsinc (p);

            if (p >= End) {
                RegString = GetEndOfStringA (RegString);
                break;
            }
        }

        *p = 0;
        p = (PSTR) SkipSpaceRA (TempValueNameBuf, p);
        if (p) // Guard against empty or all-whitespace value name.
            *(p + 1) = 0;

        RemoveWackAtEndA (TempKeyBuf);

        b = TRUE;
    }

    if (KeyBuf) {
        StringCopyA (KeyBuf, TempKeyBuf);
    }

    if (ValueBuf) {
        StringCopyA (ValueBuf, TempValueNameBuf);
    }

    if (TreeFlag) {
        *TreeFlag = TempTreeFlag;
    }

    return b;
}


BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    )
{
    WCHAR TempKeyBuf[MAX_REGISTRY_KEY];
    PWSTR End;
    WCHAR TempValueNameBuf[MAX_REGISTRY_VALUE_NAME];
    BOOL TempTreeFlag = FALSE;
    WCHAR ch;
    PWSTR p;
    BOOL b = FALSE;

    //
    // Walk through encoded string, pulling out key name
    //

    TempKeyBuf[0] = 0;
    TempValueNameBuf[0] = 0;

    End = TempKeyBuf + ARRAYSIZE(TempKeyBuf) - 2;
    p = TempKeyBuf;

    while (*RegString && *RegString != L'*' && *RegString != L'[') {
        ch = GetNextRuleCharW (&RegString, NULL);

        *((PWORD) p) = ch;
        p++;

        if (p >= End) {
            RegString = GetEndOfStringW (RegString);
            break;
        }
    }

    *p = 0;
    p = (PWSTR) SkipSpaceRW (TempKeyBuf, p);
    if (!p) {
        return FALSE;
    }
    *(p + 1) = 0;

    if (*RegString == L'*' && *p == L'\\') {
        //
        // If a tree, stop here
        //

        TempTreeFlag = TRUE;
        *p = 0;

    } else if (*RegString == L'[') {
        //
        // If a value name, parse it
        //

        RegString++;

        End = TempValueNameBuf + ARRAYSIZE(TempValueNameBuf) - 2;
        p = TempValueNameBuf;

        while (*RegString && *RegString != L']') {

            ch = GetNextRuleCharW (&RegString, NULL);

            *((PWORD) p) = ch;
            p++;

            if (p >= End) {
                RegString = GetEndOfStringW (RegString);
                break;
            }
        }

        *p = 0;
        p = (PWSTR) SkipSpaceRW (TempValueNameBuf, p);
        if (p) { // Guard against empty or all-whitespace value name.
            *(p + 1) = 0;
        }

        RemoveWackAtEndW (TempKeyBuf);

        b = TRUE;
    }

    if (KeyBuf) {
        StringCopyW (KeyBuf, TempKeyBuf);
    }

    if (ValueBuf) {
        StringCopyW (ValueBuf, TempValueNameBuf);
    }

    if (TreeFlag) {
        *TreeFlag = TempTreeFlag;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\safemode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    recovery.c

Abstract:

    A number of utilities for safe/recovery mode

Author:

    Calin Negreanu (calinn)   6-Aug-1999

Revisions:

--*/


#include "pch.h"

BOOL g_SafeModeInitialized = FALSE;
BOOL g_SafeModeActive = FALSE;
PCSTR g_SafeModeFileA = NULL;
PCWSTR g_SafeModeFileW = NULL;
HANDLE g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
HASHTABLE g_SafeModeCrashTable = NULL;
BOOL g_ExceptionOccured = FALSE;

typedef struct {
    ULONG Signature;
    ULONG NumCrashes;
} SAFEMODE_HEADER, *PSAFEMODE_HEADER;

typedef struct {
    ULONG CrashId;
    ULONG CrashStrSize;
} CRASHDATA_HEADER, *PCRASHDATA_HEADER;

typedef struct _SAFEMODE_NODE {
    DWORD FilePtr;
    struct _SAFEMODE_NODE *Next;
} SAFEMODE_NODE, *PSAFEMODE_NODE;

PSAFEMODE_NODE g_SafeModeLastNode = NULL;
PSAFEMODE_NODE g_SafeModeCurrentNode = NULL;

POOLHANDLE g_SafeModePool = NULL;

#define SAFE_MODE_SIGNATURE     0x45464153


/*++

Routine Description:

  pGenerateCrashString generates a crash string given an identifier and a string
  The generated string will look like <Id>-<String>

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  A pointer to a crash string allocated from g_SafeModePool
  The caller must free the memory by calling PoolMemReleaseMemory

--*/

PCSTR
pGenerateCrashStringA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    CHAR idStr [sizeof (ULONG) * 2 + 1];
    _ultoa (Id, idStr, 16);
    return JoinTextExA (g_SafeModePool, idStr, String, "-", 0, NULL);
}

PCWSTR
pGenerateCrashStringW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    WCHAR idStr [sizeof (ULONG) * 2 + 1];
    _ultow (Id, idStr, 16);
    return JoinTextExW (g_SafeModePool, idStr, String, L"-", 0, NULL);
}



/*++

Routine Description:

  pSafeModeOpenAndResetFile opens the safe mode file looking for
  crash strings stored here. It will also reset the part that is
  dealing with nested calls by extracting the inner most crash string
  stored there.

Arguments:

  None

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
pSafeModeOpenAndResetFileA (
    VOID
    )
{
    SAFEMODE_HEADER header;
    CRASHDATA_HEADER crashData;
    DWORD lastFilePtr;
    DWORD noBytes;
    PSTR crashString = NULL;
    PSTR lastCrashString = NULL;
    ULONG lastCrashId;
    PCSTR completeCrashString;

    //
    // Open the existing safe mode file or create a
    // new one.
    //
    g_SafeModeFileHandle = CreateFileA (
                                g_SafeModeFileA,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                                );
    if (g_SafeModeFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Let's try to read our header. If signature does
        // match we will try to read extra data.
        //

        if (ReadFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                ) &&
            (noBytes == sizeof (SAFEMODE_HEADER)) &&
            (header.Signature == SAFE_MODE_SIGNATURE)
            ) {

            //
            // we know now we had an valid safe mode file. Enter safe mode.
            //

            g_SafeModeActive = TRUE;

            LOGA ((LOG_ERROR, "Setup detected a crash on the previous upgrade attempt. Setup is running in safe mode."));
            LOGA ((LOG_WARNING, "Setup has run in safe mode %d time(s).", header.NumCrashes));

            //
            // we need to initialize safe mode crash table
            //
            g_SafeModeCrashTable = HtAllocA ();

            //
            // Now, let's read all crash data, a ULONG and a string at a time
            //

            lastFilePtr = SetFilePointer (
                                g_SafeModeFileHandle,
                                0,
                                NULL,
                                FILE_CURRENT
                                );

            while (TRUE) {

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        &crashData,
                        sizeof (CRASHDATA_HEADER),
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != sizeof (CRASHDATA_HEADER))
                    ) {
                    break;
                }

                if ((crashData.CrashId == 0) &&
                    (crashData.CrashStrSize == 0)
                    ) {

                    //
                    // we crashed inside a nested guard. We need to
                    // extract the inner guard we crashed in.
                    //

                    lastCrashId = 0;
                    lastCrashString = NULL;

                    while (TRUE) {
                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                &crashData,
                                sizeof (CRASHDATA_HEADER),
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != sizeof (CRASHDATA_HEADER))
                            ) {
                            crashData.CrashId = 0;
                            break;
                        }

                        crashString = AllocPathStringA (crashData.CrashStrSize);

                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                crashString,
                                crashData.CrashStrSize,
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != crashData.CrashStrSize)
                            ) {
                            crashData.CrashId = 0;
                            FreePathStringA (crashString);
                            break;
                        }

                        if (lastCrashString) {
                            FreePathStringA (lastCrashString);
                        }

                        lastCrashId = crashData.CrashId;
                        lastCrashString = crashString;

                    }

                    if (lastCrashId && lastCrashString) {

                        //
                        // we found the inner guard we crashed in. Let's put this into
                        // the right place.
                        //

                        SetFilePointer (
                            g_SafeModeFileHandle,
                            lastFilePtr,
                            NULL,
                            FILE_BEGIN
                            );

                        crashData.CrashId = lastCrashId;
                        crashData.CrashStrSize = SizeOfStringA (lastCrashString);

                        WriteFile (
                            g_SafeModeFileHandle,
                            &crashData,
                            sizeof (CRASHDATA_HEADER),
                            &noBytes,
                            NULL
                            );

                        WriteFile (
                            g_SafeModeFileHandle,
                            lastCrashString,
                            crashData.CrashStrSize,
                            &noBytes,
                            NULL
                            );

                        //
                        // store this information in Safe Mode crash table
                        //
                        completeCrashString = pGenerateCrashStringA (crashData.CrashId, crashString);
                        HtAddStringA (g_SafeModeCrashTable, completeCrashString);
                        PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                        LOGA ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                        lastFilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

                        FreePathStringA (lastCrashString);
                    }
                    break;
                }

                crashString = AllocPathStringA (crashData.CrashStrSize);

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        crashString,
                        crashData.CrashStrSize,
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != crashData.CrashStrSize)
                    ) {
                    break;
                }

                //
                // store this information in Safe Mode crash table
                //
                completeCrashString = pGenerateCrashStringA (crashData.CrashId, crashString);
                HtAddStringA (g_SafeModeCrashTable, completeCrashString);
                PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                LOGA ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                lastFilePtr = SetFilePointer (
                                    g_SafeModeFileHandle,
                                    0,
                                    NULL,
                                    FILE_CURRENT
                                    );
            }

            //
            // Write how many times we ran in safe mode
            //

            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes += 1;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            SetFilePointer (
                g_SafeModeFileHandle,
                lastFilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );

        } else {

            //
            // Reset the file
            //
            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes = 0;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );
        }

        //
        // Flush the file
        //

        FlushFileBuffers (g_SafeModeFileHandle);

        //
        // initialize the nested list
        //

        g_SafeModeLastNode = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));
        g_SafeModeCurrentNode = g_SafeModeLastNode->Next = g_SafeModeLastNode;
        g_SafeModeLastNode->FilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

        return TRUE;

    }
    return FALSE;
}

BOOL
pSafeModeOpenAndResetFileW (
    VOID
    )
{
    SAFEMODE_HEADER header;
    CRASHDATA_HEADER crashData;
    DWORD lastFilePtr;
    DWORD noBytes;
    PWSTR crashString = NULL;
    PWSTR lastCrashString = NULL;
    ULONG lastCrashId;
    PCWSTR completeCrashString;

    //
    // Open the existing safe mode file or create a
    // new one.
    //
    g_SafeModeFileHandle = CreateFileW (
                                g_SafeModeFileW,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                                );
    if (g_SafeModeFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Let's try to read our header. If signature does
        // match we will try to read extra data.
        //

        if (ReadFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                ) &&
            (noBytes == sizeof (SAFEMODE_HEADER)) &&
            (header.Signature == SAFE_MODE_SIGNATURE)
            ) {

            //
            // we know now we had an valid safe mode file. Enter safe mode.
            //

            g_SafeModeActive = TRUE;

            LOGW ((LOG_ERROR, "Setup detected a crash on the previous upgrade attempt. Setup is running in safe mode."));
            LOGW ((LOG_WARNING, "Setup has run in safe mode %d time(s).", header.NumCrashes));

            //
            // we need to initialize safe mode crash table
            //
            g_SafeModeCrashTable = HtAllocW ();

            //
            // Now, let's read all crash data, a ULONG and a string at a time
            //

            lastFilePtr = SetFilePointer (
                                g_SafeModeFileHandle,
                                0,
                                NULL,
                                FILE_CURRENT
                                );

            while (TRUE) {

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        &crashData,
                        sizeof (CRASHDATA_HEADER),
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != sizeof (CRASHDATA_HEADER))
                    ) {
                    break;
                }

                if ((crashData.CrashId == 0) &&
                    (crashData.CrashStrSize == 0)
                    ) {

                    //
                    // we crashed inside a nested guard. We need to
                    // extract the inner guard we crashed in.
                    //

                    lastCrashId = 0;
                    lastCrashString = NULL;

                    while (TRUE) {
                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                &crashData,
                                sizeof (CRASHDATA_HEADER),
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != sizeof (CRASHDATA_HEADER))
                            ) {
                            crashData.CrashId = 0;
                            break;
                        }

                        crashString = AllocPathStringW (crashData.CrashStrSize);

                        if (!ReadFile (
                                g_SafeModeFileHandle,
                                crashString,
                                crashData.CrashStrSize,
                                &noBytes,
                                NULL
                                ) ||
                            (noBytes != crashData.CrashStrSize)
                            ) {
                            crashData.CrashId = 0;
                            FreePathStringW (crashString);
                            break;
                        }

                        if (lastCrashString) {
                            FreePathStringW (lastCrashString);
                        }

                        lastCrashId = crashData.CrashId;
                        lastCrashString = crashString;

                    }

                    if (lastCrashId && lastCrashString) {

                        //
                        // we found the inner guard we crashed in. Let's put this into
                        // the right place.
                        //

                        SetFilePointer (
                            g_SafeModeFileHandle,
                            lastFilePtr,
                            NULL,
                            FILE_BEGIN
                            );

                        crashData.CrashId = lastCrashId;
                        crashData.CrashStrSize = SizeOfStringW (lastCrashString);

                        WriteFile (
                            g_SafeModeFileHandle,
                            &crashData,
                            sizeof (CRASHDATA_HEADER),
                            &noBytes,
                            NULL
                            );

                        WriteFile (
                            g_SafeModeFileHandle,
                            lastCrashString,
                            crashData.CrashStrSize,
                            &noBytes,
                            NULL
                            );

                        //
                        // store this information in Safe Mode crash table
                        //
                        completeCrashString = pGenerateCrashStringW (crashData.CrashId, crashString);
                        HtAddStringW (g_SafeModeCrashTable, completeCrashString);
                        PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                        LOGW ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                        lastFilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

                        FreePathStringW (lastCrashString);
                    }
                    break;
                }

                crashString = AllocPathStringW (crashData.CrashStrSize);

                if (!ReadFile (
                        g_SafeModeFileHandle,
                        crashString,
                        crashData.CrashStrSize,
                        &noBytes,
                        NULL
                        ) ||
                    (noBytes != crashData.CrashStrSize)
                    ) {
                    break;
                }

                //
                // store this information in Safe Mode crash table
                //
                completeCrashString = pGenerateCrashStringW (crashData.CrashId, crashString);
                HtAddStringW (g_SafeModeCrashTable, completeCrashString);
                PoolMemReleaseMemory (g_SafeModePool, (PVOID)completeCrashString);

                LOGW ((LOG_WARNING, "Safe mode information: 0x%08X, %s", crashData.CrashId, crashString));

                lastFilePtr = SetFilePointer (
                                    g_SafeModeFileHandle,
                                    0,
                                    NULL,
                                    FILE_CURRENT
                                    );
            }

            //
            // Write how many times we ran in safe mode
            //

            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes += 1;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            SetFilePointer (
                g_SafeModeFileHandle,
                lastFilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );

        } else {

            //
            // Reset the file
            //
            SetFilePointer (
                g_SafeModeFileHandle,
                0,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);

            header.Signature = SAFE_MODE_SIGNATURE;
            header.NumCrashes = 0;

            //
            // Write safe mode header
            //

            WriteFile (
                g_SafeModeFileHandle,
                &header,
                sizeof (SAFEMODE_HEADER),
                &noBytes,
                NULL
                );

            //
            // Write a null crash data header as an indicator
            // that we start recording nested actions
            //

            crashData.CrashId = 0;
            crashData.CrashStrSize = 0;

            WriteFile (
                g_SafeModeFileHandle,
                &crashData,
                sizeof (CRASHDATA_HEADER),
                &noBytes,
                NULL
                );
        }

        //
        // Flush the file
        //

        FlushFileBuffers (g_SafeModeFileHandle);

        //
        // initialize the nested list
        //

        g_SafeModeLastNode = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));
        g_SafeModeCurrentNode = g_SafeModeLastNode->Next = g_SafeModeLastNode;
        g_SafeModeLastNode->FilePtr = SetFilePointer (
                                            g_SafeModeFileHandle,
                                            0,
                                            NULL,
                                            FILE_CURRENT
                                            );

        return TRUE;

    }
    return FALSE;
}



/*++

Routine Description:

  SafeModeInitialize is called to initialize safe mode. The result of this
  function will be to either have safe mode active (if forced or if a crash
  was detected) or not. If safe mode is not active all other call are almost
  noop.

Arguments:

  Forced    - if this is TRUE, safe mode will be forced to be active

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeInitializeA (
    BOOL Forced
    )
{
    CHAR winDir[MAX_MBCHAR_PATH];

    g_ExceptionOccured = FALSE;

    if (GetWindowsDirectoryA (winDir, MAX_MBCHAR_PATH)) {

        g_SafeModePool = PoolMemInitNamedPool ("SafeMode Pool");

        g_SafeModeFileA = JoinPathsA (winDir, S_SAFE_MODE_FILEA);

        //
        // we are going to open the existing safe mode file
        // or to create a new one
        //
        if (pSafeModeOpenAndResetFileA ()) {

            if (Forced) {
                g_SafeModeActive = TRUE;

                if (g_SafeModeCrashTable == NULL) {
                    //
                    // we need to initialize safe mode crash table
                    //
                    g_SafeModeCrashTable = HtAllocA ();
                }
            }
            g_SafeModeInitialized = TRUE;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SafeModeInitializeW (
    BOOL Forced
    )
{
    WCHAR winDir[MAX_WCHAR_PATH];

    g_ExceptionOccured = FALSE;

    if (GetWindowsDirectoryW (winDir, MAX_WCHAR_PATH)) {

        g_SafeModePool = PoolMemInitNamedPool ("SafeMode Pool");

        g_SafeModeFileW = JoinPathsW (winDir, S_SAFE_MODE_FILEW);

        //
        // we are going to open the existing safe mode file
        // or to create a new one
        //
        if (pSafeModeOpenAndResetFileW ()) {

            if (Forced) {
                g_SafeModeActive = TRUE;

                if (g_SafeModeCrashTable == NULL) {
                    //
                    // we need to initialize safe mode crash table
                    //
                    g_SafeModeCrashTable = HtAllocA ();
                }
            }
            g_SafeModeInitialized = TRUE;
            return TRUE;
        }
    }
    return FALSE;
}



/*++

Routine Description:

  SafeModeShutDown is called to clean all data used by safe mode. It will remove
  safe mode file, release all used memory, reset all globals. Subsequent calls
  to safe mode functions after this will be noops.

Arguments:

  NONE

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeShutDownA (
    VOID
    )
{

    if (g_SafeModeInitialized) {

        //
        // Close and delete safe mode file.
        // Reset all globals.
        //
#ifdef DEBUG
        if (g_SafeModeLastNode != g_SafeModeCurrentNode) {
            DEBUGMSGA ((DBG_ERROR, "SafeMode: Unregistered action detected"));
        }
#endif


        if (!g_ExceptionOccured) {
            CloseHandle (g_SafeModeFileHandle);
            g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
            DeleteFileA (g_SafeModeFileA);
        }
        ELSE_DEBUGMSGA ((DBG_WARNING, "SafeModeShutDown called after exception. Files will not be cleaned up."));

        FreePathStringA (g_SafeModeFileA);
        g_SafeModeFileA = NULL;
        HtFree (g_SafeModeCrashTable);
        g_SafeModeCrashTable = NULL;
        g_SafeModeActive = FALSE;
        g_SafeModeInitialized = FALSE;
    }
    if (g_SafeModePool != NULL) {
        PoolMemDestroyPool (g_SafeModePool);
        g_SafeModePool = NULL;
    }
    return TRUE;
}

BOOL
SafeModeShutDownW (
    VOID
    )
{



    if (g_SafeModeInitialized) {

        //
        // Close and delete safe mode file.
        // Reset all globals.
        //
#ifdef DEBUG
        if (g_SafeModeLastNode != g_SafeModeCurrentNode) {
            DEBUGMSGW ((DBG_ERROR, "SafeMode: Unregistered action detected"));
        }
#endif

        if (!g_ExceptionOccured) {

            CloseHandle (g_SafeModeFileHandle);
            g_SafeModeFileHandle = INVALID_HANDLE_VALUE;
            DeleteFileW (g_SafeModeFileW);
        }
        ELSE_DEBUGMSGW ((DBG_WARNING, "SafeModeShutDown called after exception. Files will not be cleaned up."));


        FreePathStringW (g_SafeModeFileW);
        g_SafeModeFileW = NULL;
        HtFree (g_SafeModeCrashTable);
        g_SafeModeCrashTable = NULL;
        g_SafeModeActive = FALSE;
        g_SafeModeInitialized = FALSE;
    }
    if (g_SafeModePool != NULL) {
        PoolMemDestroyPool (g_SafeModePool);
        g_SafeModePool = NULL;
    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeRegisterAction is called when we want to guard a specific part of
  the code. The caller should pass an guard ID and a guard string (used to
  uniquely identify the portion of code beeing guarded.

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeRegisterActionA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    DWORD noBytes;
    CRASHDATA_HEADER crashData;
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        SetFilePointer (
            g_SafeModeFileHandle,
            g_SafeModeCurrentNode->FilePtr,
            NULL,
            FILE_BEGIN
            );

        SetEndOfFile (g_SafeModeFileHandle);

        crashData.CrashId = Id;
        crashData.CrashStrSize = SizeOfStringA (String);

        WriteFile (
            g_SafeModeFileHandle,
            &crashData,
            sizeof (CRASHDATA_HEADER),
            &noBytes,
            NULL
            );

        WriteFile (
            g_SafeModeFileHandle,
            String,
            crashData.CrashStrSize,
            &noBytes,
            NULL
            );

        FlushFileBuffers (g_SafeModeFileHandle);

        node = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));

        node->Next = g_SafeModeCurrentNode;

        node->FilePtr = SetFilePointer (
                            g_SafeModeFileHandle,
                            0,
                            NULL,
                            FILE_CURRENT
                            );

        g_SafeModeCurrentNode = node;

    }
    return TRUE;
}

BOOL
SafeModeRegisterActionW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    DWORD noBytes;
    CRASHDATA_HEADER crashData;
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        SetFilePointer (
            g_SafeModeFileHandle,
            g_SafeModeCurrentNode->FilePtr,
            NULL,
            FILE_BEGIN
            );

        SetEndOfFile (g_SafeModeFileHandle);

        crashData.CrashId = Id;
        crashData.CrashStrSize = SizeOfStringW (String);

        WriteFile (
            g_SafeModeFileHandle,
            &crashData,
            sizeof (CRASHDATA_HEADER),
            &noBytes,
            NULL
            );

        WriteFile (
            g_SafeModeFileHandle,
            String,
            crashData.CrashStrSize,
            &noBytes,
            NULL
            );

        FlushFileBuffers (g_SafeModeFileHandle);

        node = (PSAFEMODE_NODE) PoolMemGetMemory (g_SafeModePool, sizeof (SAFEMODE_NODE));

        node->Next = g_SafeModeCurrentNode;

        node->FilePtr = SetFilePointer (
                            g_SafeModeFileHandle,
                            0,
                            NULL,
                            FILE_CURRENT
                            );

        g_SafeModeCurrentNode = node;

    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeUnregisterAction is called when we want end the guard set for
  a specific part of the code. Since we allow nested guards, calling this
  function at the end of the guarded code is neccessary. The function will
  unregister the last registered guard.

Arguments:

  NONE

Return Value:

  TRUE if the function completed successfully, FALSE otherwise

--*/

BOOL
SafeModeUnregisterActionA (
    VOID
    )
{
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        if (g_SafeModeCurrentNode != g_SafeModeLastNode) {

            node = g_SafeModeCurrentNode;

            g_SafeModeCurrentNode = g_SafeModeCurrentNode->Next;

            PoolMemReleaseMemory (g_SafeModePool, node);

            SetFilePointer (
                g_SafeModeFileHandle,
                g_SafeModeCurrentNode->FilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);
        }
#ifdef DEBUG
        else {
            DEBUGMSGA ((DBG_ERROR, "SafeMode: Too many actions unregistered."));
        }
#endif
    }
    return TRUE;
}

BOOL
SafeModeUnregisterActionW (
    VOID
    )
{
    PSAFEMODE_NODE node;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        if (g_SafeModeCurrentNode != g_SafeModeLastNode) {

            node = g_SafeModeCurrentNode;

            g_SafeModeCurrentNode = g_SafeModeCurrentNode->Next;

            PoolMemReleaseMemory (g_SafeModePool, node);

            SetFilePointer (
                g_SafeModeFileHandle,
                g_SafeModeCurrentNode->FilePtr,
                NULL,
                FILE_BEGIN
                );

            SetEndOfFile (g_SafeModeFileHandle);
        }
#ifdef DEBUG
        else {
            DEBUGMSGW ((DBG_ERROR, "SafeMode: Too many actions unregistered."));
        }
#endif
    }
    return TRUE;
}



/*++

Routine Description:

  SafeModeActionCrashed will return TRUE if one of the previous crashes
  was detected in the code guarded by these arguments.

Arguments:

  Id        - Safe mode identifier

  String    - Safe mode string

Return Value:

  TRUE if one of the previous crashes occured in the code guarded by the
  arguments, FALSE otherwise

--*/

BOOL
SafeModeActionCrashedA (
    IN      ULONG Id,
    IN      PCSTR String
    )
{
    PCSTR crashString;
    BOOL result = FALSE;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        crashString = pGenerateCrashStringA (Id, String);
        result = crashString && (HtFindStringA (g_SafeModeCrashTable, crashString));
        PoolMemReleaseMemory (g_SafeModePool, (PVOID)crashString);
#ifdef DEBUG
        {
            UINT infId;

            infId = GetPrivateProfileIntA ("SafeMode", String, SAFEMODEID_FIRST, g_DebugInfPathA);
            result = result || (infId == Id);
        }
#endif
    }
    return result;
}

BOOL
SafeModeActionCrashedW (
    IN      ULONG Id,
    IN      PCWSTR String
    )
{
    PCWSTR crashString;
    BOOL result = FALSE;

    if (g_SafeModeInitialized && g_SafeModeActive) {

        crashString = pGenerateCrashStringW (Id, String);
        result = crashString && (HtFindStringW (g_SafeModeCrashTable, crashString));
        PoolMemReleaseMemory (g_SafeModePool, (PVOID)crashString);
#ifdef DEBUG
        {
            UINT infId;

            infId = GetPrivateProfileIntW (L"SafeMode", String, SAFEMODEID_FIRST, g_DebugInfPathW);
            result = result || (infId == Id);
        }
#endif
    }
    return result;
}



/*++

Routine Description:

  SafeModeExceptionOccured is called by exception handlers to let Safemode
  know that something unexpected happened.

Arguments:

  None.

Return Value:



--*/


VOID
SafeModeExceptionOccured (
    VOID
    )
{
    g_ExceptionOccured = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\shappmgrp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for shappmgrp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shappmgrp_h__
#define __shappmgrp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IADCCtl_FWD_DEFINED__
#define __IADCCtl_FWD_DEFINED__
typedef interface IADCCtl IADCCtl;
#endif    /* __IADCCtl_FWD_DEFINED__ */


#ifndef __ADCCtl_FWD_DEFINED__
#define __ADCCtl_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADCCtl ADCCtl;
#else
typedef struct ADCCtl ADCCtl;
#endif /* __cplusplus */

#endif    /* __ADCCtl_FWD_DEFINED__ */


#ifndef __IInstalledApp_FWD_DEFINED__
#define __IInstalledApp_FWD_DEFINED__
typedef interface IInstalledApp IInstalledApp;
#endif    /* __IInstalledApp_FWD_DEFINED__ */


#ifndef __IEnumInstalledApps_FWD_DEFINED__
#define __IEnumInstalledApps_FWD_DEFINED__
typedef interface IEnumInstalledApps IEnumInstalledApps;
#endif    /* __IEnumInstalledApps_FWD_DEFINED__ */


#ifndef __EnumInstalledApps_FWD_DEFINED__
#define __EnumInstalledApps_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInstalledApps EnumInstalledApps;
#else
typedef struct EnumInstalledApps EnumInstalledApps;
#endif /* __cplusplus */

#endif    /* __EnumInstalledApps_FWD_DEFINED__ */


#ifndef __IShellAppManager_FWD_DEFINED__
#define __IShellAppManager_FWD_DEFINED__
typedef interface IShellAppManager IShellAppManager;
#endif    /* __IShellAppManager_FWD_DEFINED__ */


#ifndef __ShellAppManager_FWD_DEFINED__
#define __ShellAppManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellAppManager ShellAppManager;
#else
typedef struct ShellAppManager ShellAppManager;
#endif /* __cplusplus */

#endif    /* __ShellAppManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "shappmgr.h"

#ifdef __cplusplus
extern "C"{
#endif

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * );

/* interface __MIDL_itf_shappmgrp_0000 */
/* [local] */

#ifndef _SHAPPMGRP_H_
#define _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_s_ifspec;


#ifndef __SHAPPMGRPLib_LIBRARY_DEFINED__
#define __SHAPPMGRPLib_LIBRARY_DEFINED__

/* library SHAPPMGRPLib */
/* [version][lcid][helpstring][uuid] */


EXTERN_C const IID LIBID_SHAPPMGRPLib;

#ifndef __IADCCtl_INTERFACE_DEFINED__
#define __IADCCtl_INTERFACE_DEFINED__

/* interface IADCCtl */
/* [dual][object][oleautomation][unique][helpstring][uuid] */


EXTERN_C const IID IID_IADCCtl;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3964D99F-AC96-11D1-9851-00C04FD91972")
    IADCCtl : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dirty(
            /* [in] */ VARIANT_BOOL bDirty) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dirty(
            /* [retval][out] */ VARIANT_BOOL *pbDirty) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Category(
            /* [in] */ BSTR bstrCategory) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Category(
            /* [retval][out] */ BSTR *pbstrCategory) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Sort(
            /* [in] */ BSTR bstrSortExpr) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Sort(
            /* [retval][out] */ BSTR *pbstrSortExpr) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Forcex86(
            /* [in] */ VARIANT_BOOL bForce) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Forcex86(
            /* [retval][out] */ VARIANT_BOOL *pbForce) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowPostSetup(
            /* [retval][out] */ VARIANT_BOOL *pbShow) = 0;

        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDomain(
            /* [in] */ VARIANT_BOOL bOnDomain) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OnDomain(
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain) = 0;

        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCategory(
            /* [retval][out] */ BSTR *pbstrCategory) = 0;

        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE msDataSourceObject(
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk) = 0;

        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE addDataSourceListener(
            /* [in] */ IUnknown *pEvent) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset(
            BSTR bstrQualifier) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsRestricted(
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted) = 0;

        virtual HRESULT STDMETHODCALLTYPE Exec(
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord) = 0;

    };

#else   /* C style interface */

    typedef struct IADCCtlVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IADCCtl * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IADCCtl * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IADCCtl * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IADCCtl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IADCCtl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dirty )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bDirty);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbDirty);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )(
            IADCCtl * This,
            /* [in] */ BSTR bstrCategory);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sort )(
            IADCCtl * This,
            /* [in] */ BSTR bstrSortExpr);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sort )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrSortExpr);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Forcex86 )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bForce);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forcex86 )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbForce);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPostSetup )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbShow);

        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDomain )(
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bOnDomain);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OnDomain )(
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain);

        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultCategory )(
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);

        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *msDataSourceObject )(
            IADCCtl * This,
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk);

        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *addDataSourceListener )(
            IADCCtl * This,
            /* [in] */ IUnknown *pEvent);

        HRESULT ( STDMETHODCALLTYPE *Reset )(
            IADCCtl * This,
            BSTR bstrQualifier);

        HRESULT ( STDMETHODCALLTYPE *IsRestricted )(
            IADCCtl * This,
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted);

        HRESULT ( STDMETHODCALLTYPE *Exec )(
            IADCCtl * This,
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord);

        END_INTERFACE
    } IADCCtlVtbl;

    interface IADCCtl
    {
        CONST_VTBL struct IADCCtlVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IADCCtl_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADCCtl_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IADCCtl_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IADCCtl_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADCCtl_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADCCtl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADCCtl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADCCtl_put_Dirty(This,bDirty)  \
    (This)->lpVtbl -> put_Dirty(This,bDirty)

#define IADCCtl_get_Dirty(This,pbDirty)   \
    (This)->lpVtbl -> get_Dirty(This,pbDirty)

#define IADCCtl_put_Category(This,bstrCategory)   \
    (This)->lpVtbl -> put_Category(This,bstrCategory)

#define IADCCtl_get_Category(This,pbstrCategory)    \
    (This)->lpVtbl -> get_Category(This,pbstrCategory)

#define IADCCtl_put_Sort(This,bstrSortExpr)   \
    (This)->lpVtbl -> put_Sort(This,bstrSortExpr)

#define IADCCtl_get_Sort(This,pbstrSortExpr)    \
    (This)->lpVtbl -> get_Sort(This,pbstrSortExpr)

#define IADCCtl_put_Forcex86(This,bForce) \
    (This)->lpVtbl -> put_Forcex86(This,bForce)

#define IADCCtl_get_Forcex86(This,pbForce)  \
    (This)->lpVtbl -> get_Forcex86(This,pbForce)

#define IADCCtl_get_ShowPostSetup(This,pbShow)  \
    (This)->lpVtbl -> get_ShowPostSetup(This,pbShow)

#define IADCCtl_put_OnDomain(This,bOnDomain)    \
    (This)->lpVtbl -> put_OnDomain(This,bOnDomain)

#define IADCCtl_get_OnDomain(This,pbOnDomain) \
    (This)->lpVtbl -> get_OnDomain(This,pbOnDomain)

#define IADCCtl_get_DefaultCategory(This,pbstrCategory)   \
    (This)->lpVtbl -> get_DefaultCategory(This,pbstrCategory)

#define IADCCtl_msDataSourceObject(This,qualifier,ppUnk)    \
    (This)->lpVtbl -> msDataSourceObject(This,qualifier,ppUnk)

#define IADCCtl_addDataSourceListener(This,pEvent)  \
    (This)->lpVtbl -> addDataSourceListener(This,pEvent)

#define IADCCtl_Reset(This,bstrQualifier) \
    (This)->lpVtbl -> Reset(This,bstrQualifier)

#define IADCCtl_IsRestricted(This,bstrPolicy,pbRestricted)  \
    (This)->lpVtbl -> IsRestricted(This,bstrPolicy,pbRestricted)

#define IADCCtl_Exec(This,bstrQualifier,bstrCmd,nRecord)    \
    (This)->lpVtbl -> Exec(This,bstrQualifier,bstrCmd,nRecord)

#endif /* COBJMACROS */


#endif    /* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Dirty_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bDirty);


void __RPC_STUB IADCCtl_put_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Dirty_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbDirty);


void __RPC_STUB IADCCtl_get_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Category_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrCategory);


void __RPC_STUB IADCCtl_put_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Category_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Sort_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrSortExpr);


void __RPC_STUB IADCCtl_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Sort_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrSortExpr);


void __RPC_STUB IADCCtl_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Forcex86_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bForce);


void __RPC_STUB IADCCtl_put_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Forcex86_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbForce);


void __RPC_STUB IADCCtl_get_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_ShowPostSetup_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbShow);


void __RPC_STUB IADCCtl_get_ShowPostSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_OnDomain_Proxy(
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bOnDomain);


void __RPC_STUB IADCCtl_put_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_OnDomain_Proxy(
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbOnDomain);


void __RPC_STUB IADCCtl_get_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_DefaultCategory_Proxy(
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_DefaultCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_msDataSourceObject_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR qualifier,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IADCCtl_msDataSourceObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_addDataSourceListener_Proxy(
    IADCCtl * This,
    /* [in] */ IUnknown *pEvent);


void __RPC_STUB IADCCtl_addDataSourceListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Reset_Proxy(
    IADCCtl * This,
    BSTR bstrQualifier);


void __RPC_STUB IADCCtl_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_IsRestricted_Proxy(
    IADCCtl * This,
    /* [in] */ BSTR bstrPolicy,
    /* [retval][out] */ VARIANT_BOOL *pbRestricted);


void __RPC_STUB IADCCtl_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Exec_Proxy(
    IADCCtl * This,
    BSTR bstrQualifier,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ LONG nRecord);


void __RPC_STUB IADCCtl_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IADCCtl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ADCCtl;

#ifdef __cplusplus

class DECLSPEC_UUID("3964D9A0-AC96-11D1-9851-00C04FD91972")
ADCCtl;
#endif

#ifndef __IInstalledApp_INTERFACE_DEFINED__
#define __IInstalledApp_INTERFACE_DEFINED__

/* interface IInstalledApp */
/* [object][helpstring][uuid] */


EXTERN_C const IID IID_IInstalledApp;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1BC752DF-9046-11D1-B8B3-006008059382")
    IInstalledApp : public IShellApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Uninstall(
            HWND hwnd) = 0;

        virtual HRESULT STDMETHODCALLTYPE Modify(
            HWND hwndParent) = 0;

        virtual HRESULT STDMETHODCALLTYPE Repair(
            /* [in] */ BOOL bReinstall) = 0;

        virtual HRESULT STDMETHODCALLTYPE Upgrade( void) = 0;

    };

#else   /* C style interface */

    typedef struct IInstalledAppVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IInstalledApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IInstalledApp * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IInstalledApp * This);

        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )(
            IInstalledApp * This,
            /* [out][in] */ PAPPINFODATA pai);

        HRESULT ( STDMETHODCALLTYPE *GetPossibleActions )(
            IInstalledApp * This,
            /* [out] */ DWORD *pdwActions);

        HRESULT ( STDMETHODCALLTYPE *GetSlowAppInfo )(
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);

        HRESULT ( STDMETHODCALLTYPE *GetCachedSlowAppInfo )(
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);

        HRESULT ( STDMETHODCALLTYPE *IsInstalled )(
            IInstalledApp * This);

        HRESULT ( STDMETHODCALLTYPE *Uninstall )(
            IInstalledApp * This,
            HWND hwnd);

        HRESULT ( STDMETHODCALLTYPE *Modify )(
            IInstalledApp * This,
            HWND hwndParent);

        HRESULT ( STDMETHODCALLTYPE *Repair )(
            IInstalledApp * This,
            /* [in] */ BOOL bReinstall);

        HRESULT ( STDMETHODCALLTYPE *Upgrade )(
            IInstalledApp * This);

        END_INTERFACE
    } IInstalledAppVtbl;

    interface IInstalledApp
    {
        CONST_VTBL struct IInstalledAppVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IInstalledApp_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstalledApp_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInstalledApp_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IInstalledApp_GetAppInfo(This,pai)  \
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IInstalledApp_GetPossibleActions(This,pdwActions) \
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IInstalledApp_GetSlowAppInfo(This,psaid)    \
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IInstalledApp_GetCachedSlowAppInfo(This,psaid)  \
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IInstalledApp_IsInstalled(This)   \
    (This)->lpVtbl -> IsInstalled(This)


#define IInstalledApp_Uninstall(This,hwnd)  \
    (This)->lpVtbl -> Uninstall(This,hwnd)

#define IInstalledApp_Modify(This,hwndParent) \
    (This)->lpVtbl -> Modify(This,hwndParent)

#define IInstalledApp_Repair(This,bReinstall) \
    (This)->lpVtbl -> Repair(This,bReinstall)

#define IInstalledApp_Upgrade(This)   \
    (This)->lpVtbl -> Upgrade(This)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IInstalledApp_Uninstall_Proxy(
    IInstalledApp * This,
    HWND hwnd);


void __RPC_STUB IInstalledApp_Uninstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Modify_Proxy(
    IInstalledApp * This,
    HWND hwndParent);


void __RPC_STUB IInstalledApp_Modify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Repair_Proxy(
    IInstalledApp * This,
    /* [in] */ BOOL bReinstall);


void __RPC_STUB IInstalledApp_Repair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Upgrade_Proxy(
    IInstalledApp * This);


void __RPC_STUB IInstalledApp_Upgrade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IInstalledApp_INTERFACE_DEFINED__ */


#ifndef __IEnumInstalledApps_INTERFACE_DEFINED__
#define __IEnumInstalledApps_INTERFACE_DEFINED__

/* interface IEnumInstalledApps */
/* [object][helpstring][uuid] */


EXTERN_C const IID IID_IEnumInstalledApps;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1BC752E1-9046-11D1-B8B3-006008059382")
    IEnumInstalledApps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [out] */ IInstalledApp **pia) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumInstalledAppsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEnumInstalledApps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEnumInstalledApps * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEnumInstalledApps * This);

        HRESULT ( STDMETHODCALLTYPE *Next )(
            IEnumInstalledApps * This,
            /* [out] */ IInstalledApp **pia);

        HRESULT ( STDMETHODCALLTYPE *Reset )(
            IEnumInstalledApps * This);

        END_INTERFACE
    } IEnumInstalledAppsVtbl;

    interface IEnumInstalledApps
    {
        CONST_VTBL struct IEnumInstalledAppsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumInstalledApps_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInstalledApps_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumInstalledApps_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumInstalledApps_Next(This,pia) \
    (This)->lpVtbl -> Next(This,pia)

#define IEnumInstalledApps_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Next_Proxy(
    IEnumInstalledApps * This,
    /* [out] */ IInstalledApp **pia);


void __RPC_STUB IEnumInstalledApps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Reset_Proxy(
    IEnumInstalledApps * This);


void __RPC_STUB IEnumInstalledApps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IEnumInstalledApps_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_EnumInstalledApps;

#ifdef __cplusplus

class DECLSPEC_UUID("0B124F8F-91F0-11D1-B8B5-006008059382")
EnumInstalledApps;
#endif

#ifndef __IShellAppManager_INTERFACE_DEFINED__
#define __IShellAppManager_INTERFACE_DEFINED__

/* interface IShellAppManager */
/* [object][helpstring][uuid] */

typedef struct _ShellAppCategory
    {
    LPWSTR pszCategory;
    UINT idCategory;
    }   SHELLAPPCATEGORY;

typedef struct _ShellAppCategory *PSHELLAPPCATEGORY;

typedef struct _ShellAppCategoryList
    {
    UINT cCategories;
    SHELLAPPCATEGORY *pCategory;
    }   SHELLAPPCATEGORYLIST;

typedef struct _ShellAppCategoryList *PSHELLAPPCATEGORYLIST;


EXTERN_C const IID IID_IShellAppManager;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("352EC2B8-8B9A-11D1-B8AE-006008059382")
    IShellAppManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberofInstalledApps(
            DWORD *pdwResult) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumInstalledApps(
            IEnumInstalledApps **peia) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPublishedAppCategories(
            PSHELLAPPCATEGORYLIST pCategoryList) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumPublishedApps(
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa) = 0;

        virtual HRESULT STDMETHODCALLTYPE InstallFromFloppyOrCDROM(
            HWND hwndParent) = 0;

    };

#else   /* C style interface */

    typedef struct IShellAppManagerVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IShellAppManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IShellAppManager * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IShellAppManager * This);

        HRESULT ( STDMETHODCALLTYPE *GetNumberofInstalledApps )(
            IShellAppManager * This,
            DWORD *pdwResult);

        HRESULT ( STDMETHODCALLTYPE *EnumInstalledApps )(
            IShellAppManager * This,
            IEnumInstalledApps **peia);

        HRESULT ( STDMETHODCALLTYPE *GetPublishedAppCategories )(
            IShellAppManager * This,
            PSHELLAPPCATEGORYLIST pCategoryList);

        HRESULT ( STDMETHODCALLTYPE *EnumPublishedApps )(
            IShellAppManager * This,
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa);

        HRESULT ( STDMETHODCALLTYPE *InstallFromFloppyOrCDROM )(
            IShellAppManager * This,
            HWND hwndParent);

        END_INTERFACE
    } IShellAppManagerVtbl;

    interface IShellAppManager
    {
        CONST_VTBL struct IShellAppManagerVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IShellAppManager_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellAppManager_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IShellAppManager_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IShellAppManager_GetNumberofInstalledApps(This,pdwResult) \
    (This)->lpVtbl -> GetNumberofInstalledApps(This,pdwResult)

#define IShellAppManager_EnumInstalledApps(This,peia) \
    (This)->lpVtbl -> EnumInstalledApps(This,peia)

#define IShellAppManager_GetPublishedAppCategories(This,pCategoryList)  \
    (This)->lpVtbl -> GetPublishedAppCategories(This,pCategoryList)

#define IShellAppManager_EnumPublishedApps(This,pszCategory,ppepa)  \
    (This)->lpVtbl -> EnumPublishedApps(This,pszCategory,ppepa)

#define IShellAppManager_InstallFromFloppyOrCDROM(This,hwndParent)  \
    (This)->lpVtbl -> InstallFromFloppyOrCDROM(This,hwndParent)

#endif /* COBJMACROS */


#endif    /* C style interface */



HRESULT STDMETHODCALLTYPE IShellAppManager_GetNumberofInstalledApps_Proxy(
    IShellAppManager * This,
    DWORD *pdwResult);


void __RPC_STUB IShellAppManager_GetNumberofInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumInstalledApps_Proxy(
    IShellAppManager * This,
    IEnumInstalledApps **peia);


void __RPC_STUB IShellAppManager_EnumInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_GetPublishedAppCategories_Proxy(
    IShellAppManager * This,
    PSHELLAPPCATEGORYLIST pCategoryList);


void __RPC_STUB IShellAppManager_GetPublishedAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumPublishedApps_Proxy(
    IShellAppManager * This,
    LPCWSTR pszCategory,
    IEnumPublishedApps **ppepa);


void __RPC_STUB IShellAppManager_EnumPublishedApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_InstallFromFloppyOrCDROM_Proxy(
    IShellAppManager * This,
    HWND hwndParent);


void __RPC_STUB IShellAppManager_InstallFromFloppyOrCDROM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif    /* __IShellAppManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellAppManager;

#ifdef __cplusplus

class DECLSPEC_UUID("352EC2B7-8B9A-11D1-B8AE-006008059382")
ShellAppManager;
#endif
#endif /* __SHAPPMGRPLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shappmgrp_0257 */
/* [local] */

#endif // _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\strmap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm)   05-Jun-2000     Added multi table capability

    Jim Schmidt (jimschm)   08-May-2000     Improved replacement routines and
                                            added consistent filtering and
                                            extra data option

    Jim Schmidt (jimschm)   18-Aug-1998     Redesigned to fix two bugs, made
                                            A & W versions

--*/

//
// Includes
//

#include "pch.h"

//
// Strings
//

// None

//
// Constants
//

#define CHARNODE_SINGLE_BYTE            0x0000
#define CHARNODE_DOUBLE_BYTE            0x0001
#define CHARNODE_REQUIRE_WACK_OR_NUL    0x0002

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilters,
    IN      BOOL UsesExtraData
    )

/*++

Routine Description:

  CreateStringMapping allocates a string mapping data structure and
  initializes it. Callers can enable filter callbacks, extra data support, or
  both. The mapping structure contains either CHARNODE elements, or
  CHARNODEEX elements, depending on the UsesFilters or UsesExtraData flag.

Arguments:

  UsesFilters   - Specifies TRUE to enable filter callbacks. If enabled,
                  those who add string pairs must specify the filter callback
                  (each search/replace pair has its own callback)
  UsesExtraData - Specifies TRUE to associate extra data with the string
                  mapping pair.

Return Value:

  A handle to the string mapping structure, or NULL if a structure could not
  be created.

--*/

{
    POOLHANDLE Pool;
    PMAPSTRUCT Map;

    Pool = PoolMemInitNamedPool ("String Mapping");
    MYASSERT (Pool);

    Map = (PMAPSTRUCT) PoolMemGetAlignedMemory (Pool, sizeof (MAPSTRUCT));
    MYASSERT (Map);

    ZeroMemory (Map, sizeof (MAPSTRUCT));
    Map->Pool = Pool;

    Map->UsesExNode = UsesFilters|UsesExtraData;
    Map->UsesFilter = UsesFilters;
    Map->UsesExtraData = UsesExtraData;

    return Map;
}

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    )
{
    if (Map) {
        PoolMemEmptyPool (Map->Pool);
        PoolMemDestroyPool (Map->Pool);
        // Map is no longer valid
    }
}

PCHARNODE
pFindCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char
    )
{
    PCHARNODE Node;

    if (!PrevNode) {
        Node = Map->FirstLevelRoot;
    } else {
        Node = PrevNode->NextLevel;
    }

    while (Node) {
        if (Node->Char == Char) {
            return Node;
        }
        Node = Node->NextPeer;
    }

    return NULL;
}

PCHARNODE
pAddCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char,
    IN      WORD Flags
    )
{
    PCHARNODE Node;
    PCHARNODEEX exNode;

    if (Map->UsesExNode) {
        exNode = PoolMemGetAlignedMemory (Map->Pool, sizeof (CHARNODEEX));
        Node = (PCHARNODE) exNode;
        MYASSERT (Node);
        ZeroMemory (exNode, sizeof (CHARNODEEX));
    } else {
        Node = PoolMemGetAlignedMemory (Map->Pool, sizeof (CHARNODE));
        MYASSERT (Node);
        ZeroMemory (Node, sizeof (CHARNODE));
    }

    Node->Char = Char;
    Node->Flags = Flags;

    if (PrevNode) {
        Node->NextPeer = PrevNode->NextLevel;
        PrevNode->NextLevel = Node;
    } else {
        Node->NextPeer = Map->FirstLevelRoot;
        Map->FirstLevelRoot = Node;
    }

    return Node;
}


VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PSTR OldCopy;
    PSTR NewCopy;
    PCSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PoolMemDuplicateStringA (Map->Pool, Old);
    NewCopy = PoolMemDuplicateStringA (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerA (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    for (Prev = NULL, p = OldCopy ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);
        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;
    }

    for ( ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);

        nodeFlags |= (WORD) (IsLeadByte (*p) ? CHARNODE_DOUBLE_BYTE : CHARNODE_SINGLE_BYTE);
        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
    }

    if (Prev) {
        StringCopyA (OldCopy, Old);
        Prev->OriginalStr = (PVOID) OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountA (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PWSTR OldCopy;
    PWSTR NewCopy;
    PCWSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PoolMemDuplicateStringW (Map->Pool, Old);
    NewCopy = PoolMemDuplicateStringW (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerW (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    Prev = NULL;
    p = OldCopy;
    while (w = *p) {        // intentional assignment optimization

        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;

        p++;
    }

    while (w = *p) {        // intentional assignment optimization

        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
        p++;
    }

    if (Prev) {
        StringCopyW (OldCopy, Old);
        Prev->OriginalStr = OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountW (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


PCSTR
pFindReplacementStringInOneMapA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    WORD Char;
    PCSTR OrgSource;
    PCSTR newString;
    INT newStringSizeInBytes;
    PCHARNODEEX exNode;
    BOOL replacementFound;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Char = (WORD) _mbsnextc (Source);

        Node = pFindCharNode (Map, Node, Char);

        if (Node) {
            //
            // Advance string pointer
            //

            if (Node->Flags & CHARNODE_DOUBLE_BYTE) {
                Source += 2;
            } else {
                Source++;
            }

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && _mbsnextc (Source) != '\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Ansi.BeginningOfMatch = OrgSource;
                        Data->Ansi.OldSubString = (PCSTR) Node->OriginalStr;
                        Data->Ansi.NewSubString = newString;
                        Data->Ansi.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Ansi.NewSubString;
                            newStringSizeInBytes = Data->Ansi.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {
        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCSTR
pFindReplacementStringA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapA (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


PCWSTR
pFindReplacementStringInOneMapW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    PCWSTR OrgSource;
    PCWSTR newString;
    INT newStringSizeInBytes;
    BOOL replacementFound;
    PCHARNODEEX exNode;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Node = pFindCharNode (Map, Node, *Source);

        if (Node) {
            //
            // Advance string pointer
            //

            Source++;

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && *Source != L'\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCWSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Unicode.BeginningOfMatch = OrgSource;
                        Data->Unicode.OldSubString = (PCWSTR) Node->OriginalStr;
                        Data->Unicode.NewSubString = newString;
                        Data->Unicode.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Unicode.NewSubString;
                            newStringSizeInBytes = Data->Unicode.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {

        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCWSTR
pFindReplacementStringW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCWSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapW (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )

/*++

Routine Description:

  MappingSearchAndReplaceEx performs a search/replace operation based on the
  specified string mapping. The replace can be in-place or to another buffer.

Arguments:

  MapArray          - Specifies an array of string mapping tables that holds
                      zero or more search/replace pairs
  MapArrayCount     - Specifies the number of mapping tables in MapArray
  SrcBuffer         - Specifies the source string that might contain one or
                      more search strings
  Buffer            - Specifies the outbound buffer. This arg can be the same
                      as SrcBuffer.
  InboundBytes      - Specifies the number of bytes in SrcBuffer to process,
                      or 0 to process a nul-terminated string in SrcBuffer.
                      If InboundBytes is specified, it must point to the nul
                      terminator of SrcBuffer.
  OutbountBytesPtr  - Receives the number of bytes that Buffer contains,
                      excluding the nul terminator.
  MaxSizeInBytes    - Specifies the size of Buffer, in bytes.
  Flags             - Specifies flags that control the search/replace:
                            STRMAP_COMPLETE_MATCH_ONLY
                            STRMAP_FIRST_CHAR_MUST_MATCH
                            STRMAP_RETURN_AFTER_FIRST_REPLACE
                            STRMAP_REQUIRE_WACK_OR_NUL
  ExtraDataValue    - Receives the extra data associated with the first search/
                      replace pair.
  EndOfString       - Receives a pointer to the end of the replace string, or
                      the nul pointer when the entire string is processed. The
                      pointer is within the string contained in Buffer.

--*/

{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCSTR lowerCaseSrc;
    PCSTR orgSrc;
    PCSTR lowerSrcPos;
    PCSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PSTR destPos;
    PCSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCSTR replaceString;
    BOOL result = FALSE;
    INT i;
    PCSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountA (SrcBuffer);
    } else {
        i = 0;
        while (i < InboundBytes) {
            if (IsLeadByte (SrcBuffer[i])) {
                MYASSERT (SrcBuffer[i + 1]);
                i += 2;
            } else {
                i++;
            }
        }

        if (i > InboundBytes) {
            InboundBytes--;
        }
    }

    inboundSize = InboundBytes + sizeof (CHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextA (sizeOfTempBuf);
    if (!lowerCaseSrc) {
        return FALSE;
    }

    CopyMemory ((PSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffA ((PSTR) lowerCaseSrc, InboundBytes / sizeof (CHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (CHAR);

    filterData.UnicodeData = FALSE;
    filterData.Ansi.OriginalString = orgSrc;
    filterData.Ansi.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringA (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {

                //
                // Respect logical dbcs characters
                //

                replaceStringBytes = 0;
                i = 0;

                while (i < destBytesLeft) {
                    MYASSERT (replaceString[i]);

                    if (IsLeadByte (replaceString[i])) {
                        MYASSERT (replaceString[i + 1]);
                        i += 2;
                    } else {
                        i++;
                    }
                }

                if (i > destBytesLeft) {
                    destBytesLeft--;
                }

                replaceStringBytes = destBytesLeft;

            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (IsLeadByte (*orgSrcPos)) {

                //
                // Copy double-byte character
                //

                if (destBytesLeft < sizeof (CHAR) * 2) {
                    break;
                }

                MYASSERT (sizeof (CHAR) * 2 == sizeof (WORD));

                *((PWORD) destPos)++ = *((PWORD) orgSrcPos)++;
                destBytesLeft -= sizeof (WORD);
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + sizeof (WORD));

            } else {

                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }
        }
    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountA (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringA (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringA (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextA (lowerCaseSrc);

    return result;
}


BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCWSTR lowerCaseSrc;
    PCWSTR orgSrc;
    PCWSTR lowerSrcPos;
    PCWSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PWSTR destPos;
    PCWSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCWSTR replaceString;
    BOOL result = FALSE;
    PCWSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountW (SrcBuffer);
    } else {
        InboundBytes = (InboundBytes / sizeof (WCHAR)) * sizeof (WCHAR);
    }


    inboundSize = InboundBytes + sizeof (WCHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextW (sizeOfTempBuf);
    if (!lowerCaseSrc) {
        return FALSE;
    }

    CopyMemory ((PWSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PWSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffW ((PWSTR) lowerCaseSrc, InboundBytes / sizeof (WCHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCWSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCWSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCWSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (WCHAR);

    filterData.UnicodeData = TRUE;
    filterData.Unicode.OriginalString = orgSrc;
    filterData.Unicode.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringW (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {
                replaceStringBytes = destBytesLeft;
            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PWSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCWSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCWSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (destBytesLeft < sizeof (WCHAR)) {
                break;
            }

            *destPos++ = *orgSrcPos++;
            destBytesLeft -= sizeof (WCHAR);
            lowerSrcPos++;
        }

    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountW (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PWSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringW (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringW (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextW (lowerCaseSrc);

    return result;
}


BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExA (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExW (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"
#include "migutilp.h"

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK 32

extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PGROWBUFFER g_LastAllocTable;        // in main.c

extern POOLHANDLE g_TextPool;

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


PCWSTR g_FailedGetResourceString = L"";




/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      POOLHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PoolMemGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    text [0] = 0;

    return text;
}

PWSTR
RealAllocTextExW (
    IN      POOLHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (CountOfChars == 0) {
        return NULL;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    text = PoolMemGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    text [0] = 0;

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR Buf;
    PSTR d;
    PCSTR s;

    Buf = AllocTextExA (Pool, CharCountA (Text) + ExtraChars + 1);
    if (Buf) {
        s = Text;
        d = Buf;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}

PWSTR
RealDuplicateTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR Buf;
    PWSTR d;
    PCWSTR s;

    Buf = AllocTextExW (Pool, wcslen (Text) + ExtraChars + 1);
    if (Buf) {
        s = Text;
        d = Buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR Buf;
    PSTR End;
    PSTR d;
    PCSTR s;

    Buf = DuplicateTextExA (
              Pool,
              String1,
              CharCountA (String2) + ExtraChars + (CenterString ? CharCountA (CenterString) : 0),
              &End
              );

    if (Buf) {

        d = End;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                if (IsLeadByte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
            }
        }

        s = String2;
        while (*s) {
            if (IsLeadByte (*s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


PWSTR
RealJoinTextExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR Buf;
    PWSTR End;
    PCWSTR s;
    PWSTR d;

    Buf = DuplicateTextExW (
              Pool,
              String1,
              wcslen (String2) + ExtraChars + (CenterString ? wcslen(CenterString) : 0),
              &End
              );

    if (Buf) {
        d = End;

        if (CenterString) {
            s = CenterString;
            while (*s) {
                *d++ = *s++;
            }
        }

        s = String2;

        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return Buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR InString,
    IN PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    INT     maxSize             = 0;
    INT     curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    //
    // We assume that InString is valid.
    //
    MYASSERT(InString);

    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize > maxSize - 3) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpanEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    memcpy(newString,rString,curSize * sizeof(WCHAR));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW(nextPercent - source);

                        _wcssafecpyab(envName,source+1,nextPercent,(nextPercent - source)*sizeof(WCHAR));


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PWSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableW(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            } else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextW(size);


                                if ((size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }

                                freeValue = TRUE;
                            }
                        }


                        if (foundValue) {
                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;
                       }
                       else {
                            DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;
                       }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextW(envName);
                        envName = NULL;
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //
            rString[curSize++] = *source++;


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) {
                        rString[curSize] = 0;
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;
                }
            }

        }
    }
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}

PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR InString,
    IN PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    INT    maxSize             = 0;
    INT    curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    //
    // We assume that InString is valid.
    //
    MYASSERT(InString);

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize > maxSize - 3) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (rString) {
                    memcpy(newString,rString,curSize * sizeof(CHAR));
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (!IsLeadByte(*source) && *source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA(nextPercent - source);
                        _mbssafecpyab(envName,source+1,nextPercent,nextPercent - source);


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatch(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableA(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            }
                            else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextA(size);
                                freeValue = TRUE;

                                if ((size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }
                            }
                        }




                        if (foundValue) {

                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;



                        }
                        else {
                            DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;

                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextA(envName);
                        envName = NULL;


                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(*source)) {
                rString[curSize++] = *source++;
            }
            rString[curSize++] = *source++;


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) {
                        rString[curSize] = 0;
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;
                }
            }
        }
    }
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}




/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str)
        return str;

    Last = str;

    while (*str) {
        Last = str;
        str = _mbsinc (str);
    }

    if (*Last != '\\') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}

PWSTR
AppendWackW (
    IN PWSTR str
    )
{
    PCWSTR Last;

    if (!str)
        return str;

    if (*str) {
        str = GetEndOfStringW (str);
        Last = str - 1;
    } else {
        Last = str;
    }

    if (*Last != '\\') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}

PSTR
AppendDosWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str || !(*str))
        return str;

    do {
        Last = str;
        str = _mbsinc (str);
    } while (*str);

    if (*Last != '\\' && *Last != ':') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}


PWSTR
AppendDosWackW (
    IN PWSTR str
    )
{
    PWSTR Last;

    if (!str || !(*str))
        return str;

    str = GetEndOfStringW (str);
    Last = str - 1;

    if (*Last != L'\\' && *Last != L':') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}


PSTR
AppendUncWackA (
    IN PSTR str
    )
{
    PCSTR Last;

    if (!str || !(*str))
        return str;

    do {
        Last = str;
        str = _mbsinc (str);
    } while (*str);

    if (*Last != '\\') {
        *str = '\\';
        str++;
        *str = 0;
    }

    return str;
}


PWSTR
AppendUncWackW (
    IN PWSTR str
    )
{
    PWSTR Last;

    if (!str || !(*str))
        return str;

    str = GetEndOfStringW (str);
    Last = str - 1;

    if (*Last != L'\\') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}

PSTR
AppendPathWackA (
    IN PSTR str
    )
{
    if (!str) {
        return str;
    }

    if (str[0] == '\\' && str[1] == '\\') {
        return AppendUncWackA (str);
    }

    return AppendDosWackA (str);
}


PWSTR
AppendPathWackW (
    IN PWSTR str
    )
{
    if (!str) {
        return str;
    }

    if (str[0] == L'\\' && str[1] == L'\\') {
        return AppendUncWackW (str);
    }

    return AppendDosWackW (str);
}


PSTR
RealJoinPathsExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR PathA,
    IN      PCSTR PathB
    )
{
    PSTR end;
    PSTR endMinusOne;
    DWORD Size;
    PSTR Dest;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    Size = ByteCountA (PathA) + 1 + SizeOfStringA (PathB);
    Dest = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    MYASSERT (Dest);

    *Dest = 0;
    end = _mbsappend (Dest, PathA);
    endMinusOne = _mbsdec (Dest, end);
    if (endMinusOne && _mbsnextc (endMinusOne) != '\\') {
        *end = '\\';
        end++;
    }
    if (_mbsnextc (PathB) == '\\') {
        PathB = _mbsinc (PathB);
    }
    StringCopyA (end, PathB);

    return Dest;
}

PWSTR
RealJoinPathsExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR PathA,
    IN      PCWSTR PathB
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    DWORD Size;
    PWSTR Dest;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    Size = ByteCountW (PathA) + sizeof (WCHAR) + SizeOfStringW (PathB);
    Dest = (PWSTR) PoolMemGetAlignedMemory (Pool, Size);
    MYASSERT (Dest);

    *Dest = 0;
    end = _wcsappend (Dest, PathA);
    endMinusOne = _wcsdec2 (Dest, end);
    if (endMinusOne && *endMinusOne != L'\\') {
        *end = L'\\';
        end++;
    }
    if (*PathB == L'\\') {
        PathB++;
    }
    StringCopyW (end, PathB);

    return Dest;
}

PSTR
RealAllocPathStringA (
    DWORD Chars
    )
{
    PSTR Str;

    if (Chars == 0) {
        Chars = MAX_MBCHAR_PATH;
    }

    Str = (PSTR) PoolMemGetAlignedMemory (g_PathsPool, Chars);

    Str [0] = 0;

    return Str;
}

PWSTR
RealAllocPathStringW (
    DWORD Chars
    )
{
    PWSTR Str;

    if (Chars == 0) {
        Chars = MAX_WCHAR_PATH;
    }

    Str = (PWSTR) PoolMemGetAlignedMemory (g_PathsPool, Chars * sizeof (WCHAR));

    Str [0] = 0;

    return Str;
}

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR FileName[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];

    _splitpath (Path, Drive, Dir, FileName, Ext);

    if (DrivePtr) {
        *DrivePtr = PoolMemDuplicateStringA (g_PathsPool, Drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PoolMemDuplicateStringA (g_PathsPool, Dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PoolMemDuplicateStringA (g_PathsPool, FileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PoolMemDuplicateStringA (g_PathsPool, Ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR Drive[_MAX_DRIVE];
    WCHAR Dir[_MAX_DIR];
    WCHAR FileName[_MAX_FNAME];
    WCHAR Ext[_MAX_EXT];

    _wsplitpath (Path, Drive, Dir, FileName, Ext);

    if (DrivePtr) {
        *DrivePtr = PoolMemDuplicateStringW (g_PathsPool, Drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PoolMemDuplicateStringW (g_PathsPool, Dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PoolMemDuplicateStringW (g_PathsPool, FileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PoolMemDuplicateStringW (g_PathsPool, Ext);
        MYASSERT (*ExtPtr);
    }
}

PSTR
RealDuplicatePathStringA (
    PCSTR Path,
    DWORD ExtraBytes
    )
{
    PSTR str;

    str = PoolMemGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}

PWSTR
RealDuplicatePathStringW (
    PCWSTR Path,
    DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PoolMemGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


PSTR
pCopyAndCleanupPathsA (
    IN      PCSTR Source,
    OUT     PSTR Dest
    )
{
    BOOL quotes = FALSE;

    do {

        while (*Source && isspace (*Source)) {
            Source++;
        }

        while (*Source) {
            if (IsLeadByte (*Source)) {
                *Dest++ = *Source++;
                *Dest++ = *Source++;
            } else {
                if (*Source == '\"') {
                    Source++;
                    quotes = !quotes;
                } else if (!quotes) {
                    *Dest++ = *Source++;
                }
            }
        }

    } while (*Source);

    *Dest = 0;

    return Dest;
}

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize = 0;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    if (IncludeEnvPath) {
        bufferSize = pathSize = GetEnvironmentVariableA ("PATH", NULL, 0);
    }
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = MemAlloc (g_hHeap, 0, bufferSize + 1);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    currPathEnd = PathEnum->BufferPtr;
    if (AdditionalPath != NULL) {
        currPathEnd = _mbsappend (currPathEnd, AdditionalPath);
    }
    if (SysDir != NULL) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        currPathEnd = _mbsappend (currPathEnd, SysDir);
    }
    if (WinDir != NULL) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        currPathEnd = _mbsappend (currPathEnd, WinDir);
    }
    if (IncludeEnvPath) {
        *currPathEnd++ = ';';
        *currPathEnd = 0;
        GetEnvironmentVariableA ("PATH", currPathEnd, pathSize);
    }

    //
    // clean up quotes
    //
    pCopyAndCleanupPathsA (currPathEnd, currPathEnd);

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    do {
        if (PathEnum->PtrNextPath == NULL) {
            EnumPathAbort (PathEnum);
            return FALSE;
        }
        PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

        PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
        if (PathEnum->PtrNextPath != NULL) {
            if (PathEnum->PtrNextPath - PathEnum->PtrCurrPath >= MAX_MBCHAR_PATH) {
                *PathEnum->PtrNextPath = 0;
                LOG ((
                    LOG_WARNING,
                    "Skipping enumeration of path (too long): %s",
                    PathEnum->PtrCurrPath
                    ));
                *PathEnum->PtrNextPath = ';';
                //
                // cut this path
                //
                *PathEnum->PtrCurrPath = 0;
                //
                // and continue with the next one
                //
                continue;
            }
            *PathEnum->PtrNextPath++ = 0;
            if (*(PathEnum->PtrNextPath) == 0) {
                PathEnum->PtrNextPath = NULL;
            }
        } else {
            if (ByteCountA (PathEnum->PtrCurrPath) >= MAX_MBCHAR_PATH) {
                LOG ((
                    LOG_WARNING,
                    "Skipping enumeration of path (too long): %s",
                    PathEnum->PtrCurrPath
                    ));
                //
                // cut this path
                //
                *PathEnum->PtrCurrPath = 0;
            }
        }

    } while (*(PathEnum->PtrCurrPath) == 0);

    return TRUE;
}

BOOL
EnumPathAbortA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        MemFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}





VOID
FreePathStringExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PoolMemReleaseMemory (Pool, (PSTR) Path);
    }
}

VOID
FreePathStringExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PoolMemReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;

void
PushNewError (DWORD dwError)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

void
PushError (void)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (void)
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

int
GetHexDigit (IN  int c)

{
    if (c >= '0' && c <= '9')
        return (c - '0');

    c = towlower ((wint_t) c);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, or 0 if a syntax error was found.

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, or zero if a syntax error was
  found.

--*/

DWORD
_mbsnum (IN PCSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == '0' && tolower (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD

_wcsnum (IN PCWSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  _tcsappend is a strcpy that returns the pointer to the end
  of a string instead of the beginning.

Arguments:

  szDest - A pointer to a caller-allocated buffer that may point
           anywhere within the string to append to
  szSrc  - A pointer to a string that is appended to szDest

Return Value:

  A pointer to the NULL terminator within the szDest string.

--*/

PSTR
_mbsappend (OUT PSTR mbstrDest,
             IN  PCSTR mbstrSrc)

{
    // Advance mbstrDest to end of string
    mbstrDest = GetEndOfStringA (mbstrDest);

    // Copy string
    while (*mbstrSrc) {
        *mbstrDest = *mbstrSrc++;
        if (IsLeadByte (*mbstrDest)) {
            mbstrDest++;
            *mbstrDest = *mbstrSrc++;
        }
        mbstrDest++;
    }

    *mbstrDest = 0;

    return mbstrDest;
}


PWSTR
_wcsappend (OUT PWSTR wstrDest,
            IN  PCWSTR wstrSrc)

{
    // Advance wstrDest to end of string
    wstrDest = GetEndOfStringW (wstrDest);

    // Copy string
    while (*wstrSrc) {
        *wstrDest++ = *wstrSrc++;
    }

    *wstrDest = 0;

    return wstrDest;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (PCSTR mbstrStr, PCSTR mbstrSubStr)

{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               _mbctolower ((MBCHAR) _mbsnextc (mbstrSubStrPos)) == _mbctolower ((MBCHAR) _mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (PCWSTR wstrStr, PCWSTR wstrSubStr)

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  _tcscmpab compares a string against a string between to string pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  End - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and End
  Zero: String matches the string between Start and End identically
  Greater than zero: String is numerically greater than the string between Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbsnextc (String) != _mbsnextc (Start)) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return _mbsnextc (Start) - _mbsnextc (String);
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (tolower (_mbsnextc (String)) != tolower (_mbsnextc (Start))) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return tolower (_mbsnextc (Start)) - tolower (_mbsnextc (String));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



void
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (*Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR)c;
    } else {
        if (!IsLeadByte (*Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *p_szRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  p_szRule   - A pointer to a pointer; a caller-allocated buffer that
               holds the rule string.
  p_bFromHex - A pointer to a caller-allocated BOOL that receives TRUE
               when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *p_bFromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = _mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = _mbsinc (StartPtr);
    return _mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )

{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (szRule), possibly
  encoded with hex-specified character values (~xx~).  The output

  string contains unencoded characters.

Arguments:

  szRule    - A caller-allocated buffer, big enough to hold an
              unencoded rule.  szRule can be equal to szEncRule.
  szEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to szRule.

--*/


PSTR
DecodeRuleCharsA (PSTR mbstrRule, PCSTR mbstrEncRule)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR)c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    } while (c);

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (PWSTR wstrRule, PCWSTR wstrEncRule)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    } while (c);

    return wstrOrgRule;
}


PSTR
DecodeRuleCharsABA (PSTR mbstrRule, PCSTR mbstrEncRule, PCSTR End)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR)c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (PWSTR wstrRule, PCWSTR wstrEncRule, PCWSTR End)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  szEncRule - A caller-allocated buffer, big enough to hold an
              encoded rule.  szEncRule CAN NOT be equal to szRule.
              One way to calculate a max buffer size for szEncRule
              is to use the following code:

                  allocsize = SizeOfString (szRule) * 6;

              In the worst case, each character in szRule will take
              six single-byte characters in szEncRule.  In the normal
              case, szEncRule will only be a few bytes bigger than
              szRule.

  szRule    - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsA (PSTR mbstrEncRule, PCSTR mbstrRule)

{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;

    mbstrOrgRule = mbstrEncRule;

    while (*mbstrRule)  {
        c = _mbsnextc (mbstrRule);

        if ((c > 127) || _mbschr (mbstrExclusions, c)) {

            // Escape unprintable or excluded character
            wsprintfA (mbstrEncRule, "~%X~", c);
            mbstrEncRule = GetEndOfStringA (mbstrEncRule);
            mbstrRule = _mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (*mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsW (PWSTR wstrEncRule, PCWSTR wstrRule)

{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;

    wstrOrgRule = wstrEncRule;

    while (c = *wstrRule)   {
        if ((c > 127) || wcschr (wstrExclusions, c)) {
            wsprintfW (wstrEncRule, L"~%X~", c);
            wstrEncRule = GetEndOfStringW (wstrEncRule);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


int
_mbsisprint (PCSTR mbstrStr)

{
    while (*mbstrStr && _ismbcprint ((MBCHAR) _mbsnextc (mbstrStr))) {
        mbstrStr = _mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


int
_wcsisprint (PCWSTR wstrStr)

{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (PCSTR mbstrStr)

{
    while (_ismbcspace ((MBCHAR) _mbsnextc (mbstrStr)))
        mbstrStr = _mbsinc (mbstrStr);

    return mbstrStr;
}


PCWSTR
SkipSpaceW (PCWSTR wstrStr)

{
    while (iswspace (*wstrStr))
        wstrStr++;

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {
        Str = _mbsdec (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) _mbsnextc(Str))) {
            return Str;
        }

    } while (Str = _mbsdec(StrBase, Str));

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses isspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) _mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = _mbsinc (Str);
    }

    if (LastNonSpace) {
        *_mbsinc (LastNonSpace) = 0;
    } else {
        *OrgStr = 0;
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        *(LastNonSpace + 1) = 0;
    } else {
        *OrgStr = 0;
    }
}



/*++

Routine Description:

  _tcsnzcpy copies bytecount bytes from the source string to the
  destination string, and terminates the string if it needs to
  be truncated.  This function is a _tcsncpy, plus a terminating
  nul.

  _tcsnzcpy always requires a destination buffer that can hold
  bytecount + sizeof (TCHAR) bytes.

  Use the _tcssafecpy macros to specify the maximum number of bytes
  to copy, including the nul.

Arguments:

  dest      - The destination buffer that is at least bytecount + sizeof(TCHAR)
  src       - The source string
  bytecount - The number of bytes to copy.  If src is greater than bytecount,
              the destination string is truncated.

Return Value:

  A pointer to dest.

--*/

PSTR
_mbsnzcpy (
    PSTR dest,
    PCSTR src,
    INT bytecount
    )
{
    PSTR realdest;

    realdest = dest;
    while (*src && bytecount >= sizeof (CHAR)) {
        if (IsLeadByte (*src)) {
            if (bytecount == 1) {
                // double char can't fit
                break;
            }
            *dest++ = *src++;
            bytecount--;
        }
        *dest++ = *src++;
        bytecount--;
    }
    *dest = 0;

    return realdest;
}

PWSTR
_wcsnzcpy (
    PWSTR dest,
    PCWSTR src,
    INT bytecount
    )
{
    PWSTR realdest;

    realdest = dest;
    while (*src && bytecount >= sizeof (WCHAR)) {
        *dest++ = *src++;
        bytecount -= sizeof(WCHAR);
    }
    *dest = 0;

    return realdest;
}



/*++

Routine Description:

  _tcsnzcpyab copies bytecount bytes between two pointers to the
  destination string, and terminates the string if it needs to
  be truncated.  This function is a _tcscpyab, plus a terminating
  nul, plus bytecount safety guard.

  _tcsnzcpy always requires a destination buffer that can hold
  bytecount + sizeof (TCHAR) bytes.

  Use the _tcssafecpyab macros to specify the maximum number of bytes
  to copy, including the nul.

Arguments:

  Dest      - The destination buffer that is at least bytecount + sizeof(TCHAR)
  Start     - The start of the source string
  End       - Points to the character one position past the
              last character to copy in the string pointed to
              by start.
  bytecount - The number of bytes to copy.  If src is greater than bytecount,
              the destination string is truncated.

Return Value:

  A pointer to Dest.  Start and End must be pointers within
  the same string, and End must be greater than Start.  If
  it isn't, the function will make the string empty.

--*/

PSTR
_mbsnzcpyab (
    PSTR Dest,
    PCSTR Start,
    PCSTR End,
    INT count
    )
{
    PSTR realdest;

    realdest = Dest;
    while ((Start < End) && count >= sizeof (CHAR)) {
        if (IsLeadByte (*Start)) {
            if (count == 1) {
                // double char can't fit
                break;
            }
            *Dest++ = *Start++;
            count--;
        }
        *Dest++ = *Start++;
        count--;
    }
    *Dest = 0;

    return realdest;
}

PWSTR
_wcsnzcpyab (
    PWSTR Dest,
    PCWSTR Start,
    PCWSTR End,
    INT count
    )
{
    PWSTR realdest;

    realdest = Dest;
    while ((Start < End) && count >= sizeof (WCHAR)) {
        *Dest++ = *Start++;
        count -= sizeof(WCHAR);
    }
    *Dest = 0;

    return realdest;
}


/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    if (wstrPattern[0] == L'*' && wstrPattern[1] == 0) {
        return TRUE;
    }

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (Start));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Start)) == '*') {
                Start = _mbsinc (Start);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = _mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = _mbsinc (Start);
        Pattern = _mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Pattern) == '*') {
        Pattern = _mbsinc (Pattern);
    }

    if (_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}


BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}


/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  Buf       - Specifies the grow buffer to add the character to, receives the
              character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (*PtrToChar) && PtrToChar[1]) {
        Len = 2;
    } else {
        Len = 1;
    }

    p = GrowBuffer (Buf, Len);
    CopyMemory (p, PtrToChar, Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GrowBuffer (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}


/*++

Routine Description:

  CreateParsedPattern parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    )
{
    POOLHANDLE Pool;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = GROWBUF_INIT;
    GROWBUFFER SegmentArray = GROWBUF_INIT;
    GROWBUFFER PatternArray = GROWBUF_INIT;
    GROWBUFFER SetBuf = GROWBUF_INIT;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PoolMemInitNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNA) PoolMemGetAlignedMemory (Pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (isspace (_mbsnextc (Pattern))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                Pattern = _mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GrowBuffer (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PoolMemGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = _mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = _mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = _mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = _mbsinc (Pattern);

                if (_mbsnextc (Pattern) == '[') {
                    Pattern = _mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = _mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PoolMemDuplicateStringA (
                                                Pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _mbslwr ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GrowBuffer (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && _mbsnextc (LookAhead) == ':') {
                Pattern = _mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PoolMemDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = _mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PoolMemDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = _mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = _mbsinc (SetBegin);

                if (_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = _mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (_mbsnextc (SetBegin) == '^') {
                SetBegin = _mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = _mbsinc (SetBegin);

            if (_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = _mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (_mbsnextc (SetBegin) == '^') {
                    SetBegin = _mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = _mbsinc (SetBegin);
            ch = _mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = _mbsinc (SetBegin);
                    ch = _mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            while (*SetBegin) {
                if (_mbsnextc (SetBegin) == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin[0]) && SetBegin[1]) {
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = _mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) {
                ch = _mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = _mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    FreeGrowBuffer (&ExactMatchBuf);
    FreeGrowBuffer (&SetBuf);
    FreeGrowBuffer (&SegmentArray);

    if (State == PATTERN_ERROR || PatternArray.End == 0) {
        FreeGrowBuffer (&PatternArray);
        PoolMemDestroyPool (Pool);
        return NULL;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PoolMemGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = Pool;

    FreeGrowBuffer (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    )
{
    POOLHANDLE Pool;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = GROWBUF_INIT;
    GROWBUFFER SegmentArray = GROWBUF_INIT;
    GROWBUFFER PatternArray = GROWBUF_INIT;
    GROWBUFFER SetBuf = GROWBUF_INIT;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PoolMemInitNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNW) PoolMemGetAlignedMemory (Pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GrowBuffer (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PoolMemGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PoolMemDuplicateStringW (
                                                Pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _wcslwr ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GrowBuffer (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PoolMemDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );
                    _wcslwr ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PoolMemDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );
                    _wcslwr ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++;

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++;

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    FreeGrowBuffer (&ExactMatchBuf);
    FreeGrowBuffer (&SetBuf);
    FreeGrowBuffer (&SegmentArray);

    if (State == PATTERN_ERROR || PatternArray.End == 0) {
        FreeGrowBuffer (&PatternArray);
        PoolMemDestroyPool (Pool);
        return NULL;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PoolMemGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = Pool;

    FreeGrowBuffer (&PatternArray);

    return Struct;
}


VOID
PrintPattern (
    PCSTR PatStr,
    PPARSEDPATTERNA Struct          OPTIONAL
    )

/*++

Routine Description:

  PrintPattern is used for debugging the pattern parsing and testing
  functions.

Arguments:

  PatStr - Specifies the original pattern string (which is printed as a
           heading)
  Struct - Specifies the parsed pattern struct

Return Value:

  None.

--*/

{
    UINT u, v;

    printf ("Pattern: %s\n\n", PatStr);

    if (!Struct) {
        printf ("Invalid Pattern\n\n");
        return;
    }

    printf ("PatternCount: %u\n", Struct->PatternCount);
    printf ("Pool: 0x%08X\n", Struct->Pool);

    for (u = 0 ; u < Struct->PatternCount ; u++) {

        printf ("  Segment Count: %u\n", Struct->Pattern[u].SegmentCount);

        for (v = 0 ; v < Struct->Pattern->SegmentCount ; v++) {
            printf ("    Type: ");

            switch (Struct->Pattern[u].Segment[v].Type) {

            case SEGMENTTYPE_EXACTMATCH:
                printf ("SEGMENTTYPE_EXACTMATCH\n");
                printf ("      String: %s\n", Struct->Pattern[u].Segment[v].Exact.LowerCasePhrase);
                printf ("      Bytes: %u\n", Struct->Pattern[u].Segment[v].Exact.PhraseBytes);
                break;

            case SEGMENTTYPE_OPTIONAL:
                printf ("SEGMENTTYPE_OPTIONAL\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;

            case SEGMENTTYPE_REQUIRED:
                printf ("SEGMENTTYPE_REQUIRED\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;
            }
        }

    }

    printf ("\n");
}



/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (isspace (ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = _mbctolower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);
            HighChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);
            HighChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (PBYTE) EndPlusOne - (PBYTE) StringToTest;

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 1;

            while (q < TempEnd) {

                ch1 = _mbsnextc (StringToTest);
                ch2 = _mbsnextc (q);

                ch1 = _mbctolower (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!isspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = _mbsinc (q);
                StringToTest = _mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            _mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = _mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = _mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (PBYTE) EndPlusOne - (PBYTE) StringToTest;

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 1;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        PoolMemDestroyPool (ParsedPattern->Pool);
    }
}

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        PoolMemDestroyPool (ParsedPattern->Pool);
    }
}


void
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (*sz2))
        sz1[1] = sz2[1];

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = _mbsdec (str, end);
    if (end && _mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}

BOOL
_wcsctrim (
    PWSTR str,
    WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    LPCTSTR *Ptr, *End, *Start;

    if (!String || String == (PCSTR) g_FailedGetResourceString) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }

    Start = (PCSTR *) AllocTable->Buf;
    End = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    Ptr = End;
    while (Ptr >= Start) {
        if (*Ptr == String) {
            break;
        }
        Ptr--;
    }

    //
    // String not found case
    //

    if (Ptr < Start) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (Ptr < End) {
        *Ptr = *End;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *Ptr;

    Ptr = (PCSTR *) GrowBuffer (GrowBuf, sizeof (PCSTR));
    if (Ptr) {
        *Ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *Ptr, *Start, *End;

    if (AllocTable->End) {
        Start = (PCSTR *) AllocTable->Buf;
        End = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (Ptr = Start ; Ptr < End ; Ptr++) {
            LocalFree ((HLOCAL) (*Ptr));
        }
    }

    FreeGrowBuffer (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
CreateAllocTable (
    VOID
    )
{
    PGROWBUFFER AllocTable;
    GROWBUFFER TempForInit = GROWBUF_INIT;

    AllocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (AllocTable, &TempForInit, sizeof (GROWBUFFER));

    return AllocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/

BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}

VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf = NULL;

    SetLastError (ERROR_SUCCESS);
    if (HIWORD (Template)) {
        // From string
        FormatMessageA (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_STRING,
            (PVOID) Template,
            0,
            0,
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    } else {
        // From resource
        FormatMessageA (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (PVOID) g_hInst,
            (DWORD) Template,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    }

    if (!MsgBuf && GetLastError() == ERROR_SUCCESS) {

        //
        // FormatMessage returns "fail" on a resource that is an empty
        // string, but fortunately it does not alter the last error
        //

        MsgBuf = (PSTR) LocalAlloc (LPTR, sizeof (CHAR));
        if (MsgBuf) {
            *MsgBuf = 0;
        }

    }

    if (MsgBuf) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    if (HIWORD (Template)) {
        DEBUGMSGA ((
            DBG_ERROR,
            "Can't get string resource ID %s -- returning an empty string",
            Template
            ));
    } else {
        DEBUGMSG ((
            DBG_ERROR,
            "Can't get string resource ID %u -- returning an empty string",
            (UINT) Template
            ));
    }

    return (PCSTR) g_FailedGetResourceString;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf = NULL;

    SetLastError (ERROR_SUCCESS);
    if (HIWORD (Template)) {
        // From string
        FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_STRING,
            (PVOID) Template,
            0,
            0,
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    } else {
        // From resource
        FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (PVOID) g_hInst,
            (DWORD) Template,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (PVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );
    }

    if (!MsgBuf && GetLastError() == ERROR_SUCCESS) {

        //
        // FormatMessage returns "fail" on a resource that is an empty
        // string, but fortunately it does not alter the last error
        //

        MsgBuf = (PWSTR) LocalAlloc (LPTR, sizeof (WCHAR));
        if (MsgBuf) {
            *MsgBuf = 0;
        }

    }

    if (MsgBuf) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    if (HIWORD (Template)) {
        DEBUGMSGW ((
            DBG_ERROR,
            "Can't get string resource ID %s -- returning an empty string",
            Template
            ));
    } else {
        DEBUGMSG ((
            DBG_ERROR,
            "Can't get string resource ID %u -- returning an empty string",
            (UINT) Template
            ));
    }

    return g_FailedGetResourceString;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    HWND hwnd,
    PCSTR ArgArray[]
    )
{
    CHAR Buffer[512];
    PCSTR ParsedMsg;

    GetWindowTextA (hwnd, Buffer, 512);
    ParsedMsg = ParseMessageA (Buffer, ArgArray);
    if (ParsedMsg) {
        SetWindowTextA (hwnd, ParsedMsg);
        FreeStringResourceA (ParsedMsg);
    }
}


VOID
ParseMessageInWndW (
    HWND hwnd,
    PCWSTR ArgArray[]
    )
{
    WCHAR Buffer[512];
    PCWSTR ParsedMsg;

    GetWindowTextW (hwnd, Buffer, 512);
    ParsedMsg = ParseMessageW (Buffer, ArgArray);
    if (ParsedMsg) {
        SetWindowTextW (hwnd, ParsedMsg);
        FreeStringResourceW (ParsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  hwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND hwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR Message;
    PCSTR Title;
    int rc;

    Message = ParseMessageA ((PSTR) ID, ArgArray);
    if (!Message)
        return -1;

    Title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (hwndOwner, Message, Title, Flags);

    FreeStringResourceA (Message);
    if (Title) {
        FreeStringResourceA (Title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND hwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR Message;
    PCWSTR Title;
    int rc;

    Message = ParseMessageW ((PWSTR) ID, ArgArray);
    if (!Message)
        return -1;

    Title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (hwndOwner, Message, Title, Flags);

    FreeStringResourceW (Message);
    if (Title) {
        FreeStringResourceW (Title);
    }

    return rc;
}




BOOL
StringReplaceA (
    IN PSTR     Buffer,
    IN DWORD    MaxSize,
    IN PSTR     ReplaceStartPos,
    IN PSTR     ReplaceEndPos,
    IN PCSTR   NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = ReplaceEndPos - ReplaceStartPos;
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    }
    else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 movePosition >= ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        }
        else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        _mbsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN PWSTR     Buffer,
    IN DWORD     MaxSize,
    IN PWSTR     ReplaceStartPos,
    IN PWSTR     ReplaceEndPos,
    IN PCWSTR   NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = ReplaceEndPos - ReplaceStartPos;
    newSubStringLength  = wcslen(NewString);
    currentStringLength = wcslen(Buffer) + 1;
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    }
    else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 movePosition >= ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        }
        else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

#if 0 // REMOVED
/*++

Routine Description:

  AddInfSectionToStringTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

  Note - if this code is re-enabled, cleanup all pSetupStringTableXXXX functions
  callers will *ALWAYS* link to SPUTILSA.LIB and never SPUTILSU.LIB
  so all pSetupStringTableXXXX functions are ANSI

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToStringTableA (
    IN OUT  PVOID Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      INT Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    DWORD ReqSize;
    DWORD CurrentSize = 0;
    PSTR NewBuffer, Buffer = NULL;
    PVOID Data;
    UINT DataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //
    // Above comment is now incorrect, string table functions linked
    // with this module are always ANSI
    //

#error FIX pSetupStringTableXXXX usage
    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &ReqSize)) {
                continue;
            }

            if (ReqSize > CurrentSize) {
                ReqSize = ((ReqSize / 1024) + 1) * 1024;
                if (Buffer) {
                    NewBuffer = (PSTR) MemReAlloc (g_hHeap, 0, Buffer, ReqSize);
                } else {
                    NewBuffer = (PSTR) MemAlloc (g_hHeap, 0, ReqSize);
                }

                if (!NewBuffer) {
                    goto cleanup;
                }

                Buffer = NewBuffer;
                CurrentSize = ReqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, Buffer, CurrentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToStringTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            Data = NULL;
            DataSize = 0;

            if (Callback) {
                rc = Callback (Buffer, &Data, &DataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            rc = pSetupStringTableAddStringEx (
                        Table,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,
                        Data,
                        DataSize
                        );

            if (rc == -1) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (Buffer) {
        PushError();
        MemFree (g_hHeap, 0, Buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToStringTableW (
    IN OUT  PVOID Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      INT Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    DWORD ReqSize;
    DWORD CurrentSize = 0;
    PWSTR NewBuffer, Buffer = NULL;
    PVOID Data;
    UINT DataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //
    // Above comment is now incorrect, string table functions linked
    // with this module are always ANSI
    //

#error FIX pSetupStringTableXXXX usage
    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &ReqSize)) {
                continue;
            }

            if (ReqSize > CurrentSize) {
                ReqSize = ((ReqSize / 1024) + 1) * 1024;
                if (Buffer) {
                    NewBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, Buffer, ReqSize);
                } else {
                    NewBuffer = (PWSTR) MemAlloc (g_hHeap, 0, ReqSize);
                }

                if (!NewBuffer) {
                    goto cleanup;
                }

                Buffer = NewBuffer;
                Cu