t
 * that moves surface contents from an offscreen back buffer to the primary
 * surface). The driver is not allowed to "queue"  more than three such blts.
 * The "end" of the presentation blt is indicated, since the
 * blt may be clipped, in which case the runtime will call the driver with 
 * several blts. All blts (even if not clipped) are tagged with DDBLT_PRESENTATION
 * and the last (even if not clipped) additionally with DDBLT_LAST_PRESENTATION.
 * Thus the true rule is that the driver must not schedule a DDBLT_PRESENTATION
 * blt if there are 3 or more DDBLT_PRESENTLAST blts in the hardware pipe.
 * If there are such blts in the pipe, the driver should return DDERR_WASSTILLDRAWING
 * until the oldest queued DDBLT_LAST_PRESENTATION blts has been retired (i.e. the
 * pixels have been actually written to the primary surface). Once the oldest blt
 * has been retired, the driver is free to schedule the current blt.
 * The goal is to provide a mechanism whereby the device's hardware queue never
 * gets more than 3 frames ahead of the frames being generated by the application.
 * When excessive queueing occurs, applications become unusable because the application
 * visibly lags user input, and such problems make windowed interactive applications impossible.
 * Some drivers may not have sufficient knowledge of their hardware's FIFO to know
 * when a certain blt has been retired. Such drivers should code cautiously, and 
 * simply not allow any frames to be queued at all. DDBLT_LAST_PRESENTATION should cause
 * such drivers to return DDERR_WASSTILLDRAWING until the accelerator is completely
 * finished- exactly as if the application had called Lock on the source surface
 * before calling Blt. 
 * In other words, the driver is allowed and encouraged to 
 * generate as much latency as it can, but never more than 3 frames worth.
 * Implementation detail: Drivers should count blts against the SOURCE surface, not
 * against the primary surface. This enables multiple parallel windowed application
 * to function more optimally.
 * This flag is passed only to DX8 or higher drivers.
 *
 * APPLICATIONS DO NOT SET THESE FLAGS. THEY ARE SET BY THE DIRECTDRAW RUNTIME.
 * 
 */
#define DDBLT_PRESENTATION                      0x10000000l
#define DDBLT_LAST_PRESENTATION                 0x20000000l


//@@BEGIN_MSINTERNAL
//We are running out of blt flags. From now on, the high bit will be used
//to indicate a DX8 (or higher) sourced blt, and we will start re-using
//old bits for internal-only flags (flags which are passed to the thunk
//layer's blt but not to the driver. All these DX8-only bits will be
//filtered off before checking against DDBLT_VALID.
#define DDBLT_DX8ORHIGHER                       0x80000000l

//will use the hWnd with the clipper to get the Destination
#define DDBLT_WINDOWCLIP                        0x00000001l /* DDBLT_ALPHADEST */
#define DDBLT_COPYVSYNC                         0x00000002l /* DDBLT_ALPHADESTCONSTOVERRIDE */

#define DDBLT_VALID                             0x1fffffffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
#define DDBLTFAST_DONOTWAIT                     0x00000020
//@@BEGIN_MSINTERNAL
#define DDBLTFAST_COLORKEY_MASK                 0x0000000F
#define DDBLTFAST_VALID                         0x00000033
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for AlphaBlt API call
 *
 ****************************************************************************/

/*
 * Use color key associated with source surface.
 */
#define DDABLT_KEYSRC                           0x40000000L

/*
 * Mirror the source image left-to-right in the destination rect.
 */
#define DDABLT_MIRRORLEFTRIGHT                  0x20000000L

/*
 * Mirror the source image vertically in the destination rect.
 */
#define DDABLT_MIRRORUPDOWN                     0x10000000L

/*
 * If previously initiated drawing operation is still in progress,
 * wait for it to finish instead of returning DDERR_WASSTILLDRAWING.
 */
#define DDABLT_WAIT                             0x08000000L

/*
 * Mandates hardware acceleration -- no software emulation.
 */
#define DDABLT_HARDWAREONLY                     0x04000000L

/*
 * Convert the source pixels to the destination pixel format, but
 * perform no color keying, no alpha blending, and no ARGB scaling.
 */
#define DDABLT_NOBLEND                          0x02000000L

/*
 * Enable filtering of source pixels for blit in order to improve quality
 * of stretched or shrunk image.
 */
#define DDABLT_FILTERENABLE                     0x01000000l

/*
 * Disable filtering.  Use nearest-neighbor source pixels for stretch blits.
 */
#define DDABLT_FILTERDISABLE                    0x00800000L

/*
 * If the driver is unable to use the ARGB scaling factors as specified,
 * degrade the scaling operation to one the driver can perform.
 */
#define DDABLT_DEGRADEARGBSCALING               0x00400000L

/*
 * If previously initiated drawing operation is still in progress,
 * return DDERR_WASSTILLDRAWING instead of waiting for it to finish.
 */
#define DDABLT_DONOTWAIT                        0x00200000L

/*
 * Fill dest surface with pixel value contained in lpDDAlphaBltFX->dwFillValue.
 */
#define DDABLT_USEFILLVALUE                     0x00100000L

/*
 * Mandates software emulation -- no hardware acceleration.
 */
#define DDABLT_SOFTWAREONLY                     0x00080000L

/*
 * When filtering, pixels bordering source rectangle are treated as transparent
 * in order to smoothly blend edges of source image onto dest image.
 */
#define DDABLT_FILTERTRANSPBORDER               0x00040000L

#define DDABLT_VALID                            0x7ffc0000L
//@@END_MSINTERNAL


/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L

/*
 * Causes DirectDraw to perform the physical flip immediately and return
 * to the application. Typically, what was the front buffer but is now the back
 * buffer will still be visible (depending on timing) until the next vertical
 * retrace. Subsequent operations involving the two flipped surfaces will
 * not check to see if the physical flip has finished (i.e. will not return
 * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
 * This allows an application to perform Flips at a higher frequency than the
 * monitor refresh rate, but may introduce visible artifacts.
 * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
 * DDFLIP_NOVSYNC has no effect.
 */
#define DDFLIP_NOVSYNC                       0x00000008L


/*
 * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
 * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
 * surface involved in the flip until the specified number of vertical retraces has
 * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
 * DDFLIP_INTERVALn has no effect.
 */

/*
 * DirectDraw will flip on every other vertical sync
 */
#define DDFLIP_INTERVAL2                     0x02000000L


/*
 * DirectDraw will flip on every third vertical sync
 */
#define DDFLIP_INTERVAL3                     0x03000000L


/*
 * DirectDraw will flip on every fourth vertical sync
 */
#define DDFLIP_INTERVAL4                     0x04000000L

/*
 * DirectDraw will flip and display a main stereo surface
 */
#define DDFLIP_STEREO                        0x00000010L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
 */
#define DDFLIP_DONOTWAIT                     0x00000020L

//@@BEGIN_MSINTERNAL
#define DDFLIP_INTERVAL1                     0x01000000L
#define DDFLIP_INTERVALMASK                  0x07000000L
#define DDFLIP_VALID                         0x0700003fL
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/****************************************************************************
 *
 * DIRECTDRAW COMP FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDCOMPOSEFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDCOMP_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDCOMPOSEFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDCOMP_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDCOMPOSEFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDCOMP_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDCOMP_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDCOMP_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Before performing this blt invoke the callback specified by the lpfnCallback
 * field in the DDCOMPOSEFX structure.
 */
#define DDCOMP_CALLBACK                         0x00000200l

/*
 * Uses the dwFillColor field in the DDCOMPOSEFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDCOMP_COLORFILL                        0x00000400l

/*
 * Uses the dwDDFX field in the DDCOMPOSEFX structure to specify the effects
 * to use for the blt.
 */
#define DDCOMP_DDFX                             0x00000800l

/*
 * Uses the dwDDROPS field in the DDCOMPOSEFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDCOMP_DDROPS                           0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDCOMP_KEYDEST                          0x00002000l

/*
 * Use the dckDestColorkey field in the DDCOMPOSEFX structure as the color key
 * for the destination surface.
 */
#define DDCOMP_KEYDESTOVERRIDE                  0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDCOMP_KEYSRC                           0x00008000l

/*
 * Use the dckSrcColorkey field in the DDCOMPOSEFX structure as the color key
 * for the source surface.
 */
#define DDCOMP_KEYSRCOVERRIDE                   0x00010000l

/*
 * Do this blt when DestUnlock is called for the last time on the source surface.
 */
#define DDCOMP_ONDESTUNLOCK                     0x00020000l

/*
 * Do this blt when Flip is called on the source surface.
 */
#define DDCOMP_ONFLIP                           0x00040000l

/*
 * Do this blt when Unlock is called for the last time on the source surface.
 */
#define DDCOMP_ONUNLOCK                         0x00080000l

/*
 * Repeat this composition blt the number of times specified in the dwRepeat
 * field of the DDCOMPOSEFX structure
 */
#define DDCOMP_REPEAT                           0x00100000l

/*
 * Use the dwROP field in the DDCOMPOSEFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDCOMP_ROP                              0x00200000l

/*
 * Use the dwRotationAngle field in the DDCOMPOSEFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDCOMP_ROTATIONANGLE                    0x00400000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDCOMP_ZBUFFER                          0x00800000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDCOMP_ZBUFFERDESTCONSTOVERRIDE         0x01000000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDCOMP_ZBUFFERDESTOVERRIDE              0x02000000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDCOMP_ZBUFFERSRCCONSTOVERRIDE          0x04000000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDCOMP_ZBUFFERSRCOVERRIDE               0x08000000l
#endif
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l

//@@BEGIN_MSINTERNAL
/*
 * Force redrawing onto the destination surface without regard for the background
 */
#define DDOVER_REFRESHPOUND                     0x00040000l
//@@END_MSINTERNAL

/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                         0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                              0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE                 0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED                      0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE                      0x01000000l

/*
 * Indicates that overlay FX structure contains valid ARGB scaling factors.
 */
#define DDOVER_ARGBSCALEFACTORS                 0x02000000l

/*
 * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
 */
#define DDOVER_DEGRADEARGBSCALING               0x04000000l

//@@BEGIN_MSINTERNAL
#define DDOVER_VALID                            0x07ffffffl
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for dwFlags member of DDSPRITE structure
 *
 ****************************************************************************/

/*
 * Use the color key associated with the destination surface.
 */
#define DDSPRITE_KEYDEST                        0x00000001l

/*
 * Uses the dest color key value stored in the embedded DDSPRITEFX
 * structure instead of the color key stored in the dest surface.
 */
#define DDSPRITE_KEYDESTOVERRIDE                0x00000002l

/*
 * Use the color key associated with the source surface.
 */
#define DDSPRITE_KEYSRC                         0x00000004l

/*
 * Uses the source color key value stored in the embedded DDSPRITEFX
 * structure instead of the color key stored in the source surface.
 */
#define DDSPRITE_KEYSRCOVERRIDE                 0x00000008l

/*
 * Indicates that the rcSrc member contains a valid source rectangle.
 */
#define DDSPRITE_RECTSRC                        0x00000010l

/*
 * Indicates that the rcDest member contains a valid destination rectangle.
 */
#define DDSPRITE_RECTDEST                       0x00000020l

/*
 * Indicates that the ddSpriteFX member contains a valid DDSPRITEFX value.
 */
#define DDSPRITE_DDSPRITEFX                     0x00000040l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Mask of valid DDSPRITE_ flag bits
#define DDSPRITE_VALID                          0x0000006fl
//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for SetSpriteDisplayList API call
 *
 ****************************************************************************/

/*
 * Sprites in display list are to be blitted to destination surface.
 */
#define DDSSDL_BLTSPRITES                       0x00000001l

/*
 * Sprites in display list are to be displayed as overlays on dest (primary) surface.
 */
#define DDSSDL_OVERLAYSPRITES                   0x00000002l

/*
 * Sprites in display list are sorted in back-to-front order (default is F-to-B).
 */
#define DDSSDL_BACKTOFRONT                      0x00000004l

/*
 * Perform page flip of primary surface at same time new display list is shown.
 */
#define DDSSDL_PAGEFLIP                         0x00000008l

/*
 * If hardware acceleration is unavailable, fail rather than emulate.
 */
#define DDSSDL_HARDWAREONLY                     0x00000010l

/*
 * Wait to return until driver is ready to accept new sprite display list.
 */
#define DDSSDL_WAIT                             0x00000020l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Mask of all valid DDSSDL_ flag bits
#define DDSSDL_VALID                            0x0000003fl
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L

//@@BEGIN_MSINTERNAL
/*
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces not explicitly in system memory.
 */
#define DDLOCK_TAKE_WIN16                       0x00000040L

/*
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces in video memory only
 */
#define DDLOCK_TAKE_WIN16_VRAM                  0x00000080L

/*
 * Indicates that InternalLock should check for lost surfaces. By
 * default it does not.
 */
#define DDLOCK_FAILLOSTSURFACES                 0x00000100L

/*
 * Indicates that InternalLock should fail if the vis rgn has changed
 * since it was last queried.  This flag is only used on NT.
 */
#define DDLOCK_FAILONVISRGNCHANGED              0x00000200L

/*
 * This flag is used by the API DD_Surface_Lock to force InternalLock
 * to fail an attempt to lock an emulated primary on NT.
 * This is a symptom of the two-headed nature of InternalLock: it both
 * locks a surface (increases its usage count) and returns a pointer
 * to the bits. An emulated blt on NT requires the first but cares not about the
 * second. DD_Surface_Lock needs the pointer, so it must fail when the
 * second function of InternalLock fails.
 */
#define DDLOCK_FAILEMULATEDNTPRIMARY            0x00000400L

//@@END_MSINTERNAL

/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L

/*
 * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
 * that were referred to in Draw*PrimtiveVB calls since the start of the
 * frame (or the last lock without this flag) will be modified during the
 * lock. This can be useful when one is only appending data to the vertex
 * buffer
 */
#define DDLOCK_NOOVERWRITE                      0x00001000L

/*
 * Indicates that no assumptions will be made about the contents of the
 * surface or vertex buffer during this lock.
 * This enables two things:
 * -    Direct3D or the driver may provide an alternative memory
 *      area as the vertex buffer. This is useful when one plans to clear the
 *      contents of the vertex buffer and fill in new data.
 * -    Drivers sometimes store surface data in a re-ordered format.
 *      When the application locks the surface, the driver is forced to un-re-order
 *      the surface data before allowing the application to see the surface contents.
 *      This flag is a hint to the driver that it can skip the un-re-ordering process
 *      since the application plans to overwrite every single pixel in the surface
 *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
 *      Applications should always set this flag when they intend to overwrite the entire
 *      surface or locked rectangle.
 */
#define DDLOCK_DISCARDCONTENTS                  0x00002000L
 /*
  * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
  */
#define DDLOCK_OKTOSWAP                         0x00002000L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
 */
#define DDLOCK_DONOTWAIT                        0x00004000L

/*
 * This indicates volume texture lock with front and back specified.
 */
#define DDLOCK_HASVOLUMETEXTUREBOXRECT          0x00008000L

/*
 * This indicates that the driver should not update dirty rect information for this lock.
 */
#define DDLOCK_NODIRTYUPDATE                    0x00010000L

//@@BEGIN_MSINTERNAL
/*
 * An aggregate of all the valid flags which can be passed into the API
 */
#define DDLOCK_VALID                            0x00017831L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGELOCK_VALID                        0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGEUNLOCK_VALID                      0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE COMP FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDCOMPFX_ARITHSTRETCHY                  0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDCOMPFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDCOMPFX_MIRRORUPDOWN                   0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDCOMPFX_NOTEARING                      0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDCOMPFX_ROTATE180                      0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDCOMPFX_ROTATE270                      0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDCOMPFX_ROTATE90                       0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDCOMPFX_ZBUFFERRANGE                   0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDCOMPFX_ZBUFFERBASEDEST                0x00000100l
//@@END_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

/*
 * Deinterlace the overlay, if possible
 */
#define DDOVERFX_DEINTERLACE                    0x00000008l

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for dwDDFX member of DDSPRITEFX structure
 *
 ****************************************************************************/
/*
 * Use affine transformation matrix in fTransform member.
 */
#define DDSPRITEFX_AFFINETRANSFORM              0x00000001l

/*
 * Use RGBA scaling factors in ddargbScaleFactors member.
 */
#define DDSPRITEFX_RGBASCALING                  0x00000002l

/*
 * Degrade RGBA scaling factors to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADERGBASCALING           0x00000004l

/*
 * Do bilinear filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BILINEARFILTER               0x00000008l

/*
 * Do "blur" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BLURFILTER                   0x00000010l

/*
 * Do "flat" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_FLATFILTER                   0x00000020l

/*
 * Degrade filtering operation to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADEFILTER                0x00000040l

// mask of valid DDSPRITEFX_ flags
#define DDSPRITEFX_VALID                        0x0000007fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l
// @@BEGIN_MSINTERNAL
#define DDGFS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l

// @@BEGIN_MSINTERNAL
#define DDGBS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l

// @@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * CREATE/LOAD SURFACE FROM STREAM/FILE FLAGS
 * Valid for:
 *     IDirectDraw4::CreateSurfaceFromStream
 *     IDirectDraw4::CreateSurfaceFromFile
 *     IDirectDrawSurface4::LoadFromStream
 *     IDirectDrawSurface4::LoadFromFile
 *
 ****************************************************************************/

/*
 * Any palette information in the stream will be discarded.
 * Mutually exclusive with DDLS_MERGEEPALETTE
 * If neither DDLS_IGNOREPALETTE nor DDLS_MERGEPALETTE are specified, then any palette information
 * in the stream will be loaded into a new DirectDrawPalette and attached to the surface.
 */
#define DDLS_IGNOREPALETTE                      0x00000001L

/*
 * Any palette information in the stream/file will be matched against all existing DirectDrawPalettes.
 * Any matching palette will be attached to the surface. If no palette matches, a new palette is created
 * and attached to the surface.
 * Mutually exclusive with DDLS_IGNOREPALETTE
 * If neither DDLS_IGNOREPALETTE nor DDLS_MERGEPALETTE are specified, then any palette information
 * in the stream will be loaded into a new DirectDrawPalette and attached to the surface.
 */
#define DDLS_MERGEPALETTE                      0x00000002L

/*
 * The source image will be stretched to fit the specified width.
 * Valid only if the DDSURFACEDESC2 passed to the function has valid width and height members,
 * or if passed to IDirectDrawSurface4::LoadFromFile/Stream.
 * Note that if the specified target width or height is smaller than the source dimension, the
 * source image will be shrunken in that dimension regardless of the setting of this flag.
 */
#define DDLS_STRETCHTOFIT                       0x00000004L

/*
 * If stretched, the source image will be bilinear filtered.
 * Valid only if DDLS_STRETCHTOFIT is specified.
 */
#define DDLS_BILINEARFILTER                     0x00000008L

/*
 * The source image will be stretched only as far as is possible maintaining the
 * height to width ratio of the source image.
 * Valid only if DDLS_STRETCHTOFIT is specified.
 */
#define DDLS_MAINTAINASPECTRATIO                0x00000010L

/*
 * The source image will be centered in the target surface. If this flag is not specified,
 * the image will be placed in the upper left corner of the surface.
 * Any unused space will be initialized to zero.
 * Valid only if the DDSURFACEDESC2 passed to the function has valid width and height members,
 * or if passed to IDirectDrawSurface4::LoadFromFile/Stream.
 */
#define DDLS_CENTER                             0x00000020L
// @@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDLS_VALID                              0x0000003FL
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L

//@@BEGIN_MSINTERNAL
#define DDSGR_VALID                            0x00000001L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW STARTMODETEST FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDSMT_ISTESTREQUIRED                   0x00000001L

//@@BEGIN_MSINTERNAL
#define DDSMT_VALID                            0x00000001L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW EVALUATEMODE FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDEM_MODEPASSED                        0x00000001L

/*
 * Indicates that the mode being tested has failed
 */
#define DDEM_MODEFAILED                        0x00000002L

//@@BEGIN_MSINTERNAL
#define DDEM_VALID                             0x00000003L
//@@END_MSINTERNAL

/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
//@@BEGIN_MSINTERNAL
#define DD_OK_HANDLED                           1
#define DD_OK_NOTHANDLED                        0
//@@END_MSINTERNAL
#define DD_OK                                   S_OK
#define DD_FALSE                                S_FALSE

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL                        0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK                            1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
//@@BEGIN_MSINTERNAL
 * NOTE: To avoid collision with other DX APIs, DDraw uses error codes
 *       [5-699] and [1024-2048].
//@@END_MSINTERNAL
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         MAKE_DDHRESULT( 180 )

/*
 * Operation could not be carried out because there is no stereo
 * hardware present or available.
 */
#define DDERR_NOSTEREOHARDWARE          MAKE_DDHRESULT( 181 )

/*
 * Operation could not be carried out because there is no hardware
 * present which supports stereo surfaces
 */
#define DDERR_NOSURFACELEFT                             MAKE_DDHRESULT( 182 )


// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for synchronizing blts to avoid tearing.
 */
#define DDERR_NOANTITEARHW                      MAKE_DDHRESULT( 190 )

/*
 * Operation could not be carried out because there is no hardware support
 * for asynchronous blting.
 */
#define DDERR_NOBLTQUEUEHW                      MAKE_DDHRESULT( 200 )
// @@END_MSINTERNAL

/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS                  MAKE_DDHRESULT( 270 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       E_NOTIMPL

/*
 * Pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   MAKE_DDHRESULT( 520 )

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   MAKE_DDHRESULT( 540 )

// @@BEGIN_MSINTERNAL

/*
 * NT specific: VisRgn changed and must be reset before call can be
 * completed.
 */
#define DDERR_VISRGNCHANGED             MAKE_DDHRESULT( 541 )

// @@END_MSINTERNAL

/*
 * The specified surface type requires specification of the COMPLEX flag
 */
#define DDERR_DDSCAPSCOMPLEXREQUIRED            MAKE_DDHRESULT( 542 )


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                MAKE_DDHRESULT( 580 )

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC                      MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )

// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for execute buffers.
 */
#define DDERR_NOEXECUTEBUFFERHW                 MAKE_DDHRESULT( 593 )
// @@END_MSINTERNAL

// @@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * This process has already created a shared Z buffer
 */
#define DDERR_SHAREDZBUFFERALREADYEXISTS        MAKE_DDHRESULT( 594 )

/*
 * Unable to match shared Z buffer creation request with existing
 * shared Z buffer.
 */
#define DDERR_INCOMPATIBLESHAREDZBUFFER         MAKE_DDHRESULT( 595 )

/*
 * This process has already created a shared backbuffer
 */
#define DDERR_SHAREDBACKBUFFERALREADYEXISTS     MAKE_DDHRESULT( 596 )

/*
 * Unable to match shared backbuffer creation request with existing
 * shared backbuffer.
 */
#define DDERR_INCOMPATIBLESHAREDBACKBUFFER      MAKE_DDHRESULT( 597 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared Z buffers.
 */
#define DDERR_NOSHAREDZBUFFERHW                 MAKE_DDHRESULT( 598 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared backbuffers.
 */
#define DDERR_NOSHAREDBACKBUFFERHW              MAKE_DDHRESULT( 599 )

#endif
// @@END_MSINTERNAL

/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )

/*
 * Attempt was made to set a palette on a mipmap sublevel
 */
#define DDERR_NOTONMIPMAPSUBLEVEL               MAKE_DDHRESULT( 603 )

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  MAKE_DDHRESULT( 620 )

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      MAKE_DDHRESULT( 640 )

//@@BEGIN_MSINTERNAL
/*
 * The GUID is not recognized by the driver. In case of Optimized Surfaces,
 * this GUID represents the compresison technique requested.
 */
#define DDERR_UNRECOGNIZEDGUID                  MAKE_DDHRESULT( 650 )

/*
 * The driver does not support Optimized Surfaces
 */
#define DDERR_NOOPTSURFACESUPPORT       MAKE_DDHRESULT( 651 )

/*
 * The surface is not an optimized surface
 */
#define DDERR_NOTANOPTIMIZEDSURFACE     MAKE_DDHRESULT( 652 )

/*
 * The surface is an empty optimized surface
 */
#define DDERR_ISANEMPTYOPTIMIZEDSURFACE         MAKE_DDHRESULT( 653 )

/*
 * The surface is not an empty optimized surface
 */
#define DDERR_NOTANEMPTYOPTIMIZEDSURFACE        MAKE_DDHRESULT( 654 )

/*
 * The surface is optimized
 */
#define DDERR_ISOPTIMIZEDSURFACE        MAKE_DDHRESULT( 655 )
//@@END_MSINTERNAL

/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     MAKE_DDHRESULT( 680 )

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA                          MAKE_DDHRESULT( 690 )

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )

/*
 * The mode test has finished executing.
 */
#define DDERR_TESTFINISHED                      MAKE_DDHRESULT( 692 )

/*
 * The mode test has switched to a new mode.
 */
#define DDERR_NEWMODE                           MAKE_DDHRESULT( 693 )

/*
 * D3D has not yet been initialized.
 */
#define DDERR_D3DNOTINITIALIZED                 MAKE_DDHRESULT( 694 )

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE                    MAKE_DDHRESULT( 695 )

/*
 * The monitor does not have EDID data.
 */
#define DDERR_NOMONITORINFORMATION              MAKE_DDHRESULT( 696 )

/*
 * The driver does not enumerate display mode refresh rates.
 */
#define DDERR_NODRIVERSUPPORT                   MAKE_DDHRESULT( 697 )

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE            MAKE_DDHRESULT( 699 )


//@@BEGIN_MSINTERNAL
/*=======================================================================
 * DANGER WIL ROBINSON! D3D errors begin at 700... take care not to
 * step on D3dD's toes when defining new ddraw errors.
 *=======================================================================*/
/****************************************************************************
 *
 * end of DIRECTDRAW ERRORS
 *
 * NOTE: To avoid collision with other DX APIs, DDraw uses error codes
 *       [5-699] and [1024-2048].
 *
 ****************************************************************************/
//@@END_MSINTERNAL

/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED


/* Alpha bit depth constants */

//@@BEGIN_MSINTERNAL
/*
 * 1 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not affect
 * the final result.
 */
#define DDALPHA1_TRANSPARENT                    0

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA1_OPAQUE                         1

/*
 * 2 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA2_TRANSPARENT                    0

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA2_50                             2

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA2_OPAQUE                         3

/*
 * 4 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA4_TRANSPARENT                    0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA4_OPAQUEMOD                      1

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA4_50                             8

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA4_OPAQUE                         15

/*
 * 8 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA8_TRANSPARENT                    0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA8_OPAQUEMOD                      1

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA8_50                             128
/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA8_OPAQUE                         255
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(default:4201)
#endif

#endif //__DDRAW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   06-jan-95  craige  video memory manager
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   22-feb-95  craige  use critical sections on Win95
 *   27-feb-95  craige  new sync. macros
 *   03-mar-95  craige  WaitForVerticalBlank stuff
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  GetFourCCCodes
 *   11-mar-95  craige  palette stuff
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   26-mar-95  craige  added TMPALLOC and TMPFREE
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  switched to PALETTEENTRY from RGBQUAD
 *   29-mar-95  craige  debug memory manager; build.h; hacks for DLL
 *                      unload problem...
 *   31-mar-95  craige  use critical sections with palettes
 *   03-apr-95  craige  added MAKE_SURF_RECT
 *   04-apr-95  craige  added DD_GetPaletteEntries, DD_SetPaletteEntries
 *   06-apr-95  craige  split out process list stuff; fill in free vidmem
 *   12-apr-95  craige  add debugging to CSECT macros
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   14-may-95  craige  added DoneExclusiveMode, DD16_EnableReboot; cleaned out
 *                      obsolete junk
 *   23-may-95  craige  no longer use MapLS_Pool; added Flush, GetBatchLimit
 *                      and SetBatchLimit
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  unicode support; cleaned up HAL: added GetBltStatus;
 *                      GetFlipStatus; GetScanLine
 *   02-jun-95  craige  added SetDisplayMode
 *   04-jun-95  craige  added AllocSurfaceMem, IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  added RestoreDisplayMode
 *   07-jun-95  craige  added StartExclusiveMode
 *   10-jun-95  craige  split out vmemmgr stuff
 *   13-jun-95  kylej   move FindAttachedFlip to misc.c, added CanBeFlippable
 *   18-jun-95  craige  specify pitch for rectangular heaps
 *   20-jun-95  craige  added DD16_InquireVisRgn; make retail builds
 *                      not bother to check for NULL (since there are 4
 *                      billion other invalid ptrs we don't check for...)
 *   21-jun-95  craige  new clipper stuff
 *   23-jun-95  craige  ATTACHED_PROCESSES stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   30-jun-95  kylej   function prototypes to support mult. prim. surfaces
 *   30-jun-95  craige  changed GET_PIXEL_FORMAT to use HASPIXELFORMAT flag
 *   01-jul-95  craige  hide composition & streaming stuff
 *   02-jul-95  craige  SEH macros; added DD16_ChangeDisplaySettings
 *   03-jul-95  kylej   Changed EnumSurfaces declaration
 *   03-jul-95  craige  YEEHAW: new driver struct; Removed GetProcessPrimary
 *   05-jul-95  craige  added Initialize fn to each object
 *   07-jul-95  craige  added some VALIDEX_xxx structs
 *   07-jul-95  kylej   proto XformRect, STRETCH_X and STRETCH_Y macros
 *   08-jul-95  craige  added FindProcessDDObject; added InvalidateAllSurfaces
 *   09-jul-95  craige  added debug output to win16 lock macro; added
 *                      ComputePitch, added hasvram flag to MoveToSystemMemory;
 *                      changed SetExclusiveMode to SetCooperativeLevel;
 *                      added ChangeToSoftwareColorKey
 *   10-jul-95  craige  support SetOverlayPosition
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock;
 *                      Get/SetOverlayPosition takes LONGs
 *   13-jul-95  toddla  remove _export from thunk functions
 *   18-jul-95  craige  removed DD_Surface_Flush
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   28-jul-95  craige  go back to private DDRAW lock
 *   31-jul-95  craige  added DCIIsBanked
 *   01-aug-95  craige  added ENTER/LEAVE_BOTH; DOHALCALL_NOWIN16
 *   04-aug-95  craige  added InternalLock/Unlock
 *   10-aug-95  toddla  changed proto of EnumDisplayModes
 *   10-aug-95  toddla  added VALIDEX_DDSURFACEDESC_PTR
 *   12-aug-95  craige  added use_full_lock parm to MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   13-aug-95  craige  flags parm for Flip
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 735: added SetPaletteAlways
 *                      bug 738: use GUID instead of IID
 *   02-sep-95  craige  bug 786: verify dwSize in retail
 *   04-sep-95  craige  bug 894: force flag to SetDisplayMode
 *   10-sep-95  toddla  added string ids
 *   21-sep-95  craige  bug 1215: added DD16_SetCertified
 *   11-nov-95  colinmc added new pointer validition macro for byte arrays
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   10-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   25-dec-95  craige  added class factory support
 *   31-dec-95  craige  added VALID_IID_PTR
 *   26-jan-96  jeffno  FlipToGDISurface now only takes 1 arg
 *   09-feb-96  colinmc local surface objects now have invalid surface flag
 *   12-feb-96  jeffno  Cheaper Mutex implementation for NT
 *   15-feb-96  jeffno  GETCURRENTPID needs to call HackCurrentPID on both 95 and NT
 *   17-feb-96  colinmc Removed dependency on Direct3D include files
 *   24-feb-96  colinmc Added prototype for new member which is used to
 *                      determine if the callback tables have already been
 *                      initialized.
 *   02-mar-96  colinmc Simply disgusting and temporary hack to keep
 *                      interim drivers working
 *   14-mar-96  colinmc Changes for the clipper class factory
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   22-mar-96  colinmc Bug 13316: Uninitialized interfaces
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   10-apr-96  colinmc Bug 16903: HEL using obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notifcation of flip to GDI
 *   15-apr-96  colinmc Bug 16885: Can't pass NULL to initialize in C++
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   26-mar-96  jeffno  Removed cheap mutexes. Added check for mode change for NT's
 *                      ENTERDDRAW.
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture or
 *                      device interface
 *   11-may-96  colinmc Bug 22293: New macro to validate GUID even if not
 *                      in debug
 *   17-may-96  kylej   Bug 23301: validate DDHALINFO size >= current size
 *   28-jul-96  colinmc Bug 2613:  Minimal support for secondary (stacked)
 *                                 drivers.
 *   16-aug-96  craige  include ddreg.h, added dwRegFlags + flag defns
 *   03-sep-96  craige  added app compat stuff.
 *   23-sep-96  ketand  added InternalGetClipList
 *   01-oct-96  ketand  added TIMING routings
 *   05-oct-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc New ref flag to control the enabling and disabling
 *                      of PrintScreen
 *   02-jan-97  colinmc Initial AGP implementation work
 *   12-jan-97  colinmc More Win16 lock work
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   18-jan-97  colinmc AGP VMM support
 *   21-jan-97  ketand  Change DD16_SetPaletteEntries for multi-mon. Deleted
 *                      unused code.
 *   26-jan-97  ketand  Remove unused DD16_GetPaletteEntries. (It didn't handle
 *                      multi-mon; and wasn't worth fixing.) Also, remove
 *                      globals that don't work anymore with multi-mon.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *                      added DD16_GetDeviceConfig
 *   02-feb-97  colinmc Bug 5625: V1.0 DirectX drivers don't get recognized
 *                      due to bad size check on DDCALLBACKS
 *   05-feb-97  ketand  Remove unused parameter from ClipRgnToRect
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   04-mar-97  ketand  Added UpdateOutstandingDC to track palette changes
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   22-mar-97  colinmc Bug 6673: Add compile time option to allow new
 *                      applications to run against legacy run times.
 *   23-mar-97  colinmc Bug 6673 again: Changed structure numbering scheme
 *                      for consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Moved AGP support detection from misc.c to ddagp.c
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   26-nov-97 t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#if defined( WIN95 ) && !defined ( NT_BUILD_ENVIRONMENT )
#undef PBT_APMRESUMEAUTOMATIC
    #include <pbt.h>
#endif

//#ifdef NT_BUILD_ENVIRONMENT
    /*
     * These are various definitions brought over from the win95 world, just to get us
     * compiling under the NT headers.
     */
    #ifdef WIN32
        /*
         * These come from \proj\dev\sdk\inc\winbase.h
         */
        #define FILE_FLAG_GLOBAL_HANDLE         0x00800000  // ;internal
        VOID    // ;internal
        WINAPI  // ;internal
        ReinitializeCriticalSection(    // ;internal
            LPCRITICAL_SECTION lpCriticalSection        // ;internal
            );  // ;internal

       //
       // Windows 9x stuff
       //

       #define CDS_EXCLUSIVE       0x80000000
       #define DISPLAY_DEVICE_VGA  0x00000010
       #define DCX_USESTYLE        0x00010000

    #endif //IS_32


    /*
     * These two come from \proj\dev\msdev\include\pbt.h
     */
    #define PBT_APMSUSPEND                  0x0004
    #define PBT_APMSTANDBY                  0x0005

//#endif //NT_BUILD_ENVIRONMENT

#include <string.h>
#include <stddef.h>

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #include <dibeng.inc>
    #ifndef HARDWARECURSOR
        //#pragma message("defining local version of HARDWARECURSOR")
        #define HARDWARECURSOR 0x0100 // new post-Win95 deFlag
    #endif
#else
    #define IID void
#endif

#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

/*
 * application compat. stuff
 */
#define DDRAW_APPCOMPAT_MODEXONLY           0x00000001l
#define DDRAW_APPCOMPAT_NODDSCAPSINDDSD     0x00000002l
#define DDRAW_APPCOMPAT_MMXFORRGB           0x00000004l
#define DDRAW_APPCOMPAT_EXPLICITMONITOR     0x00000008l
#define DDRAW_APPCOMPAT_SCREENSAVER         0x00000010l
#define DDRAW_APPCOMPAT_FORCEMODULATED      0x00000020l
#define DDRAW_APPCOMPAT_TEXENUMINCL_0       0x00000040l  // two bit field
#define DDRAW_APPCOMPAT_TEXENUMINCL_1       0x00000080l
#define DDRAW_APPCOMPAT_VALID               0x000000ffl

#define DDRAW_REGFLAGS_MODEXONLY        0x00000001l
#define DDRAW_REGFLAGS_EMULATIONONLY    0x00000002l
#define DDRAW_REGFLAGS_SHOWFRAMERATE    0x00000004l
#define DDRAW_REGFLAGS_ENABLEPRINTSCRN  0x00000008l
#define DDRAW_REGFLAGS_FORCEAGPSUPPORT  0x00000010l
#define DDRAW_REGFLAGS_DISABLEMMX       0x00000020l
#define DDRAW_REGFLAGS_DISABLEWIDESURF  0x00000040l
#define DDRAW_REGFLAGS_AGPPOLICYMAXBYTES 0x00000200l
#define DDRAW_REGFLAGS_FORCEREFRESHRATE 0x00008000l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLENOSYSLOCK  0x00000080l
    #define DDRAW_REGFLAGS_FORCENOSYSLOCK    0x00000100l
#endif
#define DDRAW_REGFLAGS_NODDSCAPSINDDSD  0x00000400l
#define DDRAW_REGFLAGS_DISABLEAGPSUPPORT 0x00000800l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLEINACTIVATE 0x00001000l
    #define DDRAW_REGFLAGS_PREGUARD          0x00002000l
    #define DDRAW_REGFLAGS_POSTGUARD         0x00004000l
#endif
#define DDRAW_REGFLAGS_USENONLOCALVIDMEM    0x00010000l

#define DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES 0x00008000l

extern  DWORD dwRegFlags;

#include "memalloc.h"

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #include <objbase.h>
#else
    #define IUnknown void
#endif
#include "ddrawi.h"
#include "dwininfo.h"

#ifdef WIN95
    #include "..\ddraw16\modex.h"
#endif

/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif

/*
 * Driver version info
 */

//========================================================================
// advanced driver information
//========================================================================
typedef struct tagDDDRIVERINFOEX
{
        DDDEVICEIDENTIFIER      di;
        char                    szDeviceID[MAX_DDDEVICEID_STRING];
} DDDRIVERINFOEX, * LPDDDRIVERINFOEX;



/*
 * Direct3D interfacing defines.
 */
#ifndef NO_D3D
#include "ddd3dapi.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95
    #define USE_CRITSECTS
    extern void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent );
    extern void DDAPI DD16_DoneDriver( DWORD hInstance );
    extern void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS list );
    extern void DDAPI DD16_GetHALInfo( LPDDHALINFO pinfo );
    extern LONG DDAPI DD16_ChangeDisplaySettings( LPDEVMODE pdm, DWORD flags);
    extern HRGN DDAPI DD16_InquireVisRgn( HDC );
    extern void DDAPI DD16_SelectPalette( HDC, HPALETTE, BOOL );
    extern BOOL DDAPI DD16_SetPaletteEntries( HDC hdc, DWORD dwBase, DWORD dwNum, LPPALETTEENTRY, BOOL fPrimary );
    extern void DDAPI DD16_EnableReboot( BOOL );
    extern void DDAPI DD16_SetCertified( BOOL iscert );
    extern BOOL DDAPI DCIIsBanked( HDC hdc );
    #define GETCURRPID HackGetCurrentProcessId
    VOID WINAPI MakeCriticalSectionGlobal( CSECT_HANDLE lpcsCriticalSection );

    extern HDC  DDAPI DD16_GetDC(HDC hdc, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette);
    extern void DDAPI DD16_ReleaseDC(HDC hdc);
    extern BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode);

    extern void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl);
    extern void DDAPI DD16_Unexclude(DWORD dwPDevice);

    extern int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY);
    extern BOOL DDAPI DD16_IsWin95MiniDriver( void );
    extern int  DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice);
    extern BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax);
    extern DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD size);
    extern BOOL DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData);
    extern DWORD DDAPI DD16_GetRateFromRegistry( LPSTR szDevice );
    extern int DDAPI DD16_SetRateInRegistry( LPSTR szDevice, DWORD dwRateToRestore );

    #ifdef USE_ALIAS
        extern BOOL DDAPI DD16_FixupDIBEngine( void );
    #endif /* USE_ALIAS */
    extern WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate);
    extern BOOL DDAPI DD16_AttemptGamma(HDC hdc);
    extern BOOL DDAPI DD16_IsDeviceBusy(HDC hdc);

#else
    #define DD16_DoneDriver( hInstance ) 0
    #define DD16_GetDriverFns( list ) 0
    #define DD16_GetHALInfo( pinfo ) 0
    #define DD16_ChangeDisplaySettings( pdm, flags) ChangeDisplaySettings( pdm, flags )
    #define DD16_SelectPalette( hdc, hpal ) SelectPalette( hdc, hpal, FALSE )
    #define DD16_EnableReboot( retboot ) 0
    #define DD16_WWOpen( ptr ) 0
    #define DD16_WWClose( ptr, newlist ) 0
    #define DD16_WWNotifyInit( pww, lpcallback, param ) 0
    #define DD16_WWGetClipList( pww, prect, rdsize, prd ) 0
    //
    // On NT, it is an assert that we are never called by DDHELP, so we should always be
    // working on the current process.
    //
    #define GETCURRPID GetCurrentProcessId
    #define DCIIsBanked( hdc ) FALSE
    #define DD16_IsWin95MiniDriver() TRUE
    #define DD16_SetCertified( iscert ) 0
    #define DD16_GetMonitorMaxSize(dev) 0
    #define DD16_GetMonitorRefreshRateRanges( dev, xres, yres, pmin, pmax) 0
    #define DD16_GetRateFromRegistry( szDevice ) 0
    #define DD16_SetRateInRegistry( szDevice, dwRateToRestore ) 0
    #ifdef USE_ALIAS
        #define DD16_FixupDIBEngine() TRUE
    #endif /* USE_ALIAS */
    #define DD16_AttemptGamma( hdc) 0
    #define DD16_IsDeviceBusy( hdc) 0
#endif

#ifndef NO_DDHELP
    #include "w95help.h"
#endif //NO_DDHELP

#define TRY             _try
#define EXCEPT(a)       _except( a )

extern LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

/*
 * list of processes attached to DLL
 */
typedef struct ATTACHED_PROCESSES
{
    struct ATTACHED_PROCESSES   *lpLink;
    DWORD                       dwPid;
#ifdef WINNT
    DWORD                       dwNTToldYet;
#endif
} ATTACHED_PROCESSES, FAR *LPATTACHED_PROCESSES;

//extern LPATTACHED_PROCESSES   lpAttachedProcesses;

/* Structure for keeping track of DCs that have
 * been handed out by DDraw for surfaces.
 */
typedef struct _dcinfo
{
    HDC hdc;                            // HDC associated with surface
    LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl; // Surface associated with HDC
    struct _dcinfo * pdcinfoNext;       // Pointer to next
} DCINFO, *LPDCINFO;
/*
 *  Head of the list of DCs handed out.
 */
extern DCINFO *g_pdcinfoHead;

/*
 * macros for doing allocations of a temporary basis.
 * Tries alloca first, if that fails, it will allocate storage from the heap
 */
#ifdef USEALLOCA
    #define TMPALLOC( ptr, size ) \
            ptr = _alloca( (size)+sizeof( DWORD ) ); \
            if( ptr == NULL ) \
            { \
                ptr = MemAlloc( (size)+sizeof( DWORD ) ); \
                if( ptr != NULL ) \
                { \
                    *(DWORD *)ptr = 1; \
                    (LPSTR) ptr += sizeof( DWORD ); \
                } \
            } \
            else \
            { \
                *(DWORD *)ptr = 0; \
                (LPSTR) ptr += sizeof( DWORD ); \
            }

    #define TMPFREE( ptr ) \
            if( ptr != NULL ) \
            { \
                (LPSTR) ptr -= sizeof( DWORD ); \
                if( (*(DWORD *) ptr) ) \
                { \
                    MemFree( ptr ); \
                } \
            }
#else

    #define TMPALLOC( ptr, size )  ptr = MemAlloc( size );
    #define TMPFREE( ptr )  MemFree( ptr );

#endif

/*
 * macros for getting at values that aren't always present in the surface
 * object
 */
#define GET_PIXEL_FORMAT( thisx, thisl, pddpf ) \
    if( thisx->dwFlags & DDRAWISURF_HASPIXELFORMAT ) \
    { \
        pddpf = &thisl->ddpfSurface; \
    } \
    else \
    { \
        pddpf = &thisl->lpDD->vmiData.ddpfDisplay; \
    }

/*
 * macro for building a rectangle that is the size of a surface.
 * For multi-monitor systems, we have a different code path
 * to deal with the fact that the upper-left coord may not be zero.
 */
#define MAKE_SURF_RECT( surf, surf_lcl, r ) \
    r.top = 0;                  \
    r.left = 0;                 \
    r.bottom = (DWORD) surf->wHeight; \
    r.right = (DWORD) surf->wWidth;

/*
 * macro for doing doing HAL call.
 *
 * Takes the Win16 lock for 32-bit Win95 driver routines.  This serves a
 * 2-fold purpose:
 *      1) keeps the 16-bit portion of the driver safe
 *      2) 32-bit routine needs lock others out while its updating
 *         its hardware
 */
#if defined( WIN95 ) && defined( WIN16_SEPARATE )
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
        if( (fn != _DDHAL_##halcall) && !isHEL ) { \
            ENTER_WIN16LOCK(); \
            rc = fn( &data ); \
            LEAVE_WIN16LOCK(); \
        } else { \
            rc = fn( &data ); \
        }

    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            rc = fn( &data );
#else
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
#endif


/*
 * macro for incrementing/decrementing the driver ref count
 */
#define CHANGE_GLOBAL_CNT( pdrv, thisg, cnt ) \
    if( !(thisg->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ) \
    { \
        (int) pdrv->dwSurfaceLockCount += (int) (cnt); \
    }


/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * maximum timeout (in ms) when spinlocked on a surface
 */
#define MAX_TIMEOUT     5000

/*
 * defined in dllmain.c
 */
extern CSECT_HANDLE     lpDDCS;
#ifdef WINNT
    extern HANDLE hDriverObjectListMutex;
#else
    #ifdef IS_32
        extern CRITICAL_SECTION csDriverObjectList;
    #endif
#endif
#define MAX_TIMER_HWNDS 15
extern HWND ghwndTopmostList[MAX_TIMER_HWNDS];
extern int giTopmostCnt;
extern BOOL bGammaCalibratorExists;
extern BYTE szGammaCalibrator[MAX_PATH];
extern DWORD dwForceRefreshRate;

/*
 * blt flags
 */
#define DDBLT_PRIVATE_ALIASPATTERN      0x80000000l

/*
 * get the fail code based on what HAL and HEL support; used by BLT
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODEBLT( testhal, testhel, halonly, helonly, flag ) \
    if( halonly ) { \
        if( !(testhal & flag) ) { \
            fail = TRUE; \
        } \
    } else if( helonly ) { \
        if( !(testhel & flag) ) { \
            fail = TRUE; \
        } \
    } else { \
        if( !(testhal & flag) ) { \
            if( !(testhel & flag) ) { \
                fail = TRUE; \
            } else { \
                helonly = TRUE; \
            } \
        } else { \
            halonly = TRUE; \
        } \
    }

/*
 * get the fail code based on what HAL and HEL support
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODE( testhal, testhel, flag ) \
    if( halonly ) \
    { \
        if( !(testhal & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else if( helonly ) \
    { \
        if( !(testhel & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else \
    { \
        if( !(testhal & flag) ) \
        { \
            if( !(testhel & flag) ) \
            { \
                fail = TRUE; \
            } \
            else \
            { \
                helonly = TRUE; \
            } \
        } \
        else \
        { \
            halonly = TRUE; \
        } \
    }


typedef struct {
    DWORD               src_height;
    DWORD               src_width;
    DWORD               dest_height;
    DWORD               dest_width;
    BOOL                halonly;
    BOOL                helonly;
    LPDDHALSURFCB_BLT   bltfn;
    LPDDHALSURFCB_BLT   helbltfn;
} SPECIAL_BLT_DATA, FAR *LPSPECIAL_BLT_DATA;

/*
 * synchronization
 */
#ifdef WINNT
#define RELEASE_EXCLUSIVEMODE_MUTEX {if (hExclusiveModeMutex) ReleaseMutex(hExclusiveModeMutex);}
#else
    #define RELEASE_EXCLUSIVEMODE_MUTEX ;
#endif


//--------------------------------- new cheap mutexes -------------------------------------------
//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD OwningProcess;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;

/*
 * The following functions are defined in mutex.c
 */
BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    );
BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
void
DestroyPIDsLock(
                PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion,
                DWORD                           dwPid,
                LPSTR                           lpName
    );


#define DDRAW_FAST_CS_NAME "DdrawGlobalFastCrit"
extern GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
extern GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess;

#define CHEAP_LEAVE {LeaveGlobalCriticalSection(&CheapMutexPerProcess);}
#define CHEAP_ENTER {EnterGlobalCriticalSection(&CheapMutexPerProcess);}

#ifdef WINNT
//    #define USE_CHEAP_MUTEX
#define NT_USES_CRITICAL_SECTION
#endif

extern void ModeChangedOnENTERDDRAW(void); // in ddmodent.c
extern ULONG uDisplaySettingsUnique;

//
#ifdef IS_32
    #ifndef USE_CRITSECTS
        #define INIT_DDRAW_CSECT()
        #define FINI_DDRAW_CSECT()
        #define ENTER_DDRAW()
        #define LEAVE_DDRAW()
        #define ENTER_DRIVERLISTCSECT()
        #define LEAVE_DRIVERLISTCSECT()
    #else //so use csects:
        #ifdef DEBUG
            //extern int iWin16Cnt;
            //extern int iDLLCSCnt;
            #define INCCSCNT() iDLLCSCnt++;
            #define DECCSCNT() iDLLCSCnt--;
            #define INCW16CNT() iWin16Cnt++;
            #define DECW16CNT() iWin16Cnt--;
        #else
            #define INCCSCNT()
            #define DECCSCNT()
            #define INCW16CNT()
            #define DECW16CNT()
        #endif //debug

        #ifdef WINNT
                extern HANDLE hDirectDrawMutex; //def'd in dllmain.c
                #ifdef USE_CHEAP_MUTEX
                    //--------------------------------- new cheap mutexes -------------------------------------------
                        #define ENTER_DDRAW() {CHEAP_ENTER;}
                        #define ENTER_DDRAW_INDLLMAIN() CHEAP_ENTER
                        #define LEAVE_DDRAW() CHEAP_LEAVE
                    #define INIT_DDRAW_CSECT()                                                                     \
                        {                                                                                          \
                            if (!AttachToGlobalCriticalSection(&CheapMutexPerProcess,&CheapMutexCrossProcess,DDRAW_FAST_CS_NAME) )  \
                                {DPF(0,"===================== Mutex Creation FAILED =================");}          \
                        }

                    #define FINI_DDRAW_CSECT() {DetachFromGlobalCriticalSection(&CheapMutexPerProcess);}

                #else

                    #ifdef NT_USES_CRITICAL_SECTION
                        //
                        // Use critical sections
                        //
                        #define INIT_DDRAW_CSECT() InitializeCriticalSection( lpDDCS );

                        #define FINI_DDRAW_CSECT() DeleteCriticalSection( lpDDCS );

                        extern DWORD gdwRecursionCount;

                        #define ENTER_DDRAW() \
                                {                                                                   \
                                    DWORD dwUniqueness;                                             \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }

                        #define ENTER_DDRAW_INDLLMAIN() \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;

                        #define LEAVE_DDRAW() { gdwRecursionCount--; LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );}


                    #else
                        //
                        // Use a mutex object.
                        //

                        #define INIT_DDRAW_CSECT()                                                      \
                            { if (hDirectDrawMutex) {DPF(0,"Direct draw mutex initialised twice!");}    \
                              else{                                                                     \
                                hDirectDrawMutex = CreateMutex(NULL,FALSE,"DirectDrawMutexName");       \
                                if (!hDirectDrawMutex) {DPF(0,"===================== Mutex Creation FAILED =================");}\
                                }      \
                            }

                        extern DWORD gdwRecursionCount;
                        #define FINI_DDRAW_CSECT() { if (hDirectDrawMutex) CloseHandle(hDirectDrawMutex); }
                        #define LEAVE_DDRAW() { gdwRecursionCount--;ReleaseMutex(hDirectDrawMutex); }
                        #define ENTER_DDRAW()                                                       \
                                {                                                                   \
                                    DWORD dwUniqueness,dwWaitValue;                                 \
                                    dwWaitValue = WaitForSingleObject(hDirectDrawMutex,INFINITE);   \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }
                        #define ENTER_DDRAW_INDLLMAIN() WaitForSingleObject(hDirectDrawMutex,INFINITE);
                    #endif //use (expensive) mutexes
                #endif //use_cheap_mutex

                #define ENTER_DRIVERLISTCSECT() \
                        WaitForSingleObject(hDriverObjectListMutex,INFINITE);
                #define LEAVE_DRIVERLISTCSECT() \
                        ReleaseMutex(hDriverObjectListMutex);

        #else //not winnt:
            #ifdef WIN16_SEPARATE
                #define INIT_DDRAW_CSECT() \
                        ReinitializeCriticalSection( lpDDCS ); \
                        MakeCriticalSectionGlobal( lpDDCS );

                #define FINI_DDRAW_CSECT() \
                        DeleteCriticalSection( lpDDCS );

                #define ENTER_DDRAW() \
                        DPF( 7, "*****%08lx ENTER_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS ); \
                        INCCSCNT(); \
                        DPF( 7, "*****%08lx GOT DDRAW CSECT: CNT = %ld," REMIND(""), GETCURRPID(), iDLLCSCnt );

                #define LEAVE_DDRAW() \
                        DECCSCNT() \
                        DPF( 7, "*****%08lx LEAVE_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );

            #else //not WIN16_SEPARATE

                #define INIT_DDRAW_CSECT()
                #define FINI_DDRAW_CSECT()
                #define ENTER_DDRAW()   \
                            DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _EnterSysLevel( lpWin16Lock ); \
                            INCW16CNT(); \
                            DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
                #define LEAVE_DDRAW() \
                            DECW16CNT() \
                            DPF( 7, "*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _LeaveSysLevel( lpWin16Lock );

            #endif //win16_separate
            #define ENTER_DRIVERLISTCSECT() \
                        EnterCriticalSection( &csDriverObjectList );

            #define LEAVE_DRIVERLISTCSECT() \
                        LeaveCriticalSection( &csDriverObjectList );
        #endif  //winnt
    #endif //use csects

    #if defined(WIN95)
        /*
         * selector management functions
         */
        extern DWORD _stdcall MapLS( LPVOID );  // flat -> 16:16
        extern void _stdcall UnMapLS( DWORD ); // unmap 16:16
        extern LPVOID _stdcall MapSLFix( DWORD ); // 16:16->flat
        extern LPVOID _stdcall MapSL( DWORD ); // 16:16->flat
        //extern void _stdcall UnMapSLFix( LPVOID ); // 16:16->flat
        /*
         * win16 lock
         */
        extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
        extern void _stdcall    _EnterSysLevel( LPVOID );
        extern void _stdcall    _LeaveSysLevel( LPVOID );
        extern LPVOID           lpWin16Lock;
    #endif win95
#endif //is_32

#ifdef WIN95
    #ifdef WIN16_SEPARATE
        #define ENTER_WIN16LOCK()       \
                    DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _EnterSysLevel( lpWin16Lock ); \
                    INCW16CNT(); \
                    DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
        #define LEAVE_WIN16LOCK() \
                    DECW16CNT() \
                    DPF( 7,"*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _LeaveSysLevel( lpWin16Lock );
    #else
        #define ENTER_WIN16LOCK()       badbadbad
        #define LEAVE_WIN16LOCK()       badbadbad
    #endif
#else
    #define ENTER_WIN16LOCK()
    #define LEAVE_WIN16LOCK()
#endif

#ifdef WIN16_SEPARATE
    #define ENTER_BOTH() \
            ENTER_DDRAW(); \
            ENTER_WIN16LOCK();

    #define LEAVE_BOTH() \
            LEAVE_WIN16LOCK(); \
            LEAVE_DDRAW();
#else
    #define ENTER_BOTH() \
            ENTER_DDRAW();
    #define LEAVE_BOTH() \
            LEAVE_DDRAW();
#endif

/* We now have a special case in dllmain on NT... */
#ifndef ENTER_DDRAW_INDLLMAIN
    #define ENTER_DDRAW_INDLLMAIN() ENTER_DDRAW()
#endif

#ifdef WIN95

    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    extern HANDLE hHelperDDVxd;

    /*
     * Macro to return the DirectSound VXD handle to use when communicating with
     * the VXD. This is necessary as we need to communicate with the VXD from
     * DirectDraw executing on a DDHELP thread. In which case we need to use
     * the VXD handle defined above (which is the VXD handle DDHELP got when it
     * loaded DDRAW.VXD). Otherwise, we use the VXD handle out of the given
     * local object.
     *
     * NOTE: We don't use GETCURRPID() or HackGetCurrentProcessId() as we want
     * the real PID not one that has been munged.
     */
    #define GETDDVXDHANDLE( pdrv_lcl ) \
        ( ( GetCurrentProcessId() == ( pdrv_lcl )->dwProcessId ) ? (HANDLE) ( ( pdrv_lcl )->hDDVxd ) : hHelperDDVxd )

#else  /* !WIN95 */

    #define GETDDVXDHANDLE( pdrv_lcl ) NULL

#endif /* !WIN95 */

#define VDPF(Args) DPF Args
#include "ddheap.h"
#include "ddagp.h"
/* apphack.c */
extern void FreeAppHackData(void);


/* cliprgn.h */
extern void ClipRgnToRect( LPRECT prect, LPRGNDATA prd );

/* ddcsurf.c */
extern BOOL isPowerOf2(DWORD dw, int* pPower);
extern HRESULT checkSurfaceDesc( LPDDSURFACEDESC2 lpsd, LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD FAR *psflags, BOOL emulation, BOOL real_sysmem, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
extern DWORD ComputePitch( LPDDRAWI_DIRECTDRAW_GBL thisg, DWORD caps, DWORD width, UINT bpp );
extern DWORD GetBytesFromPixels( DWORD pixels, UINT bpp );
extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT AllocSurfaceMem( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPDDRAWI_DDRAWSURFACE_LCL *slist, int nsurf );
#ifdef DEBUG
    void SurfaceSanityTest( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPSTR title );
    #define SURFSANITY( a,b ) SurfaceSanityTest( a, b );
#else
    #define SURFSANITY( a,b )
#endif

/* ddclip.c */
extern HRESULT InternalCreateClipper( LPDDRAWI_DIRECTDRAW_GBL lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter, BOOL fInitialized, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern char g_szPrimaryDisplay[];
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern BOOL CurrentProcessCleanup( BOOL );
extern LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd , LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap);
extern void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD, BOOL );
extern void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl );
extern LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate( LPDDHALINFO lpDDHALInfo, BOOL reset, LPDDRAWI_DIRECTDRAW_GBL pdrv, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext );
extern LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL reset, DWORD hInstance, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl );
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL DirectDrawSupported( void );
extern BOOL IsMultiMonitor( void );
extern LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(LPDDRAWI_DIRECTDRAW_GBL pdrv,LPDDHALMODEINFO pmi, HANDLE hDDVxd );

#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

#ifdef IS_32
extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);
extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags );
extern void UpdateRectFromDevice( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern void UpdateAllDeviceRects( void );
#endif

/* ddiunk.c */
extern HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int );

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* ddesurf.c */
extern void FillDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC lpdsd );
extern void FillDDSurfaceDesc2( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );
extern void FillEitherDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );

/* ddfake.c */
extern BOOL getBitMask( LPDDHALMODEINFO pmi );
extern LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject( HDC hdc_dd, LPSTR szDrvName, LPDDRAWI_DIRECTDRAW_GBL, BOOL reset, HANDLE hDDVxd );
extern DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi );
extern void BuildPixelFormat(HDC, LPDDHALMODEINFO, LPDDPIXELFORMAT);

/* ddpal.c */
extern void ResetSysPalette( LPDDRAWI_DDRAWSURFACE_GBL psurf, BOOL dofree );
extern void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int );
extern HRESULT SetPaletteAlways( LPDDRAWI_DDRAWSURFACE_INT psurf_int, LPDIRECTDRAWPALETTE lpDDPalette );

/* ddraw.c */
extern void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv );
extern void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv, DWORD dwFlags, DWORD pid );
extern HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_INT psurf_int); //, FLATPTR fpprim );
extern void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt);

/* ddsacc.c */
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
extern void RemoveProcessLocks( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, DWORD pid );
extern HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID *pbits,
                             LPRECT lpDestRect, DWORD dwFlags);
extern HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpSurfaceData, LPRECT lpDestRect, DWORD dwFlags );
#ifdef USE_ALIAS
    extern void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL thisg );
#endif /* USE_ALIAS */

/* ddsatch.c */
extern void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int );
extern HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from, LPDDRAWI_DDRAWSURFACE_INT psurf_to, BOOL implicit );
extern void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf );
#define DOA_DONTDELETEIMPLICIT FALSE
#define DOA_DELETEIMPLICIT     TRUE
extern HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int, BOOL cleanup, BOOL delete_implicit );
extern HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int );

/* ddsblt.c */
extern void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl );
extern LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr, DWORD caps );
extern HRESULT XformRect(RECT * prcSrc,RECT * prcDest,RECT * prcClippedDest,RECT * prcClippedSrc,DWORD scale_x,DWORD scale_y);
// SCALE_X and SCALE_Y are fixed point variables scaled 16.16. These macros used by calls to XformRect.
#define SCALE_X(rcSrc,rcDest) ( ((rcSrc.right - rcSrc.left) << 16) / (rcDest.right - rcDest.left))
#define SCALE_Y(rcSrc,rcDest) ( ((rcSrc.bottom - rcSrc.top) << 16) / (rcDest.bottom - rcDest.top))

/* ddsckey.c */
extern HRESULT CheckColorKey( DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDCOLORKEY lpDDColorKey, LPDWORD psflags, BOOL halonly, BOOL helonly );
extern HRESULT ChangeToSoftwareColorKey( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL );

/* ddsiunk.c */
extern LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int );
extern void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddmode.c */
extern HRESULT SetDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, DWORD modeidx, BOOL force, BOOL useRefreshRate );
extern HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, BOOL force );
extern void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD width, DWORD height, WORD refreshRate );
extern BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwWidth, DWORD dwHeight, DWORD dwBpp, DWORD dwRefreshRate);

/* ddsurf.c */
extern HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags );
extern HRESULT MoveToSystemMemory( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL hasvram, BOOL use_full_lock );
extern void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC2 lpDDSD );
extern void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL thisg, HANDLE hDDVxd, BOOL fRebuildAliases );
#ifdef SHAREDZ
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
extern BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
#endif
extern HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

extern LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpddcb );

extern HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR *lphdc );
extern HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc );
extern HRESULT EXTERN_DDAPI GetSurfaceFromDC( HDC hdc, LPDIRECTDRAWSURFACE *ppdds, HDC *phdcDriver );
extern HRESULT InternalAssociateDC( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );
extern HRESULT InternalRemoveDCFromList( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );


// function from ddsprite.c to clean pid from master sprite list:
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid);

#ifdef WIN95
extern void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
extern void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
#else
#define UpdateOutstandingDC(x,y)
#define UpdateDCOnPaletteChanges(x)
#endif


#ifdef USE_ALIAS
    /* ddalias.c */
    extern HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv );
    extern BOOL    ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv,
                                     LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                                     FLATPTR                   fpVidMem );
#endif /* USE_ALIAS */

/* dllmain.c */
extern BOOL RemoveProcessFromDLL( DWORD pid );

/* misc.c */
extern BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL thisg, LPDDRAWI_DDRAWSURFACE_LCL this_attach);
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
#ifdef WIN95
    extern HANDLE GetDXVxdHandle( void );
#endif /* WIN95 */

/* ddcallbk.c */
extern void InitCallbackTables( void );
extern BOOL CallbackTablesInitialized( void );

/* ddvp.c */
extern void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int );
extern LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int );
extern DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
#define IVAS_NOAUTOFLIPPING             0
#define IVAS_SOFTWAREAUTOFLIPPING       1
#define IVAS_HARDWAREAUTOFLIPPING       2
extern VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID SetRingZeroSurfaceData( LPDDRAWI_DDRAWSURFACE_LCL lpSurface_lcl );
extern DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT , DWORD );
extern VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int, LPDWORD lpdwFlags );
extern BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int );
extern VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int );

/* ddcolor.c */
extern VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );

/* ddgamma.c */
extern VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName );

/* ddkernel.c */
extern HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface );
extern HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, PULONG_PTR lpHandle );
extern HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags );
extern HRESULT GetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, LPDWORD lpdwFieldNum );
extern HRESULT SetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFieldNum );
extern HRESULT SetKernelSkipPattern( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwStartField, DWORD dwPatternSize, DWORD dwPattern );
extern HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags );
extern HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort );
extern BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable );
extern BOOL IsWindows98( VOID );

/* ddmc.c */
extern BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl );
extern void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* private.c */
extern void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead);

/* factory.c */
extern HRESULT InternalCreateDDFactory2(void **, IUnknown * pUnkOuter);

// ddrestor.c
extern HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl);
extern void MungeAutoflipCaps(LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* ddrefrsh.c */
extern HRESULT DDGetMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int);
extern HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd );
extern BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh );

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );


/* A handy one from ddhel.c */
/* DDRAW16 doesn't need this. */
#ifdef WIN32
    SCODE InitDIB(HDC hdc, LPBITMAPINFO lpbmi);
#endif
void ResetBITMAPINFO(LPDDRAWI_DIRECTDRAW_GBL thisg);
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1,
                                LPDDPIXELFORMAT lpddpf2);
HRESULT ConvertToPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDDARGB pSource, LPDWORD pdwPhysColor);
HRESULT ConvertFromPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDWORD pdwPhysColor, LPDDARGB pDest);
extern DWORD GetSurfPFIndex(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl);
extern DWORD GetDxtBlkSize(DWORD dwFourCC);

/*
 * HEL's public memory allocator
 */
extern void HELFreeSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl);
extern LPVOID HELAllocateSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl, DWORD nWidth,
                                DWORD nHeight, LPDWORD lpdwSurfaceSize, LPLONG lpSurfPitch );

#ifndef NO_DDHELP
    /* w95hack.c */
    extern DWORD HackGetCurrentProcessId( void );
    extern BOOL DDAPI DDNotify( LPDDHELPDATA phd );
    extern void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL );
    extern void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL );
#endif //NO_DDHELP

#ifdef POSTPONED
/* Delegating IUnknown functions */
extern HRESULT EXTERN_DDAPI DD_DelegatingQueryInterface(LPDIRECTDRAW, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD );
extern DWORD EXTERN_DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD );
#endif

/* DirectDrawFactory2 functions */
extern HRESULT EXTERN_DDAPI DDFac2_QueryInterface(LPDIRECTDRAWFACTORY2, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac );
extern ULONG EXTERN_DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac );
extern HRESULT EXTERN_DDAPI DDFac2_CreateDirectDraw(LPDIRECTDRAWFACTORY2, GUID FAR *, HWND, DWORD dwCoopLevelFlags, DWORD, IUnknown *, struct IDirectDraw4 ** );
#ifdef IS_32
#ifdef SM_CMONITORS
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACKEX , LPVOID  , DWORD );
#else
    /*
     * This def'n is a hack to keep us building under NT build which doesn't have the
     * multimon headers in it yet
     */
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACK , LPVOID  , DWORD );
#endif
#endif

/* DIRECTDRAW functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedQueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_QueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_AddRef( LPDIRECTDRAW lpDD );
extern DWORD   EXTERN_DDAPI DD_Release( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_Compact( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_CreateClipper( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreatePalette( LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable, LPDIRECTDRAWPALETTE FAR *lplpDDPalette, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface4( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_DuplicateSurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetCaps( LPDIRECTDRAW lpDD, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpHELCaps );
extern HRESULT EXTERN_DDAPI DD_GetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_GetDisplayMode( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpSurfaceDesc );
extern HRESULT EXTERN_DDAPI DD_GetFourCCCodes(LPDIRECTDRAW,DWORD FAR *,DWORD FAR *);
extern HRESULT EXTERN_DDAPI DD_GetGDISurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE FAR * );
extern HRESULT EXTERN_DDAPI DD_GetScanLine( LPDIRECTDRAW lpDD, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_GetVerticalBlankStatus( LPDIRECTDRAW lpDD, BOOL FAR * );
extern HRESULT EXTERN_DDAPI DD_Initialize(LPDIRECTDRAW, GUID FAR *);
extern HRESULT EXTERN_DDAPI DD_SetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_SetCooperativeLevel(LPDIRECTDRAW,HWND,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode(LPDIRECTDRAW,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode2(LPDIRECTDRAW,DWORD,DWORD,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW);
extern HRESULT EXTERN_DDAPI DD_GetMonitorFrequency( LPDIRECTDRAW lpDD, LPDWORD lpdwFrequency);
extern HRESULT EXTERN_DDAPI DD_WaitForVerticalBlank( LPDIRECTDRAW lpDD, DWORD dwFlags, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC, LPDIRECTDRAWSURFACE *);
extern HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER, DWORD);
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2, DWORD);
extern HRESULT EXTERN_DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout);
#ifdef IS_32
    //streaming stuff confuses ddraw16
    #ifndef __cplusplus
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
    #endif
#endif
extern HRESULT EXTERN_DDAPI DD_CreateOptSurface( LPDIRECTDRAW, LPDDOPTSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter);
extern HRESULT EXTERN_DDAPI DD_ListOptSurfaceGUIDS(LPDIRECTDRAW, DWORD *, LPGUID);
extern HRESULT EXTERN_DDAPI DD_CanOptimizeSurface(LPDIRECTDRAW, LPDDSURFACEDESC2, LPDDOPTSURFACEDESC, BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW);

/* DIRECTDRAWPALETTE functions */
extern HRESULT EXTERN_DDAPI DD_Palette_QueryInterface( LPDIRECTDRAWPALETTE lpDDPalette, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette );
extern DWORD   EXTERN_DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette );
extern HRESULT EXTERN_DDAPI DD_Palette_GetCaps( LPDIRECTDRAWPALETTE lpDDPalette, LPDWORD lpdwFlags );
extern HRESULT EXTERN_DDAPI DD_Palette_Initialize( LPDIRECTDRAWPALETTE, LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable );
extern HRESULT EXTERN_DDAPI DD_Palette_SetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_GetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_SetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, DWORD, DWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_GetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_FreePrivateData( LPDIRECTDRAWPALETTE, REFIID );
extern HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue( LPDIRECTDRAWPALETTE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue( LPDIRECTDRAWPALETTE );
extern HRESULT EXTERN_DDAPI DD_Palette_IsEqual( LPDIRECTDRAWPALETTE, LPDIRECTDRAWPALETTE );


/* DIRECTDRAWCLIPPER functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedClipperQueryInterface( LPDIRECTDRAWCLIPPER lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_Clipper_QueryInterface( LPVOID lpDDClipper, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Clipper_AddRef( LPVOID lpDDClipper );
extern ULONG   EXTERN_DDAPI DD_Clipper_Release( LPVOID lpDDClipper );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetClipList( LPDIRECTDRAWCLIPPER, LPRECT, LPRGNDATA, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetHWnd(LPDIRECTDRAWCLIPPER,HWND FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_Initialize( LPDIRECTDRAWCLIPPER, LPDIRECTDRAW lpDD, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_Clipper_IsClipListChanged(LPDIRECTDRAWCLIPPER,BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetClipList(LPDIRECTDRAWCLIPPER,LPRGNDATA, DWORD);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetHWnd(LPDIRECTDRAWCLIPPER, DWORD, HWND );
extern HRESULT EXTERN_DDAPI DD_Clipper_SetNotificationCallback(LPDIRECTDRAWCLIPPER, DWORD,LPCLIPPERCALLBACK, LPVOID);

/* Private DIRECTDRAWCLIPPER functions */
extern HRESULT InternalGetClipList( LPDIRECTDRAWCLIPPER lpDDClipper, LPRECT lpRect, LPRGNDATA lpClipList, LPDWORD lpdwSize, LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* DIRECTDRAWSURFACE functions */
extern HRESULT EXTERN_DDAPI DD_Surface_QueryInterface( LPVOID lpDDSurface, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Surface_AddRef( LPVOID lpDDSurface );
extern ULONG   EXTERN_DDAPI DD_Surface_Release( LPVOID lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_AddAttachedSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_AddOverlayDirtyRect(LPDIRECTDRAWSURFACE, LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_AlphaBlt(LPDIRECTDRAWSURFACE, LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_Blt(LPDIRECTDRAWSURFACE,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_BltFast(LPDIRECTDRAWSURFACE,DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_BltBatch( LPDIRECTDRAWSURFACE, LPDDBLTBATCH, DWORD, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue( LPDIRECTDRAWSURFACE );
extern HRESULT EXTERN_DDAPI DD_Surface_DeleteAttachedSurfaces(LPDIRECTDRAWSURFACE, DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_EnumAttachedSurfaces(LPDIRECTDRAWSURFACE,LPVOID, LPDDENUMSURFACESCALLBACK );
extern HRESULT EXTERN_DDAPI DD_Surface_EnumOverlayZOrders(LPDIRECTDRAWSURFACE,DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
extern HRESULT EXTERN_DDAPI DD_Surface_Flip(LPDIRECTDRAWSURFACE,LPDIRECTDRAWSURFACE, DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_FreePrivateData(LPDIRECTDRAWSURFACE, REFIID);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface(LPDIRECTDRAWSURFACE,LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface4(LPDIRECTDRAWSURFACE4,LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface7(LPDIRECTDRAWSURFACE7,LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetBltStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps4( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS2 lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDC( LPDIRECTDRAWSURFACE, HDC FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDDInterface(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID FAR *lplpDD );
extern HRESULT EXTERN_DDAPI DD_Surface_GetOverlayPosition( LPDIRECTDRAWSURFACE, LPLONG, LPLONG );
extern HRESULT EXTERN_DDAPI DD_Surface_GetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE FAR*);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPixelFormat(LPDIRECTDRAWSURFACE, LPDDPIXELFORMAT);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc4(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2);
extern HRESULT EXTERN_DDAPI DD_Surface_GetFlipStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue( LPDIRECTDRAWSURFACE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Initialize( LPDIRECTDRAWSURFACE, LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc);
extern HRESULT EXTERN_DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_Lock(LPDIRECTDRAWSURFACE,LPRECT,LPDDSURFACEDESC lpDDSurfaceDesc, DWORD, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_Surface_PageLock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_PageUnlock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_ReleaseDC(LPDIRECTDRAWSURFACE,HDC );
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Resize(LPDIRECTDRAWSURFACE,DWORD,DWORD,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_SetBltOrder(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_SetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER );
extern HRESULT EXTERN_DDAPI DD_Surface_SetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_SetOverlayPosition( LPDIRECTDRAWSURFACE, LONG, LONG );
extern HRESULT EXTERN_DDAPI DD_Surface_SetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, DWORD, DWORD);
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSpriteDisplayList(LPDIRECTDRAWSURFACE,LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc4( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC2, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock(LPDIRECTDRAWSURFACE,LPVOID);
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock4(LPDIRECTDRAWSURFACE,LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlay(LPDIRECTDRAWSURFACE,LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayDisplay(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayZOrder(LPDIRECTDRAWSURFACE,DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD);

/* DrawDrawVideoPortContainer functions */
extern HRESULT EXTERN_DDAPI DDVPC_QueryInterface(LPDDVIDEOPORTCONTAINER lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DDVPC_AddRef(LPDDVIDEOPORTCONTAINER lpDVP );
extern DWORD   EXTERN_DDAPI DDVPC_Release( LPDDVIDEOPORTCONTAINER lpDD );
extern HRESULT EXTERN_DDAPI DDVPC_CreateVideoPort(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwFlags, LPDDVIDEOPORTDESC lpDesc, LPDIRECTDRAWVIDEOPORT FAR *lplpVideoPort, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDVPC_EnumVideoPorts(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwReserved, LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext, LPDDENUMVIDEOCALLBACK lpCallback );
extern HRESULT EXTERN_DDAPI DDVPC_GetVideoPortConnectInfo(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDWORD lpdwNumGUIDs, LPDDVIDEOPORTCONNECT lpConnect );
extern HRESULT EXTERN_DDAPI DDVPC_QueryVideoPortStatus(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDDVIDEOPORTSTATUS lpStatus );

/* DirectDrawVideoPort functions */
extern HRESULT EXTERN_DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_VP_AddRef(LPDIRECTDRAWVIDEOPORT lpDVP );
extern DWORD   EXTERN_DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD );
extern HRESULT EXTERN_DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDDVIDEOPORTBANDWIDTH lpBandwidth );
extern HRESULT EXTERN_DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, LPDWORD lp1, LPDDPIXELFORMAT lp2, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetCurrentAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLastAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine );
extern HRESULT EXTERN_DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut );
extern HRESULT EXTERN_DDAPI DD_VP_SetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_GetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_SetSkipFieldPattern(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwStartField, DWORD dwPattSize, DWORD dwPatt );
extern HRESULT EXTERN_DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus );
extern HRESULT EXTERN_DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_GetStateInfo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStateFlags );

/* DrawDrawColorControl functions */
extern HRESULT EXTERN_DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );

/* DrawDrawGammaControl functions */
extern HRESULT EXTERN_DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );
extern HRESULT EXTERN_DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );

/* DirectDrawKernel functions */
extern HRESULT EXTERN_DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps );
extern HRESULT EXTERN_DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK );

/* DirectDrawSurfaceKernel functions */
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK );

/* DIrectDrawSurface and palette IPersist and IPersistStream functions */
#ifdef IS_32
    extern HRESULT EXTERN_DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm);
#endif

/* DirectDrawOptSurface functions */
extern HRESULT EXTERN_DDAPI DD_OptSurface_GetOptSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDOPTSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_OptSurface_LoadUnoptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_CopyOptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_Unoptimize(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *);

/* DrawDrawMotionCompContainer functions */
extern HRESULT EXTERN_DDAPI DDMCC_CreateMotionComp(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPVOID lpData, DWORD dwDataSize, LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpMotionComp, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDMCC_GetUncompressedFormats(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDWORD lpNumFormats, LPDDPIXELFORMAT lpFormats );
extern HRESULT EXTERN_DDAPI DDMCC_GetMotionCompGUIDs(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPDWORD lpNumGuids, LPGUID lpGuids );
extern HRESULT EXTERN_DDAPI DDMCC_GetCompBuffInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDWORD lpNumBuffInfo, LPDDVACompBufferInfo lpCompBuffInfo );
extern HRESULT EXTERN_DDAPI DDMCC_GetInternalMoCompInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDDVAInternalMemInfo lpMemInfo );

/* DrawDrawMotionComp functions */
extern HRESULT EXTERN_DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_MC_AddRef(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern DWORD   EXTERN_DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern HRESULT EXTERN_DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVABeginFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVAEndFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags);
extern HRESULT EXTERN_DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, DWORD dwFunction, LPVOID lpInput, DWORD dwInputSize, LPVOID lpOutput, DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo);

//#endif //WIN95

/*
 * HAL fns
 */

//#ifdef WIN95
/*
 * thunk helper fns
 */
extern DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );
extern DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );

extern DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );

extern DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );

extern DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );
extern DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );

extern DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );
extern DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );

extern DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );
extern DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );

extern DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );
extern DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );

extern DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );
extern DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );

extern DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );
extern DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );

extern DWORD DDAPI _DDHAL_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );
extern DWORD DDAPI DDThunk16_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );

extern DWORD DDAPI _DDHAL_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );
extern DWORD DDAPI DDThunk16_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );

/*
 * Palette Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );
extern DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );

extern DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA );
extern DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA );

/*
 * Surface Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );

extern DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA lpFlipData );
extern DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData );

extern DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA lpBltData );
extern DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData );

extern DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData );

extern DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );
extern DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );

extern DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );
extern DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );

extern DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );
extern DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );

extern DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );
extern DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );

extern DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );
extern DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );

extern DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );
extern DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );

extern DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );
extern DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );

extern DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );
extern DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );

extern DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );
extern DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );

/*
 * Execute Buffer Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA lpUnlockData );

/*
 * Video Port Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData );
extern DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData );
extern DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData );
extern DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData );
extern DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData );
extern DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData );
extern DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData );
extern DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData );
extern DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData );
extern DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData );

/*
 * Color Control Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );
extern DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );

/*
 * Kernel Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpSyncData );
extern DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpSyncData );

/*
 * MotionComp Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGetGuidData );
extern DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCreateData );
extern DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpBuffData );
extern DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpInternalData );
extern DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpRenderData );
extern DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpStatusData );
#ifdef POSTPONED
extern DWORD DDAPI _DDHAL_CanOptimizeSurface( LPDDHAL_CANOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_OptimizeSurface( LPDDHAL_OPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_UnOptimizeSurface( LPDDHAL_UNOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_CopyOptSurface( LPDDHAL_COPYOPTSURFACEDATA);
#endif
//#endif

#ifdef POSTPONED
    #ifdef IS_32
    /*
     * DirectDrawFactory2 implementation
     */
    typedef struct _DDFACTORY2
    {
        IDirectDrawFactory2Vtbl *lpVtbl;
        DWORD                   dwRefCnt;
        /* internal data */
    } DDFACTORY2, FAR * LPDDFACTORY2;
    #endif
#endif //POSTPONED

/*
 * Macros for checking interface versions
 */

#define LOWERTHANDDRAW7(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks || lpDD->lpVtbl == &dd4Callbacks )

#define LOWERTHANDDRAW4(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANDDRAW3(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANSURFACE7(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || \
     lpDDS->lpVtbl == &ddSurface3Callbacks || lpDDS->lpVtbl == &ddSurface4Callbacks )

#define LOWERTHANSURFACE4(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || lpDDS->lpVtbl == &ddSurface3Callbacks )

/*
 * This macro allows testing an interface pointer to see if it's one that come from
 * our implementation of ddraw, or somebody else's
 */
#define IS_NATIVE_DDRAW_INTERFACE(ptr) \
        ( ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd7Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd5UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddVideoPortContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddKernelCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddMotionCompContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddUninitCallbacks) )

/*
 * This macro tests if this ddraw interface is one for which child objects should take
 * a ref count on that interface and thus achieve immortality wrt that interface.
 */
#define CHILD_SHOULD_TAKE_REFCNT(dd_int) (!LOWERTHANDDRAW3(dd_int))

/*
 * macros for checking if surface as been lost due to mode change
 * NOTE: The flag for determining if a surface is lost or not is now
 * stored in the local than global object. This prevents the scenario
 * where a surface being shared by two processes is lost and restored
 * by one of them - giving the other no notification that the contents
 * of the surface are gone.
 */
#define SURFACE_LOST( lcl_ptr ) (((lcl_ptr)->dwFlags & DDRAWISURF_INVALID))

/*
 * Useful palette macros
 *
 * All these flags are really iritating to handle but but changing
 * to use a numeric palette size would require an API change and
 * internal structure mods (visible to the driver) so I am sticking
 * with flags.
 */
#define SIZE_PCAPS_TO_FLAGS( pcaps )                              \
    (((pcaps) & DDPCAPS_1BIT) ? DDRAWIPAL_2 :                     \
     (((pcaps) & DDPCAPS_2BIT) ? DDRAWIPAL_4 :                    \
      (((pcaps) & DDPCAPS_4BIT) ? DDRAWIPAL_16 : DDRAWIPAL_256)))

#define SIZE_FLAGS_TO_PCAPS( flags )                              \
    (((flags) & DDRAWIPAL_2) ? DDPCAPS_1BIT :                     \
     (((flags) & DDRAWIPAL_4) ? DDPCAPS_2BIT :                    \
      (((flags) & DDRAWIPAL_16) ? DDPCAPS_4BIT : DDPCAPS_8BIT)))

#define FLAGS_TO_SIZE( flags )                                    \
    (((flags) & DDRAWIPAL_2)  ? 2 :                               \
     (((flags) & DDRAWIPAL_4)  ? 4 :                              \
      (((flags) & DDRAWIPAL_16) ? 16 : 256)))

/*
 * has Direct3D been initialized for this DirectDraw driver object?
 */
#define D3D_INITIALIZED( lcl_ptr )  (( NULL != (lcl_ptr)->pD3DIUnknown)  && ( NULL != (lcl_ptr)->hD3DInstance ))

#if defined( _WIN32 ) && !defined( WINNT )
/*
 * Macros and types to support secondary (stacked) drivers.
 *
 * NOTE: This stuff is only relevant to 32-bit DirectDraw and the GUIDs
 * confuse DDRAW16.
 */
#define MAX_SECONDARY_DRIVERNAME              MAX_PATH
#define MAX_SECONDARY_ENTRYPOINTNAME          32UL
#define DEFAULT_SECONDARY_ENTRYPOINTNAME      "GetInfo"

#define REGSTR_PATH_SECONDARY                 "Software\\Microsoft\\DirectDraw\\Secondary"
#define REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME "Entry"
#define REGSTR_VALUE_SECONDARY_DRIVERNAME     "Name"

typedef DWORD                    (WINAPI * LPSECONDARY_PATCHHALINFO)(
                                        LPDDHALINFO                lpDDHALInfo,
                                        LPDDHAL_DDCALLBACKS        lpDDCallbacks,
                                        LPDDHAL_DDSURFACECALLBACKS lpDDSurfaceCallbacks,
                                        LPDDHAL_DDPALETTECALLBACKS lpDDPaletteCallbacks,
                                        LPDDHAL_DDEXEBUFCALLBACKS  lpDDExeBufCallbacks);
typedef LPSECONDARY_PATCHHALINFO (WINAPI * LPSECONDARY_VALIDATE)(LPGUID lpGuid);

DEFINE_GUID( guidCertifiedSecondaryDriver, 0x8061d4e0,0xe895,0x11cf,0xa2,0xe0,0x00,0xaa,0x00,0xb9,0x33,0x56 );
#endif

#if defined( _WIN32 )
DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );
#endif

/*
 * macros for validating pointers
 */
extern DIRECTDRAWCALLBACKS                      ddCallbacks;
extern DIRECTDRAWCALLBACKS                      ddUninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2UninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2Callbacks;
extern DIRECTDRAW4CALLBACKS                     dd4UninitCallbacks;
extern DIRECTDRAW4CALLBACKS                     dd4Callbacks;
extern DIRECTDRAW7CALLBACKS                     dd7UninitCallbacks;
extern DIRECTDRAW7CALLBACKS                     dd7Callbacks;
extern DIRECTDRAWSURFACECALLBACKS               ddSurfaceCallbacks;
extern DIRECTDRAWSURFACE2CALLBACKS              ddSurface2Callbacks;
extern DIRECTDRAWSURFACE3CALLBACKS              ddSurface3Callbacks;
extern DIRECTDRAWSURFACE4CALLBACKS              ddSurface4Callbacks;
extern DIRECTDRAWSURFACE7CALLBACKS              ddSurface7Callbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddClipperCallbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddUninitClipperCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DDVIDEOPORTCONTAINERCALLBACKS            ddVideoPortContainerCallbacks;
extern DIRECTDRAWVIDEOPORTCALLBACKS             ddVideoPortCallbacks;
extern DIRECTDRAWKERNELCALLBACKS                ddKernelCallbacks;
extern DIRECTDRAWSURFACEKERNELCALLBACKS         ddSurfaceKernelCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DIRECTDRAWCOLORCONTROLCALLBACKS          ddColorControlCallbacks;
extern DIRECTDRAWGAMMACONTROLCALLBACKS          ddGammaControlCallbacks;
#ifdef POSTPONED
extern NONDELEGATINGUNKNOWNCALLBACKS            ddNonDelegatingUnknownCallbacks;
extern NONDELEGATINGUNKNOWNCALLBACKS            ddUninitNonDelegatingUnknownCallbacks;
extern LPVOID NonDelegatingIUnknownInterface;
extern LPVOID UninitNonDelegatingIUnknownInterface;
#endif
extern DDVIDEOACCELERATORCONTAINERCALLBACKS     ddMotionCompContainerCallbacks;
extern DIRECTDRAWVIDEOACCELERATORCALLBACKS      ddMotionCompCallbacks;

#ifdef POSTPONED
extern DDFACTORY2CALLBACKS                      ddFactory2Callbacks;
extern DIRECTDRAWPALETTE2CALLBACKS              ddPalette2Callbacks;
extern DIRECTDRAWPALETTEPERSISTCALLBACKS        ddPalettePersistCallbacks;
extern DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
extern DIRECTDRAWSURFACEPERSISTCALLBACKS        ddSurfacePersistCallbacks;
extern DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
extern DIRECTDRAWOPTSURFACECALLBACKS            ddOptSurfaceCallbacks;
#endif

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (LPVOID) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDFACTORY2 )) && \
        (ptr->lpVtbl == &ddFactory2Callbacks) )
#define VALIDEX_DIRECTDRAW_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DIRECTDRAW_INT )) && \
        ( (ptr->lpVtbl == &ddCallbacks) || \
          (ptr->lpVtbl == &dd2Callbacks) || \
          (ptr->lpVtbl == &dd4Callbacks) || \
          (ptr->lpVtbl == &dd7Callbacks) || \
          (ptr->lpVtbl == &dd2UninitCallbacks) || \
          (ptr->lpVtbl == &dd4UninitCallbacks) || \
          (ptr->lpVtbl == &dd7UninitCallbacks) || \
          (ptr->lpVtbl == &ddVideoPortContainerCallbacks) || \
          (ptr->lpVtbl == &ddKernelCallbacks) || \
          (ptr->lpVtbl == &ddMotionCompContainerCallbacks) || \
          (ptr->lpVtbl == &ddUninitCallbacks) ) )
#define VALIDEX_DIRECTDRAWSURFACE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )) && \
        ( (ptr->lpVtbl == &ddSurfaceCallbacks ) || \
          (ptr->lpVtbl == &ddSurface7Callbacks ) || \
          (ptr->lpVtbl == &ddSurface4Callbacks ) || \
          (ptr->lpVtbl == &ddSurface3Callbacks ) || \
          (ptr->lpVtbl == &ddSurface2Callbacks ) || \
          (ptr->lpVtbl == &ddSurfaceKernelCallbacks ) || \
          (ptr->lpVtbl == &ddColorControlCallbacks ) || \
          (ptr->lpVtbl == &ddGammaControlCallbacks ) ) )
#define VALIDEX_DIRECTDRAWPALETTE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWPALETTE_INT )) && \
        (ptr->lpVtbl == &ddPaletteCallbacks) )
#define VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWCLIPPER_INT )) && \
        ( (ptr->lpVtbl == &ddClipperCallbacks) || \
          (ptr->lpVtbl == &ddUninitClipperCallbacks) ) )
#define VALIDEX_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDCOLORCONTROL_INT )) && \
        (ptr->lpVtbl == &ddColorControlCallbacks) )
#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#ifndef WIN95
#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )
#endif

#ifndef FAST_CHECKING
#define VALID_DIRECTDRAW_PTR( ptr )        VALIDEX_DIRECTDRAW_PTR( ptr )
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )        VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr )
#define VALID_DIRECTDRAWSURFACE_PTR( ptr ) VALIDEX_DIRECTDRAWSURFACE_PTR( ptr )
#define VALID_DIRECTDRAWPALETTE_PTR( ptr ) VALIDEX_DIRECTDRAWPALETTE_PTR( ptr )
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr ) VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr )
#define VALID_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )))
#define VALID_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTDESC ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTDESC )) )
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTCAPS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTCAPS )) )
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTINFO ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTINFO )) )
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTBANDWIDTH ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH )) )
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTSTATUS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS )) )
#define VALID_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORCONTROL ) ) && \
        (ptr->dwSize == sizeof( DDCOLORCONTROL )) )
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_DDPIXELFORMAT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDPIXELFORMAT ) ) && \
        (ptr->dwSize == sizeof( DDPIXELFORMAT )) )
#define VALID_DDCOLORKEY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_RECT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_DDBLTFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTFX ) ) && \
        (ptr->dwSize == sizeof( DDBLTFX )) )
#define VALID_DDBLTBATCH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTBATCH ) ) )
#define VALID_DDOVERLAYFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOVERLAYFX ) ) && \
        (ptr->dwSize == sizeof( DDOVERLAYFX )) )
#define VALID_DDSCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS ) ) )
#define VALID_DDSCAPS2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS2 ) ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( PALETTEENTRY ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DDCAPS_PTR( ptr )                          \
         ( ( !IsBadWritePtr( ptr, sizeof( DWORD ) ) ) && \
           ( !IsBadWritePtr( ptr, ptr->dwSize     ) ) && \
           ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt ) \
        (!IsBadReadPtr( ptr, sizeof( DDSURFACEDESC ) * cnt ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_DDVIDEOPORT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDVIDEOPORT_INT )) && \
        (ptr->lpVtbl == &ddVideoPortCallbacks) )
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOPTSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDOPTSURFACEDESC )))
#define VALID_DDMOTIONCOMP_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDMOTIONCOMP_INT )) && \
        (ptr->lpVtbl == &ddMotionCompCallbacks) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_DIRECTDRAW_PTR( ptr )     1
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )     1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )      1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )      1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )      1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_DDSURFACEDESC2_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC2 ))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTDESC ))
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTCAPS ))
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTINFO ))
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH ))
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS ))
#define VALID_DDCOLORCONTROL_PTR( ptr ) (ptr->dwSize == sizeof( DDCOLORCONTROL ))
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )     1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_RECT_PTR( ptr )   1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )     1
#define VALID_DDMASK_PTR( ptr ) 1
#define VALID_DDSCAPS_PTR( ptr )        1
#define VALID_DDSCAPS2_PTR( ptr )       1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DDCAPS_PTR( ptr )                  \
    ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )      1
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1
#define VALID_DDVIDEOPORT_PTR( ptr ) 1
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDOPTSURFACEDESC ))
#define VALID_DDMOTIONCOMP_PTR( ptr ) 1

#endif

/*
 * All global (i.e. cross-process) values now reside in an instance of the following structure.
 * This instance is in its own shared data section.
 */

#undef GLOBALS_IN_STRUCT

#ifdef GLOBALS_IN_STRUCT
    #define GLOBAL_STORAGE_CLASS
    typedef struct
    {
#else
    #define GLOBAL_STORAGE_CLASS extern
#endif

    /*
     * This member should stay at the top in order to guarantee that it be intialized to zero
     * -see dllmain.c 's instance of this structure
     */
GLOBAL_STORAGE_CLASS    DWORD               dwRefCnt;

GLOBAL_STORAGE_CLASS    DWORD                   dwLockCount;

GLOBAL_STORAGE_CLASS    DWORD                   dwFakeCurrPid;
GLOBAL_STORAGE_CLASS    DWORD                   dwGrimReaperPid;

GLOBAL_STORAGE_CLASS    LPDDWINDOWINFO      lpWindowInfo;  // the list of WINDOWINFO structures
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_INT lpDriverObjectList;
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_LCL lpDriverLocalList;
GLOBAL_STORAGE_CLASS    volatile DWORD      dwMarker;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
GLOBAL_STORAGE_CLASS    LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

GLOBAL_STORAGE_CLASS    HINSTANCE                   hModule;
GLOBAL_STORAGE_CLASS    LPATTACHED_PROCESSES    lpAttachedProcesses;
GLOBAL_STORAGE_CLASS    BOOL                bFirstTime;

    #ifdef DEBUG
GLOBAL_STORAGE_CLASS        int             iDLLCSCnt;
GLOBAL_STORAGE_CLASS        int             iWin16Cnt;
    #endif

        /*
         * Winnt specific global statics
         */
        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
GLOBAL_STORAGE_CLASS    DWORD               dwHELRefCnt;
#ifdef WINNT
    GLOBAL_STORAGE_CLASS  LPDCISURFACEINFO  gpdci;
#endif

#ifdef DEBUG
        // these are used by myCreateSurface
    GLOBAL_STORAGE_CLASS        int                 gcSurfMem; // surface memory in bytes
    GLOBAL_STORAGE_CLASS        int                 gcSurf;  // number of surfaces
#endif

GLOBAL_STORAGE_CLASS    DWORD               dwHelperPid;

#ifdef WINNT
GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;
#endif

#ifdef GLOBALS_IN_STRUCT

    } GLOBALS;

    /*
     * And this is the pointer to the globals. Each process has an instance (contained in dllmain.c)
     */
    //extern GLOBALS * gp;
    extern GLOBALS g_s;
#endif //globals in struct

/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )

#define VALIDEX_STR_PTR( ptr, len ) \
        (!IsBadReadPtr( ptr, 1 ) && (lstrlen( ptr ) <len) )
#define VALIDEX_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )) )
#define VALIDEX_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )) )

/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\disysdef.h ===
#ifndef __DISYSDEF_H__
#define __DISYSDEF_H__

// IOCTLs defined here are only for NT builds to work with DINPUT.SYS

#ifdef WINNT

#undef IOCTL_FIRST
#define IOCTL_FIRST 0x0800

#undef IOCTL_GETVERSION
#define IOCTL_GETVERSION 0x0000

#undef IOCTL_INPUTLOST
#define IOCTL_INPUTLOST           CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_DESTROYINSTANCE
#define IOCTL_DESTROYINSTANCE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETDATAFORMAT
#define IOCTL_SETDATAFORMAT       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_ACQUIREINSTANCE
#define IOCTL_ACQUIREINSTANCE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_UNACQUIREINSTANCE
#define IOCTL_UNACQUIREINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETNOTIFYHANDLE
#define IOCTL_SETNOTIFYHANDLE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETBUFFERSIZE
#define IOCTL_SETBUFFERSIZE       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+6, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Keyboard class IOCTLs
#undef IOCTL_KBD_CREATEINSTANCE
#define IOCTL_KBD_CREATEINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_KBD_INITKEYS
#define IOCTL_KBD_INITKEYS         CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Mouse class IOCTLs
#undef IOCTL_MOUSE_CREATEINSTANCE
#define IOCTL_MOUSE_CREATEINSTANCE CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MOUSE_INITBUTTONS
#define IOCTL_MOUSE_INITBUTTONS    CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+10, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Joystick class IOCTLs
#undef IOCTL_JOY_CREATEINSTANCE
#define IOCTL_JOY_CREATEINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_PING
#define IOCTL_JOY_PING             CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_GETINITPARMS
#define IOCTL_JOY_GETINITPARMS     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_FFIO
#define IOCTL_JOY_FFIO             CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_GETSEQUENCEPTR
#define IOCTL_GETSEQUENCEPTR       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_GETAXES
#define IOCTL_JOY_GETAXES          CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+16, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MOUSE_GETWHEEL
#define IOCTL_MOUSE_GETWHEEL       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+17, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_CONFIGCHANGED
#define IOCTL_JOY_CONFIGCHANGED    CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+18, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MAX
#define IOCTL_MAX                  CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+19, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  // WINNT

#endif  // __DISYSDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dinputp.h ===
//GUID_FILEEFFECT is used to establish a effect file version
//beta file format different from final, so have different GUID
DEFINE_GUID(GUID_INTERNALFILEEFFECTBETA,0X981DC402, 0X880, 0X11D3, 0X8F, 0XB2, 0X0, 0XC0, 0X4F, 0X8E, 0XC6, 0X27);
//final for DX7 {197E775C-34BA-11d3-ABD5-00C04F8EC627}
DEFINE_GUID(GUID_INTERNALFILEEFFECT, 0x197e775c, 0x34ba, 0x11d3, 0xab, 0xd5, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27);
#if DIRECTINPUT_VERSION <= 0x0300
/*
 *  Old GUIDs from DX3 that were never used but which we can't recycle
 *  because we shipped them.
 */
DEFINE_GUID(GUID_RAxis,   0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_UAxis,   0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_VAxis,   0xA36D02E5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
#endif
#define DIEFT_PREDEFMIN             0x00000001
#define DIEFT_PREDEFMAX             0x00000005
//#define DIEFT_PREDEFMAX             0x00000006
#define DIEFT_TYPEMASK              0x000000FF

#define DIEFT_FORCEFEEDBACK         0x00000100
#define DIEFT_VALIDFLAGS            0x0000FE00
#define DIEFT_ENUMVALID             0x040000FF
/*
 *  Name for the latest structures, in places where we specifically care.
 */
#if (DIRECTINPUT_VERSION >= 900)
typedef       DIEFFECT      DIEFFECT_DX9;
typedef       DIEFFECT   *LPDIEFFECT_DX9;
#else
typedef       DIEFFECT      DIEFFECT_DX6;
typedef       DIEFFECT   *LPDIEFFECT_DX6;
#endif

BOOL static __inline
IsValidSizeDIEFFECT(DWORD cb)
{
    return cb == sizeof(DIEFFECT_DX6)
        || cb == sizeof(DIEFFECT_DX5);
}


#define DIEFFECT_MAXAXES            32
#define DIEFF_OBJECTMASK            0x00000003
#define DIEFF_ANGULAR               0x00000060
#define DIEFF_COORDMASK             0x00000070
#define DIEFF_REGIONANGULAR         0x00006000
#define DIEFF_REGIONCOORDMASK       0x00007000

#define DIEFF_VALID                 0x00000073
#define DIEP_GETVALID_DX5           0x000001FF
#define DIEP_SETVALID_DX5           0xE00001FF
#define DIEP_GETVALID               0x000003FF
#define DIEP_SETVALID               0xE00003FF
#define DIEP_USESOBJECTS            0x00000028
#define DIEP_USESCOORDS             0x00000040
#define DIES_VALID                  0x80000001
#define DIES_DRIVER                 0x00000001
#define DIDEVTYPE_MAX           5
#define DI8DEVCLASS_MAX             5
#define DI8DEVTYPE_MIN              0x11
#define DI8DEVTYPE_GAMEMIN          0x14
#define DI8DEVTYPE_GAMEMAX          0x19
#define DI8DEVTYPE_MAX              0x1D
#define DIDEVTYPE_TYPEMASK      0x000000FF
#define DIDEVTYPE_SUBTYPEMASK   0x0000FF00
#define DIDEVTYPE_ENUMMASK      0xFFFFFF00
#define DIDEVTYPE_ENUMVALID     0x00010000
#define DIDEVTYPE_RANDOM        0x80000000
#define DI8DEVTYPEMOUSE_MIN                         1
#define DI8DEVTYPEMOUSE_MAX                         7
#define DI8DEVTYPEMOUSE_MIN_BUTTONS                 0
#define DI8DEVTYPEMOUSE_MIN_CAPS                    0
#define DI8DEVTYPEKEYBOARD_MIN                      0
#define DI8DEVTYPEKEYBOARD_MAX                     13
#define DI8DEVTYPEKEYBOARD_MIN_BUTTONS              0
#define DI8DEVTYPEKEYBOARD_MIN_CAPS                 0
#define DI8DEVTYPEJOYSTICK_MIN                      DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEJOYSTICK_MAX                      3
#define DI8DEVTYPEJOYSTICK_MIN_BUTTONS              5
#define DI8DEVTYPEJOYSTICK_MIN_CAPS                 ( JOY_HWS_HASPOV | JOY_HWS_HASZ )
#define DI8DEVTYPEGAMEPAD_MIN                       DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEGAMEPAD_MAX                       5
#define DI8DEVTYPEGAMEPAD_MIN_BUTTONS               6
#define DI8DEVTYPEGAMEPAD_MIN_CAPS                  0
#define DI8DEVTYPEDRIVING_MIN                       DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEDRIVING_MAX                       6
#define DI8DEVTYPEDRIVING_MIN_BUTTONS               4
#define DI8DEVTYPEDRIVING_MIN_CAPS                  0
#define DI8DEVTYPEFLIGHT_MIN                        DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEFLIGHT_MAX                        5
#define DI8DEVTYPEFLIGHT_MIN_BUTTONS                4
#define DI8DEVTYPEFLIGHT_MIN_CAPS                   ( JOY_HWS_HASPOV | JOY_HWS_HASZ )
#define DI8DEVTYPE1STPERSON_MIN                     DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPE1STPERSON_MAX                     5
#define DI8DEVTYPE1STPERSON_MIN_BUTTONS             4
#define DI8DEVTYPE1STPERSON_MIN_CAPS                0
#define DI8DEVTYPESCREENPTR_MIN                     2
#define DI8DEVTYPESCREENPTR_MAX                     6
#define DI8DEVTYPESCREENPTR_MIN_BUTTONS             0
#define DI8DEVTYPESCREENPTR_MIN_CAPS                0
#define DI8DEVTYPEREMOTE_MIN                        2
#define DI8DEVTYPEREMOTE_MAX                        3
#define DI8DEVTYPEREMOTE_MIN_BUTTONS                0
#define DI8DEVTYPEREMOTE_MIN_CAPS                   0
#define DI8DEVTYPEDEVICECTRL_MIN                    2
#define DI8DEVTYPEDEVICECTRL_MAX                    5
#define DI8DEVTYPEDEVICECTRL_MIN_BUTTONS            0
#define DI8DEVTYPEDEVICECTRL_MIN_CAPS               0
#define DI8DEVTYPESUPPLEMENTAL_MIN                  2
#define DI8DEVTYPESUPPLEMENTAL_MAX                 14
#define DI8DEVTYPESUPPLEMENTAL_MIN_BUTTONS         0
#define DI8DEVTYPESUPPLEMENTAL_MIN_CAPS            0
#define MAKE_DIDEVICE_TYPE(maj, min)    MAKEWORD(maj, min) //
#define GET_DIDEVICE_TYPEANDSUBTYPE(dwDevType)    LOWORD(dwDevType) //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVCAPS     DIDEVCAPS_DX5;
typedef       DIDEVCAPS  *LPDIDEVCAPS_DX5;

BOOL static __inline
IsValidSizeDIDEVCAPS(DWORD cb)
{
    return cb == sizeof(DIDEVCAPS_DX5) ||
           cb == sizeof(DIDEVCAPS_DX3);
}

/* Force feedback bits live in the high byte, to keep them together */
#define DIDC_FFFLAGS            0x0000FF00
/*
 * Flags in the upper word mark devices normally excluded from enumeration.
 * To force enumeration of the device, you must pass the appropriate
 * DIEDFL_* flag.
 */
#define DIDC_EXCLUDEMASK        0x00FF0000
#define DIDC_RANDOM             0x80000000              //
#define DIDFT_RESERVEDTYPES 0x00000020      //
                                            //
#define DIDFT_DWORDOBJS     0x00000013      //
#define DIDFT_BYTEOBJS      0x0000000C      //
#define DIDFT_CONTROLOBJS   0x0000001F      //
#define DIDFT_ALLOBJS_DX3   0x0000001F      //
#define DIDFT_ALLOBJS       0x000000DF      //
#define DIDFT_TYPEMASK      0x000000FF
#define DIDFT_TYPEVALID     DIDFT_TYPEMASK   //
#define DIDFT_FINDMASK      0x00FFFFFF  //
#define DIDFT_FINDMATCH(n,m) ((((n)^(m)) & DIDFT_FINDMASK) == 0)

                                            //
/*                                          //
 *  DIDFT_OPTIONAL means that the           //
 *  SetDataFormat should ignore the         //
 *  field if the device does not            //
 *  support the object.                     //
 */                                         //
#define DIDFT_OPTIONAL          0x80000000  //
#define DIDFT_BESTFIT           0x40000000  //
#define DIDFT_RANDOM            0x20000000  //
#define DIDFT_ATTRVALID         0x1f000000
#if 0   // Disable the next line if building 5a
#endif
#define DIDFT_ATTRMASK          0xFF000000
#define DIDFT_ALIASATTRMASK     0x0C000000
#define DIDFT_GETATTR(n)    ((DWORD)(n) >> 24)
#define DIDFT_MAKEATTR(n)   ((BYTE)(n)  << 24)
#define DIDFT_GETCOLLECTION(n)  LOWORD((n) >> 8)
#define DIDFT_ENUMVALID                   \
        (DIDFT_ATTRVALID | DIDFT_ANYINSTANCE | DIDFT_ALLOBJS)
#define DIDF_VALID              0x00000003  //
#define DIA_VALID               0x0000001F
#define DIAH_OTHERAPP           0x00000010
#define DIAH_MAPMASK            0x0000003F
#define DIAH_VALID              0x8000003F
#define DIDBAM_VALID            0x00000007
#define DIDSAM_VALID            0x00000003
#define DICD_VALID              0x00000001
#define DIDIFTT_VALID           0x00000003
/*#define DIDIFT_DELETE           0x01000000 defined in dinput.w*/
#define DIDIFT_VALID            ( DIDIFTT_VALID)
#define DIDAL_VALID         0x0000000F  //
#define HAVE_DIDEVICEOBJECTINSTANCE_DX5
typedef       DIDEVICEOBJECTINSTANCEA    DIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW    DIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE     DIDEVICEOBJECTINSTANCE_DX5;
typedef       DIDEVICEOBJECTINSTANCEA *LPDIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW *LPDIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE  *LPDIDEVICEOBJECTINSTANCE_DX5;
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCE_DX5A;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCE_DX5W;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3A);
}

#define DIDOI_NOTINPUT          0x80000000
#define DIDOI_ASPECTUNKNOWN     0x00000000
#define DIDOI_RANDOM            0x80000000
typedef struct DIIMAGELABEL {
    RECT    MaxStringExtent;
    DWORD   dwFlags;
    POINT   Line[10];
    DWORD   dwLineCount;
    WCHAR   wsz[MAX_PATH];
} DIIMAGELABEL, *LPDIIMAGELABEL;
typedef const DIIMAGELABEL *LPCDIIMAGELABEL;


#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPGUID {
    DIPROPHEADER diph;
    GUID guid;
} DIPROPGUID, *LPDIPROPGUID;
typedef const DIPROPGUID *LPCDIPROPGUID;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPFILETIME {
    DIPROPHEADER diph;
    FILETIME time;
} DIPROPFILETIME, *LPDIPROPFILETIME;
typedef const DIPROPFILETIME *LPCDIPROPFILETIME;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
#define DIPROPAXISMODE_VALID    1   //
#define ISVALIDGAIN(n)          (HIWORD(n) == 0)
#define DIPROPAUTOCENTER_VALID  1
#define DIPROPCALIBRATIONMODE_VALID     1
#define DIPROP_ENABLEREPORTID       MAKEDIPROP(0xFFFB)


// now unused, may be replaced DIPROP_IMAGEFILE MAKEDIPROP(0xFFFC)

#define DIPROP_MAPFILE MAKEDIPROP(0xFFFD)//

#define DIPROP_SPECIFICCALIBRATION MAKEDIPROP(0xFFFE)//

#define DIPROP_MAXBUFFERSIZE    MAKEDIPROP(0xFFFF) //

#define DEVICE_MAXBUFFERSIZE    1023               //
#define DIGDD_RESIDUAL      0x00000002  //
#define DIGDD_VALID         0x00000003  //
#define DISCL_EXCLMASK      0x00000003  //
#define DISCL_GROUNDMASK    0x0000000C  //
#define DISCL_VALID         0x0000001F  //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEA    DIDEVICEINSTANCE_DX5A;
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEW    DIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5W DIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5A DIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE     DIDEVICEINSTANCE_DX5;
typedef       DIDEVICEINSTANCEA *LPDIDEVICEINSTANCE_DX5A;
typedef       DIDEVICEINSTANCEW *LPDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef LPDIDEVICEINSTANCE_DX5W LPDIDEVICEINSTANCE_DX5;
#else
typedef LPDIDEVICEINSTANCE_DX5A LPDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE  *LPDIDEVICEINSTANCE_DX5;
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCE_DX5A;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5W LPCDIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5A LPCDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3A);
}

#define DIRCP_MODAL         0x00000001  //
#define DIRCP_VALID         0x00000000  //
#define DISFFC_NULL             0x00000000
#define DISFFC_VALID            0x0000003F
#define DISFFC_FORCERESET       0x80000000
#define DIGFFS_RANDOM           0x40000000
#define DISDD_VALID             0x00000001
#define DIECEFL_VALID       0x00000000
#define DIFEF_ENUMVALID             0x00000011
#define DIFEF_WRITEVALID            0x00000001
#if DIRECTINPUT_VERSION >= 0x0700           //
#define DIMOUSESTATE_INT DIMOUSESTATE2      //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE2  //
#else                                       //
#define DIMOUSESTATE_INT DIMOUSESTATE       //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE   //
#endif                                      //
#define DIKBD_CKEYS         256     /* Size of buffers */       //
                                                                //
//  NT puts them here in their keyboard driver              
//  So keep them in the same place to avoid problems later
#define DIK_F16             0x67    //
#define DIK_F17             0x68    //
#define DIK_F18             0x69    //
#define DIK_F19             0x6A    //
#define DIK_F20             0x6B    //
#define DIK_F21             0x6C    //
#define DIK_F22             0x6D    //
#define DIK_F23             0x6E    //
#define DIK_F24             0x76    //
#define DIK_SHARP           0x84    /* Hash-mark                      */
//k_def(DIK_SNAPSHOT       ,0xC5)    /* Print Screen */
#define DIK_PRTSC           DIK_SNAPSHOT        /* Print Screen */
#define DIEDFL_INCLUDEMASK      0x00FF0000
#define DIEDFL_VALID            0x00030101
#if DIRECTINPUT_VERSION > 0x700
#define DIEDFL_VALID_DX5        0x00030101
#undef  DIEDFL_VALID
#define DIEDFL_VALID            0x00070101
#endif /* DIRECTINPUT_VERSION > 0x700 */
/********************************************************************************************
| Decoding a semantic
|            :           |           :           |           :           |           :
| 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|PHY <      Genre       > <  Reserved   ><  Flags  > Pri<Group > <Typ> A/R<    Control Index    >
|
| PHY: Genre refers to a physical device
| Genre: Genre# (1-128)
| A/R - Axis mode ( 0 - Absolute,   1 - Relative )
| Pri - Priority  ( 0 - Priority 1, 1 - Priority 2 )
|
|
*IMPORTANT: The Mapper UI uses some of the masks generated by M4. If you change any of the 
 	    masks or Flags please make sure that the changes are also made to the the Mapper UI
            #defines. 
********************************************************************************************/
#define DISEM_GENRE_SET(x)                      ( ( (BYTE)(x)<<24 ) & 0xFF000000 ) 
#define DISEM_GENRE_GET(x)                      ((BYTE)( ( (x) & 0xFF000000 )>>24 )) 
#define DISEM_GENRE_MASK                        ( 0xFF000000 )
#define DISEM_GENRE_SHIFT                       ( 24 ) 
#define DISEM_PHYSICAL_SET(x)                   ( ( (BYTE)(x)<<31 ) & 0x80000000 ) 
#define DISEM_PHYSICAL_GET(x)                   ((BYTE)( ( (x) & 0x80000000 )>>31 )) 
#define DISEM_PHYSICAL_MASK                     ( 0x80000000 )
#define DISEM_PHYSICAL_SHIFT                    ( 31 ) 
#define DISEM_VIRTUAL_SET(x)                    ( ( (BYTE)(x)<<24 ) & 0x7F000000 ) 
#define DISEM_VIRTUAL_GET(x)                    ((BYTE)( ( (x) & 0x7F000000 )>>24 )) 
#define DISEM_VIRTUAL_MASK                      ( 0x7F000000 )
#define DISEM_VIRTUAL_SHIFT                     ( 24 ) 
#define DISEM_RES_SET(x)                        ( ( (BYTE)(x)<<19 ) & 0x00F80000 ) 
#define DISEM_RES_GET(x)                        ((BYTE)( ( (x) & 0x00F80000 )>>19 )) 
#define DISEM_RES_MASK                          ( 0x00F80000 )
#define DISEM_RES_SHIFT                         ( 19 ) 
#define DISEM_FLAGS_SET(x)                      ( ( (BYTE)(x)<<15 ) & 0x00078000 ) 
#define DISEM_FLAGS_GET(x)                      ((BYTE)( ( (x) & 0x00078000 )>>15 )) 
#define DISEM_FLAGS_MASK                        ( 0x00078000 )
#define DISEM_FLAGS_SHIFT                       ( 15 ) 
#define DISEM_PRI_SET(x)                        ( ( (BYTE)(x)<<14 ) & 0x00004000 ) 
#define DISEM_PRI_GET(x)                        ((BYTE)( ( (x) & 0x00004000 )>>14 )) 
#define DISEM_PRI_MASK                          ( 0x00004000 )
#define DISEM_PRI_SHIFT                         ( 14 ) 
#define DISEM_GROUP_SET(x)                      ( ( (BYTE)(x)<<11 ) & 0x00003800 ) 
#define DISEM_GROUP_GET(x)                      ((BYTE)( ( (x) & 0x00003800 )>>11 )) 
#define DISEM_GROUP_MASK                        ( 0x00003800 )
#define DISEM_GROUP_SHIFT                       ( 11 ) 
#define DISEM_TYPE_SET(x)                       ( ( (BYTE)(x)<<9 ) & 0x00000600 ) 
#define DISEM_TYPE_GET(x)                       ((BYTE)( ( (x) & 0x00000600 )>>9 )) 
#define DISEM_TYPE_MASK                         ( 0x00000600 )
#define DISEM_TYPE_SHIFT                        ( 9 ) 
#define DISEM_REL_SET(x)                        ( ( (BYTE)(x)<<8 ) & 0x00000100 ) 
#define DISEM_REL_GET(x)                        ((BYTE)( ( (x) & 0x00000100 )>>8 )) 
#define DISEM_REL_MASK                          ( 0x00000100 )
#define DISEM_REL_SHIFT                         ( 8 ) 
#define DISEM_INDEX_SET(x)                      ( ( (BYTE)(x)<<0 ) & 0x000000FF ) 
#define DISEM_INDEX_GET(x)                      ((BYTE)( ( (x) & 0x000000FF )>>0 )) 
#define DISEM_INDEX_MASK                        ( 0x000000FF )
#define DISEM_INDEX_SHIFT                       ( 0 ) 
#define DISEM_TYPE_AXIS                         0x00000200
#define DISEM_TYPE_BUTTON                       0x00000400
#define DISEM_TYPE_POV                          0x00000600
/*
 *  Default Axis mapping is encoded as follows:
 *      X - X or steering axis
 *      Y - Y
 *      Z - Z, not throttle
 *      R - rZ or rudder
 *      U - rY (not available for WinMM unless 6DOF or head tracker)
 *      V - rx (not available for WinMM unless 6DOF or head tracker)
 *      A - Accellerator or throttle
 *      B - Brake
 *      C - Clutch
 *      S - Slider
 *      
 *      P - is used in fallback button flags to indicate a POV
 */
#define DISEM_FLAGS_X                           0x00008000
#define DISEM_FLAGS_Y                           0x00010000
#define DISEM_FLAGS_Z                           0x00018000
#define DISEM_FLAGS_R                           0x00020000
#define DISEM_FLAGS_U                           0x00028000
#define DISEM_FLAGS_V                           0x00030000
#define DISEM_FLAGS_A                           0x00038000
#define DISEM_FLAGS_B                           0x00040000
#define DISEM_FLAGS_C                           0x00048000
#define DISEM_FLAGS_S                           0x00050000

#define DISEM_FLAGS_P                           0x00078000

/* The reserved button values */


/*
 *  Any axis value can be set to relative by or'ing the appropriate flags.
 */
#define DIAXIS_RELATIVE                         0x00000100 
#define DIAXIS_ABSOLUTE                         0x00000000
#define DIPHYSICAL_KEYBOARD                     0x81000000
/* @doc EXTERNAL 
 * @Semantics Keyboard | 
 * @normal Genre:  <c 01  >
 */

//  NT puts them here in their keyboard driver              
//  So keep them in the same place to avoid problems later
#define DIKEYBOARD_F16                          0x81000467    //
#define DIKEYBOARD_F17                          0x81000468    //
#define DIKEYBOARD_F18                          0x81000469    //
#define DIKEYBOARD_F19                          0x8100046A    //
#define DIKEYBOARD_F20                          0x8100046B    //
#define DIKEYBOARD_F21                          0x8100046C    //
#define DIKEYBOARD_F22                          0x8100046D    //
#define DIKEYBOARD_F23                          0x8100046E    //
#define DIKEYBOARD_F24                          0x81000476    //
#define DIKEYBOARD_SHARP                        0x81000484    /* Hash-mark                      */
//k_def(DIK_SNAPSHOT       ,0xC5)    /* Print Screen */
#define DIPHYSICAL_MOUSE                        0x82000000
/* @doc EXTERNAL 
 * @Semantics MOUSE | 
 * @normal Genre:  <c 02  >
 */

#define DIPHYSICAL_VOICE                        0x83000000
/* @doc EXTERNAL 
 * @Semantics VOICE | 
 * @normal Genre:  <c 03  >
 */

/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Racing | 
 * @normal Genre:  <c 01  >
 */

#define DISEM_DEFAULTDEVICE_1 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGR_STEER>:0x01008A01
 *   Steering */
 /* @normal <c DIAXIS_DRIVINGR_ACCELERATE>:0x01039202
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGR_BRAKE>:0x01041203
 *   Brake-Axis */
 /* @normal <c DIBUTTON_DRIVINGR_SHIFTUP>:0x01000C01
 *    Shift to next higher gear */
 /* @normal <c DIBUTTON_DRIVINGR_SHIFTDOWN>:0x01000C02
 *    Shift to next lower gear */
 /* @normal <c DIBUTTON_DRIVINGR_VIEW>:0x01001C03
 *    Cycle through view options */
 /* @normal <c DIBUTTON_DRIVINGR_MENU>:0x010004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_DRIVINGR_ACCEL_AND_BRAKE>:0x01014A04
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIHATSWITCH_DRIVINGR_GLANCE>:0x01004601
 *   Look around */
 /* @normal <c DIBUTTON_DRIVINGR_BRAKE>:0x01004C04
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGR_DASHBOARD>:0x01004405
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGR_AIDS>:0x01004406
 *    Driver correction aids */
 /* @normal <c DIBUTTON_DRIVINGR_MAP>:0x01004407
 *    Display Driving Map */
 /* @normal <c DIBUTTON_DRIVINGR_BOOST>:0x01004408
 *    Turbo Boost */
 /* @normal <c DIBUTTON_DRIVINGR_PIT>:0x01004409
 *    Pit stop notification */
 /* @normal <c DIBUTTON_DRIVINGR_ACCELERATE_LINK>:0x0103D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGR_STEER_LEFT_LINK>:0x0100CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGR_STEER_RIGHT_LINK>:0x0100CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGR_GLANCE_LEFT_LINK>:0x0107C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGR_GLANCE_RIGHT_LINK>:0x0107C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGR_DEVICE>:0x010044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGR_PAUSE>:0x010044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Combat | 
 * @normal Genre:  <c 02  >
 */

#define DISEM_DEFAULTDEVICE_2 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGC_STEER>:0x02008A01
 *   Steering  */
 /* @normal <c DIAXIS_DRIVINGC_ACCELERATE>:0x02039202
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGC_BRAKE>:0x02041203
 *   Brake-axis */
 /* @normal <c DIBUTTON_DRIVINGC_FIRE>:0x02000C01
 *    Fire */
 /* @normal <c DIBUTTON_DRIVINGC_WEAPONS>:0x02000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_DRIVINGC_TARGET>:0x02000C03
 *    Select next available target */
 /* @normal <c DIBUTTON_DRIVINGC_MENU>:0x020004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_DRIVINGC_ACCEL_AND_BRAKE>:0x02014A04
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIHATSWITCH_DRIVINGC_GLANCE>:0x02004601
 *   Look around */
 /* @normal <c DIBUTTON_DRIVINGC_SHIFTUP>:0x02004C04
 *    Shift to next higher gear */
 /* @normal <c DIBUTTON_DRIVINGC_SHIFTDOWN>:0x02004C05
 *    Shift to next lower gear */
 /* @normal <c DIBUTTON_DRIVINGC_DASHBOARD>:0x02004406
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGC_AIDS>:0x02004407
 *    Driver correction aids */
 /* @normal <c DIBUTTON_DRIVINGC_BRAKE>:0x02004C08
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGC_FIRESECONDARY>:0x02004C09
 *    Alternative fire button */
 /* @normal <c DIBUTTON_DRIVINGC_ACCELERATE_LINK>:0x0203D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGC_STEER_LEFT_LINK>:0x0200CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGC_STEER_RIGHT_LINK>:0x0200CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGC_GLANCE_LEFT_LINK>:0x0207C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGC_GLANCE_RIGHT_LINK>:0x0207C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGC_DEVICE>:0x020044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGC_PAUSE>:0x020044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Tank | 
 * @normal Genre:  <c 03  >
 */

#define DISEM_DEFAULTDEVICE_3 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGT_STEER>:0x03008A01
 *   Turn tank left / right */
 /* @normal <c DIAXIS_DRIVINGT_BARREL>:0x03010202
 *   Raise / lower barrel */
 /* @normal <c DIAXIS_DRIVINGT_ACCELERATE>:0x03039203
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGT_ROTATE>:0x03020204
 *   Turn barrel left / right */
 /* @normal <c DIBUTTON_DRIVINGT_FIRE>:0x03000C01
 *    Fire */
 /* @normal <c DIBUTTON_DRIVINGT_WEAPONS>:0x03000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_DRIVINGT_TARGET>:0x03000C03
 *    Selects next available target */
 /* @normal <c DIBUTTON_DRIVINGT_MENU>:0x030004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_DRIVINGT_GLANCE>:0x03004601
 *   Look around */
 /* @normal <c DIAXIS_DRIVINGT_BRAKE>:0x03045205
 *   Brake-axis */
 /* @normal <c DIAXIS_DRIVINGT_ACCEL_AND_BRAKE>:0x03014A06
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIBUTTON_DRIVINGT_VIEW>:0x03005C04
 *    Cycle through view options */
 /* @normal <c DIBUTTON_DRIVINGT_DASHBOARD>:0x03005C05
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGT_BRAKE>:0x03004C06
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGT_FIRESECONDARY>:0x03004C07
 *    Alternative fire button */
 /* @normal <c DIBUTTON_DRIVINGT_ACCELERATE_LINK>:0x0303D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGT_STEER_LEFT_LINK>:0x0300CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGT_STEER_RIGHT_LINK>:0x0300CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGT_BARREL_UP_LINK>:0x030144E0
 *    Fallback Barrel up button */
 /* @normal <c DIBUTTON_DRIVINGT_BARREL_DOWN_LINK>:0x030144E8
 *    Fallback Barrel down button */
 /* @normal <c DIBUTTON_DRIVINGT_ROTATE_LEFT_LINK>:0x030244E4
 *    Fallback Rotate left button */
 /* @normal <c DIBUTTON_DRIVINGT_ROTATE_RIGHT_LINK>:0x030244EC
 *    Fallback Rotate right button */
 /* @normal <c DIBUTTON_DRIVINGT_GLANCE_LEFT_LINK>:0x0307C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGT_GLANCE_RIGHT_LINK>:0x0307C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGT_DEVICE>:0x030044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGT_PAUSE>:0x030044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Civilian  | 
 * @normal Genre:  <c 04  >
 */

#define DISEM_DEFAULTDEVICE_4 { DI8DEVTYPE_FLIGHT, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGC_BANK>:0x04008A01
 *   Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGC_PITCH>:0x04010A02
 *   Nose up / down */
 /* @normal <c DIAXIS_FLYINGC_THROTTLE>:0x04039203
 *   Throttle */
 /* @normal <c DIBUTTON_FLYINGC_VIEW>:0x04002401
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGC_DISPLAY>:0x04002402
 *    Select next dashboard / heads up display option */
 /* @normal <c DIBUTTON_FLYINGC_GEAR>:0x04002C03
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGC_MENU>:0x040004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGC_GLANCE>:0x04004601
 *   Look around */
 /* @normal <c DIAXIS_FLYINGC_BRAKE>:0x04046A04
 *   Apply Brake */
 /* @normal <c DIAXIS_FLYINGC_RUDDER>:0x04025205
 *   Yaw ship left/right */
 /* @normal <c DIAXIS_FLYINGC_FLAPS>:0x04055A06
 *   Flaps */
 /* @normal <c DIBUTTON_FLYINGC_FLAPSUP>:0x04006404
 *    Increment stepping up until fully retracted */
 /* @normal <c DIBUTTON_FLYINGC_FLAPSDOWN>:0x04006405
 *    Decrement stepping down until fully extended */
 /* @normal <c DIBUTTON_FLYINGC_BRAKE_LINK>:0x04046CE0
 *    Fallback brake button */
 /* @normal <c DIBUTTON_FLYINGC_FASTER_LINK>:0x0403D4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGC_SLOWER_LINK>:0x0403D4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_LEFT_LINK>:0x0407C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_RIGHT_LINK>:0x0407C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_UP_LINK>:0x0407C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_DOWN_LINK>:0x0407C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGC_DEVICE>:0x040044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGC_PAUSE>:0x040044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Military  | 
 * @normal Genre:  <c 05  >
 */

#define DISEM_DEFAULTDEVICE_5 { DI8DEVTYPE_FLIGHT, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGM_BANK>:0x05008A01
 *   Bank - Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGM_PITCH>:0x05010A02
 *   Pitch - Nose up / down */
 /* @normal <c DIAXIS_FLYINGM_THROTTLE>:0x05039203
 *   Throttle - faster / slower */
 /* @normal <c DIBUTTON_FLYINGM_FIRE>:0x05000C01
 *    Fire */
 /* @normal <c DIBUTTON_FLYINGM_WEAPONS>:0x05000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_FLYINGM_TARGET>:0x05000C03
 *    Selects next available target */
 /* @normal <c DIBUTTON_FLYINGM_MENU>:0x050004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGM_GLANCE>:0x05004601
 *   Look around */
 /* @normal <c DIBUTTON_FLYINGM_COUNTER>:0x05005C04
 *    Activate counter measures */
 /* @normal <c DIAXIS_FLYINGM_RUDDER>:0x05024A04
 *   Rudder - Yaw ship left/right */
 /* @normal <c DIAXIS_FLYINGM_BRAKE>:0x05046205
 *   Brake-axis */
 /* @normal <c DIBUTTON_FLYINGM_VIEW>:0x05006405
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGM_DISPLAY>:0x05006406
 *    Select next dashboard option */
 /* @normal <c DIAXIS_FLYINGM_FLAPS>:0x05055206
 *   Flaps */
 /* @normal <c DIBUTTON_FLYINGM_FLAPSUP>:0x05005407
 *    Increment stepping up until fully retracted */
 /* @normal <c DIBUTTON_FLYINGM_FLAPSDOWN>:0x05005408
 *    Decrement stepping down until fully extended */
 /* @normal <c DIBUTTON_FLYINGM_FIRESECONDARY>:0x05004C09
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FLYINGM_GEAR>:0x0500640A
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGM_BRAKE_LINK>:0x050464E0
 *    Fallback brake button */
 /* @normal <c DIBUTTON_FLYINGM_FASTER_LINK>:0x0503D4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGM_SLOWER_LINK>:0x0503D4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_LEFT_LINK>:0x0507C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_RIGHT_LINK>:0x0507C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_UP_LINK>:0x0507C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_DOWN_LINK>:0x0507C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGM_DEVICE>:0x050044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGM_PAUSE>:0x050044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Combat Helicopter | 
 * @normal Genre:  <c 06  >
 */

#define DISEM_DEFAULTDEVICE_6 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGH_BANK>:0x06008A01
 *   Bank - Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGH_PITCH>:0x06010A02
 *   Pitch - Nose up / down */
 /* @normal <c DIAXIS_FLYINGH_COLLECTIVE>:0x06018A03
 *   Collective - Blade pitch/power */
 /* @normal <c DIBUTTON_FLYINGH_FIRE>:0x06001401
 *    Fire */
 /* @normal <c DIBUTTON_FLYINGH_WEAPONS>:0x06001402
 *    Select next weapon */
 /* @normal <c DIBUTTON_FLYINGH_TARGET>:0x06001403
 *    Selects next available target */
 /* @normal <c DIBUTTON_FLYINGH_MENU>:0x060004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGH_GLANCE>:0x06004601
 *   Look around */
 /* @normal <c DIAXIS_FLYINGH_TORQUE>:0x06025A04
 *   Torque - Rotate ship around left / right axis */
 /* @normal <c DIAXIS_FLYINGH_THROTTLE>:0x0603DA05
 *   Throttle */
 /* @normal <c DIBUTTON_FLYINGH_COUNTER>:0x06005404
 *    Activate counter measures */
 /* @normal <c DIBUTTON_FLYINGH_VIEW>:0x06006405
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGH_GEAR>:0x06006406
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGH_FIRESECONDARY>:0x06004C07
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FLYINGH_FASTER_LINK>:0x0603DCE0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGH_SLOWER_LINK>:0x0603DCE8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_LEFT_LINK>:0x0607C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_RIGHT_LINK>:0x0607C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_UP_LINK>:0x0607C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_DOWN_LINK>:0x0607C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGH_DEVICE>:0x060044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGH_PAUSE>:0x060044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Space Simulator - Combat | 
 * @normal Genre:  <c 07  >
 */

#define DISEM_DEFAULTDEVICE_7 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SPACESIM_LATERAL>:0x07008201
 *   Move ship left / right */
 /* @normal <c DIAXIS_SPACESIM_MOVE>:0x07010202
 *   Move ship forward/backward */
 /* @normal <c DIAXIS_SPACESIM_THROTTLE>:0x07038203
 *   Throttle - Engine speed */
 /* @normal <c DIBUTTON_SPACESIM_FIRE>:0x07000401
 *    Fire */
 /* @normal <c DIBUTTON_SPACESIM_WEAPONS>:0x07000402
 *    Select next weapon */
 /* @normal <c DIBUTTON_SPACESIM_TARGET>:0x07000403
 *    Selects next available target */
 /* @normal <c DIBUTTON_SPACESIM_MENU>:0x070004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SPACESIM_GLANCE>:0x07004601
 *   Look around */
 /* @normal <c DIAXIS_SPACESIM_CLIMB>:0x0701C204
 *   Climb - Pitch ship up/down */
 /* @normal <c DIAXIS_SPACESIM_ROTATE>:0x07024205
 *   Rotate - Turn ship left/right */
 /* @normal <c DIBUTTON_SPACESIM_VIEW>:0x07004404
 *    Cycle through view options */
 /* @normal <c DIBUTTON_SPACESIM_DISPLAY>:0x07004405
 *    Select next dashboard / heads up display option */
 /* @normal <c DIBUTTON_SPACESIM_RAISE>:0x07004406
 *    Raise ship while maintaining current pitch */
 /* @normal <c DIBUTTON_SPACESIM_LOWER>:0x07004407
 *    Lower ship while maintaining current pitch */
 /* @normal <c DIBUTTON_SPACESIM_GEAR>:0x07004408
 *    Gear up / down */
 /* @normal <c DIBUTTON_SPACESIM_FIRESECONDARY>:0x07004409
 *    Alternative fire button */
 /* @normal <c DIBUTTON_SPACESIM_LEFT_LINK>:0x0700C4E4
 *    Fallback move left button */
 /* @normal <c DIBUTTON_SPACESIM_RIGHT_LINK>:0x0700C4EC
 *    Fallback move right button */
 /* @normal <c DIBUTTON_SPACESIM_FORWARD_LINK>:0x070144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SPACESIM_BACKWARD_LINK>:0x070144E8
 *    Fallback move backwards button */
 /* @normal <c DIBUTTON_SPACESIM_FASTER_LINK>:0x0703C4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_SPACESIM_SLOWER_LINK>:0x0703C4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_SPACESIM_TURN_LEFT_LINK>:0x070244E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_SPACESIM_TURN_RIGHT_LINK>:0x070244EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_LEFT_LINK>:0x0707C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_RIGHT_LINK>:0x0707C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_UP_LINK>:0x0707C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_DOWN_LINK>:0x0707C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_SPACESIM_DEVICE>:0x070044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SPACESIM_PAUSE>:0x070044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - First Person  | 
 * @normal Genre:  <c 08  >
 */

#define DISEM_DEFAULTDEVICE_8 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FIGHTINGH_LATERAL>:0x08008201
 *   Sidestep left/right */
 /* @normal <c DIAXIS_FIGHTINGH_MOVE>:0x08010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_FIGHTINGH_PUNCH>:0x08000401
 *    Punch */
 /* @normal <c DIBUTTON_FIGHTINGH_KICK>:0x08000402
 *    Kick */
 /* @normal <c DIBUTTON_FIGHTINGH_BLOCK>:0x08000403
 *    Block */
 /* @normal <c DIBUTTON_FIGHTINGH_CROUCH>:0x08000404
 *    Crouch */
 /* @normal <c DIBUTTON_FIGHTINGH_JUMP>:0x08000405
 *    Jump */
 /* @normal <c DIBUTTON_FIGHTINGH_SPECIAL1>:0x08000406
 *    Apply first special move */
 /* @normal <c DIBUTTON_FIGHTINGH_SPECIAL2>:0x08000407
 *    Apply second special move */
 /* @normal <c DIBUTTON_FIGHTINGH_MENU>:0x080004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FIGHTINGH_SELECT>:0x08004408
 *    Select special move */
 /* @normal <c DIHATSWITCH_FIGHTINGH_SLIDE>:0x08004601
 *   Look around */
 /* @normal <c DIBUTTON_FIGHTINGH_DISPLAY>:0x08004409
 *    Shows next on-screen display option */
 /* @normal <c DIAXIS_FIGHTINGH_ROTATE>:0x08024203
 *   Rotate - Turn body left/right */
 /* @normal <c DIBUTTON_FIGHTINGH_DODGE>:0x0800440A
 *    Dodge */
 /* @normal <c DIBUTTON_FIGHTINGH_LEFT_LINK>:0x0800C4E4
 *    Fallback left sidestep button */
 /* @normal <c DIBUTTON_FIGHTINGH_RIGHT_LINK>:0x0800C4EC
 *    Fallback right sidestep button */
 /* @normal <c DIBUTTON_FIGHTINGH_FORWARD_LINK>:0x080144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_FIGHTINGH_BACKWARD_LINK>:0x080144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_FIGHTINGH_DEVICE>:0x080044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FIGHTINGH_PAUSE>:0x080044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - First Person Shooting | 
 * @normal Genre:  <c 09  >
 */

#define DISEM_DEFAULTDEVICE_9 { DI8DEVTYPE_1STPERSON,  }
 /* @normal <c DIAXIS_FPS_ROTATE>:0x09008201
 *   Rotate character left/right */
 /* @normal <c DIAXIS_FPS_MOVE>:0x09010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_FPS_FIRE>:0x09000401
 *    Fire */
 /* @normal <c DIBUTTON_FPS_WEAPONS>:0x09000402
 *    Select next weapon */
 /* @normal <c DIBUTTON_FPS_APPLY>:0x09000403
 *    Use item */
 /* @normal <c DIBUTTON_FPS_SELECT>:0x09000404
 *    Select next inventory item */
 /* @normal <c DIBUTTON_FPS_CROUCH>:0x09000405
 *    Crouch/ climb down/ swim down */
 /* @normal <c DIBUTTON_FPS_JUMP>:0x09000406
 *    Jump/ climb up/ swim up */
 /* @normal <c DIAXIS_FPS_LOOKUPDOWN>:0x09018203
 *   Look up / down  */
 /* @normal <c DIBUTTON_FPS_STRAFE>:0x09000407
 *    Enable strafing while active */
 /* @normal <c DIBUTTON_FPS_MENU>:0x090004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FPS_GLANCE>:0x09004601
 *   Look around */
 /* @normal <c DIBUTTON_FPS_DISPLAY>:0x09004408
 *    Shows next on-screen display option/ map */
 /* @normal <c DIAXIS_FPS_SIDESTEP>:0x09024204
 *   Sidestep */
 /* @normal <c DIBUTTON_FPS_DODGE>:0x09004409
 *    Dodge */
 /* @normal <c DIBUTTON_FPS_GLANCEL>:0x0900440A
 *    Glance Left */
 /* @normal <c DIBUTTON_FPS_GLANCER>:0x0900440B
 *    Glance Right */
 /* @normal <c DIBUTTON_FPS_FIRESECONDARY>:0x0900440C
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FPS_ROTATE_LEFT_LINK>:0x0900C4E4
 *    Fallback rotate left button */
 /* @normal <c DIBUTTON_FPS_ROTATE_RIGHT_LINK>:0x0900C4EC
 *    Fallback rotate right button */
 /* @normal <c DIBUTTON_FPS_FORWARD_LINK>:0x090144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_FPS_BACKWARD_LINK>:0x090144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_FPS_GLANCE_UP_LINK>:0x0901C4E0
 *    Fallback look up button */
 /* @normal <c DIBUTTON_FPS_GLANCE_DOWN_LINK>:0x0901C4E8
 *    Fallback look down button */
 /* @normal <c DIBUTTON_FPS_STEP_LEFT_LINK>:0x090244E4
 *    Fallback step left button */
 /* @normal <c DIBUTTON_FPS_STEP_RIGHT_LINK>:0x090244EC
 *    Fallback step right button */
 /* @normal <c DIBUTTON_FPS_DEVICE>:0x090044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FPS_PAUSE>:0x090044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - Third Person action | 
 * @normal Genre:  <c 10  >
 */

#define DISEM_DEFAULTDEVICE_10 { DI8DEVTYPE_1STPERSON,  }
 /* @normal <c DIAXIS_TPS_TURN>:0x0A020201
 *   Turn left/right */
 /* @normal <c DIAXIS_TPS_MOVE>:0x0A010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_TPS_RUN>:0x0A000401
 *    Run or walk toggle switch */
 /* @normal <c DIBUTTON_TPS_ACTION>:0x0A000402
 *    Action Button */
 /* @normal <c DIBUTTON_TPS_SELECT>:0x0A000403
 *    Select next weapon */
 /* @normal <c DIBUTTON_TPS_USE>:0x0A000404
 *    Use inventory item currently selected */
 /* @normal <c DIBUTTON_TPS_JUMP>:0x0A000405
 *    Character Jumps */
 /* @normal <c DIBUTTON_TPS_MENU>:0x0A0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_TPS_GLANCE>:0x0A004601
 *   Look around */
 /* @normal <c DIBUTTON_TPS_VIEW>:0x0A004406
 *    Select camera view */
 /* @normal <c DIBUTTON_TPS_STEPLEFT>:0x0A004407
 *    Character takes a left step */
 /* @normal <c DIBUTTON_TPS_STEPRIGHT>:0x0A004408
 *    Character takes a right step */
 /* @normal <c DIAXIS_TPS_STEP>:0x0A00C203
 *   Character steps left/right */
 /* @normal <c DIBUTTON_TPS_DODGE>:0x0A004409
 *    Character dodges or ducks */
 /* @normal <c DIBUTTON_TPS_INVENTORY>:0x0A00440A
 *    Cycle through inventory */
 /* @normal <c DIBUTTON_TPS_TURN_LEFT_LINK>:0x0A0244E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_TPS_TURN_RIGHT_LINK>:0x0A0244EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_TPS_FORWARD_LINK>:0x0A0144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_TPS_BACKWARD_LINK>:0x0A0144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_TPS_GLANCE_UP_LINK>:0x0A07C4E0
 *    Fallback look up button */
 /* @normal <c DIBUTTON_TPS_GLANCE_DOWN_LINK>:0x0A07C4E8
 *    Fallback look down button */
 /* @normal <c DIBUTTON_TPS_GLANCE_LEFT_LINK>:0x0A07C4E4
 *    Fallback glance up button */
 /* @normal <c DIBUTTON_TPS_GLANCE_RIGHT_LINK>:0x0A07C4EC
 *    Fallback glance right button */
 /* @normal <c DIBUTTON_TPS_DEVICE>:0x0A0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_TPS_PAUSE>:0x0A0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Strategy - Role Playing | 
 * @normal Genre:  <c 11  >
 */

#define DISEM_DEFAULTDEVICE_11 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_STRATEGYR_LATERAL>:0x0B008201
 *   sidestep - left/right */
 /* @normal <c DIAXIS_STRATEGYR_MOVE>:0x0B010202
 *   move forward/backward */
 /* @normal <c DIBUTTON_STRATEGYR_GET>:0x0B000401
 *    Acquire item */
 /* @normal <c DIBUTTON_STRATEGYR_APPLY>:0x0B000402
 *    Use selected item */
 /* @normal <c DIBUTTON_STRATEGYR_SELECT>:0x0B000403
 *    Select nextitem */
 /* @normal <c DIBUTTON_STRATEGYR_ATTACK>:0x0B000404
 *    Attack */
 /* @normal <c DIBUTTON_STRATEGYR_CAST>:0x0B000405
 *    Cast Spell */
 /* @normal <c DIBUTTON_STRATEGYR_CROUCH>:0x0B000406
 *    Crouch */
 /* @normal <c DIBUTTON_STRATEGYR_JUMP>:0x0B000407
 *    Jump */
 /* @normal <c DIBUTTON_STRATEGYR_MENU>:0x0B0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_STRATEGYR_GLANCE>:0x0B004601
 *   Look around */
 /* @normal <c DIBUTTON_STRATEGYR_MAP>:0x0B004408
 *    Cycle through map options */
 /* @normal <c DIBUTTON_STRATEGYR_DISPLAY>:0x0B004409
 *    Shows next on-screen display option */
 /* @normal <c DIAXIS_STRATEGYR_ROTATE>:0x0B024203
 *   Turn body left/right */
 /* @normal <c DIBUTTON_STRATEGYR_LEFT_LINK>:0x0B00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_STRATEGYR_RIGHT_LINK>:0x0B00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_STRATEGYR_FORWARD_LINK>:0x0B0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_STRATEGYR_BACK_LINK>:0x0B0144E8
 *    Fallback move backward button */
 /* @normal <c DIBUTTON_STRATEGYR_ROTATE_LEFT_LINK>:0x0B0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_STRATEGYR_ROTATE_RIGHT_LINK>:0x0B0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_STRATEGYR_DEVICE>:0x0B0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_STRATEGYR_PAUSE>:0x0B0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Strategy - Turn based | 
 * @normal Genre:  <c 12  >
 */

#define DISEM_DEFAULTDEVICE_12 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_STRATEGYT_LATERAL>:0x0C008201
 *   Sidestep left/right */
 /* @normal <c DIAXIS_STRATEGYT_MOVE>:0x0C010202
 *   Move forward/backwards */
 /* @normal <c DIBUTTON_STRATEGYT_SELECT>:0x0C000401
 *    Select unit or object */
 /* @normal <c DIBUTTON_STRATEGYT_INSTRUCT>:0x0C000402
 *    Cycle through instructions */
 /* @normal <c DIBUTTON_STRATEGYT_APPLY>:0x0C000403
 *    Apply selected instruction */
 /* @normal <c DIBUTTON_STRATEGYT_TEAM>:0x0C000404
 *    Select next team / cycle through all */
 /* @normal <c DIBUTTON_STRATEGYT_TURN>:0x0C000405
 *    Indicate turn over */
 /* @normal <c DIBUTTON_STRATEGYT_MENU>:0x0C0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_STRATEGYT_ZOOM>:0x0C004406
 *    Zoom - in / out */
 /* @normal <c DIBUTTON_STRATEGYT_MAP>:0x0C004407
 *    cycle through map options */
 /* @normal <c DIBUTTON_STRATEGYT_DISPLAY>:0x0C004408
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_STRATEGYT_LEFT_LINK>:0x0C00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_STRATEGYT_RIGHT_LINK>:0x0C00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_STRATEGYT_FORWARD_LINK>:0x0C0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_STRATEGYT_BACK_LINK>:0x0C0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_STRATEGYT_DEVICE>:0x0C0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_STRATEGYT_PAUSE>:0x0C0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hunting | 
 * @normal Genre:  <c 13  >
 */

#define DISEM_DEFAULTDEVICE_13 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HUNTING_LATERAL>:0x0D008201
 *   sidestep left/right */
 /* @normal <c DIAXIS_HUNTING_MOVE>:0x0D010202
 *   move forward/backwards */
 /* @normal <c DIBUTTON_HUNTING_FIRE>:0x0D000401
 *    Fire selected weapon */
 /* @normal <c DIBUTTON_HUNTING_AIM>:0x0D000402
 *    Select aim/move */
 /* @normal <c DIBUTTON_HUNTING_WEAPON>:0x0D000403
 *    Select next weapon */
 /* @normal <c DIBUTTON_HUNTING_BINOCULAR>:0x0D000404
 *    Look through Binoculars */
 /* @normal <c DIBUTTON_HUNTING_CALL>:0x0D000405
 *    Make animal call */
 /* @normal <c DIBUTTON_HUNTING_MAP>:0x0D000406
 *    View Map */
 /* @normal <c DIBUTTON_HUNTING_SPECIAL>:0x0D000407
 *    Special game operation */
 /* @normal <c DIBUTTON_HUNTING_MENU>:0x0D0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HUNTING_GLANCE>:0x0D004601
 *   Look around */
 /* @normal <c DIBUTTON_HUNTING_DISPLAY>:0x0D004408
 *    show next on-screen display option */
 /* @normal <c DIAXIS_HUNTING_ROTATE>:0x0D024203
 *   Turn body left/right */
 /* @normal <c DIBUTTON_HUNTING_CROUCH>:0x0D004409
 *    Crouch/ Climb / Swim down */
 /* @normal <c DIBUTTON_HUNTING_JUMP>:0x0D00440A
 *    Jump/ Climb up / Swim up */
 /* @normal <c DIBUTTON_HUNTING_FIRESECONDARY>:0x0D00440B
 *    Alternative fire button */
 /* @normal <c DIBUTTON_HUNTING_LEFT_LINK>:0x0D00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HUNTING_RIGHT_LINK>:0x0D00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HUNTING_FORWARD_LINK>:0x0D0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HUNTING_BACK_LINK>:0x0D0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HUNTING_ROTATE_LEFT_LINK>:0x0D0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_HUNTING_ROTATE_RIGHT_LINK>:0x0D0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_HUNTING_DEVICE>:0x0D0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HUNTING_PAUSE>:0x0D0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Fishing | 
 * @normal Genre:  <c 14  >
 */

#define DISEM_DEFAULTDEVICE_14 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FISHING_LATERAL>:0x0E008201
 *   sidestep left/right */
 /* @normal <c DIAXIS_FISHING_MOVE>:0x0E010202
 *   move forward/backwards */
 /* @normal <c DIBUTTON_FISHING_CAST>:0x0E000401
 *    Cast line */
 /* @normal <c DIBUTTON_FISHING_TYPE>:0x0E000402
 *    Select cast type */
 /* @normal <c DIBUTTON_FISHING_BINOCULAR>:0x0E000403
 *    Look through Binocular */
 /* @normal <c DIBUTTON_FISHING_BAIT>:0x0E000404
 *    Select type of Bait */
 /* @normal <c DIBUTTON_FISHING_MAP>:0x0E000405
 *    View Map */
 /* @normal <c DIBUTTON_FISHING_MENU>:0x0E0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FISHING_GLANCE>:0x0E004601
 *   Look around */
 /* @normal <c DIBUTTON_FISHING_DISPLAY>:0x0E004406
 *    Show next on-screen display option */
 /* @normal <c DIAXIS_FISHING_ROTATE>:0x0E024203
 *   Turn character left / right */
 /* @normal <c DIBUTTON_FISHING_CROUCH>:0x0E004407
 *    Crouch/ Climb / Swim down */
 /* @normal <c DIBUTTON_FISHING_JUMP>:0x0E004408
 *    Jump/ Climb up / Swim up */
 /* @normal <c DIBUTTON_FISHING_LEFT_LINK>:0x0E00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FISHING_RIGHT_LINK>:0x0E00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FISHING_FORWARD_LINK>:0x0E0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FISHING_BACK_LINK>:0x0E0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FISHING_ROTATE_LEFT_LINK>:0x0E0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_FISHING_ROTATE_RIGHT_LINK>:0x0E0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_FISHING_DEVICE>:0x0E0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FISHING_PAUSE>:0x0E0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Batting | 
 * @normal Genre:  <c 15  >
 */

#define DISEM_DEFAULTDEVICE_15 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLB_LATERAL>:0x0F008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLB_MOVE>:0x0F010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLB_SELECT>:0x0F000401
 *    cycle through swing options */
 /* @normal <c DIBUTTON_BASEBALLB_NORMAL>:0x0F000402
 *    normal swing */
 /* @normal <c DIBUTTON_BASEBALLB_POWER>:0x0F000403
 *    swing for the fence */
 /* @normal <c DIBUTTON_BASEBALLB_BUNT>:0x0F000404
 *    bunt */
 /* @normal <c DIBUTTON_BASEBALLB_STEAL>:0x0F000405
 *    Base runner attempts to steal a base */
 /* @normal <c DIBUTTON_BASEBALLB_BURST>:0x0F000406
 *    Base runner invokes burst of speed */
 /* @normal <c DIBUTTON_BASEBALLB_SLIDE>:0x0F000407
 *    Base runner slides into base */
 /* @normal <c DIBUTTON_BASEBALLB_CONTACT>:0x0F000408
 *    Contact swing */
 /* @normal <c DIBUTTON_BASEBALLB_MENU>:0x0F0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLB_NOSTEAL>:0x0F004409
 *    Base runner goes back to a base */
 /* @normal <c DIBUTTON_BASEBALLB_BOX>:0x0F00440A
 *    Enter or exit batting box */
 /* @normal <c DIBUTTON_BASEBALLB_LEFT_LINK>:0x0F00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BASEBALLB_RIGHT_LINK>:0x0F00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BASEBALLB_FORWARD_LINK>:0x0F0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLB_BACK_LINK>:0x0F0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLB_DEVICE>:0x0F0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLB_PAUSE>:0x0F0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Pitching | 
 * @normal Genre:  <c 16  >
 */

#define DISEM_DEFAULTDEVICE_16 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLP_LATERAL>:0x10008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLP_MOVE>:0x10010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLP_SELECT>:0x10000401
 *    cycle through pitch selections */
 /* @normal <c DIBUTTON_BASEBALLP_PITCH>:0x10000402
 *    throw pitch */
 /* @normal <c DIBUTTON_BASEBALLP_BASE>:0x10000403
 *    select base to throw to */
 /* @normal <c DIBUTTON_BASEBALLP_THROW>:0x10000404
 *    throw to base */
 /* @normal <c DIBUTTON_BASEBALLP_FAKE>:0x10000405
 *    Fake a throw to a base */
 /* @normal <c DIBUTTON_BASEBALLP_MENU>:0x100004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLP_WALK>:0x10004406
 *    Throw intentional walk / pitch out */
 /* @normal <c DIBUTTON_BASEBALLP_LOOK>:0x10004407
 *    Look at runners on bases */
 /* @normal <c DIBUTTON_BASEBALLP_LEFT_LINK>:0x1000C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BASEBALLP_RIGHT_LINK>:0x1000C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BASEBALLP_FORWARD_LINK>:0x100144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLP_BACK_LINK>:0x100144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLP_DEVICE>:0x100044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLP_PAUSE>:0x100044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Fielding | 
 * @normal Genre:  <c 17  >
 */

#define DISEM_DEFAULTDEVICE_17 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLF_LATERAL>:0x11008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLF_MOVE>:0x11010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLF_NEAREST>:0x11000401
 *    Switch to fielder nearest to the ball */
 /* @normal <c DIBUTTON_BASEBALLF_THROW1>:0x11000402
 *    Make conservative throw */
 /* @normal <c DIBUTTON_BASEBALLF_THROW2>:0x11000403
 *    Make aggressive throw */
 /* @normal <c DIBUTTON_BASEBALLF_BURST>:0x11000404
 *    Invoke burst of speed */
 /* @normal <c DIBUTTON_BASEBALLF_JUMP>:0x11000405
 *    Jump to catch ball */
 /* @normal <c DIBUTTON_BASEBALLF_DIVE>:0x11000406
 *    Dive to catch ball */
 /* @normal <c DIBUTTON_BASEBALLF_MENU>:0x110004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLF_SHIFTIN>:0x11004407
 *    Shift the infield positioning */
 /* @normal <c DIBUTTON_BASEBALLF_SHIFTOUT>:0x11004408
 *    Shift the outfield positioning */
 /* @normal <c DIBUTTON_BASEBALLF_AIM_LEFT_LINK>:0x1100C4E4
 *    Fallback aim left button */
 /* @normal <c DIBUTTON_BASEBALLF_AIM_RIGHT_LINK>:0x1100C4EC
 *    Fallback aim right button */
 /* @normal <c DIBUTTON_BASEBALLF_FORWARD_LINK>:0x110144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLF_BACK_LINK>:0x110144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLF_DEVICE>:0x110044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLF_PAUSE>:0x110044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Basketball - Offense | 
 * @normal Genre:  <c 18  >
 */

#define DISEM_DEFAULTDEVICE_18 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BBALLO_LATERAL>:0x12008201
 *   left / right */
 /* @normal <c DIAXIS_BBALLO_MOVE>:0x12010202
 *   up / down */
 /* @normal <c DIBUTTON_BBALLO_SHOOT>:0x12000401
 *    shoot basket */
 /* @normal <c DIBUTTON_BBALLO_DUNK>:0x12000402
 *    dunk basket */
 /* @normal <c DIBUTTON_BBALLO_PASS>:0x12000403
 *    throw pass */
 /* @normal <c DIBUTTON_BBALLO_FAKE>:0x12000404
 *    fake shot or pass */
 /* @normal <c DIBUTTON_BBALLO_SPECIAL>:0x12000405
 *    apply special move */
 /* @normal <c DIBUTTON_BBALLO_PLAYER>:0x12000406
 *    select next player */
 /* @normal <c DIBUTTON_BBALLO_BURST>:0x12000407
 *    invoke burst */
 /* @normal <c DIBUTTON_BBALLO_CALL>:0x12000408
 *    call for ball / pass to me */
 /* @normal <c DIBUTTON_BBALLO_MENU>:0x120004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BBALLO_GLANCE>:0x12004601
 *   scroll view */
 /* @normal <c DIBUTTON_BBALLO_SCREEN>:0x12004409
 *    Call for screen */
 /* @normal <c DIBUTTON_BBALLO_PLAY>:0x1200440A
 *    Call for specific offensive play */
 /* @normal <c DIBUTTON_BBALLO_JAB>:0x1200440B
 *    Initiate fake drive to basket */
 /* @normal <c DIBUTTON_BBALLO_POST>:0x1200440C
 *    Perform post move */
 /* @normal <c DIBUTTON_BBALLO_TIMEOUT>:0x1200440D
 *    Time Out */
 /* @normal <c DIBUTTON_BBALLO_SUBSTITUTE>:0x1200440E
 *    substitute one player for another */
 /* @normal <c DIBUTTON_BBALLO_LEFT_LINK>:0x1200C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BBALLO_RIGHT_LINK>:0x1200C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BBALLO_FORWARD_LINK>:0x120144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BBALLO_BACK_LINK>:0x120144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BBALLO_DEVICE>:0x120044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BBALLO_PAUSE>:0x120044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Basketball - Defense | 
 * @normal Genre:  <c 19  >
 */

#define DISEM_DEFAULTDEVICE_19 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BBALLD_LATERAL>:0x13008201
 *   left / right */
 /* @normal <c DIAXIS_BBALLD_MOVE>:0x13010202
 *   up / down */
 /* @normal <c DIBUTTON_BBALLD_JUMP>:0x13000401
 *    jump to block shot */
 /* @normal <c DIBUTTON_BBALLD_STEAL>:0x13000402
 *    attempt to steal ball */
 /* @normal <c DIBUTTON_BBALLD_FAKE>:0x13000403
 *    fake block or steal */
 /* @normal <c DIBUTTON_BBALLD_SPECIAL>:0x13000404
 *    apply special move */
 /* @normal <c DIBUTTON_BBALLD_PLAYER>:0x13000405
 *    select next player */
 /* @normal <c DIBUTTON_BBALLD_BURST>:0x13000406
 *    invoke burst */
 /* @normal <c DIBUTTON_BBALLD_PLAY>:0x13000407
 *    call for specific defensive play */
 /* @normal <c DIBUTTON_BBALLD_MENU>:0x130004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BBALLD_GLANCE>:0x13004601
 *   scroll view */
 /* @normal <c DIBUTTON_BBALLD_TIMEOUT>:0x13004408
 *    Time Out */
 /* @normal <c DIBUTTON_BBALLD_SUBSTITUTE>:0x13004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_BBALLD_LEFT_LINK>:0x1300C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BBALLD_RIGHT_LINK>:0x1300C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BBALLD_FORWARD_LINK>:0x130144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BBALLD_BACK_LINK>:0x130144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BBALLD_DEVICE>:0x130044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BBALLD_PAUSE>:0x130044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Play | 
 * @normal Genre:  <c 20  >
 */

#define DISEM_DEFAULTDEVICE_20 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIBUTTON_FOOTBALLP_PLAY>:0x14000401
 *    cycle through available plays */
 /* @normal <c DIBUTTON_FOOTBALLP_SELECT>:0x14000402
 *    select play */
 /* @normal <c DIBUTTON_FOOTBALLP_HELP>:0x14000403
 *    Bring up pop-up help */
 /* @normal <c DIBUTTON_FOOTBALLP_MENU>:0x140004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLP_DEVICE>:0x140044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLP_PAUSE>:0x140044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - QB | 
 * @normal Genre:  <c 21  >
 */

#define DISEM_DEFAULTDEVICE_21 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLQ_LATERAL>:0x15008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLQ_MOVE>:0x15010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLQ_SELECT>:0x15000401
 *    Select */
 /* @normal <c DIBUTTON_FOOTBALLQ_SNAP>:0x15000402
 *    snap ball - start play */
 /* @normal <c DIBUTTON_FOOTBALLQ_JUMP>:0x15000403
 *    jump over defender */
 /* @normal <c DIBUTTON_FOOTBALLQ_SLIDE>:0x15000404
 *    Dive/Slide */
 /* @normal <c DIBUTTON_FOOTBALLQ_PASS>:0x15000405
 *    throws pass to receiver */
 /* @normal <c DIBUTTON_FOOTBALLQ_FAKE>:0x15000406
 *    pump fake pass or fake kick */
 /* @normal <c DIBUTTON_FOOTBALLQ_MENU>:0x150004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLQ_FAKESNAP>:0x15004407
 *    Fake snap  */
 /* @normal <c DIBUTTON_FOOTBALLQ_MOTION>:0x15004408
 *    Send receivers in motion */
 /* @normal <c DIBUTTON_FOOTBALLQ_AUDIBLE>:0x15004409
 *    Change offensive play at line of scrimmage */
 /* @normal <c DIBUTTON_FOOTBALLQ_LEFT_LINK>:0x1500C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLQ_RIGHT_LINK>:0x1500C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLQ_FORWARD_LINK>:0x150144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLQ_BACK_LINK>:0x150144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLQ_DEVICE>:0x150044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLQ_PAUSE>:0x150044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Offense | 
 * @normal Genre:  <c 22  >
 */

#define DISEM_DEFAULTDEVICE_22 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLO_LATERAL>:0x16008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLO_MOVE>:0x16010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLO_JUMP>:0x16000401
 *    jump or hurdle over defender */
 /* @normal <c DIBUTTON_FOOTBALLO_LEFTARM>:0x16000402
 *    holds out left arm */
 /* @normal <c DIBUTTON_FOOTBALLO_RIGHTARM>:0x16000403
 *    holds out right arm */
 /* @normal <c DIBUTTON_FOOTBALLO_THROW>:0x16000404
 *    throw pass or lateral ball to another runner */
 /* @normal <c DIBUTTON_FOOTBALLO_SPIN>:0x16000405
 *    Spin to avoid defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_MENU>:0x160004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLO_JUKE>:0x16004406
 *    Use special move to avoid defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_SHOULDER>:0x16004407
 *    Lower shoulder to run over defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_TURBO>:0x16004408
 *    Speed burst past defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_DIVE>:0x16004409
 *    Dive over defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_ZOOM>:0x1600440A
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_FOOTBALLO_SUBSTITUTE>:0x1600440B
 *    substitute one player for another */
 /* @normal <c DIBUTTON_FOOTBALLO_LEFT_LINK>:0x1600C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLO_RIGHT_LINK>:0x1600C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLO_FORWARD_LINK>:0x160144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLO_BACK_LINK>:0x160144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLO_DEVICE>:0x160044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLO_PAUSE>:0x160044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Defense | 
 * @normal Genre:  <c 23  >
 */

#define DISEM_DEFAULTDEVICE_23 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLD_LATERAL>:0x17008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLD_MOVE>:0x17010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLD_PLAY>:0x17000401
 *    cycle through available plays */
 /* @normal <c DIBUTTON_FOOTBALLD_SELECT>:0x17000402
 *    select player closest to the ball */
 /* @normal <c DIBUTTON_FOOTBALLD_JUMP>:0x17000403
 *    jump to intercept or block */
 /* @normal <c DIBUTTON_FOOTBALLD_TACKLE>:0x17000404
 *    tackler runner */
 /* @normal <c DIBUTTON_FOOTBALLD_FAKE>:0x17000405
 *    hold down to fake tackle or intercept */
 /* @normal <c DIBUTTON_FOOTBALLD_SUPERTACKLE>:0x17000406
 *    Initiate special tackle */
 /* @normal <c DIBUTTON_FOOTBALLD_MENU>:0x170004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLD_SPIN>:0x17004407
 *    Spin to beat offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_SWIM>:0x17004408
 *    Swim to beat the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_BULLRUSH>:0x17004409
 *    Bull rush the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_RIP>:0x1700440A
 *    Rip the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_AUDIBLE>:0x1700440B
 *    Change defensive play at the line of scrimmage */
 /* @normal <c DIBUTTON_FOOTBALLD_ZOOM>:0x1700440C
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_FOOTBALLD_SUBSTITUTE>:0x1700440D
 *    substitute one player for another */
 /* @normal <c DIBUTTON_FOOTBALLD_LEFT_LINK>:0x1700C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLD_RIGHT_LINK>:0x1700C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLD_FORWARD_LINK>:0x170144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLD_BACK_LINK>:0x170144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLD_DEVICE>:0x170044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLD_PAUSE>:0x170044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Golf | 
 * @normal Genre:  <c 24  >
 */

#define DISEM_DEFAULTDEVICE_24 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_GOLF_LATERAL>:0x18008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_GOLF_MOVE>:0x18010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_GOLF_SWING>:0x18000401
 *    swing club */
 /* @normal <c DIBUTTON_GOLF_SELECT>:0x18000402
 *    cycle between: club / swing strength / ball arc / ball spin */
 /* @normal <c DIBUTTON_GOLF_UP>:0x18000403
 *    increase selection */
 /* @normal <c DIBUTTON_GOLF_DOWN>:0x18000404
 *    decrease selection */
 /* @normal <c DIBUTTON_GOLF_TERRAIN>:0x18000405
 *    shows terrain detail */
 /* @normal <c DIBUTTON_GOLF_FLYBY>:0x18000406
 *    view the hole via a flyby */
 /* @normal <c DIBUTTON_GOLF_MENU>:0x180004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_GOLF_SCROLL>:0x18004601
 *   scroll view */
 /* @normal <c DIBUTTON_GOLF_ZOOM>:0x18004407
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_GOLF_TIMEOUT>:0x18004408
 *    Call for time out */
 /* @normal <c DIBUTTON_GOLF_SUBSTITUTE>:0x18004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_GOLF_LEFT_LINK>:0x1800C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_GOLF_RIGHT_LINK>:0x1800C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_GOLF_FORWARD_LINK>:0x180144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_GOLF_BACK_LINK>:0x180144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_GOLF_DEVICE>:0x180044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_GOLF_PAUSE>:0x180044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Offense | 
 * @normal Genre:  <c 25  >
 */

#define DISEM_DEFAULTDEVICE_25 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYO_LATERAL>:0x19008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYO_MOVE>:0x19010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYO_SHOOT>:0x19000401
 *    Shoot */
 /* @normal <c DIBUTTON_HOCKEYO_PASS>:0x19000402
 *    pass the puck */
 /* @normal <c DIBUTTON_HOCKEYO_BURST>:0x19000403
 *    invoke speed burst */
 /* @normal <c DIBUTTON_HOCKEYO_SPECIAL>:0x19000404
 *    invoke special move */
 /* @normal <c DIBUTTON_HOCKEYO_FAKE>:0x19000405
 *    hold down to fake pass or kick */
 /* @normal <c DIBUTTON_HOCKEYO_MENU>:0x190004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYO_SCROLL>:0x19004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYO_ZOOM>:0x19004406
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYO_STRATEGY>:0x19004407
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYO_TIMEOUT>:0x19004408
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYO_SUBSTITUTE>:0x19004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYO_LEFT_LINK>:0x1900C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYO_RIGHT_LINK>:0x1900C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYO_FORWARD_LINK>:0x190144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYO_BACK_LINK>:0x190144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYO_DEVICE>:0x190044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYO_PAUSE>:0x190044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Defense | 
 * @normal Genre:  <c 26  >
 */

#define DISEM_DEFAULTDEVICE_26 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYD_LATERAL>:0x1A008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYD_MOVE>:0x1A010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYD_PLAYER>:0x1A000401
 *    control player closest to the puck */
 /* @normal <c DIBUTTON_HOCKEYD_STEAL>:0x1A000402
 *    attempt steal */
 /* @normal <c DIBUTTON_HOCKEYD_BURST>:0x1A000403
 *    speed burst or body check */
 /* @normal <c DIBUTTON_HOCKEYD_BLOCK>:0x1A000404
 *    block puck */
 /* @normal <c DIBUTTON_HOCKEYD_FAKE>:0x1A000405
 *    hold down to fake tackle or intercept */
 /* @normal <c DIBUTTON_HOCKEYD_MENU>:0x1A0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYD_SCROLL>:0x1A004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYD_ZOOM>:0x1A004406
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYD_STRATEGY>:0x1A004407
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYD_TIMEOUT>:0x1A004408
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYD_SUBSTITUTE>:0x1A004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYD_LEFT_LINK>:0x1A00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYD_RIGHT_LINK>:0x1A00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYD_FORWARD_LINK>:0x1A0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYD_BACK_LINK>:0x1A0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYD_DEVICE>:0x1A0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYD_PAUSE>:0x1A0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Goalie | 
 * @normal Genre:  <c 27  >
 */

#define DISEM_DEFAULTDEVICE_27 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYG_LATERAL>:0x1B008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYG_MOVE>:0x1B010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYG_PASS>:0x1B000401
 *    pass puck */
 /* @normal <c DIBUTTON_HOCKEYG_POKE>:0x1B000402
 *    poke / check / hack */
 /* @normal <c DIBUTTON_HOCKEYG_STEAL>:0x1B000403
 *    attempt steal */
 /* @normal <c DIBUTTON_HOCKEYG_BLOCK>:0x1B000404
 *    block puck */
 /* @normal <c DIBUTTON_HOCKEYG_MENU>:0x1B0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYG_SCROLL>:0x1B004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYG_ZOOM>:0x1B004405
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYG_STRATEGY>:0x1B004406
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYG_TIMEOUT>:0x1B004407
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYG_SUBSTITUTE>:0x1B004408
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYG_LEFT_LINK>:0x1B00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYG_RIGHT_LINK>:0x1B00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYG_FORWARD_LINK>:0x1B0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYG_BACK_LINK>:0x1B0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYG_DEVICE>:0x1B0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYG_PAUSE>:0x1B0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Mountain Biking | 
 * @normal Genre:  <c 28  >
 */

#define DISEM_DEFAULTDEVICE_28 { DI8DEVTYPE_JOYSTICK, DI8DEVTYPE_GAMEPAD,  }
 /* @normal <c DIAXIS_BIKINGM_TURN>:0x1C008201
 *   left / right */
 /* @normal <c DIAXIS_BIKINGM_PEDAL>:0x1C010202
 *   Pedal faster / slower / brake */
 /* @normal <c DIBUTTON_BIKINGM_JUMP>:0x1C000401
 *    jump over obstacle */
 /* @normal <c DIBUTTON_BIKINGM_CAMERA>:0x1C000402
 *    switch camera view */
 /* @normal <c DIBUTTON_BIKINGM_SPECIAL1>:0x1C000403
 *    perform first special move */
 /* @normal <c DIBUTTON_BIKINGM_SELECT>:0x1C000404
 *    Select */
 /* @normal <c DIBUTTON_BIKINGM_SPECIAL2>:0x1C000405
 *    perform second special move */
 /* @normal <c DIBUTTON_BIKINGM_MENU>:0x1C0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BIKINGM_SCROLL>:0x1C004601
 *   scroll view */
 /* @normal <c DIBUTTON_BIKINGM_ZOOM>:0x1C004406
 *    Zoom view in / out */
 /* @normal <c DIAXIS_BIKINGM_BRAKE>:0x1C044203
 *   Brake axis  */
 /* @normal <c DIBUTTON_BIKINGM_LEFT_LINK>:0x1C00C4E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_BIKINGM_RIGHT_LINK>:0x1C00C4EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_BIKINGM_FASTER_LINK>:0x1C0144E0
 *    Fallback pedal faster button */
 /* @normal <c DIBUTTON_BIKINGM_SLOWER_LINK>:0x1C0144E8
 *    Fallback pedal slower button */
 /* @normal <c DIBUTTON_BIKINGM_BRAKE_BUTTON_LINK>:0x1C0444E8
 *    Fallback brake button */
 /* @normal <c DIBUTTON_BIKINGM_DEVICE>:0x1C0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BIKINGM_PAUSE>:0x1C0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports: Skiing / Snowboarding / Skateboarding | 
 * @normal Genre:  <c 29  >
 */

#define DISEM_DEFAULTDEVICE_29 { DI8DEVTYPE_JOYSTICK, DI8DEVTYPE_GAMEPAD ,  }
 /* @normal <c DIAXIS_SKIING_TURN>:0x1D008201
 *   left / right */
 /* @normal <c DIAXIS_SKIING_SPEED>:0x1D010202
 *   faster / slower */
 /* @normal <c DIBUTTON_SKIING_JUMP>:0x1D000401
 *    Jump */
 /* @normal <c DIBUTTON_SKIING_CROUCH>:0x1D000402
 *    crouch down */
 /* @normal <c DIBUTTON_SKIING_CAMERA>:0x1D000403
 *    switch camera view */
 /* @normal <c DIBUTTON_SKIING_SPECIAL1>:0x1D000404
 *    perform first special move */
 /* @normal <c DIBUTTON_SKIING_SELECT>:0x1D000405
 *    Select */
 /* @normal <c DIBUTTON_SKIING_SPECIAL2>:0x1D000406
 *    perform second special move */
 /* @normal <c DIBUTTON_SKIING_MENU>:0x1D0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SKIING_GLANCE>:0x1D004601
 *   scroll view */
 /* @normal <c DIBUTTON_SKIING_ZOOM>:0x1D004407
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_SKIING_LEFT_LINK>:0x1D00C4E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_SKIING_RIGHT_LINK>:0x1D00C4EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_SKIING_FASTER_LINK>:0x1D0144E0
 *    Fallback increase speed button */
 /* @normal <c DIBUTTON_SKIING_SLOWER_LINK>:0x1D0144E8
 *    Fallback decrease speed button */
 /* @normal <c DIBUTTON_SKIING_DEVICE>:0x1D0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SKIING_PAUSE>:0x1D0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Soccer - Offense | 
 * @normal Genre:  <c 30  >
 */

#define DISEM_DEFAULTDEVICE_30 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SOCCERO_LATERAL>:0x1E008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_SOCCERO_MOVE>:0x1E010202
 *   Move / Aim: up / down */
 /* @normal <c DIAXIS_SOCCERO_BEND>:0x1E018203
 *   Bend to soccer shot/pass */
 /* @normal <c DIBUTTON_SOCCERO_SHOOT>:0x1E000401
 *    Shoot the ball */
 /* @normal <c DIBUTTON_SOCCERO_PASS>:0x1E000402
 *    Pass  */
 /* @normal <c DIBUTTON_SOCCERO_FAKE>:0x1E000403
 *    Fake */
 /* @normal <c DIBUTTON_SOCCERO_PLAYER>:0x1E000404
 *    Select next player */
 /* @normal <c DIBUTTON_SOCCERO_SPECIAL1>:0x1E000405
 *    Apply special move */
 /* @normal <c DIBUTTON_SOCCERO_SELECT>:0x1E000406
 *    Select special move */
 /* @normal <c DIBUTTON_SOCCERO_MENU>:0x1E0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SOCCERO_GLANCE>:0x1E004601
 *   scroll view */
 /* @normal <c DIBUTTON_SOCCERO_SUBSTITUTE>:0x1E004407
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_SOCCERO_SHOOTLOW>:0x1E004408
 *    Shoot the ball low */
 /* @normal <c DIBUTTON_SOCCERO_SHOOTHIGH>:0x1E004409
 *    Shoot the ball high */
 /* @normal <c DIBUTTON_SOCCERO_PASSTHRU>:0x1E00440A
 *    Make a thru pass */
 /* @normal <c DIBUTTON_SOCCERO_SPRINT>:0x1E00440B
 *    Sprint / turbo boost */
 /* @normal <c DIBUTTON_SOCCERO_CONTROL>:0x1E00440C
 *    Obtain control of the ball */
 /* @normal <c DIBUTTON_SOCCERO_HEAD>:0x1E00440D
 *    Attempt to head the ball */
 /* @normal <c DIBUTTON_SOCCERO_LEFT_LINK>:0x1E00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_SOCCERO_RIGHT_LINK>:0x1E00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_SOCCERO_FORWARD_LINK>:0x1E0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SOCCERO_BACK_LINK>:0x1E0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_SOCCERO_DEVICE>:0x1E0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SOCCERO_PAUSE>:0x1E0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Soccer - Defense | 
 * @normal Genre:  <c 31  >
 */

#define DISEM_DEFAULTDEVICE_31 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SOCCERD_LATERAL>:0x1F008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_SOCCERD_MOVE>:0x1F010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_SOCCERD_BLOCK>:0x1F000401
 *    Attempt to block shot */
 /* @normal <c DIBUTTON_SOCCERD_STEAL>:0x1F000402
 *    Attempt to steal ball */
 /* @normal <c DIBUTTON_SOCCERD_FAKE>:0x1F000403
 *    Fake a block or a steal */
 /* @normal <c DIBUTTON_SOCCERD_PLAYER>:0x1F000404
 *    Select next player */
 /* @normal <c DIBUTTON_SOCCERD_SPECIAL>:0x1F000405
 *    Apply special move */
 /* @normal <c DIBUTTON_SOCCERD_SELECT>:0x1F000406
 *    Select special move */
 /* @normal <c DIBUTTON_SOCCERD_SLIDE>:0x1F000407
 *    Attempt a slide tackle */
 /* @normal <c DIBUTTON_SOCCERD_MENU>:0x1F0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SOCCERD_GLANCE>:0x1F004601
 *   scroll view */
 /* @normal <c DIBUTTON_SOCCERD_FOUL>:0x1F004408
 *    Initiate a foul / hard-foul */
 /* @normal <c DIBUTTON_SOCCERD_HEAD>:0x1F004409
 *    Attempt a Header */
 /* @normal <c DIBUTTON_SOCCERD_CLEAR>:0x1F00440A
 *    Attempt to clear the ball down the field */
 /* @normal <c DIBUTTON_SOCCERD_GOALIECHARGE>:0x1F00440B
 *    Make the goalie charge out of the box */
 /* @normal <c DIBUTTON_SOCCERD_SUBSTITUTE>:0x1F00440C
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_SOCCERD_LEFT_LINK>:0x1F00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_SOCCERD_RIGHT_LINK>:0x1F00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_SOCCERD_FORWARD_LINK>:0x1F0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SOCCERD_BACK_LINK>:0x1F0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_SOCCERD_DEVICE>:0x1F0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SOCCERD_PAUSE>:0x1F0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Racquet | 
 * @normal Genre:  <c 32  >
 */

#define DISEM_DEFAULTDEVICE_32 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_RACQUET_LATERAL>:0x20008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_RACQUET_MOVE>:0x20010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_RACQUET_SWING>:0x20000401
 *    Swing racquet */
 /* @normal <c DIBUTTON_RACQUET_BACKSWING>:0x20000402
 *    Swing backhand */
 /* @normal <c DIBUTTON_RACQUET_SMASH>:0x20000403
 *    Smash shot */
 /* @normal <c DIBUTTON_RACQUET_SPECIAL>:0x20000404
 *    Special shot */
 /* @normal <c DIBUTTON_RACQUET_SELECT>:0x20000405
 *    Select special shot */
 /* @normal <c DIBUTTON_RACQUET_MENU>:0x200004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_RACQUET_GLANCE>:0x20004601
 *   scroll view */
 /* @normal <c DIBUTTON_RACQUET_TIMEOUT>:0x20004406
 *    Call for time out */
 /* @normal <c DIBUTTON_RACQUET_SUBSTITUTE>:0x20004407
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_RACQUET_LEFT_LINK>:0x2000C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_RACQUET_RIGHT_LINK>:0x2000C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_RACQUET_FORWARD_LINK>:0x200144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_RACQUET_BACK_LINK>:0x200144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_RACQUET_DEVICE>:0x200044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_RACQUET_PAUSE>:0x200044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Arcade- 2D | 
 * @normal Genre:  <c 33  >
 */

#define DISEM_DEFAULTDEVICE_33 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_ARCADES_LATERAL>:0x21008201
 *   left / right */
 /* @normal <c DIAXIS_ARCADES_MOVE>:0x21010202
 *   up / down */
 /* @normal <c DIBUTTON_ARCADES_THROW>:0x21000401
 *    throw object */
 /* @normal <c DIBUTTON_ARCADES_CARRY>:0x21000402
 *    carry object */
 /* @normal <c DIBUTTON_ARCADES_ATTACK>:0x21000403
 *    attack */
 /* @normal <c DIBUTTON_ARCADES_SPECIAL>:0x21000404
 *    apply special move */
 /* @normal <c DIBUTTON_ARCADES_SELECT>:0x21000405
 *    select special move */
 /* @normal <c DIBUTTON_ARCADES_MENU>:0x210004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_ARCADES_VIEW>:0x21004601
 *   scroll view left / right / up / down */
 /* @normal <c DIBUTTON_ARCADES_LEFT_LINK>:0x2100C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_ARCADES_RIGHT_LINK>:0x2100C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_ARCADES_FORWARD_LINK>:0x210144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_ARCADES_BACK_LINK>:0x210144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_UP_LINK>:0x2107C4E0
 *    Fallback scroll view up button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_DOWN_LINK>:0x2107C4E8
 *    Fallback scroll view down button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_LEFT_LINK>:0x2107C4E4
 *    Fallback scroll view left button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_RIGHT_LINK>:0x2107C4EC
 *    Fallback scroll view right button */
 /* @normal <c DIBUTTON_ARCADES_DEVICE>:0x210044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_ARCADES_PAUSE>:0x210044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Arcade - Platform Game | 
 * @normal Genre:  <c 34  >
 */

#define DISEM_DEFAULTDEVICE_34 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_ARCADEP_LATERAL>:0x22008201
 *   Left / right */
 /* @normal <c DIAXIS_ARCADEP_MOVE>:0x22010202
 *   Up / down */
 /* @normal <c DIBUTTON_ARCADEP_JUMP>:0x22000401
 *    Jump */
 /* @normal <c DIBUTTON_ARCADEP_FIRE>:0x22000402
 *    Fire */
 /* @normal <c DIBUTTON_ARCADEP_CROUCH>:0x22000403
 *    Crouch */
 /* @normal <c DIBUTTON_ARCADEP_SPECIAL>:0x22000404
 *    Apply special move */
 /* @normal <c DIBUTTON_ARCADEP_SELECT>:0x22000405
 *    Select special move */
 /* @normal <c DIBUTTON_ARCADEP_MENU>:0x220004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_ARCADEP_VIEW>:0x22004601
 *   Scroll view */
 /* @normal <c DIBUTTON_ARCADEP_FIRESECONDARY>:0x22004406
 *    Alternative fire button */
 /* @normal <c DIBUTTON_ARCADEP_LEFT_LINK>:0x2200C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_ARCADEP_RIGHT_LINK>:0x2200C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_ARCADEP_FORWARD_LINK>:0x220144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_ARCADEP_BACK_LINK>:0x220144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_UP_LINK>:0x2207C4E0
 *    Fallback scroll view up button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_DOWN_LINK>:0x2207C4E8
 *    Fallback scroll view down button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_LEFT_LINK>:0x2207C4E4
 *    Fallback scroll view left button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_RIGHT_LINK>:0x2207C4EC
 *    Fallback scroll view right button */
 /* @normal <c DIBUTTON_ARCADEP_DEVICE>:0x220044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_ARCADEP_PAUSE>:0x220044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 2D Object Control | 
 * @normal Genre:  <c 35  >
 */

#define DISEM_DEFAULTDEVICE_35 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_2DCONTROL_LATERAL>:0x23008201
 *   Move view left / right */
 /* @normal <c DIAXIS_2DCONTROL_MOVE>:0x23010202
 *   Move view up / down */
 /* @normal <c DIAXIS_2DCONTROL_INOUT>:0x23018203
 *   Zoom - in / out */
 /* @normal <c DIBUTTON_2DCONTROL_SELECT>:0x23000401
 *    Select Object */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL1>:0x23000402
 *    Do first special operation */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL>:0x23000403
 *    Select special operation */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL2>:0x23000404
 *    Do second special operation */
 /* @normal <c DIBUTTON_2DCONTROL_MENU>:0x230004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_2DCONTROL_HATSWITCH>:0x23004601
 *   Hat switch */
 /* @normal <c DIAXIS_2DCONTROL_ROTATEZ>:0x23024204
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIBUTTON_2DCONTROL_DISPLAY>:0x23004405
 *    Shows next on-screen display options */
 /* @normal <c DIBUTTON_2DCONTROL_DEVICE>:0x230044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_2DCONTROL_PAUSE>:0x230044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D object control | 
 * @normal Genre:  <c 36  >
 */

#define DISEM_DEFAULTDEVICE_36 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_3DCONTROL_LATERAL>:0x24008201
 *   Move view left / right */
 /* @normal <c DIAXIS_3DCONTROL_MOVE>:0x24010202
 *   Move view up / down */
 /* @normal <c DIAXIS_3DCONTROL_INOUT>:0x24018203
 *   Zoom - in / out */
 /* @normal <c DIBUTTON_3DCONTROL_SELECT>:0x24000401
 *    Select Object */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL1>:0x24000402
 *    Do first special operation */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL>:0x24000403
 *    Select special operation */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL2>:0x24000404
 *    Do second special operation */
 /* @normal <c DIBUTTON_3DCONTROL_MENU>:0x240004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_3DCONTROL_HATSWITCH>:0x24004601
 *   Hat switch */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEX>:0x24034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEY>:0x2402C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEZ>:0x24024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_3DCONTROL_DISPLAY>:0x24004405
 *    Show next on-screen display options */
 /* @normal <c DIBUTTON_3DCONTROL_DEVICE>:0x240044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_3DCONTROL_PAUSE>:0x240044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D Navigation - Fly through | 
 * @normal Genre:  <c 37  >
 */

#define DISEM_DEFAULTDEVICE_37 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_CADF_LATERAL>:0x25008201
 *   move view left / right */
 /* @normal <c DIAXIS_CADF_MOVE>:0x25010202
 *   move view up / down */
 /* @normal <c DIAXIS_CADF_INOUT>:0x25018203
 *   in / out */
 /* @normal <c DIBUTTON_CADF_SELECT>:0x25000401
 *    Select Object */
 /* @normal <c DIBUTTON_CADF_SPECIAL1>:0x25000402
 *    do first special operation */
 /* @normal <c DIBUTTON_CADF_SPECIAL>:0x25000403
 *    Select special operation */
 /* @normal <c DIBUTTON_CADF_SPECIAL2>:0x25000404
 *    do second special operation */
 /* @normal <c DIBUTTON_CADF_MENU>:0x250004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_CADF_HATSWITCH>:0x25004601
 *   Hat switch */
 /* @normal <c DIAXIS_CADF_ROTATEX>:0x25034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_CADF_ROTATEY>:0x2502C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_CADF_ROTATEZ>:0x25024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_CADF_DISPLAY>:0x25004405
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_CADF_DEVICE>:0x250044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_CADF_PAUSE>:0x250044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D Model Control | 
 * @normal Genre:  <c 38  >
 */

#define DISEM_DEFAULTDEVICE_38 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_CADM_LATERAL>:0x26008201
 *   move view left / right */
 /* @normal <c DIAXIS_CADM_MOVE>:0x26010202
 *   move view up / down */
 /* @normal <c DIAXIS_CADM_INOUT>:0x26018203
 *   in / out */
 /* @normal <c DIBUTTON_CADM_SELECT>:0x26000401
 *    Select Object */
 /* @normal <c DIBUTTON_CADM_SPECIAL1>:0x26000402
 *    do first special operation */
 /* @normal <c DIBUTTON_CADM_SPECIAL>:0x26000403
 *    Select special operation */
 /* @normal <c DIBUTTON_CADM_SPECIAL2>:0x26000404
 *    do second special operation */
 /* @normal <c DIBUTTON_CADM_MENU>:0x260004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_CADM_HATSWITCH>:0x26004601
 *   Hat switch */
 /* @normal <c DIAXIS_CADM_ROTATEX>:0x26034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_CADM_ROTATEY>:0x2602C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_CADM_ROTATEZ>:0x26024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_CADM_DISPLAY>:0x26004405
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_CADM_DEVICE>:0x260044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_CADM_PAUSE>:0x260044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Control - Media Equipment | 
 * @normal Genre:  <c 39  >
 */

#define DISEM_DEFAULTDEVICE_39 { DI8DEVTYPE_GAMEPAD,  }
 /* @normal <c DIAXIS_REMOTE_SLIDER>:0x27050201
 *   Slider for adjustment: volume / color / bass / etc */
 /* @normal <c DIBUTTON_REMOTE_MUTE>:0x27000401
 *    Set volume on current device to zero */
 /* @normal <c DIBUTTON_REMOTE_SELECT>:0x27000402
 *    Next/previous: channel/ track / chapter / picture / station */
 /* @normal <c DIBUTTON_REMOTE_PLAY>:0x27002403
 *    Start or pause entertainment on current device */
 /* @normal <c DIBUTTON_REMOTE_CUE>:0x27002404
 *    Move through current media */
 /* @normal <c DIBUTTON_REMOTE_REVIEW>:0x27002405
 *    Move through current media */
 /* @normal <c DIBUTTON_REMOTE_CHANGE>:0x27002406
 *    Select next device */
 /* @normal <c DIBUTTON_REMOTE_RECORD>:0x27002407
 *    Start recording the current media */
 /* @normal <c DIBUTTON_REMOTE_MENU>:0x270004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_REMOTE_SLIDER2>:0x27054202
 *   Slider for adjustment: volume */
 /* @normal <c DIBUTTON_REMOTE_TV>:0x27005C08
 *    Select TV */
 /* @normal <c DIBUTTON_REMOTE_CABLE>:0x27005C09
 *    Select cable box */
 /* @normal <c DIBUTTON_REMOTE_CD>:0x27005C0A
 *    Select CD player */
 /* @normal <c DIBUTTON_REMOTE_VCR>:0x27005C0B
 *    Select VCR */
 /* @normal <c DIBUTTON_REMOTE_TUNER>:0x27005C0C
 *    Select tuner */
 /* @normal <c DIBUTTON_REMOTE_DVD>:0x27005C0D
 *    Select DVD player */
 /* @normal <c DIBUTTON_REMOTE_ADJUST>:0x27005C0E
 *    Enter device adjustment menu */
 /* @normal <c DIBUTTON_REMOTE_DIGIT0>:0x2700540F
 *    Digit 0 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT1>:0x27005410
 *    Digit 1 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT2>:0x27005411
 *    Digit 2 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT3>:0x27005412
 *    Digit 3 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT4>:0x27005413
 *    Digit 4 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT5>:0x27005414
 *    Digit 5 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT6>:0x27005415
 *    Digit 6 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT7>:0x27005416
 *    Digit 7 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT8>:0x27005417
 *    Digit 8 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT9>:0x27005418
 *    Digit 9 */
 /* @normal <c DIBUTTON_REMOTE_DEVICE>:0x270044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_REMOTE_PAUSE>:0x270044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Control- Web | 
 * @normal Genre:  <c 40  >
 */

#define DISEM_DEFAULTDEVICE_40 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BROWSER_LATERAL>:0x28008201
 *   Move on screen pointer */
 /* @normal <c DIAXIS_BROWSER_MOVE>:0x28010202
 *   Move on screen pointer */
 /* @normal <c DIBUTTON_BROWSER_SELECT>:0x28000401
 *    Select current item */
 /* @normal <c DIAXIS_BROWSER_VIEW>:0x28018203
 *   Move view up/down */
 /* @normal <c DIBUTTON_BROWSER_REFRESH>:0x28000402
 *    Refresh */
 /* @normal <c DIBUTTON_BROWSER_MENU>:0x280004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BROWSER_SEARCH>:0x28004403
 *    Use search tool */
 /* @normal <c DIBUTTON_BROWSER_STOP>:0x28004404
 *    Cease current update */
 /* @normal <c DIBUTTON_BROWSER_HOME>:0x28004405
 *    Go directly to "home" location */
 /* @normal <c DIBUTTON_BROWSER_FAVORITES>:0x28004406
 *    Mark current site as favorite */
 /* @normal <c DIBUTTON_BROWSER_NEXT>:0x28004407
 *    Select Next page */
 /* @normal <c DIBUTTON_BROWSER_PREVIOUS>:0x28004408
 *    Select Previous page */
 /* @normal <c DIBUTTON_BROWSER_HISTORY>:0x28004409
 *    Show/Hide History */
 /* @normal <c DIBUTTON_BROWSER_PRINT>:0x2800440A
 *    Print current page */
 /* @normal <c DIBUTTON_BROWSER_DEVICE>:0x280044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BROWSER_PAUSE>:0x280044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Giant Walking Robot | 
 * @normal Genre:  <c 41  >
 */

#define DISEM_DEFAULTDEVICE_41 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_MECHA_STEER>:0x29008201
 *   Turns mecha left/right */
 /* @normal <c DIAXIS_MECHA_TORSO>:0x29010202
 *   Tilts torso forward/backward */
 /* @normal <c DIAXIS_MECHA_ROTATE>:0x29020203
 *   Turns torso left/right */
 /* @normal <c DIAXIS_MECHA_THROTTLE>:0x29038204
 *   Engine Speed */
 /* @normal <c DIBUTTON_MECHA_FIRE>:0x29000401
 *    Fire */
 /* @normal <c DIBUTTON_MECHA_WEAPONS>:0x29000402
 *    Select next weapon group */
 /* @normal <c DIBUTTON_MECHA_TARGET>:0x29000403
 *    Select closest enemy available target */
 /* @normal <c DIBUTTON_MECHA_REVERSE>:0x29000404
 *    Toggles throttle in/out of reverse */
 /* @normal <c DIBUTTON_MECHA_ZOOM>:0x29000405
 *    Zoom in/out targeting reticule */
 /* @normal <c DIBUTTON_MECHA_JUMP>:0x29000406
 *    Fires jump jets */
 /* @normal <c DIBUTTON_MECHA_MENU>:0x290004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_MECHA_CENTER>:0x29004407
 *    Center torso to legs */
 /* @normal <c DIHATSWITCH_MECHA_GLANCE>:0x29004601
 *   Look around */
 /* @normal <c DIBUTTON_MECHA_VIEW>:0x29004408
 *    Cycle through view options */
 /* @normal <c DIBUTTON_MECHA_FIRESECONDARY>:0x29004409
 *    Alternative fire button */
 /* @normal <c DIBUTTON_MECHA_LEFT_LINK>:0x2900C4E4
 *    Fallback steer left button */
 /* @normal <c DIBUTTON_MECHA_RIGHT_LINK>:0x2900C4EC
 *    Fallback steer right button */
 /* @normal <c DIBUTTON_MECHA_FORWARD_LINK>:0x290144E0
 *    Fallback tilt torso forward button */
 /* @normal <c DIBUTTON_MECHA_BACK_LINK>:0x290144E8
 *    Fallback tilt toroso backward button */
 /* @normal <c DIBUTTON_MECHA_ROTATE_LEFT_LINK>:0x290244E4
 *    Fallback rotate toroso right button */
 /* @normal <c DIBUTTON_MECHA_ROTATE_RIGHT_LINK>:0x290244EC
 *    Fallback rotate torso left button */
 /* @normal <c DIBUTTON_MECHA_FASTER_LINK>:0x2903C4E0
 *    Fallback increase engine speed */
 /* @normal <c DIBUTTON_MECHA_SLOWER_LINK>:0x2903C4E8
 *    Fallback decrease engine speed */
 /* @normal <c DIBUTTON_MECHA_DEVICE>:0x290044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_MECHA_PAUSE>:0x290044FC
 *    Start / Pause / Restart game */


#define DIAS_INDEX_SPECIAL                      0xFC
#define DIAS_INDEX_LINK                         0xE0
#define DIGENRE_ANY                             0xFF
#define DISEMGENRE_ANY                          0xFF000000
#define DISEM_TYPEANDMODE_GET(x)                ( ( x & ( DISEM_TYPE_MASK | DISEM_REL_MASK ) ) >> DISEM_REL_SHIFT )
#define DISEM_VALID                             ( ~DISEM_RES_MASK )

#if (DIRECTINPUT_VERSION >= 0x0800)
#define DISEM_MAX_GENRE      41
static const BYTE DiGenreDeviceOrder[DISEM_MAX_GENRE][DI8DEVTYPE_MAX-DI8DEVTYPE_MIN]={
DISEM_DEFAULTDEVICE_1,
DISEM_DEFAULTDEVICE_2,
DISEM_DEFAULTDEVICE_3,
DISEM_DEFAULTDEVICE_4,
DISEM_DEFAULTDEVICE_5,
DISEM_DEFAULTDEVICE_6,
DISEM_DEFAULTDEVICE_7,
DISEM_DEFAULTDEVICE_8,
DISEM_DEFAULTDEVICE_9,
DISEM_DEFAULTDEVICE_10,
DISEM_DEFAULTDEVICE_11,
DISEM_DEFAULTDEVICE_12,
DISEM_DEFAULTDEVICE_13,
DISEM_DEFAULTDEVICE_14,
DISEM_DEFAULTDEVICE_15,
DISEM_DEFAULTDEVICE_16,
DISEM_DEFAULTDEVICE_17,
DISEM_DEFAULTDEVICE_18,
DISEM_DEFAULTDEVICE_19,
DISEM_DEFAULTDEVICE_20,
DISEM_DEFAULTDEVICE_21,
DISEM_DEFAULTDEVICE_22,
DISEM_DEFAULTDEVICE_23,
DISEM_DEFAULTDEVICE_24,
DISEM_DEFAULTDEVICE_25,
DISEM_DEFAULTDEVICE_26,
DISEM_DEFAULTDEVICE_27,
DISEM_DEFAULTDEVICE_28,
DISEM_DEFAULTDEVICE_29,
DISEM_DEFAULTDEVICE_30,
DISEM_DEFAULTDEVICE_31,
DISEM_DEFAULTDEVICE_32,
DISEM_DEFAULTDEVICE_33,
DISEM_DEFAULTDEVICE_34,
DISEM_DEFAULTDEVICE_35,
DISEM_DEFAULTDEVICE_36,
DISEM_DEFAULTDEVICE_37,
DISEM_DEFAULTDEVICE_38,
DISEM_DEFAULTDEVICE_39,
DISEM_DEFAULTDEVICE_40,
DISEM_DEFAULTDEVICE_41,

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dpnathlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnathlp.h
 *
 *  Content:	Header for using DirectPlayNATHelp interface.
 *
 ***************************************************************************/



#ifndef __DPNATHLP_H__
#define __DPNATHLP_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT



#ifndef DPNATHLP_EXPORTS
#define DPNATHLPAPI DECLSPEC_IMPORT
#else
#define DPNATHLPAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DirectPlay NAT Helper object class IDs
 *
 ****************************************************************************/

// {B9C2E9C4-68C1-4d42-A7A1-E76A26982AD6}
DEFINE_GUID(CLSID_DirectPlayNATHelpUPnP, 
0xb9c2e9c4, 0x68c1, 0x4d42, 0xa7, 0xa1, 0xe7, 0x6a, 0x26, 0x98, 0x2a, 0xd6);

// {963AB779-16A1-477c-A36D-CB5E711938F7}
DEFINE_GUID(CLSID_DirectPlayNATHelpPAST, 
0x963ab779, 0x16a1, 0x477c, 0xa3, 0x6d, 0xcb, 0x5e, 0x71, 0x19, 0x38, 0xf7);




/****************************************************************************
 *
 * DirectPlay NAT Helper interface ID
 *
 ****************************************************************************/

// {154940B6-2278-4a2f-9101-9BA9F431F603}
DEFINE_GUID(IID_IDirectPlayNATHelp, 
0x154940b6, 0x2278, 0x4a2f, 0x91, 0x1, 0x9b, 0xa9, 0xf4, 0x31, 0xf6, 0x3);


/****************************************************************************
 *
 * DirectPlay NAT Helper interface pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlayNATHelp     *PDIRECTPLAYNATHELP;




/****************************************************************************
 *
 * DirectPlay NAT Helper data types
 *
 ****************************************************************************/

//
// Handles used to identify specific port binding groups.  If multiple ports
// are registered at the same time, the DPNHHANDLE refers to all ports.
//
typedef DWORD_PTR	DPNHHANDLE,	* PDPNHHANDLE;




/****************************************************************************
 *
 * DirectPlay NAT Helper constants
 *
 ****************************************************************************/

#define DPNH_MAX_SIMULTANEOUS_PORTS		16	// up to 16 ports may be specified in a single RegisterPorts call




/****************************************************************************
 *
 * DirectPlay NAT Helper API flags
 *
 ****************************************************************************/

//
// Flags that can be passed to Initialize
//
#define DPNHINITIALIZE_DISABLEGATEWAYSUPPORT				0x01	// disables Internet gateway traversal support (cannot be specified with DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
#define DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT			0x02	// disables local firewall traversal support (cannot be specified with DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)

//
// Flags that can be passed to GetCaps.
//
#define DPNHGETCAPS_UPDATESERVERSTATUS						0x01	// automatically extend expiring leases and detect changes in server status

//
// Flags that can be passed to RegisterPorts.
//
#define DPNHREGISTERPORTS_TCP								0x01	// request TCP ports instead of UDP
#define DPNHREGISTERPORTS_FIXEDPORTS						0x02	// asks the server to use the same port numbers on the public interface
#define DPNHREGISTERPORTS_SHAREDPORTS						0x04	// requests that the server allow the UDP fixed ports to be shared with other clients (must be specified with DPNHREGISTERPORTS_FIXEDPORTS and cannot be specified with DPNHREGISTERPORTS_TCP)

//
// Flags that can be passed to GetRegisteredAddresses.
//
#define DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY	0x01	// retrieve the public address for the local firewall only, even if mapped on remote Internet gateway

//
// Flags that can be passed to QueryAddress.
//
#define DPNHQUERYADDRESS_TCP								0x01	// request a TCP port instead of UDP
#define DPNHQUERYADDRESS_CACHEFOUND							0x02	// cache the discovered address if found
#define DPNHQUERYADDRESS_CACHENOTFOUND						0x04	// cache the fact that no address was found, if that is the case
#define DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED			0x08	// determine if the address is behind the same Internet gateway, but not mapped on that Internet gateway




/****************************************************************************
 *
 * DirectPlay NAT Helper structure flags
 *
 ****************************************************************************/

//
// DPNHCAPS flags
//
#define DPNHCAPSFLAG_LOCALFIREWALLPRESENT		0x01	// at least one network connection has a local firewall present
#define DPNHCAPSFLAG_GATEWAYPRESENT				0x02	// at least one network connection has an Internet gateway present
#define DPNHCAPSFLAG_GATEWAYISLOCAL				0x04	// a detected Internet gateway is local (i.e. the public address is another network interface on the same machine)
#define DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE		0x08	// at least one server has a valid public address for registered mappings
#define DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY	0x10	// at least one available server does not support an active-notification mechanisms and must be polled





/****************************************************************************
 *
 * DirectPlay NAT Helper structures
 *
 ****************************************************************************/
 
typedef struct _DPNHCAPS
{
	DWORD	dwSize;							// size of this structure, must be filled in prior to calling GetCaps
	DWORD	dwFlags;						// flags indicating capabilities of Internet gateway server(s)
	DWORD	dwNumRegisteredPorts;			// number of ports currently registered, including multiple ports registered at the same time (so this may not be equal to the number of DPNHHANDLEs given out)
	DWORD	dwMinLeaseTimeRemaining;		// approximate time remaining, in milliseconds, for the lease that will expire soonest
	DWORD	dwRecommendedGetCapsInterval;	// recommended time, in milliseconds, after which GetCaps should be called again (with DPNHGETCAPS_UPDATESERVERSTATUS flag)
} DPNHCAPS, * PDPNHCAPS;





/****************************************************************************
 *
 * Address type flags (returned by GetRegisteredAddresses)
 *
 ****************************************************************************/

#define DPNHADDRESSTYPE_TCP				0x01	// the mappings are for TCP ports instead of UDP
#define DPNHADDRESSTYPE_FIXEDPORTS		0x02	// the mappings are for ports which are the same on the Internet gateway 
#define DPNHADDRESSTYPE_SHAREDPORTS		0x04	// the mappings are for shared UDP fixed ports
#define DPNHADDRESSTYPE_LOCALFIREWALL	0x08	// the addresses are opened on a local firewall
#define DPNHADDRESSTYPE_GATEWAY			0x10	// the addresses are registered with an Internet gateway
#define DPNHADDRESSTYPE_GATEWAYISLOCAL	0x20	// the Internet gateway is local (i.e. the public address is another network interface on the same machine)




/****************************************************************************
 *
 * DirectPlay NAT Helper DLL exported functions
 *
 ****************************************************************************/

typedef HRESULT (WINAPI * PFN_DIRECTPLAYNATHELPCREATE)(const GUID * pIID, void ** ppvInterface);





/****************************************************************************
 *
 * DirectPlay NAT Helper application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayNATHelp
DECLARE_INTERFACE_(IDirectPlayNATHelp, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDirectPlayNATHelp methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)						(THIS_ DPNHCAPS * const dpnhcaps, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterPorts)				(THIS_ const SOCKADDR * const aLocalAddresses, const DWORD dwAddressesSize, const DWORD dwNumAddresses, const DWORD dwLeaseTime, DPNHHANDLE * const phRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(GetRegisteredAddresses)		(THIS_ const DPNHHANDLE hRegisteredPorts, SOCKADDR * const paPublicAddresses, DWORD * const pdwPublicAddressesSize, DWORD * const pdwAddressTypeFlags, DWORD * const pdwLeaseTimeRemaining, const DWORD dwFlags) PURE;
	STDMETHOD(DeregisterPorts)				(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(QueryAddress)					(THIS_ const SOCKADDR * const pSourceAddress, const SOCKADDR * const pQueryAddress, SOCKADDR * const pResponseAddress, const int iAddressesSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertEvent)				(THIS_ const HANDLE hEvent, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertIOCompletionPort)		(THIS_ const HANDLE hIOCompletionPort, const DWORD dwCompletionKey, const DWORD dwNumConcurrentThreads, const DWORD dwFlags) PURE;
	STDMETHOD(ExtendRegisteredPortsLease)	(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwLeaseTime, const DWORD dwFlags) PURE;
};




/****************************************************************************
 *
 * DirectPlay NAT Helper application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlayNATHelp_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->lpVtbl->Initialize(p,a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->lpVtbl->RegisterPorts(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->lpVtbl->GetRegisteredAddresses(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->lpVtbl->DeregisterPorts(p,a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->lpVtbl->QueryAddress(p,a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->lpVtbl->SetAlertEvent(p,a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->lpVtbl->SetAlertIOCompletionPort(p,a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->lpVtbl->ExtendRegisteredPortsLease(p,a,b,c)

#else // C++

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->AddRef()
#define	IDirectPlayNATHelp_Release(p)								(p)->Release()
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->Initialize(a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->Close(a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->RegisterPorts(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->GetRegisteredAddresses(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->DeregisterPorts(a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->QueryAddress(a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->SetAlertEvent(a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->SetAlertIOCompletionPort(a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->ExtendRegisteredPortsLease(a,b,c)

#endif



/****************************************************************************
 *
 * DirectPlay NAT Helper return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPNH_FACILITY_CODE					0x015
#define _DPNH_HRESULT_BASE					0xF000

#define MAKE_DPNHSUCCESS(code)				MAKE_HRESULT(0, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))
#define MAKE_DPNHFAILURE(code)				MAKE_HRESULT(1, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))



#define DPNH_OK								S_OK

#define DPNHSUCCESS_ADDRESSESCHANGED		MAKE_DPNHSUCCESS(0x10)

#define DPNHERR_ALREADYINITIALIZED			MAKE_DPNHFAILURE(0x10)
#define DPNHERR_BUFFERTOOSMALL				MAKE_DPNHFAILURE(0x20)
#define DPNHERR_GENERIC						E_FAIL
#define DPNHERR_INVALIDFLAGS				MAKE_DPNHFAILURE(0x30)
#define DPNHERR_INVALIDOBJECT				MAKE_DPNHFAILURE(0x40)
#define DPNHERR_INVALIDPARAM				E_INVALIDARG
#define DPNHERR_INVALIDPOINTER				E_POINTER
#define DPNHERR_NOMAPPING					MAKE_DPNHFAILURE(0x50)
#define DPNHERR_NOMAPPINGBUTPRIVATE			MAKE_DPNHFAILURE(0x60)
#define DPNHERR_NOTINITIALIZED				MAKE_DPNHFAILURE(0x70)
#define DPNHERR_OUTOFMEMORY					E_OUTOFMEMORY
#define DPNHERR_PORTALREADYREGISTERED		MAKE_DPNHFAILURE(0x80)
#define DPNHERR_PORTUNAVAILABLE				MAKE_DPNHFAILURE(0x90)
#define DPNHERR_REENTRANT					MAKE_DPNHFAILURE(0x95)
#define DPNHERR_SERVERNOTAVAILABLE			MAKE_DPNHFAILURE(0xA0)
#define DPNHERR_UPDATESERVERSTATUS			MAKE_DPNHFAILURE(0xC0)







#ifdef __cplusplus
}
#endif

#endif // __DPNATHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dsdmo.h ===
#ifndef _DSDMO_H_
#define _DSDMO_H_

#include <mmsystem.h>
#include <dsoundp.h>  // For effect IID and ClassID declarations

extern double LogNorm[32];
extern float mylog( float finput, unsigned long maxexponent);
extern DWORD g_amPlatform;
extern long g_cComponent;
extern HMODULE g_hModule;

#define EXT_STD_CREATE(x) \
    extern HRESULT CreateCDirectSound ## x ## DMO(IUnknown **ppunk);

#define EXT_STD_CAPTURE_CREATE(x) \
    extern HRESULT CreateCDirectSoundCapture ## x ## DMO(IUnknown **ppunk);
    
// Exception warnings   
//
#pragma warning(disable:4530)    
#define STD_CREATE(x) \
HRESULT CreateCDirectSound ## x ## DMO(IUnknown **ppunk)                \
    {                                                                   \
        HRESULT hr = E_OUTOFMEMORY;                                     \
        CDirectSound ## x ## DMO *p = NULL;                             \
        try {                                                           \
            p = new CDirectSound ## x ## DMO;                           \
        } catch (...) {};                                               \
        if (p) {                                                        \
            hr = p->InitOnCreation();                                   \
            if (FAILED(hr))                                             \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        *ppunk = static_cast<IPersist*>(p);                             \
        return hr;                                                      \
    }

#define STD_CAPTURE_CREATE(x) \
HRESULT CreateCDirectSoundCapture ## x ## DMO(IUnknown **ppunk)         \
    {                                                                   \
        HRESULT hr = E_OUTOFMEMORY;                                     \
        CDirectSoundCapture ## x ## DMO *p = NULL;                      \
        try {                                                           \
            p = new CDirectSoundCapture ## x ## DMO;                    \
        } catch (...) {};                                               \
        if (p) {                                                        \
            hr = p->InitOnCreation();                                   \
            if (FAILED(hr))                                             \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        *ppunk = static_cast<IPersist*>(p);                             \
        return hr;                                                      \
    }

// Common #define's and templates for all filters
//
#define MaxSamplesPerSec	96000
#define PI 3.1415926535
#define DefineMsecSize(y, x)	((int)(((x) * (y)) / 1000))
#define DefineDelayLineSize(x)	DefineMsecSize(MaxSamplesPerSec, x)
//#define GetMsecPos(x)		(DefineDelayLineSize(x))
#define GetMsecPos(x)		(DefineMsecSize(m_EaxSamplesPerSec, x))
#define FractMask		0xfff
#define FractMultiplier		0x1000

template <int BufferSize> class DelayBuffer
{
	int Buffer[BufferSize];
	int BufferPos;

public:
	inline void Init(void)
	{
		BufferPos = 0;
		memset(Buffer, 0, sizeof(Buffer));
	}

	inline int Pos(int x)
	{
		x += BufferPos;
		while (x < 0)
			x += BufferSize * FractMultiplier;
		x /= FractMultiplier;
		while (x >= BufferSize)
			x -= BufferSize;

		return(x);
	}

	inline void Bump(void)
	{
		if (BufferPos == 0)
			BufferPos += BufferSize * FractMultiplier;
		if (BufferPos < 0)
			BufferPos += BufferSize * FractMultiplier;
		BufferPos -= FractMultiplier;
	}

	inline int& operator[] (int i)
	{
		return (Buffer[i]);
	}
};

template <class type, float Msec, int AdditionalPositions> class DelayBuffer2
{
	union {
		type Buffer[DefineDelayLineSize(Msec) + AdditionalPositions];
		type BufferDisplay[DefineDelayLineSize(Msec/10) + AdditionalPositions];
	};
	int BufferPos;
	int BufferSize;

public:
	inline void Init(int SamplesPerSec)
	{
		BufferPos = 0;
		BufferSize = DefineMsecSize(Msec, SamplesPerSec) + AdditionalPositions;

		memset(Buffer, 0, sizeof(Buffer));
	}


	inline int FractPos(int x)
	{
		x *= FractMultiplier;
		x += BufferPos;
		while (x < 0)
			x += BufferSize * FractMultiplier;
		x /= FractMultiplier;
		while (x >= BufferSize)
			x -= BufferSize;

		return(x);
	}

	inline int Pos(int x)
	{
		x += BufferPos;
		while (x < 0)
			x += BufferSize * FractMultiplier;
		x /= FractMultiplier;
		while (x >= BufferSize)
			x -= BufferSize;

		return(x);
	}

	inline int LastPos(int x)
	{
		x = Pos(x + BufferSize - 1);

		return(x);
	}

	inline void Bump(void)
	{
		if (BufferPos == 0)
			BufferPos += BufferSize * FractMultiplier;
		if (BufferPos < 0)
			BufferPos += BufferSize * FractMultiplier;
		BufferPos -= FractMultiplier;
	}

	inline type& operator[] (int i)
	{
		return (Buffer[i]);
	}
};

//
//
//
// { EAX
#ifndef _EAXDMO_
#define _EAXDMO_

#define CHECK_PARAM(lo, hi) \
    if (value < lo || value > hi) {return DSERR_INVALIDPARAM;} else;

#define PUT_EAX_VALUE(var, val) \
	m_Eax ## var = val

#define PUT_EAX_FVAL(var, val) \
	m_Eax ## var = (float)(val)

#define PUT_EAX_LVAL(var, val) \
	m_Eax ## var = (long)(val)

#define TOFRACTION(x)	((float)x)
#define INTERPOLATE(x, y)	PUT_EAX_FVAL(x, (y))	// ??? Smooth it out...

#define SET_MPV_FLOAT(var) \
    MP_DATA mpv; \
    mpv = (MP_DATA)var;

#define SET_MPV_LONG SET_MPV_FLOAT

enum ChorusFilterParams 
{
	CFP_Wetdrymix = 0,
	CFP_Depth,
	CFP_Frequency,
	CFP_Waveform,
	CFP_Phase,
	CFP_Feedback,
	CFP_Delay,
	CFP_MAX
};

enum CompressorFilterParams 
{
	CPFP_Gain = 0,
	CPFP_Attack,
	CPFP_Release,
	CPFP_Threshold,
	CPFP_Ratio,
	CPFP_Predelay,
	CPFP_CompMeterReset,
	CPFP_CompInputMeter,
	CPFP_CompGainMeter,
	CPFP_MAX
};

enum DistortionFilterParams 
{
	DFP_Gain = 0,
	DFP_Edge,
	DFP_LpCutoff,
	DFP_EqCenter,
	DFP_EqWidth,
	DFP_MAX
};

enum EchoFilterParams 
{
	EFP_Wetdrymix = 0,
	EFP_Feedback,
	EFP_DelayLeft,
	EFP_DelayRight,
	EFP_PanDelay,
	EFP_MAX
};

enum FilterParams 
{
	FFP_Wetdrymix = 0,
	FFP_Waveform,
	FFP_Frequency,
	FFP_Depth,
	FFP_Phase,
	FFP_Feedback,
	FFP_Delay,
	FFP_MAX
};

enum ParamEqFilterParams 
{
	PFP_Center = 0,
	PFP_Bandwidth,
	PFP_Gain,
	PFP_MAX
};

enum GargleFilterParams
{
    GFP_Rate = 0,
    GFP_Shape,
    GFP_MAX
};

enum SVerbParams
{
    SVP_Gain = 0,
    SVP_Mix,
    SVP_ReverbTime,
    SVP_Ratio,
    SVP_MAX
};

enum AecParams
{
    AECP_Enable = 0,
    AECP_MAX
};

enum NoiseSuppressParams
{
    NSP_Enable = 0,
    NSP_MAX
};

enum AgcParams
{
    AGCP_Enable = 0,
    AGCP_MAX
};

#define GET_PUT(x, type) \
	STDMETHOD(get_Eax ## x) \
		( THIS_ \
		type *Eax ## x \
		) PURE; \
	STDMETHOD(put_Eax ## x) \
		( THIS_ \
		type Eax ## x \
		) PURE

interface IChorus : public IUnknown
{
public:
	GET_PUT(Wetdrymix, float);
	GET_PUT(Depth,     float);
	GET_PUT(Frequency, float);
	GET_PUT(Waveform,  long);
	GET_PUT(Phase,     long);
	GET_PUT(Feedback,  float);
	GET_PUT(Delay,     float);

};

interface ICompressor : public IUnknown
{
public:
	GET_PUT(Gain,           float);
	GET_PUT(Attack,         float);
	GET_PUT(Release,        float);
	GET_PUT(Threshold,      float);
	GET_PUT(Ratio,          float);
	GET_PUT(Predelay,       float);
	GET_PUT(CompMeterReset, float);
	GET_PUT(CompInputMeter, float);
	GET_PUT(CompGainMeter,  float);

};

interface IDistortion : public IUnknown
{
public:
	GET_PUT(Gain,     float);
	GET_PUT(Edge,     float);
	GET_PUT(LpCutoff, float);
	GET_PUT(EqCenter, float);
	GET_PUT(EqWidth,  float);
};

interface IEcho : public IUnknown
{
public:
	GET_PUT(Wetdrymix,  float);
	GET_PUT(Feedback,   float);
	GET_PUT(DelayLeft,  float);
	GET_PUT(DelayRight, float);
	GET_PUT(PanDelay,   long);
};

interface IFlanger : public IUnknown
{
public:
	GET_PUT(Wetdrymix,  float);
	GET_PUT(Waveform,   long);
	GET_PUT(Frequency,  float);
	GET_PUT(Depth,      float);
	GET_PUT(Phase,      long);
	GET_PUT(Feedback,   float);
	GET_PUT(Delay,      float);
};

interface IParamEq : public IUnknown
{
public:
	GET_PUT(Center,    float);
	GET_PUT(Bandwidth, float);
	GET_PUT(Gain,      float);
};

#undef GET_PUT


#if 0

// Replaced these with the GUIDs from dsound.x; e.g. for chorus, the interface
// ID is IID_IDirectSoundFXChorus and the ClassId is GUID_DSFX_STANDARD_CHORUS.

DEFINE_GUID(IID_IChorus, 0x514b6fb2,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);
DEFINE_GUID(IID_ICompressor, 0x514b6fc0,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);
DEFINE_GUID(IID_IDistortion, 0x514b6fb8,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);
DEFINE_GUID(IID_IEcho,0x514b6fb3,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);
DEFINE_GUID(IID_IFlanger,0x514b6fb4,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);
DEFINE_GUID(IID_IParamEq,0x514b6fb7,0x0611,0x4714,0x80,0x02,0x0e,0x06,0x29,0x92,0x7d,0x8e);

DEFINE_GUID(CLSID_DirectSoundChorusDMO, 0x120ced86,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);
DEFINE_GUID(CLSID_DirectSoundCompressorDMO,0x120ced92,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);
DEFINE_GUID(CLSID_DirectSoundDistortionDMO,0x120ced90,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);
DEFINE_GUID(CLSID_DirectSoundEchoDMO,0x120ced87,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);
DEFINE_GUID(CLSID_DirectSoundFlangerDMO,0x120ced88,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);
DEFINE_GUID(CLSID_DirectSoundParamEqDMO,0x120ced89,0x3bf4,0x4173,0xa1,0x32,0x3c,0xb4,0x06,0xcf,0x32,0x31);

#endif

DEFINE_GUID(IID_IGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);
DEFINE_GUID(CLSID_GargleDMO, 0xdafd8210,0x5711,0x4b91,0x9f,0xe3,0xf7,0x5b,0x7a,0xe2,0x79,0xbf);
DEFINE_GUID(CLSID_DirectSoundPropGargle,0x794885CC,0x5EB7,0x46E3,0xA9,0x37,0xAD,0x89,0x0A,0x6C,0x66,0x77);

DEFINE_GUID(CLSID_DirectSoundPropChorus,0x60129CFD,0x2E9B,0x4098,0xAA,0x4B,0xD6,0xCF,0xAD,0xA2,0x65,0xC3);
DEFINE_GUID(CLSID_DirectSoundPropFlanger,0x22AF00DF,0x46B4,0x4F51,0xA3,0x63,0x68,0x54,0xD5,0x2E,0x13,0xA0);
DEFINE_GUID(CLSID_DirectSoundPropDistortion,0x5858107D,0x11EA,0x47B1,0x96,0x94,0x3F,0x29,0xF7,0x68,0x0F,0xB8);
DEFINE_GUID(CLSID_DirectSoundPropEcho,0xD45CF2C7,0x48CF,0x4234,0x86,0xE2,0x45,0x59,0xC3,0x2F,0xAD,0x1A);
DEFINE_GUID(CLSID_DirectSoundPropCompressor,0xED3DC730,0x31E5,0x4108,0xAD,0x8A,0x39,0x62,0xC9,0x30,0x42,0x5E);
DEFINE_GUID(CLSID_DirectSoundPropParamEq,0xAE86C36D,0x808E,0x4B07,0xB7,0x99,0x56,0xD7,0x36,0x1C,0x38,0x35);
DEFINE_GUID(CLSID_DirectSoundPropWavesReverb,0x6A879859,0x3858,0x4322,0x97,0x1A,0xB7,0x05,0xF3,0x49,0xF1,0x24);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Reverb,0xD3952B77,0x2D22,0x4B72,0x8D,0xF4,0xBA,0x26,0x7A,0x9C,0x12,0xD0);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Source,0x3DC26D0C,0xBEFF,0x406C,0x89,0xB0,0xCA,0x13,0xE2,0xBD,0x91,0x72);

// } EAX

#endif 

#endif // _DSDMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dinputdp.h ===
DEFINE_GUID(IID_IDirectInputDeviceCallback, 0x1DE12AA0,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputEffectShepherd, 0x1DE12AA1,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputMapShepherd,    0x6a3e3144,0x3eee,0x4aa5,0x95,0x87,0xe1,0x0a,0x21,0xfe,0xc7,0x71);
DEFINE_GUID(IID_IDIActionFramework,             0xf4279160,0x608f,0x11d3,0x8f,0xb2,0x0, 0xc0,0x4f,0x8e,0xc6,0x27);
DEFINE_GUID(CLSID_CDirectInputActionFramework,  0x9f34af20,0x6095,0x11d3,0x8f,0xb2,0x0, 0xc0,0x4f,0x8e,0xc6,0x27);
/****************************************************************************
 *
 *      IDirectInputEffectShepherd
 *
 *      Special wrapper class which gates access to DirectInput
 *      effect drivers.
 *
 ****************************************************************************/

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHEPHANDLE |
 *
 *          Information that shepherds an effect handle.
 *
 *  @field  DWORD | dwEffect |
 *
 *          The effect handle itself, possibly invalid if the device
 *          has since been reset.
 *
 *          If the value is zero, then the effect has not
 *          been downloaded.
 *
 *  @field  DWORD | dwTag |
 *
 *          Reset counter tag for the effect.  If this value is different
 *          from the tag stored in shared memory, then it means that
 *          the device has been reset in the interim and no longer
 *          belongs to the caller.
 *
 ****************************************************************************/

typedef struct SHEPHANDLE {
    DWORD dwEffect;
    DWORD dwTag;
} SHEPHANDLE, *PSHEPHANDLE;

#undef INTERFACE
#define INTERFACE IDirectInputEffectShepherd

DECLARE_INTERFACE_(IDirectInputEffectShepherd, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffectShepherd methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,LPVOID) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(Escape)(THIS_ PSHEPHANDLE,LPDIEFFESCAPE) PURE;
    STDMETHOD(DeviceEscape)(THIS_ PSHEPHANDLE,LPDIEFFESCAPE) PURE;
    STDMETHOD(SetGain)(THIS_ PSHEPHANDLE,DWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ PSHEPHANDLE,DWORD) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ PSHEPHANDLE,LPDIDEVICESTATE) PURE;
    STDMETHOD(DownloadEffect)(THIS_ DWORD,PSHEPHANDLE,LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(DestroyEffect)(THIS_ PSHEPHANDLE) PURE;
    STDMETHOD(StartEffect)(THIS_ PSHEPHANDLE,DWORD,DWORD) PURE;
    STDMETHOD(StopEffect)(THIS_ PSHEPHANDLE) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ PSHEPHANDLE,LPDWORD) PURE;
    STDMETHOD(SetGlobalGain)(THIS_ DWORD) PURE;
};

typedef struct IDirectInputEffectShepherd *LPDIRECTINPUTEFFECTSHEPHERD;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffectShepherd_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffectShepherd_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffectShepherd_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffectShepherd_DeviceID(p,a,b,c) (p)->lpVtbl->DeviceID(p,a,b,c)
#define IDirectInputEffectShepherd_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputEffectShepherd_Escape(p,a,b) (p)->lpVtbl->Escape(p,a,b)
#define IDirectInputEffectShepherd_DeviceEscape(p,a,b) (p)->lpVtbl->DeviceEscape(p,a,b)
#define IDirectInputEffectShepherd_SetGain(p,a,b) (p)->lpVtbl->SetGain(p,a,b)
#define IDirectInputEffectShepherd_SendForceFeedbackCommand(p,a,b) (p)->lpVtbl->SendForceFeedbackCommand(p,a,b)
#define IDirectInputEffectShepherd_GetForceFeedbackState(p,a,b) (p)->lpVtbl->GetForceFeedbackState(p,a,b)
#define IDirectInputEffectShepherd_DownloadEffect(p,a,b,c,d) (p)->lpVtbl->DownloadEffect(p,a,b,c,d)
#define IDirectInputEffectShepherd_DestroyEffect(p,a) (p)->lpVtbl->DestroyEffect(p,a)
#define IDirectInputEffectShepherd_StartEffect(p,a,b,c) (p)->lpVtbl->StartEffect(p,a,b,c)
#define IDirectInputEffectShepherd_StopEffect(p,a) (p)->lpVtbl->StopEffect(p,a)
#define IDirectInputEffectShepherd_GetEffectStatus(p,a,b) (p)->lpVtbl->GetEffectStatus(p,a,b)
#define IDirectInputEffectShepherd_SetGlobalGain(p,a) (p)->lpVtbl->SetGlobalGain(p,a)
#else
#define IDirectInputEffectShepherd_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffectShepherd_AddRef(p) (p)->AddRef()
#define IDirectInputEffectShepherd_Release(p) (p)->Release()
#define IDirectInputEffectShepherd_DeviceID(p,a,b,c) (p)->DeviceID(a,b,c)
#define IDirectInputEffectShepherd_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputEffectShepherd_Escape(p,a,b) (p)->Escape(a,b)
#define IDirectInputEffectShepherd_DeviceEscape(p,a,b) (p)->DeviceEscape(a,b)
#define IDirectInputEffectShepherd_SetGain(p,a,b) (p)->SetGain(a,b)
#define IDirectInputEffectShepherd_SendForceFeedbackCommand(p,a,b) (p)->SendForceFeedbackCommand(a,b)
#define IDirectInputEffectShepherd_GetForceFeedbackState(p,a,b) (p)->GetForceFeedbackState(a,b)
#define IDirectInputEffectShepherd_DownloadEffect(p,a,b,c,d) (p)->DownloadEffect(a,b,c,d)
#define IDirectInputEffectShepherd_DestroyEffect(p,a) (p)->DestroyEffect(a)
#define IDirectInputEffectShepherd_StartEffect(p,a,b,c) (p)->StartEffect(a,b,c)
#define IDirectInputEffectShepherd_StopEffect(p,a) (p)->StopEffect(a)
#define IDirectInputEffectShepherd_GetEffectStatus(p,a,b) (p)->GetEffectStatus(a,b)
#define IDirectInputEffectShepherd_SetGlobalGain(p,a) (p)->SetGlobalGain(a)
#endif

/****************************************************************************
 *
 *      IDirectInputMapShepherd
 *
 *      Special wrapper class which gates access to DirectInput mapper.
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInputMapShepherd

DECLARE_INTERFACE_(IDirectInputMapShepherd, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapShepherd methods ***/
    STDMETHOD(GetActionMap)(THIS_ REFGUID,LPCWSTR,LPDIACTIONFORMATW,LPCWSTR,LPFILETIME,DWORD) PURE;
    STDMETHOD(SaveActionMap)(THIS_ REFGUID,LPCWSTR,LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ REFGUID,LPCWSTR,LPDIDEVICEIMAGEINFOHEADERW) PURE;
};

typedef struct IDirectInputMapShepherd *LPDIRECTINPUTMAPSHEPHERD;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputMapShepherd_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputMapShepherd_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputMapShepherd_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputMapShepherd_GetActionMap(p,a,b,c,d,e,f) (p)->lpVtbl->GetActionMap(p,a,b,c,d,e,f)
#define IDirectInputMapShepherd_SaveActionMap(p,a,b,c,d,e) (p)->lpVtbl->SaveActionMap(p,a,b,c,d,e)
#define IDirectInputMapShepherd_GetImageInfo(p,a,b,c) (p)->lpVtbl->GetImageInfo(p,a,b,c)
#else
#define IDirectInputMapShepherd_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputMapShepherd_AddRef(p) (p)->AddRef()
#define IDirectInputMapShepherd_Release(p) (p)->Release()
#define IDirectInputMapShepherd_GetActionMap(p,a,b,c,d,e,f) (p)->GetActionMap(a,b,c,d,e,f)
#define IDirectInputMapShepherd_SaveActionMap(p,a,b,c,d,e) (p)->SaveActionMap(a,b,c,d,e)
#define IDirectInputMapShepherd_GetImageInfo(p,a,b,c) (p)->GetImageInfo(a,b,c)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct DIPROPINFO |
 *
 *          Information used to describe an object being accessed.
 *
 *  @field  const GUID * | pguid |
 *
 *          The property being accessed (if applicable).
 *
 *  @field  UINT | iobj |
 *
 *          Zero-based index to object (or 0xFFFFFFFF if accessing the
 *          device).
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type information (or 0 if accessing the device).
 *
 ****************************************************************************/

typedef struct DIPROPINFO {
    const GUID *pguid;
    UINT iobj;
    DWORD dwDevType;
} DIPROPINFO, *LPDIPROPINFO;
typedef const DIPROPINFO *LPCDIPROPINFO;

#define DICOOK_DFOFSFROMOFSID(dwOfs, dwType)        MAKELONG(dwOfs, dwType)
#define DICOOK_IDFROMDFOFS(dwFakeOfs)               HIWORD(dwFakeOfs)
#define DICOOK_OFSFROMDFOFS(dwFakeOfs)              LOWORD(dwFakeOfs)

/****************************************************************************
 *
 *      IDirectInputDeviceCallback
 *
 *      IDirectInputDevice uses it to communicate with the
 *      component that is responsible for collecting data from
 *      the appropriate hardware device.
 *
 *      E.g., mouse, keyboard, joystick, HID.
 *
 *      Methods should return E_NOTIMPL for anything not understood.
 *
 ****************************************************************************/
#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInputDeviceCallback

DECLARE_INTERFACE_(IDirectInputDeviceCallback, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceCallback methods ***/
    STDMETHOD(GetInstance)(THIS_ LPVOID *) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(GetDataFormat)(THIS_ LPDIDATAFORMAT *) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPCDIPROPINFO,LPDIDEVICEOBJECTINSTANCEW) PURE;
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ LPVOID) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(GetProperty)(THIS_ LPCDIPROPINFO,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ LPCDIPROPINFO,LPCDIPROPHEADER) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(CookDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA) PURE;
    STDMETHOD(CreateEffect)(THIS_ LPDIRECTINPUTEFFECTSHEPHERD *) PURE;
    STDMETHOD(GetFFConfigKey)(THIS_ DWORD,PHKEY) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD_(DWORD,GetUsage)(THIS_ int) PURE;
    STDMETHOD(MapUsage)(THIS_ DWORD,PINT) PURE;
    STDMETHOD(SetDIData)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(BuildDefaultActionMap)(THIS_ LPDIACTIONFORMATW,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceCallback *LPDIRECTINPUTDEVICECALLBACK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDeviceCallback_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->lpVtbl->GetInstance(p,a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->lpVtbl->GetDataFormat(p,a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->lpVtbl->GetObjectInfo(p,a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDeviceCallback_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->lpVtbl->GetDeviceState(p,a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->lpVtbl->CookDeviceData(p,a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->lpVtbl->CreateEffect(p,a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->lpVtbl->GetFFConfigKey(p,a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDeviceCallback_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->lpVtbl->GetUsage(p,a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->lpVtbl->MapUsage(p,a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->lpVtbl->SetDIData(p,a,b)
#define IDirectInputDeviceCallback_BuildDefaultActionMap(p,a,b,c) (p)->lpVtbl->BuildDefaultActionMap(p,a,b,c)
#else
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->AddRef()
#define IDirectInputDeviceCallback_Release(p) (p)->Release()
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->GetInstance(a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->GetDataFormat(a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->GetObjectInfo(a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->Acquire()
#define IDirectInputDeviceCallback_Unacquire(p) (p)->Unacquire()
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->GetDeviceState(a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->CookDeviceData(a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->CreateEffect(a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->GetFFConfigKey(a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDeviceCallback_Poll(p) (p)->Poll()
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->GetUsage(a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->MapUsage(a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->SetDIData(a,b)
#define IDirectInputDeviceCallback_BuildDefaultActionMap(p,a,b,c) (p)->BuildDefaultActionMap(a,b,c)
#endif

#else
#undef INTERFACE
#define INTERFACE IDirectInputDeviceCallback

DECLARE_INTERFACE_(IDirectInputDeviceCallback, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceCallback methods ***/
    STDMETHOD(GetInstance)(THIS_ LPVOID *) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(GetDataFormat)(THIS_ LPDIDATAFORMAT *) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPCDIPROPINFO,LPDIDEVICEOBJECTINSTANCEW) PURE;
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ LPVOID) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(GetProperty)(THIS_ LPCDIPROPINFO,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ LPCDIPROPINFO,LPCDIPROPHEADER) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(CookDeviceData)(THIS_ UINT,LPDIDEVICEOBJECTDATA) PURE;
    STDMETHOD(CreateEffect)(THIS_ LPDIRECTINPUTEFFECTSHEPHERD *) PURE;
    STDMETHOD(GetFFConfigKey)(THIS_ DWORD,PHKEY) PURE;
    STDMETHOD(SendDeviceData)(THIS_ LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD_(DWORD,GetUsage)(THIS_ int) PURE;
    STDMETHOD(MapUsage)(THIS_ DWORD,PINT) PURE;
    STDMETHOD(SetDIData)(THIS_ DWORD,LPVOID) PURE;
};

typedef struct IDirectInputDeviceCallback *LPDIRECTINPUTDEVICECALLBACK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDeviceCallback_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->lpVtbl->GetInstance(p,a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->lpVtbl->GetDataFormat(p,a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->lpVtbl->GetObjectInfo(p,a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDeviceCallback_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->lpVtbl->GetDeviceState(p,a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->lpVtbl->CookDeviceData(p,a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->lpVtbl->CreateEffect(p,a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->lpVtbl->GetFFConfigKey(p,a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c) (p)->lpVtbl->SendDeviceData(p,a,b,c)
#define IDirectInputDeviceCallback_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->lpVtbl->GetUsage(p,a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->lpVtbl->MapUsage(p,a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->lpVtbl->SetDIData(p,a,b)
#else
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->AddRef()
#define IDirectInputDeviceCallback_Release(p) (p)->Release()
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->GetInstance(a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->GetDataFormat(a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->GetObjectInfo(a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->Acquire()
#define IDirectInputDeviceCallback_Unacquire(p) (p)->Unacquire()
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->GetDeviceState(a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->CookDeviceData(a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->CreateEffect(a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->GetFFConfigKey(a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c) (p)->SendDeviceData(a,b,c)
#define IDirectInputDeviceCallback_Poll(p) (p)->Poll()
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->GetUsage(a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->MapUsage(a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->SetDIData(a,b)
#endif

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

/****************************************************************************
 *
 *      Emulation flags
 *
 *      These bits can be put into the Emulation flag in the registry
 *      key REGSTR_PATH_DINPUT as the DWORD value of REGSTR_VAL_EMULATION.
 *
 *      Warning!  If you use more than fifteen bits of emulation, then
 *      you also have to mess with DIGETEMFL() and DIMAKEEMFL() in
 *      dinputv.h.
 *
 ****************************************************************************/

#define DIEMFL_MOUSE    0x00000001      /* Force mouse emulation */
#define DIEMFL_KBD      0x00000002      /* Force keyboard emulation */
#define DIEMFL_JOYSTICK 0x00000004      /* Force joystick emulation */
#define DIEMFL_KBD2     0x00000008      /* Force keyboard emulation 2 */
#define DIEMFL_MOUSE2   0x00000010      /* Force mouse emulation 2 */

/****************************************************************************
 *
 *      IDirectInputActionFramework
 *      Framework interface for configuring devices
 *
 ****************************************************************************/
#if(DIRECTINPUT_VERSION >= 0x0800)

#undef INTERFACE
#define INTERFACE IDirectInputActionFramework

DECLARE_INTERFACE_(IDirectInputActionFramework, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputActionFramework methods ***/
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSW,DWORD,LPVOID) PURE;
};

typedef struct IDirectInputActionFramework *LPDIRECTINPUTACTIONFRAMEWORK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputActionFramework_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputActionFramework_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputActionFramework_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputActionFramework_ConfigureDevices(p,a,b,c,d) (p)->lpVtbl->ConfigureDevices(p,a,b,c,d)
#else
#define IDirectInputActionFramework_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputActionFramework_AddRef(p) (p)->AddRef()
#define IDirectInputActionFramework_Release(p) (p)->Release()
#define IDirectInputActionFramework_ConfigureDevices(p,a,b,c,d) (p)->ConfigureDevices(a,b,c,d)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define JOY_HW_PREDEFMIN    JOY_HW_2A_2B_GENERIC 
#ifdef WINNT
  #define JOY_HW_PREDEFMAX    JOY_HW_LASTENTRY 
#else
  #define JOY_HW_PREDEFMAX    (JOY_HW_LASTENTRY-1)
#endif
#define JOYTYPE_FLAGS1_SETVALID         0x80000000l
#define JOYTYPE_FLAGS1_GETVALID         0x8000000Fl
#define JOYTYPE_FLAGS2_SETVALID         0x01FFFFFFl
#define JOYTYPE_FLAGS2_GETVALID         0x01FFFFFFl
#define iJoyPosAxisX        0                   /* The order in which   */
#define iJoyPosAxisY        1                   /* axes appear          */
#define iJoyPosAxisZ        2                   /* in a JOYPOS          */
#define iJoyPosAxisR        3
#define iJoyPosAxisU        4
#define iJoyPosAxisV        5
#define cJoyPosAxisMax      6
#define cJoyPosButtonMax   32

#define DITC_VOLATILEREGKEY         0x80000000
#define DITC_INREGISTRY_DX5         0x0000000F
#define DITC_GETVALID_DX5           0x0000000F
#define DITC_SETVALID_DX5           0x0000000F
#define DITC_INREGISTRY_DX6         0x0000003F
#define DITC_GETVALID_DX6           0x0000003F
#define DITC_SETVALID_DX6           0x0000003F


#define DITC_INREGISTRY             0x000000FF
#define DITC_GETVALID               0x000000FF
#define DITC_SETVALID               0x000000FF
/*
 *  Name for the 8.0 structure, in places where we specifically care.
 */
typedef       DIJOYTYPEINFO         DIJOYTYPEINFO_DX8;
typedef       LPDIJOYTYPEINFO      *LPDIJOYTYPEINFO_DX8;

BOOL static __inline
IsValidSizeDIJOYTYPEINFO(DWORD cb)
{
    return cb == sizeof(DIJOYTYPEINFO_DX8) ||
           cb == sizeof(DIJOYTYPEINFO_DX6) ||
           cb == sizeof(DIJOYTYPEINFO_DX5);
}

#define DIJC_UPDATEALIAS            0x80000000


#define DIJC_INREGISTRY_DX5         0x0000000E
#define DIJC_GETVALID_DX5           0x0000000F
#define DIJC_SETVALID_DX5           0x0000000E

#define DIJC_INREGISTRY             0x0000001E
#define DIJC_GETVALID               0x0000001F
#define DIJC_SETVALID               0x0000001F
#define DIJC_INTERNALSETVALID       0x8000001F
/*
 *  Name for the 6.? structure, in places where we specifically care.
 */
typedef       DIJOYCONFIG         DIJOYCONFIG_DX6;
typedef       DIJOYCONFIG        *LPDIJOYCONFIG_DX6;

BOOL static __inline
IsValidSizeDIJOYCONFIG(DWORD cb)
{
    return cb == sizeof(DIJOYCONFIG_DX6) ||
           cb == sizeof(DIJOYCONFIG_DX5);
}
#define DIJU_INDRIVERREGISTRY       0x00000006
#define DIJU_GETVALID               0x00000007
#define DIJU_SETVALID               0x80000007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dsextend.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-2000.
//
//--------------------------------------------------------------------------;
//
// dsextend.cpp : implementation of various direct show extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "ksextend.h"
#include "dsextend.h"

const int MAX_OCCURRENCE_COUNT = 2;

static DWORD dwFetch;
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap
// and calling it in our dllmain.

// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = &std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = &std_arity0_member(&IEnumFilters::Reset);
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = &std_arity1_member(&IBaseFilter::EnumPins);
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = &std_arity0_member(&IEnumPins::Reset);
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = &std_arity0_member(&IEnumMoniker::Reset);
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = &std_arity1_member(&IPin::EnumMediaTypes);
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = &std_arity0_member(&IEnumMediaTypes::Reset);
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
#else
// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = NULL;
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = NULL;
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = NULL;

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = NULL;
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = NULL;
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = NULL;

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = NULL;
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = NULL;

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = NULL;
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = NULL;
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = NULL;
#endif


// work around compiler bug as per above description
void CtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    DSGraphContainer::Fetch = new std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
    DSGraphContainer::iterator::Reset = new std_arity0pmf<IEnumFilters, HRESULT>(&IEnumFilters::Reset);
    DSGraphContainer::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumFilters, ULONG, IBaseFilter**, ULONG *, HRESULT> >(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

    // DSFilter
    DSFilter::Fetch = new std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT>(&IBaseFilter::EnumPins);
    DSFilter::iterator::Reset = new std_arity0pmf<IEnumPins, HRESULT>(&IEnumPins::Reset);
    DSFilter::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumPins, ULONG, IPin **, ULONG *, HRESULT> >(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    DSDevices::iterator::Reset = new std_arity0pmf<IEnumMoniker, HRESULT>(&IEnumMoniker::Reset);
    DSDevices::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMoniker, ULONG, IMoniker **, ULONG *, HRESULT> >(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    DSPin::Fetch = new std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT>(&IPin::EnumMediaTypes);
    DSPin::iterator::Reset = new std_arity0pmf<IEnumMediaTypes, HRESULT>(&IEnumMediaTypes::Reset);
    DSPin::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMediaTypes, DWORD, AM_MEDIA_TYPE **, DWORD *, HRESULT> >(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    delete DSGraphContainer::Fetch;
    delete DSGraphContainer::iterator::Reset;
    delete DSGraphContainer::iterator::Next;

    // DSFilter
    delete DSFilter::Fetch;
    delete DSFilter::iterator::Reset;
    delete DSFilter::iterator::Next;

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    delete DSDevices::iterator::Reset;
    delete DSDevices::iterator::Next;

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    delete DSPin::Fetch;
    delete DSPin::iterator::Reset;
    delete DSPin::iterator::Next;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSGraph
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT DSGraph::Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    ASSERT(pStop.GetGraph() == *this);
    try {
		DSFilterIDList AddedIDs;
        int origsize = Added.size();
        if (ConnectFilters(pStart, pStop, AddedIDs, dwFlags, pd)) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				Added.push_back((*i).first);
			}
            return NOERROR;
        }
        ASSERT(!AddedIDs.size());
        ASSERT(Added.size() == origsize);
        return E_FAIL;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

bool DSGraph::Connect(DSFilter &pStart, DSFilterMoniker &pStop, DSFilter &pEndPointAdded, DSFilterList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    pEndPointAdded = AddMoniker(pStop);
    if (!pEndPointAdded) {
        return false;
    }
    ASSERT(pEndPointAdded.GetGraph() == *this);
    int origsize = IntermediatesAdded.size();
    if (SUCCEEDED(Connect(pStart, pEndPointAdded, IntermediatesAdded, dwFlags, pd))) {
        return true;
    }
    RemoveFilter(pEndPointAdded);
    pEndPointAdded.Release();
    ASSERT(IntermediatesAdded.size() == origsize);
    return false;
}


#ifdef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinDirect(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinDirect() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
			if (!DSPin(*i).GetConnection()) {
				HRESULT hr = pPin.Connect(*i, NULL);
				if (SUCCEEDED(hr)) {
					TRACEOUTDENT();
					TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinDirect() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinDirect() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinDirect() failed");
    return false;
}
#endif

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    int cUseablePins = 0;
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMedium() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
            if (HasUnconnectedMedium(pPin, *i, cUseablePins)) {
                break;
            }
        }
        if (i != pFilter.end()) {
            HRESULT hr = pPin.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() can't connect pin " << pPin << " to " << *i), " with matching medium");
                return false;
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMedium() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() connect pin "), " THREWUP");
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinByMedium() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinByMedium() failed");
    return false;
}
#endif

// attempt to connect the given pin to the given filter by hunting for an indirection through
// another filter already in the graph
// then attempt to connect the new filter to the original destination
bool DSGraph::FindPinByMedium(DSPin &pPin1, DSFilter &pFDest, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() pPin1 = " << pPin1 << " pFDest = " << pFDest), "");
    KSMediumList ml;
    HRESULT hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() " << pPin1 << " has no mediums"), "");
        return false;
    }

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        // try all the direct connections
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() succeeded");
				return true;
			}
		}
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() can't connect pin to anything in graph");
    return false;
}

// we have already established that we can't connect directly or via other filters
// already in the graph so go hunt for a new filter to load
// if we fail we must leave the graph in its initial state
bool DSGraph::LoadPinByMedium(KSPinMedium &medium, DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    if (medium == NULL_MEDIUM || medium == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() NULL Medium, don't bother");
        // don't build an enumerator for a null medium or we will search through every
        // single filter on the system that doesn't have mediums
        return false;
    }
    try {
        TRACEINDENT();
        TRACELSM(TRACE_PAINT, (dbgDump << "medium = " << medium), "");
        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
                THROWCOM(E_UNEXPECTED);
        }


        bool fInReq = false, fOutReq = false;
        DSREGPINMEDIUM *pInMed = NULL, *pOutMed = NULL;

        switch (pd) {
        case PINDIR_INPUT:  // hunting through graph from right to left

#ifdef FILTERDATA
                    fOutReq = true;
                    pOutMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#else
            // NOTE: because of mediums get registered from the .inf with an
            // incomplete registry blob, filtermapper thinks that any pin with a
            // medium is an input pin and we use the low flag bit in the second
            // medium dword to solve this problem. == 1 for input == 0 for output
                    fInReq = true;
                    pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
            medium.Flags &= ~(KSMEDIUM_INPUTFLAG);
#endif
            break;
        case PINDIR_OUTPUT: // hunting through graph from left to right
            fInReq = true;
            pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#ifndef FILTERDATA
            medium.Flags |= KSMEDIUM_INPUTFLAG;
#endif
            break;
        }

        if (pInMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " " << (*pInMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " (NULL)"), "");
        }
        if (pOutMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " " << (*pOutMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " (Null)"), "");
        }
        // NOTE: since we're using mediums which are hw specific we include filters w/
        // MERIT_DO_NOT_USE since this is the default merit and most HW device filters
        // don't specify a merit.
        DSFilterMapper fmr(PQFilterMapper(*this),
                       0,
                       true,                                    // no wildcards
                       MERIT_DO_NOT_USE,                        // default merit for hw filters
                       fInReq,                                  // input required
                       0,
                       NULL,
                       pInMed,                                  // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       0,
                       NULL,
                       pOutMed,                                 // output medium
                       NULL                                     // output pin cat
                      );
        if (fmr) {
            // try all the direct connections
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() succeeded");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMedium(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMedium()");
    try {
        KSMediumList ml;
        HRESULT hr = pPin.GetMediums(ml);
        if (FAILED(hr) || !ml.size()) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMedium() " << pPin << " has no mediums"), "");
            return false;
        }
		for (KSMediumList::iterator i = ml.begin(); i != ml.end(); ++i) {
			if (LoadPinByMedium(KSPinMedium(*i), pPin, pRight, IntermediatesAdded, dwFlags)) {
				return true;
			}
		}
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMedium() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMedium() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we may have added and leave the graph in the
// state we started with.
bool DSGraph::ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags) {
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    try {
        TRACEINDENT();
        // try media types
		DSFilter::iterator i;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			if (HasUnconnectedMediaType(pPin1, *i, dwFlags)) {
				break;
			}
		}
        if (i != pFilter1.end()) {
            ASSERT(*this);
            ASSERT(pPin1.GetGraph() == *this);
            ASSERT((*i).GetGraph() == *this);
            HRESULT hr = pPin1.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) can't connect pin " << pPin1 << " to " << *i << " hr = " << hexdump(hr)), " with matching media type.");
#ifdef DEBUG
                if (dwTraceLevel >= TRACE_DETAIL) {
                    DumpHdr(dbgDump) << "pin1 " << pPin1.GetFilter() << " " << pPin1 << std::endl;
                    DumpHdr(dbgDump) << "pin2 " << (*i).GetFilter() << " " << *i << std::endl;
                    DumpMediaTypes(pPin1, *i);
                }
#endif
                if (!(dwFlags & IGNORE_MEDIATYPE_ERRORS)) {
                    THROWCOM(HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH));
                } else {
                    return false;
                }
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) connected " << pPin1.GetFilter() << " " << pPin1 << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED || h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) failed");

    return false;
}
#endif

bool DSGraph::FindPinByMediaType(DSPin &pPinLeft, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    ASSERT(pPinLeft.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() pPinLeft = " << pPinLeft << " filter = " << pRight), "");
    // possibly in the future we should find all of the possible choices and
    // use the shortest available path.  but for now, we're just going to
    // find the first one that exists
    try {
        TRACEINDENT();
		// NOTE: IFilterGraph::ConnectDirect() bumps the graph version number which invalidates
		// all the enumerators.  thus we'll run through and make a list of all the filters in the 
		// graph and then check them
		DSFilterList l;
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
			l.push_back(*i);
		}
		for (DSFilterList::iterator li = l.begin(); li != l.end(); ++li) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() succeeded");
				return true;
			}
		}
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() enumeration exhausted");
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() rethrowing E_UNEXPECTED");
			throw;
		}
		TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
    } catch(...) {
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() catch ...");
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMediaType() pPin = " << pPin.GetName() << " dwFlags = " << hexdump(dwFlags)), "");
    ASSERT(pPin.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
#ifdef DEBUG
    BEGIN_TRACEL(TRACE_DETAIL)
        if (pPin.begin() == pPin.end()) {
            dbgDump << "DSGraph::LoadPinByAnyMediaType() pin has no media types\r\n";
            dbgDump.flush();
        }
    END_TRACEL
#endif
    try {
		DWORD dwMerit = MERIT_NORMAL;
		if (dwFlags & ATTEMPT_MERIT_UNLIKELY) {
			dwMerit = MERIT_UNLIKELY;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_UNLIKELY");
		} else if (dwFlags & ATTEMPT_MERIT_DO_NOT_USE) {
			dwMerit = MERIT_DO_NOT_USE;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_DO_NOT_USE");
		}

		return LoadPinByMediaType(pPin, pRight, IntermediatesAdded, dwFlags, dwMerit);
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() failed");

    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsConnectable(DSPin &pPin1, DSFilter &pNew, DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, ConnectPred_t ConnPred) {
    ASSERT(pPin1 != NULL);
    ASSERT(pPin1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() pPin1 = " << pPin1 << " pNew = " << pNew << " pFDestination = " << pFDestination), "");
    try {
        PIN_INFO pinfo;
        HRESULT hr = pPin1->QueryPinInfo(&pinfo);
		if (FAILED(hr)) {
			THROWCOM(E_UNEXPECTED);
		}
        DSFilter Pin1Filter;
        Pin1Filter.p = pinfo.pFilter;  // transfer refcount ownership

        if (pNew && pNew != pFDestination && pNew != Pin1Filter) {
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() connpred == true");
                PIN_DIRECTION direction;
                hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsConnectable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
                if (ConnectFilters(pNew, pFDestination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() succeeded");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsConnectable() rethrowing E_UNEXPECTED");
			    pPin1.Disconnect();
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsConnectable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, ConnectPred_t ConnPred) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() pPin1 = " << pPin1 << " " << pPin1.GetFilter() << " Destination = " << Destination), "");
    ASSERT(pPin1.GetGraph() == *this);
    DSFilter pNew;
    try {
		DSFilterIDList::iterator i = IntermediatesAdded.size() ? (IntermediatesAdded.end() - 1) : IntermediatesAdded.end();

		if (i != IntermediatesAdded.end()) {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() checking duplicate moniker last = " << (*i).second << " new = " << Mapper.DisplayName()), "");
		} else {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() first moniker can't be dup(no check) new = " << Mapper.DisplayName()), "");
		}

		// undone: if the chains get longer we should use a map for this.  this may explain why perf
        // collapses as soon as we end up over on the audio side of things
		int occurrences = 0;
		CString newmkrname = Mapper.DisplayName();
		for (i = IntermediatesAdded.begin(); i != IntermediatesAdded.end(); ++i) {
			if ((!(*i).second.IsEmpty()) && 
				(newmkrname == (*i).second)) {
				   ++occurrences;
			}
		}
		if (occurrences > MAX_OCCURRENCE_COUNT) {
			TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::IsLoadable() max occurrence count exceeded for mkr = " << newmkrname), "");
			return false;
		}
        pNew = AddMoniker(Mapper);
        IntermediatesAdded.push_back(DSFilterID(pNew, Mapper.DisplayName()));
// ???? implement flag
        if (pNew) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() added moniker pNew = " << pNew), "");
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() connpred succeeded");
                PIN_DIRECTION direction;
                HRESULT hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsLoadable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
		        if (!pNew.PinCount(direction)) {
                    if (!(dwFlags & DONT_TERMINATE_ON_RENDERER)) {
                        TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() throwing ERROR_NO_MORE_ITEMS");
                        THROWCOM(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
                    }
		        }
                if (ConnectFilters(pNew, Destination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() succeeded.  pPin1 = " << pPin1 << " pNew = " << pNew << " Destination = " << Destination), "");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsLoadable() rethrowing");
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
				pPin1.Disconnect();
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
				IntermediatesAdded.pop_back();
				RemoveFilter(pNew);
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
	IntermediatesAdded.pop_back();
    if (pNew) {
        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
        RemoveFilter(pNew);
    }
    return false;
}

bool DSGraph::ConnectPin(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
    // NOTE: this is where we enforce the desired directional assymetry.  from now on through the call tree
    // we can assume that pin1 is already the desired directional type. and we only have to check
    // pin2 at the end in hasunconnectedxxxx()
    // this ensures that all of our connection paths are unidirectional through the graph. in other words,
    // make sure that we don't go downstream then back upstream or vice versa.
    // this allows all of our connection routines to be useable from either direction
    // since there are times when we have an input side starting point and other times the opposite
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1 = " << pPin1 << " " << pPin1.GetFilter() << " to " << pFilter1), "");
	TRACEINDENT();
    PIN_DIRECTION pd;

    HRESULT hr = pPin1->QueryDirection(&pd);
    if (pd != pin1dir) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() wrong dir");
        return false;
    }

	if (!(dwFlags & RENDER_ALL_PINS) &&  !pPin1.IsRenderable()) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() non-renderable");
		return false;
	}

    // make sure we're not trying to connect a filter to itself
    PIN_INFO pinfo;
    DSFilter PinFilter;
    hr = pPin1->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
		TRACEOUTDENT();
        TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() can't get pin info");
        THROWCOM(E_UNEXPECTED);
    }
    PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    if (PinFilter == pFilter1) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() can't connect filter to itself");
        return false;
    }

    DSPin pConn = pPin1.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1  = " << pPin1 << " connected, tracing through to next filter = " << pConn.GetFilter()), "");
        // a connected output pin should be traced through the next filter
        DSFilter pNext = pConn.GetFilter();
        if (!pNext) {
			TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() pNext has no filter");
            THROWCOM(E_UNEXPECTED);
        }
        if (pNext != pFilter1) {
	        bool rc = ConnectFilters(pNext, pFilter1, IntermediatesAdded, dwFlags, pin1dir);
			TRACEOUTDENT();
			return rc;
		} else {
			TRACEOUTDENT();
			TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pNext == pFilter1");
			return true;
		}
    }

#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by returning, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pin free");
	PIN_DIRECTION pd2;
	pd2 = OppositeDirection(pd);
	if (!pFilter1.HasFreePins(pd2)) {
		TRACEOUTDENT();
		TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has no free pins");
		return false;
	}
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has free pins");
#endif

    try {
#ifdef ATTEMPT_DIRECT_CONNECT
        if (ConnectPinDirect(pPin1, pFilter1) ||     // can these connect direct
#else
        if (ConnectPinByMedium(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||     // any paths in graph
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags))    ||     // any filters in system
#ifndef ATTEMPT_DIRECT_CONNECT
			ConnectPinByMediaType(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags))) {
			TRACEOUTDENT();
            TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() succeeded");
            return true;
        }
        TRACEOUTDENT(); // to avoid outdenting too far in a catch case
    } catch (ComException &h) {
		TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPin() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPin() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch (...) {
		TRACEOUTDENT();
    }

	//TRACEOUTDENT();
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() failed");
    return false;
}

// attempt to disconnect this pin
bool DSGraph::DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs) {
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin()");

    PIN_DIRECTION pd;
    HRESULT hr = pPin->QueryDirection(&pd);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() can't get direction");
        THROWCOM(E_UNEXPECTED);
    }

    DSPin pConnection = pPin.GetConnection();
    if (!pConnection) {
        return false;
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::DisconnectPin() disconnecting " << pPin << " from " << pConnection), "");
    pPin.Disconnect();
    DSFilter pNext = pConnection.GetFilter();
    if (!pNext) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() pConnection has no filter");
        THROWCOM(E_UNEXPECTED);
    }

    switch (pd) {
    case PINDIR_INPUT:
        if (fRecurseInputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  fRecurseInputs,
                                  false));  // we moving inputward, don't backtrack
#endif
		    for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, fRecurseInputs, false);
			}
        }
        break;
    case PINDIR_OUTPUT:
        if (fRecurseOutputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  false,
                                  fRecurseOutputs));
#endif
			for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, false, fRecurseOutputs);
			}
        }
        break;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin() succeeded");
    return true;
}

// attempt to connect this from the graph
bool DSGraph::DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs) {
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectFilter() can't disconnect NULL filter");
        return FALSE;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectFilter()");
    for (DSFilter::iterator i = pFilter.begin(); i != pFilter.end(); ++i) {
        DisconnectPin(*i, fRecurseInputs, fRecurseOutputs);
    }

    return true;
}


bool DSGraph::RemoveFilter(DSFilter &pFilter) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::RemoveFilter() removing " << pFilter), "");
    if (!pFilter) return false;

    DisconnectFilter(pFilter, false, false);

    HRESULT hr = (*this)->RemoveFilter(pFilter);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::RemoveFilter() can't remove filter");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::RemoveFilter() complete");

    return true;
}

// pin matches medium
// requires an exact match, won't treat GUID_NULL as wildcard and treats 'host memory' as unmatchable
bool DSGraph::HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const {
    DSPin junk(pPin2);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMedium() medium1 = " << Medium1 << " pPin2 = " << junk), "");
    if (Medium1 == NULL_MEDIUM || Medium1 == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() medium1 == NULL");
        return false;
    }
    KSMediumList ml;

    HRESULT hr = pPin2.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        return false;
    }
#if 0
    KSMediumList::iterator i = std::find_if(ml.begin(),
                                       ml.end(),
                                       std::bind2nd(std::equal_to<KSPinMedium>(), Medium1));
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
        return true;
    }
#endif
	KSMediumList::iterator i;
	for (i = ml.begin(); i != ml.end(); ++i) {
		if (*i == Medium1) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
			return true;
		}
	}

    TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() no match");

    return false;
}

bool DSGraph::HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() LeftMedia = " << LeftMedia << " LeftMedia.p " << LeftMedia.p << " pPinRight = " << pPinRight), "");

    if (pPinRight.IsKsProxied()) {
#if 0
        DSPin::iterator i = std::find_if(pPinRight.begin(),
                                         pPinRight.end(),
                                         std::bind2nd(std::equal_to<DSMediaType>(),
                                         LeftMedia) );
        if (i != pPinRight.end()) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
#endif
		DSPin::iterator i;
		for (i = pPinRight.begin(); i != pPinRight.end(); ++i) {
            // NOTE: DSMediaType operator== enables wildcard matches
			if (*i == LeftMedia) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
				return true;
			}
		}
    } else {
        HRESULT hr = pPinRight->QueryAccept(LeftMedia);
        if (SUCCEEDED(hr) && hr != S_FALSE) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() query accept refused hr = " << hexdump(hr)), "");
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// pin is unconnected, opposite direction, and has at least 1 matching medium
// requires an exact match, won't treat GUID_NULL as wildcard
bool DSGraph::HasUnconnectedMedium(const DSPin &pPin1, const DSPin &pPin2, int& cUseable) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMedium() pin1 = " << pPin1 << " pin2 = " << pPin2), "");
    PIN_DIRECTION pd1, pd2;
    HRESULT hr = pPin1->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin1 direction");
        return false;
    }
    hr = pPin2->QueryDirection(&pd2);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin2 direction");
        return false;
    }
    if (pd1 == pd2) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() can't connect two pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() checking connection status");

    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMedium() pPin2 = " << pPin2 << " already connected"), "");
        return false;
    }
    ++cUseable;

    KSMediumList ml;
    hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pin has no mediums");
        return false;
    }
    KSMediumList::iterator i;
    for (i = ml.begin(); i != ml.end(); ++i) {
        if (HasMedium(*i, pPin2)) {
            break;
        }
    }
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() succeeded");
        return true;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pPin2 has no matching medium");
    return false;
}

// pin is unconnected, opposite direction,  and there is at least 1 matching media type
bool DSGraph::HasUnconnectedMediaType(const DSPin &pPin1, const DSPin &pPin2, DWORD dwFlags) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMediaType() pPin1 = " << pPin1 << " pPin2 = " << pPin2), "");
    if (pPin1.GetDirection() == pPin2.GetDirection()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() cant connect 2 pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMediaType() pPin2 connected to " << pConn), "");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() finding");
    // pin right isn't connected to anything so hunt for a
    // compatible media type
	for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
		if (HasMediaType(*i, pPin2)) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded forward");
			return true;
		}
	}
    if (dwFlags & BIDIRECTIONAL_MEDIATYPE_MATCHING) {
	    for (DSPin::iterator i = pPin2.begin(); i != pPin2.end(); ++i) {
		    if (HasMediaType(*i, pPin1)) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded backward(bidi)");
			    return true;
		    }
	    }
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() no matching media types");
    return false;
}
#endif

// we are checking to see if pPin1 is connected(possibly indirectly) to pFDestionation by traveling in destdir direction through
// the graph
bool DSGraph::IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, PIN_DIRECTION destdir) const {
    PIN_DIRECTION direction;
    HRESULT hr = pPin1->QueryDirection(&direction);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::IsPinConnected() can't query direction");
        THROWCOM(E_UNEXPECTED);
    }
    if (direction != destdir) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() wrong direction");
        return false;
    }
    DSPin pConn = pPin1.GetConnection();
        if (!pConn) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to anything");
        return false;
        }
    PIN_INFO pinfo;
    DSFilter PinFilter;
    if (pConn) {
        hr = pConn->QueryPinInfo(&pinfo);
        PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    }
    if (PinFilter == pFDestination) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() directly true");
        return true;
    }
#if 0
#if CRASH
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bind_const_obj_2_3_4(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#else
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#endif
    if (i != PinFilter.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
        return true;
    }
#endif
	for (DSFilter::iterator i = PinFilter.begin(); i != PinFilter.end(); ++i) {
		if (IsPinConnected(*i, pFDestination, IntermediatesAdded, destdir)) {
			TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
			return true;
		}
	}
    TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to desired dest");
    return false;
}


#if 0
DSFilter DSGraph::LoadFilter(const PQMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    csName = _T("");
    PQFilter pFilter;
    PQPropertyBag pPropBag;
    HRESULT hr = (pM)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to storage");
        THROWCOM(hr);
    }
    CComVariant vName;
    vName.vt = VT_BSTR;
    hr = pPropBag->Read(L"FriendlyName", &vName, NULL);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't read friendly name");
        THROWCOM(hr);
    }
    USES_CONVERSION;
    BSTR p = vName.bstrVal;
    csName = OLE2T(p);
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter() have propbag");
    hr = (pM)->BindToObject(0, 0, IID_IBaseFilter, reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to object");
        THROWCOM(hr);
    }
    return pFilter;
}
#else
DSFilter DSGraph::LoadFilter(const DSFilterMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    CComBSTR p(pM.GetName());
        if (p) {
                USES_CONVERSION;
                csName = OLE2T(p);
        }
    return pM.GetFilter();
}
#endif

DSFilter DSGraph::AddMoniker(const DSFilterMoniker &pM) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker()");
    CString csName;

    DSFilter pFilter = LoadFilter(pM, csName);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddMoniker() can't load filter");
        return pFilter;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker() have pFilter");
    USES_CONVERSION;
    HRESULT hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddMoniker() can't add filter " << csName << " to graph"), "");
        return DSFilter();
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddMoniker() added " << csName), "");

    return pFilter;
}

HRESULT DSGraph::AddFilter(DSFilter &pFilter, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    USES_CONVERSION;
    hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return hr;
}

DSFilter DSGraph::AddFilter(const CLSID &cls, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    DSFilter pFilter(cls, NULL, CLSCTX_INPROC_SERVER);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddFilter() can't create filter");
        return pFilter;
    }
    hr = AddFilter(pFilter, csName);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
        THROWCOM(hr);
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return pFilter;
}

// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we've added and leave the graph in the
// state we started with.
// only look at pFilter1 pins of pFilter1Direction
bool DSGraph::ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, PIN_DIRECTION pFilter1Direction) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    if (pFilter1 == pFilter2) {
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters same filter");
        return false;
    }
    try {
        TRACEINDENT();
		// undone: there should be some way to preserve the info
		// from the following check to speed up the actual connection in the event
		// that they aren't already connected.

        // see if these filters are already connected
		DSFilter::iterator i;
		if (!(dwFlags & IGNORE_EXISTING_CONNECTIONS)) {
#if 0
#if CRASH
			i = std::find_if(pFilter1.begin(),
 							 pFilter1.end(),
 							 bind_obj_2_3_4(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#else
			i = std::find_if(pFilter1.begin(),
							 pFilter1.end(),
							 bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#endif
			if (i != pFilter1.end()) {
				TRACEOUTDENT();
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
				return true;
			}
#endif
			for (DSFilter::iterator i = pFilter1.begin(); i != pFilter1.end(); ++i) {
				if (IsPinConnected(*i, pFilter2, IntermediatesAdded, pFilter1Direction)) {
					TRACEOUTDENT();
					TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
					return true;
				}
			}
		}

        // they're not connected so see if we can connect them
        // connect every possible pin available and keep track of how many we connect
        int cConnected = 0;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			try {
				if (ConnectPin(DSPin(*i), pFilter2, IntermediatesAdded, dwFlags, pFilter1Direction)) {
					TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() pin connected");
					cConnected++;
				}
			} catch(ComException &h) {
				if (h != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
					try {
						TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() rethrowing");
					} catch(...) {
					}
					throw;
				}
			}
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() cConnected = " << cConnected), "");
        if (cConnected) {
            TRACEOUTDENT();// just inside try
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() succeeded pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
            return true;    // we connected at least one pin
        }
        TRACEOUTDENT();// just inside try
	} catch (ComException &h) {
        TRACEOUTDENT();// just inside try
		if (h == E_UNEXPECTED) {
			throw;
		}
    } catch (...) {
        TRACEOUTDENT();  // just inside try
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() catch...");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() failed pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    return false;
}

// this function returns a list of pairs of input and output points
// that must be connected to activate the shortest path between two filters
// it returns the number of connections in the path.
// i.e if start is adjacent to stop then rc is 1. if a single filter is between them then 2, etc.
// 0 indicates no path found.
int DSGraph::BuildGraphPath(const DSFilter& pStart,
                            const DSFilter& pStop,
                            VWStream &path,
                            MediaMajorTypeList& MediaTypes,
                            PIN_DIRECTION direction,
                            const DSPin &InitialInput)
{
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() start = " << pStart << " stop = " << pStop), "");
    int pathlen = INT_MAX;
    VWStream returnpath;
    ASSERT(InitialInput || (!InitialInput && !pStart.IsXBar())); // first time in can't be an xbar unless original caller establishes InitialInput
    for (DSFilter::iterator i = pStart.begin(); i != pStart.end(); ++i) {
        DSPin pPin1(*i);
        if (pPin1.GetDirection() != direction) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " wrong direction"), "");
            continue;  // search forward
        }
        DSPin pConnection = pPin1.GetConnection();
        if (!pConnection) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " unconnected"), "");
            continue;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() checking " << pPin1 << " connected to " << pConnection.GetFilter() << " " << pConnection), "");
        if (InitialInput) {
            ASSERT(pPin1 != InitialInput);  // direction check should already have filtered for this

            DSMediaType amt(pPin1.GetConnectionMediaType());
            ASSERT(amt);
            if (amt->pUnk) {
                amt->pUnk->Release();
            }

            MediaMajorTypeList::iterator l;
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() searching for " << GUID2(amt.p->majortype)), "");
            l = std::find(MediaTypes.begin(), MediaTypes.end(), amt.p->majortype);
            if (l == MediaTypes.end()) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "major media type not matched"), "");
                continue;
            }

            if (!pPin1.CanRoute(InitialInput)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ",  " << InitialInput << " Can't Route to " << pPin1), "");
                continue;
            }
        }

        DSFilter nextFilter = pConnection.GetFilter();
        ASSERT(nextFilter);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() nextFilter = " << nextFilter), "");

        if (nextFilter == pStop) {
            TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() found stop filter"), "");
            // we found the destination, we're done with this one
                        if (pStart.IsXBar()) {
                // if we started on xbar then connected pin's outputpoint pairs with the
                // initialinput(&pin) to form the first pair in the return path
                    TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                ASSERT(DSXBarPin(InitialInput));
                PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                ASSERT(!!p1);

                ASSERT(DSXBarPin(pPin1));
                PQPoint p2(DSXBarPin(pPin1).GetPoint());
                ASSERT(!!p2);

                switch (direction) {
                case DOWNSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                    returnpath.push_back(CIOPoint(p1, p2));
                    break;
                case UPSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                    returnpath.push_back(CIOPoint(p2, p1));
                    break;
                }
                        }
            pathlen = 1;
            break;
        } else {
            VWStream temp;
            int rc = BuildGraphPath(nextFilter, pStop, temp, MediaTypes, direction, pConnection);
            // undone: in win64 size() is really __int64.  fix output operator for
            // that type and remove cast

            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() recursed buildgraphpath returned rc = " << rc << " pathlen = " << pathlen << "sz = " << (long)temp.size()), "");

            // if we found a path and the new one is shorter then the current one
            if (rc && ((rc + 1) < pathlen)) {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() accepting new path");
                // save the new path
                pathlen = rc + 1;
                returnpath.clear();
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() checking xbar adjacency");
                if (pStart.IsXBar()) {
                                        // if we started on xbar then connected pin's outputpoint pairs with the
                                        // initialinput(&pin) to form the next pair in the return path
                        TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                    ASSERT(DSXBarPin(InitialInput));
                    PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                    ASSERT(!!p1);

                    ASSERT(DSXBarPin(pPin1));
                    PQPoint p2(DSXBarPin(pPin1).GetPoint());
                    ASSERT(!!p2);

                    switch (direction) {
                    case DOWNSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                        returnpath.push_back(CIOPoint(p1, p2));
                        break;
                    case UPSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                        returnpath.push_back(CIOPoint(p2, p1));
                        break;
                    }
                }
                                // append onto path any further downstream xbars found by recursion
                returnpath.splice(returnpath.end(), temp);
            } else {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() discarding new path");
                // keep the old return path and cleanup the temp one we just got back
                temp.clear();
            }
        }
    }
    if (pathlen == INT_MAX) {  // didn't find anything
                return 0;
    }
    path = returnpath;
    return pathlen;
}

HRESULT DSGraph::AddToROT(DWORD *pdwObjectRegistration) {
    PQMoniker pGraphMK;
    PQROT pROT;
    if (FAILED(::GetRunningObjectTable(0, &pROT))) {
        return E_UNEXPECTED;
    }
    OLECHAR osz[256];
    // undone: in the ia64 case the following format spec isn't enough digits for an address
    //wsprintfW(osz, OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    HRESULT hr = StringCchPrintfW(osz, sizeof(osz) / sizeof(osz[0]), OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    if(FAILED(hr)){
        ASSERT(false);
    }
    hr = ::CreateItemMoniker(OLESTR("!"), osz, &pGraphMK);
    if (SUCCEEDED(hr)) {
        hr = pROT->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, *this, pGraphMK, pdwObjectRegistration);
    }
    return hr;
}

void DSGraph::RemoveFromROT(DWORD dwObjectRegistration) {
   PQROT pROT;
   if (SUCCEEDED(::GetRunningObjectTable(0, &pROT))) {
       pROT->Revoke(dwObjectRegistration);
   }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////

DSGraph DSFilter::GetGraph(void) {
    FILTER_INFO finfo;
    HRESULT hr = (*this)->QueryFilterInfo(&finfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSFilter::GetGraph() failed");
        return DSGraph();
    }
    DSGraph graph = finfo.pGraph;
    if (finfo.pGraph) finfo.pGraph->Release(); // transfer ref count
    return graph;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////
CString DSFilter::GetName(void) const {
    CString csName;
    FILTER_INFO finfo;
    if (*this) {
        HRESULT hr = (*this)->QueryFilterInfo(&finfo);
        if (SUCCEEDED(hr)) {
            csName = finfo.achName;
            if (csName.IsEmpty()) {
                csName = _T("");
            }
            if (finfo.pGraph) {
                finfo.pGraph->Release();
            }
        } else {
#ifdef _DEBUG
            csName = _T("**** UNKNOWN FILTER NAME ****");
#endif
        }
    } else {
#ifdef _DEBUG
        csName = _T("**** NULL FILTER POINTER ****");
#endif
    }
    return csName;
}

void DSFilter::GetPinCounts(ULONG &ulIn, ULONG &ulOut) const
{
    HRESULT hr;
    ulIn = ulOut = 0;
    PIN_DIRECTION pd;
    DSFilter::iterator i;
    for (i = begin(); i != end(); ++i) {
        hr = (*i)->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSFilter:GetPinCounts() can't query pin direction hr = " << hr), "");
            THROWCOM(E_UNEXPECTED);
        }
        switch (pd) {
        case PINDIR_INPUT:
            ulIn++;
            break;
        case PINDIR_OUTPUT:
            ulOut++;
            break;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSPin
///////////////////////////////////////////////////////////////////////////////////////////////

bool DSPin::HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    PIN_DIRECTION pd1;
    HRESULT hr = (*this)->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPIN::IsPinCategeory() cant query Pin direction");
        return false;
    }
    if (pd1 != pd) {
        TRACELM(TRACE_ERROR, "DSPin::IsPinCategeory() wrong direction");
        return false;
    }
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

HRESULT DSPin::Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType) {
    DSGraph pGraph = GetGraph();
    DSGraph pConnGraph = ConnectTo.GetGraph();
    ASSERT(pGraph);
    ASSERT(pConnGraph);
    ASSERT(pGraph == pConnGraph);
    if (!pGraph || !pConnGraph || pGraph != pConnGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() pins not in same graph");
        THROWCOM(E_FAIL);
    }
	if (GetDirection() == PINDIR_OUTPUT) {
	    return pGraph->ConnectDirect(*this, ConnectTo, pMediaType);
	} else {
	    return pGraph->ConnectDirect(ConnectTo, *this, pMediaType);
	}
}

HRESULT DSPin::Disconnect(void) {
    DSPin ConnectedTo;
    HRESULT hr = (*this)->ConnectedTo(&ConnectedTo);
    if (FAILED(hr) || !ConnectedTo) {
        return NOERROR;  // not connected to anything
    }
    PIN_INFO pinfo;
    hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() can't call QueryPinInfo");
        THROWCOM(E_UNEXPECTED);
    }
    DSFilter PinFilter;
    PinFilter.p = pinfo.pFilter;  // directly transfer ownership of ref count
    DSGraph pGraph = PinFilter.GetGraph();
    if (!pGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Disconnect() can't get graph from PinFilter");
        THROWCOM(E_UNEXPECTED);
    }
    hr = pGraph->Disconnect(ConnectedTo);
    if (FAILED(hr)) {
        return hr;
    }
    return pGraph->Disconnect(*this);
}

// for any pin to possibly route they must be on the same filter and different directions
bool DSPin::Routable(const DSPin pin2) const {
    if (GetFilter() != pin2.GetFilter()) {
        return false;
    }
    if (GetDirection() == pin2.GetDirection()) {
        return false;
    }
    return true;
}

bool DSPin::CanRoute(const DSPin pin2) const {
        ASSERT(GetFilter() == pin2.GetFilter());
    PQCrossbarSwitch px1(GetFilter());
    if (!px1) {
        return Routable(pin2);
    }

    return DSXBarPin(*this).CanRoute(DSXBarPin(pin2));
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSXBarPin
///////////////////////////////////////////////////////////////////////////////////////////////
#if 0
const DSXBarPin DSXBarPin::Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir) {
    CPinPoints::const_iterator i;
    TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() finding " << point << " direction = " << pindir), "");
    for (i = pinpoints.begin(); i != pinpoints.end(); ++i) {
        TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() checking " << DSPin((*i).first) << " direction " << DSPin((*i).first).GetDirection() << " " << (*i).second), "");
        if ((*i).second == point && DSPin((*i).first).GetDirection() == pindir) {
            DSPin p((*i).first);
            PQCrossbarSwitch px1(p.GetFilter());
            if (!px1) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Find() not an xbar " << p), "");
                THROWCOM(E_FAIL);
            }
            TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() found " << p), "");
            return DSXBarPin(p);
        }
    }
    THROWCOM(E_FAIL);
    return DSXBarPin();
}
#endif
// undone: cache this lookup
const PQPoint DSXBarPin::GetPoint() const {
    DSFilter f= GetFilter();
    PQCrossbarSwitch px(f);
    if (!px) {
        TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Pin2Point() not an xbar" << *this), "");
        THROWCOM(E_INVALIDARG);
    }

    PIN_DIRECTION dir = GetDirection();
    long idx = 0;
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end() && *i != *this; ++i) {
        if ((*i).GetDirection() == dir) {  // output idx's start over at 0
            ++idx;
        }
    }

    if (i != f.end()) {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() " << *this << " pt = " << idx), "");
        return PQPoint(px, idx);
    } else {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() No Point"), "");
        return PQPoint();
    }
}

bool DSXBarPin::CanRoute(const DSXBarPin pin2) const {
    if (!Routable(pin2)) {
        // pins not on same filter or both pins same direction
        return false;
    }
    PQPoint pt1(GetPoint());
    if (!pt1.first) {
        // not on xbar or something corrupt
        return false;
    }
    PQPoint pt2(pin2.GetPoint());
    if (!pt2.first) {
        // not on xbar or something corrupt
        return false;
    }
    ASSERT(pt1.first == pt2.first);  // must be on same xbar

    HRESULT hr = E_FAIL;
    switch(GetDirection()) {
    case PINDIR_INPUT:
        hr = (pt1.first)->CanRoute(pt2.second, pt1.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() in 2.sec " << pt2.second << " 1.sec " << pt1.second << " hr = " << hr), "");
        break;
    case PINDIR_OUTPUT:
        hr = (pt1.first)->CanRoute(pt1.second, pt2.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() out 1.sec " << pt1.second << " 2.sec " << pt2.second << " hr = " << hr), "");
        break;
    }
    return hr == S_OK;
}

void VWStream::Route() {
    for (iterator i = begin(); i != end(); ++i) {
        CIOPoint p(*i);
        ASSERT(p.first.first == p.second.first);
        PQCrossbarSwitch px(p.first.first);
        HRESULT hr = px->Route(p.second.second, p.first.second);
        ASSERT(SUCCEEDED(hr));
                TRACELSM(TRACE_DETAIL, (dbgDump << "VWStream::Route() hr = " << hr << " px = " << px << " P.2.2 = " << p.second.second << " p.1.2 " << p.first.second), "");
    }
}

bool IsVideoFilter(const DSFilter& f) {
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end(); ++i) {
        if (IsVideoPin(*i)) {
            return true;
        }
    }
    return false;
}

bool IsVideoPin(const DSPin& p) {
    DSPin::iterator i;
    for (i = p.begin(); i != p.end(); ++i) {
        if (IsVideoMediaType(*i)) {
            return true;
        }
    }
    return false;
}

#if 0
// disable until we have pinpoints cache
void DSXBarPin::GetRelations(const CPinPoints &pinpoints, CString &csName, CString &csType, CString &csRelName) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar pin " << *this), "");
    CString csw;

    DSFilter f = GetFilter();
    PQCrossbarSwitch xbar(f);
    if (!xbar) {
        THROWCOM(E_FAIL);
    }
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar filter" << f), "");
    long rel, phys;
    HRESULT hr = xbar->get_CrossbarPinInfo(IsInput(), Pin2Point(pinpoints).second, &rel, &phys);
    if (FAILED(hr)) {
        THROWCOM(hr);
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  have xbar info.  pin = " << (*this) << " rel = " << rel << " phys = " << phys), "");

    TCHAR tphys[256];
    _ltot(phys, tphys, 10);

    csName = GetName();
    csType = tphys;

    ULONG inc, outc;
    f.GetPinCounts(inc, outc);
    long pincount = inc + outc;
    if (rel >= 0 && rel < pincount) {
        DSXBarPin RelPin(Find(pinpoints, PQPoint(xbar, rel), (*this).GetDirection()));
        if (!RelPin) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  can't build relpin.  rel = " << rel), "");
        } else {
            csRelName = RelPin.GetName();
        }
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  Name " << csName << " Type " << csType << " RelName " << csRelName), "");

    return;
}
#endif

#ifdef _DEBUG
void DumpMediaTypes(DSPin &p1, DSPin &p2) {
    DSPin::iterator i;
    DumpHdr(dbgDump) << "DumpMediaTypes(): " << std::endl;
    TRACEINDENT();
    for (i = p1.begin(); i != p1.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p2->QueryAccept(*i)) << std::endl;
    }
    DumpHdr(dbgDump) << "----" << std::endl;
    for (i = p2.begin(); i != p2.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p1->QueryAccept(*i)) << std::endl;
    }
    TRACEOUTDENT();
    dbgDump.flush();
}
#endif

#pragma optimize("a", off)

bool DSGraph::LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);

    GUID2* pInMedia = NULL;
    GUID2* pOutMedia = NULL;

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
            THROWCOM(E_UNEXPECTED);
        }
		PIN_DIRECTION pd2;
		switch (pd) {
		case PINDIR_INPUT:
			pd2 = PINDIR_OUTPUT;
			break;
		case PINDIR_OUTPUT:
			pd2 = PINDIR_INPUT;
			break;
		}

        bool fInReq = false, fOutReq = false;
        DWORD dwIn = 0;
        DWORD dwOut = 0;
        GUID2** ppMediaList = NULL;
        DWORD dwMediaCount = 0;

        for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
            ++dwMediaCount;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pindir = " << pd << " mediacount = " << dwMediaCount), "");

        switch (pd) {
        case PINDIR_INPUT:
            // hunting through graph from right to left
            fOutReq = true;
            dwOut = dwMediaCount;
            pOutMedia = new GUID2[dwOut * 2];
            ppMediaList = &pOutMedia;
            break;
        case PINDIR_OUTPUT:
            // hunting through graph from left to right
            fInReq = true;
            dwIn = dwMediaCount;
            pInMedia = new GUID2[dwIn * 2];
            ppMediaList = &pInMedia;

            break;
        }
        DWORD idx = 0;
        // note: some buggy filters don't support the reuse of an IEnumMediaTypes even though
        // reset succeeds.  they AV during the next pass through the enumerator.  thus, we
        // just create a new iterator which fetches a new IEnumMediaTypes interface(and underlying object)
        for (DSPin::iterator i2 = pPin1.begin(); i2 != pPin1.end(); ++i2) {
            (*ppMediaList)[idx++] = (*i2)->majortype;
            (*ppMediaList)[idx++] =  (*i2)->subtype;
        }

        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMediaType()  dwFlags = " << hexdump(dwFlags) << " Merit = " << hexdump(dwMerit) << " MediaList = ");
        TRACEINDENT();
        for (idx = 0; idx < dwMediaCount; ++idx) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "major = " << (*ppMediaList)[idx * 2] << " sub = " << (*ppMediaList)[(idx * 2) + 1] ), "");
        }
        TRACEOUTDENT();

        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fInReq = " << fInReq), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fOutReq = " << fOutReq), "");

                // try normal first
        {DSFilterMapper fmr(PQFilterMapper(*this),
                       0,										// 0 flags
                       !(dwFlags & ALLOW_WILDCARDS),			// bExactMatch
                       dwMerit,						            // merit
                       fInReq,                                  // input required
                       dwIn,
                       pInMedia,
                       NULL,                                    // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       dwOut,
                       pOutMedia,
                       NULL,                                    // output medium
                       NULL                                             // output pin cat
                      );
        if (fmr) {
            // direct connect
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() succeeded");
                    delete[] pInMedia;
                    delete[] pOutMedia;
					return true;
				}
			}
        }}
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
                delete[] pInMedia;
                delete[] pOutMedia;
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    delete[] pInMedia;
    delete[] pOutMedia;
    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() failed");
    return false;
}

#endif //TUNING_MODEL_ONLY

// end of file - dsextend.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dsoundp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/10/96     angusm  Added CLSID for DirectSound
 *  2/11/96     angusm  Added DSERR_UNINITIALIZED
 *  2/12/96     angusm  Added DSSCL_UNINITIALIZED
 *  3/5/96      angusm  Removed DSSCL_UNINITIALIZED
 *  1/29/97     dereks  Added boundaries, LPC* and REFGUIDs
 *  4/10/97     dereks  Added IDirectSoundCapture
 *  4/11/97     dereks  Added IKsPropertySet
 *  4/25/97     johnnyl Added DSCCREATE_WAVEMAPPED flag
 *  5/7/97      johnnyl Added DirectSoundCaptureBuffer::Initialize method
 *  5/8/97      dereks  Backed out REFGUIDs
 *  5/9/97      johnnyl Changed DSCCREATE_WAVEMAPPED to DSCBCAPS_WAVEMAPPED
 *                      Added DSCBLOCK_ENTIREBUFFER flag
 *  5/29/97     dereks  IDirectSoundPropertySet => IKsPropertySet
 *  7/10/98     dereks  Added DirectX 6.1 features
 *  8/19/98     dereks  Moved private object to dsprv.h
 *  9/15/98     dereks  Added DirectX 7.0 features
 *  7/6/99      duganp  Added DirectX 8.0 features
 *  10/29/99    duganp  Added DirectX 7.1 features (sic)
 *  06/06/00    alanlu  Cleaned up DSFX_I3DL2* constants
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);

//@@BEGIN_MSINTERNAL
// DirectSound Buffer Descriptor GUID {B2F586D4-5558-49D1-A07B3249DBBB33C2}
DEFINE_GUID(CLSID_DirectSoundBufferConfig, 0xb2f586d4, 0x5558, 0x49d1, 0xa0, 0x7b, 0x32, 0x49, 0xdb, 0xbb, 0x33, 0xc2);
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Magic private DirectSound buffer descriptor GUID {74A794F9-FDD2-4684-88831CB3CA6E6DA6}
DEFINE_GUID(CLSID_PRIVATE_CDirectSoundBufferConfig, 0x74a794f9, 0xfdd2, 0x4684, 0x88, 0x83, 0x1c, 0xb3, 0xca, 0x6e, 0x6d, 0xa6);
//@@END_MSINTERNAL

// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//@@BEGIN_MSINTERNAL

//
// DirectSound 7.1 (Windows ME) interface.
//

#if DIRECTSOUND_VERSION >= 0x0701
#ifdef __cplusplus
struct IDirectSoundCaptureBuffer7_1;
#endif
#endif

//@@END_MSINTERNAL

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
//@@BEGIN_MSINTERNAL
struct IDirectSoundFXSend;
//@@END_MSINTERNAL
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
//@@BEGIN_MSINTERNAL
///struct IDirectSoundFXI3DL2Source;
//@@END_MSINTERNAL
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
//@@BEGIN_MSINTERNAL
struct IDirectSoundCaptureFXAgc;
struct IDirectSoundCaptureFXMicArray;
struct IDirectSoundDMOProxy;
struct IDirectSoundFXI3DL2SourceEnv;
struct IDirectSound3DBufferPrivate;
//@@END_MSINTERNAL
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IDirectSoundFXSend8             IDirectSoundFXSend
//@@END_MSINTERNAL
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IDirectSoundFXI3DL2Source8      IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IDirectSoundCaptureFXAgc8       IDirectSoundCaptureFXAgc
#define IDirectSoundCaptureFXMicArray8  IDirectSoundCaptureFXMicArray
#define IDirectSoundDMOProxy8           IDirectSoundDMOProxy
#define IDirectSoundFXI3DL2SourceEnv8   IDirectSoundFXI3DL2SourceEnv
#define IDirectSound3DBufferPrivate8    IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
typedef struct IDirectSoundCaptureBuffer7_1 *LPDIRECTSOUNDCAPTUREBUFFER7_1;
#endif
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source    *LPDIRECTSOUNDFXI3DL2SOURCE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc     *LPDIRECTSOUNDCAPTUREFXAGC;
typedef struct IDirectSoundCaptureFXMicArray *LPDIRECTSOUNDCAPTUREFXMICARRAY;
typedef struct IDirectSoundDMOProxy         *LPDIRECTSOUNDDMOPROXY;
typedef struct IDirectSoundFXI3DL2SourceEnv *LPDIRECTSOUNDFXI3DL2SOURCEENV;
typedef struct IDirectSound3DBufferPrivate  *LPDIRECTSOUND3DBUFFERPRIVATE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend8          *LPDIRECTSOUNDFXSEND8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source8   *LPDIRECTSOUNDFXI3DL2SOURCE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc8    *LPDIRECTSOUNDCAPTUREFXAGC8;
typedef struct IDirectSoundCaptureFXMicArray8 *LPDIRECTSOUNDCAPTUREFXMICARRAY8;
typedef struct IDirectSoundDMOProxy8        *LPDIRECTSOUNDDMOPROXY8;
typedef struct IDirectSoundFXI3DL2SourceEnv8 *LPDIRECTSOUNDFXI3DL2SOURCEENV8;
typedef struct IDirectSound3DBufferPrivate8 *LPDIRECTSOUND3DBUFFERPRIVATE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundFXSend8             IID_IDirectSoundFXSend
//@@END_MSINTERNAL
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IID_IDirectSoundFXI3DL2Source8      IID_IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundCaptureFXAgc8       IID_IDirectSoundCaptureFXAgc
#define IID_IDirectSoundCaptureFXMicArray8  IID_IDirectSoundCaptureFXMicArray
#define IID_IDirectSoundDMOProxy8           IID_IDirectSoundDMOProxy
#define IID_IDirectSoundFXI3DL2SourceEnv8   IID_IDirectSoundFXI3DL2SourceEnv
#define IID_IDirectSound3DBufferPrivate8    IID_IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
//@@BEGIN_MSINTERNAL
    // dwReserved1 == minor ver number, dwReserved2 == major ver number.
//@@END_MSINTERNAL
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
//@@BEGIN_MSINTERNAL
    #define DSFX_OPTIONAL       0x00000004
    #define DSFX_VALIDFLAGS     (DSFX_LOCHARDWARE | DSFX_LOCSOFTWARE)
//@@END_MSINTERNAL

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002
//@@BEGIN_MSINTERNAL
    #define DSCFX_RESERVED      0x00000020
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
    #define DSCFX_LOCMASK         (DSCFX_LOCHARDWARE | DSCFX_LOCSOFTWARE )
    #define DSCFX_VALIDFLAGS      (DSCFX_LOCMASK)
//@@END_MSINTERNAL

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
//@@BEGIN_MSINTERNAL
// Since we don't support LOCDEFER-style voice management on capture,
// and we don't have a DSCFX_OPTIONAL flag at the moment, none of the
// flags below can ever be returned.  So they're private for now.
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
//@@END_MSINTERNAL

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
    STDMETHOD(CreateSoundBufferFromWave) (THIS_ LPUNKNOWN pDSWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
#endif
//@@END_MSINTERNAL
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->lpVtbl->CreateSoundBufferFromWave(p,a,b,c)
#endif
//@@END_MSINTERNAL
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->CreateSoundBufferFromWave(a,b,c)
#endif
//@@END_MSINTERNAL
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
    STDMETHOD(SetChannelVolume)     (THIS_ DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes) PURE;
#endif
//@@END_MSINTERNAL
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701

//
// IDirectSoundCaptureBuffer7_1
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer7_1, 0xd6b2a50d, 0x918e, 0x47de, 0x9b, 0xcd, 0x64, 0xd4, 0x9c, 0x5b, 0x1d, 0x75);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer7_1

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer7_1, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer7_1 methods
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(SetMicVolume)         (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetMicVolume)         (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(EnableMic)            (THIS_ BOOL fEnable) PURE;
    STDMETHOD(YieldFocus)           (THIS) PURE;
    STDMETHOD(ClaimFocus)           (THIS) PURE;
    STDMETHOD(SetFocusHWND)         (THIS_ HWND hwndMainWindow) PURE;
    STDMETHOD(GetFocusHWND)         (THIS_ HWND *phwndMainWindow) PURE;
    STDMETHOD(EnableFocusNotifications) (THIS_ HANDLE hFocusEvent) PURE;
};

#define IDirectSoundCaptureBuffer7_1_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer7_1_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer7_1_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->lpVtbl->SetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->lpVtbl->GetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->lpVtbl->YieldFocus(p)
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->lpVtbl->ClaimFocus(p)
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->lpVtbl->SetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->lpVtbl->GetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->lpVtbl->EnableFocusNotifications(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->Start(a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->Stop()
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->Unlock(a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->SetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->GetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->YieldFocus()
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->ClaimFocus()
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->SetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->GetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->EnableFocusNotifications(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0701
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL

//
// IDirectSoundFXSend
//

DEFINE_GUID(IID_IDirectSoundFXSend, 0xb30f3564, 0x1698, 0x45ba, 0x9f, 0x75, 0xfc, 0x3c, 0x6c, 0x3b, 0x28, 0x10);

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend, *LPDSFXSend;

typedef const DSFXSend *LPCDSFXSend;

#undef INTERFACE
#define INTERFACE IDirectSoundFXSend

DECLARE_INTERFACE_(IDirectSoundFXSend, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXSend methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXSend pcDsFxSend) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXSend pDsFxSend) PURE;
};

#define IDirectSoundFXSend_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXSend_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXSend_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if 0
//
// IDirectSoundFXI3DL2Source
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Source, 0x4363ff5c, 0x0410, 0x4507, 0xb3, 0x21, 0xea, 0x09, 0xf8, 0xf4, 0x56, 0x99);

typedef struct _DSFXI3DL2Obstruction
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.0
} DSFXI3DL2Obstruction, *LPDSFXI3DL2Obstruction;

typedef const DSFXI3DL2Obstruction *LPCDSFXI3DL2Obstruction;

typedef struct _DSFXI3DL2Occlusion
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.25
} DSFXI3DL2Occlusion, *LPDSFXI3DL2Occlusion;

typedef const DSFXI3DL2Occlusion *LPCDSFXI3DL2Occlusion;

typedef struct _DSFXI3DL2Source
{
    LONG                    lDirect;                // [-10000, 1000] default: 0 mB
    LONG                    lDirectHF;              // [-10000, 0]    default: 0 mB
    LONG                    lRoom;                  // [-10000, 1000] default: 0 mB
    LONG                    lRoomHF;                // [-10000, 0]    default: 0 mB
    FLOAT                   flRoomRolloffFactor;    // [0.0, 10.0]    default: 0.0
    DSFXI3DL2Obstruction  Obstruction;
    DSFXI3DL2Occlusion    Occlusion;
    DWORD                   dwFlags;                // default: DSFX_I3DL2SOURCE_OCC_LPF
} DSFXI3DL2Source, *LPDSFXI3DL2Source;

typedef const DSFXI3DL2Source *LPCDSFXI3DL2Source;

#define DSFX_I3DL2SOURCE_DIRECT_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_DIRECT_MAX                     1000
#define DSFX_I3DL2SOURCE_DIRECT_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_DIRECTHF_MIN                   (-10000)
#define DSFX_I3DL2SOURCE_DIRECTHF_MAX                   0
#define DSFX_I3DL2SOURCE_DIRECTHF_DEFAULT               0
                                                        
#define DSFX_I3DL2SOURCE_ROOM_MIN                       (-10000)
#define DSFX_I3DL2SOURCE_ROOM_MAX                        1000
#define DSFX_I3DL2SOURCE_ROOM_DEFAULT                   0
                                                        
#define DSFX_I3DL2SOURCE_ROOMHF_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_ROOMHF_MAX                     0
#define DSFX_I3DL2SOURCE_ROOMHF_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN          0.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX          10.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_DEFAULT      0.0f
                                                        
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN        (-10000)
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX        0
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_DEFAULT    0

#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN        0.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX        1.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_DEFAULT    0.0f

#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN          (-10000)
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX          0
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_DEFAULT      0
                                                        
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN          0.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX          1.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_DEFAULT      0.25f

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Source

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Source, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Source methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Source pcDsFxI3DL2Source) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Source pDsFxI3DL2Source) PURE;
    STDMETHOD(SetObstructionPreset) (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetObstructionPreset) (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetOcclusionPreset)   (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetOcclusionPreset)   (THIS_ LPDWORD pdwPreset) PURE;
};

#define IDirectSoundFXI3DL2Source_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Source_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Source_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->lpVtbl->SetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->lpVtbl->GetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->lpVtbl->SetOcclusionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->lpVtbl->GetOcclusionPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->SetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->GetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->SetOcclusionPreset(a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->GetOcclusionPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
#endif // 0
//@@END_MSINTERNAL

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
//
// IDirectSoundFXI3DL2SourceEnv - A private interface used by the I3DL2 source DMO
// to receive various bits of information about the environment it's operating in.
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2SourceEnv, 0xf6c55470, 0x7706, 0x4ce1, 0xa3, 0x54, 0x74, 0xb2, 0xf0, 0x3, 0x25, 0xe2);

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2SourceEnv

DECLARE_INTERFACE_(IDirectSoundFXI3DL2SourceEnv, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2SourceEnv methods
    STDMETHOD(SetEnvironmentReverb) (THIS_ LPDIRECTSOUNDFXI3DL2REVERB8) PURE;
    STDMETHOD(SetDS3DBuffer)        (THIS_ LPDIRECTSOUND3DBUFFER) PURE;
    STDMETHOD(SetDS3DListener)      (THIS_ LPDIRECTSOUND3DLISTENER) PURE;
};

#define IDirectSoundFXI3DL2SourceEnv_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2SourceEnv_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2SourceEnv_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->lpVtbl->SetEnvironmentReverb(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->lpVtbl->SetDS3DBuffer(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->lpVtbl->SetDS3DListener(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->SetEnvironmentReverb(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->SetDS3DBuffer(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->SetDS3DListener(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBufferPrivate - provided by our 3D buffer object so that the
// I3DL2 source DMO can discover the current attenuation of its host buffer.
//

DEFINE_GUID(IID_IDirectSound3DBufferPrivate, 0x7d8ef383, 0xca05, 0x4593, 0x82, 0xa1, 0x44, 0x4e, 0x80, 0x08, 0x71, 0xe1);

#undef INTERFACE
#define INTERFACE IDirectSound3DBufferPrivate

DECLARE_INTERFACE_(IDirectSound3DBufferPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBufferPrivate methods
    STDMETHOD(GetAttenuation)       (THIS_ FLOAT*) PURE;
};

#define IDirectSound3DBufferPrivate_QueryInterface(p,a,b)   IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBufferPrivate_AddRef(p)               IUnknown_AddRef(p)
#define IDirectSound3DBufferPrivate_Release(p)              IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->lpVtbl->GetAttenuation(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->GetAttenuation(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL

//
// IDirectSoundCaptureFXAgc
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAgc, 0xe54f76b8, 0xe48f, 0x427b, 0xb7, 0xf7, 0xaf, 0xb8, 0xc7, 0x13, 0xa1, 0x25);

typedef struct _DSCFXAgc
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAgc, *LPDSCFXAgc;

typedef const DSCFXAgc *LPCDSCFXAgc;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAgc

DECLARE_INTERFACE_(IDirectSoundCaptureFXAgc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAgc methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc pcDscFxAgc) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc pDscFxAgc) PURE;
};

#define IDirectSoundCaptureFXAgc_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAgc_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAgc_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXMicArray
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMicArray, 0x9AAB5F95, 0xCAF6, 0x4e2a, 0x9D, 0x16, 0x24, 0x5E, 0xBF, 0xDC, 0xFB, 0xE9);

typedef struct _DSCFXMicArray
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXMicArray, *LPDSCFXMicArray;

typedef const DSCFXMicArray *LPCDSCFXMicArray;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMicArray

DECLARE_INTERFACE_(IDirectSoundCaptureFXMicArray, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMicArray methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXMicArray pcDscFxMicArray) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXMicArray pDscFxMicArray) PURE;
};

#define IDirectSoundCaptureFXMicArray_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMicArray_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMicArray_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundDMOProxy
//

DEFINE_GUID(IID_IDirectSoundDMOProxy,0xe782c03b,0x8187,0x4110,0xb6,0x53,0xd1,0x53,0xff,0x8f,0x42,0xc7);

#undef INTERFACE
#define INTERFACE IDirectSoundDMOProxy

DECLARE_INTERFACE_(IDirectSoundDMOProxy, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundDMOProxy methods
    STDMETHOD(AcquireResources)     (THIS_ IKsPropertySet *pKsPropertySet) PURE;
    STDMETHOD(ReleaseResources)     (THIS) PURE;
    STDMETHOD(InitializeNode)       (THIS_ HANDLE hPin, ULONG ulNodeId) PURE;
};

#define IDirectSoundDMOProxy_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundDMOProxy_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundDMOProxy_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->lpVtbl->AcquireResources(p,a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->lpVtbl->ReleaseResources(p)
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->lpVtbl->InitializeNode(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->AcquireResources(a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->ReleaseResources()
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->InitializeNode(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@END_MSINTERNAL

//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK
//@@BEGIN_MSINTERNAL
#define DS_OK_EXPLANATION TEXT("The function completed successfully")
//@@END_MSINTERNAL

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)
//@@BEGIN_MSINTERNAL
#define DS_NO_VIRTUALIZATION_EXPLANATION TEXT("The function succeeded, substituting the Pan3D algorithm")
//@@END_MSINTERNAL

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)
//@@BEGIN_MSINTERNAL
#define DS_INCOMPLETE_EXPLANATION TEXT("The function succeeded, but not all of the optional effects requested could be obtained")
//@@END_MSINTERNAL

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
//@@BEGIN_MSINTERNAL
#define DSERR_ALLOCATED_EXPLANATION TEXT("The call failed because resources (such as a priority level) were already being used by another caller")
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
// An attempt was made to lock the area between the play and write cursors
#define DSERR_CANTLOCKPLAYCURSOR        MAKE_DSHRESULT(20)
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#define DSERR_CANTLOCKPLAYCURSOR_EXPLANATION TEXT("An attempt was made to lock the area between the play and write cursors")
//@@END_MSINTERNAL

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
//@@BEGIN_MSINTERNAL
#define DSERR_CONTROLUNAVAIL_EXPLANATION TEXT("The control (vol, pan, etc.) requested by the caller is not available")
//@@END_MSINTERNAL

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDPARAM_EXPLANATION TEXT("An invalid parameter was passed to the returning function")
//@@END_MSINTERNAL

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDCALL_EXPLANATION TEXT("This call is not valid for the current state of this object")
//@@END_MSINTERNAL

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL
//@@BEGIN_MSINTERNAL
#define DSERR_GENERIC_EXPLANATION TEXT("An undetermined error occurred inside the DirectSound subsystem")
//@@END_MSINTERNAL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
//@@BEGIN_MSINTERNAL
#define DSERR_PRIOLEVELNEEDED_EXPLANATION TEXT("The caller does not have the priority level required for the function to succeed")
//@@END_MSINTERNAL

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
//@@BEGIN_MSINTERNAL
#define DSERR_OUTOFMEMORY_EXPLANATION TEXT("Not enough free memory is available to complete the operation")
//@@END_MSINTERNAL

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
//@@BEGIN_MSINTERNAL
#define DSERR_BADFORMAT_EXPLANATION TEXT("The specified WAVE format is not supported")
//@@END_MSINTERNAL

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL
//@@BEGIN_MSINTERNAL
#define DSERR_UNSUPPORTED_EXPLANATION TEXT("The function called is not supported at this time")
//@@END_MSINTERNAL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
//@@BEGIN_MSINTERNAL
#define DSERR_NODRIVER_EXPLANATION TEXT("No sound device is available for use, or the given device ID isn't valid")
//@@END_MSINTERNAL

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
//@@BEGIN_MSINTERNAL
#define DSERR_ALREADYINITIALIZED_EXPLANATION TEXT("This object is already initialized")
//@@END_MSINTERNAL

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
//@@BEGIN_MSINTERNAL
#define DSERR_NOAGGREGATION_EXPLANATION TEXT("This object does not support aggregation")
//@@END_MSINTERNAL

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERLOST_EXPLANATION TEXT("The buffer memory has been lost, and must be restored")
//@@END_MSINTERNAL

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
//@@BEGIN_MSINTERNAL
#define DSERR_OTHERAPPHASPRIO_EXPLANATION TEXT("Another app has a higher priority level, preventing this call from succeeding")
//@@END_MSINTERNAL

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
//@@BEGIN_MSINTERNAL
#define DSERR_UNINITIALIZED_EXPLANATION TEXT("This object has not been initialized")
//@@END_MSINTERNAL

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE
//@@BEGIN_MSINTERNAL
#define DSERR_NOINTERFACE_EXPLANATION TEXT("The requested COM interface is not available")
//@@END_MSINTERNAL

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED
//@@BEGIN_MSINTERNAL
#define DSERR_ACCESSDENIED_EXPLANATION TEXT("Access is denied")
//@@END_MSINTERNAL

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERTOOSMALL_EXPLANATION TEXT("Tried to create a CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")
//@@END_MSINTERNAL

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)
//@@BEGIN_MSINTERNAL
#define DSERR_DS8_REQUIRED_EXPLANATION TEXT("Attempt to use DirectSound 8 functionality on an older DirectSound object")
//@@END_MSINTERNAL

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)
//@@BEGIN_MSINTERNAL
#define DSERR_SENDLOOP_EXPLANATION TEXT("A circular loop of send effects was detected")
//@@END_MSINTERNAL

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)
//@@BEGIN_MSINTERNAL
#define DSERR_BADSENDBUFFERGUID_EXPLANATION TEXT("The GUID specified does not match a valid MIXIN buffer")
//@@END_MSINTERNAL

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)
//@@BEGIN_MSINTERNAL
// Can't just be #defined to DMUS_E_NOTFOUND because we don't include the header
#define DSERR_OBJECTNOTFOUND_EXPLANATION TEXT("The object was not found")
//@@END_MSINTERNAL

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)
//@@BEGIN_MSINTERNAL
#define DSERR_FXUNAVAILABLE_EXPLANATION TEXT("The effects could not be found in the order and location requested")
//@@END_MSINTERNAL

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
//@@BEGIN_MSINTERNAL
#define DSCAPS_PRIMARYFLAGS         (DSCAPS_PRIMARYMONO | DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARY16BIT)
#define DSCAPS_SECONDARYFLAGS       (DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO | DSCAPS_SECONDARY8BIT | DSCAPS_SECONDARY16BIT)
#define DSCAPS_VALIDDRIVERFLAGS     (DSCAPS_PRIMARYFLAGS | DSCAPS_SECONDARYFLAGS | DSCAPS_CONTINUOUSRATE)
#define DSCAPS_VALIDFLAGS           (DSCAPS_VALIDDRIVERFLAGS | DSCAPS_EMULDRIVER | DSCAPS_CERTIFIED)
#define DSCAPS_FILENAMECOOKIE       179  // Must be less than 256.
#define DSCAPS_FILENAMEMODVALUE     247  // Must be less that 256.
//@@END_MSINTERNAL

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006
#define DSSPEAKER_7POINT1           0x00000007
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_FIRST             DSSPEAKER_DIRECTOUT
#define DSSPEAKER_LAST              DSSPEAKER_7POINT1
#define DSSPEAKER_DEFAULT           DSSPEAKER_STEREO
//@@END_MSINTERNAL

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_CONFIG_MASK       0x000000FF
#define DSSPEAKER_GEOMETRY_MASK     0x00FF0000
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#ifndef _SPEAKER_POSITIONS_

// Speaker positions for SetChannelVolume()
#define _SPEAKER_POSITIONS_
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Not used in the DirectSound API
#define SPEAKER_ALL                     0x80000000

#endif // _SPEAKER_POSITIONS_
#endif // FUTURE_MULTIPAN_SUPPORT
//@@END_MSINTERNAL

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#define DSBCAPS_CTRLCHANNELVOLUME   0x00000400
#endif
#define DSBCAPS_MIXIN               0x00002000
//@@END_MSINTERNAL
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
//@@BEGIN_MSINTERNAL
#define DSBCAPS_SINKIN              0x00001000  // Means buffer will receive data from a DirectSound sink
#ifdef FUTURE_WAVE_SUPPORT
#define DSBCAPS_FROMWAVEOBJECT      0x00080000  // Means buffer was created with CreateSoundBufferFromWave()
#endif
#define DSBCAPS_DSBUFFERDESC1MASK   0x0003C1FF  // Flags valid for pre-DX7 applications
#define DSBCAPS_DSBUFFERDESC7MASK   (DSBCAPS_DSBUFFERDESC1MASK | DSBCAPS_LOCDEFER)  // Flags valid for DX7 apps
#define DSBCAPS_VALIDFLAGS          (DSBCAPS_DSBUFFERDESC7MASK | DSBCAPS_CTRLFX | DSBCAPS_MIXIN)  //...DX8 apps
#define DSBCAPS_CTRLATTENUATION     (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN)
#define DSBCAPS_CTRLNOVIRT          (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY)
#define DSBCAPS_LOCMASK             (DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE)  // All valid location flags
#define DSBCAPS_FOCUSMASK           (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS)  // All valid focus flags
#define DSBCAPS_DRIVERFLAGSMASK     (DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLATTENUATION | \
                                     DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY)  // Flags of interest to a VxD driver
#define DSBCAPS_STREAMINGVALIDFLAGS (DSBCAPS_LOCMASK | DSBCAPS_FOCUSMASK | DSBCAPS_MIXIN | \
                                     DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | \
                                     DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE )
#define DSBCAPS_CHANVOLVALIDFLAGS   (DSBCAPS_VALIDFLAGS & ~(DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPAN | \
                                                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE))
#define DSBCAPS_FROMWAVEVALIDFLAGS  (DSBCAPS_LOCMASK | DSBCAPS_LOCDEFER | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLPAN | \
                                     DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLFREQUENCY)
//@@END_MSINTERNAL

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
//@@BEGIN_MSINTERNAL
#define DSBPLAY_LOCMASK             (DSBPLAY_LOCHARDWARE | DSBPLAY_LOCSOFTWARE)  // All valid location flags
#define DSBPLAY_TERMINATEBY_MASK    (DSBPLAY_TERMINATEBY_TIME | DSBPLAY_TERMINATEBY_DISTANCE | DSBPLAY_TERMINATEBY_PRIORITY)
#define DSBPLAY_LOCDEFERMASK        (DSBPLAY_LOCMASK | DSBPLAY_TERMINATEBY_MASK)
#define DSBPLAY_VALIDFLAGS          (DSBPLAY_LOCDEFERMASK | DSBPLAY_LOOPING)
//@@END_MSINTERNAL

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_ACTIVE            0x00000040
#define DSBSTATUS_RESOURCESACQUIRED 0x00000080
#define DSBSTATUS_STOPPEDBYFOCUS    0x00000100
#define DSBSTATUS_LOCMASK           (DSBSTATUS_LOCHARDWARE | DSBSTATUS_LOCSOFTWARE)
#define DSBSTATUS_LOCDEFERMASK      (DSBSTATUS_LOCMASK | DSBSTATUS_TERMINATED)
#define DSBSTATUS_USERMASK          (DSBSTATUS_LOCDEFERMASK | DSBSTATUS_PLAYING | DSBSTATUS_BUFFERLOST | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
//@@BEGIN_MSINTERNAL
#define DSBLOCK_VALIDFLAGS          (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
//@@BEGIN_MSINTERNAL
#define DS3D_VALIDFLAGS             0x00000001
//@@END_MSINTERNAL

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCCAPS_MULTIPLECAPTURE     0x00000001
#endif
//@@END_MSINTERNAL

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

//@@BEGIN_MSINTERNAL
#define DSCBCAPS_LOCHARDWARE        0x00000004
#define DSCBCAPS_LOCSOFTWARE        0x00000008

#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBCAPS_CTRLVOLUME         0x10000000
#define DSCBCAPS_FOCUSAWARE         0x20000000
#define DSCBCAPS_STRICTFOCUS        0x40000000
#endif

#define DSCBCAPS_VALIDFLAGS         (DSCBCAPS_WAVEMAPPED | DSCBCAPS_STRICTFOCUS | DSCBCAPS_FOCUSAWARE | DSCBCAPS_CTRLVOLUME | DSCBCAPS_CTRLFX)
//@@END_MSINTERNAL

#define DSCBLOCK_ENTIREBUFFER       0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBLOCK_VALIDFLAGS         0x00000001
//@@END_MSINTERNAL

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBSTATUS_INFOCUS          0x00000004
#define DSCBSTATUS_LOSTFOCUS        0x00000008
#endif
#define DSCBSTATUS_STOPPING         0x80000000
#define DSCBSTATUS_STOPPED          0x40000000

#define DSCBSTATUS_USERMASK         0x0000FFFF
//@@END_MSINTERNAL

#define DSCBSTART_LOOPING           0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBSTART_VALIDFLAGS        DSCBSTART_LOOPING
//@@END_MSINTERNAL

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//@@BEGIN_MSINTERNAL

// Dsound system resource constants: these match the
// KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values in ksmedia.h
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000

#if 0
//
// Flags for the I3DL2 reverberation effect
//

enum
{
    DSFX_I3DL2SOURCE_OCC_LPF,
    DSFX_I3DL2SOURCE_OCC_VOLUME
};
#endif
//@@END_MSINTERNAL

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_MATERIAL_PRESET_MAX
//@@END_MSINTERNAL
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_ENVIRONMENT_PRESET_MAX
//@@END_MSINTERNAL
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL
// Original DirectSound3D ITD algorithm {1B5C9566-5E20-11d2-91BD-00C04FC28ACA}
DEFINE_GUID(DS3DALG_ITD, 0x1b5c9566, 0x5e20, 0x11d2, 0x91, 0xbd, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Buffer Send {EF602176-BCBB-49E0-8CCA-E09A5A152B33}
DEFINE_GUID(GUID_DSFX_SEND, 0xef602176, 0xbcbb, 0x49e0, 0x8c, 0xca, 0xe0, 0x9a, 0x5a, 0x15, 0x2b, 0x33);
//@@END_MSINTERNAL

// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

//@@BEGIN_MSINTERNAL
// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
///DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);
//@@END_MSINTERNAL

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Microphone Array Processor {830A44f2-A32D-476B-BE97-42845673B35A}
// Matches KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_MA, 0x830A44F2, 0xA32D, 0x476B,  0xBE, 0x97, 0x42, 0x84, 0x56, 0x73, 0xB3, 0x5A);

// Microsoft Microphone Array Processor {F4A49496-1481-44d7-9C4E-A0269CAF0597}
DEFINE_GUID(GUID_DSCFX_MS_MA, 0xF4A49496, 0x1481, 0x44d7, 0x9C, 0x4E, 0xA0, 0x26, 0x9C, 0xAF, 0x5, 0x97);

// System Microphone Array Processor {B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}
DEFINE_GUID(GUID_DSCFX_SYSTEM_MA, 0xB6F5A0A0, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F );

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft Automatic Gain Control {5A86531E-8E2A-419f-B4CC-18EB8E891796}
DEFINE_GUID(GUID_DSCFX_MS_AGC, 0x5a86531e, 0x8e2a, 0x419f, 0xb4, 0xcc, 0x18, 0xeb, 0x8e, 0x89, 0x17, 0x96);

// System Automatic Gain Control {950E55B9-877C-4c67-BE08-E47B5611130A}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AGC, 0x950e55b9, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa);
//@@END_MSINTERNAL

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__


//@@BEGIN_MSINTERNAL

#ifndef __DSOUNDP_INCLUDED__
#define __DSOUNDP_INCLUDED__

#if DIRECTSOUND_VERSION >= 0x0800

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUNDP_INCLUDED__

//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dsprv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprv.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/19/98     dereks  Created.
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __DSPRV_INCLUDED__
#define __DSPRV_INCLUDED__

#ifndef __DSOUND_INCLUDED__
#error dsound.h not included
#endif // __DSOUND_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// 
// DirectSound Mixer Properties {84624F80-25EC-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundMixer, 0x84624f80, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum 
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
} DSPROPERTY_DIRECTSOUNDMIXER;

typedef enum
{
    DIRECTSOUNDMIXER_SRCQUALITY_WORST,
    DIRECTSOUNDMIXER_SRCQUALITY_PC,
    DIRECTSOUNDMIXER_SRCQUALITY_BASIC,
    DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED,
} DIRECTSOUNDMIXER_SRCQUALITY;

#define DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA
{
    GUID                        DeviceId;   // DirectSound device id
    DIRECTSOUNDMIXER_SRCQUALITY Quality;    // SRC quality
} DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA;

#define DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX   0x00000001
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS  0x00000002
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D       0x00000004
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS 0x00000008
                                                        
#define DIRECTSOUNDMIXER_ACCELERATIONF_FULL         0x00000000
#define DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD     0x00000008
#define DIRECTSOUNDMIXER_ACCELERATIONF_NONE         0x0000000F

#ifdef WINNT
#define DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT      DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD
#else // WINNT
#define DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT      DIRECTSOUNDMIXER_ACCELERATIONF_FULL
#endif // WINNT

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA
{
    GUID    DeviceId;   // DirectSound device id
    ULONG   Flags;      // Acceleration flags
} DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA;

// 
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE
} DSPROPERTY_DIRECTSOUNDDEVICE;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1
#define DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
{
    GUID    DeviceId;   // DirectSound device id
    BOOL    Present;    // Presence switch
} DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA
{
    GUID                        DeviceId;   // DirectSound device id
    DIRECTSOUNDDEVICE_TYPE      DeviceType; // Device type
    BOOL                        Present;    // Presence switch
} DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA;

#if DIRECTSOUND_VERSION < 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
#endif // DIRECTSOUND_VERSION < 0x0700

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
{
    LPWSTR                      DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, LPVOID);

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW
#else // UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1 Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

// 
// Basic DirectSound Acceleration Properties {1AEAA606-35F0-11D1-B161-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundBasicAcceleration, 0x1aeaa606, 0x35f0, 0x11d1, 0xb1, 0x61, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT,
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION;

typedef enum
{
    DIRECTSOUNDBASICACCELERATION_NONE,
    DIRECTSOUNDBASICACCELERATION_SAFE,
    DIRECTSOUNDBASICACCELERATION_STANDARD,
    DIRECTSOUNDBASICACCELERATION_FULL,
} DIRECTSOUNDBASICACCELERATION_LEVEL;

typedef struct _DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA
{
    GUID                                DeviceId;   // DirectSound device id
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level;      // Basic acceleration level
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA,
  DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA, *PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA;

// 
// DirectSound Debug Properties {F2957840-260C-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundDebug, 0xf2957840, 0x260c, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A,
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W,
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A,
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W,
} DSPROPERTY_DIRECTSOUNDDEBUG;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME     0x00000001
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID  0x00000002
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE         0x00000004
#define DIRECTSOUNDDEBUG_DPFINFOF_LOGTOFILEONLY         0x00000008

#define DIRECTSOUNDDEBUG_DPFINFOF_DEFAULT               DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    CHAR    LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    WCHAR   LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
{
    HRESULT ResultCode;     // Result code
    LPSTR   String;         // Result code in string form
    LPSTR   Explanation;    // Result code description
} DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
{
    HRESULT ResultCode;     // Result code
    LPWSTR  String;         // Result code in string form
    LPWSTR  Explanation;    // Result code description
} DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFLEVEL_DEFAULT   0
#define DIRECTSOUNDDEBUG_BREAKLEVEL_DEFAULT 0

// 
// DirectSound Persistent Data {1BE55C3E-36AB-11d1-B162-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundPersistentData, 0x1be55c3e, 0x36ab, 0x11d1, 0xb1, 0x62, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A,
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W,
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPSTR   SubKeyName;         // Optional subkey name
    LPSTR   ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPWSTR  SubKeyName;         // Optional subkey name
    LPWSTR  ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#endif // UNICODE

// 
// DirectSound Buffer Properties {50393DEA-51AD-11d2-91B2-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundBuffer, 0x50393dea, 0x51ad, 0x11d2, 0x91, 0xb2, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum 
{
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
} DSPROPERTY_DIRECTSOUNDBUFFER;

typedef struct _DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA
{
    LPDIRECTSOUNDBUFFER Buffer;     // Buffer object pointer
    GUID                DeviceId;   // DirectSound device ID
} DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA, *PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA;

// 
// DirectSound Object Properties {4BE334F0-1C8E-4D91-8C17-5889D6F0B154}
// 

DEFINE_GUID(DSPROPSETID_DirectSound, 0x4be334f0, 0x1c8e, 0x4d91, 0x8c, 0x17, 0x58, 0x89, 0xd6, 0xf0, 0xb1, 0x54);

typedef enum 
{
    DSPROPERTY_DIRECTSOUND_OBJECTS,
    DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS
} DSPROPERTY_DIRECTSOUND;

#pragma warning(disable:4200)           // Disable the nag about the Objects[0] arrays below

typedef struct _DIRECTSOUND_INFO
{
    LPDIRECTSOUND           DirectSound;
    GUID                    DeviceId;
} DIRECTSOUND_INFO;

typedef struct _DSPROPERTY_DIRECTSOUND_OBJECTS_DATA
{
    GUID                    DeviceId;   // [in]  DirectSound device ID (or GUID_NULL for all DS objects)
    ULONG                   Count;      // [out] Count of DirectSound objects matching this DeviceId
    DIRECTSOUND_INFO        Objects[0]; // [out] Information about each DirectSound object
} DSPROPERTY_DIRECTSOUND_OBJECTS_DATA, *PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA;

typedef struct _DIRECTSOUNDCAPTURE_INFO
{
    LPDIRECTSOUNDCAPTURE    DirectSoundCapture;
    GUID                    DeviceId;
} DIRECTSOUNDCAPTURE_INFO;

typedef struct _DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA
{
    GUID                    DeviceId;   // [in]  DirectSoundCapture device ID (or GUID_NULL for all DSC objects)
    ULONG                   Count;      // [out] Count of DirectSoundCapture objects matching this DeviceId
    DIRECTSOUNDCAPTURE_INFO Objects[0]; // [out] Information about each DirectSoundCapture object
} DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA, *PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSPRV_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\dvpp.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	initial implementation
 *   29-jan-97	smac	Various API changes
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawVideoPortNotify,    0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88);



DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer            FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort             FAR *LPDIRECTDRAWVIDEOPORT;
typedef struct IDirectDrawVideoPortNotify       FAR *LPDIRECTDRAWVIDEOPORTNOTIFY;

typedef struct _DDVIDEOPORTCONNECT              FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS                 FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC                 FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO                 FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH            FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS               FAR *LPDDVIDEOPORTSTATUS;
typedef struct _DDVIDEOPORTNOTIFY               FAR *LPDDVIDEOPORTNOTIFY;

typedef struct IDDVideoPortContainerVtbl        DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl         DIRECTDRAWVIDEOPORTCALLBACKS;
typedef struct IDirectDrawVideoPortNotifyVtbl   DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif

/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPortNotify
DECLARE_INTERFACE_( IDirectDrawVideoPortNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(AcquireNotification)(THIS_ HANDLE *, LPDDVIDEOPORTNOTIFY) PURE;
    STDMETHOD(ReleaseNotification)(THIS_ HANDLE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoPortNotify_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(p,a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(p,a)
#else
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->AddRef()
#define IVideoPortNotify_Release(p)                 (p)->Release()
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(a)
#endif

#endif

/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTNOTIFY
 */
typedef struct _DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;	// Timestamp in the event notification
    LONG lField;                        // 0 if even, 1 if odd, -1 if unknown
    UINT dwSurfaceIndex;                // Index in the surface chain of the surface that received the sample
    LONG lDone;                         // Call InterlockedIncrement on this when done with sample
} DDVIDEOPORTNOTIFY;


/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag to disable the VBI/video-only check
 */
#define DDVPFORMAT_NOFAIL			0x08000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag indicating interface is for the IDirectDrawVidoePortNotify object
 */
#define DDVPCREATE_NOTIFY			0x80000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\edevctrl.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    EDevCtrl.h

Abstract:

    This header contain structures and peroperty sets for 
    interfacing to an external device, like a DV.
    The code is modeled after DirectShow's Vcrctrl Sample 
    (VCR Control Filter). It contain IAMExtDevice, 
    IAMExtTransport, and IAMTimecodeReader interfaces, and 
    a new interface IAMAdvancedAVControl() is added
    for additional advanced device controls.

    Note:  (From DShow DDK)
        The VCR control sample filter, Vcrctrl, is a simple 
        implementation of the external device control interfaces 
        that DirectShow provides. Vcrctrl provides basic transport 
        control and SMPTE timecode-reading capabilities for certain 
        Betacam and SVHS videocassette recorders with RS-422 or RS-232 
        serial interfaces (see source code for specific machine types 
        supported).

    Note:  some methods in IAM* interfaces may not be 
           used and will return not implemented.           

Created:

    September 23, 1998    

    Yee J. Wu


Revision:

   0.6

--*/

#ifndef __EDevCtrl__
#define __EDevCtrl__

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
   struct {
	 WORD   wFrameRate;
	 WORD   wFrameFract;
	 DWORD  dwFrames;
	 };
   DWORDLONG  qw;
   } TIMECODE;



typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE
    {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
    }	TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

// Device Capabilities
typedef struct tagDEVCAPS{
    long CanRecord;
    long CanRecordStrobe;
    long HasAudio;
    long HasVideo;
    long UsesFiles;
    long CanSave;
    long DeviceType;
    long TCRead;
    long TCWrite;
    long CTLRead;
    long IndexRead;
    long Preroll;
    long Postroll;
    long SyncAcc;
    long NormRate;
    long CanPreview;
    long CanMonitorSrc;
    long CanTest;
    long VideoIn;
    long AudioIn;
    long Calibrate;
    long SeekType;
    long SimulatedHardware;        // private
} DEVCAPS, *PDEVCAPS;

// transport status
typedef struct tagTRANSPORTSTATUS{
    long Mode;
    long LastError;
    long RecordInhibit;
    long ServoLock;
    long MediaPresent;
    long MediaLength;
    long MediaSize;
    long MediaTrackCount;
    long MediaTrackLength;
    long MediaTrackSide;
    long MediaType;
    long LinkMode;
    long NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

// transport basic parameters
typedef struct tagTRANSPORTBASICPARMS{
    long TimeFormat;
    long TimeReference;
    long Superimpose;
    long EndStopAction;
    long RecordFormat;
    long StepFrames;
    long SetpField;
    long Preroll;
    long RecPreroll;
    long Postroll;
    long EditDelay;
    long PlayTCDelay;
    long RecTCDelay;
    long EditField;
    long FrameServo;
    long ColorFrameServo;
    long ServoRef;
    long WarnGenlock;
    long SetTracking;
    TCHAR VolumeName[40];
    long Ballistic[20];
    long Speed;
    long CounterFormat;
    long TunerChannel;
    long TunerNumber;
    long TimerEvent;
    long TimerStartDay;
    long TimerStartTime;
    long TimerStopDay;
    long TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

// transport video parameters
typedef struct tagTRANSPORTVIDEOPARMS{
    long OutputMode;
    long Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

// transport audio parameters
typedef struct tagTRANSPORTAUDIOPARMS{
    long EnableOutput;
    long EnableRecord;
    long EnableSelsync;
    long Input;
    long MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;


// low level machine status structure filled in after
// REQUEST_STATUS command from above.  This structure would
// grow in a full implementation
typedef struct tagVCRSTATUS{
	BOOL bCassetteOut;	// OATRUE means no cassette
	BOOL bLocal;		// OATRUE means front panel switch in local
} VCRSTATUS;

typedef VCRSTATUS far *PVCRSTATUS;



//---------------------------------------------------------
// STATIC_PROPSETID_VIDCAP_EXT_DEVICE
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)


// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_EXTDEVICE_ID,           // ID (such as Symbolic Lin) that can uniquely idenfy this device
    KSPROPERTY_EXTDEVICE_VERSION,      // Device model number and version (such AV/C VCR Subunit Spec. 2.01)
    KSPROPERTY_EXTDEVICE_POWER_STATE,  // Return current device power state.
    KSPROPERTY_EXTDEVICE_PORT,         // Can use this to return DEV_PORT_1394
    KSPROPERTY_EXTDEVICE_CAPABILITIES, // Device specific capabilities  

} KSPROPERTY_EXTDEVICE;


typedef struct {
    KSPROPERTY Property;
 
    union {
        // Client is responsible for allocating this.
        DEVCAPS  Capabilities;          // May need to expand on the existing structure
		ULONG    DevPort;               // 
        ULONG    PowerState;            // On, off standby
        WCHAR    pawchString[MAX_PATH]; // ID and version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;

} KSPROPERTY_EXTDEVICE_S, *PKSPROPERTY_EXTDEVICE_S;


//---------------------------------------------------------
// STATIC_PROPSETID_VIDCAP_EXT_TRANSPORT
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)



// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_EXTXPORT_CAPABILITIES,       // Transport specific capability 
    KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // MPEG, D-VHS, Analog VHS etc. 
    KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // MPEG, D-VHS, Analog VHS etc. 
    KSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // Eject, open tray, close tray
    KSPROPERTY_EXTXPORT_MEDIUM_INFO,        // cassettte_type and tape_grade_and_write_protect    
    KSPROPERTY_EXTXPORT_STATE,              // Get/Set transport mode and state
    KSPROPERTY_EXTXPORT_STATE_NOTIFY,       // NOTIFY: Mode + State (Table 4-8) 
    KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // Request VCR subunit to search for a specific timecode on the medium
    KSPROPERTY_EXTXPORT_ATN_SEARCH,         // Request VCR subunit to search for a specific ATN on the medium
    KSPROPERTY_EXTXPORT_RTC_SEARCH,         // Request VCR subunit to search for a specific RelativeTimeCounter on the medium

    //
    // Implemented for testing purpose
    // Will remove this later...
    //
    KSPROPERTY_RAW_AVC_CMD,                 // Send/Rcv raw AVC commnad with a FCP packet.

} KSPROPERTY_EXTXPORT;

typedef struct {
    BOOL  MediaPresent;      // TRUE/FALSE
    ULONG MediaType;         // DVCR standard, small, medium; VHS; VHS-C; unknown
    BOOL  RecordInhibit;     // TRUE/FALSE
} MEDIUM_INFO, *PMEDIUM_INFO;


typedef struct {
    ULONG Mode;              // LOAD MEDIUM, RECORD, PLAY or WIND
    ULONG State;             // Vary depend on mode (Table 4-8) 
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    KSPROPERTY Property;

    union {    
        ULONG      Capabilities;     // May need to expand on the existing structure
        ULONG      SignalMode;       // MPEG, D-VHS, Analog VHS etc.
        ULONG      LoadMedium;       // Eject, open tray, close tray
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;

        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;       // hour:minute:second:frame
        DWORD dwAbsTrackNumber; // absolute track number


       //
       // Implemented for testing purpose
       // Will remove this later or will keep this for 
       // packet specific command.
       //
       struct {
           ULONG   PayloadSize;
           BYTE    Payload[512];  // This is only for testing sending AVC command from User mode.
       } RawAVC;

     } u;
     
} KSPROPERTY_EXTXPORT_S, *PKSPROPERTY_EXTXPORT_S;



//---------------------------------------------------------
// PROPSETID_TIMECODE
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)


// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_TIMECODE_READER,  // Timecode for the current medium position
    KSPROPERTY_ATN_READER,       // Absolute track number the current medium position
    KSPROPERTY_RTC_READER,       // Relative time counter for the current medium position

} KSPROPERTY_TIMECODE;


typedef struct {
    KSPROPERTY Property;

    TIMECODE_SAMPLE TimecodeSamp;
     
} KSPROPERTY_TIMECODE_S, *PKSPROPERTY_TIMECODE_S;



//---------------------------------------------------------
//  External Device Command event notification
//---------------------------------------------------------

#define STATIC_KSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", KSEVENTSETID_EXTDEV_Command);
#define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)

typedef enum {
    KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
    KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
    KSEVENT_EXTDEV_COMMAND_BUSRESET,
    KSEVENT_EXTDEV_TIMECODE_UPDATE,
    KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,    // Notify mode of operation change (VCR,OFF,Camera)
    KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,   // XPrt state change
    KSEVENT_EXTDEV_NOTIFY_REMOVAL,           // Notify device removal
    KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE,     // Notify medium (tape) is removed or added

} KSEVENT_DEVCMD;


#endif // __EDevCTrl__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\mmddkp.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif

#ifdef  NOMIDIDEV       /* ;Internal */
#define MMNOMIDIDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOWAVEDEV       /* ;Internal */
#define MMNOWAVEDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOAUXDEV        /* ;Internal */
#define MMNOAUXDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTIMERDEV      /* ;Internal */
#define MMNOTIMERDEV        /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOJOYDEV        /* ;Internal */
#define MMNOJOYDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOMCIDEV        /* ;Internal */
#define MMNOMCIDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTASKDEV       /* ;Internal */
#define MMNOTASKDEV     /* ;Internal */
#endif              /* ;Internal */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal */
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal */
#define DRVM_MAPPER_CONSOLEVOICECOM_GET           (DRVM_MAPPER+23)
#define DRVM_MAPPER_CONSOLEVOICECOM_SET           (DRVM_MAPPER+24) /* ;Internal */

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal */
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal */
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal */
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal */
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal */
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal */
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#define DRV_QUERYSTRINGID            (DRV_RESERVED + 14)
#define DRV_QUERYSTRINGIDSIZE        (DRV_RESERVED + 15)
#define DRV_QUERYIDFROMSTRINGID      (DRV_RESERVED + 16)

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
#ifdef  BUILDDLL                                            /* ;Internal */
typedef VOID (FAR PASCAL TASKCALLBACK) (DWORD_PTR dwInst);  /* ;Internal */
#else                                                       /* ;Internal */
typedef VOID (TASKCALLBACK) (DWORD_PTR dwInst);
#endif  // ifdef BUILDDLL                                   /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\mmcommon.h ===
/***************************************************************************
 *  mmcommon.h
 *
 *  Copyright (c) Microsoft Corporation 1996. All rights reserved
 *
 *  private include file for definitions common to the NT project
 *
 *  History
 *
 *  16  Feb 96 - NoelC created
 *
 ***************************************************************************/

/***************************************************************************


 Common definitions needed for wx86


 ***************************************************************************/

#define WOD_MESSAGE          "wodMessage"
#define WID_MESSAGE          "widMessage"
#define MOD_MESSAGE          "modMessage"
#define MID_MESSAGE          "midMessage"
#define AUX_MESSAGE          "auxMessage"


#define MMDRVI_TYPE          0x000F  /* low 4 bits give driver type */
#define MMDRVI_WAVEIN        0x0001
#define MMDRVI_WAVEOUT       0x0002
#define MMDRVI_MIDIIN        0x0003
#define MMDRVI_MIDIOUT       0x0004
#define MMDRVI_AUX           0x0005
#define MMDRVI_MIDISTRM      0x0006

#define MMDRVI_MAPPER        0x8000  /* install this driver as the mapper */
#define MMDRVI_HDRV          0x4000  /* hDriver is a installable driver   */
#define MMDRVI_REMOVE        0x2000  /* remove the driver                 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\mmdet.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmdet.h

Abstract:
    MM detection module header, borrowed from KyleB's net detection base

Author:

    bryanw 18-Oct-1997

--*/


#ifndef _MMDET_H_
#define _MMDET_H_

#define DEVIDSTR_SB                 TEXT( "*PNPb000" ) // Sound Blaster wave
#define DEVIDSTR_SB2                TEXT( "*PNPb001" ) // Sound Blaster 2 wave
#define DEVIDSTR_SBPRO              TEXT( "*PNPb002" ) // Sound Blaster Pro wave
#define DEVIDSTR_SB16               TEXT( "*PNPb003" ) // Sound Blaster 16 wave
#define DEVIDSTR_MV                 TEXT( "*PNPb004" ) // Media Vision Thunder Board
#define DEVIDSTR_ADLIB              TEXT( "*PNPb005" ) // Adlib
#define DEVIDSTR_MPU401             TEXT( "*PNPb006" ) // MPU-401 midi
#define DEVIDSTR_SNDSYS             TEXT( "*PNPb007" ) // Windows Sound System
#define DEVIDSTR_CPQBA              TEXT( "*PNPb008" ) // Compaq Business Audio
                                                     
#define DEVIDSTR_PAS16              TEXT( "*PNPb00d" ) // PAS-16 variations
#define DEVIDSTR_PAS16_WITH_SCSI    TEXT( "*PNPb00e" ) // PAS-16 + SCSI
#define DEVIDSTR_PAS_ORIGINAL       TEXT( "*PNPb018" ) // MV Pro Audio Spectrum (original)
#define DEVIDSTR_PAS_PLUS           TEXT( "*PNPb019" ) // PAS Plus variations

#define DEVIDSTR_OPTI82C928         TEXT( "*PNPb01a" )
#define DEVIDSTR_OPTI82C929         TEXT( "*PNPb01b" )
#define DEVIDSTR_OPTI82C930         TEXT( "*PNPb01c" )
                                                     
#define DEVIDSTR_PA3D               TEXT( "*PNPb00b" ) // Media Vision ProAudio3D
#define DEVIDSTR_MQMPU401           TEXT( "*PNPb00c" ) // MusicQuest MPU-401 midi
#define DEVIDSTR_JAZZ               TEXT( "*PNPb00f" ) // Media Vision OEM Jazz-16
#define DEVIDSTR_VXP500             TEXT( "*PNPb010" ) // Auravision VxP500 based video cap.
#define DEVIDSTR_ADLIBOPL3          TEXT( "*PNPb020" ) // Adlib OPL3 midi
#define DEVIDSTR_GAMEPORT           TEXT( "*PNPb02f" ) // Game port

#define DEVIDSTR_AZTECH_PRO16           TEXT( "*AZT1608" )
#define DEVIDSTR_AZTECH_NOVA16          TEXT( "*AZT1605" )
#define DEVIDSTR_AZTECH_WASHINGTON16    TEXT( "*AZT2316" )
                                                        
#define DEVIDSTR_ESS4881                TEXT( "*ESS4881" )
#define DEVIDSTR_ESS6881                TEXT( "*ESS6881" )
#define DEVIDSTR_ESS1481                TEXT( "*ESS1481" )
#define DEVIDSTR_ESS1681                TEXT( "*ESS1681" )
#define DEVIDSTR_ESS1781                TEXT( "*ESS1781" )
#define DEVIDSTR_ESS1881                TEXT( "*ESS1881" )

ULONG
WINAPI
MmDetectAdapters(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );
    
typedef
ULONG
(*PFNMMDETECTADAPTERS)(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );

#if (!defined( _NTDDK_ ) && !defined( NT_INCLUDED ))
typedef ULONG INTERFACE_TYPE,*PINTERFACE_TYPE;
#endif
typedef
VOID 
(*PFNMMDETECTIRQCALLBACK)(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG Context
    );

USHORT
WINAPI
MmDetectIRQ( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN USHORT InterruptMask,
    IN PFNMMDETECTIRQCALLBACK SetInterrupt,
    IN PFNMMDETECTIRQCALLBACK ClearInterrupt,
    IN ULONG Context 
    );
    
#if (defined( _CFGMGR32_H_ ))
ULONG
WINAPI
MmRegisterDetectedDevice( 
    IN HDEVINFO DeviceInfoSet,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PTSTR DeviceId,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
VOID
WINAPI    
MmAvoidDetectedResources( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
#endif    

#endif // _MMDET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\synth.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    synth.h

Abstract:

    This include file defines constants and types for
    the Microsoft midi synthesizer driver

    This header file is shared between the low level driver and the
    kernel mode driver.

Author:

    Robin Speed (RobinSp) 20-Oct-92

Revision History:

--*/

#define STR_DRIVERNAME L"synth"
#define STR_MV_DRIVERNAME L"mvopl3"
#define STR_OPL3_DEVICENAME L"\\Device\\opl3.mid"
#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 *  Why on earth isn't there a type for sharing short data?
 */

 typedef struct {
     unsigned short IoPort;
     unsigned short PortData;
 } SYNTH_DATA, *PSYNTH_DATA;

/* positions within FM */
#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/*
**  Special IOCTL
*/

#define IOCTL_MIDI_SET_OPL3_MODE CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x000A, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\segment.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-1999.
//
//--------------------------------------------------------------------------;
//
// segment.cpp : implementation of various graph segment extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <bdamedia.h>

#include "devices.h"
#include "seg.h"

#include "closedcaptioning.h"
#include "MSViddataservices.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidClosedCaptioning, CClosedCaptioning)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServices, CDataServices)

// VWSegment
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = &std_arity1_member(&IMSVidGraphSegment::EnumFilters);
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#else
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = NULL;
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#endif

namespace MSVideoControl {
// work around compiler bug as per above description
void CtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    VWGraphSegment::Fetch = new std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT>(&IMSVidGraphSegment::EnumFilters);
}

// work around compiler bug as per above description
void DtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    delete VWGraphSegment::Fetch;
}

VWSegmentContainer VWGraphSegment::Container(void) {
    VWSegmentContainer g;
    HRESULT hr = (*this)->get_Container(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

MSVidSegmentType VWGraphSegment::Type(void) {
    MSVidSegmentType t;
    HRESULT hr = (*this)->get_Type(&t);
    ASSERT(SUCCEEDED(hr));
    return t;
}

DSGraph VWGraphSegment::Graph(void) {
    DSGraph g;
    HRESULT hr = (Container())->get_Graph(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::Category(void) {
    GUID2 g;
    HRESULT hr = (*this)->get_Category(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::ClassID(void) {
    GUID2 g;
    HRESULT hr = (*this)->GetClassID(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - segment.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\propertyhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#pragma once
#include "ocidl.h"

// Paste these declarations into your class methods to implement the interfaces.  Replace DSFXZZZ with the name of your struct.
// These assume that you implement GetAllParameters/SetAllParameters interfaces with a struct and that you have a public m_fDirty
// member variable that you use to hold the dirty state of your object for persistence.

/*
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropZZZ, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXZZZ(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXZZZ(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXZZZ); return S_OK; }
*/

// Load, Save, and GetPages are actually implemented in the following functions.

namespace PropertyHelp
{
    HRESULT GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages);

    template<class O, class S> HRESULT Load(O *pt_object, S &t_struct, IStream *pStm)
    {
        ULONG cbRead;
        HRESULT hr;

        if (pStm==NULL)
        	return E_POINTER;

        hr = pStm->Read(&t_struct, sizeof(t_struct), &cbRead);
        if (hr != S_OK || cbRead < sizeof(t_struct))
            return E_FAIL;

        hr = pt_object->SetAllParameters(&t_struct);
        pt_object->m_fDirty = false;
        return hr;
    }

    template<class O, class S> HRESULT Save(O *pt_object, S &t_struct, IStream *pStm, BOOL fClearDirty)
    {
        HRESULT hr; 

        if (pStm==NULL)
        	return E_POINTER;

        hr = pt_object->GetAllParameters(&t_struct);
        if (FAILED(hr))
            return hr;

        ULONG cbWritten;
        hr = pStm->Write(&t_struct, sizeof(t_struct), &cbWritten);
        if (hr != S_OK || cbWritten < sizeof(t_struct))
            return E_FAIL;

        if (fClearDirty)
            pt_object->m_fDirty = false;
        return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\mmsysp.h ===
/*==========================================================================
 *
 *  mmsysp.h -- Internal include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */
#ifndef _INC_MMSYSP
#define _INC_MMSYSP
#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */
#ifdef _WIN32
#ifndef _WINMM_
#define WINMMAPI        DECLSPEC_IMPORT
#else
#define WINMMAPI
#endif
#define _loadds
#define _huge
#endif
#ifdef  BUILDDLL
#undef  WINAPI
#define WINAPI            _loadds FAR PASCAL
#undef  CALLBACK
#define CALLBACK          _loadds FAR PASCAL
#endif  /* ifdef BUILDDLL */
/* Multimedia messages */
#define WM_MM_RESERVED_FIRST    0x03A0
#define WM_MM_RESERVED_LAST     0x03DF
/* 0x3BA is open */
#define MM_MCISYSTEM_STRING 0x3CA
#if(WINVER <  0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for MEVT_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_MOREDATA      0x3CC          /* MIM_DONE w/ pending events */

/* 0x3CF is open */

#endif /* WINVER <  0x0400 */
/* 3D8 - 3DF are reserved for Haiku */

#ifdef _WIN32
#define WINMMDEVICECHANGEMSGSTRINGA "winmm_devicechange"
#define WINMMDEVICECHANGEMSGSTRINGW L"winmm_devicechange"
#ifdef UNICODE
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGW
#else
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGA
#endif
#else
#define WINMMDEVICECHANGEMSGSTRING "winmm_devicechange"
#endif
#ifndef MMNODRV
#endif  /* ifndef MMNODRV */
#define CALLBACK_THUNK      0x00040000l    /* dwCallback is a Ring0 Thread Handle */
#define CALLBACK_EVENT16    0x00060000l    /* dwCallback is an EVENT under Win16*/

#ifdef  BUILDDLL
typedef void (FAR PASCAL DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#else   /* ifdef BUILDDLL */
#endif  /* ifdef BUILDDLL */
#ifndef MMNOMMSYSTEM
WINMMAPI UINT WINAPI mmsystemGetVersion(void);
void FAR CDECL _loadds OutputDebugStrF(LPCSTR pszFormat, ...);
void WINAPI winmmUntileBuffer(DWORD dwTilingInfo);
DWORD WINAPI winmmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);
BOOL WINAPI mmShowMMCPLPropertySheet(HWND hWnd, LPSTR szPropSheetID, LPSTR szTabName, LPSTR szCaption);
#endif  /* ifndef MMNOMMSYSTEM */
#ifndef MMNOSOUND
#if(WINVER <  0x0400)
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */
#endif /* WINVER <  0x0400 */
#define SND_LOPRIORITY  0x10000000L /* low priority sound */
#define SND_EVENTTIME   0x20000000L /* dangerous event time */
#define SND_VALIDFLAGS  0x001720DF  // Set of valid flag bits.  Anything outside
                                    // this range will raise an error
#define SND_SNDPLAYSOUNDF_VALID 0x20FF
#define SND_PLAYSOUNDF_VALID    0x301720DFL
#endif  /* ifndef MMNOSOUND */
#ifndef MMNOWAVE
#if(WINVER <  0x0400)
#define  WAVE_MAPPED               0x0004
#define  WAVE_FORMAT_DIRECT        0x0008
#define  WAVE_FORMAT_DIRECT_QUERY  (WAVE_FORMAT_QUERY | WAVE_FORMAT_DIRECT)
#endif /* WINVER <  0x0400 */
#ifndef _WIN32
#define  WAVE_SHARED               0x8000
#endif
#define  WAVE_VALID                0x800F
#define WHDR_MAPPED     0x00001000  /* thunked header */
#define WHDR_VALID      0x0000101F  /* valid flags */
#endif  /* ifndef MMNOWAVE */
#ifndef MMNOMIDI
#if(WINVER <  0x0400)
#define MIM_MOREDATA      MM_MIM_MOREDATA
#define MOM_POSITIONCB    MM_MOM_POSITIONCB
#endif /* WINVER <  0x0400 */
#if(WINVER <  0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_STATUS      0x00000020L
#endif /* WINVER <  0x0400 */
#define MIDI_IO_CONTROL     0x00000008L
#define MIDI_IO_INPUT       0x00000010L  /*future*/
#define MIDI_IO_OWNED       0x00004000L
#define MIDI_IO_SHARED      0x00008000L
#define MIDI_I_VALID        0xC027
#define MIDI_O_VALID        0xC00E
#define MIDI_CACHE_VALID    (MIDI_CACHE_ALL | MIDI_CACHE_BESTFIT | MIDI_CACHE_QUERY | MIDI_UNCACHE)
#if(WINVER <  0x0400)
#define MIDICAPS_STREAM          0x0008  /* driver supports midiStreamOut directly */
#endif /* WINVER <  0x0400 */
/* 3.1 style MIDIHDR for parameter validation */
typedef struct midihdr31_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD_PTR   dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD_PTR   reserved;             /* reserved for driver */
} MIDIHDR31, *PMIDIHDR31, NEAR *NPMIDIHDR31, FAR *LPMIDIHDR31;
#if(WINVER <  0x0400)
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
    DWORD       dwParms[1];           /* Parameters if this is a long event */
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */
} MIDISTRMBUFFVER;
#endif /* WINVER <  0x0400 */
#define MHDR_SENDING    0x00000020
#define MHDR_MAPPED     0x00001000       /* thunked header */
#define MHDR_SHADOWHDR  0x00002000       /* MIDIHDR is 16-bit shadow */
#define MHDR_VALID      0x0000302F       /* valid flags */
/*#define MHDR_VALID      0xFFFF000F       /* valid flags */

#define MHDR_SAVE       0x00003000       /* Save these flags */
                                         /* past driver calls */
#if(WINVER <  0x0400)
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */

#define MEVT_F_SHORT        0x00000000L
#define MEVT_F_LONG         0x80000000L
#define MEVT_F_CALLBACK     0x40000000L

#define MEVT_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define MEVT_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define MEVT_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define MEVT_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define MEVT_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

#define MEVT_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define MEVT_COMMENT        ((BYTE)0x82)    /* parm = comment data                 */
#define MEVT_VERSION        ((BYTE)0x84)    /* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */

#define MIDISTRM_ERROR      (-2)

/* */
/* Structures and defines for midiStreamProperty */
/* */
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L

/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

#endif /* WINVER <  0x0400 */
#define MIDIPROP_PROPVAL    0x3FFFFFFFL
#if(WINVER <  0x0400)
WINMMAPI MMRESULT WINAPI midiStreamOpen( OUT LPHMIDISTRM phms, IN LPUINT puDeviceID, IN DWORD cMidi, IN DWORD_PTR dwCallback, IN DWORD_PTR dwInstance, IN DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiStreamClose( IN HMIDISTRM hms);

WINMMAPI MMRESULT WINAPI midiStreamProperty( IN HMIDISTRM hms, OUT LPBYTE lppropdata, IN DWORD dwProperty);
WINMMAPI MMRESULT WINAPI midiStreamPosition( IN HMIDISTRM hms, OUT LPMMTIME lpmmt, IN UINT cbmmt);

WINMMAPI MMRESULT WINAPI midiStreamOut( IN HMIDISTRM hms, IN LPMIDIHDR pmh, IN UINT cbmh);
WINMMAPI MMRESULT WINAPI midiStreamPause( IN HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamRestart( IN HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamStop( IN HMIDISTRM hms);

#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiConnect( IN HMIDI hmi, IN HMIDIOUT hmo, IN LPVOID pReserved);
WINMMAPI MMRESULT WINAPI midiDisconnect( IN HMIDI hmi, IN HMIDIOUT hmo, IN LPVOID pReserved);
#endif
#endif /* WINVER <  0x0400 */
#endif  /* ifndef MMNOMIDI */
#ifndef MMNOAUX
#endif  /* ifndef MMNOAUX */
#ifndef MMNOMIXER
#define MIXER_OBJECTF_TYPEMASK  0xF0000000L
#define MIXERCAPS_SUPPORTF_xxx          0x00000000L
#define MIXER_OPENF_VALID       (MIXER_OBJECTF_TYPEMASK | CALLBACK_TYPEMASK)
#define MIXER_GETLINEINFOF_VALID            (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINEINFOF_QUERYMASK)
#define MIXER_GETIDF_VALID      (MIXER_OBJECTF_TYPEMASK)
#define MIXERCONTROL_CONTROLF_VALID     0x80000003L
#define MIXER_GETLINECONTROLSF_VALID    (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINECONTROLSF_QUERYMASK)
#define MIXER_GETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_GETCONTROLDETAILSF_QUERYMASK)
#define MIXER_SETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_SETCONTROLDETAILSF_QUERYMASK)
#endif /* ifndef MMNOMIXER */
#ifndef MMNOTIMER
#ifdef  BUILDDLL
typedef void (FAR PASCAL TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#else   /* ifdef BUILDDLL */
#endif  /* ifdef BUILDDLL */
#define TIME_CALLBACK_TYPEMASK      0x00F0
#endif  /* ifndef MMNOTIMER */
#ifndef MMNOJOY
#if(WINVER <  0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;                /* size of structure */
    DWORD dwFlags;               /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;                /* rudder/4th axis position */
    DWORD dwUpos;                /* 5th axis position */
    DWORD dwVpos;                /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;           /* reserved for communication between winmm & driver */
    DWORD dwReserved2;           /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER <  0x0400 */
#if(WINVER <  0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx( IN UINT uJoyID, OUT LPJOYINFOEX pji);
#endif /* WINVER <  0x0400 */
UINT WINAPI joySetCalibration(UINT uJoyID, LPUINT puXbase,
              LPUINT puXdelta, LPUINT puYbase, LPUINT puYdelta,
              LPUINT puZbase, LPUINT puZdelta);
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyConfigChanged( IN DWORD dwFlags );
#endif
#endif  /* ifndef MMNOJOY */
#ifndef MMNOMMIO
#define MMIO_OPEN_VALID 0x0003FFFF      /* valid flags for mmioOpen */
#define MMIO_FLUSH_VALID MMIO_EMPTYBUF  /* valid flags for mmioFlush */
#define MMIO_ADVANCE_VALID (MMIO_WRITE | MMIO_READ)     /* valid flags for mmioAdvance */
#define MMIO_FOURCC_VALID MMIO_TOUPPER  /* valid flags for mmioStringToFOURCC */
#define MMIO_DESCEND_VALID (MMIO_FINDCHUNK | MMIO_FINDRIFF | MMIO_FINDLIST)
#define MMIO_CREATE_VALID (MMIO_CREATERIFF | MMIO_CREATELIST)

#define MMIO_WIN31_TASK 0x80000000
#define MMIO_VALIDPROC      0x10070000  /* valid for mmioInstallIOProc */
#endif  /* ifndef MMNOMMIO */
#ifndef MMNOMCI
#define MCI_SOUND                       0x0812
#define MCI_WIN32CLIENT                 0x0857
/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L


/* parameter block for MCI_SOUND command message */
#ifdef _WIN32

typedef struct tagMCI_SOUND_PARMSA {
    DWORD_PTR   dwCallback;
    LPCSTR      lpstrSoundName;
} MCI_SOUND_PARMSA, *PMCI_SOUND_PARMSA, *LPMCI_SOUND_PARMSA;
typedef struct tagMCI_SOUND_PARMSW {
    DWORD_PTR   dwCallback;
    LPCWSTR     lpstrSoundName;
} MCI_SOUND_PARMSW, *PMCI_SOUND_PARMSW, *LPMCI_SOUND_PARMSW;
#ifdef UNICODE
typedef MCI_SOUND_PARMSW MCI_SOUND_PARMS;
typedef PMCI_SOUND_PARMSW PMCI_SOUND_PARMS;
typedef LPMCI_SOUND_PARMSW LPMCI_SOUND_PARMS;
#else
typedef MCI_SOUND_PARMSA MCI_SOUND_PARMS;
typedef PMCI_SOUND_PARMSA PMCI_SOUND_PARMS;
typedef LPMCI_SOUND_PARMSA LPMCI_SOUND_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;
#endif

#endif  /* ifndef MMNOMCI */
/****************************************************************************

                        audiosrv MME PNP definitions

****************************************************************************/
#define MMDEVICEINFO_REMOVED 0x00000001

#define PAD_POINTER(p)          (PVOID)((((DWORD_PTR)(p))+7)&(~0x7))

typedef struct _MMDEVICEINTERFACEINFO {
    LONG            cPnpEvents;
    DWORD           fdwInfo;
    DWORD           SetupPreferredAudioCount;
    WCHAR           szName[1];
} MMDEVICEINTERFACEINFO, *PMMDEVICEINTERFACEINFO;

//  Note:  This structure MMNPNPINFO is used with a global file mapping, and
//         it is also used by DirectSound.
//
//         Don't modify unless absolutely necessary!!!

typedef struct _MMPNPINFO {
    DWORD                   cbSize;
    LONG                    cPnpEvents;
    LONG                    cPreferredDeviceChanges;
    LONG                    cDevInterfaces;
    HWND                    hwndNotify;
/*  MMDEVINTERFACEINFO      DevInfo[0]; */
} MMPNPINFO, *PMMPNPINFO;

#ifdef _WIN32
#define MMGLOBALPNPINFONAMEA "Global\\mmGlobalPnpInfo"
#define MMGLOBALPNPINFONAMEW L"Global\\mmGlobalPnpInfo"
#ifdef UNICODE
#define MMGLOBALPNPINFONAME MMGLOBALPNPINFONAMEW
#else
#define MMGLOBALPNPINFONAME MMGLOBALPNPINFONAMEA
#endif
#else
#define MMGLOBALPNPINFONAME "Global\\mmGlobalPnpInfo"
#endif


/****************************************************************************

                        GFX support

    A series of functions to support the GFX features of the control panel

****************************************************************************/

#define GFXTYPE_INVALID          0
#define GFXTYPE_RENDER           1
#define GFXTYPE_CAPTURE          2
#define GFXTYPE_RENDERCAPTURE    3

#define GFX_MAXORDER             (0x1000 - 1)

typedef struct _DEVICEINTERFACELIST
{
    LONG Count;
    PWSTR DeviceInterface[1];
} DEVICEINTERFACELIST, *PDEVICEINTERFACELIST;


WINMMAPI
LONG
WINAPI
gfxCreateZoneFactoriesList
(
    OUT PDEVICEINTERFACELIST *ppDeviceInterfaceList
);


WINMMAPI
LONG
WINAPI
gfxCreateGfxFactoriesList
(
     IN PCWSTR ZoneFactoryDi,
     OUT PDEVICEINTERFACELIST *ppDeviceInterfaceList
);


WINMMAPI
LONG
WINAPI
gfxDestroyDeviceInterfaceList
(
    IN PDEVICEINTERFACELIST pDiList
);


typedef LONG (CALLBACK* GFXENUMCALLBACK)(PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, ULONG Type, ULONG Order);

WINMMAPI
LONG
WINAPI
gfxEnumerateGfxs
(
    IN PCWSTR pstrZoneDeviceInterface,
    IN GFXENUMCALLBACK pGfxEnumCallback,
    IN PVOID Context
);


WINMMAPI
LONG
WINAPI
gfxRemoveGfx
(
    IN DWORD Id
);


WINMMAPI
LONG
WINAPI
gfxAddGfx
(
    IN PCWSTR ZoneFactoryDi,
    IN PCWSTR GfxFactoryDi,
    IN ULONG Type,
    IN ULONG Order,
    OUT PDWORD pNewId
);


WINMMAPI
LONG
WINAPI
gfxModifyGfx
(
    IN DWORD Id,
    IN ULONG Order
);

WINMMAPI
LONG
WINAPI
gfxOpenGfx
(
    IN DWORD dwGfxId,
    OUT HANDLE *pFileHandle
);

typedef struct _GFXREMOVEREQUEST {
    DWORD IdToRemove;
    LONG Error;
} GFXREMOVEREQUEST, *PGFXREMOVEREQUEST;


typedef struct _GFXMODIFYREQUEST {
    DWORD IdToModify;
    ULONG NewOrder;
    LONG Error;
} GFXMODIFYREQUEST, *PGFXMODIFYREQUEST;


typedef struct _GFXADDREQUEST {
    PWSTR ZoneFactoryDi;
    PWSTR GfxFactoryDi;
    ULONG Type;
    ULONG Order;
    DWORD NewId;
    LONG Error;
} GFXADDREQUEST, *PGFXADDREQUEST;


WINMMAPI
LONG
WINAPI
gfxBatchChange
(
    PGFXREMOVEREQUEST paGfxRemoveRequests,
    ULONG cGfxRemoveRequests,
    PGFXMODIFYREQUEST paGfxModifyRequests,
    ULONG cGfxModifyRequests,
    PGFXADDREQUEST paGfxAddRequests,
    ULONG cGfxAddRequests
);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif
#endif  /* _INC_MMSYSP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\trace.cpp ===
//
// trace.cpp -- global vars for trace.h
// copyright (c) Microsoft Corp. 1998
//
// this file should be include in stdafx.cpp

#ifdef DEBUG
#include "tstring.h"
#include <ostream>
#include <fstream>
#include "trace.h"
#include <process.h>


DWORD dwTraceLevel = 0;  // default to trace_error
tostream* tdbgout;
DWORD dwTraceIndent = 0;

typedef basic_oftstream<TCHAR> tfstream;

void DebugInit(LPCTSTR pszModule) {
        if (!pszModule) {
                dwTraceLevel = TRACE_ERROR;
        tdbgout = new TdbgStream;
                return;
        }
        CRegKey c;
        TCHAR szLogFile[MAX_PATH + 1];
        szLogFile[0] = 0;
        CString keyname(_T("SOFTWARE\\Debug\\"));
        keyname += pszModule;
        DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
        if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwTraceLevel, _T("Trace"));
                if (rc != ERROR_SUCCESS) {
                        dwTraceLevel = 1;
                }
                DWORD len = sizeof(szLogFile);
                rc = c.QueryValue(szLogFile, _T("LogFile"), &len);
                if (rc != ERROR_SUCCESS) {
                        szLogFile[0] = 0;
                }
                if(_tcslen(szLogFile)){
                    TCHAR szPID[MAX_PATH+1];
                    _itot(_getpid(), szPID, 10);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), szPID);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), _T(".log"));
                }
        }
    if (!_tcslen(szLogFile)) {
        tdbgout = new TdbgStream;
    } else {
        USES_CONVERSION;
        tdbgout = new tfstream(T2CA(szLogFile), std::ios::out);
    }
}

void DebugTerm(void) {
    dbgDump.flush();
    delete tdbgout;
    tdbgout = NULL;
}

#endif

// end of file - trace.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\sndblst.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    sndblst.h

Abstract:

    This include file defines constants and types for
    the Sound blaster card.

	This header file is shared between the low level driver and the
	kernel driver.

Revision History:

--*/

#define SOUND_DEF_DMACHANNEL   1        // DMA channel no
#define SOUND_DEF_DMACHANNEL16 5        // DMA channel no 5
#define SOUND_DEF_INT          7
#define SOUND_DEF_PORT         0x220
#define SOUND_DEF_MPU401_PORT  0x330

#define NUMBER_OF_SOUND_PORTS (0x10)
#define NUMBER_OF_MPU401_PORTS (0x02)

/*
**  Registry value names
*/

#define SOUND_REG_DMACHANNEL16 (L"DmaChannel16")
#define SOUND_REG_MPU401_PORT  (L"MPU401 Port")
#define SOUND_REG_DSP_VERSION  (L"DSP Version")
#define SOUND_REG_REALBUFFERSIZE (L"Actual Dma Buffer Size")

/*
**  Sound blaster midi mappings
*/

#define SNDBLST_MAPPER_OPL3 TEXT("SNDBLST OPL3")
#define SNDBLST_MAPPER_ADLIB TEXT("SNDBLST AD LIB")


/*
**  Registry 'return' codes
*/

#define SOUND_CONFIG_THUNDER             0x80000001
#define SOUND_CONFIG_MPU401_PORT_INUSE   0x80000002
#define SOUND_CONFIG_BAD_MPU401_PORT     0x80000003

/*
**  String ids (strings in sndblst.dll)
*/

#define IDS_AUX_LINE_PNAME                                   100
#define IDS_AUX_CD_PNAME                                     101
#define IDS_SYNTH_PNAME                                      102
#define IDS_WAVEIN_PNAME                                     103
#define IDS_WAVEOUT_PNAME                                    104
#define IDS_MIXER_PNAME                                      105

#define IDS_CONTROL_AGCMIC_LONG_NAME                         106
#define IDS_CONTROL_AGCMIC_SHORT_NAME                        107
#define IDS_CONTROL_METERRECORD_LONG_NAME                    108
#define IDS_CONTROL_METERRECORD_SHORT_NAME                   109
#define IDS_CONTROL_MUTEAUX_LONG_NAME                        110
#define IDS_CONTROL_MUTEAUX_SHORT_NAME                       111
#define IDS_CONTROL_MUTEINTERNAL_LONG_NAME                   112
#define IDS_CONTROL_MUTEINTERNAL_SHORT_NAME                  113
#define IDS_CONTROL_MUTELINEOUT_LONG_NAME                    114
#define IDS_CONTROL_MUTELINEOUT_SHORT_NAME                   115
#define IDS_CONTROL_MUTEMIC_SHORT_NAME                       116
#define IDS_CONTROL_MUTEMIC_LONG_NAME                        117
#define IDS_CONTROL_MUTEMIDIOUT_LONG_NAME                    118
#define IDS_CONTROL_MUTEMIDIOUT_SHORT_NAME                   119
#define IDS_CONTROL_MUTEWAVEOUT_LONG_NAME                    120
#define IDS_CONTROL_MUTEWAVEOUT_SHORT_NAME                   121
#define IDS_CONTROL_MUXLINEOUT_LONG_NAME                     122
#define IDS_CONTROL_MUXLINEOUT_SHORT_NAME                    123
#define IDS_CONTROL_MUXWAVEIN_LONG_NAME                      124
#define IDS_CONTROL_MUXWAVEIN_SHORT_NAME                     125
#define IDS_CONTROL_PEAKVOICEINAUX_LONG_NAME                 126
#define IDS_CONTROL_PEAKVOICEINAUX_SHORT_NAME                127
#define IDS_CONTROL_PEAKVOICEINMIC_LONG_NAME                 128
#define IDS_CONTROL_PEAKVOICEINMIC_SHORT_NAME                129
#define IDS_CONTROL_PEAKWAVEINAUX_LONG_NAME                  130
#define IDS_CONTROL_PEAKWAVEINAUX_SHORT_NAME                 131
#define IDS_CONTROL_PEAKWAVEININTERNAL_LONG_NAME             132
#define IDS_CONTROL_PEAKWAVEININTERNAL_SHORT_NAME            133
#define IDS_CONTROL_PEAKWAVEINMIC_LONG_NAME                  134
#define IDS_CONTROL_PEAKWAVEINMIC_SHORT_NAME                 135
#define IDS_CONTROL_PEAKWAVEOUT_LONG_NAME                    136
#define IDS_CONTROL_PEAKWAVEOUT_SHORT_NAME                   137
#define IDS_CONTROL_VOICEINMUX_LONG_NAME                     138
#define IDS_CONTROL_VOICEINMUX_SHORT_NAME                    139
#define IDS_CONTROL_VOLBASS_LONG_NAME                        140
#define IDS_CONTROL_VOLBASS_SHORT_NAME                       141
#define IDS_CONTROL_VOLLINEOUTAUX_LONG_NAME                  142
#define IDS_CONTROL_VOLLINEOUTAUX_SHORT_NAME                 143
#define IDS_CONTROL_VOLLINEOUTINTERNAL_LONG_NAME             144
#define IDS_CONTROL_VOLLINEOUTINTERNAL_SHORT_NAME            145
#define IDS_CONTROL_VOLLINEOUTMIC_LONG_NAME                  146
#define IDS_CONTROL_VOLLINEOUTMIC_SHORT_NAME                 147
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_LONG_NAME              148
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_SHORT_NAME             149
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_LONG_NAME              150
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_SHORT_NAME             151
#define IDS_CONTROL_VOLLINEOUT_LONG_NAME                     152
#define IDS_CONTROL_VOLLINEOUT_SHORT_NAME                    153
#define IDS_CONTROL_VOLRECORD_LONG_NAME                      154
#define IDS_CONTROL_VOLRECORD_SHORT_NAME                     155
#define IDS_CONTROL_VOLTREBLE_LONG_NAME                      156
#define IDS_CONTROL_VOLTREBLE_SHORT_NAME                     157
#define IDS_CONTROL_VOLVOICEINAUX_LONG_NAME                  158
#define IDS_CONTROL_VOLVOICEINAUX_SHORT_NAME                 159
#define IDS_CONTROL_VOLVOICEINMIC_LONG_NAME                  160
#define IDS_CONTROL_VOLVOICEINMIC_SHORT_NAME                 161
#define IDS_CONTROL_VOLWAVEINAUX_LONG_NAME                   162
#define IDS_CONTROL_VOLWAVEINAUX_SHORT_NAME                  163
#define IDS_CONTROL_VOLWAVEININTERNAL_LONG_NAME              164
#define IDS_CONTROL_VOLWAVEININTERNAL_SHORT_NAME             165
#define IDS_CONTROL_VOLWAVEINMIC_LONG_NAME                   166
#define IDS_CONTROL_VOLWAVEINMIC_SHORT_NAME                  167
#define IDS_CONTROL_VOLWAVEINMIDIOUT_LONG_NAME               168
#define IDS_CONTROL_VOLWAVEINMIDIOUT_SHORT_NAME              169
#define IDS_DESTLINEOUT_LONG_NAME                            170
#define IDS_DESTLINEOUT_SHORT_NAME                           171
#define IDS_DESTVOICEIN_LONG_NAME                            172
#define IDS_DESTVOICEIN_SHORT_NAME                           173
#define IDS_DESTWAVEIN_LONG_NAME                             174
#define IDS_DESTWAVEIN_SHORT_NAME                            175
#define IDS_SRCAUX_LONG_NAME                                 176
#define IDS_SRCAUX_SHORT_NAME                                177
#define IDS_SRCINTERNALCD_LONG_NAME                          178
#define IDS_SRCINTERNALCD_SHORT_NAME                         179
#define IDS_SRCMICOUT_LONG_NAME                              180
#define IDS_SRCMICOUT_SHORT_NAME                             181
#define IDS_SRCMIDIOUT_LONG_NAME                             182
#define IDS_SRCMIDIOUT_SHORT_NAME                            183
#define IDS_SRCWAVEOUT_LONG_NAME                             184
#define IDS_SRCWAVEOUT_SHORT_NAME                            185
#define IDS_CONTROL_MIXERWAVEIN_LONG_NAME                    186
#define IDS_CONTROL_MIXERWAVEIN_SHORT_NAME                   187
#define IDS_CONTROL_VOLGAIN_SHORT_NAME                       188
#define IDS_CONTROL_VOLGAIN_LONG_NAME                        189
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\vjoyd.inc ===
;***************************************************************************
;  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;  PURPOSE.
;  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
;  File: vjoyd.h
;  Content: include file for describing VJoyD mini-driver communications
;*************************************************************************
ifndef WCHAR
endif
ifndef UNICODE_STRING

UNICODE_STRING	STRUC
us_Length	DB	SIZE WORD DUP (?)
us_MaximumLength	DB	SIZE WORD DUP (?)
us_Buffer	DD	?
UNICODE_STRING	ENDS
endif
INCLUDE vjoydapi.INC
Begin_Service_Table VJOYD
;   *  Win95 Gold services
;
    VJOYD_Service   VJOYD_Register_Device_Driver, LOCAL
    VJOYD_Service   VJOYD_GetPosEx_Service, LOCAL
;   *  DInput services (for internal use only)
;
    VJOYD_Service   VJOYD_GetInitParams_Service, LOCAL
    VJOYD_Service   VJOYD_Poll_Service, LOCAL
    VJOYD_Service   VJOYD_Escape_Service, LOCAL
    VJOYD_Service   VJOYD_CtrlMsg_Service, LOCAL
    VJOYD_Service   VJOYD_SetGain_Service, LOCAL
    VJOYD_Service   VJOYD_SendFFCommand_Service, LOCAL
    VJOYD_Service   VJOYD_GetFFState_Service, LOCAL
    VJOYD_Service   VJOYD_DownloadEffect_Service, LOCAL
    VJOYD_Service   VJOYD_DestroyEffect_Service, LOCAL
    VJOYD_Service   VJOYD_StartEffect_Service, LOCAL
    VJOYD_Service   VJOYD_StopEffect_Service, LOCAL
    VJOYD_Service   VJOYD_GetEffectStatus_Service, LOCAL
;   *  Interrupt polling
;   *  Mini-drivers should call this if they are interrupt driven at the
;   *  time they are notified of a change.
;
    VJOYD_Service   VJOYD_DeviceUpdateNotify_Service, LOCAL
;   *  Screen saver (internal only)
;
    VJOYD_Service   VJOYD_JoystickActivity_Service, LOCAL
;   *  Registry access
;
    VJOYD_Service   VJOYD_OpenTypeKey_Service, LOCAL
    VJOYD_Service   VJOYD_OpenConfigKey_Service, LOCAL
;   *  Gameport provider (not fully supported)
;
    VJOYD_Service   VJOYD_NewGameportDevNode, LOCAL
;   *  Config Changed
;
    VJOYD_Service   VJOYD_ConfigChanged_Service, LOCAL
End_Service_Table VJOYD
VJOYD_Init_Order	EQU	<UNDEFINED_INIT_ORDER>
MAX_MSJSTICK	EQU	(16)
S_OK	EQU	00000000H
S_FALSE	EQU	00000001H
E_FAIL	EQU	80004005H
E_INVALIDARG	EQU	80000003H
VJ_OK	EQU	S_OK                      ; A complete success
VJ_FALSE	EQU	S_FALSE                ; A success but not without some difficulties
VJ_DEFAULT	EQU	VJ_FALSE             ; Mini-driver does not understand
VJ_INCOMPLETE	EQU	VJ_FALSE          ; Some requested poll data was not returned
VJERR_FAIL	EQU	E_FAIL
VJERR_NEED_DEVNODE	EQU	VJERR_FAIL   ; Need more resources
VJERR_BAD_DEVNODE	EQU	VJERR_FAIL    ; Last resources were insufficient
VJERR_INVALIDPARAM	EQU	E_INVALIDARG
VJERR_FAIL_HID	EQU	80070052H       ; The device is HID, so fail VJoyD polls: MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_DUP_NAME)
VJERR_FAIL_OOM	EQU	<E_OUTOFMEMORY>    ; An out of memory condition cause a failure
VJERR_FAIL_DRVLOAD	EQU	VJERR_FAIL   ; mini driver failed to load, internal error
VJERR_FAIL_POWER	EQU	VJERR_FAIL     ; the power state of the device caused a failure
;  Driver Config flags
;  Interface attributes (result is combination of OEM flag and VJOYD)
VJDF_UNIT_ID	EQU	00000001H        ; unit id is valid
VJDF_ISHID	EQU	00000002H          ; This is a HID device, so refuse polls
VJDF_SENDSNOTIFY	EQU	00000004H    ; Driver calls VJOYD_DeviceUpdateNotify_Service
VJDF_NEWIF	EQU	00000080H          ; use new interface (will be set by VJOYD on registration if new i/f used)
VJDF_USAGES	EQU	00000010H         ; usages are valid
VJDF_GENERICNAME	EQU	00000020H    ; The lpszOEMName string is generic name, not a whole string
;  Interface requirements
VJDF_NONVOLATILE	EQU	00000100H    ; This value should not be deleted on boot
;  Devnode requirement flags
VJDF_NODEVNODE	EQU	00010000H      ; does not get its resources via CFG_MGR
VJDF_ISANALOGPORTDRIVER	EQU	00020000H ; it plugs into a standard gameport
VJDF_NOCHAINING	EQU	00040000H     ; one devnode per device
MAX_JOYSTICKOEMVXDNAME	EQU	260      ; max oem vxd name length (including NULL)
POV_MIN	EQU	0
POV_MAX	EQU	1
;***************************************************************************
;  @doc DDK |
;  @struct JOYHWCAPS |
;  The <t JOYHWCAPS> structure is defined only because previous versions of
;  this file defined it.  There is no reason this should be needed.
;**************************************************************************

JOYHWCAPS	STRUC
dwMaxButtons	DD	?
dwMaxAxes	DD	?
dwNumAxes	DD	?
szOEMVxD	DB	MAX_JOYSTICKOEMVXDNAME DUP (?)
JOYHWCAPS	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct JOYPOLLDATA |
;  The <t JOYPOLLDATA> structure is used to collect sensor data
;  from a DX5 mini-driver.
;  @field DWORD | dwX |
;  The X axis value.
;  @field DWORD | dwY |
;  The X axis value.
;  @field DWORD | dwZ |
;  The X axis value.
;  @field DWORD | dwR |
;  The X axis value.
;  @field DWORD | dwU |
;  The X axis value.
;  @field DWORD | dwV |
;  The X axis value.
;  @field DWORD | dwPOV0 |
;  The first point of view value.
;  @field DWORD | dwPOV1 |
;  The second point of view value.
;  @field DWORD | dwPOV2 |
;  The third point of view value.
;  @field DWORD | dwPOV3 |
;  The fourth point of view value.
;  @field DWORD | dwBTN0 |
;  The first DWORD of button bits. (Buttons 1 to 32 )
;  @field DWORD | dwBTN1 |
;  The second DWORD of button bits. (Buttons 33 to 64 )
;  @field DWORD | dwBTN2 |
;  The third DWORD of button bits. (Buttons 65 to 96 )
;  @field DWORD | dwBTN3 |
;  The fourth DWORD of button bits. (Buttons 97 to 128 )
;  @field DWORD | dwReserved0 |
;  The first reserved DWORD.
;  @field DWORD | dwReserved1 |
;  The second reserved DWORD.
;**************************************************************************

VJPOLLDATA	STRUC
dwX	DD	?
dwY	DD	?
dwZ	DD	?
dwR	DD	?
dwU	DD	?
dwV	DD	?
dwPOV0	DD	?
dwPOV1	DD	?
dwPOV2	DD	?
dwPOV3	DD	?
dwBTN0	DD	?
dwBTN1	DD	?
dwBTN2	DD	?
dwBTN3	DD	?
dwReserved0	DD	?
dwReserved1	DD	?
VJPOLLDATA	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct JOYOEMHWCAPS |
;  The <t JOYOEMHWCAPS> structure is used to pass driver capabilites
;  @field DWORD | dwMaxButtons |
;  The number of buttons supported by the device.
;  @field DWORD | dwMaxAxes |
;  The highest axis supported by the device.
;  For example a device with X, Y and R has 3 axes but the highest
;  one is axis 4 so dwMaxAxes is 4.
;  @field DWORD | dwNumAxes |
;  The number of axes supported by the device.
;  For example a device with X, Y and R has 3 so dwNumAxes is 3.
;**************************************************************************

JOYOEMHWCAPS	STRUC
dwMaxButtons	DD	?
dwMaxAxes	DD	?
dwNumAxes	DD	?
JOYOEMHWCAPS	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct VJPOLLREG |
;  The <t VJPOLLREG> structure is used by a mini-driver to register polling
;  and other general purpose callbacks with VJoyD for DX5 interface mini-
;  drivers.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJPOLLREG>)
;  @field JOYPOLLRTN | fpPoll |
;  Poll callback.  Used for all device polling.
;  @field CMCONFIGHANDLER | fpCfg |
;  Standard configuration manager callback.
;  @field INITIALIZERTN | fpInitialize |
;  Initialization callback.  This callback replaces and extends the JoyId
;  callback used with Win95 interface mini-drivers.
;  @field ESCAPERTN | fpEscape |
;  Escape callback.  May be sent to a device in response to an application
;  calling the Escape member.
;  @field CTRLMSGRTN | fpCtrlMsg |
;  Control message callback.  Used to send notifications from VJoyD to mini-
;  drivers.
;**************************************************************************

VJPOLLREG	STRUC
dwSize	DD	?
fpPoll	DD	?
fpCfg	DD	?
fpInitialize	DD	?
fpEscape	DD	?
fpCtrlMsg	DD	?
VJPOLLREG	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct VJFORCEREG |
;  The <t VJFORCEREG> structure is used by a mini-driver to register force
;  feedback related callbacks with VJoyD for DX5 interface.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJFORCEREG>)
;  @field SETGAINRTN | fpSetFFGain |
;  Set Force Feedback Gain callback.
;  @field SENDFFCOMMANDRTN | fpSendFFCommand |
;  Send Force Feedback Command callback.
;  @field GETFFSTATERTN | fpGetFFState |
;  Get Force Feedback state callback.
;  @field DOWNLOADEFFECTRTN | fpDownloadEff |
;  Download effect callback.
;  @field DESTROYEFFECTRTN | fpDestroyEff |
;  Destroy effect callback.
;  @field STARTEFFECTRTN | fpStartEff |
;  Start effect callback.
;  @field STOPEFFECTRTN | fpStopEff |
;  Stop effect callback.
;  @field GETEFFECTSTATUSRTN | fpGetStatusEff |
;  Get effect status callback.
;**************************************************************************

VJFORCEREG	STRUC
dwSize	DD	?
fpSetFFGain	DD	?
fpSendFFCommand	DD	?
fpGetFFState	DD	?
fpDownloadEff	DD	?
fpDestroyEff	DD	?
fpStartEff	DD	?
fpStopEff	DD	?
fpGetStatusEff	DD	?
VJFORCEREG	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJDEVICEDESC |
;  The <t VJDEVICEDESC > structure is used to describe a DX5 DDI
;  device. This structure has been extended since DX5. See the
;  VJDEVICEDESC_DX5 structure for the previous version.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJDEVICEDESC>).
;  @field LPSTR | lpszOEMType |
;  Points to a null terminated string containing the text used to
;  describe the device as stored in the OEMName entry in the
;  registry. Renamed in Win98 (was lpszOEMName), is unused for
;  DX5 drivers.
;  @field DWORD | dwUnitId |
;  Specifies the unit id of this device.
;  @field LPJOYOEMHWCAPS | lpHWCaps |
;  Points to a <t JOYOEMHWCAPS> structure which contains the device
;  hardware capabilities.
;  @field LPJOYREGHWCONFIG | lpHWConfig |
;  Points to a <t JOYREGHWCONFIG> structure which contains the
;  configuration and calibration data for the device. Is unused for
;  DX5 drivers.
;  @field UNICODE_STRING | FileName |
;  An optional filename associated with the device. This is used for
;  HID devices to allow them to be accessed directly through the HID
;  stack without the joyGetPosEx restrictions. Added Win98.
;  @field USAGE_AND_PAGE | Usages |
;  An array of HID usages to describe what HID axis description has
;  been used for each WinMM axis. Added Win98. The elements are:
;  Usages[0] - X
;  Usages[1] - Y
;  Usages[2] - Z
;  Usages[3] - R
;  Usages[4] - U
;  Usages[5] - V
;  Usages[6] - POV0
;  Usages[7] - POV1
;  Usages[8] - POV2
;  Usages[9] - POV3
;  @field LPSTR | lpszOEMName |
;  Points to a null terminated string containing a friendly name
;  for the device. Added Win98.
;**************************************************************************

VJDEVICEDESC	STRUC
dwSize	DD	?
lpszOEMType	DD	?
dwUnitId	DD	?
lpHWCaps	DD	?
lpHWConfig	DD	?
FileName	DB	SIZE UNICODE_STRING DUP (?)
Usages	DD	10 DUP (?)
lpszOEMName	DD	?
VJDEVICEDESC	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJDEVICEDESC_DX5 |
;  The <t VJDEVICEDESC_DX5 > structure is used to describe a DX5 DDI
;  device. This is the DX5 version of the structure.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJDEVICEDESC_DX5>).
;  @field LPSTR | lpszOEMName |
;  This field is ignored.
;  @field DWORD | dwUnitId |
;  Specifies the unit id of this device.
;  @field LPJOYOEMHWCAPS | lpHWCaps |
;  Points to a <t JOYOEMHWCAPS> structure which contains the device
;  hardware capabilities.
;  @field LPJOYREGHWCONFIG | lpHWConfig |
;  This field is unused in DX5.
;**************************************************************************

VJDEVICEDESC_DX5	STRUC
dwSize	DD	?
lpszOEMName	DD	?
dwUnitId	DD	?
lpHWCaps	DD	?
lpHWConfig	DD	?
VJDEVICEDESC_DX5	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJREGDRVINFO |
;  The <t VJREGDRVINFO > structure is used to register a DX5 DDI
;  driver with VJoyD.
;  @field DWORD | dwSize |
;  The size of the structure.
;  @field DWORD | dwFunction |
;  The type of registration to be performed
;  It must be one of the <c VJRT_*> values.
;  @field DWORD | dwFlags |
;  Flags associated with this registration
;  It consists of one or more <c VJDF_*> flag values.
;  @field LPSTR | lpszOEMCallout |
;  The name of the driver associated with this registration,
;  for example "msanalog.vxd"
;  @field DWORD | dwFirmwareRevision |
;  Specifies the firmware revision of the device.
;  If the revision is unknown a value of zero should be used.
;  @field DWORD | dwHardwareRevision |
;  Specifies the hardware revision of the device.
;  If the revision is unknown a value of zero should be used.
;  @field DWORD | dwDriverVersion |
;  Specifies the version number of the device driver.
;  If the revision is unknown a value of zero should be used.
;  @field LPVJDEVICEDESC | lpDeviceDesc |
;  Optional pointer to a <t VJDEVICEDESC > structure
;  that describes the configuration properties of the device.
;  This allows drivers to supply the description of the device
;  rather than use the registry for this purpose.
;  If no description is available then the field should be
;  set to <c NULL>.
;  @field LPVJPOLLREG | lpPollReg |
;  Optional pointer to a <t VJPOLLREG > structure
;  that contains the most common driver callbacks.
;  Only a very strange driver would not need to register any
;  of these callbacks but if that was the case, then the field
;  should be set to <c NULL>.
;  @field LPVJFORCEREG | lpForceReg |
;  Optional pointer to a <t VJFORCEREG > structure
;  that contains all of the force feedback specific callbacks.
;  If the ring 0 driver does not support force feedback then
;  the field should be set to <c NULL>.
;  @field DWORD | dwReserved |
;  Reserved, must be set to zero.
;**************************************************************************

VJREGDRVINFO	STRUC
dwSize	DD	?
dwFunction	DD	?
dwFlags	DD	?
lpszOEMCallout	DD	?
dwFirmwareRevision	DD	?
dwHardwareRevision	DD	?
dwDriverVersion	DD	?
lpDeviceDesc	DD	?
lpPollReg	DD	?
lpForceReg	DD	?
dwReserved	DD	?
VJREGDRVINFO	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\vjoyd.h ===
/****************************************************************************
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
 *
 *  File: vjoyd.h
 *  Content: include file for describing VJoyD mini-driver communications
 *
 *
 ***************************************************************************/

#ifndef __VJOYD_INCLUDED__
#define __VJOYD_INCLUDED__

/*
 *  define all types and macros necessary to include dinputd.h
 */
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef FAR
#define FAR
#endif
#ifndef NEAR
#define NEAR
#endif

#ifndef DWORD
typedef ULONG DWORD;
#endif
typedef DWORD FAR *LPDWORD;

#ifndef LPVOID
typedef void FAR *LPVOID;
#endif
#ifndef PVOID
typedef void FAR *PVOID;
#endif

typedef long LONG;
typedef long FAR *LPLONG;

typedef char FAR *LPSTR;

#ifndef WCHAR
typedef unsigned short WCHAR;
typedef unsigned short FAR *PWCHAR;
#endif

#ifndef UNICODE_STRING
typedef struct UNICODE_STRING { /* us */
    WORD Length;
    WORD MaximumLength;
    PWCHAR Buffer;
} UNICODE_STRING, FAR *PUNICODE_STRING;
#endif

#define DIJ_RINGZERO

#define _INC_MMSYSTEM

/*
 *  Make joyConfigChanged compile 
 */
#ifndef WINMMAPI
#define WINMMAPI __declspec(dllimport)
#endif
#ifndef MMRESULT
typedef UINT MMRESULT; /* error return code, 0 means no error */
#endif
#ifndef WINAPI
#define WINAPI
#endif

#include <winerror.h>
#include <dinput.h>
#include <dinputd.h>
#include <configmg.h>
#include "vjoydapi.h"

/*
 *  Make sure HID types have been defined
 */
#ifndef USAGE
typedef USHORT USAGE;
typedef USHORT FAR *PUSAGE;
#endif

#ifndef USAGE_AND_PAGE
typedef struct USAGE_AND_PAGE {
    USAGE Usage;
    USAGE UsagePage;
} USAGE_AND_PAGE;
typedef struct USAGE_AND_PAGE FAR *PUSAGE_AND_PAGE;
#endif

/*
 *  joystick ports
 */
#define MIN_JOY_PORT 0x200
#define MAX_JOY_PORT 0x20F
#define DEFAULT_JOY_PORT 0x201

/* 
 *  Poll types 
 *  passed in the type field to a Win95 interface poll callback
 */
#define JOY_OEMPOLL_POLL1 0
#define JOY_OEMPOLL_POLL2 1
#define JOY_OEMPOLL_POLL3 2
#define JOY_OEMPOLL_POLL4 3
#define JOY_OEMPOLL_POLL5 4
#define JOY_OEMPOLL_POLL6 5
#define JOY_OEMPOLL_GETBUTTONS 6
#define JOY_OEMPOLL_PASSDRIVERDATA 7 

/*
 *  Axis numbers used for single axis (JOY_OEMPOLL_POLL1) polls
 */
#define JOY_AXIS_X 0
#define JOY_AXIS_Y 1
#define JOY_AXIS_Z 2
#define JOY_AXIS_R 3
#define JOY_AXIS_U 4
#define JOY_AXIS_V 5

/*
 *  joystick error return values
 */
#define JOYERR_BASE 160
#define JOYERR_NOERROR (0)                  /*  no error */
#define JOYERR_PARMS (JOYERR_BASE+5)        /*  bad parameters */
#define JOYERR_NOCANDO (JOYERR_BASE+6)      /*  request not completed */
#define JOYERR_UNPLUGGED (JOYERR_BASE+7)    /*  joystick is unplugged */

/* 
 *  constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages
 */
#define JOY_BUTTON1 0x0001
#define JOY_BUTTON2 0x0002
#define JOY_BUTTON3 0x0004
#define JOY_BUTTON4 0x0008

/*
 *  constants used with JOYINFOEX structure 
 */
#define JOY_POVCENTERED (WORD) -1
#define JOY_POVFORWARD 0
#define JOY_POVRIGHT 9000
#define JOY_POVBACKWARD 18000
#define JOY_POVLEFT 27000

#define POV_UNDEFINED (DWORD) -1

/*
 *  List of services available for calling by VxDs
 *  Note, many of these are for internal use only.
 */
#define VJOYD_Service Declare_Service
#pragma warning (disable:4003) /* turn off not enough params warning */

/*MACROS*/
Begin_Service_Table(VJOYD)

    /*
     *  Win95 Gold services
     */
    VJOYD_Service ( VJOYD_Register_Device_Driver, LOCAL )
    VJOYD_Service ( VJOYD_GetPosEx_Service, LOCAL )

    /*
     *  DInput services (for internal use only)
     */
    VJOYD_Service ( VJOYD_GetInitParams_Service, LOCAL )
    VJOYD_Service ( VJOYD_Poll_Service, LOCAL )
    VJOYD_Service ( VJOYD_Escape_Service, LOCAL )
    VJOYD_Service ( VJOYD_CtrlMsg_Service, LOCAL )
    VJOYD_Service ( VJOYD_SetGain_Service, LOCAL )
    VJOYD_Service ( VJOYD_SendFFCommand_Service, LOCAL )
    VJOYD_Service ( VJOYD_GetFFState_Service, LOCAL )
    VJOYD_Service ( VJOYD_DownloadEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_DestroyEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_StartEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_StopEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_GetEffectStatus_Service, LOCAL )

    /*
     *  Interrupt polling
     *  Mini-drivers should call this if they are interrupt driven at the 
     *  time they are notified of a change.
     */
    VJOYD_Service ( VJOYD_DeviceUpdateNotify_Service, LOCAL )

    /*
     *  Screen saver (internal only)
     */
    VJOYD_Service ( VJOYD_JoystickActivity_Service, LOCAL )

    /*
     *  Registry access
     */
    VJOYD_Service ( VJOYD_OpenTypeKey_Service, LOCAL )
    VJOYD_Service ( VJOYD_OpenConfigKey_Service, LOCAL )

    /*
     *  Gameport provider (not fully supported)
     */
    VJOYD_Service ( VJOYD_NewGameportDevNode, LOCAL )

    /*
     *  Config Changed
     */
    VJOYD_Service ( VJOYD_ConfigChanged_Service, LOCAL )

End_Service_Table(VJOYD)
/*ENDMACROS*/

#define VJOYD_Init_Order UNDEFINED_INIT_ORDER

#pragma warning (default:4003) /* restore not enough params warning */

#ifndef HRESULT
typedef LONG HRESULT;
#endif

#define MAX_MSJSTICK (16)
#define MAX_POLL MAX_MSJSTICK

/*
 *  VJoyD sends this system control message to a mini-driver when it needs 
 *  the mini-driver to register it's callbacks and properties.
 *  A mini-driver that can be loaded by some mechanism other than by VJoyD 
 *  should perform it's registration only in response to this message rather 
 *  than in response to SYS_DYNAMIC_DEVICE_INIT or SYS_DYNAMIC_DEVICE_REINIT.
 *  
 *  alias BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL
 */
#define VJOYD_REINIT_PRIVATE_SYSTEM_CONTROL 0x70000000

#define JOY_OEMPOLLRC_OK 1
#define JOY_OEMPOLLRC_FAIL 0

/*  
 *  Error codes 
 *  These are custom names for standard HRESULTs
 */

#define VJ_OK S_OK                      /* A complete success */
#define VJ_FALSE S_FALSE                /* A success but not without some difficulties */
#define VJ_DEFAULT VJ_FALSE             /* Mini-driver does not understand */
#define VJ_INCOMPLETE VJ_FALSE          /* Some requested poll data was not returned */

#define VJERR_FAIL E_FAIL
#define VJERR_NEED_DEVNODE VJERR_FAIL   /* Need more resources */
#define VJERR_BAD_DEVNODE VJERR_FAIL    /* Last resources were insufficient */
#define VJERR_INVALIDPARAM E_INVALIDARG

#define VJERR_FAIL_HID 0x80070052       /* The device is HID, so fail VJoyD polls: MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_DUP_NAME) */

#define VJERR_FAIL_OOM E_OUTOFMEMORY    /* An out of memory condition cause a failure */
#define VJERR_FAIL_DRVLOAD VJERR_FAIL   /* mini driver failed to load, internal error */
#define VJERR_FAIL_POWER VJERR_FAIL     /* the power state of the device caused a failure */

/*
 *  Driver Config flags
 */

/*
 *  Interface attributes (result is combination of OEM flag and VJOYD)
 */
#define VJDF_UNIT_ID 0x00000001L        /* unit id is valid */
#define VJDF_ISHID 0x00000002L          /* This is a HID device, so refuse polls */
#define VJDF_SENDSNOTIFY 0x00000004L    /* Driver calls VJOYD_DeviceUpdateNotify_Service */
#define VJDF_NEWIF 0x00000080L          /* use new interface (will be set by VJOYD on registration if new i/f used) */
#define VJDF_USAGES 0x00000010L         /* usages are valid */
#define VJDF_GENERICNAME 0x00000020L    /* The lpszOEMName string is generic name, not a whole string */

/*
 *  Interface requirements
 */
#define VJDF_NONVOLATILE 0x00000100L    /* This value should not be deleted on boot */

/*
 *  Devnode requirement flags
 */
#define VJDF_NODEVNODE 0x00010000L      /* does not get its resources via CFG_MGR */
#define VJDF_ISANALOGPORTDRIVER 0x00020000L /* it plugs into a standard gameport */
#define VJDF_NOCHAINING 0x00040000L     /* one devnode per device */

/*
 *  Polling flags
 *  These flags are passed to and from DX5 interface mini-driver poll
 *  callbacks.
 *  The low WORD contains flags detailing which elements are being requested 
 *  or provided; whereas the high WORD contains flags detailing the attributes 
 *  of the data.
 */
#define JOYPD_X             0x00000001
#define JOYPD_Y             0x00000002
#define JOYPD_Z             0x00000004
#define JOYPD_R             0x00000008
#define JOYPD_U             0x00000010
#define JOYPD_V             0x00000020
#define JOYPD_POV0          0x00000040
#define JOYPD_POV1          0x00000080
#define JOYPD_POV2          0x00000100
#define JOYPD_POV3          0x00000200
#define JOYPD_BTN0          0x00000400
#define JOYPD_BTN1          0x00000800
#define JOYPD_BTN2          0x00001000
#define JOYPD_BTN3          0x00002000
#define JOYPD_RESERVED0     0x00004000
#define JOYPD_RESERVED1     0x00008000

#define JOYPD_ELEMENT_MASK  0x0000FFFF

#define JOYPD_POSITION      0x00010000
#define JOYPD_VELOCITY      0x00020000
#define JOYPD_ACCELERATION  0x00040000
#define JOYPD_FORCE         0x00080000

#define JOYPD_ATTRIB_MASK   0x000F0000

#define MAX_JOYSTICKOEMVXDNAME 260      /* max oem vxd name length (including NULL) */

#define POV_MIN 0
#define POV_MAX 1

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYHWCAPS |
 *
 *  The <t JOYHWCAPS> structure is defined only because previous versions of 
 *  this file defined it.  There is no reason this should be needed.
 *
 ****************************************************************************/
typedef struct JOYHWCAPS {
    DWORD dwMaxButtons;
    DWORD dwMaxAxes;
    DWORD dwNumAxes;
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME];
} JOYHWCAPS; 
typedef struct JOYHWCAPS FAR *LPJOYHWCAPS;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYPOLLDATA |
 *
 *  The <t JOYPOLLDATA> structure is used to collect sensor data
 *  from a DX5 mini-driver.
 *
 *  @field DWORD | dwX |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwY |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwZ |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwR |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwU |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwV |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwPOV0 |
 *
 *  The first point of view value.
 *
 *  @field DWORD | dwPOV1 |
 *
 *  The second point of view value.
 *
 *  @field DWORD | dwPOV2 |
 *
 *  The third point of view value.
 *
 *  @field DWORD | dwPOV3 |
 *
 *  The fourth point of view value.
 *
 *  @field DWORD | dwBTN0 |
 *
 *  The first DWORD of button bits. (Buttons 1 to 32 )
 *
 *  @field DWORD | dwBTN1 |
 *
 *  The second DWORD of button bits. (Buttons 33 to 64 )
 *
 *  @field DWORD | dwBTN2 |
 *
 *  The third DWORD of button bits. (Buttons 65 to 96 )
 *
 *  @field DWORD | dwBTN3 |
 *
 *  The fourth DWORD of button bits. (Buttons 97 to 128 )
 *
 *  @field DWORD | dwReserved0 |
 *
 *  The first reserved DWORD.
 *
 *  @field DWORD | dwReserved1 |
 *
 *  The second reserved DWORD.
 *
 *
 ****************************************************************************/
typedef struct VJPOLLDATA {
    DWORD dwX;
    DWORD dwY;
    DWORD dwZ;
    DWORD dwR;
    DWORD dwU;
    DWORD dwV;
    DWORD dwPOV0;
    DWORD dwPOV1;
    DWORD dwPOV2;
    DWORD dwPOV3;
    DWORD dwBTN0;
    DWORD dwBTN1;
    DWORD dwBTN2;
    DWORD dwBTN3;
    DWORD dwReserved0;
    DWORD dwReserved1;
} VJPOLLDATA;
typedef struct VJPOLLDATA FAR *LPVJPOLLDATA;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYOEMPOLLDATA |
 *
 *  The <t JOYOEMPOLLDATA> structure is used to collect sensor data
 *  from a pre-DX5 mini-driver.
 *
 *  @field DWORD | id |
 *
 *  The id of the joystick to be polled.
 *
 *  @field DWORD | do_other |
 *
 *  If the poll type is JOY_OEMPOLL_POLL1, this is the axis to be 
 *  polled.
 *  If the poll type is JOY_OEMPOLL_POLL3, this is zero if the poll 
 *  is X,Y,Z or non-zero if the poll is X,Y,R.
 *  If the poll type is JOY_OEMPOLL_POLL5, this is zero if the poll 
 *  is X,Y,Z,R,U or non-zero if the poll is X,Y,Z,R,V.
 *  If the poll type is JOY_OEMPOLL_PASSDRIVERDATA poll, this DWORD 
 *  is the value set in the dwReserved2 field by the caller.
 *  Otherwise this values is undefined and should be ignored
 *
 *  @field JOYPOS | jp |
 *
 *  Values to hold the X,Y,Z,R,U,V values.
 *  Note for a JOY_OEMPOLL_POLL1 poll type the requested axis value
 *  should always be returned in jp.dwX.
 *
 *  @field DWORD | dwPOV |
 *
 *  The Point Of View value if not supported through button combos 
 *  or an axis value.
 *  Note, should be left as POV_UNDEFINED if not used.
 *
 *  @field DWORD | dwButtons |
 *
 *  Bitmask of the button values.
 *
 *  @field DWORD | dwButtonNumber |
 *
 *  The one-based bit position of the lowest numbered button pressed.
 *  Zero if no buttons are pressed.
 *
 *
 ****************************************************************************/
typedef struct JOYOEMPOLLDATA {
    DWORD id;
    DWORD do_other;
    JOYPOS jp;
    DWORD dwPOV;
    DWORD dwButtons;
    DWORD dwButtonNumber;
} JOYOEMPOLLDATA;
typedef struct JOYOEMPOLLDATA FAR *LPJOYOEMPOLLDATA;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYOEMHWCAPS |
 *
 *  The <t JOYOEMHWCAPS> structure is used to pass driver capabilites
 *
 *  @field DWORD | dwMaxButtons |
 *
 *  The number of buttons supported by the device.
 *
 *  @field DWORD | dwMaxAxes |
 *
 *  The highest axis supported by the device.
 *  For example a device with X, Y and R has 3 axes but the highest
 *  one is axis 4 so dwMaxAxes is 4.
 *
 *  @field DWORD | dwNumAxes |
 *
 *  The number of axes supported by the device.
 *  For example a device with X, Y and R has 3 so dwNumAxes is 3.
 *
 *
 ****************************************************************************/
typedef struct JOYOEMHWCAPS {
    DWORD dwMaxButtons;
    DWORD dwMaxAxes;
    DWORD dwNumAxes;
} JOYOEMHWCAPS;
typedef struct JOYOEMHWCAPS FAR *LPJOYOEMHWCAPS;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct DID_INITPARAMS |
 *
 *  The <t DID_INITPARAMS> structure is used to pass details of the 
 *  joystick being initialized to a particular id in DX5 drivers.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t DID_INITPARAMS>)
 *
 *  @field DWORD | dwFlags |
 *
 *  Flags associated with the call.
 *
 *  It will be either:
 *  VJIF_BEGIN_ACCESS if the id association is being made, or
 *  VJIF_END_ACCESS if the id association is being broken.
 *  Other flags may be defined in the future so all other values
 *  should be refused.
 *
 *  @field DWORD | dwUnitId |
 *
 *  The id for which polling support is being requested.
 *
 *  @field DWORD | dwDevnode |
 *
 *  The Devnode containing hardware resources to use for this id.
 *
 *  @field JOYREGHWSETTINGS | hws |
 *
 *  The hardware settings flags applied to this device.
 *
 *
 ****************************************************************************/
typedef struct DID_INITPARAMS {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwUnitId;
    DWORD dwDevnode;
    JOYREGHWSETTINGS hws;
} DID_INITPARAMS;
typedef struct DID_INITPARAMS FAR *LPDID_INITPARAMS;

/*
 *  DX1 callbacks
 */
typedef int (__stdcall *JOYOEMPOLLRTN)( int type, LPJOYOEMPOLLDATA pojd );
typedef int (__stdcall *JOYOEMHWCAPSRTN)( int joyid, LPJOYOEMHWCAPS pohwcaps );
typedef int (__stdcall *JOYOEMJOYIDRTN)( int joyid, BOOL inuse );
/*
 *  General callbacks
 */
typedef HRESULT (__stdcall *JOYPOLLRTN)( DWORD dwDeviceID, LPDWORD lpdwMask, LPVJPOLLDATA lpPollData );
typedef HRESULT (__stdcall *INITIALIZERTN)( DWORD dwDeviceID, LPDID_INITPARAMS lpInitParams );
typedef HRESULT (__stdcall *ESCAPERTN)( DWORD dwDeviceID, DWORD dwEffectID, LPDIEFFESCAPE lpEscape );
typedef HRESULT (__stdcall *CTRLMSGRTN)( DWORD dwDeviceID, DWORD dwMsgId, DWORD dwParam );
/*
 *  Force feedback callbacks
 */
typedef HRESULT (__stdcall *SETGAINRTN)( DWORD dwDeviceID, DWORD dwGain );
typedef HRESULT (__stdcall *SENDFFCOMMANDRTN)( DWORD dwDeviceID, DWORD dwState );
typedef HRESULT (__stdcall *GETFFSTATERTN)( DWORD dwDeviceID, LPDIDEVICESTATE lpDeviceState );
typedef HRESULT (__stdcall *DOWNLOADEFFECTRTN)( DWORD dwDeviceID, DWORD dwInternalEffectType, LPDWORD lpdwDnloadID, LPDIEFFECT lpEffect, DWORD dwFlags );
typedef HRESULT (__stdcall *DESTROYEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID );
typedef HRESULT (__stdcall *STARTEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode, DWORD dwIterations );
typedef HRESULT (__stdcall *STOPEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID );
typedef HRESULT (__stdcall *GETEFFECTSTATUSRTN)( DWORD dwDeviceID, DWORD dwDnloadID, LPDWORD lpdwStatusCode );
/*
 *  Gameport Emulation callbacks
 */
typedef HRESULT (__stdcall *JOYOEMGPEMULCTRL)( DWORD port, DWORD inuse );
typedef DWORD JOYOEMGPEMULTRAP;
typedef HRESULT (__stdcall *JOYOEMGPPROVRTN)( DWORD function, DWORD dwParam );

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct VJPOLLREG |
 *
 *  The <t VJPOLLREG> structure is used by a mini-driver to register polling 
 *  and other general purpose callbacks with VJoyD for DX5 interface mini-
 *  drivers.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJPOLLREG>)
 *
 *  @field JOYPOLLRTN | fpPoll |
 *
 *  Poll callback.  Used for all device polling.
 *
 *  @field CMCONFIGHANDLER | fpCfg |
 *
 *  Standard configuration manager callback.
 *
 *  @field INITIALIZERTN | fpInitialize |
 *
 *  Initialization callback.  This callback replaces and extends the JoyId 
 *  callback used with Win95 interface mini-drivers.
 *
 *  @field ESCAPERTN | fpEscape |
 *
 *  Escape callback.  May be sent to a device in response to an application 
 *  calling the Escape member.
 *
 *  @field CTRLMSGRTN | fpCtrlMsg |
 *
 *  Control message callback.  Used to send notifications from VJoyD to mini-
 *  drivers.
 *
 ****************************************************************************/
typedef struct VJPOLLREG {
    DWORD dwSize;
    JOYPOLLRTN fpPoll;
    CMCONFIGHANDLER fpCfg;
    INITIALIZERTN fpInitialize;
    ESCAPERTN fpEscape;
    CTRLMSGRTN fpCtrlMsg;
} VJPOLLREG;
typedef struct VJPOLLREG FAR *LPVJPOLLREG;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct VJFORCEREG |
 *
 *  The <t VJFORCEREG> structure is used by a mini-driver to register force 
 *  feedback related callbacks with VJoyD for DX5 interface.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJFORCEREG>)
 *
 *  @field SETGAINRTN | fpSetFFGain |
 *
 *  Set Force Feedback Gain callback.
 *
 *  @field SENDFFCOMMANDRTN | fpSendFFCommand |
 *
 *  Send Force Feedback Command callback.
 *
 *  @field GETFFSTATERTN | fpGetFFState |
 *
 *  Get Force Feedback state callback.
 *
 *  @field DOWNLOADEFFECTRTN | fpDownloadEff |
 *
 *  Download effect callback.
 *
 *  @field DESTROYEFFECTRTN | fpDestroyEff |
 *
 *  Destroy effect callback.
 *
 *  @field STARTEFFECTRTN | fpStartEff |
 *
 *  Start effect callback.
 *
 *  @field STOPEFFECTRTN | fpStopEff |
 *
 *  Stop effect callback.
 *
 *  @field GETEFFECTSTATUSRTN | fpGetStatusEff |
 *
 *  Get effect status callback.
 *
 *
 ****************************************************************************/
typedef struct VJFORCEREG {
    DWORD dwSize;
    SETGAINRTN fpSetFFGain;
    SENDFFCOMMANDRTN fpSendFFCommand;
    GETFFSTATERTN fpGetFFState;
    DOWNLOADEFFECTRTN fpDownloadEff;
    DESTROYEFFECTRTN fpDestroyEff;
    STARTEFFECTRTN fpStartEff;
    STOPEFFECTRTN fpStopEff;
    GETEFFECTSTATUSRTN fpGetStatusEff;
} VJFORCEREG;
typedef struct VJFORCEREG FAR *LPVJFORCEREG;
 

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJDEVICEDESC |
 *
 *  The <t VJDEVICEDESC > structure is used to describe a DX5 DDI
 *  device. This structure has been extended since DX5. See the 
 *  VJDEVICEDESC_DX5 structure for the previous version.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJDEVICEDESC>).
 *
 *  @field LPSTR | lpszOEMType |
 *
 *  Points to a null terminated string containing the text used to 
 *  describe the device as stored in the OEMName entry in the 
 *  registry. Renamed in Win98 (was lpszOEMName), is unused for
 *  DX5 drivers.
 *
 *  @field DWORD | dwUnitId |
 *
 *  Specifies the unit id of this device.
 *
 *  @field LPJOYOEMHWCAPS | lpHWCaps |
 *
 *  Points to a <t JOYOEMHWCAPS> structure which contains the device 
 *  hardware capabilities.
 *
 *  @field LPJOYREGHWCONFIG | lpHWConfig |
 *
 *  Points to a <t JOYREGHWCONFIG> structure which contains the 
 *  configuration and calibration data for the device. Is unused for
 *  DX5 drivers.
 *
 *  @field UNICODE_STRING | FileName |
 *
 *  An optional filename associated with the device. This is used for
 *  HID devices to allow them to be accessed directly through the HID
 *  stack without the joyGetPosEx restrictions. Added Win98.
 *
 *  @field USAGE_AND_PAGE | Usages |
 *
 *  An array of HID usages to describe what HID axis description has 
 *  been used for each WinMM axis. Added Win98. The elements are:
 *
 *  Usages[0] - X
 *  Usages[1] - Y
 *  Usages[2] - Z
 *  Usages[3] - R
 *  Usages[4] - U
 *  Usages[5] - V
 *  Usages[6] - POV0
 *  Usages[7] - POV1
 *  Usages[8] - POV2
 *  Usages[9] - POV3
 *
 *
 *  @field LPSTR | lpszOEMName |
 *
 *  Points to a null terminated string containing a friendly name 
 *  for the device. Added Win98.
 *
 *
 ****************************************************************************/
typedef struct VJDEVICEDESC {
    DWORD dwSize;
    LPSTR lpszOEMType;
    DWORD dwUnitId;
    LPJOYOEMHWCAPS lpHWCaps;
    LPJOYREGHWCONFIG lpHWConfig;
    UNICODE_STRING FileName;
    USAGE_AND_PAGE Usages[10];
    LPSTR lpszOEMName;
} VJDEVICEDESC ;
typedef struct VJDEVICEDESC FAR *LPVJDEVICEDESC;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJDEVICEDESC_DX5 |
 *
 *  The <t VJDEVICEDESC_DX5 > structure is used to describe a DX5 DDI
 *  device. This is the DX5 version of the structure.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJDEVICEDESC_DX5>).
 *
 *  @field LPSTR | lpszOEMName |
 *
 *  This field is ignored.
 *
 *  @field DWORD | dwUnitId |
 *
 *  Specifies the unit id of this device.
 *
 *  @field LPJOYOEMHWCAPS | lpHWCaps |
 *
 *  Points to a <t JOYOEMHWCAPS> structure which contains the device 
 *  hardware capabilities.
 *
 *  @field LPJOYREGHWCONFIG | lpHWConfig |
 *
 *  This field is unused in DX5.
 *
 *
 ****************************************************************************/
typedef struct VJDEVICEDESC_DX5 {
    DWORD dwSize;
    LPSTR lpszOEMName;
    DWORD dwUnitId;
    LPJOYOEMHWCAPS lpHWCaps;
    LPJOYREGHWCONFIG lpHWConfig;
} VJDEVICEDESC_DX5;
typedef struct VJDEVICEDESC_DX5 FAR *LPVJDEVICEDESC_DX5;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJREGDRVINFO |
 *
 *  The <t VJREGDRVINFO > structure is used to register a DX5 DDI
 *  driver with VJoyD.
 *
 *  @field DWORD | dwSize |
 *
 *  The size of the structure.
 *
 *  @field DWORD | dwFunction |
 *
 *  The type of registration to be performed
 *  It must be one of the <c VJRT_*> values.
 *
 *  @field DWORD | dwFlags |
 *
 *  Flags associated with this registration
 *  It consists of one or more <c VJDF_*> flag values.
 *
 *  @field LPSTR | lpszOEMCallout |
 *
 *  The name of the driver associated with this registration,
 *  for example "msanalog.vxd"
 *
 *  @field DWORD | dwFirmwareRevision |
 *
 *  Specifies the firmware revision of the device.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field DWORD | dwHardwareRevision |
 *
 *  Specifies the hardware revision of the device.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field DWORD | dwDriverVersion |
 *
 *  Specifies the version number of the device driver.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field LPVJDEVICEDESC | lpDeviceDesc |
 *
 *  Optional pointer to a <t VJDEVICEDESC > structure
 *  that describes the configuration properties of the device.
 *  This allows drivers to supply the description of the device 
 *  rather than use the registry for this purpose.
 *  If no description is available then the field should be 
 *  set to <c NULL>.
 *
 *  @field LPVJPOLLREG | lpPollReg |
 *
 *  Optional pointer to a <t VJPOLLREG > structure
 *  that contains the most common driver callbacks.
 *  Only a very strange driver would not need to register any 
 *  of these callbacks but if that was the case, then the field 
 *  should be set to <c NULL>.
 *
 *  @field LPVJFORCEREG | lpForceReg |
 *
 *  Optional pointer to a <t VJFORCEREG > structure
 *  that contains all of the force feedback specific callbacks.
 *  If the ring 0 driver does not support force feedback then 
 *  the field should be set to <c NULL>.
 *
 *  @field DWORD | dwReserved |
 *
 *  Reserved, must be set to zero.
 *
 ****************************************************************************/
typedef struct VJREGDRVINFO {
    DWORD dwSize;
    DWORD dwFunction;
    DWORD dwFlags;
    LPSTR lpszOEMCallout;
    DWORD dwFirmwareRevision;
    DWORD dwHardwareRevision;
    DWORD dwDriverVersion;
    LPVJDEVICEDESC lpDeviceDesc;
    LPVJPOLLREG lpPollReg;
    LPVJFORCEREG lpForceReg;
    DWORD dwReserved;
} VJREGDRVINFO;
typedef struct VJREGDRVINFO FAR *LPVJREGDRVINFO;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJCFGCHG |
 *
 *  The <t VJCFGCHG > structure is passed in the dwParam of a CtrlMsg
 *  callback when the dwMsg type is VJCM_CONFIGCHANGED.
 *
 *  @field DWORD | dwSize |
 *
 *  The size of the structure.
 *
 *  @field DWORD | dwChangeType |
 *
 *  The type of change which has been made
 *  It must be one of the <c VJCMCT_*> values.
 *  Currently the only supported value is VJCMCT_GENERAL.
 *
 *  @field DWORD | dwTimeOut |
 *
 *  The dwTimeOut value from the user data registry values.
 *  This value is passed as a convenience to drivers which use it as
 *  there are no other driver values in this structure.
 *
 ****************************************************************************/
typedef struct VJCFGCHG {
    DWORD dwSize;
    DWORD dwChangeType;
    DWORD dwTimeOut;
} VJCFGCHG;
typedef struct VJCFGCHG FAR *LPVJCFGCHG;

/*
 *  Control messages
 */
#define VJCM_PASSDRIVERDATA 1 /* dwParam = DWORD to pass to driver */
#define VJCM_CONFIGCHANGED 2 /* dwParam = PVJCFGCHG pointer to config changed structure */

/*
 *  Config changed types
 */
#define VJCMCT_GENERAL 0x00010000L
#define VJCMCT_CONFIG 0x00020000L
#define VJCMCT_TYPEDATA 0x00030000L
#define VJCMCT_OEMDEFN 0x00040000L
#define VJCMCT_GLOBAL 0x00050000L

/*
 *  Masks
 */
#define VJCMCTM_MAJORMASK 0x00ff0000L
#define VJCMCTM_MINORMASK 0x0000ffffL

/*
 *  Registration types
 */
#define VJRT_LOADED 1 /* Driver has been loaded */
#define VJRT_CHANGE 2 /* NOT IMPLEMENTED! Modify anything except driver and initialization parameters */
#define VJRT_PLUG 3 /* New instance of a device, New in Win98 */
#define VJRT_UNPLUG 4 /* Device instance is gone, New in Win98 */

/*
 *  Driver Initialize dwFlags
 */
#define VJIF_BEGIN_ACCESS 0x00000001L
#define VJIF_END_ACCESS 0x00000002L

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\soundcfg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1990  Microsoft Corporation

Module Name:

    soundcfg.h

Abstract:

    This include file defines common strings and values for sound driver
	configuration.

Author:

    Robin Speed (RobinSp) 17-Oct-92

Revision History:
--*/

#define SOUND_REG_PORT (L"Port")
#define SOUND_REG_DMACHANNEL (L"DmaChannel")
#define SOUND_REG_INTERRUPT (L"Interrupt")
#define SOUND_REG_INPUTSOURCE (L"Input Source")
#define SOUND_REG_DMABUFFERSIZE (L"Dma Buffer Size")
#define SOUND_REG_CONFIGERROR (L"Configuration Error")
#define SOUND_REG_LOADTYPE (L"Load Type")
#define SOUND_REG_PNPDEVICE (L"PnP Device")

    //
    //  Values for Load Type
    //

    #define SOUND_LOADTYPE_NORMAL  0x00
    #define SOUND_LOADTYPE_CONFIG  0x01  // Fail load but return config data

#define SOUND_REG_SYNTH_TYPE (L"Synth Type")

    //
    //  Values for synth type
    //

    #define SOUND_SYNTH_TYPE_ADLIB  0x01
    #define SOUND_SYNTH_TYPE_OPL3   0x02
    #define SOUND_SYNTH_TYPE_NONE   0x03

#define SOUND_MIXER_SETTINGS_NAME (L"Mixer Settings")


//
// Errors
//

#define SOUND_CONFIG_ERROR      0x00000000
#define SOUND_CONFIG_OK         0xFFFFFFFF
#define SOUND_CONFIG_NOCARD     0x00000001
#define SOUND_CONFIG_BADINT     0x00000002
#define SOUND_CONFIG_BADDMA     0x00000003
#define SOUND_CONFIG_BADCARD    0x00000004
#define SOUND_CONFIG_RESOURCE   0x00000005

#define SOUND_CONFIG_BADPORT    0x00000006
#define SOUND_CONFIG_PORT_INUSE 0x00000007
#define SOUND_CONFIG_DMA_INUSE  0x00000008
#define SOUND_CONFIG_INT_INUSE  0x00000009

#define SOUND_CONFIG_NOINT      0x0000000A
#define SOUND_CONFIG_NODMA      0x0000000B


#define PARMS_SUBKEY                  L"Parameters"
#define SOUND_DEVICES_SUBKEY          L"Devices"
#define SOUND_DRIVER_PARMS            L"DriverParameters"

#define REG_VALUENAME_LEFTMASTER      L"LeftMasterVolumeAtten"
#define REG_VALUENAME_RIGHTMASTER     L"RightMasterVolumeAtten"
#define REG_VALUENAME_LEFTLINEIN      L"LeftLineInAtten"
#define REG_VALUENAME_RIGHTLINEIN     L"RightLineInAtten"
#define REG_VALUENAME_LEFTDAC         L"LeftDACAtten"
#define REG_VALUENAME_RIGHTDAC        L"RightDACAtten"
#define REG_VALUENAME_LEFTMICMIX      L"LeftMicMixAtten"
#define REG_VALUENAME_RIGHTMICMIX     L"RightMicMixAtten"
#define REG_VALUENAME_LEFTADC         L"LeftADCAtten"
#define REG_VALUENAME_RIGHTADC        L"RightADCAtten"
#define REG_VALUENAME_LEFTSYNTH       L"LeftSynthAtten"
#define REG_VALUENAME_RIGHTSYNTH      L"RightSynthAtten"


//
// Input source selection
//

#define INPUT_LINEIN            0
#define INPUT_AUX               1
#define INPUT_MIC               2
#define INPUT_OUTPUT            3

//
// Default volume settings on initial install
//

#define DEF_ADC_VOLUME    0x24000000
#define DEF_DAC_VOLUME    0x24000000
#define DEF_SYNTH_VOLUME  0x24000000
#define DEF_AUX_VOLUME    0x24000000
#define DEF_MICMIX_VOLUME 0x00000000

/****************************************************************************

 Device Types

 ***************************************************************************/

//
// Device type flags used in the local info structure
//

#define WAVE_IN             0x01    // Wave in device
#define WAVE_OUT            0x02    // Wave out device
#define MIDI_IN             0x03    // Midi in device
#define MIDI_OUT            0x04    // Midi out device
#define AUX_DEVICE          0x05    // aux device
#define MIXER_DEVICE        0x06    // Mixer device
#define SYNTH_DEVICE        0x07    // Synth device (adlib or opl3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\duser.h ===
#if !defined(INC__DUser_h__INCLUDED)
#define INC__DUser_h__INCLUDED


// 
// Setup implied switches
//

#ifdef _GDIPLUS_H
#if !defined(GADGET_ENABLE_GDIPLUS)
#define GADGET_ENABLE_GDIPLUS
#endif
#endif


#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif


//
// Object declaration wrappers
//

#define BEGIN_ENUM(name)                \
    struct name                         \
    {                                   \
        enum E;                         \
                                        \
        inline name()                   \
        {                               \
        }                               \
                                        \
        inline name(E src)              \
        {                               \
            value = src;                \
        }                               \
                                        \
        inline void operator=(E e)      \
        {                               \
            value = e;                  \
        }                               \
                                        \
        inline bool operator==(E e)     \
        {                               \
            return value == e;          \
        }                               \
                                        \
        inline bool operator!=(E e)     \
        {                               \
            return value != e;          \
        }                               \
                                        \
        inline bool operator<(E e)      \
        {                               \
            return value < e;           \
        }                               \
                                        \
        inline bool operator<=(E e)     \
        {                               \
            return value <= e;          \
        }                               \
                                        \
        inline bool operator>(E e)      \
        {                               \
            return value > e;           \
        }                               \
                                        \
        inline bool operator>=(E e)     \
        {                               \
            return value >= e;          \
        }                               \
                                        \
        inline operator E() const       \
        {                               \
            return value;               \
        }                               \
                                        \
        enum E                          \
        {                               \


#define END_ENUM()                      \
        } value;                        \
    };                                  \


//
// Include external DirectUser definitions.
//

#include <ObjBase.h>            // "interface", STDMETHOD, and CoCreateInstance
#include <unknwn.h>             // IUnknown

#include <DUserError.h>
#include <DUserColor.h>
#include <DUserGeom2D.h>
#include <DUserCore.h>
#include <DUserMotion.h>

#endif // INC__DUser_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\vjoydapi.h ===
/****************************************************************************
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
 *
 *  File: vjoydapi.h
 *  Content: VJOYDAPI service equates and structures
 *
 ***************************************************************************/

#define REGSTR_KEY_JOYFIXEDKEY "<FixedKey>"

#define MULTIMEDIA_OEM_ID 0x0440                /*  MS Reserved OEM # 34   */
#define VJOYD_DEVICE_ID (MULTIMEDIA_OEM_ID + 9)   /*  VJOYD API Device       */
#define VJOYD_Device_ID VJOYD_DEVICE_ID

#define VJOYD_Ver_Major 1
#define VJOYD_Ver_Minor 3                   /*  0=Win95 1=DX3 2=DX5 3=DX5a and DX7a */

/*
 *  VJOYDAPI_Get_Version
 *
 *  ENTRY:
 *   AX = 0
 *
 *  RETURNS:
 *  SUCCESS: AX == TRUE
 *  ERROR: AX == FALSE
 */
#define VJOYDAPI_GetVersion 0
#define VJOYDAPI_IOCTL_GetVersion VJOYDAPI_GetVersion

/*
 *  VJOYDAPI_GetPosEx
 *
 *  ENTRY:
 *  AX = 1
 *  DX = joystick id (0->15)
 *  ES:BX = pointer to JOYINFOEX struct
 *
 *  RETURNS:
 *  SUCCESS: EAX == MMSYSERR_NOERROR
 *  ERROR: EAX == JOYERR_PARMS
 *  JOYERR_UNPLUGGED
 */
#define VJOYDAPI_GetPosEx 1
#define VJOYDAPI_IOCTL_GetPosEx VJOYDAPI_GetPosEx

/*
 *  VJOYDAPI_GetPos
 *
 *  ENTRY:
 *  AX = 2
 *  DX = joystick id (0->15)
 *  ES:BX = pointer to JOYINFO struct
 *
 *  RETURNS:
 *  SUCCESS: EAX == MMSYSERR_NOERROR
 *  ERROR: EAX == JOYERR_PARMS
 *  JOYERR_UNPLUGGED
 */
#define VJOYDAPI_GetPos 2
#define VJOYDAPI_IOCTL_GetPos VJOYDAPI_GetPos
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\vjoydapi.inc ===
;***************************************************************************
;  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;  PURPOSE.
;  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
;  File: vjoydapi.h
;  Content: VJOYDAPI service equates and structures
;*************************************************************************
MULTIMEDIA_OEM_ID	EQU	0440H                ;  MS Reserved OEM # 34
VJOYD_DEVICE_ID	EQU	(MULTIMEDIA_OEM_ID+9)   ;  VJOYD API Device
VJOYD_Ver_Major	EQU	1
VJOYD_Ver_Minor	EQU	3                   ;  0=Win95 1=DX3 2=DX5 3=DX5a and DX7a
;  VJOYDAPI_Get_Version
;  ENTRY:
;   AX = 0
;  RETURNS:
;  SUCCESS: AX == TRUE
;  ERROR: AX == FALSE
VJOYDAPI_GetVersion	EQU	0
VJOYDAPI_IOCTL_GetVersion	EQU	VJOYDAPI_GetVersion
;  VJOYDAPI_GetPosEx
;  ENTRY:
;  AX = 1
;  DX = joystick id (0->15)
;  ES:BX = pointer to JOYINFOEX struct
;  RETURNS:
;  SUCCESS: EAX == MMSYSERR_NOERROR
;  ERROR: EAX == JOYERR_PARMS
;  JOYERR_UNPLUGGED
VJOYDAPI_GetPosEx	EQU	1
VJOYDAPI_IOCTL_GetPosEx	EQU	VJOYDAPI_GetPosEx
;  VJOYDAPI_GetPos
;  ENTRY:
;  AX = 2
;  DX = joystick id (0->15)
;  ES:BX = pointer to JOYINFO struct
;  RETURNS:
;  SUCCESS: EAX == MMSYSERR_NOERROR
;  ERROR: EAX == JOYERR_PARMS
;  JOYERR_UNPLUGGED
VJOYDAPI_GetPos	EQU	2
VJOYDAPI_IOCTL_GetPos	EQU	VJOYDAPI_GetPos
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\dusercore.h ===
/***************************************************************************\
*
* File: DUserCore.h
*
* Description:
* DUserCore.h defines the DirectUser/Core, the low-level composition engine.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserCore_h__INCLUDED)
#define INC__DUserCore_h__INCLUDED

/*
 * Include dependencies
 */

#include <limits.h>             // Standard constants

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************\
*
* Basics
*
\***************************************************************************/

DECLARE_HANDLE(HGADGET);
DECLARE_HANDLE(HDCONTEXT);
DECLARE_HANDLE(HCLASS);

DUSER_API   BOOL        WINAPI  DeleteHandle(HANDLE h);
DUSER_API   BOOL        WINAPI  IsStartDelete(HANDLE h, BOOL * pfStarted);

#define IGTM_MIN                (0)     // +
#define IGTM_NONE               (0)     // | No special threading model
#define IGTM_SINGLE             (1)     // | Single threaded application
#define IGTM_SEPARATE           (2)     // | MT with single thread per context 
#define IGTM_MAX                (2)     // +

#define IGMM_MIN                (1)     // +
#define IGMM_COMPATIBLE         (1)     // | Core running in Compatible mode
#define IGMM_ADVANCED           (2)     // | Core running in Advanced mode
#define IGMM_STANDARD           (3)     // | Standard mode on Whistler
#define IGMM_MAX                (3)     // +

#define IGPM_MIN                (0)     // +
#define IGPM_BLEND              (0)     // | Optimize for blend between speed / size
#define IGPM_SPEED              (1)     // | Optimize for pure speed
#define IGPM_SIZE               (2)     // | Optimize for minimum working set
#define IGPM_MAX                (2)     // +

typedef struct tagINITGADGET
{
    DWORD       cbSize;         // Size of structure
    UINT        nThreadMode;    // Threading model
    UINT        nMsgMode;       // DirectUser/Core messaging subsystem mode
    UINT        nPerfMode;      // Performance tuning mode
    UINT        nDevice;        // Rendering device
    HDCONTEXT   hctxShare;      // Existing context to share with
} INITGADGET;

DUSER_API   HDCONTEXT   WINAPI  InitGadgets(INITGADGET * pInit);
DUSER_API   HRESULT     WINAPI  DUserGetThreadContext(HDCONTEXT * phctx);

#define IGC_MIN             (1)
#define IGC_GDIPLUS         (1) // GDI+
#define IGC_MAX             (1)

DUSER_API   BOOL        WINAPI  InitGadgetComponent(UINT nOptionalComponent);
DUSER_API   BOOL        WINAPI  UninitGadgetComponent(UINT nOptionalComponent);

DUSER_API   HDCONTEXT   WINAPI  GetContext(HANDLE h);
DUSER_API   BOOL        WINAPI  IsInsideContext(HANDLE h);

#ifdef __cplusplus

#define BEGIN_STRUCT(name, baseclass) \
    struct name : baseclass {

#define END_STRUCT(name)   \
    };

#define FORWARD_STRUCT(name) \
    struct name;

#else

#define BEGIN_STRUCT(name, baseclass) \
    typedef struct tag##name {  \
        baseclass;

#define END_STRUCT(name) \
    } name;

#define FORWARD_STRUCT(name) \
    typedef struct name;

#endif


/***************************************************************************\
*
* Messaging and Events
*
\***************************************************************************/

#define GMF_DIRECT              0x00000000  // + When message reaches hgadMsg
#define GMF_ROUTED              0x00000001  // | Before message reaches hgadMsg
#define GMF_BUBBLED             0x00000002  // | After message reaches hgadMsg
#define GMF_EVENT               0x00000003  // | After message becomes an event
#define GMF_DESTINATION         0x00000003  // + Destination of message

typedef int MSGID;
typedef int PRID;

// New Messages
typedef struct tagGMSG
{
    DWORD       cbSize;         // (REQUIRED) Size of message in bytes
    MSGID       nMsg;           // (REQUIRED) Gadget message
} GMSG;

BEGIN_STRUCT(MethodMsg, GMSG)
END_STRUCT(MethodMsg)

BEGIN_STRUCT(EventMsg, MethodMsg)
    HGADGET     hgadMsg;        // (REQUIRED) Gadget that message is "about"
    UINT        nMsgFlags;      // Flags about message
END_STRUCT(EventMsg)


#define GET_EVENT_DEST(pmsg) \
    (pmsg->nMsgFlags & GMF_DESTINATION)

#define SET_EVENT_DEST(pmsg, dest) \
    (pmsg->nMsgFlags = ((pmsg->nMsgFlags & ~GMF_DESTINATION) | (dest & GMF_DESTINATION)))

#define DEFINE_EVENT(event, guid)       \
    struct __declspec(uuid(guid)) event


/***************************************************************************\
*
* Gadget Classes
*
\***************************************************************************/

#ifndef __cplusplus
#error Requires C++ to compile
#endif

}; // extern "C" 

namespace DUser
{

// Forward declarations
class Gadget;
class SGadget;
struct MessageInfoStub;

};

DUSER_API   HRESULT     WINAPI  DUserDeleteGadget(DUser::Gadget * pg);
DUSER_API   HGADGET     WINAPI  DUserCastHandle(DUser::Gadget * pg);

namespace DUser
{

#define dapi
#define devent

//
// Core Classes
//

class Gadget
{
public:
            void *      m_pDummy;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (this));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(this);
    }

            HRESULT     CallStubMethod(MethodMsg * pmsg);
            HRESULT     CallSuperMethod(MethodMsg * pmsg, void * pMT);
            
            UINT        CallStubEvent(EventMsg * pmsg, int nEventMsg);
            UINT        CallSuperEvent(EventMsg * pmsg, void * pMT, int nEventMsg);

    enum ConstructCommand
    {
        ccSuper         = 0,        // Construct the super-class
        ccSetThis       = 1,        // Set this pointer
    };

    struct ConstructInfo
    {
    };
};


class SGadget
{
public:
            Gadget *    m_pgad;
    static  HCLASS      s_hclSuper;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (m_pgad));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(m_pgad);
    }
};

typedef HRESULT (SGadget::*MethodProc)(MethodMsg * pmsg);
typedef HRESULT (SGadget::*EventProc)(EventMsg * pmsg);


interface ISimpleImage;
interface ISimpleText;

BEGIN_ENUM(GraphicsType)
    Min         = 0,
    None        = 0,
    HDC         = 1,
    GpGraphics  = 2,
    D3d8Device  = 3,
    D3d7Device  = 4,
    Max         = 4,
END_ENUM()

BEGIN_ENUM(AlphaType)
    Min             = 0,
    None            = 0,
    Normal          = 1,
    Premultiplied   = 2,
    Max             = 2,
END_ENUM()


interface __declspec(uuid("{8C99782F-3B31-4965-823D-F7D86F0D3FA0}")) ISurface;
interface ISurface : IUnknown
{
    STDMETHOD(GetType)(GraphicsType * ptype) PURE;
    STDMETHOD(GetAlphaType)(AlphaType * pat) PURE;
    STDMETHOD(GetBitmapSize)(DirectUser::Geometry::SizeF * psizefPxl) PURE;
    STDMETHOD(GetSurfaceSize)(DirectUser::Geometry::SizeF * psizefPxl) PURE;
    STDMETHOD(GetRawSurface)(void ** ppRawSurface) PURE;
    STDMETHOD(GetGenerationCount)(int * pcGeneration) PURE;
    
    STDMETHOD(NotifyDestroyedOwner)() PURE;
#if DBG    
    STDMETHOD(DEBUG_SetDescription)(LPCWSTR pszDescription) PURE;
#endif
};


interface __declspec(uuid("{EFA21455-188D-49e4-893D-7F90B6BBC7BF}")) ISurfaceOwner;
interface ISurfaceOwner : IUnknown
{
    STDMETHOD(GetSurface)(ISurface ** ppSurface) PURE;
    STDMETHOD(OnLostSurface)(bool fNewSurface) PURE;
    STDMETHOD(OnDeviceDestroy)() PURE;
};


BEGIN_ENUM(SurfaceOptions)
    Durable     = 0x00000001,               // Surface contents are memory backed
    pExternal   = 0x40000000,               // INTERNAL: Surface was externally allocated
    Valid       = Durable,                  // Valid flags
    pValidInternal =                        // INTERNAL: Valid external & internal flags
                Valid | pExternal
END_ENUM()


interface __declspec(uuid("{8B88AAF5-4F0D-44a0-ADC9-A7CE1970E11F}")) IDevice;
interface IDevice : IUnknown
{
    STDMETHOD(GetType)(GraphicsType * ptype) PURE;
    STDMETHOD(OpenDevice)(REFIID riid, void ** ppvDevice) PURE;
    STDMETHOD(CloseDevice)() PURE;
    STDMETHOD(CreateSurface)(ISurfaceOwner * pOwner, DirectUser::Geometry::Size sizeRequestPxl, AlphaType at, UINT nFlags, ISurface ** ppSurface) PURE;

    STDMETHOD(MarkInvalidContent)() PURE;
};


interface __declspec(uuid("{7F9AAAF0-41E9-4e69-907A-11784B892DF6}")) ID3d7Device;
interface ID3d7Device : IUnknown
{
    STDMETHOD(CreateSurface)(ISurfaceOwner * pOwner, IUnknown * pRawSurface, DirectUser::Geometry::Size sizeRequestPxl, AlphaType at, ISurface ** ppSurface) PURE;
    STDMETHOD(GetCaps)(void * pvCaps) PURE;
    STDMETHOD(BeginVideoSurfaceAllocation)() PURE;
    STDMETHOD(EndVideoSurfaceAllocation)() PURE;
};


#if DBG

interface __declspec(uuid("{D4302C96-F44D-42f8-A2A1-C4E8FF896302}")) IDebugDevice;
interface IDebugDevice : IUnknown
{
    STDMETHOD(Invoke)(LPCWSTR pszCommand) PURE;
};

#endif


interface __declspec(uuid("{5AE21A59-F163-41d7-ACF7-C2F643D39711}")) IGraphics;
interface IGraphics : IUnknown
{
    STDMETHOD(GetType)(GraphicsType * ptype) PURE;
    STDMETHOD(OpenGraphics)(REFIID riid, void ** ppvDevice) PURE;
    STDMETHOD(CloseGraphics)() PURE;
};


interface __declspec(uuid("{03AB8158-6646-4c2f-B97A-8A2EE13BABCE}")) ID3d7Graphics;
interface ID3d7Graphics : public IUnknown
{
    STDMETHOD(GetVertexAlpha)(BYTE * pbAlpha) PURE;
    STDMETHOD(PushVertexAlpha)(BYTE bAlpha) PURE;
    STDMETHOD(PopVertexAlpha)() PURE;
    STDMETHOD(TransformPoints)(DirectUser::Geometry::PointF * rgptfIn, int cPts) PURE;
};


interface __declspec(uuid("{4F6A8A17-67B1-4ecd-B344-FD7B83C02C82}")) IRenderOperation;
interface IRenderOperation : public IUnknown
{
    STDMETHOD(Before)(IGraphics * pgr, DirectUser::Geometry::RectF rcfGadgetPxl) PURE;
    STDMETHOD(After)() PURE;
    STDMETHOD(CleanUp)() PURE;
};


interface __declspec(uuid("{6CDAF326-1C4E-4a50-B02E-60BA14545178}")) ISimpleSession;
interface ISimpleSession : IUnknown
{
    STDMETHOD(CreateImage)(HBITMAP hbmp, BOOL fPreMultiplied, ISimpleImage ** ppImg) PURE;
    STDMETHOD(LoadImage)(LPCWSTR pszFileName, ISimpleImage ** ppImg) PURE;
    STDMETHOD(LoadImage)(HINSTANCE hinstance, LPCWSTR pszName, LPCWSTR pszType, ISimpleImage ** ppImg) PURE;
    STDMETHOD(LoadImage)(IStream * pStream, ISimpleImage ** ppImg) PURE;
    
    STDMETHOD(CreateText)(LPCWSTR pszText, ISimpleText ** ppText) PURE;

    STDMETHOD(CreateSolidFillRO)(DUser::Color clr, DUser::IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateSolidFillRO)(DUser::Color clr, DirectUser::Geometry::RectF rcfDest, DUser::IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateSurfaceRO)(ISurface * psrf, IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateSurfaceRO)(ISurface * psrf, DirectUser::Geometry::RectF rcfSrc, DirectUser::Geometry::RectF rcfDest, IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateDDrawRO)(IUnknown * pdds, DirectUser::Geometry::RectF rcfSrc, DirectUser::Geometry::RectF rcfDest, IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateDDrawSolidFillRO)(DUser::Color clr, DirectUser::Geometry::RectF rcfDest, DUser::IRenderOperation ** pproNew) PURE;
};


interface __declspec(uuid("{D79ADD77-2F8F-470e-B964-025CBD947985}")) ISimpleImage;
interface ISimpleImage : IUnknown
{
    STDMETHOD(GetType)(GraphicsType * ptype) PURE;
    STDMETHOD(GetSize)(DirectUser::Geometry::Size * psizePxl) PURE;

    STDMETHOD(CreateRenderOperation)(IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateRenderOperation)(DirectUser::Geometry::RectF rcfSrc, IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateRenderOperation)(DirectUser::Geometry::RectF rcfSrc, DirectUser::Geometry::RectF rcfDst, IRenderOperation ** pproNew) PURE;
};


interface __declspec(uuid("{46CB2632-90D4-4c05-87E6-6959F15A0431}")) ISimpleText;
interface ISimpleText : IUnknown
{
    STDMETHOD(GetType)(GraphicsType * ptype) PURE;
    STDMETHOD(GetText)(LPWSTR psz, int cch) PURE;
    STDMETHOD(SetText)(LPCWSTR psz, int cch) PURE;
    STDMETHOD(GetFont)(HFONT* phfont) PURE;
    STDMETHOD(SetFont)(HFONT hfont) PURE;
    STDMETHOD(GetScale)(DirectUser::Geometry::SizeF * psizefScale) PURE;
    STDMETHOD(SetScale)(DirectUser::Geometry::SizeF sizefScale) PURE;
    STDMETHOD(GetColor)(DUser::Color* pclr) PURE;
    STDMETHOD(SetColor)(DUser::Color clr) PURE;
    STDMETHOD(GetBkColor)(DUser::Color* pclr) PURE;
    STDMETHOD(SetBkColor)(DUser::Color clr) PURE;
    STDMETHOD(GetFlags)(UINT* puFlags) PURE;
    STDMETHOD(SetFlags)(UINT uFlags) PURE;
    STDMETHOD(SetMaxWidth)(int nMaxWidth) PURE;
    STDMETHOD(GetCharacterSpacing)(float * pflFactor) PURE;
    STDMETHOD(SetCharacterSpacing)(float flFactor) PURE;
        
    STDMETHOD(ComputeSize)(DirectUser::Geometry::Size * psizeActualPxl) PURE;
    STDMETHOD(CreateRenderOperation)(IRenderOperation ** pproNew) PURE;
    STDMETHOD(CreateRenderOperation)(DirectUser::Geometry::RectF rcfSrc, IRenderOperation ** pproNew) PURE;
};

/*
interface __declspec(uuid("{B4F564EF-4816-484a-8A41-97D9C0AA5E1C}")) ISimpleModel;
interface ISimpleModel : IUnknown
{
    STDMETHOD(CreateRenderOperation)(IRenderOperation ** pproNew) PURE;
};
*/


//
// Delegate support
//

template <class type, class arg>
class Delegate
{
public:
    typedef HRESULT (CALLBACK type::*Proc)(arg * p1);

    static inline Delegate<type, arg>
    Build(type * pvThis, Proc pfn) 
    {
        Delegate<type, arg> d;
        d.m_pvThis  = pvThis;
        d.m_pfn     = pfn;
        return d;
    }

    inline HRESULT Invoke(arg * p1)
    {
        return (m_pvThis->*m_pfn)(p1);
    }

    type *      m_pvThis;
    Proc        m_pfn;
};


typedef Delegate<DUser::Gadget, EventMsg> EventDelegate;
#define EVENT_DELEGATE(instance, function) \
    DUser::EventDelegate::Build(reinterpret_cast<DUser::Gadget *>(instance), \
            reinterpret_cast<DUser::EventDelegate::Proc>(function))


//
// Typedef's
//

typedef HRESULT (CALLBACK * ConstructProc)(DUser::Gadget::ConstructCommand cmd, HCLASS hclCur, DUser::Gadget * pg, void * pvData);
typedef HRESULT (CALLBACK * PromoteProc)(ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pg, DUser::Gadget::ConstructInfo * pmicData);
typedef HCLASS  (CALLBACK * DemoteProc)(HCLASS hclCur, DUser::Gadget * pg, void * pvData);


//
// Message information and class structures
//

template<class t, class m>
inline void *
Method(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}

template<class t, class m>
inline void *
Event(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}


struct MessageInfoGuts
{
    void *      pfn;            // IN:  Implementation function
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassGuts
{
    DWORD       cbSize;         // IN:  Structure size
    DWORD       nClassVersion;  // IN:  This class's version
    LPCWSTR     pszClassName;   // IN:  Name of new class
    LPCWSTR     pszSuperName;   // IN:  Name of super-class
    MessageInfoGuts *           // IN:  Message information
                rgMsgInfo;
    int         cMsgs;          // IN:  Number of messages being registered
    PromoteProc pfnPromote;     // IN:  Promotion function
    DemoteProc  pfnDemote;      // IN:  Demotion function
    HCLASS      hclNew;         // OUT: Newly created class
    HCLASS      hclSuper;       // OUT: Newly created class's super
};

struct MessageInfoStub
{
    int         cbSlotOffset;   // OUT: Message slot offset
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassStub
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    DUser::MessageInfoStub *
                rgMsgInfo;
    int         cMsgs;
};

struct MessageClassSuper
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    void *      pmt;
};

}; // namespace DUser

extern "C" {

#define DRS_IMMEDIATE       0x00000001
#define DRS_VALID          (DRS_IMMEDIATE)

DUSER_API   HCLASS      WINAPI  DUserRegisterGuts(DUser::MessageClassGuts * pmc);
DUSER_API   HCLASS      WINAPI  DUserRegisterStub(DUser::MessageClassStub * pmc, UINT nFlags);
DUSER_API   HCLASS      WINAPI  DUserRegisterSuper(DUser::MessageClassSuper * pmc);
DUSER_API   HCLASS      WINAPI  DUserFindClass(LPCWSTR pszName, DWORD nVersion);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserBuildGadget(HCLASS hcl, DUser::Gadget::ConstructInfo * pmicData);

#define GCC_INPUT           0x00000001
#define GCC_VALID          (GCC_INPUT)

DUSER_API   HRESULT     WINAPI  DUserBuildHWndContainer(HWND hwnd, UINT nFlags, HCLASS hclRoot, DUser::Gadget ** ppgvRoot);
DUSER_API   HRESULT     WINAPI  DUserGetDevice(DUser::IDevice ** ppDevice);
DUSER_API   HRESULT     WINAPI  DUserBuildSession(DUser::IDevice * pDevice, DUser::ISimpleSession ** ppSession);

DUSER_API   BOOL        WINAPI  DUserClassInstanceOf(HCLASS hclSrc, HCLASS hclTest);
DUSER_API   BOOL        WINAPI  DUserInstanceOf(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastClass(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastDirect(HGADGET hgad);
DUSER_API   void *      WINAPI  DUserGetGutsData(DUser::Gadget * pg, HCLASS hclData);


/***************************************************************************\
*
* Messages
*
\***************************************************************************/

// Core messages
#define GM_EVENT            32768

#define GM_DESTROY          (1 + GM_EVENT)
#define GM_PAINT            (2 + GM_EVENT)
#define GM_INPUT            (3 + GM_EVENT)
#define GM_CHANGESTATE      (4 + GM_EVENT)
#define GM_CHANGERECT       (5 + GM_EVENT)
#define GM_CHANGESTYLE      (6 + GM_EVENT)
#define GM_QUERY            (7 + GM_EVENT)
#define GM_SYNCADAPTOR      (8 + GM_EVENT)
#define GM_LOSTDEVICE       (9 + GM_EVENT)

#define GM_USER             (1024 + GM_EVENT) // Starting point for user messages
#define GM_REGISTER         (1000000 + GM_EVENT) // Starting point for registered messages

// Win32 Messages
// TODO: Move these to winuser.h
#define WM_GETROOTGADGET   (WM_USER - 1)

// Message filtering
#define GMFI_PAINT          0x00000001
#define GMFI_INPUTKEYBOARD  0x00000002
#define GMFI_INPUTMOUSE     0x00000004
#define GMFI_INPUTMOUSEMOVE 0x00000008
#define GMFI_CHANGESTATE    0x00000010
#define GMFI_CHANGERECT     0x00000020
#define GMFI_CHANGESTYLE    0x00000040
#define GMFI_ALL            0xFFFFFFFF
#define GMFI_VALID         (GMFI_PAINT |                                                 \
                            GMFI_INPUTKEYBOARD | GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | \
                            GMFI_CHANGESTATE | GMFI_CHANGERECT | GMFI_CHANGESTYLE)

#define GDESTROY_START      1   // Gadget has started the destruction process
#define GDESTROY_FINAL      2   // Gadget has been fully destroyed

BEGIN_STRUCT(GMSG_DESTROY, EventMsg)
    UINT        nCode;          // Destruction code
END_STRUCT(GMSG_DESTROY)

#define GINPUT_MOUSE        0
#define GINPUT_KEYBOARD     1
#define GINPUT_JOYSTICK     2

BEGIN_STRUCT(GMSG_INPUT, EventMsg)
    UINT        nDevice;        // Input device
    UINT        nCode;          // Specific action
    UINT        nModifiers;     // ctrl, alt, shift, leftbutton, middlebutton, rightbutton
    LONG        lTime;          // Time when message was sent
END_STRUCT(GMSG_INPUT)


#define GMOUSE_MOVE         0
#define GMOUSE_DOWN         1
#define GMOUSE_UP           2
#define GMOUSE_DRAG         3
#define GMOUSE_HOVER        4
#define GMOUSE_WHEEL        5
#define GMOUSE_MAX          5

#define GBUTTON_NONE        0
#define GBUTTON_LEFT        1
#define GBUTTON_RIGHT       2
#define GBUTTON_MIDDLE      3
#define GBUTTON_MAX         3

#define GMODIFIER_LCONTROL  0x00000001
#define GMODIFIER_RCONTROL  0x00000002
#define GMODIFIER_LSHIFT    0x00000004
#define GMODIFIER_RSHIFT    0x00000008
#define GMODIFIER_LALT      0x00000010
#define GMODIFIER_RALT      0x00000020
#define GMODIFIER_LBUTTON   0x00000040
#define GMODIFIER_RBUTTON   0x00000080
#define GMODIFIER_MBUTTON   0x00000100

#define GMODIFIER_CONTROL   (GMODIFIER_LCONTROL | GMODIFIER_RCONTROL)
#define GMODIFIER_SHIFT     (GMODIFIER_LSHIFT   | GMODIFIER_RSHIFT)
#define GMODIFIER_ALT       (GMODIFIER_LALT     | GMODIFIER_RALT)

BEGIN_STRUCT(GMSG_MOUSE, GMSG_INPUT)
    POINT       ptClientPxl;    // Mouse location in client coordinates
    BYTE        bButton;        // Mouse button
    UINT        nFlags;         // Misc. flags
END_STRUCT(GMSG_MOUSE)

BEGIN_STRUCT(GMSG_MOUSEDRAG, GMSG_MOUSE)
    SIZE        sizeDelta;      // Mouse drag distance
    BOOL        fWithin;        // Mouse within gadget's bounds
END_STRUCT(GMSG_MOUSEDRAG)

BEGIN_STRUCT(GMSG_MOUSECLICK, GMSG_MOUSE)
    UINT        cClicks;        // number of clicks in "quick" succession
END_STRUCT(GMSG_MOUSECLICK)

BEGIN_STRUCT(GMSG_MOUSEWHEEL, GMSG_MOUSE)
    short       sWheel;         // Wheel position
END_STRUCT(GMSG_MOUSEWHEEL)

#define GKEY_DOWN           0
#define GKEY_UP             1
#define GKEY_CHAR           2
#define GKEY_SYSDOWN        3
#define GKEY_SYSUP          4
#define GKEY_SYSCHAR        5

BEGIN_STRUCT(GMSG_KEYBOARD, GMSG_INPUT)
    WCHAR       ch;             // Character
    WORD        cRep;           // Repeat count
    WORD        wFlags;         // Misc. flags
END_STRUCT(GMSG_KEYBOARD)


BEGIN_STRUCT(PaintMsg, EventMsg)
    DUser::GraphicsType
                nSurfaceType;   // Surface type
    DirectUser::Geometry::RectF 
                rcfGadgetPxl;  // Logical position of Gadget
    DirectUser::Geometry::RectF 
                rcfInvalidPxl; // Invalid rectangle in client coordinates
    DUser::IGraphics * 
                pgr;            // Graphics to draw into
END_STRUCT(PaintMsg)


#define GSTATE_KEYBOARDFOCUS    0
#define GSTATE_MOUSEFOCUS       1
#define GSTATE_ACTIVE           2
#define GSTATE_CAPTURE          3

#define GSC_SET             0
#define GSC_LOST            1

BEGIN_STRUCT(GMSG_CHANGESTATE, EventMsg)
    UINT        nCode;          // Change command
    HGADGET     hgadSet;        // Gadget that is receiving the "state"
    HGADGET     hgadLost;       // Gadget that is loosing the "state"
    UINT        nCmd;           // Action that occurred
END_STRUCT(GMSG_CHANGESTATE)


BEGIN_STRUCT(GMSG_CHANGESTYLE, EventMsg)
    UINT        nNewStyle;      // New style
    UINT        nOldStyle;      // Old style
END_STRUCT(GMSG_CHANGESTYLE)


BEGIN_STRUCT(GMSG_CHANGERECT, EventMsg)
    RECT        rcNewRect;
    UINT        nFlags;
END_STRUCT(GMSG_CHANGERECT)


#define GQUERY_HITTEST      5
#define GQUERY_PADDING      6

BEGIN_STRUCT(GMSG_QUERY, EventMsg)
    UINT        nCode;          // Query command
END_STRUCT(GMSG_QUERY)


#define GQHT_NOWHERE        0   // Location is not "inside"
#define GQHT_INSIDE         1   // Location is generically "inside"
#define GQHT_CHILD          2   // Location is inside child specified by pvResultData
                                // (NOT YET IMPLEMENTED)

BEGIN_STRUCT(GMSG_QUERYHITTEST, GMSG_QUERY)
    POINT       ptClientPxl;    // Location in client pixels
    UINT        nResultCode;    // Result code
    void *      pvResultData;   // Extra result information
END_STRUCT(GMSG_QUERYHITTEST)


BEGIN_STRUCT(GMSG_QUERYPADDING, GMSG_QUERY)
    RECT        rcPadding;      // Extra padding around content
END_STRUCT(GMSG_QUERYPADDING)


#define GSYNC_RECT          (1)
#define GSYNC_XFORM         (2)
#define GSYNC_STYLE         (3)
#define GSYNC_PARENT        (4)

BEGIN_STRUCT(GMSG_SYNCADAPTOR, EventMsg)
    UINT        nCode;          // Change code
END_STRUCT(GMSG_SYNCADAPTOR)

BEGIN_STRUCT(GMSG_LOSTDEVICE, EventMsg)
    BOOL        fLost;          // FALSE -> device was lost, else device came back
END_STRUCT(GMSG_LOSTDEVICE)


typedef HRESULT     (CALLBACK * GADGETPROC)(HGADGET hgadCur, void * pvCur, EventMsg * pMsg);

#define SGM_FULL            0x00000001      // Route and bubble the message
#define SGM_RECEIVECONTEXT  0x00000002      // Use the receiving Gadget's Context
#define SGM_VALID          (SGM_FULL | SGM_RECEIVECONTEXT)

typedef struct tagFGM_INFO
{
    EventMsg* pmsg;             // Message to fire
    UINT        nFlags;         // Flags modifying message being fired
    HRESULT     hr;             // Result of message (if send)
    void *      pvReserved;     // Reserved
} FGM_INFO;

#define FGMQ_SEND           1   // Standard "Send" message queue
#define FGMQ_POST           2   // Standard "Post" message queue

DUSER_API   HRESULT     WINAPI  DUserSendMethod(DUser::Gadget * pgadMsg, MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserPostMethod(DUser::Gadget * pgadMsg, MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserSendEvent(EventMsg * pmsg, UINT nFlags);
DUSER_API   HRESULT     WINAPI  DUserPostEvent(EventMsg * pmsg, UINT nFlags);

DUSER_API   BOOL        WINAPI  FireGadgetMessages(FGM_INFO * rgFGM, int cMsgs, UINT idQueue);
DUSER_API   UINT        WINAPI  GetGadgetMessageFilter(HGADGET hgad, void * pvCookie);
DUSER_API   BOOL        WINAPI  SetGadgetMessageFilter(HGADGET hgad, void * pvCookie, UINT nNewFilter, UINT nMask);

DUSER_API   MSGID       WINAPI  RegisterGadgetMessage(const GUID * pguid);
DUSER_API   MSGID       WINAPI  RegisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessage(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  FindGadgetMessages(const GUID ** rgpguid, MSGID * rgnMsg, int cMsgs);

DUSER_API   BOOL        WINAPI  AddGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);
DUSER_API   BOOL        WINAPI  RemoveGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);

DUSER_API   BOOL        WINAPI  GetMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  GetMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  PeekMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  PeekMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  WaitMessageEx();

#ifdef UNICODE
#define GetMessageEx        GetMessageExW
#define PeekMessageEx       PeekMessageExW
#else
#define GetMessageEx        GetMessageExA
#define PeekMessageEx       PeekMessageExA
#endif


/***************************************************************************\
*
* Construction, Tree management
*
\***************************************************************************/

#define GC_HWNDHOST         0x00000001      // + Host inside an HWND
#define GC_NCHOST           0x00000002      // | Host inside Non-client of HWND
#define GC_COMPLEX          0x00000004      // | Complex TreeGadget
#define GC_SIMPLE           0x00000005      // | Simple TreeGadget
#define GC_DETACHED         0x00000006      // | Detached TreeGadget
#define GC_MESSAGE          0x00000007      // | Message-only Gadget
#define GC_TYPE             0x0000000F      // + Type of Gadget to create
#define GC_VALID           (GC_TYPE)

DUSER_API   HGADGET     WINAPI  CreateGadget(HANDLE hParent, UINT nFlags, GADGETPROC pfnProc, void * pvGadgetData);
DUSER_API   HRESULT     WINAPI  DUserBuildHWndContainer2(HWND hwnd, UINT nFlags, GADGETPROC pfnProc, void * pvData, HGADGET * phgadRoot);


#define GENUM_CURRENT       0x00000001      // Starting node in enumeration
#define GENUM_SIBLINGS      0x00000002      // Siblings of starting node in enumeration

                                            // + Type of enumeration (exclusive)
#define GENUM_PARENTSUP     0x00000004      // | Parents of this node going up
#define GENUM_PARENTSDOWN   0x00000008      // | Parents of this node going down
#define GENUM_SHALLOWCHILD  0x0000000C      // | Shallow children
#define GENUM_DEEPCHILD     0x00000010      // + Deep children
#define GENUM_TYPE         (GENUM_PARENTSUP | GENUM_PARENTSDOWN | \
                            GENUM_SHALLOWCHILD | GENUM_DEEPCHILD)

#define GENUM_MODIFYTREE    0x00000020      // Allow modifying the Tree during enumeration

#define GENUM_VALID         (GENUM_CURRENT | GENUM_SIBLINGS | GENUM_TYPE | GENUM_MODIFYTREE)

typedef BOOL    (CALLBACK * GADGETENUMPROC)(HGADGET hgad, void * pvData);

DUSER_API   BOOL        WINAPI  EnumGadgets(HGADGET hgadEnum, GADGETENUMPROC pfnProc, void * pvData, UINT nFlags);

#define GORDER_MIN          0
#define GORDER_ANY          0               // Order does not matter
#define GORDER_BEFORE       1               // Move this gadget in-front of sibling
#define GORDER_BEHIND       2               // Move this gadget behind sibling
#define GORDER_TOP          3               // Move to front of sibling z-order
#define GORDER_BOTTOM       4               // Move to bottom of sibling z-order
#define GORDER_FORWARD      5               // Move forward in z-order
#define GORDER_BACKWARD     6               // Move backward in z-order
#define GORDER_MAX          6

DUSER_API   BOOL        WINAPI  SetGadgetOrder(HGADGET hgadMove, HGADGET hgadOther, UINT nCmd);
DUSER_API   BOOL        WINAPI  SetGadgetParent(HGADGET hgadMove, HGADGET hgadParent, HGADGET hgadOther, UINT nCmd);


#define GR_MIN              0
#define GR_PARENT           0
#define GR_NEXT             1
#define GR_PREV             2
#define GR_TOPCHILD         3
#define GR_BOTTOMCHILD      4
#define GR_ROOT             5
#define GR_MAX              5

DUSER_API   HGADGET     WINAPI  GetGadgetRelative(HGADGET hgad, UINT nCmd);

/***************************************************************************\
*
* Styles and properties
*
\***************************************************************************/

#define GS_VISIBLE          0x00000001      // Drawing is visible
#define GS_ENABLED          0x00000002      // Input in "enabled"
#define GS_KEYBOARDFOCUS    0x00000004      // Gadget can receive keyboard focus
#define GS_MOUSEFOCUS       0x00000008      // Gadget can receive mouse focus
#define GS_CLIPINSIDE       0x00000010      // Clip drawing inside this Gadget
#define GS_HREDRAW          0x00000020      // Redraw entire Gadget if resized horizontally
#define GS_VREDRAW          0x00000040      // Redraw entire Gadget if resized vertically
#define GS_ZEROORIGIN       0x00000080      // Set origin to (0,0)
#define GS_CUSTOMHITTEST    0x00000100      // Requires custom hit-testing
#define GS_ADAPTOR          0x00000200      // Requires extra notifications to host
#define GS_NORESETINVALID   0x00000400      // Once invalidated, Gadget stays invalid

#define GS_VALID           (GS_VISIBLE | GS_ENABLED | GS_KEYBOARDFOCUS | GS_MOUSEFOCUS | \
                            GS_CLIPINSIDE | GS_HREDRAW | GS_VREDRAW | GS_ZEROORIGIN | \
                            GS_CUSTOMHITTEST | GS_ADAPTOR | GS_NORESETINVALID)

DUSER_API   UINT        WINAPI  GetGadgetStyle(HGADGET hgad);
DUSER_API   BOOL        WINAPI  SetGadgetStyle(HGADGET hgadChange, UINT nNewStyle, UINT nMask);

DUSER_API   HGADGET     WINAPI  GetGadgetFocus();
DUSER_API   BOOL        WINAPI  SetGadgetFocus(HGADGET hgadFocus);
DUSER_API   BOOL        WINAPI  IsGadgetParentChainStyle(HGADGET hgad, UINT nStyle, BOOL * pfVisible, UINT nFlags);

inline BOOL IsGadgetVisible(HGADGET hgad, BOOL * pfVisible, UINT nFlags) 
{
    return IsGadgetParentChainStyle(hgad, GS_VISIBLE, pfVisible, nFlags); 
}

inline BOOL IsGadgetEnabled(HGADGET hgad, BOOL * pfEnabled, UINT nFlags) 
{
    return IsGadgetParentChainStyle(hgad, GS_ENABLED, pfEnabled, nFlags); 
}


DUSER_API   PRID        WINAPI  RegisterGadgetProperty(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetProperty(const GUID * pguid);

DUSER_API   BOOL        WINAPI  GetGadgetProperty(HGADGET hgad, PRID id, void ** ppvValue);
DUSER_API   BOOL        WINAPI  SetGadgetProperty(HGADGET hgad, PRID id, void * pvValue);
DUSER_API   BOOL        WINAPI  RemoveGadgetProperty(HGADGET hgad, PRID id);


struct GADGET_DESCRIPTION
{
    DWORD       cbSize;
    wchar_t     szName[128];
    wchar_t     szType[128];
    wchar_t     szStyle[1024];
};

DUSER_API   BOOL        WINAPI  GetGadgetDescription(HGADGET hgad, GADGET_DESCRIPTION * pgd);
DUSER_API   BOOL        WINAPI  SetGadgetDescription(HGADGET hgad, const GADGET_DESCRIPTION * pgd);


/***************************************************************************\
*
* Painting, Transforms
*
\***************************************************************************/

#define BLEND_OPAQUE        255
#define BLEND_TRANSPARENT   0

#define PI                  3.14159265359

#define IG_ME               0x00000001
#define IG_CHILDREN         0x00000002
#define IG_VALID           (IG_ME | IG_CHILDREN)

DUSER_API   BOOL        WINAPI  InvalidateGadget(HGADGET hgad, UINT nFlags);


/***************************************************************************\
*
* Position
*
\***************************************************************************/

#define SGR_MOVE            0x00000001      // Gadget is being moved
#define SGR_SIZE            0x00000002      // Gadget is being resized
#define SGR_CHANGEMASK     (SGR_MOVE | SGR_SIZE)
#define SGR_NOINVALIDATE    0x00000200      // Don't automatically invalidate

#define SGR_VALID_SET      (SGR_CHANGEMASK | SGR_NOINVALIDATE)

DUSER_API   BOOL        WINAPI  GetGadgetSize(HGADGET hgad, DirectUser::Geometry::Size * psizeLogicalPxl);
DUSER_API   BOOL        WINAPI  GetGadgetRect(HGADGET hgad, RECT * prcPxl, UINT nFlags);
DUSER_API   BOOL        WINAPI  SetGadgetRect(HGADGET hgadChange, int x, int y, int w, int h, UINT nFlags);

DUSER_API   HGADGET     WINAPI  FindGadgetFromPoint(HGADGET hgadRoot, POINT ptContainerPxl, UINT nStyle, POINT * pptClientPxl);
DUSER_API   BOOL        WINAPI  MapGadgetPoints(HGADGET hgadFrom, HGADGET hgadTo, POINT * rgptClientPxl, int cPts);


/***************************************************************************\
*
* Tickets
*
\***************************************************************************/

DUSER_API   DWORD        WINAPI  GetGadgetTicket(HGADGET hgad);
DUSER_API   HGADGET      WINAPI  LookupGadgetTicket(DWORD dwTicket);


/***************************************************************************\
*
* Special hooks for different containers
*
\***************************************************************************/

DUSER_API   BOOL        WINAPI  ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr);

#define GDRAW_SHOW          0x00000001
#define GDRAW_VALID         (GDRAW_SHOW)

DUSER_API   HRESULT     WINAPI  DrawGadgetTree(HGADGET hgadDraw, HDC hdcDraw, const RECT * prcDraw, UINT nFlags);

typedef BOOL (CALLBACK* ATTACHWNDPROC)(void * pvThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRet);
DUSER_API   BOOL        WINAPI  AttachWndProcA(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);

#ifdef UNICODE
#define AttachWndProc       AttachWndProcW
#else
#define AttachWndProc       AttachWndProcA
#endif

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\dusercolor.h ===
/***************************************************************************\
*
* File: Color.h
*
* Description:
* Color defines a standard lightweight object for a color.
*
*
* History:
*  2/10/2001: JStall:       Copied from \windows\AdvCore\Gdiplus\sdkinc\GdiplusColor.h
*
* Copyright (C) 2001 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(DUSERX__Color_h__INCLUDED)
#define DUSERX__Color_h__INCLUDED
#pragma once

typedef DWORD D3DCOLOR;

namespace DUser
{
    
//------------------------------------------------------------------------------
class Color
{
// Construction
public:
    inline Color()
    {
        m_argb = 0;
    }

    inline Color(
        IN  D3DCOLOR argb)
    {
        m_argb = argb;
    }

#ifdef GADGET_ENABLE_GDIPLUS    
    inline Color(
        IN  Gdiplus::Color cr)
    {
        m_argb = cr.GetValue();
    }
#endif

    inline Color(
        IN  BYTE r,
        IN  BYTE g,
        IN  BYTE b)
    {
        m_argb = MakeARGB(255, r, g, b);
    }

    inline Color(
        IN  BYTE a,
        IN  BYTE r,
        IN  BYTE g,
        IN  BYTE b)
    {
        //
        // NOTE: r, g, b values are NOT premultiplied.
        //
        
        m_argb = MakeARGB(a, r, g, b);
    }

// Operations
public:
    inline BYTE GetAlpha() const
    {
        return (BYTE) (m_argb >> AlphaShift);
    }

    inline float GetAlphaF() const
    {
        return GetAlpha() / 255.0f;
    }
    
    inline void SetAlpha(
        IN  BYTE bAlpha)
    {
        m_argb = (m_argb & ~AlphaMask) | (bAlpha << AlphaShift);
    }

    inline BYTE GetRed() const
    {
        return (BYTE) (m_argb >> RedShift);
    }

    inline float GetRedF() const
    {
        return GetRed() / 255.0f;
    }

    inline void SetRed(
        IN  BYTE bRed)
    {
        m_argb = (m_argb & ~RedMask) | (bRed << RedShift);
    }

    inline BYTE GetGreen() const
    {
        return (BYTE) (m_argb >> GreenShift);
    }

    inline float GetGreenF() const
    {
        return GetGreen() / 255.0f;
    }

    inline void SetGreen(
        IN  BYTE bGreen)
    {
        m_argb = (m_argb & ~GreenMask) | (bGreen << GreenShift);
    }

    inline BYTE GetBlue() const
    {
        return (BYTE) (m_argb >> BlueShift);
    }

    inline float GetBlueF() const
    {
        return GetBlue() / 255.0f;
    }

    inline void SetBlue(
        IN  BYTE bBlue)
    {
        m_argb = (m_argb & ~BlueMask) | (bBlue << BlueShift);
    }

#ifdef GADGET_ENABLE_GDIPLUS    
    inline operator Gdiplus::Color() const
    {
        return Gdiplus::Color(m_argb);
    }
#endif

    inline operator D3DCOLOR() const
    {
        return m_argb;
    }

    inline DWORD GetXRGB() const
    {
        // Add full alpha level
        return m_argb | AlphaMask;
    }

    inline DWORD GetARGB() const
    {
        return m_argb;
    }

    inline VOID SetXRGB(
        IN  DWORD rgb)
    {
        // Set full alpha level
        m_argb = rgb | AlphaMask;
    }

    inline VOID SetARGB(
        IN  DWORD argb)
    {
        m_argb = argb;
    }

    inline COLORREF GetCR() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

    inline VOID SetCR(
        IN  COLORREF rgb)
    {
        m_argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    // Shift count and bit mask for A, R, G, B components
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    inline static DWORD MakeARGB(
        IN BYTE a,
        IN BYTE r,
        IN BYTE g,
        IN BYTE b)
    {
        return (((DWORD) (b) << BlueShift) |
                ((DWORD) (g) << GreenShift) |
                ((DWORD) (r) << RedShift) |
                ((DWORD) (a) << AlphaShift));
    }
        
// Data
protected:
            DWORD       m_argb;
};

} // namespace DUser

#endif // DUSERX__Color_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\dusererror.h ===
/***************************************************************************\
*
* File: DUserError.h
*
* Description:
* DUserError.h defines the DirectUser error values common across all of
* DirectUser.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserError_h__INCLUDED)
#define INC__DUserError_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#define FACILITY_DUSER  FACILITY_ITF
#define MAKE_DUSUCCESS(code)    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DUSER, code)
#define MAKE_DUERROR(code)      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DUSER, code)

/***************************************************************************\
*
* Error codes
*
\***************************************************************************/

// Callback function definitions

/*
 * Message was not handled at all.
 */
#define DU_S_NOTHANDLED             MAKE_DUSUCCESS(0)

/*
 * Message was completely handled (stop bubbling).
 */
#define DU_S_COMPLETE               MAKE_DUSUCCESS(1)

/*
 * Message was partially handled (continue bubbling).
 */
#define DU_S_PARTIAL                MAKE_DUSUCCESS(2)

/*
 * Enumeration was successful but prematurely stopped by the enumeration 
 * function
 */
#define DU_S_STOPPEDENUMERATION     MAKE_DUSUCCESS(10)


/*
 * The operation was successful, but the object was already created.
 */
#define DU_S_ALREADYEXISTS          MAKE_DUSUCCESS(20)

/*
 * There are not enough Kernel resources to perform the operation
 */
#define DU_E_OUTOFKERNELRESOURCES   MAKE_DUERROR(1)

/*
 * There are not enough GDI resources to perform the operation
 */
#define DU_E_OUTOFGDIRESOURCES      MAKE_DUERROR(2)

/*
 * Generic failure.
 */
#define DU_E_GENERIC                MAKE_DUERROR(10)

/*
 * The object is in a "busy" state and is not available to process the request.
 */
#define DU_E_BUSY                   MAKE_DUERROR(11)

/*
 * The Context has not been initialized with InitGadgets().
 */
#define DU_E_NOCONTEXT              MAKE_DUERROR(20)

 /*
 * The object was used in the incorrect context.
 */
#define DU_E_INVALIDCONTEXT         MAKE_DUERROR(30)

/*
 * The Context has been marked to only allow read-only operations.  For example,
 * this may be in the middle of a read-only callback.
 */
#define DU_E_READONLYCONTEXT        MAKE_DUERROR(31)

/*
 * The threading model has already be determined by a previous call to 
 * InitGadgets() and can no longer be changed.
 */
#define DU_E_THREADINGALREADYSET    MAKE_DUERROR(32)

/*
 * Unable to use the IGMM_STANDARD messaging model because it is either 
 * unsupported or cannot be installed.
 */
#define DU_E_CANNOTUSESTANDARDMESSAGING MAKE_DUERROR(33)

/*
 * Can not mix an invalid coordinate mapping, for example having a non-relative
 * child of a relative parent.
 */
#define DU_E_BADCOORDINATEMAP       MAKE_DUERROR(40)

/*
 * Could not find a MSGID for one of the requested messages.  This will be 
 * represented by a '0' in the MSGID field for that message.
 */
#define DU_E_CANNOTFINDMSGID        MAKE_DUERROR(50)

/*
 * The operation is not legal because the specified Gadget does not have a 
 * GS_BUFFERED style.
 */
#define DU_E_NOTBUFFERED            MAKE_DUERROR(60)

/*
 * The specific Gadget has started the destruction and can not be be modified
 * in this manner.
 */
#define DU_E_STARTDESTROY           MAKE_DUERROR(70)

/*
 * The specific object is locked and may not be modified.
 */
#define DU_E_OBJECTLOCKED           MAKE_DUERROR(71)

/*
 * The specified DirectUser optional component has not yet been initialized with
 * InitGadgetComponent().
 */
#define DU_E_NOTINITIALIZED         MAKE_DUERROR(80)

/*
 * The specified DirectUser object was not found.
 */
#define DU_E_NOTFOUND               MAKE_DUERROR(90)

/*
 * The specified parmeters are mismatched for the current object state.  For
 * example, the object is specified to use GDI HANDLE's, but the parameter was
 * a GDI+ Object.
 */
#define DU_E_MISMATCHEDTYPES        MAKE_DUERROR(100)

/*
 * GDI+ was unable to be loaded.  It may not be installed on the system or may
 * not be properly initialized.
 */
#define DU_E_CANNOTLOADGDIPLUS      MAKE_DUERROR(110)

/*
 * Direct3D was unable to be loaded.  It may not be installed on the system or 
 * may not be properly initialized.
 */
#define DU_E_CANNOTLOADDIRECT3D     MAKE_DUERROR(111)

/*
 * The specified class was already registered.
 */
#define DU_E_CLASSALREADYREGISTERED MAKE_DUERROR(120)

/*
 * The specified message was not found during class registration.
 */
#define DU_E_MESSAGENOTFOUND        MAKE_DUERROR(121)

/*
 * The specified message was not implemented during class registration.
 */
#define DU_E_MESSAGENOTIMPLEMENTED  MAKE_DUERROR(122)

/*
 * The implementation of the specific class has not yet been registered.
 */
#define DU_E_CLASSNOTIMPLEMENTED    MAKE_DUERROR(123)

/*
 * Sending the message failed.
 */
#define DU_E_MESSAGEFAILED          MAKE_DUERROR(124)


#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\duserhandletable.h ===
#if !defined(INC__DUserHandleTable_h__INCLUDED)
#define INC__DUserHandleTable_h__INCLUDED
#pragma once

#ifdef __cplusplus
extern "C" {
#endif


DECLARE_HANDLE(HHANDLETABLE);


typedef void        (CALLBACK * DESTROYHANDLEPROC)(void * pvData, void * pvObject);


DUSER_API HRESULT WINAPI
DUserHandleTableCreate(
    int cItemsPerGroupBits, 
    int cGroupBits,
    HHANDLETABLE * phtbl);


DUSER_API HRESULT WINAPI
DUserHandleTableDestroy(
    HHANDLETABLE htbl);


DUSER_API HRESULT WINAPI
DUserHandleTableAddItem(
    HHANDLETABLE htbl,
    DWORD dwItemID, 
    void * pvAdd);


DUSER_API HRESULT WINAPI
DUserHandleTableDeleteItem(
    HHANDLETABLE htbl,
    DWORD dwItemID);


DUSER_API HRESULT WINAPI
DUserHandleTableRemoveItem(
    HHANDLETABLE htbl,
    DWORD dwItemID);


DUSER_API HRESULT WINAPI
DUserHandleTableFindItem(
    HHANDLETABLE htbl,
    DWORD dwItemID, 
    void ** ppvFound);


DUSER_API HRESULT WINAPI
DUserHandleTableAddGroup(
    HHANDLETABLE htbl,
    int idxGroup,
    DESTROYHANDLEPROC pfnDestroy,
    void * pvData);


DUSER_API HRESULT WINAPI
DUserHandleTableDeleteGroup(
    HHANDLETABLE htbl,
    int idxGroup);


#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserHandleTable_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\dusergeom2d.h ===
/***************************************************************************\
*
* File: Geom2D.h
*
* Description:
* Geom2D defines a standard lightweight objects for 2D space, including
* size, point, and rect.
*
*
* History:
*  2/10/2001: JStall:       Copied from \windows\AdvCore\Gdiplus\sdkinc\GdiplusTypes.h
*
* Copyright (C) 2001 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(DUSERX___Types_h__INCLUDED)
#define DUSERX___Types_h__INCLUDED
#pragma once

namespace DirectUser
{
namespace Geometry
{
typedef float REAL;


//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT8
//      UINT8
//      INT16
//      UINT16
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

// Forward declarations
class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;


//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:

   // Default constructor
    SizeF()
    {
        
    }
   
    SizeF(bool fInit)
    {
        if (fInit) {
            Width = Height = 0.0f;
        }
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width,
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:

   // Default constructor
    Size()
    {
        
    }
   
    Size(bool fInit)
    {
        if (fInit) {
            Width = Height = 0;
        }
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
    
   }
    
   PointF(bool fInit)
   {
       if (fInit) {
           X = Y = 0.0f;
       }
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x,
          IN REAL y)
   {
       X = x;
       Y = y;
   }

   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
    
   }
    
   Point(bool fInit)
   {
       if (fInit) {
           X = Y = 0;
       }
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }

   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    // Default constructor

    RectF()
    {
        
    }
    
    RectF(bool fInit)
    {
        if (fInit) {
            X = Y = Width = Height = 0.0f;
        }
    }

    RectF(IN REAL x,
          IN REAL y,
          IN REAL width,
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    REAL GetLeft() const
    {
        return X;
    }

    void SetLeft(REAL x)
    {
        X = x;
    }

    REAL GetTop() const
    {
        return Y;
    }

    void SetTop(REAL y)
    {
        Y = y;
    }

    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        REAL epsilon = 1.192092896e-07F;        /* FLT_EPSILON */

        return (Width <= epsilon) || (Height <= epsilon);
    }

    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x,
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN REAL dx,
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }

    // Intersect the current rect with the specified object

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a,
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const RectF& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c,
                      IN const RectF& a,
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx,
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    // Default constructor

    Rect()
    {
        
    }
    
    Rect(bool fInit)
    {
        if (fInit) {
            X = Y = Width = Height = 0;
        }
    }

    Rect(IN INT x,
         IN INT y,
         IN INT width,
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location,
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x,
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN INT dx,
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }

    // Intersect the current rect with the specified object

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a,
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx,
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

} // namespace Geometry
} // namespace DirectUser

#endif // DUSERX___Types_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\acd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasacd.h

Abstract:

    This header file defines constants and types for accessing the NT
    Automatic Connection Driver (rasacd.sys).

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/

#ifndef _RASACD_
#define _RASACD_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define ACD_DEVICE_NAME   L"\\Device\\RasAcd"

//
// Address type.
//
typedef enum {
    ACD_ADDR_IP,            // IP address (128.95.1.4)
    ACD_ADDR_IPX,           // IPX node address ()
    ACD_ADDR_NB,            // NETBIOS name ("server")
    ACD_ADDR_INET,          // Internet hostname ("ftp.microsoft.com")
    ACD_ADDR_MAX
} ACD_ADDR_TYPE;

//
// Generic network address string.
//
#define ACD_ADDR_NB_LEN         16      // nb30.h/NCBNAMSZ
#define ACD_ADDR_IPX_LEN        6       // wsipx.h
#define ACD_ADDR_INET_LEN       1024    // wininet.h/INTERNET_MAX_PATH_LENGTH

typedef struct _ACD_ADDR {
    ACD_ADDR_TYPE fType;
    union {
        ULONG ulIpaddr;                         // IP address
        UCHAR cNode[ACD_ADDR_IPX_LEN];          // IPX address
        UCHAR cNetbios[ACD_ADDR_NB_LEN];        // NetBios server
        UCHAR szInet[ACD_ADDR_INET_LEN];        // Internet address
    };
} ACD_ADDR, *PACD_ADDR;

//
// Adapter information.
//
// Each transport passes up some identifier
// of which adapter over which a successful
// connection was made.
//
typedef enum {
    ACD_ADAPTER_LANA,
    ACD_ADAPTER_IP,
    ACD_ADAPTER_NAME,
    ACD_ADAPTER_MAC
} ACD_ADAPTER_TYPE;

#define ACD_ADAPTER_NAME_LEN    256

typedef struct _ACD_ADAPTER {
    enum ACD_ADAPTER_TYPE fType;
    union {
        UCHAR bLana;                            // NetBios LANA
        ULONG ulIpaddr;                         // IP address
        WCHAR szName[ACD_ADAPTER_NAME_LEN];     // for example, "NdisWan4"
        UCHAR cMac[6];                          // IPX mac address
    };
} ACD_ADAPTER, *PACD_ADAPTER;

//
// Connection notification structure.
//
// The automatic connection system service
// posts one of these to the automatic connection
// driver.  The request will be completed and
// this structure filled in by the driver when a
// new RAS connection is to be made.
//
#define ACD_NOTIFICATION_SUCCESS    0x00000001  // successful connection

typedef struct _ACD_NOTIFICATION {
    ACD_ADDR addr;                 // address of connection attempt
    ULONG ulFlags;                 // ACD_NOTIFICATION_* flags above
    ACD_ADAPTER adapter;           // adapter identifier
    HANDLE  Pid;                    // pid of the process requesting the conneciton
} ACD_NOTIFICATION, *PACD_NOTIFICATION;

#if defined(_WIN64)
typedef struct _ACD_NOTIFICATION_32 {

    ACD_ADDR addr;                 // address of connection attempt
    ULONG ulFlags;                 // ACD_NOTIFICATION_* flags above
    ACD_ADAPTER adapter;           // adapter identifier
    VOID * POINTER_32  Pid;        // pid of the process requesting the conneciton
} ACD_NOTIFICATION_32, *PACD_NOTIFICATION_32;
#endif

typedef struct _ACD_STATUS {
    BOOLEAN fSuccess;               // success or failure
    ACD_ADDR addr;                  // address of connection attempt
} ACD_STATUS, *PACD_STATUS;

typedef struct _ACD_ENABLE_ADDRESS {
    BOOLEAN fDisable;
    ACD_ADDR addr;
} ACD_ENABLE_ADDRESS, *PACD_ENABLE_ADDRESS;    

//
//
// IOCTL code definitions
//
#define FILE_DEVICE_ACD   0x000000f1
#define _ACD_CTL_CODE(function, method, access) \
            CTL_CODE(FILE_DEVICE_ACD, function, method, access)

//
// Set the notification mode for the driver.
//
#define IOCTL_ACD_RESET \
            _ACD_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Set the notification mode for the driver.
//
#define IOCTL_ACD_ENABLE \
            _ACD_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Wait for a connection request notification
// from the automatic connection driver.
//
#define IOCTL_ACD_NOTIFICATION \
            _ACD_CTL_CODE(2, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Inform the automatic connection driver that
// the connection attempt is progressing.
//
#define IOCTL_ACD_KEEPALIVE \
            _ACD_CTL_CODE(3, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Inform the automatic connection driver of
// the final status of the connection attempt.
//
#define IOCTL_ACD_COMPLETION \
            _ACD_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Generate an automatic connection attempt
// from user space.
//
#define IOCTL_ACD_CONNECT_ADDRESS \
            _ACD_CTL_CODE(5, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Disable an address so that any automatic connection attempts
// to this address are disabled. This is required so that we don't
// create a deadlock when attempting to dial vpn connection by name.
// We don't want the name resolution of the vpn destination to
// cause an autodial attempt.
//
#define IOCTL_ACD_ENABLE_ADDRESS \
            _ACD_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif  // ifndef _RASACD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\dusermotion.h ===
#if !defined(INC__DUserMotion_h__INCLUDED)
#define INC__DUserMotion_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************\
*
* Actions
*
\***************************************************************************/

struct GMA_ACTION;

DECLARE_HANDLE(HACTION);

struct GMA_ACTIONINFO
{
    HACTION     hact;           // Handle
    void *      pvData;         // Caller data
    float       flDuration;     // Duration in seconds
    float       flProgress;     // Progress (0 - 1)
    int         cEvent;         // Number of callbacks in this period
    int         cPeriods;       // Number of periods
    BOOL        fFinished;      // TODO: Change to a command
};

typedef void    (CALLBACK * ACTIONPROC)(GMA_ACTIONINFO * pmai);

struct GMA_ACTION
{
    DWORD       cbSize;         // Size of structure
    float       flDelay;        // Delay in seconds before starting
    float       flDuration;     // Duration in seconds of each period (0 = single shot)
    float       flPeriod;       // Time between beginnings of repeats (0 = no gap)
    UINT        cRepeat;        // Number of times to repeat (0 = single, -1 = infinite)
    DWORD       dwPause;        // Pause between callbacks (0 = default, -1 = none)
    ACTIONPROC  pfnProc;        // Function to call
    void *      pvData;         // Caller data
};


DUSER_API   HACTION     WINAPI  CreateAction(const GMA_ACTION * pma);
DUSER_API   BOOL        WINAPI  GetActionTimeslice(DWORD * pdwTimeslice);
DUSER_API   BOOL        WINAPI  SetActionTimeslice(DWORD dwTimeslice);


/***************************************************************************\
*
* Animations
*
\***************************************************************************/

class Visual;

namespace DUser
{

struct KeyFrame
{
    DWORD       cbSize;
};

};  // namespace DUser

DUSER_API   PRID        WINAPI  DUserGetAlphaVertexPRID();
DUSER_API   PRID        WINAPI  DUserGetRectPRID();
DUSER_API   PRID        WINAPI  DUserGetRotatePRID();
DUSER_API   PRID        WINAPI  DUserGetScalePRID();
DUSER_API   PRID        WINAPI  DUserGetLightPRID();

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserMotion_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ehui\gadget.h ===
#if !defined(INC__Gadget_h__INCLUDED)
#define INC__Gadget_h__INCLUDED
#pragma once

// Forward declarations used in .gidl files

class Visual;

namespace Gdiplus
{
    class Brush;
    class Font;
    class Pen;
};


// Global helper functions

template <class T>
inline T * 
BuildVisual(Visual * pgvParent)
{
    Visual::VisualCI ci;
    ZeroMemory(&ci, sizeof(ci));
    ci.pgvParent = pgvParent;
    return T::Build(&ci);
}


inline bool IsHandled(HRESULT hr)
{
    return (hr == DU_S_COMPLETE) || (hr == DU_S_PARTIAL);
}


#endif // INC__Gadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\afd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Afd.h

Abstract:

    Contains structures and declarations for AFD.  AFD stands for the
    Ancillary Function Driver.  This driver enhances the functionality
    of TDI so that it is a sufficiently rich interface to support
    user-mode sockets and XTI DLLs.

Author:

    David Treadwell (davidtr)    20-Feb-1992

Revision History:

--*/

#ifndef _AFD_
#define _AFD_

//
// If WINSOCK2.H has not been included, then just embed the definition
// of the WSABUF and QOS structures here. This makes building AFD.SYS
// much easier.
//


#ifndef _WINSOCK2API_

typedef struct _WSABUF {
    ULONG len;
    PCHAR buf;
} WSABUF, *LPWSABUF;

#include <qos.h>


typedef struct _QualityOfService
{
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF        ProviderSpecific;      /* additional provider specific stuff */
} QOS, *LPQOS;

#define MSG_TRUNC       0x0100
#define MSG_CTRUNC      0x0200
#define MSG_BCAST       0x0400
#define MSG_MCAST       0x0800
#endif

#define AFD_DEVICE_NAME L"\\Device\\Afd"

//
// Endpoint flags computed based on Winsock2 provider flags
// and socket type
//

typedef struct _AFD_ENDPOINT_FLAGS {
    union {
        struct {
            BOOLEAN     ConnectionLess :1;
            BOOLEAN     :3;                 // This spacing makes strcutures
                                            // much more readable (hex) in the 
                                            // debugger and has no effect
                                            // on the generated code as long
                                            // as number of flags is less than
                                            // 8 (we still take up full 32 bits
                                            // because of aligment requiremens
                                            // of most other fields)
            BOOLEAN     MessageMode :1;
            BOOLEAN     :3;
            BOOLEAN     Raw :1;
            BOOLEAN     :3;
            BOOLEAN     Multipoint :1;
            BOOLEAN     :3;
            BOOLEAN     C_Root :1;
            BOOLEAN     :3;
            BOOLEAN     D_Root :1;
            BOOLEAN     :3;
        };
        ULONG           EndpointFlags;      // Flags are as fine as bit fields,
                                            // but create problems when we need
                                            // to cast them to boolean.
    };
#define AFD_ENDPOINT_FLAG_CONNECTIONLESS	0x00000001
#define AFD_ENDPOINT_FLAG_MESSAGEMODE		0x00000010
#define AFD_ENDPOINT_FLAG_RAW			    0x00000100

//
// Old AFD_ENDPOINT_TYPE mappings. Flags make things clearer at
// at the TDI level and after all Winsock2 switched to provider flags
// instead of socket type anyway (ATM for example needs connection oriented
// raw sockets, which can only be reflected by SOCK_RAW+SOCK_STREAM combination
// which does not exists).
//
#define AfdEndpointTypeStream			0
#define AfdEndpointTypeDatagram			(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeRaw				(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE|\
                                            AFD_ENDPOINT_FLAG_RAW)
#define AfdEndpointTypeSequencedPacket	(AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeReliableMessage	(AFD_ENDPOINT_FLAG_MESSAGEMODE)

//
// New multipoint semantics
//
#define AFD_ENDPOINT_FLAG_MULTIPOINT	    0x00001000
#define AFD_ENDPOINT_FLAG_CROOT			    0x00010000
#define AFD_ENDPOINT_FLAG_DROOT			    0x00100000

#define AFD_ENDPOINT_VALID_FLAGS		    0x00111111

} AFD_ENDPOINT_FLAGS;

//
// Structures used on NtCreateFile() for AFD.
//

typedef struct _AFD_OPEN_PACKET {
	AFD_ENDPOINT_FLAGS __f;
#define afdConnectionLess  __f.ConnectionLess
#define afdMessageMode     __f.MessageMode
#define afdRaw             __f.Raw
#define afdMultipoint      __f.Multipoint
#define afdC_Root          __f.C_Root
#define afdD_Root          __f.D_Root
#define afdEndpointFlags   __f.EndpointFlags
    LONG  GroupID;
    ULONG TransportDeviceNameLength;
    WCHAR TransportDeviceName[1];
} AFD_OPEN_PACKET, *PAFD_OPEN_PACKET;

// *** the XX is to ensure natural alignment of the open packet part
//     of the EA buffer

#define AfdOpenPacket "AfdOpenPacketXX"
#define AFD_OPEN_PACKET_NAME_LENGTH (sizeof(AfdOpenPacket) - 1)

//
// The input structure for IOCTL_AFD_BIND
//
typedef struct _AFD_BIND_INFO {
    ULONG                       ShareAccess;
#define AFD_NORMALADDRUSE		0	// Do not reuse address if
									// already in use but allow
									// subsequent reuse by others
									// (this is a default)
#define AFD_REUSEADDRESS		1	// Reuse address if necessary
#define AFD_WILDCARDADDRESS     2   // Address is a wildcard, no checking
                                    // can be performed by winsock layer.
#define AFD_EXCLUSIVEADDRUSE	3	// Do not allow reuse of this
									// address (admin only).
	TRANSPORT_ADDRESS			Address;
} AFD_BIND_INFO, *PAFD_BIND_INFO;

//
// The output strucuture is TDI_ADDRESS_INFO
// The address handle is returned via IoStatus->Information
//

//
// The input structure for IOCTL_AFD_START_LISTEN.
//

typedef struct _AFD_LISTEN_INFO {
    BOOLEAN     SanActive;
    ULONG MaximumConnectionQueue;
    BOOLEAN UseDelayedAcceptance;
} AFD_LISTEN_INFO, *PAFD_LISTEN_INFO;

//
// The output structure for IOCTL_AFD_WAIT_FOR_LISTEN.
//

typedef struct _AFD_LISTEN_RESPONSE_INFO {
    LONG Sequence;
    TRANSPORT_ADDRESS RemoteAddress;
} AFD_LISTEN_RESPONSE_INFO, *PAFD_LISTEN_RESPONSE_INFO;

//
// The input structure for IOCTL_AFD_ACCEPT.
//

typedef struct _AFD_ACCEPT_INFO {
    BOOLEAN     SanActive;
    LONG Sequence;
    HANDLE AcceptHandle;
} AFD_ACCEPT_INFO, *PAFD_ACCEPT_INFO;


typedef struct _AFD_SUPER_ACCEPT_INFO {
    BOOLEAN     SanActive;
    BOOLEAN     FixAddressAlignment;
    HANDLE      AcceptHandle;
    ULONG       ReceiveDataLength;
    ULONG       LocalAddressLength;
    ULONG       RemoteAddressLength;
} AFD_SUPER_ACCEPT_INFO, *PAFD_SUPER_ACCEPT_INFO;


//
// The input structure for IOCTL_AFD_DEFER_ACCEPT.
//

typedef struct _AFD_DEFER_ACCEPT_INFO {
    LONG Sequence;
    BOOLEAN Reject;
} AFD_DEFER_ACCEPT_INFO, *PAFD_DEFER_ACCEPT_INFO;

//
// Flags and input structure for IOCTL_AFD_PARTIAL_DISCONNECT.
//

#define AFD_PARTIAL_DISCONNECT_SEND 0x01
#define AFD_PARTIAL_DISCONNECT_RECEIVE 0x02
#define AFD_ABORTIVE_DISCONNECT 0x4
#define AFD_UNCONNECT_DATAGRAM 0x08

typedef struct _AFD_PARTIAL_DISCONNECT_INFO {
    ULONG DisconnectMode;
    LARGE_INTEGER Timeout;
} AFD_PARTIAL_DISCONNECT_INFO, *PAFD_PARTIAL_DISCONNECT_INFO;

typedef struct _AFD_SUPER_DISCONNECT_INFO {
    ULONG  Flags;           // Same as TransmitFile
} AFD_SUPER_DISCONNECT_INFO, *PAFD_SUPER_DISCONNECT_INFO;

//
// Structures for IOCTL_AFD_POLL.
//

typedef struct _AFD_POLL_HANDLE_INFO {
    HANDLE Handle;
    ULONG PollEvents;
    NTSTATUS Status;
} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;

typedef struct _AFD_POLL_INFO {
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO Handles[1];
} AFD_POLL_INFO, *PAFD_POLL_INFO;

#define AFD_POLL_RECEIVE_BIT            0   //0001
#define AFD_POLL_RECEIVE                (1 << AFD_POLL_RECEIVE_BIT)
#define AFD_POLL_RECEIVE_EXPEDITED_BIT  1   //0002
#define AFD_POLL_RECEIVE_EXPEDITED      (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
#define AFD_POLL_SEND_BIT               2   //0004
#define AFD_POLL_SEND                   (1 << AFD_POLL_SEND_BIT)
#define AFD_POLL_DISCONNECT_BIT         3   //0008
#define AFD_POLL_DISCONNECT             (1 << AFD_POLL_DISCONNECT_BIT)
#define AFD_POLL_ABORT_BIT              4   //0010
#define AFD_POLL_ABORT                  (1 << AFD_POLL_ABORT_BIT)
#define AFD_POLL_LOCAL_CLOSE_BIT        5   //0020
#define AFD_POLL_LOCAL_CLOSE            (1 << AFD_POLL_LOCAL_CLOSE_BIT)
#define AFD_POLL_CONNECT_BIT            6   //0040
#define AFD_POLL_CONNECT                (1 << AFD_POLL_CONNECT_BIT)
#define AFD_POLL_ACCEPT_BIT             7   //0080
#define AFD_POLL_ACCEPT                 (1 << AFD_POLL_ACCEPT_BIT)
#define AFD_POLL_CONNECT_FAIL_BIT       8   //0100
#define AFD_POLL_CONNECT_FAIL           (1 << AFD_POLL_CONNECT_FAIL_BIT)
#define AFD_POLL_QOS_BIT                9   //0200
#define AFD_POLL_QOS                    (1 << AFD_POLL_QOS_BIT)
#define AFD_POLL_GROUP_QOS_BIT          10  //0400
#define AFD_POLL_GROUP_QOS              (1 << AFD_POLL_GROUP_QOS_BIT)

#define AFD_POLL_ROUTING_IF_CHANGE_BIT  11  //0800
#define AFD_POLL_ROUTING_IF_CHANGE      (1 << AFD_POLL_ROUTING_IF_CHANGE_BIT)
#define AFD_POLL_ADDRESS_LIST_CHANGE_BIT 12 //1000
#define AFD_POLL_ADDRESS_LIST_CHANGE    (1 << AFD_POLL_ADDRESS_LIST_CHANGE_BIT)
#define AFD_NUM_POLL_EVENTS             13
#define AFD_POLL_ALL                    ((1 << AFD_NUM_POLL_EVENTS) - 1)

#define AFD_POLL_SANCOUNTS_UPDATED  0x80000000


//
// Structure for querying receive information.
//

typedef struct _AFD_RECEIVE_INFORMATION {
    ULONG BytesAvailable;
    ULONG ExpeditedBytesAvailable;
} AFD_RECEIVE_INFORMATION, *PAFD_RECEIVE_INFORMATION;

//
// Structure for quering the TDI handles for an AFD endpoint.
//

#define AFD_QUERY_ADDRESS_HANDLE 1
#define AFD_QUERY_CONNECTION_HANDLE 2


typedef struct _AFD_HANDLE_INFO {
    HANDLE TdiAddressHandle;
    HANDLE TdiConnectionHandle;
} AFD_HANDLE_INFO, *PAFD_HANDLE_INFO;

//
// Structure and manifests for setting information in AFD.
//

typedef struct _AFD_INFORMATION {
    ULONG InformationType;
    union {
        BOOLEAN Boolean;
        ULONG Ulong;
        LARGE_INTEGER LargeInteger;
    } Information;
} AFD_INFORMATION, *PAFD_INFORMATION;

#define AFD_INLINE_MODE          0x01
#define AFD_NONBLOCKING_MODE     0x02
#define AFD_MAX_SEND_SIZE        0x03
#define AFD_SENDS_PENDING        0x04
#define AFD_MAX_PATH_SEND_SIZE   0x05
#define AFD_RECEIVE_WINDOW_SIZE  0x06
#define AFD_SEND_WINDOW_SIZE     0x07
#define AFD_CONNECT_TIME         0x08
#define AFD_CIRCULAR_QUEUEING    0x09
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_REPORT_PORT_UNREACHABLE 0x0B

//
// Structure for the transmit file IOCTL.
//


typedef struct _AFD_TRANSMIT_FILE_INFO {
    LARGE_INTEGER Offset;
    LARGE_INTEGER WriteLength;
    ULONG SendPacketLength;
    HANDLE FileHandle;
    PVOID Head;
    ULONG HeadLength;
    PVOID Tail;
    ULONG TailLength;
    ULONG Flags;
} AFD_TRANSMIT_FILE_INFO, *PAFD_TRANSMIT_FILE_INFO;

//
// Flags for the TransmitFile API.
//

#define AFD_TF_DISCONNECT           0x01
#define AFD_TF_REUSE_SOCKET         0x02
#define AFD_TF_WRITE_BEHIND         0x04

#define AFD_TF_USE_DEFAULT_WORKER   0x00
#define AFD_TF_USE_SYSTEM_THREAD    0x10
#define AFD_TF_USE_KERNEL_APC       0x20
#define AFD_TF_WORKER_KIND_MASK     0x30


//
// Flag definitions for the AfdFlags field in the AFD_SEND_INFO,
// AFD_SEND_DATAGRAM_INFO, AFD_RECV_INFO, and AFD_RECV_DATAGRAM_INFO
// structures.
//

#define AFD_NO_FAST_IO      0x0001      // Always fail Fast IO on this request.
#define AFD_OVERLAPPED      0x0002      // Overlapped operation.

//
// Structure for connected sends.
//

typedef struct _AFD_SEND_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_SEND_INFO, *PAFD_SEND_INFO;

//
// Structure for unconnected datagram sends.
//

typedef struct _AFD_SEND_DATAGRAM_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    TDI_REQUEST_SEND_DATAGRAM   TdiRequest;
    TDI_CONNECTION_INFORMATION  TdiConnInfo;
} AFD_SEND_DATAGRAM_INFO, *PAFD_SEND_DATAGRAM_INFO;

//
// Structure for connected recvs.
//

typedef struct _AFD_RECV_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_RECV_INFO, *PAFD_RECV_INFO;

//
// Structure for receiving datagrams on unconnected sockets.
//

typedef struct _AFD_RECV_DATAGRAM_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    PVOID Address;
    PULONG AddressLength;
} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;


//
// Structure for receiving datagram messages.
//
typedef struct _AFD_RECV_MESSAGE_INFO {
    AFD_RECV_DATAGRAM_INFO dgi;
    PVOID   ControlBuffer;
    PULONG  ControlLength;
    PULONG  MsgFlags;
} AFD_RECV_MESSAGE_INFO, *PAFD_RECV_MESSAGE_INFO;

#define AFD_MAX_TDI_FAST_ADDRESS 32

//
// Structure for event select.
//

typedef struct _AFD_EVENT_SELECT_INFO {
    HANDLE Event;
    ULONG PollEvents;
} AFD_EVENT_SELECT_INFO, *PAFD_EVENT_SELECT_INFO;

//
// Output structure for enum network events.
//

typedef struct _AFD_ENUM_NETWORK_EVENTS_INFO {
    ULONG PollEvents;
    NTSTATUS EventStatus[AFD_NUM_POLL_EVENTS];
} AFD_ENUM_NETWORK_EVENTS_INFO, *PAFD_ENUM_NETWORK_EVENTS_INFO;

//
// Structures for QOS and grouping.
//


typedef struct _AFD_QOS_INFO {
    QOS Qos;
    BOOLEAN GroupQos;
} AFD_QOS_INFO, *PAFD_QOS_INFO;

//
// Group membership type.
//

typedef enum _AFD_GROUP_TYPE {
    GroupTypeNeither = 0,
    GroupTypeConstrained = SG_CONSTRAINED_GROUP,
    GroupTypeUnconstrained = SG_UNCONSTRAINED_GROUP
} AFD_GROUP_TYPE, *PAFD_GROUP_TYPE;

//
// Note that, for totally slimy reasons, the following
// structure must be exactly eight bytes long (the size
// of a LARGE_INTEGER). See msafd\socket.c and afd\misc.c
// for the gory details.
//

typedef struct _AFD_GROUP_INFO {
    LONG GroupID;
    AFD_GROUP_TYPE GroupType;
} AFD_GROUP_INFO, *PAFD_GROUP_INFO;

//
// Structure for validating group membership.
//

typedef struct _AFD_VALIDATE_GROUP_INFO {
    LONG GroupID;
    TRANSPORT_ADDRESS RemoteAddress;
} AFD_VALIDATE_GROUP_INFO, *PAFD_VALIDATE_GROUP_INFO;

//
// Structure for querying connect data on an unaccepted connection.
//

typedef struct _AFD_UNACCEPTED_CONNECT_DATA_INFO {
    LONG Sequence;
    ULONG ConnectDataLength;
    BOOLEAN LengthOnly;

} AFD_UNACCEPTED_CONNECT_DATA_INFO, *PAFD_UNACCEPTED_CONNECT_DATA_INFO;

typedef struct _AFD_TRANSPORT_IOCTL_INFO {
    HANDLE  Handle;
    PVOID   InputBuffer;
    ULONG   InputBufferLength;
    ULONG   IoControlCode;
    ULONG   AfdFlags;
    ULONG   PollEvent;
} AFD_TRANSPORT_IOCTL_INFO, *PAFD_TRANSPORT_IOCTL_INFO;


typedef struct _AFD_CONNECT_JOIN_INFO {
    BOOLEAN     SanActive;
    HANDLE  RootEndpoint;       // Root endpoint for joins
    HANDLE  ConnectEndpoint;    // Connect/leaf endpoint for async connects
    TRANSPORT_ADDRESS   RemoteAddress; // Remote address
} AFD_CONNECT_JOIN_INFO, *PAFD_CONNECT_JOIN_INFO;


#ifndef _WINSOCK2API_
typedef struct _TRANSMIT_PACKETS_ELEMENT {
    ULONG dwElFlags;
#define TP_MEMORY   1
#define TP_FILE     2
#define TP_EOP      4
    ULONG cLength;
    union {
        struct {
            LARGE_INTEGER nFileOffset;
            HANDLE        hFile;
        };
        PVOID             pBuffer;
    };
} TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#else
typedef struct _TRANSMIT_PACKETS_ELEMENT TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#endif

typedef struct _AFD_TPACKETS_INFO {
    LPTRANSMIT_PACKETS_ELEMENT  ElementArray;
    ULONG                       ElementCount;
    ULONG                       SendSize;
    ULONG                       Flags;
} AFD_TPACKETS_INFO, *PAFD_TPACKETS_INFO;

//
// AFD IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by AFD's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      ntos\afd\dispatch.c!
//

#define FSCTL_AFD_BASE                  FILE_DEVICE_NETWORK
#define _AFD_CONTROL_CODE(request,method) \
                ((FSCTL_AFD_BASE)<<12 | (request<<2) | method)
#define _AFD_REQUEST(ioctl) \
                ((((ULONG)(ioctl)) >> 2) & 0x03FF)

#define _AFD_BASE(ioctl) \
                ((((ULONG)(ioctl)) >> 12) & 0xFFFFF)

#define AFD_BIND                    0
#define AFD_CONNECT                 1
#define AFD_START_LISTEN            2
#define AFD_WAIT_FOR_LISTEN         3
#define AFD_ACCEPT                  4
#define AFD_RECEIVE                 5
#define AFD_RECEIVE_DATAGRAM        6
#define AFD_SEND                    7
#define AFD_SEND_DATAGRAM           8
#define AFD_POLL                    9
#define AFD_PARTIAL_DISCONNECT      10

#define AFD_GET_ADDRESS             11
#define AFD_QUERY_RECEIVE_INFO      12
#define AFD_QUERY_HANDLES           13
#define AFD_SET_INFORMATION         14
#define AFD_GET_REMOTE_ADDRESS      15
#define AFD_GET_CONTEXT             16
#define AFD_SET_CONTEXT             17

#define AFD_SET_CONNECT_DATA        18
#define AFD_SET_CONNECT_OPTIONS     19
#define AFD_SET_DISCONNECT_DATA     20
#define AFD_SET_DISCONNECT_OPTIONS  21

#define AFD_GET_CONNECT_DATA        22
#define AFD_GET_CONNECT_OPTIONS     23
#define AFD_GET_DISCONNECT_DATA     24
#define AFD_GET_DISCONNECT_OPTIONS  25

#define AFD_SIZE_CONNECT_DATA       26
#define AFD_SIZE_CONNECT_OPTIONS    27
#define AFD_SIZE_DISCONNECT_DATA    28
#define AFD_SIZE_DISCONNECT_OPTIONS 29

#define AFD_GET_INFORMATION         30
#define AFD_TRANSMIT_FILE           31
#define AFD_SUPER_ACCEPT            32

#define AFD_EVENT_SELECT            33
#define AFD_ENUM_NETWORK_EVENTS     34

#define AFD_DEFER_ACCEPT            35
#define AFD_WAIT_FOR_LISTEN_LIFO    36
#define AFD_SET_QOS                 37
#define AFD_GET_QOS                 38
#define AFD_NO_OPERATION            39
#define AFD_VALIDATE_GROUP          40
#define AFD_GET_UNACCEPTED_CONNECT_DATA 41

#define AFD_ROUTING_INTERFACE_QUERY  42
#define AFD_ROUTING_INTERFACE_CHANGE 43
#define AFD_ADDRESS_LIST_QUERY      44
#define AFD_ADDRESS_LIST_CHANGE     45
#define AFD_JOIN_LEAF               46
#define AFD_TRANSPORT_IOCTL         47
#define AFD_TRANSMIT_PACKETS        48
#define AFD_SUPER_CONNECT           49
#define AFD_SUPER_DISCONNECT        50
#define AFD_RECEIVE_MESSAGE         51

//
// SAN switch specific AFD function numbers
//
#define AFD_SWITCH_CEMENT_SAN       52
#define AFD_SWITCH_SET_EVENTS       53
#define AFD_SWITCH_RESET_EVENTS     54
#define AFD_SWITCH_CONNECT_IND      55
#define AFD_SWITCH_CMPL_ACCEPT      56
#define AFD_SWITCH_CMPL_REQUEST     57
#define AFD_SWITCH_CMPL_IO          58
#define AFD_SWITCH_REFRESH_ENDP     59
#define AFD_SWITCH_GET_PHYSICAL_ADDR 60
#define AFD_SWITCH_ACQUIRE_CTX      61
#define AFD_SWITCH_TRANSFER_CTX     62
#define AFD_SWITCH_GET_SERVICE_PID  63
#define AFD_SWITCH_SET_SERVICE_PROCESS  64
#define AFD_SWITCH_PROVIDER_CHANGE  65
#define AFD_SWITCH_ADDRLIST_CHANGE	66
#define AFD_NUM_IOCTLS				67



#define IOCTL_AFD_BIND                    _AFD_CONTROL_CODE( AFD_BIND, METHOD_NEITHER )
#define IOCTL_AFD_CONNECT                 _AFD_CONTROL_CODE( AFD_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_START_LISTEN            _AFD_CONTROL_CODE( AFD_START_LISTEN, METHOD_NEITHER )
#define IOCTL_AFD_WAIT_FOR_LISTEN         _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN, METHOD_BUFFERED )
#define IOCTL_AFD_ACCEPT                  _AFD_CONTROL_CODE( AFD_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_RECEIVE                 _AFD_CONTROL_CODE( AFD_RECEIVE, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_DATAGRAM        _AFD_CONTROL_CODE( AFD_RECEIVE_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_SEND                    _AFD_CONTROL_CODE( AFD_SEND, METHOD_NEITHER )
#define IOCTL_AFD_SEND_DATAGRAM           _AFD_CONTROL_CODE( AFD_SEND_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_POLL                    _AFD_CONTROL_CODE( AFD_POLL, METHOD_BUFFERED )
#define IOCTL_AFD_PARTIAL_DISCONNECT      _AFD_CONTROL_CODE( AFD_PARTIAL_DISCONNECT, METHOD_NEITHER )

#define IOCTL_AFD_GET_ADDRESS             _AFD_CONTROL_CODE( AFD_GET_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_RECEIVE_INFO      _AFD_CONTROL_CODE( AFD_QUERY_RECEIVE_INFO, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_HANDLES           _AFD_CONTROL_CODE( AFD_QUERY_HANDLES, METHOD_NEITHER )
#define IOCTL_AFD_SET_INFORMATION         _AFD_CONTROL_CODE( AFD_SET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_GET_REMOTE_ADDRESS      _AFD_CONTROL_CODE( AFD_GET_REMOTE_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONTEXT             _AFD_CONTROL_CODE( AFD_GET_CONTEXT, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONTEXT             _AFD_CONTROL_CODE( AFD_SET_CONTEXT, METHOD_NEITHER )

#define IOCTL_AFD_SET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_SET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_SET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_GET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_GET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_SIZE_CONNECT_DATA       _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_CONNECT_OPTIONS    _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_DATA    _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_OPTIONS _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_INFORMATION         _AFD_CONTROL_CODE( AFD_GET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_FILE           _AFD_CONTROL_CODE( AFD_TRANSMIT_FILE, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_ACCEPT            _AFD_CONTROL_CODE( AFD_SUPER_ACCEPT, METHOD_NEITHER )

#define IOCTL_AFD_EVENT_SELECT            _AFD_CONTROL_CODE( AFD_EVENT_SELECT, METHOD_NEITHER )
#define IOCTL_AFD_ENUM_NETWORK_EVENTS     _AFD_CONTROL_CODE( AFD_ENUM_NETWORK_EVENTS, METHOD_NEITHER )

#define IOCTL_AFD_DEFER_ACCEPT            _AFD_CONTROL_CODE( AFD_DEFER_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_WAIT_FOR_LISTEN_LIFO    _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN_LIFO, METHOD_BUFFERED )
#define IOCTL_AFD_SET_QOS                 _AFD_CONTROL_CODE( AFD_SET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_GET_QOS                 _AFD_CONTROL_CODE( AFD_GET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_NO_OPERATION            _AFD_CONTROL_CODE( AFD_NO_OPERATION, METHOD_NEITHER )
#define IOCTL_AFD_VALIDATE_GROUP          _AFD_CONTROL_CODE( AFD_VALIDATE_GROUP, METHOD_BUFFERED )
#define IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA _AFD_CONTROL_CODE( AFD_GET_UNACCEPTED_CONNECT_DATA, METHOD_NEITHER )

#define IOCTL_AFD_ROUTING_INTERFACE_QUERY  _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ROUTING_INTERFACE_CHANGE _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_ADDRESS_LIST_QUERY       _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ADDRESS_LIST_CHANGE      _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_JOIN_LEAF                _AFD_CONTROL_CODE( AFD_JOIN_LEAF, METHOD_NEITHER )
#define IOCTL_AFD_TRANSPORT_IOCTL          _AFD_CONTROL_CODE( AFD_TRANSPORT_IOCTL, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_PACKETS         _AFD_CONTROL_CODE( AFD_TRANSMIT_PACKETS, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_CONNECT            _AFD_CONTROL_CODE( AFD_SUPER_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_DISCONNECT         _AFD_CONTROL_CODE( AFD_SUPER_DISCONNECT, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_MESSAGE          _AFD_CONTROL_CODE( AFD_RECEIVE_MESSAGE, METHOD_NEITHER )




//
// SAN support
//
//

//
// SAN IOCTL control codes.
//

#define IOCTL_AFD_SWITCH_CEMENT_SAN     _AFD_CONTROL_CODE( AFD_SWITCH_CEMENT_SAN, METHOD_NEITHER )
/*++
Ioctl Description:
    Changes the AFD endpoint type to SAN to indicate that
    it is used for support of user mode SAN providers
    Associates switch context with the endpoint.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ingored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond to AFD
                                endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_SET_EVENTS     _AFD_CONTROL_CODE( AFD_SWITCH_SET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Sets the poll event on the san endpoint to report
    to the application via various forms of the select.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint (except
                                                AFD_POLL_EVENT_CONNECT_FAIL which
                                                just needs a bound endpoint).
                            SwitchContext   - switch context associated with endpoint (NULL
                                                for AFD_POLL_EVENT_CONNECT_FAIL) to validate
                                                the handle-endpoint association
                            EventBit        - event bit to set
                            Status          - associated status (for AFD_POLL_EVENT_CONNECT_FAIL)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_RESET_EVENTS   _AFD_CONTROL_CODE( AFD_SWITCH_RESET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Resets the poll event on the san endpoint so that it is no
    longer reported to the application via various forms of the select
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint
                            SwitchContext   - switch context associated with endpoint 
                                                to validate the handle-endpoint association
                            EventBit        - event bit to reset
                            Status          - associated status (ignored)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_CONNECT_IND    _AFD_CONTROL_CODE( AFD_SWITCH_CONNECT_IND, METHOD_OUT_DIRECT )
/*++
Ioctl Description:
    Implements connect indication from SAN provider.
    Picks up the accept from the listening endpoint queue
    or queues the indication an signals the application to come
    down with an accept.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONNECT_INFO):
                            ListenHandle    - handle of the listening endpoint
                            RemoteAddress   - remote and local addresses associated
                                                with indication incoming connection
    InputBufferLength - sizeof(AFD_SWITCH_CONNECT_INFO)+addresses
    OutputBuffer    - output parameters for the operation (AFD_SWITCH_ACCEPT_INFO):
                            AcceptHandle    - handle of the accepting endpoint
                            ReceiveLength   - length of the receive buffer supplied by
                                                the application in AcceptEx
                            
    OutputBufferLength - sizeof (AFD_SWITCH_ACCEPT_INFO)
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or listen socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or listen socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input or output buffers are of incorrect size.
        STATUS_CANCELLED    -  connection indication was cancelled (thread exited or
                                accepting and/or listening socket closed)
        other - failed when attempting to access listening socket, input or output buffers
    IoStatus.Information - sizeof (AFD_SWITCH_ACCEPT_INFO) in case of success.
--*/

#define IOCTL_AFD_SWITCH_CMPL_ACCEPT    _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_ACCEPT, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the acceptance of SAN connection
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the accepting endpoint
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - data to copy into the AcceptEx receive buffer
    OutputBufferLength - size of received data
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_LOCAL_DISCONNECT - accept was aborted by the application.
        other - failed when attempting to access accepte socket, input/output buffers, 
                or switch context.
    IoStatus.Information - Number of bytes copied into application's receive buffer.
--*/


#define IOCTL_AFD_SWITCH_CMPL_REQUEST   _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_REQUEST, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the redirected read/write request processed by SAN provider
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_REQUEST_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies the request to complete
                        RequestStatus - status with which to complete the request (
                                        STATUS_PENDING has special meaning, request
                                        is not completed - merely data is copied)
                        DataOffset - offset in the request buffer to read/write the data
    InputBufferLength - sizeof (AFD_SWITCH_REQUEST_INFO)
    OutputBuffer - switch buffer to read/write data
    OutputBufferLength - length of the buffer
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_CANCELLED - request to be completed has already been cancelled
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied from/to switch buffer.
--*/

#define IOCTL_AFD_SWITCH_CMPL_IO        _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_IO, METHOD_NEITHER )
/*++
Ioctl Description:
    Simulates async IO completion for the switch.
Arguments:
    Handle          - SAN socket handle on which to complete the IO.
    InputBuffer     - input parameters for the operation (IO_STATUS_BLOCK)
                        Status - final operation status
                        Information - associated information (number of bytes 
                                        transferred to/from request buffer(s))
    InputBufferLength - sizeof (IO_STATUS_BLOCK)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_INVALID_PARAMETER - input buffer is of invalid size.
        other - status of the IO operation or failure code when attempting to 
                    access input buffer.
    IoStatus.Information - information from the input buffer
--*/

#define IOCTL_AFD_SWITCH_REFRESH_ENDP   _AFD_CONTROL_CODE( AFD_SWITCH_REFRESH_ENDP, METHOD_NEITHER )
/*++
Ioctl Description:
    Refreshes endpoint so it can be used again in AcceptEx
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                        SocketHandle - Socket to refresh
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
    InputBufferLength - sizeof (AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR _AFD_CONTROL_CODE( AFD_SWITCH_GET_PHYSICAL_ADDR, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns physical address corresponding to provided virtual address.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - user mode virtual address
    InputBufferLength - access mode
    OutputBuffer    - Buffer to place physical address into.
    OutputBufferLength - sizeof (PHYSICAL_ADDRESS)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_BUFFER_TOO_SMALL - output buffer is of incorrect size.
        STATUS_INVALID_PARAMETER - invalid access mode.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - sizeof(PHYSICAL_ADDRESS).
--*/

#define IOCTL_AFD_SWITCH_ACQUIRE_CTX    _AFD_CONTROL_CODE( AFD_SWITCH_ACQUIRE_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests transfer of the socket context to the current process.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_ACQUIRE_CTX_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context to be associated with endpoint 
                                            when context transfered to the current process.
                        SocketCtxBuf  - buffer to receive current socket context from
                                            another process
                        SocketCtxBufSize - size of the buffer
    InputBufferLength - sizeof (AFD_SWITCH_ACQUIRE_CTX_INFO)
    OutputBuffer - buffer to receive data buffered on the socket in another process
                        and not yet delivered to the applicaiton
    OutputBufferLength - length of the receive buffer
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied to receive buffer.
--*/

#define IOCTL_AFD_SWITCH_TRANSFER_CTX   _AFD_CONTROL_CODE( AFD_SWITCH_TRANSFER_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests AFD to transfer endpoint into another process context
Arguments:
    InputBuffer     - input parameters for the operation (AFD_SWITCH_TRANSFER_CTX_INFO)
                        SocketHandle - Socket to transfer
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies corresponding acquire request,
                                        NULL if this is unsolicited request to transfer to
                                        the service process.
                        SocketCtxBuf - socket context to copy destination process
                                            acquire request context buffer
                        SocketCtxSize - size of the context buffer to copy
                        RcvBufferArray - array of buffered data to transfer to 
                                            destination process acquire request
                        RcvBufferCount - number of elements in the array.
    InputBufferLength - sizeof (AFD_SWITCH_TRANSFER_CTX_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - number of bytes copied from RcvBufferArray.
--*/

#define IOCTL_AFD_SWITCH_GET_SERVICE_PID _AFD_CONTROL_CODE( AFD_SWITCH_GET_SERVICE_PID, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns PID of the service process used for intermediate socket duplication.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - pid of the service process.
--*/

#define IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS _AFD_CONTROL_CODE( AFD_SWITCH_SET_SERVICE_PROCESS, METHOD_NEITHER )
/*++
Ioctl Description:
    Notifies AFD that this process will be used for handle duplication services
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_PROVIDER_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_PROVIDER_CHANGE, METHOD_NEITHER )
/*++
Ioctl Description:
        Notifies interested processes of SAN provider addition/deletion/change.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_ADDRLIST_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_ADDRLIST_CHANGE, METHOD_BUFFERED )
/*++
Ioctl Description:
        SAN specific version of address list change notifications.
        Capture provider installation/removal in addition to plain
        address list changes.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - Input parameters for the operation (AFD_TRANSPORT_IOCTL_INFO):
                        AfdFlags - operation flags (e.g. AFD_OVERLAPPED)
                        Handle  - unused
                        PollEvent - unused
                        IoControlCode - IOCTL_AFD_ADDRESS_LIST_CHANGE
                        InputBuffer - pointer to address family (AF_INET)
                        InputBufferLength - sizeof (USHORT)
                        
    InputBufferLength - sizeof (AFD_TRANSPORT_IOCTL_INFO)
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - 0 - regular address list change
                            otherwise, seq number of provider list change.
--*/

// Open packet that identifies SAN helper endpoint used
// for communication between SAN switch and AFD.
// This is EA name
//
#define AfdSwitchOpenPacket     "AfdSwOpenPacket"
#define AFD_SWITCH_OPEN_PACKET_NAME_LENGTH (sizeof(AfdSwitchOpenPacket)-1)

//
// Data passed in the open packet
// This is EA value
//
typedef struct _AFD_SWITCH_OPEN_PACKET {
    HANDLE      CompletionPort; // Completion port notify SAN switch
                                // of SAN io completions
    HANDLE      CompletionEvent;// Completion event to distinguish IO issued
                                // by SAN switch from application IO.
} AFD_SWITCH_OPEN_PACKET, *PAFD_SWITCH_OPEN_PACKET;

typedef struct _AFD_SWITCH_CONTEXT {
    LONG        EventsActive;   // Poll events activated by switch
    LONG        RcvCount;       // Count of polls for receive
    LONG        ExpCount;       // Count of polls for expedited
    LONG        SndCount;       // Count of polls for send
	BOOLEAN		SelectFlag;		// TRUE if app has done any form of select
} AFD_SWITCH_CONTEXT, *PAFD_SWITCH_CONTEXT;


//
// Information for associating AFD endpoint with SAN provider
//
typedef struct _AFD_SWITCH_CONTEXT_INFO {
    HANDLE      SocketHandle;   // Handle to associate with SAN provider
    PAFD_SWITCH_CONTEXT SwitchContext;  // Opaque context value maintained for the switch
} AFD_SWITCH_CONTEXT_INFO, *PAFD_SWITCH_CONTEXT_INFO;

//
// Information for connection indication from SAN provider to AFD
//
typedef struct _AFD_SWITCH_CONNECT_INFO {
    HANDLE              ListenHandle;   // Listening socket handle
    PAFD_SWITCH_CONTEXT SwitchContext;
    TRANSPORT_ADDRESS   RemoteAddress;  // Address of the remote peer wishing
                                        // to connect
} AFD_SWITCH_CONNECT_INFO, *PAFD_SWITCH_CONNECT_INFO;

//
// Information returned by the AFD to switch in response
// to connection indication
//
typedef struct _AFD_SWITCH_ACCEPT_INFO {
    HANDLE              AcceptHandle;   // Socket handle to use to accept connection
    ULONG               ReceiveLength;  // Length of the initial receive buffer (for AcceptEx)
} AFD_SWITCH_ACCEPT_INFO, *PAFD_SWITCH_ACCEPT_INFO;

//
// Information passed by the switch to signal network events on the
// endpoint (socket)
//
typedef struct _AFD_SWITCH_EVENT_INFO {
	HANDLE		SocketHandle;   // Socket handle on which to signal
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
	ULONG		EventBit;       // Event bit to set/reset (AFD_POLL_xxx_BIT constants)
    NTSTATUS    Status;         // Status code associated with the event (this
                                // is used for AFD_POLL_CONNECT_FAIL_BIT)
} AFD_SWITCH_EVENT_INFO, *PAFD_SWITCH_EVENT_INFO;


//
// Information passed by the switch to retreive parameters/complete
// redirected read/write request
//
typedef struct _AFD_SWITCH_REQUEST_INFO {
	HANDLE		SocketHandle;   // Socket handle on which request us active
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Request context that identifies it
    NTSTATUS    RequestStatus;  // Completion status of the request (STATUS_PENDING
                                // indicates that request should NOT be completed yet)
    ULONG       DataOffset;     // Offset from which to start copying data from/to
                                // application's buffer
} AFD_SWITCH_REQUEST_INFO, *PAFD_SWITCH_REQUEST_INFO;



//
// Access type (read access or write access) that's needed for an app buffer
// whose physical address is requested thru AfdSanFastGetPhysicalAddr
//
#define MEM_READ_ACCESS		1
#define MEM_WRITE_ACCESS	2


//
// Information passed between processes when socket is duplicated.
//
typedef struct _AFD_SWITCH_ACQUIRE_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context to be associated with the socket
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
} AFD_SWITCH_ACQUIRE_CTX_INFO, *PAFD_SWITCH_ACQUIRE_CTX_INFO;

typedef struct _AFD_SWITCH_TRANSFER_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Value that identifies corresponding acquire request
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
    LPWSABUF    RcvBufferArray; // Receive buffers to copy to destination process
    ULONG       RcvBufferCount; // Number of receive buffers
    NTSTATUS    Status;         // Status of transfer opertaion.
} AFD_SWITCH_TRANSFER_CTX_INFO, *PAFD_SWITCH_TRANSFER_CTX_INFO;

//
// Request from AFD to switch (passed via completion port)
//
#define AFD_SWITCH_REQUEST_CLOSE    0
/*++
Request Description:
    All references to the socket have been closed in all processes, safe
    to destroy the SAN provider socket and connection
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLOSE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0 (ignored)
--*/

#define AFD_SWITCH_REQUEST_READ     1
/*++
Request Description:
    Read request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_READ)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the receive buffer supplied by the application
--*/

#define AFD_SWITCH_REQUEST_WRITE    2
/*++
Request Description:
    Write request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_WRITE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the send data supplied by the application
--*/

#define AFD_SWITCH_REQUEST_TFCTX    3
/*++
Request Description:
    Another process requests ownership of the socket.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_TFCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - PID of the process requesting ownership.
--*/

#define AFD_SWITCH_REQUEST_CHCTX    4
/*++
Request Description:
    Relationship between socket handle and switch context has become invalid
    (application must have closed the original socket and using duplicated handle)
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CHCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle currently used by the application.
--*/

#define AFD_SWITCH_REQUEST_AQCTX    5
/*++
Request Description:
    Request to service process to acquire ownership of the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - NULL
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_AQCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle of the socket to be acquired.
--*/

#define AFD_SWITCH_REQUEST_CLSOC    6
/*++
Request Description:
    Request to service process to close the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLSOC)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0.
--*/


#define AFD_SWITCH_REQUEST_ID_SHIFT 3
#define AFD_SWITCH_REQUEST_TYPE_MASK    \
            ((1<<AFD_SWITCH_REQUEST_ID_SHIFT)-1)

#define AFD_SWITCH_MAKE_REQUEST_CONTEXT(_id,_type)      \
            UlongToPtr(((_id)<<AFD_SWITCH_REQUEST_ID_SHIFT)+(_type))

//
// Retrives request type from the request context
//
#define AFD_SWITCH_REQUEST_TYPE(_RequestContext)        \
        (((ULONG_PTR)(_RequestContext))&AFD_SWITCH_REQUEST_TYPE_MASK)

#endif // ndef _AFD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\apiworke.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/*++

Revision History:

    16-Jan-1992 JohnRo
        The redirector always expects UNICODE for the transact parm name.

--*/

#ifndef _APIWORKE_
#define _APIWORKE_

/*
 * apiworke.h - General defines used by the API worker.
 */

#define REM_MAX_PARMS           360
#define BUF_INC                 200


#define REM_NO_SRV_RESOURCE     55
#define REM_NO_ADMIN_RIGHTS     44

#define REM_API_TIMEOUT         5000            /* 5 second timeout */

/* The REM_API_TXT is the text string that is copied into the parmater
 * packet of the redirector transaction IOCTl following "\\SERVERNAME".
 * The additional \0 is so that the password field is terminated.
 * APIEXTR is the length of this field.
 */
#define REM_APITXT      L"\\PIPE\\LANMAN\0"
#define APIEXTR         (sizeof(REM_APITXT))

/* The pointer identifiers in the descriptor stings are all lower case so
 * thet a quick check can be made for a pointer type. The IS_POINTER macro
 * just checks for > 'Z' for maximum speed.
 */

#define IS_POINTER(x)           ((x) > 'Z')


#define RANGE_F(x,y,z)          (((unsigned long)x >= (unsigned long)y) && \
                                 ((unsigned long)x < ((unsigned long)y + z)))

#endif // ndef _APIWORKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\apiparam.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    apiparam.h

Abstract:

    Declaration of structures representing parameters to the API calls.
    Each structure contains all parameters for a corresponding call,
    except for any server name (PSZ Server) parameters.

Author:

    Shanku Niyogi (w-shanku) 11-Jan-1991

Revision History:

--*/

#ifndef _APIPARAMS_
#define _APIPARAMS_

#include <packon.h>                     // Pack structures.

//
// Access permission APIs.
//

typedef struct _XS_NET_ACCESS_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_ACCESS_ADD, *PXS_NET_ACCESS_ADD;

typedef struct _XS_NET_ACCESS_CHECK {
    LPSTR Reserved;
    LPSTR UserName;
    LPSTR Resource;
    WORD Operation;
    WORD Result;
} XS_NET_ACCESS_CHECK, *PXS_NET_ACCESS_CHECK;

typedef struct _XS_NET_ACCESS_DEL {
    LPSTR Resource;
} XS_NET_ACCESS_DEL, *PXS_NET_ACCESS_DEL;

typedef struct _XS_NET_ACCESS_ENUM {
    LPSTR BasePath;
    WORD Recursive;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_ACCESS_ENUM, *PXS_NET_ACCESS_ENUM;

typedef struct _XS_NET_ACCESS_GET_INFO {
    LPSTR Resource;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_ACCESS_GET_INFO, *PXS_NET_ACCESS_GET_INFO;

typedef struct _XS_NET_ACCESS_SET_INFO {
    LPSTR Resource;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_ACCESS_SET_INFO, *PXS_NET_ACCESS_SET_INFO;

typedef struct _XS_NET_ACCESS_GET_USER_PERMS {
    LPSTR UgName;
    LPSTR Resource;
    WORD Perms;
} XS_NET_ACCESS_GET_USER_PERMS, *PXS_NET_ACCESS_GET_USER_PERMS;

//
// Account APIs.
//

typedef struct _XS_I_NET_ACCOUNT_DELTAS {
    LPSTR ComputerName;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    LPBYTE RecordID;
    WORD Count;
    WORD Level;
    LPBYTE Buffer;
    WORD BufferLen;
    WORD EntriesRead;
    WORD TotalEntries;
    BYTE NextRecordID[24];
} XS_I_NET_ACCOUNT_DELTAS, *PXS_I_NET_ACCOUNT_DELTAS;

typedef struct _XS_I_NET_ACCOUNT_SYNC {
    LPSTR ComputerName;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    DWORD Reference;
    WORD Level;
    LPBYTE Buffer;
    WORD BufferLen;
    WORD EntriesRead;
    WORD TotalEntries;
    DWORD NextReference;
    BYTE LastRecordID[24];
} XS_I_NET_ACCOUNT_SYNC, *PXS_I_NET_ACCOUNT_SYNC;

//
// Alerter APIs.
//

typedef struct _XS_NET_ALERT_RAISE {
    LPSTR Event;
    LPBYTE Buffer;
    WORD BufLen;
    DWORD Timeout;
} XS_NET_ALERT_RAISE, *PXS_NET_ALERT_RAISE;

typedef struct _XS_NET_ALERT_START {
    LPSTR Event;
    LPSTR Recipient;
    WORD MaxData;
} XS_NET_ALERT_START, *PXS_NET_ALERT_START;

typedef struct _XS_NET_ALERT_STOP {
    LPSTR Event;
    LPSTR Recipient;
} XS_NET_ALERT_STOP, *PXS_NET_ALERT_STOP;

//
// Auditing APIs.
//

typedef struct _XS_NET_AUDIT_CLEAR {
    LPSTR BackupFile;
    LPSTR Reserved;
} XS_NET_AUDIT_CLEAR, *PXS_NET_AUDIT_CLEAR;

typedef struct _XS_NET_AUDIT_OPEN {
    WORD AuditLog;
    LPSTR Reserved;
} XS_NET_AUDIT_OPEN, *PXS_NET_AUDIT_OPEN;

typedef struct _XS_NET_AUDIT_READ {
    LPSTR Reserved1;
    LPBYTE LogHandleIn;
    BYTE LogHandleOut[16];
    DWORD Offset;
    WORD Reserved2;
    DWORD Reserved3;
    DWORD OffsetFlag;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_AUDIT_READ, *PXS_NET_AUDIT_READ;

//
// Character device APIs.
//

typedef struct _XS_NET_CHAR_DEV_CONTROL {
    LPSTR DevName;
    WORD OpCode;
} XS_NET_CHAR_DEV_CONTROL, *PXS_NET_CHAR_DEV_CONTROL;

typedef struct _XS_NET_CHAR_DEV_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} _XS_NET_CHAR_DEV_ENUM, *PXS_NET_CHAR_DEV_ENUM;

typedef struct _XS_NET_CHAR_DEV_GET_INFO {
    LPSTR DevName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_GET_INFO, *PXS_NET_CHAR_DEV_GET_INFO;

typedef struct _XS_NET_CHAR_DEV_Q_ENUM {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_Q_ENUM, *PXS_NET_CHAR_DEV_Q_ENUM;

typedef struct _XS_NET_CHAR_DEV_Q_GET_INFO {
    LPSTR QueueName;
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_Q_GET_INFO, *PXS_NET_CHAR_DEV_Q_GET_INFO;

typedef struct _XS_NET_CHAR_DEV_Q_PURGE {
    LPSTR QueueName;
} XS_NET_CHAR_DEV_Q_PURGE, *PXS_NET_CHAR_DEV_Q_PURGE;

typedef struct _XS_NET_CHAR_DEV_Q_PURGE_SELF {
    LPSTR QueueName;
    LPSTR ComputerName;
} XS_NET_CHAR_DEV_Q_PURGE_SELF, *PXS_NET_CHAR_DEV_Q_PURGE_SELF;

typedef struct _XS_NET_CHAR_DEV_Q_SET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_CHAR_DEV_Q_SET_INFO, *PXS_NET_CHAR_DEV_Q_SET_INFO;

//
// Configuration APIs.
//

typedef struct _XS_NET_CONFIG_GET_2 {
    LPSTR Reserved;
    LPSTR Component;
    LPSTR Parameter;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Parmlen;
} XS_NET_CONFIG_GET_2, *PXS_NET_CONFIG_GET_2;

typedef struct _XS_NET_CONFIG_GET_ALL_2 {
    LPSTR Reserved;
    LPSTR Component;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_CONFIG_GET_ALL_2, *PXS_NET_CONFIG_GET_ALL_2;


//
// Connection API.
//

typedef struct _XS_NET_CONNECTION_ENUM {
    LPSTR Qualifier;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_CONNECTION_ENUM, *PXS_NET_CONNECTION_ENUM;

//
// Domain APIs.
//

typedef struct _XS_NET_GET_DC_NAME {
    LPSTR Domain;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_GET_DC_NAME, *PXS_NET_GET_DC_NAME;

typedef struct _XS_NET_LOGON_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_LOGON_ENUM, *PXS_NET_LOGON_ENUM;

//
// Error logging APIs.
//

typedef struct _XS_NET_ERROR_LOG_CLEAR {
    LPSTR BackupFile;
    LPSTR Reserved;
} XS_NET_ERROR_LOG_CLEAR, *PXS_NET_ERROR_LOG_CLEAR;

typedef struct _XS_NET_ERROR_LOG_READ {
    LPSTR Reserved1;
//    HLOG * ErrorLog;
    DWORD Offset;
    WORD Reserved2;
    DWORD Reserved3;
    DWORD OffsetFlag;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_ERROR_LOG_READ, *PXS_NET_ERROR_LOG_READ;

typedef struct _XS_NET_ERROR_LOG_WRITE {
    LPSTR Reserved1;
    WORD Code;
    LPSTR Component;
    LPBYTE Buffer;
    WORD BufLen;
    LPSTR StrBuf;
    WORD StrBufLen;
    LPSTR Reserved2;
} XS_NET_ERROR_LOG_WRITE, *PXS_NET_ERROR_LOG_WRITE;

//
// File APIs.
//

typedef struct _XS_NET_FILE_CLOSE_2 {
    DWORD FileId;
} XS_NET_FILE_CLOSE_2, *PXS_NET_FILE_CLOSE_2;

typedef struct _XS_NET_FILE_ENUM_2 {
    LPSTR BasePath;
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD EntriesRemaining;
    LPBYTE ResumeKeyIn;
    BYTE ResumeKeyOut[8];
} XS_NET_FILE_ENUM_2, *PXS_NET_FILE_ENUM_2;

typedef struct _XS_NET_FILE_GET_INFO_2 {
    DWORD FileId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_FILE_GET_INFO_2, *PXS_NET_FILE_GET_INFO_2;

//
// Group APIs.
//

typedef struct _XS_NET_GROUP_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_GROUP_ADD, *PXS_NET_GROUP_ADD;

typedef struct _XS_NET_GROUP_DEL {
    LPSTR GroupName;
} XS_NET_GROUP_DEL, *PXS_NET_GROUP_DEL;

typedef struct _XS_NET_GROUP_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_GROUP_ENUM, *PXS_NET_GROUP_ENUM;

typedef struct _XS_NET_GROUP_ADD_USER {
    LPSTR GroupName;
    LPSTR UserName;
} XS_NET_GROUP_ADD_USER, *PXS_NET_GROUP_ADD_USER;

typedef struct _XS_NET_GROUP_DEL_USER {
    LPSTR GroupName;
    LPSTR UserName;
} XS_NET_GROUP_DEL_USER, *PXS_NET_GROUP_DEL_USER;

typedef struct _XS_NET_GROUP_GET_USERS {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_GROUP_GET_USERS, *PXS_NET_GROUP_GET_USERS;

typedef struct _XS_NET_GROUP_SET_USERS {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Entries;
} XS_NET_GROUP_SET_USERS, *PXS_NET_GROUP_SET_USERS;

typedef struct _XS_NET_GROUP_GET_INFO {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_GROUP_GET_INFO, *PXS_NET_GROUP_GET_INFO;

typedef struct _XS_NET_GROUP_SET_INFO {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_GROUP_SET_INFO, *PXS_NET_GROUP_SET_INFO;

//
// Handle APIs.
//

typedef struct _XS_NET_HANDLE_GET_INFO {
    WORD Handle;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_HANDLE_GET_INFO, *PXS_NET_HANDLE_GET_INFO;

typedef struct _XS_NET_HANDLE_SET_INFO {
    WORD Handle;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_HANDLE_SET_INFO, *PXS_NET_HANDLE_SET_INFO;

//
// Mailslot APIs.
//

typedef struct _XS_DOS_MAKE_MAILSLOT {
    LPSTR Name;
    WORD MessageSize;
    WORD MailslotSize;
    WORD Mailslot;
} XS_DOS_MAKE_MAILSLOT, *PXS_DOS_MAKE_MAILSLOT;

typedef struct _XS_DOS_PEEK_MAILSLOT {
    WORD Mailslot;
    LPBYTE Buffer;
    WORD Returned;
    WORD NextSize;
    WORD NextPriority;
} XS_DOS_PEEK_MAILSLOT, *PXS_DOS_PEEK_MAILSLOT;

typedef struct _XS_DOS_DELETE_MAILSLOT {
    WORD Mailslot;
} XS_DOS_DELETE_MAILSLOT, *PXS_DOS_DELETE_MAILSLOT;

typedef struct _XS_DOS_MAILSLOT_INFO {
    WORD Mailslot;
    WORD MessageSize;
    WORD MailslotSize;
    WORD NextSize;
    WORD NextPriority;
    WORD Messages;
} XS_DOS_MAILSLOT_INFO, *PXS_DOS_MAILSLOT_INFO;

typedef struct _XS_DOS_READ_MAILSLOT {
    WORD Mailslot;
    LPBYTE Buffer;
    WORD Returned;
    WORD NextSize;
    WORD NextPriority;
    DWORD Timeout;
} XS_DOS_READ_MAILSLOT, *PXS_DOS_READ_MAILSLOT;

typedef struct _XS_DOS_WRITE_MAILSLOT {
    LPSTR Name;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Priority;
    WORD Class;
    DWORD Timeout;
} XS_DOS_WRITE_MAILSLOT, *PXS_DOS_WRITE_MAILSLOT;

//
// Message APIs.
//

typedef struct _XS_NET_MESSAGE_BUFFER_SEND {
    LPSTR Recipient;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_MESSAGE_BUFFER_SEND, *PXS_NET_MESSAGE_BUFFER_SEND;

typedef struct _XS_NET_MESSAGE_NAME_ADD {
    LPSTR MessageName;
    WORD FwdAction;
} XS_NET_MESSAGE_NAME_ADD, *PXS_NET_MESSAGE_NAME_ADD;

typedef struct _XS_NET_MESSAGE_NAME_DEL {
    LPSTR MessageName;
    WORD FwdAction;
} XS_NET_MESSAGE_NAME_DEL, *PXS_NET_MESSAGE_NAME_DEL;

typedef struct _XS_NET_MESSAGE_NAME_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_MESSAGE_NAME_ENUM, *PXS_NET_MESSAGE_NAME_ENUM;

typedef struct _XS_NET_MESSAGE_NAME_GET_INFO {
    LPSTR MessageName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_MESSAGE_NAME_GET_INFO, *PXS_NET_MESSAGE_NAME_GET_INFO;

//
// NetBIOS APIs.
//

typedef struct _XS_NET_BIOS_OPEN {
    LPSTR DevName;
    LPSTR Reserved;
    WORD OpenOpt;
    WORD DevHandle;
} XS_NET_BIOS_OPEN, *PXS_NET_BIOS_OPEN;

typedef struct _XS_NET_BIOS_CLOSE {
    WORD DevName;
    WORD Reserved;
} XS_NET_BIOS_CLOSE, *PXS_NET_BIOS_CLOSE;

typedef struct _XS_NET_BIOS_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_BIOS_ENUM, *PXS_NET_BIOS_ENUM;

typedef struct _XS_NET_BIOS_GET_INFO {
    LPSTR NetBiosName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_BIOS_GET_INFO, *PXS_NET_BIOS_GET_INFO;

typedef struct _XS_NET_BIOS_SUBMIT {
    WORD DevName;
    WORD NcbOpt;
//    NCB * NCBPointer;
} XS_NET_BIOS_SUBMIT, *PXS_NET_BIOS_SUBMIT;

//
// Path APIs.
//

typedef struct _XS_I_NET_PATH_CANONICALIZE {
    LPSTR PathName;
    LPSTR Outbuf;
    WORD OutbufLen;
    LPSTR Prefix;
    DWORD PathTypeOut;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_CANONICALIZE, *PXS_I_NET_PATH_CANONICALIZE;

typedef struct _XS_I_NET_PATH_COMPARE {
    LPSTR PathName1;
    LPSTR PathName2;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_COMPARE, *PXS_I_NET_PATH_COMPARE;

typedef struct _XS_I_NET_PATH_TYPE {
    LPSTR PathName;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_TYPE, *PXS_I_NET_PATH_TYPE;

typedef struct _XS_I_NET_NAME_CANONICALIZE {
    LPSTR Name;
    LPSTR Outbuf;
    DWORD OutbufLen;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_CANONICALIZE, *PXS_I_NET_NAME_CANONICALIZE;

typedef struct _XS_I_NET_NAME_COMPARE {
    LPSTR Name1;
    LPSTR Name2;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_COMPARE, *PXS_I_NET_NAME_COMPARE;

typedef struct _XS_I_NET_NAME_VALIDATE {
    LPSTR Name;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_VALIDATE, *PXS_I_NET_NAME_VALIDATE;

//
// Print Destination APIs.
//

typedef struct _XS_DOS_PRINT_DEST_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_DOS_PRINT_DEST_ADD, *PXS_DOS_PRINT_DEST_ADD;

typedef struct _XS_DOS_PRINT_DEST_CONTROL {
    LPSTR DestName;
    WORD Control;
} XS_DOS_PRINT_DEST_CONTROL, *PXS_DOS_PRINT_DEST_CONTROL;

typedef struct _XS_DOS_PRINT_DEST_DEL {
    LPSTR PrinterName;
} XS_DOS_PRINT_DEST_DEL, *PXS_DOS_PRINT_DEST_DEL;

typedef struct _XS_DOS_PRINT_DEST_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_DEST_ENUM, *PXS_DOS_PRINT_DEST_ENUM;

typedef struct _XS_DOS_PRINT_DEST_GET_INFO {
    LPSTR Name;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_DEST_GET_INFO, *PXS_DOS_PRINT_DEST_GET_INFO;

typedef struct _XS_DOS_PRINT_DEST_SET_INFO {
    LPSTR Name;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_DEST_SET_INFO, *PXS_DOS_PRINT_DEST_SET_INFO;

//
// Print job APIs.
//

typedef struct _XS_DOS_PRINT_JOB_CONTINUE {
    WORD JobId;
} XS_DOS_PRINT_JOB_CONTINUE, *PXS_DOS_PRINT_JOB_CONTINUE;

typedef struct _XS_DOS_PRINT_JOB_DEL {
    WORD JobId;
} XS_DOS_PRINT_JOB_DEL, *PXS_DOS_PRINT_JOB_DEL;

typedef struct _XS_DOS_PRINT_JOB_ENUM {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_JOB_ENUM, *PXS_DOS_PRINT_JOB_ENUM;

typedef struct _XS_DOS_PRINT_JOB_GET_ID {
//    HFILE File;
//    PPRIDINFO Info;
    WORD InfoLen;
} XS_DOS_PRINT_JOB_GET_ID, *PXS_DOS_PRINT_JOB_GET_ID;

typedef struct _XS_DOS_PRINT_JOB_GET_INFO {
    WORD JobId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_JOB_GET_INFO, *PXS_DOS_PRINT_JOB_GET_INFO;

typedef struct _XS_DOS_PRINT_JOB_PAUSE {
    WORD JobId;
} XS_DOS_PRINT_JOB_PAUSE, *PXS_DOS_PRINT_JOB_PAUSE;

typedef struct _XS_DOS_PRINT_JOB_SET_INFO {
    WORD JobId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_JOB_SET_INFO, *PXS_DOS_PRINT_JOB_SET_INFO;

//
// Printer Queue APIs.
//

typedef struct _XS_DOS_PRINT_Q_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_DOS_PRINT_Q_ADD, *PXS_DOS_PRINT_Q_ADD;

typedef struct _XS_DOS_PRINT_Q_CONTINUE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_CONTINUE, *PXS_DOS_PRINT_Q_CONTINUE;

typedef struct _XS_DOS_PRINT_Q_DEL {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_DEL, *PXS_DOS_PRINT_Q_DEL;

typedef struct _XS_DOS_PRINT_Q_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_Q_ENUM, *PXS_DOS_PRINT_Q_ENUM;

typedef struct _XS_DOS_PRINT_Q_GET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_Q_GET_INFO, *PXS_DOS_PRINT_Q_GET_INFO;

typedef struct _XS_DOS_PRINT_Q_PAUSE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_PAUSE, *PXS_DOS_PRINT_Q_PAUSE;

typedef struct _XS_DOS_PRINT_Q_PURGE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_PURGE, *PXS_DOS_PRINT_Q_PURGE;

typedef struct _XS_DOS_PRINT_Q_SET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_Q_SET_INFO, *PXS_DOS_PRINT_Q_SET_INFO;

//
// Remote APIs.
//

typedef struct _XS_NET_REMOTE_COPY {
    LPSTR SourcePath;
    LPSTR DestPath;
    LPSTR SourcePasswd;
    LPSTR DestPasswd;
    WORD Open;
    WORD Copy;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_COPY, *PXS_NET_REMOTE_COPY;

typedef struct _XS_NET_REMOTE_EXEC {
    LPSTR Reserved1;
    LPSTR FailName;
    WORD FailNameLen;
    WORD Async;
    LPSTR Args;
    LPSTR Envs;
    LPSTR ReturnCodes;
    LPSTR PgmName;
    LPSTR Reserved2;
    WORD RemoteExec;
} XS_NET_REMOTE_EXEC, *PXS_NET_REMOTE_EXEC;

typedef struct _XS_NET_REMOTE_MOVE {
    LPSTR SourcePath;
    LPSTR DestPath;
    LPSTR SourcePasswd;
    LPSTR DestPasswd;
    WORD Open;
    WORD Move;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_MOVE, *PXS_NET_REMOTE_MOVE;

typedef struct _XS_NET_REMOTE_TOD {
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_TOD, *PXS_NET_REMOTE_TOD;

//
// Server APIs.
//

typedef struct _XS_NET_SERVER_AUTHENTICATE {
    LPSTR Requestor;
    LPBYTE Caller;
    BYTE Primary[8];
} XS_NET_SERVER_AUTHENTICATE, *PXS_NET_SERVER_AUTHENTICATE;

typedef struct _XS_NET_SERVER_DISK_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SERVER_DISK_ENUM, *PXS_NET_SERVER_DISK_ENUM;

typedef struct _XS_NET_SERVER_ENUM_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
    DWORD ServerType;
    LPSTR Domain;
} XS_NET_SERVER_ENUM_2, *PXS_NET_SERVER_ENUM_2;

typedef struct _XS_NET_SERVER_ENUM_3 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
    DWORD ServerType;
    LPSTR Domain;
    LPSTR FirstNameToReturn;
} XS_NET_SERVER_ENUM_3, *PXS_NET_SERVER_ENUM_3;

typedef struct _XS_NET_SERVER_GET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SERVER_GET_INFO, *PXS_NET_SERVER_GET_INFO;

typedef struct _XS_NET_SERVER_PASSWORD_SET {
    LPSTR Requestor;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    LPBYTE Password;
} XS_NET_SERVER_PASSWORD_SET, *PXS_NET_SERVER_PASSWORD_SET;

typedef struct _XS_NET_SERVER_REQ_CHALLENGE {
    LPSTR Requestor;
    LPBYTE Caller;
    BYTE Primary[8];
} XS_NET_SERVER_REQ_CHALLENGE, *PXS_NET_SERVER_REQ_CHALLENGE;

typedef struct _XS_NET_SERVER_SET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_SERVER_SET_INFO, *PXS_NET_SERVER_SET_INFO;

//
// Service APIs.
//

typedef struct _XS_NET_SERVICE_CONTROL {
    LPSTR Service;
    WORD OpCode;
    WORD Arg;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_SERVICE_CONTROL, *PXS_NET_SERVICE_CONTROL;

typedef struct _XS_NET_SERVICE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SERVICE_ENUM, *PXS_NET_SERVICE_ENUM;

typedef struct _XS_NET_SERVICE_GET_INFO {
    LPSTR Service;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SERVICE_GET_INFO, *PXS_NET_SERVICE_GET_INFO;

typedef struct _XS_NET_SERVICE_INSTALL {
    LPSTR Service;
    LPBYTE FillSpace;
    LPBYTE RcvBuffer;
    BYTE RetBuffer[88];
} XS_NET_SERVICE_INSTALL, *PXS_NET_SERVICE_INSTALL;

//
// Session APIs.
//

typedef struct _XS_NET_SESSION_DEL {
    LPSTR ClientName;
    WORD Reserved;
} XS_NET_SESSION_DEL, *PXS_NET_SESSION_DEL;

typedef struct _XS_NET_SESSION_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SESSION_ENUM, *PXS_NET_SESSION_ENUM;

typedef struct _XS_NET_SESSION_GET_INFO {
    LPSTR ClientName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SESSION_GET_INFO, *PXS_NET_SESSION_GET_INFO;

//
// Share APIs.
//

typedef struct _XS_NET_SHARE_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_SHARE_ADD, *PXS_NET_SHARE_ADD;

typedef struct _XS_NET_SHARE_CHECK {
    LPSTR DeviceName;
    WORD Type;
} XS_NET_SHARE_CHECK, *PXS_NET_SHARE_CHECK;

typedef struct _XS_NET_SHARE_DEL {
    LPSTR NetName;
    WORD Reserved;
} XS_NET_SHARE_DEL, *PXS_NET_SHARE_DEL;

typedef struct _XS_NET_SHARE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SHARE_ENUM, *PXS_NET_SHARE_ENUM;

typedef struct _XS_NET_SHARE_GET_INFO {
    LPSTR NetName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SHARE_GET_INFO, *PXS_NET_SHARE_GET_INFO;

typedef struct _XS_NET_SHARE_SET_INFO {
    LPSTR NetName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_SHARE_SET_INFO, *PXS_NET_SHARE_SET_INFO;

//
// Statistics APIs.
//

typedef struct _XS_NET_STATISTICS_GET_2 {
    LPSTR Service;
    DWORD Reserved;
    WORD Level;
    DWORD Options;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_STATISTICS_GET_2, *PXS_NET_STATISTICS_GET_2;

//
// Use APIs.
//

typedef struct _XS_NET_USE_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_USE_ADD, *PXS_NET_USE_ADD;

typedef struct _XS_NET_USE_DEL {
    LPSTR UseName;
    WORD Force;
} XS_NET_USE_DEL, *PXS_NET_USE_DEL;

typedef struct _XS_NET_USE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USE_ENUM, *PXS_NET_USE_ENUM;

typedef struct _XS_NET_USE_GET_INFO {
    LPSTR UseName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USE_GET_INFO, *PXS_NET_USE_GET_INFO;

//
// User APIs.
//

typedef struct _XS_NET_USER_ADD_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_ADD_2, *PXS_NET_USER_ADD_2;

typedef struct _XS_NET_USER_DEL {
    LPSTR UserName;
} XS_NET_USER_DEL, *PXS_NET_USER_DEL;

typedef struct _XS_NET_USER_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_ENUM, *PXS_NET_USER_ENUM;

typedef struct _XS_NET_USER_ENUM_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    DWORD ResumeIn;
    DWORD ResumeOut;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_ENUM_2, *PXS_NET_USER_ENUM_2;

typedef struct _XS_NET_USER_GET_INFO {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USER_GET_INFO, *PXS_NET_USER_GET_INFO;

typedef struct _XS_NET_USER_SET_INFO {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
    WORD DataEncryption;
} XS_NET_USER_SET_INFO, *PXS_NET_USER_SET_INFO;

typedef struct _XS_NET_USER_SET_INFO_2 {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_SET_INFO_2, *PXS_NET_USER_SET_INFO_2;

typedef struct _XS_NET_USER_PASSWORD_SET_2 {
    LPSTR UserName;
    LPSTR OldPassword;
    LPSTR NewPassword;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_PASSWORD_SET_2, *PXS_NET_USER_PASSWORD_SET_2;

typedef struct _XS_SAMOEMCHGPASSWORDUSER2_P {
    LPSTR  UserName;
    LPBYTE Buffer;
    WORD   BufLen;
} XS_SAMOEMCHGPASSWORDUSER2_P, *PXS_SAMOEMCHGPASSWORDUSER2_P;


typedef struct _XS_NET_USER_GET_GROUPS {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_GET_GROUPS, *PXS_NET_USER_GET_GROUPS;

typedef struct _XS_NET_USER_SET_GROUPS {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Entries;
} XS_NET_USER_SET_GROUPS, *PXS_NET_USER_SET_GROUPS;

typedef struct _XS_NET_USER_MODALS_GET {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USER_MODALS_GET, *PXS_NET_USER_MODALS_GET;

typedef struct _XS_NET_USER_MODALS_SET {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_USER_MODALS_SET, *PXS_NET_USER_MODALS_SET;

typedef struct _XS_NET_USER_VALIDATE {
    LPSTR Reserved;
    LPSTR UserName;
    LPSTR Password;
    WORD Privilege;
} XS_NET_USER_VALIDATE, *PXS_NET_USER_VALIDATE;

typedef struct _XS_NET_USER_VALIDATE_2 {
    LPSTR Reserved1;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Reserved2;
    WORD TotalAvail;
} XS_NET_USER_VALIDATE_2, *PXS_NET_USER_VALIDATE_2;

//
// Workstation APIs.
//

typedef struct _XS_NET_WKSTA_GET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_GET_INFO, *PXS_NET_WKSTA_GET_INFO;

typedef struct _XS_NET_WKSTA_SET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_WKSTA_SET_INFO, *PXS_NET_WKSTA_SET_INFO;

typedef struct _XS_NET_WKSTA_SET_UID {
    LPSTR UserName;
    LPSTR Password;
    LPSTR Parms;
    WORD LogOff;
} XS_NET_WKSTA_SET_UID, *PXS_NET_WKSTA_SET_UID;

typedef struct _XS_NET_WKSTA_SET_UID_2 {
    LPSTR Reserved;
    LPSTR Domain;
    LPSTR UserName;
    LPSTR Password;
    LPSTR Parms;
    WORD LogoffForce;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_SET_UID_2, *PXS_NET_WKSTA_SET_UID_2;

typedef struct _XS_NET_WKSTA_USER_LOGON {
    LPSTR Reserved1;
    LPSTR Reserved2;
    WORD Level;
    LPBYTE InBuf;
    WORD InBufLen;
    LPBYTE OutBuf;
    WORD OutBufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_USER_LOGON, *PXS_NET_WKSTA_USER_LOGON;

typedef struct _XS_NET_WKSTA_USER_LOGOFF {
    LPSTR Reserved1;
    LPSTR Reserved2;
    WORD Level;
    LPBYTE InBuf;
    WORD InBufLen;
    LPBYTE OutBuf;
    WORD OutBufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_USER_LOGOFF, *PXS_NET_WKSTA_USER_LOGOFF;

#include <packoff.h>

#endif  // ndef _APIPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\acdapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    acdapi.h

Abstract:

    Exported routines from the Implicit Connection
    Driver (rasacd.sys) for use by transports to allow a
    user space process to dynamically create a network
    connection upon a network unreachable error.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDAPI_
#define _ACDAPI_

//
// A callback from the automatic connection
// driver to the transport to continue the
// connection process.
//
typedef VOID (*ACD_CONNECT_CALLBACK)(
    IN BOOLEAN,
    IN PVOID *);

typedef VOID
(*ACD_NEWCONNECTION)(
    IN PACD_ADDR pszAddr,
    IN PACD_ADAPTER pAdapter
    );

typedef BOOLEAN
(*ACD_STARTCONNECTION)(
    IN ULONG ulDriverId,
    IN PACD_ADDR pszAddr,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    );

//
// A callback to allow the caller
// to rummage around in the parameters
// to find the right request to cancel.
// To cancel the connection, the
// ACD_CANCEL_CALLBACK routine returns
// TRUE.
//
typedef BOOLEAN (*ACD_CANCEL_CALLBACK)(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    );

typedef BOOLEAN
(*ACD_CANCELCONNECTION)(
    IN ULONG ulDriverId,
    IN PACD_ADDR pszAddr,
    IN ACD_CANCEL_CALLBACK pProc,
    IN PVOID pArg
    );

//
// The structure a transport client receives
// when it binds (IOCTL_INTERNAL_ACD_BIND) with the driver.
//
typedef struct {
    LIST_ENTRY ListEntry;
    //
    // Provided by the transport.
    //
    KSPIN_LOCK SpinLock;
    ULONG ulDriverId;
    //
    // Filled in by rasacd.sys.
    //
    BOOLEAN fEnabled;
    ACD_NEWCONNECTION lpfnNewConnection;
    ACD_STARTCONNECTION lpfnStartConnection;
    ACD_CANCELCONNECTION lpfnCancelConnection;
} ACD_DRIVER, *PACD_DRIVER;

//
// Internal IOCTL definitions
//
#define IOCTL_INTERNAL_ACD_BIND  \
            _ACD_CTL_CODE(0x1234, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_ACD_UNBIND  \
            _ACD_CTL_CODE(0x1235, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_ACD_QUERY_STATE \
            _ACD_CTL_CODE(0x1236, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  // ifndef _ACDAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\apinums.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1987-1991             **/
/********************************************************************/

#define API_WShareEnum          0
#define API_WShareGetInfo          1
#define API_WShareSetInfo          2
#define API_WShareAdd          3
#define API_WShareDel          4
#define API_NetShareCheck          5
#define API_WSessionEnum          6
#define API_WSessionGetInfo          7
#define API_WSessionDel          8
#define API_WConnectionEnum          9
#define API_WFileEnum          10
#define API_WFileGetInfo          11
#define API_WFileClose          12
#define API_WServerGetInfo          13
#define API_WServerSetInfo          14
#define API_WServerDiskEnum          15
#define API_WServerAdminCommand          16
#define API_NetAuditOpen          17
#define API_WAuditClear          18
#define API_NetErrorLogOpen          19
#define API_WErrorLogClear          20
#define API_NetCharDevEnum          21
#define API_NetCharDevGetInfo          22
#define API_WCharDevControl          23
#define API_NetCharDevQEnum          24
#define API_NetCharDevQGetInfo          25
#define API_WCharDevQSetInfo          26
#define API_WCharDevQPurge          27
#define API_WCharDevQPurgeSelf          28
#define API_WMessageNameEnum          29
#define API_WMessageNameGetInfo          30
#define API_WMessageNameAdd          31
#define API_WMessageNameDel          32
#define API_WMessageNameFwd          33
#define API_WMessageNameUnFwd          34
#define API_WMessageBufferSend          35
#define API_WMessageFileSend          36
#define API_WMessageLogFileSet          37
#define API_WMessageLogFileGet          38
#define API_WServiceEnum          39
#define API_WServiceInstall          40
#define API_WServiceControl          41
#define API_WAccessEnum          42
#define API_WAccessGetInfo          43
#define API_WAccessSetInfo          44
#define API_WAccessAdd          45
#define API_WAccessDel          46
#define API_WGroupEnum          47
#define API_WGroupAdd          48
#define API_WGroupDel          49
#define API_WGroupAddUser          50
#define API_WGroupDelUser          51
#define API_WGroupGetUsers          52
#define API_WUserEnum          53
#define API_WUserAdd          54
#define API_WUserDel          55
#define API_WUserGetInfo          56
#define API_WUserSetInfo          57
#define API_WUserPasswordSet          58
#define API_WUserGetGroups          59
#define API_DeadTableEntry          60
/* This line and number replaced a Dead Entry */
#define API_WWkstaSetUID          62
#define API_WWkstaGetInfo          63
#define API_WWkstaSetInfo          64
#define API_WUseEnum          65
#define API_WUseAdd          66
#define API_WUseDel          67
#define API_WUseGetInfo          68
#define API_WPrintQEnum          69
#define API_WPrintQGetInfo          70
#define API_WPrintQSetInfo          71
#define API_WPrintQAdd          72
#define API_WPrintQDel          73
#define API_WPrintQPause          74
#define API_WPrintQContinue          75
#define API_WPrintJobEnum          76
#define API_WPrintJobGetInfo          77
#define API_WPrintJobSetInfo_OLD          78
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintJobDel          81
#define API_WPrintJobPause          82
#define API_WPrintJobContinue          83
#define API_WPrintDestEnum          84
#define API_WPrintDestGetInfo          85
#define API_WPrintDestControl          86
#define API_WProfileSave          87
#define API_WProfileLoad          88
#define API_WStatisticsGet          89
#define API_WStatisticsClear          90
#define API_NetRemoteTOD          91
#define API_WNetBiosEnum          92
#define API_WNetBiosGetInfo          93
#define API_NetServerEnum          94
#define API_I_NetServerEnum          95
#define API_WServiceGetInfo          96
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintQPurge          103
#define API_NetServerEnum2          104
#define API_WAccessGetUserPerms          105
#define API_WGroupGetInfo          106
#define API_WGroupSetInfo          107
#define API_WGroupSetUsers          108
#define API_WUserSetGroups          109
#define API_WUserModalsGet          110
#define API_WUserModalsSet          111
#define API_WFileEnum2          112
#define API_WUserAdd2          113
#define API_WUserSetInfo2          114
#define API_WUserPasswordSet2          115
#define API_I_NetServerEnum2          116
#define API_WConfigGet2          117
#define API_WConfigGetAll2          118
#define API_WGetDCName          119
#define API_NetHandleGetInfo          120
#define API_NetHandleSetInfo          121
#define API_WStatisticsGet2          122
#define API_WBuildGetInfo          123
#define API_WFileGetInfo2          124
#define API_WFileClose2          125
#define API_WNetServerReqChallenge          126
#define API_WNetServerAuthenticate          127
#define API_WNetServerPasswordSet          128
#define API_WNetAccountDeltas          129
#define API_WNetAccountSync          130
#define API_WUserEnum2          131
#define API_WWkstaUserLogon          132
#define API_WWkstaUserLogoff          133
#define API_WLogonEnum          134
#define API_WErrorLogRead          135
#define API_WI_NetPathType          136
#define API_WI_NetPathCanonicalize          137
#define API_WI_NetPathCompare          138
#define API_WI_NetNameValidate          139
#define API_WI_NetNameCanonicalize          140
#define API_WI_NetNameCompare          141
#define API_WAuditRead          142
#define API_WPrintDestAdd          143
#define API_WPrintDestSetInfo          144
#define API_WPrintDestDel          145
#define API_WUserValidate2          146
#define API_WPrintJobSetInfo          147
#define API_TI_NetServerDiskEnum          148
#define API_TI_NetServerDiskGetInfo          149
#define API_TI_FTVerifyMirror          150
#define API_TI_FTAbortVerify          151
#define API_TI_FTGetInfo          152
#define API_TI_FTSetInfo          153
#define API_TI_FTLockDisk          154
#define API_TI_FTFixError          155
#define API_TI_FTAbortFix          156
#define API_TI_FTDiagnoseError          157
#define API_TI_FTGetDriveStats          158
/* This line and number replaced a Dead Entry */
#define API_TI_FTErrorGetInfo          160
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_NetAccessCheck          163
#define API_NetAlertRaise          164
#define API_NetAlertStart          165
#define API_NetAlertStop          166
#define API_NetAuditWrite          167
#define API_NetIRemoteAPI          168
#define API_NetServiceStatus          169
#define API_I_NetServerRegister          170
#define API_I_NetServerDeregister          171
#define API_I_NetSessionEntryMake          172
#define API_I_NetSessionEntryClear          173
#define API_I_NetSessionEntryGetInfo          174
#define API_I_NetSessionEntrySetInfo          175
#define API_I_NetConnectionEntryMake          176
#define API_I_NetConnectionEntryClear          177
#define API_I_NetConnectionEntrySetInfo          178
#define API_I_NetConnectionEntryGetInfo          179
#define API_I_NetFileEntryMake          180
#define API_I_NetFileEntryClear          181
#define API_I_NetFileEntrySetInfo          182
#define API_I_NetFileEntryGetInfo          183
#define API_AltSrvMessageBufferSend          184
#define API_AltSrvMessageFileSend          185
#define API_wI_NetRplWkstaEnum          186
#define API_wI_NetRplWkstaGetInfo          187
#define API_wI_NetRplWkstaSetInfo          188
#define API_wI_NetRplWkstaAdd          189
#define API_wI_NetRplWkstaDel          190
#define API_wI_NetRplProfileEnum          191
#define API_wI_NetRplProfileGetInfo          192
#define API_wI_NetRplProfileSetInfo          193
#define API_wI_NetRplProfileAdd          194
#define API_wI_NetRplProfileDel          195
#define API_wI_NetRplProfileClone          196
#define API_wI_NetRplBaseProfileEnum          197
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WIServerSetInfo          201
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintDriverEnum          205
#define API_WPrintQProcessorEnum          206
#define API_WPrintPortEnum          207
#define API_WNetWriteUpdateLog          208
#define API_WNetAccountUpdate          209
#define API_WNetAccountConfirmUpdate          210
#define API_WConfigSet          211
#define API_WAccountsReplicate          212
/*   213 is used by WfW  */
#define API_SamOEMChgPasswordUser2_P    214
#define API_NetServerEnum3              215
#define MAX_API         215
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\dhcpcapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpcapi.h

Abstract:

    This file contains function proto types for the DHCP CONFIG API
    functions.

Author:

    Madan Appiah (madana)  Dec-22-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _DHCPCAPI_
#define _DHCPCAPI_

#include <time.h>


HANDLE
APIENTRY
DhcpOpenGlobalEvent(
    VOID
    );

typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;

DWORD
APIENTRY
DhcpAcquireParameters(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpFallbackRefreshParams(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpReleaseParameters(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpEnableDynamicConfig(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpDisableDynamicConfig(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpNotifyConfigChange(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled
    );

#define NOTIFY_FLG_DO_DNS           0x01
#define NOTIFY_FLG_RESET_IPADDR     0x02

DWORD
APIENTRY
DhcpNotifyConfigChangeEx(
    IN LPWSTR ServerName,
    IN LPWSTR AdapterName,
    IN BOOL IsNewIpAddress,
    IN DWORD IpIndex,
    IN DWORD IpAddress,
    IN DWORD SubnetMask,
    IN SERVICE_ENABLE DhcpServiceEnabled,
    IN ULONG Flags
);

DWORD
DhcpQueryHWInfo(
    DWORD   IpInterfaceContext,
    DWORD  *pIpInterfaceInstance,
    LPBYTE HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength
    );

//
// IP address lease apis for RAS .
//



typedef struct _DHCP_CLIENT_UID {
    LPBYTE ClientUID;
    DWORD ClientUIDLength;
} DHCP_CLIENT_UID, *LPDHCP_CLIENT_UID;

typedef struct _DHCP_LEASE_INFO {
    DHCP_CLIENT_UID ClientUID;
    DWORD IpAddress;
    DWORD SubnetMask;
    DWORD DhcpServerAddress;
    DWORD Lease;
    time_t LeaseObtained;
    time_t T1Time;
    time_t T2Time;
    time_t LeaseExpires;
} DHCP_LEASE_INFO, *LPDHCP_LEASE_INFO;

typedef struct _DHCP_OPTION_DATA {
    DWORD OptionID;
    DWORD OptionLen;
    LPBYTE Option;
} DHCP_OPTION_DATA, *LPDHCP_OPTION_DATA;

typedef struct _DHCP_OPTION_INFO {
    DWORD NumOptions;
    LPDHCP_OPTION_DATA OptionDataArray;
} DHCP_OPTION_INFO, *LPDHCP_OPTION_INFO;


typedef struct _DHCP_OPTION_LIST {
    DWORD NumOptions;
    LPWORD OptionIDArray;
} DHCP_OPTION_LIST, *LPDHCP_OPTION_LIST;

DWORD
DhcpLeaseIpAddress(
    DWORD AdapterIpAddress,
    LPDHCP_CLIENT_UID ClientUID,
    DWORD DesiredIpAddress,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_LEASE_INFO *LeaseInfo,
    LPDHCP_OPTION_INFO *OptionInfo
    );

DWORD
DhcpRenewIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo
    );

DWORD
DhcpReleaseIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo
    );


//DOC
//DOC The following are the APIs needed for dhcp-class id UI.
//DOC

enum        /* anonymous */ {
    DHCP_CLASS_INFO_VERSION_0                     // first cut structure version
};

typedef     struct                 _DHCP_CLASS_INFO {
    DWORD                          Version;       // MUST BE DHCP_CLASS_INFO_VERSION_0
    LPWSTR                         ClassName;     // Name of the Class.
    LPWSTR                         ClassDescr;    // Description about the class
    LPBYTE                         ClassData;     // byte stream on the wire data.
    DWORD                          ClassDataLen;  // # of bytes in the ClassData (must be > 0)
} DHCP_CLASS_INFO, *PDHCP_CLASS_INFO, *LPDHCP_CLASS_INFO;

typedef
DWORD
(WINAPI *LPDHCPENUMCLASSES)(
    IN DWORD Flags,
    IN LPWSTR AdapterName,
    IN OUT DWORD *Size,
    IN OUT DHCP_CLASS_INFO *ClassesArray
);

//DOC DhcpEnumClasses enumerates the list of classes available on the system for configuration.
//DOC This is predominantly going to be used by the NetUI. (in which case the ClassData part of the
//DOC DHCP_CLASS_INFO structure is essentially useless).
//DOC Note that Flags is used for future use.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either ALL adapters.
//DOC The Size parameter is an input/output parameter. The input value is the # of bytes of allocated
//DOC space in the ClassesArray buffer.  On return, the meaning of this value depends on the return value.
//DOC If the function returns ERROR_SUCCESS, then, this parameter would return the # of elements in the
//DOC array ClassesArray.  If the function returns ERROR_MORE_DATA, then, this parameter refers to the
//DOC # of bytes space that is actually REQUIRED to hold the information.
//DOC In all other cases, the values in Size and ClassesArray dont mean anything.
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_MORE_DATA
//DOC ERROR_FILE_NOT_FOUND         The DHCP Client is not running and could not be started up.
//DOC ERROR_NOT_ENOUGH_MEMORY      This is NOT the same as ERROR_MORE_DATA
//DOC Win32 errors
//DOC
//DOC Remarks:
//DOC To notify DHCP that some class has changed, please use the DhcpHandlePnPEvent API.
DWORD
WINAPI
DhcpEnumClasses(                                  // enumerate the list of classes available
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AdapterName,   // currently must be AdapterGUID (cannot be NULL yet)
    IN OUT  DWORD                 *Size,          // input # of bytes available in BUFFER, output # of elements in array
    IN OUT  DHCP_CLASS_INFO       *ClassesArray   // pre-allocated buffer
);


enum        /* anonymous */ {                     // who are the recognized callers of this API
    DHCP_CALLER_OTHER  =  0,                      // un-specified user, not one of below
    DHCP_CALLER_TCPUI,                            // the TcpIp UI
    DHCP_CALLER_RAS,                              // the RAS Api
    DHCP_CALLER_API,                              // some one else via DHCP API
};

enum        /* anonymous */ {                     // supported structure versions..
    DHCP_PNP_CHANGE_VERSION_0  = 0                // first cut version structure
};

typedef     struct                 _DHCP_PNP_CHANGE {
    DWORD                          Version;       // MUST BE DHCP_PNP_CHANGE_VERSION_0
    BOOL                           DnsListChanged;// DNS Server list changed
    BOOL                           DomainChanged; // Domain Name changed
    BOOL                           HostNameChanged;  // the DNS Host name changed..
    BOOL                           ClassIdChanged;// ClassId changed
    BOOL                           MaskChanged;   // SubnetMask changed; CURRENTLY NOT USED
    BOOL                           GateWayChanged;// DefaultGateWay changed; CURRENTLY NOT USED
    BOOL                           RouteChanged;  // some STATIC route changed; CURRENTLY NOT USED
    BOOL                           OptsChanged;   // some options changed. CURRENTLY NOT USED
    BOOL                           OptDefsChanged;// some option definitions changed. CURRENTLY NOT USED
    BOOL                           DnsOptionsChanged; // some DNS specific options have changed.
} DHCP_PNP_CHANGE, *PDHCP_PNP_CHANGE, *LPDHCP_PNP_CHANGE;

typedef                                           // this typedef SHOULD match the following declaration.
DWORD
(WINAPI FAR *LPDHCPHANDLEPNPEVENT)(
    IN      DWORD                  Flags,
    IN      DWORD                  Caller,
    IN      LPWSTR                 AdapterName,
    IN      LPDHCP_PNP_CHANGE      Changes,
    IN      LPVOID                 Reserved
);

//DOC DhcpHandlePnpEvent can be called as an API by any process (excepting that executing within the
//DOC DHCP process itself) when any of the registry based configuration has changed and DHCP client has to
//DOC re-read the registry.  The Flags parameter is for future expansion.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either GLOBAL parameters or ALL adapters
//DOC depending on which BOOL has been set. (this may not get done for BETA2).
//DOC The Changes structure gives the information on what changed.
//DOC Currently, only a few of the defined BOOLs would be supported (for BETA2 NT5).
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_CALL_NOT_SUPPORTED     The particular parameter that has changed is not completely pnp yet.
//DOC Win32 errors
DWORD
WINAPI
DhcpHandlePnPEvent(
    IN      DWORD                  Flags,         // MUST BE ZERO
    IN      DWORD                  Caller,        // currently must be DHCP_CALLER_TCPUI
    IN      LPWSTR                 AdapterName,   // currently must be the adapter GUID or NULL if global
    IN      LPDHCP_PNP_CHANGE      Changes,       // specify what changed
    IN      LPVOID                 Reserved       // reserved for future use..
);
//================================================================================
// end of file
//================================================================================
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\gpcifc.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/

#ifndef __GPCIFC
#define __GPCIFC

//***   gpcifc.h - GPC interface definitions
//
//  This file containes all the GPC interface definitions.


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

//
// Protocol Template Id's
//
#define GPC_PROTOCOL_TEMPLATE_IP                  0
#define GPC_PROTOCOL_TEMPLATE_IPX                 1

#define GPC_PROTOCOL_TEMPLATE_MAX                 2

#define GPC_PROTOCOL_TEMPLATE_NOT_SPECIFIED       (-1)

#define DD_GPC_DEVICE_NAME      L"\\Device\\Gpc"

#define GpcMajorVersion 2

//
// GPC max supported priorities
//
#define GPC_PRIORITY_MAX    16

//
// Classification Family IDs
//
#define GPC_CF_QOS			0
#define GPC_CF_IPSEC_OUT	1
#define GPC_CF_IPSEC_IN		2
#define GPC_CF_FILTER		3
#define GPC_CF_CLASS_MAP	4

#define GPC_CF_MAX			5

//
// IPSEC specific
//
#define GPC_PRIORITY_IPSEC	2
#define GPC_CF_IPSEC	    GPC_CF_IPSEC_OUT
#define GPC_CF_IPSEC_MAX    GPC_CF_IPSEC_IN
#define GPC_CF_IPSEC_MIN    GPC_CF_IPSEC_OUT

//
// GPC flags defined
//
#define GPC_FLAGS_FRAGMENT          0x00000001

#define MAX_STRING_LENGTH	256

//
// handle definitions and error codes
//
#define GPC_INVALID_HANDLE	    (-1)

#define GPC_STATUS_SUCCESS				STATUS_SUCCESS
#define GPC_STATUS_PENDING				STATUS_PENDING
#define GPC_STATUS_FAILURE				STATUS_UNSUCCESSFUL
#define GPC_STATUS_RESOURCES			STATUS_INSUFFICIENT_RESOURCES
#define GPC_STATUS_NOTREADY				STATUS_DEVICE_NOT_READY 
#define GPC_STATUS_NOT_FOUND			STATUS_NOT_FOUND
#define GPC_STATUS_CONFLICT				STATUS_DUPLICATE_NAME
#define GPC_STATUS_INVALID_HANDLE		STATUS_INVALID_HANDLE
#define GPC_STATUS_INVALID_PARAMETER	STATUS_INVALID_PARAMETER
#define GPC_STATUS_NOT_SUPPORTED    	STATUS_NOT_SUPPORTED
#define GPC_STATUS_NOT_EMPTY            STATUS_DIRECTORY_NOT_EMPTY
#define GPC_STATUS_TOO_MANY_HANDLES     STATUS_TOO_MANY_OPENED_FILES
#define GPC_STATUS_NOT_IMPLEMENTED      STATUS_NOT_IMPLEMENTED
#define GPC_STATUS_INSUFFICIENT_BUFFER	STATUS_BUFFER_TOO_SMALL
#define GPC_STATUS_NO_MEMORY			STATUS_NO_MEMORY
#define GPC_STATUS_IGNORED				1L


/*
/////////////////////////////////////////////////////////////////
//
//   typedef
//
/////////////////////////////////////////////////////////////////
*/

//
// Gpc status
//
typedef NTSTATUS  GPC_STATUS;

//
// handles
//

typedef HANDLE  GPC_HANDLE, *PGPC_HANDLE;
typedef HANDLE  GPC_CLIENT_HANDLE, *PGPC_CLIENT_HANDLE;

//
// A classification handle is used as a reference to a classification 
// block by the clients
//

typedef ULONG	CLASSIFICATION_HANDLE, *PCLASSIFICATION_HANDLE;

//
// A pointer to the CfInfo blob data that is stored in the GPC.
// The client will use this definition in all references to a CfInfo blob.
//

typedef UCHAR	GPC_CFINFO, *PGPC_CFINFO;

typedef VOID    GPC_PATTERN, *PGPC_PATTERN;

typedef struct _TC_INTERFACE_ID {

    ULONG	InterfaceId;
    ULONG	LinkId;

} TC_INTERFACE_ID, *PTC_INTERFACE_ID;

//
// Clients on the IP stack use the IP template.
// The usage of the union is defined by the value of the ProtocolId,
// which can be IP, TCP, UDP, ICMP or IPSEC.
//
typedef struct _GPC_IP_PATTERN {

    TC_INTERFACE_ID	InterfaceId;
    ULONG			SrcAddr;
    ULONG			DstAddr;
	
    union {
        struct { USHORT s_srcport,s_dstport; } S_un_ports;	      // UDP, TCP
        struct { UCHAR s_type,s_code; USHORT filler; } S_un_icmp; // ICMP
        ULONG	S_Spi;							                  // IPSEC
    } S_un;

    UCHAR	    	ProtocolId;

    UCHAR       	Reserved[3];
    
#define gpcSrcPort	S_un.S_un_ports.s_srcport
#define gpcDstPort	S_un.S_un_ports.s_dstport
#define gpcIcmpType	S_un.S_un_icmp.s_type
#define gpcIcmpCode	S_un.S_un_icmp.s_code
#define gpcSpi		S_un.S_Spi

} GPC_IP_PATTERN, *PGPC_IP_PATTERN;

//
// Clients of the IPX stack will use the IPX pattern
//
typedef struct _GPC_IPX_PATTERN {

    struct {
        ULONG 	NetworkAddress;
        UCHAR 	NodeAddress[6];
        USHORT 	Socket;
    } Src, Dest;

} GPC_IPX_PATTERN, *PGPC_IPX_PATTERN;


typedef struct _GPC_GEN_PATTERN {

    ULONG	ProtocolId;
	ULONG	PatternSize;
	ULONG  	PatternOffset;
	ULONG  	MaskOffset;
    //
    // the pattern and mask bits will follow here...
    //

} GPC_GEN_PATTERN, *PGPC_GEN_PATTERN;


typedef struct _GPC_ENUM_CFINFO_BUFFER {

    ULONG				Length;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    ULONG				CfInfoSize;
    ULONG				CfInfoOffset;	// from the beginning of this buffer
    GPC_CLIENT_HANDLE	OwnerClientCtx;
    ULONG				PatternCount;
    ULONG				PatternMaskLen;
    GPC_GEN_PATTERN		GenericPattern[1];

} GPC_ENUM_CFINFO_BUFFER, *PGPC_ENUM_CFINFO_BUFFER;

/*
/////////////////////////////////////////////////////////////////
//
//   Client handler prototypes
//
/////////////////////////////////////////////////////////////////
*/


typedef
GPC_STATUS
(*GPC_CL_ADD_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_HANDLE				GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID					pCfInfo,
	OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

  
typedef
VOID
(*GPC_CL_ADD_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
VOID
(*GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS	        	Status
    );


typedef
GPC_STATUS
(*GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	PVOID                   pNewCfInfo
    );


typedef
VOID
(*GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
GPC_STATUS
(*GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_CL_GET_CFINFO_NAME)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    OUT	PUNICODE_STRING			CfInfoName
    );


//
// A function list used to pass function pointers for client registration.
//
typedef struct _GPC_CLIENT_FUNC_LIST {

    ULONG 									GpcVersion;
    GPC_CL_ADD_CFINFO_COMPLETE_HANDLER		ClAddCfInfoCompleteHandler;
    GPC_CL_ADD_CFINFO_NOTIFY_HANDLER		ClAddCfInfoNotifyHandler;
    GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER	ClModifyCfInfoCompleteHandler;
    GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER		ClModifyCfInfoNotifyHandler;
    GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER	ClRemoveCfInfoCompleteHandler;
    GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER		ClRemoveCfInfoNotifyHandler;
    GPC_CL_GET_CFINFO_NAME					ClGetCfInfoName;
    
} GPC_CLIENT_FUNC_LIST, *PGPC_CLIENT_FUNC_LIST;


/*
/////////////////////////////////////////////////////////////////
//
//   GPC API prototypes
//
/////////////////////////////////////////////////////////////////
*/


//
// Calls to GPC
//

typedef
GPC_STATUS
(*GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

typedef
GPC_CLIENT_HANDLE
(*GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    );

typedef
GPC_STATUS
(*GPC_GET_ULONG_FROM_CFINFO_HANDLER)(
    IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue
    );

typedef
GPC_STATUS
(*GPC_REGISTER_CLIENT_HANDLER)(
    IN	ULONG					CfId,
	IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
	IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
	IN	GPC_CLIENT_HANDLE		ClientContext,
	OUT	PGPC_HANDLE				pClientHandle
    );

typedef
GPC_STATUS
(*GPC_DEREGISTER_CLIENT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_CFINFO_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN  ULONG					CfInfoSize,
	IN	PVOID					pClientCfInfo,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	OUT	PGPC_HANDLE	    		pGpcCfInfoHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_PATTERN_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					Pattern,
	IN	PVOID					Mask,
	IN	ULONG					Priority,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	OUT	PGPC_HANDLE				pGpcPatternHandle,
	OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

typedef
VOID
(*GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_MODIFY_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
	IN  PVOID	    			pClientCfInfo
    );

typedef
VOID
(*GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle
    );

typedef
VOID
(*GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcPatternHandle
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID			        pPattern,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue,
    IN	BOOLEAN					bNoCache
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PACKET_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					pNdisPacket,   // PNDIS_PACKET type
	IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		pInterfaceId,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    );

typedef struct _GPC_EXPORTED_CALLS {

    ULONG										    GpcVersion;
    HANDLE										    Reserved;
    GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER		    GpcGetCfInfoClientContextHandler;
    GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER	GpcGetCfInfoClientContextWithRefHandler;
    GPC_GET_ULONG_FROM_CFINFO_HANDLER			    GpcGetUlongFromCfInfoHandler;
    GPC_REGISTER_CLIENT_HANDLER					    GpcRegisterClientHandler;
    GPC_DEREGISTER_CLIENT_HANDLER				    GpcDeregisterClientHandler;
    GPC_ADD_CFINFO_HANDLER						    GpcAddCfInfoHandler;
    GPC_ADD_PATTERN_HANDLER						    GpcAddPatternHandler;
    GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER		    GpcAddCfInfoNotifyCompleteHandler;
    GPC_MODIFY_CFINFO_HANDLER					    GpcModifyCfInfoHandler;
    GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcModifyCfInfoNotifyCompleteHandler;
    GPC_REMOVE_CFINFO_HANDLER					    GpcRemoveCfInfoHandler;
    GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcRemoveCfInfoNotifyCompleteHandler;
    GPC_REMOVE_PATTERN_HANDLER					    GpcRemovePatternHandler;
    GPC_CLASSIFY_PATTERN_HANDLER				    GpcClassifyPatternHandler;
    GPC_CLASSIFY_PACKET_HANDLER					    GpcClassifyPacketHandler;

} GPC_EXPORTED_CALLS, *PGPC_EXPORTED_CALLS;


NTSTATUS
GpcInitialize(
	OUT	PGPC_EXPORTED_CALLS		pGpcEntries
    );


NTSTATUS
GpcDeinitialize(
	IN	PGPC_EXPORTED_CALLS		pGpcEntries
    );

#if 0
NTSTATUS
GetInterfaceIdFromIp(
	IN	ULONG   DestAddress,
	IN	PULONG  pBestIfIndex
    );
#endif

#endif // __GPCIFC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\dlcio.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
          (c) 1991  Nokia Data Systems AB

Module Name:

    ntccbs.h

Abstract:

    This file defines the internal DLC API data structures used by
    Windows/NT DLC.  Most parameter structures are copied directly,
    but here are also defined some new structures for internal use.
    
Author:

    Antti Saarenheimo   [o-anttis]          6-JUNE-1991

Revision History:

--*/

/*
    The commands in alphanumeric order (just saved here)

LLC_BUFFER_CREATE                            0x0025
LLC_BUFFER_FREE                              0x0027
LLC_BUFFER_GET                               0x0026
LLC_DIR_CLOSE_ADAPTER                        0x0004
LLC_DIR_CLOSE_DIRECT                         0x0034
LLC_DIR_INITIALIZE                           0x0020
LLC_DIR_INTERRUPT                            0x0000
LLC_DIR_OPEN_ADAPTER                         0x0003
LLC_DIR_OPEN_DIRECT                          0x0035
LLC_DIR_READ_LOG                             0x0008
LLC_DIR_SET_EXCEPTION_FLAGS                  0x002D
LLC_DIR_SET_FUNCTIONAL_ADDRESS               0x0007
LLC_DIR_SET_GROUP_ADDRESS                    0x0006
LLC_DIR_STATUS                               0x0021
LLC_DIR_TIMER_CANCEL                         0x0023
LLC_DIR_TIMER_CANCEL_GROUP                   0x002C
LLC_DIR_TIMER_SET                            0x0022
LLC_DLC_CLOSE_SAP                            0x0016
LLC_DLC_CLOSE_STATION                        0x001A
LLC_DLC_CONNECT_STATION                      0x001B
LLC_DLC_FLOW_CONTROL                         0x001D
LLC_DLC_MODIFY                               0x001C
LLC_DLC_OPEN_SAP                             0x0015
LLC_DLC_OPEN_STATION                         0x0019
LLC_DLC_REALLOCATE_STATIONS                  0x0017
LLC_DLC_RESET                                0x0014
LLC_DLC_SET_THRESHOLD                        0x0033
LLC_DLC_STATISTICS                           0x001E
LLC_READ                                     0x0031
LLC_READ_CANCEL                              0x0032
LLC_RECEIVE                                  0x0028
LLC_RECEIVE_CANCEL                           0x0029
LLC_RECEIVE_MODIFY                           0x002A
LLC_TRANSMIT_DIR_FRAME                       0x000A
LLC_TRANSMIT_FRAMES                          0x0009
LLC_TRANSMIT_I_FRAME                         0x000B
LLC_TRANSMIT_TEST_CMD                        0x0011
LLC_TRANSMIT_UI_FRAME                        0x000D
LLC_TRANSMIT_XID_CMD                         0x000E
LLC_TRANSMIT_XID_RESP_FINAL                  0x000F
LLC_TRANSMIT_XID_RESP_NOT_FINAL              0x0010

*/

//
//  Change this version number whenever the driver-acslan api has
//  been changed or both modules must be changed.
//
#define NT_DLC_IOCTL_VERSION        1

//
//  Defines the maximum number of buffer segments used in a transmit.
//  Max IBM token-ring frame may consist about 72 buffers ((18 * 4) * 256),
//  if the application uses 256 bytes as its buffer size.
//
#define MAX_TRANSMIT_SEGMENTS       128     // takes about 1 kB in stack!!!

//
//  We use three different CCB structures:  the first one is needed
//  to allocate space for whole ccb, if READ and RECEIVE parameter table
//  is catenated to CCB structure (=> we have only one output buffer).
//  The second input CCB buffer is used with the commands having no
//  input parameters except those in CCB parameter table field
//  (all close commands, DirTimerSet).
//  The last buffer is always returned by asynchronous dlc commands.
//
typedef struct _NT_DLC_CCB {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    OUT UCHAR       uchInformation;        // # successful transmits
    IN PVOID        pCcbAddress;
    IN ULONG        CommandCompletionFlag;
    union {
        IN PLLC_PARMS   pParameterTable; // pointer to the parameter table
        IN PVOID        pMdl;
        struct {
            IN USHORT       usStationId;    // Station id
            IN USHORT       usParameter;    // optional parameter
        } dlc;
        struct {
            IN USHORT       usParameter0;   // first optional parameter
            IN USHORT       usParameter1;   // second optional parameter
        } dir;
        IN UCHAR            auchBuffer[4];  // group/functional address
        IN ULONG            ulParameter;
    } u;
    ULONG           Reserved1;
    ULONG           Reserved2;

//  (I am still thinking about this):
//
//  The multiple frame transmit should return the number a successfully
//  sent frames or otherwise it's not useable for higher protocols.
//  We should actually free the transmit buffers only as far as the
//  transmits succeeds.  The buffers should not be released after the
//  first error, because then the data would be lost for ever.  The only thing
//  the user need to know is how many sequestial frames were sent successfully.
//  The number is also the index of the first failed frame, when one 
//  of the frames fails.  The frames are not necessary completed in 
//  same order, because the error may happed in DlcTransmit, LlcSendX or
//  asynchronoulsy (eg. link lost) => we need the index of the first
//  failing frame.  The frame must not be released, if its index is higher
//  than that of the first failed frame. A new error (async) be overwrite
//  an earlier (sync) error having higher sequency number.
//  Initially the number of successful frames is -1 and each frame of 
//  the multiple send needs a sequency number.  The last frame copies
//  own sequency number (added by one) to the CCB.
//
//  ULONG           cSuccessfulTransmits;   // REMOVE Reserved2!!!!!
//
} NT_DLC_CCB, *PNT_DLC_CCB;

typedef struct _NT_DLC_CCB_INPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;           // 
    IN ULONG        CommandCompletionFlag;
    union {
        IN OUT PLLC_PARMS   pParameterTable; // pointer to the parameter table
        struct {
            IN USHORT       usStationId;    // Station id
            IN USHORT       usParameter;    // optional parameter
        } dlc;
        struct {
            IN USHORT       usParameter0;   // first optional parameter
            IN USHORT       usParameter1;   // second optional parameter
        } dir;
        IN UCHAR            auchBuffer[4];  // group/functional address
        IN ULONG            ulParameter;
    } u;
} NT_DLC_CCB_INPUT, *PNT_DLC_CCB_INPUT;

typedef struct _NT_DLC_CCB_OUTPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;    // 
} NT_DLC_CCB_OUTPUT, *PNT_DLC_CCB_OUTPUT;

typedef struct _NT_DLC_TRANSMIT2_CCB_OUTPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;    // 
} NT_DLC_TRANSMIT2_CCB_OUTPUT, *PNT_DLC_CCB_TRANSMIT2_OUTPUT;
 
//
//  BUFFER.FREE
//
//  DlcCommand = 0x27
//
//  Internal NT DLC API data structure.
//
typedef struct _NT_DLC_BUFFER_FREE_PARMS {
    IN USHORT               Reserved1;
    OUT USHORT              cBuffersLeft;
    IN USHORT               BufferCount;
    IN USHORT               Reserved2;
    IN LLC_TRANSMIT_DESCRIPTOR    DlcBuffer[1];
} NT_DLC_BUFFER_FREE_PARMS, *PNT_DLC_BUFFER_FREE_PARMS;

typedef struct _NT_DLC_BUFFER_FREE_ALLOCATION {
    IN USHORT               Reserved1;
    OUT USHORT              cBuffersLeft;
    IN USHORT               BufferCount;
    IN USHORT               Reserved2;
    IN LLC_TRANSMIT_DESCRIPTOR    DlcBuffer[MAX_TRANSMIT_SEGMENTS];
} NT_DLC_BUFFER_FREE_ALLOCATION, *PNT_DLC_BUFFER_FREE_ALLOCATION;

typedef struct _NT_DLC_BUFFER_FREE_OUTPUT {
    IN USHORT               Reserved2;
    OUT USHORT              cBuffersLeft;
} NT_DLC_BUFFER_FREE_OUTPUT, *PNT_DLC_BUFFER_FREE_OUTPUT;

//
//  DLC_CONNECT_STATION
//
//  DlcCommand = 0x1b
// (copied by DLC API)
//
#define DLC_MAX_ROUTING_INFOMATION      18
typedef struct _NT_DLC_CONNECT_STATION_PARMS {
    IN LLC_CCB          Ccb;
    IN USHORT           Reserved;
    IN USHORT           StationId;
    IN UCHAR            aRoutingInformation[DLC_MAX_ROUTING_INFOMATION];
    IN USHORT           RoutingInformationLength;
} NT_DLC_CONNECT_STATION_PARMS, *PNT_DLC_CONNECT_STATION_PARMS;

//
//  DLC_FLOW_CONTROL
//
//  DlcCommand = 0x1d
// (copied by DLC API)
//
#define     LLC_VALID_FLOW_CONTROL_BITS 0xc0

//
//  This is special DOS DLC extensions to generate 
//  dlc local busy (dos dlc buffer) indication from 
//  dos dlc support dll.
//
#define     LLC_SET_LOCAL_BUSY_BUFFER   0x20
#define     LLC_DOS_DLC_FLOW_CONTROL    0x1f

typedef struct _NT_DLC_FLOW_CONTROL_PARMS {
    IN USHORT           StationId;
    IN UCHAR            FlowControlOption;
    IN UCHAR            Reserved;
} NT_DLC_FLOW_CONTROL_PARMS, *PNT_DLC_FLOW_CONTROL_PARMS;

//
//  DLC_SET_INFORMATION
//
//  This command is used to set the parameters of a link 
//  station or a sap. A null field in the station id struct
//  defines a 
//
//  DlcCommand = 0x1c
//

//
//  Info classes for datalink Set/Query Information
//
enum _DLC_INFO_CLASS_TYPES {
    DLC_INFO_CLASS_STATISTICS,          // get
    DLC_INFO_CLASS_STATISTICS_RESET,    // get and reset
    DLC_INFO_CLASS_DLC_TIMERS,          // get/set
    DLC_INFO_CLASS_DIR_ADAPTER,         // get
    DLC_INFO_CLASS_DLC_ADAPTER,         // get
    DLC_INFO_CLASS_PERMANENT_ADDRESS,   // get
    DLC_INFO_CLASS_LINK_STATION,        // set
    DLC_INFO_CLASS_DIRECT_INFO,         // set
    DLC_INFO_CLASS_GROUP,               // set
    DLC_INFO_CLASS_RESET_FUNCTIONAL,    // set
    DLC_INFO_CLASS_SET_GROUP,           // set / get 
    DLC_INFO_CLASS_SET_FUNCTIONAL,      // set / get
    DLC_INFO_CLASS_ADAPTER_LOG,         // get
    DLC_INFO_CLASS_SET_MULTICAST        // set
};
#define     DLC_MAX_GROUPS  127         // max for group saps

typedef struct _LinkStationInfoSet {
    IN UCHAR            TimerT1;
    IN UCHAR            TimerT2;
    IN UCHAR            TimerTi;
    IN UCHAR            MaxOut;
    IN UCHAR            MaxIn;
    IN UCHAR            MaxOutIncrement;
    IN UCHAR            MaxRetryCount;
    IN UCHAR            TokenRingAccessPriority;
    IN USHORT           MaxInformationField;
} DLC_LINK_PARAMETERS, * PDLC_LINK_PARAMETERS;

typedef struct _LLC_TICKS {
    UCHAR       T1TickOne;       // default short delay for response timer
    UCHAR       T2TickOne;       // default short delay for ack delay timer
    UCHAR       TiTickOne;       // default short delay for inactivity timer
    UCHAR       T1TickTwo;       // default short delay for response timer
    UCHAR       T2TickTwo;       // default short delay for ack delay timer
    UCHAR       TiTickTwo;       // default short delay for inactivity timer
} LLC_TICKS, *PLLC_TICKS;

typedef union _TR_BROADCAST_ADDRESS
{
    ULONG   ulAddress;
    UCHAR   auchAddress[4];
} TR_BROADCAST_ADDRESS, *PTR_BROADCAST_ADDRESS;

typedef struct _NT_DLC_SET_INFORMATION_PARMS {
    struct _DlcSetInfoHeader {
        IN USHORT           StationId;
        IN USHORT           InfoClass;
    } Header;
    union {
        // InfoClass = DLC_INFO_CLASS_LINK_STATION
        DLC_LINK_PARAMETERS LinkStation;

        // InfoClass = DLC_INFO_CLASS_GROUP
        struct _DlcSapInfoSet {
            IN UCHAR            GroupCount;
            IN UCHAR            GroupList[DLC_MAX_GROUPS];
        } Sap;

        // InfoClass = DLC_INFO_CLASS_DIRECT_STATION
        struct _DlcDirectStationInfoSet {
            IN ULONG            FrameMask;
        } Direct;

        // InfoClass = DLC_INFO_CLASS_DLC_TIMERS
        LLC_TICKS TimerParameters;

        // InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_SET_GROUP
        UCHAR   Buffer[1];
        
        // InfoClass = DLC_INFO_CLASS_SET_MULTICAST
        UCHAR   auchMulticastAddress[6];
      
        TR_BROADCAST_ADDRESS Broadcast;
    } Info;
} NT_DLC_SET_INFORMATION_PARMS, *PNT_DLC_SET_INFORMATION_PARMS;

typedef struct _DlcAdapterInfoGet {
            OUT UCHAR           MaxSap;
            OUT UCHAR           OpenSaps;
            OUT UCHAR           MaxStations;
            OUT UCHAR           OpenStations;
            OUT UCHAR           AvailStations;
} LLC_ADAPTER_DLC_INFO, *PLLC_ADAPTER_DLC_INFO;

//
//  This structure is tailored for DLC DirOpenAdapter and DirStatus 
//  functions.
//
typedef struct _LLC_ADAPTER_INFO { 
    UCHAR               auchNodeAddress[6];
    UCHAR               auchGroupAddress[4];
    UCHAR               auchFunctionalAddress[4];
    USHORT              usAdapterType; //  (struct may not be dword align!)
    USHORT              usReserved;
    USHORT              usMaxFrameSize;
    ULONG               ulLinkSpeed;
} LLC_ADAPTER_INFO, *PLLC_ADAPTER_INFO;

//
//  DLC_QUERY_INFOMATION
//
//  This command is used to set the parameters of a link 
//  station or a sap. A null field in the station id struct
//  defines a 
//
//  DlcCommand = 
//

typedef union _NT_DLC_QUERY_INFORMATION_OUTPUT {
// (Query dlc parameters not used by DLC)
//        // InfoClass = DLC_INFO_CLASS_STATION_INFO for link station
//        DLC_LINK_PARAMETERS Link;
//        // InfoClass = DLC_INFO_CLASS_DIRECT_INFO for direct station
//      struct _DlcDirectStationInfoGet {
//         OUT ULONG           FrameMask;
//      } Direct;

        // InfoClass = DLC_INFO_CLASS_DIR_ADAPTER;
        LLC_ADAPTER_INFO    DirAdapter;

        // InfoClass = DLC_INFO_CLASS_SAP
        struct _DlcSapInfoGet {
            OUT USHORT          MaxInformationField;
            OUT UCHAR           MaxMembers;
            OUT UCHAR           GroupCount;
            OUT UCHAR           GroupList[DLC_MAX_GROUPS];
        } Sap;

        // InfoClass = DLC_INFO_CLASS_LINK_STATION
        struct _DlcLinkInfoGet {
            OUT USHORT          MaxInformationField;
        } Link;

        // InfoClass = DLC_INFO_CLASS_DLC_ADAPTER
        LLC_ADAPTER_DLC_INFO    DlcAdapter;

//        struct _DlcInfoSetBroadcast Broadcast;

        // InfoClass = DLC_INFO_CLASS_DLC_TIMERS
        LLC_TICKS TimerParameters;

        // InfoClass = DLC_INFO_CLASS_ADAPTER_LOG
        LLC_ADAPTER_LOG AdapterLog;

        // InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_SET_GROUP
        UCHAR   Buffer[1];
} NT_DLC_QUERY_INFORMATION_OUTPUT, *PNT_DLC_QUERY_INFORMATION_OUTPUT;

typedef struct _NT_DLC_QUERY_INFORMATION_INPUT {
    IN USHORT           StationId;
    IN USHORT           InfoClass;
} NT_DLC_QUERY_INFORMATION_INPUT, *PNT_DLC_QUERY_INFORMATION_INPUT;

typedef union _NT_DLC_QUERY_INFORMATION_PARMS {
    NT_DLC_QUERY_INFORMATION_INPUT Header;
    NT_DLC_QUERY_INFORMATION_OUTPUT Info;
} NT_DLC_QUERY_INFORMATION_PARMS, *PNT_DLC_QUERY_INFORMATION_PARMS;

//
//  DLC_OPEN_SAP
//
//  DlcCommand = 0x15
//
typedef struct _NT_DLC_OPEN_SAP_PARMS {
    OUT USHORT          StationId;        // SAP or link station id
    IN USHORT           UserStatusValue;
    IN DLC_LINK_PARAMETERS LinkParameters;
    IN UCHAR            SapValue;
    IN UCHAR            OptionsPriority;
    IN UCHAR            StationCount;   
    IN UCHAR            Reserved1[7];
    IN ULONG            DlcStatusFlag;
    IN UCHAR            Reserved2[8];
    OUT UCHAR           AvailableStations;  // == StationCount
} NT_DLC_OPEN_SAP_PARMS, *PNT_DLC_OPEN_SAP_PARMS;

//
//  NT_DLC_OPEN_STATION
//
//  DlcCommand = 0x19
//
//
typedef struct _NT_DLC_OPEN_STATION_PARMS {
    IN OUT USHORT           LinkStationId;
    IN DLC_LINK_PARAMETERS  LinkParameters;
    IN UCHAR                aRemoteNodeAddress[6];
    IN UCHAR                RemoteSap;
} NT_DLC_OPEN_STATION_PARMS, *PNT_DLC_OPEN_STATION_PARMS;

//
//  NT_DLC_SET_TRESHOLD
//
//  DlcCommand = 0x33
//
//typedef struct _NT_DLC_SET_TRESHOLD_PARMS {
//    IN USHORT           StationId;
//    IN USHORT           Reserved;
//    IN ULONG            BufferTresholdSize;
//    IN PVOID            AlertEvent;
//} NT_DLC_SET_TRESHOLD_PARMS, *PNT_DLC_SET_TRESHOLD_PARMS;

//
//  DIR_OPEN_ADAPTER
//
//  DlcCommand = 0x03
//
//  OUT: Info.ulParameter  = BringUpDiagnostics;
//
#ifndef    MAX_PATH   // I don't want to include whole windows because of this
#define MAX_PATH    260
#endif
typedef struct _NT_DIR_OPEN_ADAPTER_PARMS {
    OUT LLC_ADAPTER_OPEN_PARMS  Adapter;
    IN  PVOID               pSecurityDescriptor;
    IN  PVOID               hBufferPoolHandle;
    IN  LLC_ETHERNET_TYPE   LlcEthernetType;
    IN  ULONG               NtDlcIoctlVersion;
    IN  LLC_TICKS           LlcTicks;
    IN  UCHAR               AdapterNumber;
    IN  UCHAR               uchReserved;
    IN  UNICODE_STRING      NdisDeviceName;
    IN  WCHAR               Buffer[ MAX_PATH ];
} NT_DIR_OPEN_ADAPTER_PARMS, *PNT_DIR_OPEN_ADAPTER_PARMS;

//
//  READ_CANCEL         (DlcCommand = 0x32)
//  DIR_TIMER_CANCEL    (DlcCommand = 0x23)
//
typedef struct _NT_DLC_CANCEL_COMMAND_PARMS {
    IN PVOID   CcbAddress;
} NT_DLC_CANCEL_COMMAND_PARMS, *PNT_DLC_CANCEL_COMMAND_PARMS;

//
//  RECEIVE_CANCEL
//
//  DlcCommand = 0x29
//
typedef struct _NT_DLC_RECEIVE_CANCEL_PARMS {
    PVOID   pCcb;
} NT_DLC_RECEIVE_CANCEL_PARMS, *PNT_DLC_RECEIVE_CANCEL_PARMS;

typedef struct _NT_DLC_COMMAND_CANCEL_PARMS {
    PVOID   pCcb;
} NT_DLC_COMMAND_CANCEL_PARMS, *PNT_DLC_COMMAND_CANCEL_PARMS;

//
//  TRANSMIT_DIR_FRAME
//  TRANSMIT_I_FRAME
//  TRANSMIT_TEST_CMD
//  TRANSMIT_UI_FRAME
//  TRANSMIT_XID_CMD
//  TRANSMIT_XID_RESP_FINAL
//  TRANSMIT_XID_RESP_NOT_FINAL
//  
typedef struct _NT_DLC_TRANSMIT_PARMS {
    IN USHORT       StationId;
    IN USHORT       FrameType;              // DLC frame or ethernet protocol
    IN UCHAR        RemoteSap OPTIONAL;     // used only for DLC types
    IN UCHAR        XmitReadOption;
    OUT UCHAR       FrameStatus;            // not returned by I or new xmit
    IN UCHAR        Reserved;
    IN ULONG        XmitBufferCount;
    IN LLC_TRANSMIT_DESCRIPTOR  XmitBuffer[1];
} NT_DLC_TRANSMIT_PARMS, *PNT_DLC_TRANSMIT_PARMS;

typedef struct _NT_DLC_TRANSMIT_ALLOCATION {
    IN USHORT       StationId;
    IN USHORT       FrameType;
    IN UCHAR        RemoteSap;
    IN UCHAR        XmitReadOption;
    OUT UCHAR       FrameStatus; 
    IN UCHAR        Reserved;
    IN ULONG        XmitBufferCount;
    IN LLC_TRANSMIT_DESCRIPTOR  XmitBuffer[MAX_TRANSMIT_SEGMENTS];
} NT_DLC_TRANSMIT_ALLOCATION;

typedef struct _NT_DLC_TRANSMIT_OUTPUT {
    OUT UCHAR           FrameStatus; 
} NT_DLC_TRANSMIT_OUTPUT, *PNT_DLC_TRANSMIT_OUTPUT;

enum _XMIT_READ_OPTION {
    DLC_CHAIN_XMIT_IN_LINK = 0,
    DLC_DO_NOT_CHAIN_XMIT = 1,
    DLC_CHAIN_XMIT_IN_SAP = 2
};
    
//
//  COMPLETE_COMMAND
//
//  DlcCommand = 0x??
//
//  The command is used to complete all synchronous commands.
//  The DLC API library calls the DLC device driver again with
//  these parameters, when a synchronous DLC command with 
//  COMMAND_COMPLETION_FLAG has completed.
//  The command completes immediately, but the orginal CCB pointer
//  and command completion flag are queued to the even queue
//  or completed immediately with a READ command.
//  The asynchronous commands are queued immediately when they 
//  completes, but their 
//
typedef struct _NT_DLC_COMPLETE_COMMAND_PARMS {
    IN PVOID    pCcbPointer;
    IN ULONG    CommandCompletionFlag;
    IN USHORT   StationId;
    IN USHORT   Reserved;
} NT_DLC_COMPLETE_COMMAND_PARMS, *PNT_DLC_COMPLETE_COMMAND_PARMS;


//
//  There is a small READ_INPUT parameter structure, because we
// do not want to copy all output parameters in every read request.
//  
//
typedef struct _NT_DLC_READ_INPUT {
    IN USHORT           StationId;
    IN UCHAR            OptionIndicator;
    IN UCHAR            EventSet;
    IN PVOID            CommandCompletionCcbLink;
} NT_DLC_READ_INPUT, * PNT_DLC_READ_INPUT;

//
//  This buffer is copied back to user memory, when read parameter table
//  is separate from CCB- table.
//
typedef LLC_READ_PARMS LLC_READ_OUTPUT_PARMS, *PLLC_READ_OUTPUT_PARMS;

//typedef struct _LLC_READ_OUTPUT_PARMS {
//    IN USHORT           usStationId;
//    IN UCHAR            uchOptionIndicator;
//    IN UCHAR            uchEventSet;
//    OUT UCHAR           uchEvent;
//    OUT UCHAR           uchCriticalSubset;
//    OUT ULONG           ulNotificationFlag;
//    union {
//        struct {
//            OUT USHORT          usCcbCount;
//            OUT PLLC_CCB        pCcbCompletionList;
//            OUT USHORT          usBufferCount;
//            OUT PLLC_BUFFER     pFirstBuffer;
//            OUT USHORT          usReceivedFrameCount;
//            OUT PLLC_BUFFER     pReceivedFrame;
//            OUT USHORT          usEventErrorCode;
//            OUT USHORT          usEventErrorData[3];
//        } Event;
//        struct {
//            OUT USHORT          usStationId;
//            OUT USHORT          usDlcStatusCode;
//            OUT UCHAR           uchFrmrData[5];
//            OUT UCHAR           uchAccessPritority;
//            OUT UCHAR           uchRemoteNodeAddress[6];
//            OUT UCHAR           uchRemoteSap;
//            OUT UCHAR           uchReserved;
//            OUT USHORT          usUserStatusValue;
//        } Status;
//    } Type;
//} LLC_READ_OUTPUT_PARMS, *PLLC_READ_OUTPUT_PARMS;

typedef struct _NT_DLC_READ_PARMS {
    IN USHORT           StationId;
    IN UCHAR            OptionIndicator;
    IN UCHAR            EventSet;
    OUT UCHAR           Event;
    OUT UCHAR           CriticalSubset;
    OUT ULONG           NotificationFlag;
    union {
        struct {
            OUT USHORT          CcbCount;
            OUT PVOID           pCcbCompletionList;
            OUT USHORT          BufferCount;
            OUT PLLC_BUFFER     pFirstBuffer;
            OUT USHORT          ReceivedFrameCount;
            OUT PLLC_BUFFER     pReceivedFrame;
            OUT USHORT          EventErrorCode;
            OUT USHORT          EventErrorData[3];
        } Event;
        struct {
            OUT USHORT          StationId;
            OUT USHORT          DlcStatusCode;
            OUT UCHAR           FrmrData[5];
            OUT UCHAR           AccessPritority;
            OUT UCHAR           RemoteNodeAddress[6];
            OUT UCHAR           RemoteSap;
            OUT UCHAR           Reserved;
            OUT USHORT          UserStatusValue;
        } Status;
    } u;
} NT_DLC_READ_PARMS, *PNT_DLC_READ_PARMS;

typedef struct _LLC_IOCTL_BUFFERS {
    USHORT  InputBufferSize;
    USHORT  OutputBufferSize;
} LLC_IOCTL_BUFFERS, *PLLC_IOCTL_BUFFERS;

//
//  This table is used by dlc driver and dlcapi dll modules.
//  In the application level debug version of dlc we link all modules
//  together and this table must be defined only once.  
//
#ifdef INCLUDE_IO_BUFFER_SIZE_TABLE

LLC_IOCTL_BUFFERS aDlcIoBuffers[IOCTL_DLC_LAST_COMMAND] = 
{
    {sizeof(NT_DLC_READ_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(LLC_RECEIVE_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_TRANSMIT_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_BUFFER_FREE_PARMS), 
     sizeof(NT_DLC_BUFFER_FREE_OUTPUT)},
    {sizeof(LLC_BUFFER_GET_PARMS), 
     sizeof(LLC_BUFFER_GET_PARMS)},
    {sizeof(LLC_BUFFER_CREATE_PARMS), 
     sizeof(PVOID)},
// DirInitialize included in DirClose
//    {sizeof( NT_DLC_CCB_INPUT ),
//     sizeof( NT_DLC_CCB_OUTPUT )},              // DIR.INITIALIZE
    {sizeof(LLC_DIR_SET_EFLAG_PARMS), 
     0},
    {sizeof( NT_DLC_CCB_INPUT ),
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.CLOSE.STATION
    {sizeof(NT_DLC_CONNECT_STATION_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_FLOW_CONTROL_PARMS), 
     0},
    {sizeof(NT_DLC_OPEN_STATION_PARMS), 
     sizeof( USHORT )},
    {sizeof( NT_DLC_CCB_INPUT ), 
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.RESET
    {sizeof(NT_DLC_COMMAND_CANCEL_PARMS), 
     0},                                        // READ.CANCEL
    {sizeof(NT_DLC_RECEIVE_CANCEL_PARMS), 
     0},
    {sizeof(NT_DLC_QUERY_INFORMATION_INPUT), 
     0},
    {sizeof( struct _DlcSetInfoHeader ), 
     0},
    {sizeof(NT_DLC_COMMAND_CANCEL_PARMS),       // TIMER.CANCEL
     0},
    {sizeof( NT_DLC_CCB_INPUT ),                // TIMER.CANCEL.GROUP
     sizeof( NT_DLC_CCB_OUTPUT )},              
    {sizeof( NT_DLC_CCB_INPUT ),                // DIR.TIMER.SET
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_OPEN_SAP_PARMS), 
     sizeof(NT_DLC_OPEN_SAP_PARMS)},
    {sizeof( NT_DLC_CCB_INPUT ),
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.CLOSE.SAP
    {sizeof(LLC_DIR_OPEN_DIRECT_PARMS), 
     0},
    {sizeof( NT_DLC_CCB_INPUT ),               // DIR.CLOSE.DIRECT
     sizeof( NT_DLC_CCB_OUTPUT )},             
    {sizeof(NT_DIR_OPEN_ADAPTER_PARMS),         // DIR.OPEN.ADAPTER
     sizeof( LLC_ADAPTER_OPEN_PARMS )},
    {sizeof( NT_DLC_CCB_INPUT ),               // DIR.CLOSE.ADAPTER
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof( LLC_DLC_REALLOCATE_PARMS ),        // DLC.REALLOCATE
     sizeof( LLC_DLC_REALLOCATE_PARMS )},
    {sizeof( NT_DLC_READ_INPUT) + sizeof( LLC_CCB ),    // READ2
     sizeof( NT_DLC_READ_PARMS) + sizeof( LLC_CCB )},
    {sizeof( LLC_RECEIVE_PARMS) + sizeof( LLC_CCB ),    // RECEIVE2 
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof( NT_DLC_TRANSMIT_PARMS ) + sizeof( LLC_CCB ), // TRANSMIT2
     sizeof( NT_DLC_CCB_OUTPUT )}, 
    {sizeof( NT_DLC_COMPLETE_COMMAND_PARMS ),   // DLC.COMPLETE.COMMAND
     0},
//    {sizeof( LLC_TRACE_INITIALIZE_PARMS ) + sizeof( LLC_CCB ),
//     0},
//    {0, 0}
//    {sizeof( NT_NDIS_REQUEST_PARMS ),
//     sizeof( NT_NDIS_REQUEST_PARMS )}
};
#else

extern LLC_IOCTL_BUFFERS aDlcIoBuffers[];

#endif

//
//  All NT DLC API parameters in one structure
//
typedef union _NT_DLC_PARMS {
        NT_DLC_BUFFER_FREE_ALLOCATION   BufferFree;
        LLC_BUFFER_GET_PARMS            BufferGet;
        LLC_BUFFER_CREATE_PARMS         BufferCreate;
        NT_DLC_FLOW_CONTROL_PARMS       DlcFlowControl;
        NT_DLC_OPEN_STATION_PARMS       DlcOpenStation;
        NT_DLC_SET_INFORMATION_PARMS    DlcSetInformation;
        NT_DLC_QUERY_INFORMATION_PARMS  DlcGetInformation;
        NT_DLC_OPEN_SAP_PARMS           DlcOpenSap;
        LLC_DIR_SET_EFLAG_PARMS         DirSetExceptionFlags;
        NT_DLC_CANCEL_COMMAND_PARMS     DlcCancelCommand;
        NT_DLC_RECEIVE_CANCEL_PARMS     ReceiveCancel;
        USHORT                          StationId;
        NT_DLC_COMPLETE_COMMAND_PARMS   CompleteCommand;
        LLC_DLC_REALLOCATE_PARMS        DlcReallocate;
        LLC_DIR_OPEN_DIRECT_PARMS       DirOpenDirect;
        NT_DIR_OPEN_ADAPTER_PARMS       DirOpenAdapter;
//        NT_NDIS_REQUEST_PARMS           NdisRequest;
        LLC_DLC_STATISTICS_PARMS        DlcStatistics;
        LLC_ADAPTER_DLC_INFO            DlcAdapter;
        WCHAR                           UnicodePath[MAX_PATH];

        //
        //  At least DirTimerCancelGroup:
        //
        NT_DLC_CCB_INPUT                InputCcb;

        //
        //  Asynchronous parameters
        //
        //close sap/link/direct,reset, DirTimerSet;
        struct _ASYNC_DLC_PARMS {
            NT_DLC_CCB                          Ccb;
            union {
                UCHAR                           ByteBuffer[512];
                NT_DLC_CONNECT_STATION_PARMS    DlcConnectStation;
                NT_DLC_READ_INPUT               ReadInput;
                NT_DLC_READ_PARMS               Read;
                LLC_RECEIVE_PARMS               Receive;
                NT_DLC_TRANSMIT_ALLOCATION      Transmit;
//                NT_NDIS_REQUEST_PARMS           NdisRequest;
                LLC_TRACE_INITIALIZE_PARMS      TraceInitialize;
            } Parms;
        } Async;
} NT_DLC_PARMS, *PNT_DLC_PARMS;

LLC_STATUS
DlcCallDriver(
    IN UINT AdapterNumber,
    IN UINT IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
LLC_STATUS
NtAcsLan( 
    IN PLLC_CCB pCCB,
    IN PVOID pOrginalCcbAddress,
    OUT PLLC_CCB pOutputCcb,
    IN HANDLE EventHandle OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\dhcpapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpapi.h

Abstract:

    This file contains the DHCP APIs proto-type and description. Also
    contains the data structures used by the DHCP APIs.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

    Cheng Yang (t-cheny)  18-Jun-1996  superscope

--*/

#ifndef _DHCPAPI_
#define _DHCPAPI_

#if defined(MIDL_PASS)
#define LPWSTR [string] wchar_t *
#endif

//
// DHCP data structures.
//

#ifndef _DHCP_

//
// the follwing typedef's are defined in dhcp.h also.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH    0
#define DHCP_DATE_TIME_ZERO_LOW     0

#define DHCP_DATE_TIME_INFINIT_HIGH 0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW  0xFFFFFFFF
#endif

#ifndef DHCP_ENCODE_SEED
#define  DHCP_ENCODE_SEED ((UCHAR)0xA5)
#endif

#ifdef __cplusplus
#define DHCP_CONST   const
#else
#define DHCP_CONST
#endif // __cplusplus

#if (_MSC_VER >= 800)
#define DHCP_API_FUNCTION    __stdcall
#else
#define DHCP_API_FUNCTION
#endif

//
// RPC security.
//

#define DHCP_SERVER_SECURITY            L"DhcpServerApp"
#define DHCP_SERVER_SECURITY_AUTH_ID    10
#define DHCP_NAMED_PIPE                 L"\\PIPE\\DHCPSERVER"
#define DHCP_SERVER_BIND_PORT           L""
#define DHCP_LPC_EP                     L"DHCPSERVERLPC"

#define DHCP_SERVER_USE_RPC_OVER_TCPIP  0x1
#define DHCP_SERVER_USE_RPC_OVER_NP     0x2
#define DHCP_SERVER_USE_RPC_OVER_LPC    0x4

#define DHCP_SERVER_USE_RPC_OVER_ALL (\
            DHCP_SERVER_USE_RPC_OVER_TCPIP | \
            DHCP_SERVER_USE_RPC_OVER_NP    | \
            DHCP_SERVER_USE_RPC_OVER_LPC)

#ifndef HARDWARE_TYPE_10MB_EITHERNET
#define HARDWARE_TYPE_10MB_EITHERNET     (1)
#endif


#define DHCP_RAS_CLASS_TXT    "RRAS.Microsoft"
#define DHCP_BOOTP_CLASS_TXT  "BOOTP.Microsoft"
#define DHCP_MSFT50_CLASS_TXT "MSFT 5.0"
#define DHCP_MSFT98_CLASS_TXT "MSFT 98"            
#define DHCP_MSFT_CLASS_TXT   "MSFT"


typedef DWORD DHCP_IP_MASK;
typedef DWORD DHCP_RESUME_HANDLE;

typedef struct _DHCP_IP_RANGE {
    DHCP_IP_ADDRESS StartAddress;
    DHCP_IP_ADDRESS EndAddress;
} DHCP_IP_RANGE, *LPDHCP_IP_RANGE;

typedef struct _DHCP_BINARY_DATA {
    DWORD DataLength;

#if defined(MIDL_PASS)
    [size_is(DataLength)]
#endif // MIDL_PASS
        BYTE *Data;

} DHCP_BINARY_DATA, *LPDHCP_BINARY_DATA;

typedef DHCP_BINARY_DATA DHCP_CLIENT_UID;

typedef struct _DHCP_HOST_INFO {
    DHCP_IP_ADDRESS IpAddress;      // minimum information always available
    LPWSTR NetBiosName;             // optional information
    LPWSTR HostName;                // optional information
} DHCP_HOST_INFO, *LPDHCP_HOST_INFO;

//
// Flag type that is used to delete DHCP objects.
//

typedef enum _DHCP_FORCE_FLAG {
    DhcpFullForce,
    DhcpNoForce
} DHCP_FORCE_FLAG, *LPDHCP_FORCE_FLAG;

//
// DWORD_DWORD - subtitute for LARGE_INTEGER
//

typedef struct _DWORD_DWORD {
    DWORD DWord1;
    DWORD DWord2;
} DWORD_DWORD, *LPDWORD_DWORD;

//
// Subnet State.
//
// Currently a Subnet scope can be Enabled or Disabled.
//
// If the state is Enabled State,
//  The server distributes address to the client, extends leases and
//  accepts releases.
//
// If the state is Disabled State,
//  The server does not distribute address to any new client, and does
//  extent (and sends NACK) old leases, but the servers accepts lease
//  releases.
//
// The idea behind this subnet state is, when the admin wants to stop
//  serving a subnet, he moves the state from Enbaled to Disabled so
//  that the clients from the subnets smoothly move to another servers
//  serving that subnet. When all or most of the clients move to
//  another server, the admin can delete the subnet without any force
//  if no client left in that subnet, otherwise the admin should use
//  full force to delete the subnet.
//

typedef enum _DHCP_SUBNET_STATE {
    DhcpSubnetEnabled,
    DhcpSubnetDisabled,
    DhcpSubnetEnabledSwitched,
    DhcpSubnetDisabledSwitched
} DHCP_SUBNET_STATE, *LPDHCP_SUBNET_STATE;

//
// Subnet related data structures.
//

typedef struct _DHCP_SUBNET_INFO {
    DHCP_IP_ADDRESS  SubnetAddress;
    DHCP_IP_MASK SubnetMask;
    LPWSTR SubnetName;
    LPWSTR SubnetComment;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE SubnetState;
} DHCP_SUBNET_INFO, *LPDHCP_SUBNET_INFO;

typedef struct _DHCP_IP_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_IP_ADDRESS Elements; //array
} DHCP_IP_ARRAY, *LPDHCP_IP_ARRAY;

typedef struct _DHCP_IP_CLUSTER {
    DHCP_IP_ADDRESS ClusterAddress; // First IP address of the cluster.
    DWORD ClusterMask;              // Cluster usage mask, 0xFFFFFFFF
                                    //  indicates the cluster is fully used.
} DHCP_IP_CLUSTER, *LPDHCP_IP_CLUSTER;

typedef struct _DHCP_IP_RESERVATION {
    DHCP_IP_ADDRESS ReservedIpAddress;
    DHCP_CLIENT_UID *ReservedForClient;
} DHCP_IP_RESERVATION, *LPDHCP_IP_RESERVATION;

typedef enum _DHCP_SUBNET_ELEMENT_TYPE_V5 {
    //
    // If you don't care about what you wan't to  get..
    // NB: These six lines should not be changed!
    //
    DhcpIpRanges,
    DhcpSecondaryHosts,
    DhcpReservedIps,
    DhcpExcludedIpRanges,
    DhcpIpUsedClusters,                     // read only

    //
    //  These are for IP ranges for DHCP ONLY
    //

    DhcpIpRangesDhcpOnly,

    //
    //  These are ranges that are BOTH DHCP & Dynamic BOOTP
    //

    DhcpIpRangesDhcpBootp,

    //
    //  These are ranges that are ONLY BOOTP
    //

    DhcpIpRangesBootpOnly,
} DHCP_SUBNET_ELEMENT_TYPE, *LPDHCP_SUBNET_ELEMENT_TYPE;

#define ELEMENT_MASK(E) ((((E) <= DhcpIpRangesBootpOnly) && (DhcpIpRangesDhcpOnly <= (E)))?(0):(E))

typedef struct _DHCP_SUBNET_ELEMENT_DATA {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION {
        [case(DhcpIpRanges)] DHCP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION {
        DHCP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA, *LPDHCP_SUBNET_ELEMENT_DATA;

#if !defined(MIDL_PASS)
typedef union _DHCP_SUBNET_ELEMENT_UNION
    DHCP_SUBNET_ELEMENT_UNION, *LPDHCP_SUBNET_ELEMENT_UNION;
#endif

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_SUBNET_ELEMENT_DATA Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY;

//
// DHCP Options related data structures.
//

typedef enum _DHCP_OPTION_DATA_TYPE {
    DhcpByteOption,
    DhcpWordOption,
    DhcpDWordOption,
    DhcpDWordDWordOption,
    DhcpIpAddressOption,
    DhcpStringDataOption,
    DhcpBinaryDataOption,
    DhcpEncapsulatedDataOption
} DHCP_OPTION_DATA_TYPE, *LPDHCP_OPTION_DATA_TYPE;


typedef struct _DHCP_OPTION_DATA_ELEMENT {
    DHCP_OPTION_DATA_TYPE    OptionType;
#if defined(MIDL_PASS)
    [switch_is(OptionType), switch_type(DHCP_OPTION_DATA_TYPE)]
    union _DHCP_OPTION_ELEMENT_UNION {
        [case(DhcpByteOption)] BYTE ByteOption;
        [case(DhcpWordOption)] WORD WordOption;
        [case(DhcpDWordOption)] DWORD DWordOption;
        [case(DhcpDWordDWordOption)] DWORD_DWORD DWordDWordOption;
        [case(DhcpIpAddressOption)] DHCP_IP_ADDRESS IpAddressOption;
        [case(DhcpStringDataOption)] LPWSTR StringDataOption;
        [case(DhcpBinaryDataOption)] DHCP_BINARY_DATA BinaryDataOption;
        [case(DhcpEncapsulatedDataOption)] DHCP_BINARY_DATA EncapsulatedDataOption;
        [default] ;
    } Element;
#else
    union _DHCP_OPTION_ELEMENT_UNION {
        BYTE ByteOption;
        WORD WordOption;
        DWORD DWordOption;
        DWORD_DWORD DWordDWordOption;
        DHCP_IP_ADDRESS IpAddressOption;
        LPWSTR StringDataOption;
        DHCP_BINARY_DATA BinaryDataOption;
        DHCP_BINARY_DATA EncapsulatedDataOption;
                // for vendor specific information option.
    } Element;
#endif // MIDL_PASS
} DHCP_OPTION_DATA_ELEMENT, *LPDHCP_OPTION_DATA_ELEMENT;

#if !defined(MIDL_PASS)
typedef union _DHCP_OPTION_ELEMENT_UNION
    DHCP_OPTION_ELEMENT_UNION, *LPDHCP_OPTION_ELEMENT_UNION;
#endif

typedef struct _DHCP_OPTION_DATA {
    DWORD NumElements; // number of option elements in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_DATA_ELEMENT Elements; //array
} DHCP_OPTION_DATA, *LPDHCP_OPTION_DATA;

typedef enum _DHCP_OPTION_TYPE {
    DhcpUnaryElementTypeOption,
    DhcpArrayTypeOption
} DHCP_OPTION_TYPE, *LPDHCP_OPTION_TYPE;

typedef struct _DHCP_OPTION {
    DHCP_OPTION_ID OptionID;
    LPWSTR OptionName;
    LPWSTR OptionComment;
    DHCP_OPTION_DATA DefaultValue;
    DHCP_OPTION_TYPE OptionType;
} DHCP_OPTION, *LPDHCP_OPTION;

typedef struct _DHCP_OPTION_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION Options;  // array
} DHCP_OPTION_ARRAY, *LPDHCP_OPTION_ARRAY;

typedef struct _DHCP_OPTION_VALUE {
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_DATA Value;
} DHCP_OPTION_VALUE, *LPDHCP_OPTION_VALUE;

typedef struct _DHCP_OPTION_VALUE_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_VALUE Values;  // array
} DHCP_OPTION_VALUE_ARRAY, *LPDHCP_OPTION_VALUE_ARRAY;

typedef enum _DHCP_OPTION_SCOPE_TYPE {
    DhcpDefaultOptions,
    DhcpGlobalOptions,
    DhcpSubnetOptions,
    DhcpReservedOptions,
    DhcpMScopeOptions
} DHCP_OPTION_SCOPE_TYPE, *LPDHCP_OPTION_SCOPE_TYPE;

typedef struct _DHCP_RESERVED_SCOPE {
    DHCP_IP_ADDRESS ReservedIpAddress;
    DHCP_IP_ADDRESS ReservedIpSubnetAddress;
} DHCP_RESERVED_SCOPE, *LPDHCP_RESERVED_SCOPE;

typedef struct _DHCP_OPTION_SCOPE_INFO {
    DHCP_OPTION_SCOPE_TYPE ScopeType;
#if defined(MIDL_PASS)
    [switch_is(ScopeType), switch_type(DHCP_OPTION_SCOPE_TYPE)]
    union _DHCP_OPTION_SCOPE_UNION {
        [case(DhcpDefaultOptions)] ; // PVOID DefaultScopeInfo;
        [case(DhcpGlobalOptions)] ;  // PVOID GlobalScopeInfo;
        [case(DhcpSubnetOptions)] DHCP_IP_ADDRESS SubnetScopeInfo;
        [case(DhcpReservedOptions)] DHCP_RESERVED_SCOPE ReservedScopeInfo;
        [case(DhcpMScopeOptions)] LPWSTR MScopeInfo;
        [default] ;
    } ScopeInfo;
#else
    union _DHCP_OPTION_SCOPE_UNION {
        PVOID DefaultScopeInfo; // must be NULL
        PVOID GlobalScopeInfo;  // must be NULL
        DHCP_IP_ADDRESS SubnetScopeInfo;
        DHCP_RESERVED_SCOPE ReservedScopeInfo;
        LPWSTR  MScopeInfo;
    } ScopeInfo;
#endif // MIDL_PASS
} DHCP_OPTION_SCOPE_INFO, *LPDHCP_OPTION_SCOPE_INFO;

#if !defined(MIDL_PASS)
typedef union _DHCP_OPTION_SCOPE_UNION
    DHCP_OPTION_SCOPE_UNION, *LPDHCP_OPTION_SCOPE_UNION;
#endif

typedef struct _DHCP_OPTION_LIST {
    DWORD NumOptions;
#if defined(MIDL_PASS)
    [size_is(NumOptions)]
#endif // MIDL_PASS
        DHCP_OPTION_VALUE *Options;     // array
} DHCP_OPTION_LIST, *LPDHCP_OPTION_LIST;

//
// DHCP Client information data structures
//

typedef struct _DHCP_CLIENT_INFO {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
} DHCP_CLIENT_INFO, *LPDHCP_CLIENT_INFO;

typedef struct _DHCP_CLIENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY, *LPDHCP_CLIENT_INFO_ARRAY;

typedef enum _DHCP_CLIENT_SEARCH_TYPE {
    DhcpClientIpAddress,
    DhcpClientHardwareAddress,
    DhcpClientName
} DHCP_SEARCH_INFO_TYPE, *LPDHCP_SEARCH_INFO_TYPE;

typedef struct _DHCP_CLIENT_SEARCH_INFO {
    DHCP_SEARCH_INFO_TYPE SearchType;
#if defined(MIDL_PASS)
    [switch_is(SearchType), switch_type(DHCP_SEARCH_INFO_TYPE)]
    union _DHCP_CLIENT_SEARCH_UNION {
        [case(DhcpClientIpAddress)] DHCP_IP_ADDRESS ClientIpAddress;
        [case(DhcpClientHardwareAddress)] DHCP_CLIENT_UID ClientHardwareAddress;
        [case(DhcpClientName)] LPWSTR ClientName;
        [default] ;
    } SearchInfo;
#else
    union _DHCP_CLIENT_SEARCH_UNION {
        DHCP_IP_ADDRESS ClientIpAddress;
        DHCP_CLIENT_UID ClientHardwareAddress;
        LPWSTR ClientName;
    } SearchInfo;
#endif // MIDL_PASS
} DHCP_SEARCH_INFO, *LPDHCP_SEARCH_INFO;


#if !defined(MIDL_PASS)
typedef union _DHCP_CLIENT_SEARCH_UNION
    DHCP_CLIENT_SEARCH_UNION, *LPDHCP_CLIENT_SEARCH_UNION;
#endif // MIDL_PASS

//
// Mib Info structures.
//

typedef struct _SCOPE_MIB_INFO {
    DHCP_IP_ADDRESS Subnet;
    DWORD NumAddressesInuse;
    DWORD NumAddressesFree;
    DWORD NumPendingOffers;
} SCOPE_MIB_INFO, *LPSCOPE_MIB_INFO;

typedef struct _DHCP_MIB_INFO {
    DWORD Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Acks;
    DWORD Naks;
    DWORD Declines;
    DWORD Releases;
    DATE_TIME ServerStartTime;
    DWORD Scopes;
#if defined(MIDL_PASS)
    [size_is(Scopes)]
#endif // MIDL_PASS
    LPSCOPE_MIB_INFO ScopeInfo; // array.
} DHCP_MIB_INFO, *LPDHCP_MIB_INFO;

#define Set_APIProtocolSupport          0x00000001
#define Set_DatabaseName                0x00000002
#define Set_DatabasePath                0x00000004
#define Set_BackupPath                  0x00000008
#define Set_BackupInterval              0x00000010
#define Set_DatabaseLoggingFlag         0x00000020
#define Set_RestoreFlag                 0x00000040
#define Set_DatabaseCleanupInterval     0x00000080
#define Set_DebugFlag                   0x00000100
#define Set_PingRetries                 0x00000200
#define Set_BootFileTable               0x00000400
#define Set_AuditLogState               0x00000800

typedef struct _DHCP_SERVER_CONFIG_INFO {
    DWORD APIProtocolSupport;       // bit map of the protocols supported.
    LPWSTR DatabaseName;            // JET database name.
    LPWSTR DatabasePath;            // JET database path.
    LPWSTR BackupPath;              // Backup path.
    DWORD BackupInterval;           // Backup interval in mins.
    DWORD DatabaseLoggingFlag;      // Boolean database logging flag.
    DWORD RestoreFlag;              // Boolean database restore flag.
    DWORD DatabaseCleanupInterval;  // Database Cleanup Interval in mins.
    DWORD DebugFlag;                // Bit map of server debug flags.
} DHCP_SERVER_CONFIG_INFO, *LPDHCP_SERVER_CONFIG_INFO;

typedef enum _DHCP_SCAN_FLAG {
    DhcpRegistryFix,
    DhcpDatabaseFix
} DHCP_SCAN_FLAG, *LPDHCP_SCAN_FLAG;

typedef struct _DHCP_SCAN_ITEM {
    DHCP_IP_ADDRESS IpAddress;
    DHCP_SCAN_FLAG ScanFlag;
} DHCP_SCAN_ITEM, *LPDHCP_SCAN_ITEM;

typedef struct _DHCP_SCAN_LIST {
    DWORD NumScanItems;
#if defined(MIDL_PASS)
    [size_is(NumScanItems)]
#endif // MIDL_PASS
        DHCP_SCAN_ITEM *ScanItems;     // array
} DHCP_SCAN_LIST, *LPDHCP_SCAN_LIST;

typedef struct _DHCP_CLASS_INFO {
    LPWSTR                         ClassName;
    LPWSTR                         ClassComment;
    DWORD                          ClassDataLength;
    BOOL                           IsVendor;
    DWORD                          Flags;
#if defined(MIDL_PASS)
    [size_is(ClassDataLength)]
#endif // MIDL_PASS
    LPBYTE                         ClassData;
} DHCP_CLASS_INFO, *LPDHCP_CLASS_INFO;

typedef struct _DHCP_CLASS_INFO_ARRAY {
    DWORD                          NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif //MIDL_PASS
    LPDHCP_CLASS_INFO              Classes;
} DHCP_CLASS_INFO_ARRAY, *LPDHCP_CLASS_INFO_ARRAY;

//
// API proto types
//

//
// Subnet APIs
//

#ifndef     DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpCreateSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnets(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_IP_ARRAY *EnumInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElement(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElements(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElement(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
    );

//
// Option APIs
//

DWORD DHCP_API_FUNCTION
DhcpCreateOption(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION * OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION * OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetOptionInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION *OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumOptions(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_ARRAY *Options,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveOption(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo,
    DHCP_CONST DHCP_OPTION_DATA * OptionValue
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionValues(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo,
    DHCP_CONST DHCP_OPTION_VALUE_ARRAY * OptionValues
    );

DWORD DHCP_API_FUNCTION
DhcpGetOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO *ScopeInfo,
    LPDHCP_OPTION_VALUE *OptionValue
    );

DWORD DHCP_API_FUNCTION
DhcpEnumOptionValues(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO *ScopeInfo,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo
    );

//
// Client APIs
//

DWORD DHCP_API_FUNCTION
DhcpCreateClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *SearchInfo,
    LPDHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClients(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpGetClientOptions(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    );

DWORD DHCP_API_FUNCTION
DhcpGetMibInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerSetConfig(
    DHCP_CONST WCHAR *ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerGetConfig(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    );


DWORD DHCP_API_FUNCTION
DhcpScanDatabase(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    );

VOID DHCP_API_FUNCTION
DhcpRpcFreeMemory(
    PVOID BufferPointer
    );

DWORD DHCP_API_FUNCTION
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    );

#endif   DHCPAPI_NO_PROTOTYPES
//
// new structures for NT4SP1
//

typedef struct _DHCP_IP_RESERVATION_V4 {
    DHCP_IP_ADDRESS  ReservedIpAddress;
    DHCP_CLIENT_UID *ReservedForClient;
    BYTE             bAllowedClientTypes;
} DHCP_IP_RESERVATION_V4, *LPDHCP_IP_RESERVATION_V4;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V4 {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION_V4 {
        [case(DhcpIpRanges)] DHCP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION_V4 *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION_V4 {
        DHCP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION_V4 *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA_V4, *LPDHCP_SUBNET_ELEMENT_DATA_V4;

#if !defined(MIDL_PASS)
typedef union _DHCP_SUBNET_ELEMENT_UNION_V4
    DHCP_SUBNET_ELEMENT_UNION_V4, *LPDHCP_SUBNET_ELEMENT_UNION_V4;
#endif

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_SUBNET_ELEMENT_DATA_V4 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4;


// DHCP_CLIENT_INFO:bClientType

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )
#define CLIENT_TYPE_RESERVATION_FLAG 0x4
#define CLIENT_TYPE_NONE            0x64
#define BOOT_FILE_STRING_DELIMITER  ','
#define BOOT_FILE_STRING_DELIMITER_W L','


typedef struct _DHCP_CLIENT_INFO_V4 {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    //
    // new fields for NT4SP1
    //

    BYTE   bClientType;          // CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP |
                                 // CLIENT_TYPE_NONE
} DHCP_CLIENT_INFO_V4, *LPDHCP_CLIENT_INFO_V4;

typedef struct _DHCP_CLIENT_INFO_ARRAY_V4 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO_V4 *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY_V4, *LPDHCP_CLIENT_INFO_ARRAY_V4;


typedef struct _DHCP_SERVER_CONFIG_INFO_V4 {
    DWORD APIProtocolSupport;       // bit map of the protocols supported.
    LPWSTR DatabaseName;            // JET database name.
    LPWSTR DatabasePath;            // JET database path.
    LPWSTR BackupPath;              // Backup path.
    DWORD BackupInterval;           // Backup interval in mins.
    DWORD DatabaseLoggingFlag;      // Boolean database logging flag.
    DWORD RestoreFlag;              // Boolean database restore flag.
    DWORD DatabaseCleanupInterval;  // Database Cleanup Interval in mins.
    DWORD DebugFlag;                // Bit map of server debug flags.

    // new fields for NT4 SP1

    DWORD  dwPingRetries;           // valid range: 0-5 inclusive
    DWORD  cbBootTableString;
#if defined( MIDL_PASS )
    [ size_is( cbBootTableString ) ]
#endif
    WCHAR  *wszBootTableString;
    BOOL   fAuditLog;               // TRUE to enable audit log

} DHCP_SERVER_CONFIG_INFO_V4, *LPDHCP_SERVER_CONFIG_INFO_V4;


//
// superscope info structure  (added by t-cheny)
//

typedef struct _DHCP_SUPER_SCOPE_TABLE_ENTRY {
    DHCP_IP_ADDRESS SubnetAddress; // subnet address
    DWORD  SuperScopeNumber;       // super scope group number
    DWORD  NextInSuperScope;       // index of the next subnet in the superscope
    LPWSTR SuperScopeName;         // super scope name
                                   // NULL indicates no superscope membership.
} DHCP_SUPER_SCOPE_TABLE_ENTRY, *LPDHCP_SUPER_SCOPE_TABLE_ENTRY;


typedef struct _DHCP_SUPER_SCOPE_TABLE
{
    DWORD cEntries;
#if defined( MIDL_PASS )
    [ size_is( cEntries ) ]
#endif;
    DHCP_SUPER_SCOPE_TABLE_ENTRY *pEntries;
} DHCP_SUPER_SCOPE_TABLE, *LPDHCP_SUPER_SCOPE_TABLE;

//
// NT4SP1 RPC interface
//

#ifndef     DHCPAPI_NO_PROTOTYPES

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );


DWORD DHCP_API_FUNCTION
DhcpCreateClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpSetClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpGetClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClientsV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );


DWORD DHCP_API_FUNCTION
DhcpServerSetConfigV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerGetConfigV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    );


DWORD
DhcpSetSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST LPWSTR SuperScopeName,
    DHCP_CONST BOOL ChangeExisting
    );

DWORD
DhcpDeleteSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST LPWSTR SuperScopeName
    );

DWORD
DhcpGetSuperScopeInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
    );

#endif      DHCPAPI_NO_PROTOTYPES

typedef struct _DHCP_CLIENT_INFO_V5 {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    //
    // new fields for NT4SP1
    //

    BYTE   bClientType;          // CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP |
                                 // CLIENT_TYPE_NONE
    // new field for NT5.0
    BYTE   AddressState;         // OFFERED, DOOMED ...etc as given below
} DHCP_CLIENT_INFO_V5, *LPDHCP_CLIENT_INFO_V5;

// the following are four valid states for the record.  Note that only the last two
// bits must be used to find out the state... the higher bits are used as bit flags to
// indicate DNS stuff.
#define V5_ADDRESS_STATE_OFFERED       0x0
#define V5_ADDRESS_STATE_ACTIVE        0x1
#define V5_ADDRESS_STATE_DECLINED      0x2
#define V5_ADDRESS_STATE_DOOM          0x3

// DELETED => DNS DeRegistration pending
// UNREGISTERED => DNS Registration pending
// BOTH_REC => Both [Name->Ip] AND [Ip->Name] DNS registration would be done by server.

#define V5_ADDRESS_BIT_DELETED         0x80
#define V5_ADDRESS_BIT_UNREGISTERED    0x40
#define V5_ADDRESS_BIT_BOTH_REC        0x20

// Here are the flags that could be set/unset to affect DNS behaviour (option 81)
// If FLAG_ENABLED is not set, then this client is ignored for DNS updates or cleanups
// If update DOWNLEVEL is set, then DOWNLEVEL clients would have both A & Ptr records updated.
// If Cleanup expired is set, then the client's records would be cleaned up on delete.
// If UPDATE_BOTH_ALWAYS is set, all clients are treated like down level clients with both records updated.
//

// Some common cases:
// If you want updates to occur as requested by client, clear UPDATE_ALWAYS
// If you want updates to be only Ip->Name, clear FLAG_UPDATE_BOTH_ALWAYS
// If you want down level clients to be handled, set UPDATE_DOWNLEVEL
// If you want de-registrations on lease expiry, set CLEANUP_EXPIRED
// If you want any DNS activity at all, set ENABLED


#define DNS_FLAG_ENABLED               0x01
#define DNS_FLAG_UPDATE_DOWNLEVEL      0x02
#define DNS_FLAG_CLEANUP_EXPIRED       0x04
#define DNS_FLAG_UPDATE_BOTH_ALWAYS    0x10

typedef struct _DHCP_CLIENT_INFO_ARRAY_V5 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO_V5 *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY_V5, *LPDHCP_CLIENT_INFO_ARRAY_V5;

#ifndef     DHCPAPI_NO_PROTOTYPES
// Newer NT50 Version of the function..
DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClientsV5(
    DHCP_CONST  WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

//================================================================================
//  here is the NT 5.0 Beta2 stuff -- ClassId and Vendor specific stuff
//================================================================================

DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfoV5(                              // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptionsV5(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOptionV5(                               // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValueV5(                             // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValuesV5(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValueV5(                             // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValuesV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


DWORD
DhcpCreateClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
DhcpModifyClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;

#endif      DHCPAPI_NO_PROTOTYPES

#define     DHCP_OPT_ENUM_IGNORE_VENDOR           0x01
#define     DHCP_OPT_ENUM_USE_CLASSNAME           0x02

typedef     struct _DHCP_ALL_OPTIONS {
    DWORD                          Flags;         // must be zero -- not used..
    LPDHCP_OPTION_ARRAY            NonVendorOptions;
    DWORD                          NumVendorOptions;

#if defined(MIDL_PASS)
    [size_is(NumVendorOptions)]
#endif
    struct                         /* anonymous */ {
        DHCP_OPTION                Option;
        LPWSTR                     VendorName;
        LPWSTR                     ClassName;     // currently unused.
    }                             *VendorOptions;
} DHCP_ALL_OPTIONS, *LPDHCP_ALL_OPTIONS;


typedef     struct _DHCP_ALL_OPTION_VALUES {
    DWORD                          Flags;         // must be zero -- not used
    DWORD                          NumElements;   // the # of elements in array of Options below..
#if     defined(MIDL_PASS)
    [size_is(NumElements)]
#endif  MIDL_PASS
    struct                         /* anonymous */ {
        LPWSTR                     ClassName;     // for each user class (NULL if none exists)
        LPWSTR                     VendorName;    // for each vendor class (NULL if none exists)
        BOOL                       IsVendor;      // is this set of options vendor specific?
        LPDHCP_OPTION_VALUE_ARRAY  OptionsArray;  // list of options for the above pair: (vendor,user)
    }                             *Options;       // for each vendor/user class pair, one element in this array..
} DHCP_ALL_OPTION_VALUES, *LPDHCP_ALL_OPTION_VALUES;

#ifndef     DHCPAPI_NO_PROTOTYPES
// NT 50 Beta2 extended options api

DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS     *OptionStruct   // fill the fields of this structure
) ;
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;
#endif      DHCPAPI_NO_PROTOTYPES

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;

typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;

#endif      _ST_SRVR_H_

//DOC DhcpDsInit must be called exactly once per process.. this initializes the
//DOC memory and other structures for this process.  This initializes some DS
//DOC object handles (memory), and hence is slow as this has to read from DS.
DWORD
DhcpDsInit(
    VOID
);

//DOC DhcpDsCleanup undoes the effect of any DhcpDsInit.  This function should be
//DOC called exactly once for each process, and only at termination.  Note that
//DOC it is safe to call this function even if DhcpDsInit does not succeed.
VOID
DhcpDsCleanup(
    VOID
);

#define     DHCP_FLAGS_DONT_ACCESS_DS             0x01
#define     DHCP_FLAGS_DONT_DO_RPC                0x02
#define     DHCP_FLAGS_OPTION_IS_VENDOR           0x03


//DOC DhcpSetThreadOptions currently allows only one option to be set.  This is the
//DOC flag DHCP_FLAGS_DONT_ACCESS_DS.  This affects only the current executing thread.
//DOC When this function is executed, all calls made further DONT access the registry,
//DOC excepting the DhcpEnumServers, DhcpAddServer and DhcpDeleteServer calls.
DWORD
DhcpSetThreadOptions(                             // set options for current thread
    IN      DWORD                  Flags,         // options, currently 0 or DHCP_FLAGS_DONT_ACCESS_DS
    IN      LPVOID                 Reserved       // must be NULL, reserved for future
);

//DOC DhcpGetThreadOptions retrieves the current thread options as set by DhcpSetThreadOptions.
//DOC If none were set, the return value is zero.
DWORD
DhcpGetThreadOptions(                             // get current thread options
    OUT     LPDWORD                pFlags,        // this DWORD is filled with current optiosn..
    IN OUT  LPVOID                 Reserved       // must be NULL, reserved for future
);

#ifndef DHCPAPI_NO_PROTOTYPES
//DOC DhcpEnumServers enumerates the list of servers found in the DS.  If the DS
//DOC is not accessible, it returns an error. The only currently used parameter
//DOC is the out parameter Servers.  This is a SLOW call.
DWORD
DhcpEnumServers(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,    // output servers list
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpAddServer tries to add a new server to the existing list of servers in
//DOC the DS. The function returns error if the Server already exists in the DS.
//DOC The function tries to upload the server configuration to the DS..
//DOC This is a SLOW call.  Currently, the DsLocation and DsLocType are not valid
//DOC fields in the NewServer and they'd be ignored. Version must be zero.
DWORD
DhcpAddServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpDeleteServer tries to delete the server from DS. It is an error if the
//DOC server does not already exist.  This also deletes any objects related to
//DOC this server in the DS (like subnet, reservations etc.).
DWORD
DhcpDeleteServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);
#endif // DHCPAPI_NO_PROTOTYPES

#define     DHCP_ATTRIB_BOOL_IS_ROGUE             0x01
#define     DHCP_ATTRIB_BOOL_IS_DYNBOOTP          0x02
#define     DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC      0x03
#define     DHCP_ATTRIB_BOOL_IS_BINDING_AWARE     0x04
#define     DHCP_ATTRIB_BOOL_IS_ADMIN             0x05
#define     DHCP_ATTRIB_ULONG_RESTORE_STATUS      0x06

#define     DHCP_ATTRIB_TYPE_BOOL                 0x01
#define     DHCP_ATTRIB_TYPE_ULONG                0x02

typedef     ULONG                  DHCP_ATTRIB_ID, *PDHCP_ATTRIB_ID, *LPDHCP_ATTRIB_ID;

typedef     struct                 _DHCP_ATTRIB {
    DHCP_ATTRIB_ID                 DhcpAttribId;  // one of the DHCP_ATTRIB_*
    ULONG                          DhcpAttribType;// type of attrib
#if defined(MIDL_PASS)
    [switch_is(DhcpAttribType), switch_type(ULONG)]
    union                          {
    [case(DHCP_ATTRIB_TYPE_BOOL)]  BOOL  DhcpAttribBool;
    [case(DHCP_ATTRIB_TYPE_ULONG)] ULONG DhcpAttribUlong;
    };
#else MIDL_PASS
    union                          {              // predefined values..
    BOOL                           DhcpAttribBool;
    ULONG                          DhcpAttribUlong;
    };
#endif MIDL_PASS
}   DHCP_ATTRIB, *PDHCP_ATTRIB, *LPDHCP_ATTRIB;

typedef     struct                 _DHCP_ATTRIB_ARRAY {
    ULONG                          NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif MIDL_PASS
    LPDHCP_ATTRIB                  DhcpAttribs;
}   DHCP_ATTRIB_ARRAY, *PDHCP_ATTRIB_ARRAY, *LPDHCP_ATTRIB_ARRAY;

DWORD                                             // Status code
DhcpServerQueryAttribute(                         // get a server status
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      DHCP_ATTRIB_ID         DhcpAttribId,  // the attrib being queried
    OUT     LPDHCP_ATTRIB         *pDhcpAttrib    // fill in this field
);

DWORD                                             // Status code
DhcpServerQueryAttributes(                        // query multiple attributes
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      ULONG                  dwAttribCount, // # of attribs being queried
    IN      DHCP_ATTRIB_ID         pDhcpAttribs[],// array of attribs
    OUT     LPDHCP_ATTRIB_ARRAY   *pDhcpAttribArr // Ptr is filled w/ array
);

DWORD                                             // Status code
DhcpServerRedoAuthorization(                      // retry the rogue server stuff
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved     // reserved for future
);

DWORD
DhcpAuditLogSetParams(                            // set some auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
);

DWORD
DhcpAuditLogGetParams(                                // get the auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
);

typedef struct _DHCP_BOOTP_IP_RANGE {
    DHCP_IP_ADDRESS StartAddress;
    DHCP_IP_ADDRESS EndAddress;
    ULONG BootpAllocated;
    ULONG MaxBootpAllowed;
} DHCP_BOOTP_IP_RANGE, *LPDHCP_BOOT_IP_RANGE;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V5 {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION_V5 {
        [case(DhcpIpRanges)] DHCP_BOOTP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION_V4 *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION_V5 {
        DHCP_BOOTP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION_V4 *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA_V5, *LPDHCP_SUBNET_ELEMENT_DATA_V5;

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_SUBNET_ELEMENT_DATA_V5 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5;

#ifndef DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );
#endif // DHCPAPI_NO_PROTOTYPES

#define     DHCPCTR_SHARED_MEM_NAME   L"DHCPCTRS_SHMEM"

#pragma     pack(4)
typedef struct _DHCP_PERF_STATS {                     // performance statistics
    //
    // DO NOT CHANGE THIS ORDER -- THIS AFFECTS THE PERF COUNTER DEFINITION
    // ORDER IN DHCPDATA.C (under PERF directory)
    //
    ULONG   dwNumPacketsReceived;
    ULONG   dwNumPacketsDuplicate;
    ULONG   dwNumPacketsExpired;
    ULONG   dwNumMilliSecondsProcessed;
    ULONG   dwNumPacketsInActiveQueue;
    ULONG   dwNumPacketsInPingQueue;

    ULONG   dwNumDiscoversReceived;
    ULONG   dwNumOffersSent;

    ULONG   dwNumRequestsReceived;
    ULONG   dwNumInformsReceived;
    ULONG   dwNumAcksSent;
    ULONG   dwNumNacksSent;

    ULONG   dwNumDeclinesReceived;
    ULONG   dwNumReleasesReceived;

    //
    // This is not a counter value.. but there just to aid calculation of packet
    // processing time/ # of packets processed.
    //
    ULONG   dwNumPacketsProcessed;
} DHCP_PERF_STATS, *LPDHCP_PERF_STATS;
#pragma     pack()


typedef VOID (WINAPI *DHCP_CLEAR_DS_ROUTINE) (VOID);

VOID
WINAPI
DhcpDsClearHostServerEntries(
    VOID
);

typedef VOID (WINAPI *DHCP_MARKUPG_ROUTINE) (VOID);
VOID
WINAPI
DhcpMarkUpgrade(
    VOID
);

#define DHCP_ENDPOINT_FLAG_CANT_MODIFY 0x01

typedef struct _DHCP_BIND_ELEMENT {
    ULONG Flags;
    BOOL fBoundToDHCPServer;
    DHCP_IP_ADDRESS AdapterPrimaryAddress;
    DHCP_IP_ADDRESS AdapterSubnetAddress;
    LPWSTR IfDescription;
    ULONG IfIdSize;
#if defined (MIDL_PASS)
    [size_is(IfIdSize)]
#endif // MIDL_PASS
    LPBYTE IfId;    
} DHCP_BIND_ELEMENT, *LPDHCP_BIND_ELEMENT;

typedef struct _DHCP_BIND_ELEMENT_ARRAY {
    DWORD NumElements;
#if defined (MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_BIND_ELEMENT Elements; //array
} DHCP_BIND_ELEMENT_ARRAY, *LPDHCP_BIND_ELEMENT_ARRAY;


#ifndef DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpGetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY *BindElementsInfo
);

DWORD DHCP_API_FUNCTION
DhcpSetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY BindElementInfo
);
#endif // DHCPAPI_NO_PROTOTYPES

DWORD
DhcpServerQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize, //in BYTES
    OUT LPWSTR Uname,
    IN ULONG DomainSize, // in BYTES
    OUT LPWSTR Domain
    );

DWORD
DhcpServerSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    );

DWORD
DhcpServerBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    );

DWORD
DhcpServerRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    );

#endif // _DHCPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\dhcpds.h ===
//================================================================================
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  Author: RameshV
//  Description: This is the structure of the server information passed to
//  user via dhcpds.dll.
//================================================================================

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

//BeginExport(typedef)
typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;
//EndExport(typedef)

#endif      _ST_SRVR_H_

//================================================================================
//  end of file
//================================================================================
//========================================================================
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef CONVERT_NAMES
#define DhcpCreateSubnet DhcpCreateSubnetDS
#define DhcpSetSubnetInfo DhcpSetSubnetInfoDS
#define DhcpGetSubnetInfo DhcpGetSubnetInfoDS
#define DhcpEnumSubnets DhcpEnumSubnetsDS
#define DhcpDeleteSubnet DhcpDeleteSubnetDS
#define DhcpCreateOption DhcpCreateOptionDS
#define DhcpSetOptionInfo DhcpSetOptionInfoDS
#define DhcpGetOptionInfo DhcpGetOptionInfoDS
#define DhcpRemoveOption DhcpRemoveOptionDS
#define DhcpSetOptionValue DhcpSetOptionValueDS
#define DhcpGetOptionValue DhcpGetOptionValueDS
#define DhcpEnumOptionValues DhcpEnumOptionValuesDS
#define DhcpRemoveOptionValue DhcpRemoveOptionValueDS
#define DhcpEnumOptions DhcpEnumOptionsDS
#define DhcpSetOptionValues DhcpSetOptionValuesDS
#define DhcpAddSubnetElement DhcpAddSubnetElementDS
#define DhcpEnumSubnetElements DhcpEnumSubnetElementsDS
#define DhcpRemoveSubnetElement DhcpRemoveSubnetElementDS
#define DhcpAddSubnetElementV4 DhcpAddSubnetElementV4DS
#define DhcpEnumSubnetElementsV4 DhcpEnumSubnetElementsV4DS
#define DhcpRemoveSubnetElementV4 DhcpRemoveSubnetElementV4DS
#define DhcpSetSuperScopeV4 DhcpSetSuperScopeV4DS
#define DhcpGetSuperScopeInfoV4 DhcpGetSuperScopeInfoV4DS
#define DhcpDeleteSuperScopeV4 DhcpDeleteSuperScopeV4DS

#define DhcpSetClientInfo DhcpSetClientInfoDS
#define DhcpGetClientInfo DhcpGetClientInfoDS
#define DhcpSetClientInfoV4 DhcpSetClientInfoV4DS
#define DhcpGetClientInfoV4 DhcpGetClientInfoV4DS

#define DhcpCreateOptionV5 DhcpCreateOptionV5DS
#define DhcpSetOptionInfoV5 DhcpSetOptionInfoV5DS
#define DhcpGetOptionInfoV5 DhcpGetOptionInfoV5DS
#define DhcpEnumOptionsV5 DhcpEnumOptionsV5DS
#define DhcpRemoveOptionV5 DhcpRemoveOptionV5DS
#define DhcpSetOptionValueV5 DhcpSetOptionValueV5DS
#define DhcpSetOptionValuesV5 DhcpSetOptionValuesV5DS
#define DhcpGetOptionValueV5 DhcpGetOptionValueV5DS
#define DhcpEnumOptionValuesV5 DhcpEnumOptionValuesV5DS
#define DhcpRemoveOptionValueV5 DhcpRemoveOptionValueV5DS
#define DhcpCreateClass DhcpCreateClassDS
#define DhcpModifyClass DhcpModifyClassDS
#define DhcpDeleteClass DhcpDeleteClassDS
#define DhcpGetClassInfo DhcpGetClassInfoDS
#define DhcpEnumClasses DhcpEnumClassesDS
#define DhcpGetAllOptions DhcpGetAllOptionsDS
#define DhcpGetAllOptionValues DhcpGetAllOptionValuesDS

#endif  CONVERT_NAMES


//DOC Create an option in DS. Checkout DhcpDsCreateOptionDef for more info...
DWORD
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC Modify existing option's fields in the DS. See DhcpDsModifyOptionDef for more
//DOC details
DWORD
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC not yet supported at this level... (this is supported in a
//DOC DhcpDs function, no wrapper yet)
DWORD
DhcpGetOptionInfoV5(                              // retrieve option info from off ds structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory
) ;


//DOC See DhcpDsEnumOptionDefs for more info on this function.. but essentially, all this
//DOC does is to read thru the options and create a list of options..
DWORD
DhcpEnumOptionsV5(                                // create list of all options in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Delete an option from off the DS. See DhcpDsDeleteOptionDef for
//DOC more details.
DWORD
DhcpRemoveOptionV5(                               // remove an option from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


//DOC Set the specified option value in the DS.  For more information,
//DOC see DhcpDsSetOptionValue.
DWORD
DhcpSetOptionValueV5(                             // set the option value in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


//DOC This function just calls the SetOptionValue function N times.. this is not
//DOC atomic (), but even worse, it is highly inefficient, as it creates the
//DOC required objects over and over again!!!!!
//DOC This has to be fixed..
DWORD
DhcpSetOptionValuesV5(                            // set a series of option values
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


//DOC This function retrives the value of an option from the DS.  For more info,
//DOC pl check DhcpDsGetOptionValue.
DWORD
DhcpGetOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue
) ;


//DOC Get the list of option values defined in DS. For more information,
//DOC check DhcpDsEnumOptionValues.
DWORD
DhcpEnumOptionValuesV5(                           // get list of options defined in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Remove the option value from off the DS.  See DhcpDsRemoveOptionValue
//DOC for further information.
DWORD
DhcpRemoveOptionValueV5(                          // remove option value from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC Create a class in the DS.  Please see DhcpDsCreateClass for more
//DOC details on this function.
DWORD
DhcpCreateClass(                                  // create a class in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Modify an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpModifyClass(                                  // modify existing class
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Delete an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpDeleteClass(                                  // delete a class from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


//DOC DhcpGetClassInfo completes the information provided for a class in struct
//DOC PartialClassInfo.  For more details pl see DhcpDsGetClassInfo.
DWORD
DhcpGetClassInfo(                                 // fetch complete info frm DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


//DOC This is implememented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOption(                                 // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfo(                                // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfo(                                // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptions(                                  // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOption(                                 // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValue(                               // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValues(                              // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValue(                               // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC This function sets the superscope of a subnet, thereby creating the superscope
//DOC if required.  Please see DhcpDsSetSScope for more details.
DWORD
DhcpSetSuperScopeV4(                              // set superscope in DS.
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


//DOC This function removes the superscope, and resets any subnet with this
//DOC superscope.. so that all those subnets end up with no superscopes..
//DOC Please see DhcpDsDelSScope for more details.
DWORD
DhcpDeleteSuperScopeV4(                           // delete subnet sscope from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


//DOC This function retrievs the supercsope info for each subnet that is
//DOC present for the given server.  Please see DhcpDsGetSScopeInfo for more
//DOC details on this..
DWORD
DhcpGetSuperScopeInfoV4(                          // get sscope tbl from DS
    IN      LPWSTR                 ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


//DOC This function creates a subnet in the DS with the specified params.
//DOC Please see DhcpDsServerAddSubnet for more details on this function.
DWORD
DhcpCreateSubnet(                                 // add subnet 2 DS for this srvr
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Modify existing subnet with new parameters... some restrictions apply.
//DOC Please see DhcpDsServerModifySubnet for further details.
DWORD
DhcpSetSubnetInfo(                                // modify existing subnet params
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpGetSubnetInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpEnumSubnets(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


//DOC This function deletes the subnet from the DS.  For further information, pl
//DOC see DhcpDsServerDelSubnet..
DWORD
DhcpDeleteSubnet(                                 // Del subnet from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function sets some particular information for RESERVATIONS only
//DOC all other stuff it just ignores and returns success..
DWORD
DhcpSetClientInfo(
    IN      LPWSTR                 ServerIpAddresess,
    IN      LPDHCP_CLIENT_INFO     ClientInfo
) ;


//DOC This function retrieves some particular client's information
//DOC for RESERVATIONS only.. For all other stuff it returns CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_SEARCH_INFO     SearchInfo,
    OUT      LPDHCP_CLIENT_INFO    *ClientInfo
) ;


//DOC This function sets the client informatoin for RESERVATIONS only in DS
//DOC For all toher clients it returns ERROR_SUCCESS w/o doing anything
DWORD
DhcpSetClientInfoV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_CLIENT_INFO_V4  ClientInfo
) ;


//DOC Thsi function sets the client information for RESERVATIONS only
//DOC For all others it returns ERROR_CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfoV4(
    IN     LPWSTR                  ServerIpAddress,
    IN     LPDHCP_SEARCH_INFO      SearchInfo,
    OUT    LPDHCP_CLIENT_INFO_V4  *ClientInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElement(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA  AddElementInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElementsV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElements(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElement(                          // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElementV4(                        // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


#ifndef CONVERT_NAMES
#undef DhcpCreateSubnet
#undef DhcpSetSubnetInfo
#undef DhcpGetSubnetInfo
#undef DhcpEnumSubnets
#undef DhcpDeleteSubnet
#undef DhcpCreateOption
#undef DhcpSetOptionInfo
#undef DhcpGetOptionInfo
#undef DhcpRemoveOption
#undef DhcpSetOptionValue
#undef DhcpGetOptionValue
#undef DhcpEnumOptionValues
#undef DhcpRemoveOptionValue
#undef DhcpEnumOptions
#undef DhcpSetOptionValues
#undef DhcpAddSubnetElementV4
#undef DhcpEnumSubnetElementsV4
#undef DhcpRemoveSubnetElementV4
#undef DhcpAddSubnetElement
#undef DhcpEnumSubnetElements
#undef DhcpRemoveSubnetElement
#undef DhcpSetSuperScopeV4
#undef DhcpGetSuperScopeInfoV4
#undef DhcpDeleteSuperScopeV4

#undef DhcpSetClientInfo
#undef DhcpGetClientInfo
#undef DhcpSetClientInfoV4
#undef DhcpGetClientInfoV4

#undef DhcpCreateOptionV5
#undef DhcpSetOptionInfoV5
#undef DhcpGetOptionInfoV5
#undef DhcpEnumOptionsV5
#undef DhcpRemoveOptionV5
#undef DhcpSetOptionValueV5
#undef DhcpSetOptionValuesV5
#undef DhcpGetOptionValueV5
#undef DhcpEnumOptionValuesV5
#undef DhcpRemoveOptionValueV5
#undef DhcpCreateClass
#undef DhcpModifyClass
#undef DhcpDeleteClass
#undef DhcpGetClassInfo
#undef DhcpEnumClasses
#undef DhcpGetAllOptions
#undef DhcpGetAllOptionValues
#endif CONVERT_NAMES


#define     DHCP_SERVER_ANOTHER_ENTERPRISE        0x01
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;


//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) ;


//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) ;


//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//DOC DhcpDsGetLastUpdateTime is defined in upndown.c --> see there for more details.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\gpcstruc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    gpcstruc.h

Abstract:

    This module contains type definitions for the interface between the traffic dll and
    kernel mode components.

Author:

    Jim Stewart ( jstew )    August 22, 1996

Revision History:

    Yoram Bernet (yoramb)       May 1, 1997

    Ofer Bar (oferbar)          Oct 1, 1997 - Revision 2 changes


--*/

#ifndef __GPCSTRUC_H
#define __GPCSTRUC_H


#define GPC_NOTIFY_CFINFO_CLOSED	1

//
// NtDeviceIoControlFile IoControlCode values for the GPC.
//
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)


#define IOCTL_GPC_REGISTER_CLIENT       CTRL_CODE( 20, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_DEREGISTER_CLIENT     CTRL_CODE( 21, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_CF_INFO           CTRL_CODE( 22, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_PATTERN           CTRL_CODE( 23, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_MODIFY_CF_INFO        CTRL_CODE( 24, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_CF_INFO        CTRL_CODE( 25, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_PATTERN        CTRL_CODE( 26, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ENUM_CFINFO           CTRL_CODE( 27, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_NOTIFY_REQUEST        CTRL_CODE( 28, METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define IOCTL_GPC_GET_ENTRIES           CTRL_CODE( 50, METHOD_BUFFERED,FILE_ANY_ACCESS)


/*
/////////////////////////////////////////////////////////////////
//
//   Ioctl buffer formats - user level clients send buffers to the
//   GPC instead of calling entry points. Parameters are returned 
//   in other buffers. Buffers are defined below:
//
/////////////////////////////////////////////////////////////////
*/


//
// Register client
//
typedef struct _GPC_REGISTER_CLIENT_REQ {

    ULONG               CfId;
    ULONG               Flags;
    ULONG               MaxPriorities;
    GPC_CLIENT_HANDLE   ClientContext;

} GPC_REGISTER_CLIENT_REQ, *PGPC_REGISTER_CLIENT_REQ;

typedef struct _GPC_REGISTER_CLIENT_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          ClientHandle;

} GPC_REGISTER_CLIENT_RES, *PGPC_REGISTER_CLIENT_RES;


//
// Deregister client
//
typedef struct _GPC_DEREGISTER_CLIENT_REQ {

    GPC_HANDLE          ClientHandle;

} GPC_DEREGISTER_CLIENT_REQ, *PGPC_DEREGISTER_CLIENT_REQ;

typedef struct _GPC_DEREGISTER_CLIENT_RES {

    GPC_STATUS          Status;

} GPC_DEREGISTER_CLIENT_RES, *PGPC_DEREGISTER_CLIENT_RES;


//
// Add CfInfo
//
typedef struct _GPC_ADD_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_CLIENT_HANDLE   ClientCfInfoContext;    // client specific context
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];  // Varies from CF to CF

} GPC_ADD_CF_INFO_REQ, *PGPC_ADD_CF_INFO_REQ;

typedef struct _GPC_ADD_CF_INFO_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          GpcCfInfoHandle;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    
} GPC_ADD_CF_INFO_RES, *PGPC_ADD_CF_INFO_RES;


//
// Add pattern
//
typedef struct _GPC_ADD_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    GPC_CLIENT_HANDLE   ClientPatternContext;
    ULONG               Priority;
    ULONG				ProtocolTemplate;
    ULONG               PatternSize;
    CHAR                PatternAndMask[1];

} GPC_ADD_PATTERN_REQ, *PGPC_ADD_PATTERN_REQ;

typedef struct _GPC_ADD_PATTERN_RES {

    GPC_STATUS              Status;
    GPC_HANDLE              GpcPatternHandle;
    CLASSIFICATION_HANDLE   ClassificationHandle;

} GPC_ADD_PATTERN_RES, *PGPC_ADD_PATTERN_RES;


//
// Modify CfInfo
//
typedef struct _GPC_MODIFY_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];

} GPC_MODIFY_CF_INFO_REQ, *PGPC_MODIFY_CF_INFO_REQ;

typedef struct _GPC_MODIFY_CF_INFO_RES {
    
    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_MODIFY_CF_INFO_RES, *PGPC_MODIFY_CF_INFO_RES;


//
// Remove CfInfo
//
typedef struct _GPC_REMOVE_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;

} GPC_REMOVE_CF_INFO_REQ, *PGPC_REMOVE_CF_INFO_REQ;

typedef struct _GPC_REMOVE_CF_INFO_RES {

    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_REMOVE_CF_INFO_RES, *PGPC_REMOVE_CF_INFO_RES;


//
// Remove pattern
//
typedef struct _GPC_REMOVE_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcPatternHandle;

} GPC_REMOVE_PATTERN_REQ, *PGPC_REMOVE_PATTERN_REQ;

typedef struct _GPC_REMOVE_PATTERN_RES {

    GPC_STATUS          Status;

} GPC_REMOVE_PATTERN_RES, *PGPC_REMOVE_PATTERN_RES;


//
// Enumerate CfInfo
//
typedef struct _GPC_ENUM_CFINFO_REQ {

    GPC_HANDLE          ClientHandle;
    HANDLE				EnumHandle;
    ULONG				CfInfoCount;     // # requested

} GPC_ENUM_CFINFO_REQ, *PGPC_ENUM_CFINFO_REQ;

typedef struct _GPC_ENUM_CFINFO_RES {

    GPC_STATUS          	Status;
    HANDLE					EnumHandle;
    ULONG					TotalCfInfo;     // total installed
    GPC_ENUM_CFINFO_BUFFER	EnumBuffer[1];

} GPC_ENUM_CFINFO_RES, *PGPC_ENUM_CFINFO_RES;


//
// Notify request
//
typedef struct _GPC_NOTIFY_REQUEST_REQ {

    HANDLE       	ClientHandle;

} GPC_NOTIFY_REQUEST_REQ, *PGPC_NOTIFY_REQUEST_REQ;

typedef struct _GPC_NOTIFY_REQUEST_RES {

    HANDLE			ClientCtx;
    ULONG			SubCode;			// notification type
    ULONG			Reason;				// reason
    ULONG_PTR	    NotificationCtx;	// i.e. flow context
    ULONG			Param1;				// optional param
    IO_STATUS_BLOCK	IoStatBlock;		// reserved for the IOCTL

} GPC_NOTIFY_REQUEST_RES, *PGPC_NOTIFY_REQUEST_RES;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\hnetbcon.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for hnetbcon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hnetbcon_h__
#define __hnetbcon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInternetConnectionDevice_FWD_DEFINED__
#define __IInternetConnectionDevice_FWD_DEFINED__
typedef interface IInternetConnectionDevice IInternetConnectionDevice;
#endif 	/* __IInternetConnectionDevice_FWD_DEFINED__ */


#ifndef __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__
#define __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__
typedef interface IInternetConnectionDeviceSharedConnection IInternetConnectionDeviceSharedConnection;
#endif 	/* __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__ */


#ifndef __IInternetConnectionDeviceClient_FWD_DEFINED__
#define __IInternetConnectionDeviceClient_FWD_DEFINED__
typedef interface IInternetConnectionDeviceClient IInternetConnectionDeviceClient;
#endif 	/* __IInternetConnectionDeviceClient_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_hnetbcon_0000 */
/* [local] */ 

//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

EXTERN_C const CLSID CLSID_InternetConnectionBeaconService;





extern RPC_IF_HANDLE __MIDL_itf_hnetbcon_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetbcon_0000_v0_0_s_ifspec;

#ifndef __IInternetConnectionDevice_INTERFACE_DEFINED__
#define __IInternetConnectionDevice_INTERFACE_DEFINED__

/* interface IInternetConnectionDevice */
/* [unique][helpstring][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagICS_OS_VER
    {	WINDOWS_OS	= 1,
	WINME_OS	= 2,
	WINNT_OS	= 3,
	OTHER_OS	= 4,
	UNK_OS	= 5
    } 	ICS_OS_VER;


EXTERN_C const IID IID_IInternetConnectionDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6137-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsICSDeviceAvailable( 
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceNameInfo( 
            /* [string][out] */ LPOLESTR *ppszMachineName,
            /* [string][out] */ LPOLESTR *ppszDomainName,
            /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceSystemTime( 
            /* [out] */ FILETIME *pTime,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceOSVersion( 
            /* [out] */ ICS_OS_VER *pOSVersion,
            /* [out] */ DWORD *pdwOSMajorVersion,
            /* [out] */ DWORD *pdwOSMinorVersion,
            /* [out] */ DWORD *pdwOSBuildNumber,
            /* [string][out] */ LPOLESTR *ppszOSName,
            /* [string][out] */ LPOLESTR *ppszPlatformName,
            /* [in] */ BOOL fBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsICSDeviceAvailable )( 
            IInternetConnectionDevice * This,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceNameInfo )( 
            IInternetConnectionDevice * This,
            /* [string][out] */ LPOLESTR *ppszMachineName,
            /* [string][out] */ LPOLESTR *ppszDomainName,
            /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceSystemTime )( 
            IInternetConnectionDevice * This,
            /* [out] */ FILETIME *pTime,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceOSVersion )( 
            IInternetConnectionDevice * This,
            /* [out] */ ICS_OS_VER *pOSVersion,
            /* [out] */ DWORD *pdwOSMajorVersion,
            /* [out] */ DWORD *pdwOSMinorVersion,
            /* [out] */ DWORD *pdwOSBuildNumber,
            /* [string][out] */ LPOLESTR *ppszOSName,
            /* [string][out] */ LPOLESTR *ppszPlatformName,
            /* [in] */ BOOL fBlock);
        
        END_INTERFACE
    } IInternetConnectionDeviceVtbl;

    interface IInternetConnectionDevice
    {
        CONST_VTBL struct IInternetConnectionDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDevice_IsICSDeviceAvailable(This,fBlock)	\
    (This)->lpVtbl -> IsICSDeviceAvailable(This,fBlock)

#define IInternetConnectionDevice_GetICSDeviceNameInfo(This,ppszMachineName,ppszDomainName,ppszSharedAdapterName,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceNameInfo(This,ppszMachineName,ppszDomainName,ppszSharedAdapterName,fBlock)

#define IInternetConnectionDevice_GetICSDeviceSystemTime(This,pTime,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceSystemTime(This,pTime,fBlock)

#define IInternetConnectionDevice_GetICSDeviceOSVersion(This,pOSVersion,pdwOSMajorVersion,pdwOSMinorVersion,pdwOSBuildNumber,ppszOSName,ppszPlatformName,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceOSVersion(This,pOSVersion,pdwOSMajorVersion,pdwOSMinorVersion,pdwOSBuildNumber,ppszOSName,ppszPlatformName,fBlock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_IsICSDeviceAvailable_Proxy( 
    IInternetConnectionDevice * This,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_IsICSDeviceAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceNameInfo_Proxy( 
    IInternetConnectionDevice * This,
    /* [string][out] */ LPOLESTR *ppszMachineName,
    /* [string][out] */ LPOLESTR *ppszDomainName,
    /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceNameInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceSystemTime_Proxy( 
    IInternetConnectionDevice * This,
    /* [out] */ FILETIME *pTime,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceSystemTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceOSVersion_Proxy( 
    IInternetConnectionDevice * This,
    /* [out] */ ICS_OS_VER *pOSVersion,
    /* [out] */ DWORD *pdwOSMajorVersion,
    /* [out] */ DWORD *pdwOSMinorVersion,
    /* [out] */ DWORD *pdwOSBuildNumber,
    /* [string][out] */ LPOLESTR *ppszOSName,
    /* [string][out] */ LPOLESTR *ppszPlatformName,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceOSVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDevice_INTERFACE_DEFINED__ */


#ifndef __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__
#define __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__

/* interface IInternetConnectionDeviceSharedConnection */
/* [unique][helpstring][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagICS_CONN_DIAL_STATE
    {	STARTING	= 1,
	CONNECTING	= 2,
	CONNECTED	= 3,
	DISCONNECTING	= 4,
	DISCONNECTED	= 5,
	STOPPED	= 6,
	PERMANENT	= 7,
	UNK_DIAL_STATE	= 8,
	CALLWAITING	= 9
    } 	ICS_CONN_DIAL_STATE;

typedef /* [v1_enum] */ 
enum tagICS_CONN_TYPE
    {	LAN	= 1,
	RAS	= 2,
	UNK_CONN_TYPE	= 3
    } 	ICS_CONN_TYPE;


EXTERN_C const IID IID_IInternetConnectionDeviceSharedConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6138-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDeviceSharedConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDialState( 
            /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInfo( 
            /* [out] */ ULONGLONG *pBytesSent,
            /* [out] */ ULONGLONG *pBytesRecv,
            /* [out] */ ULONGLONG *pPktsSent,
            /* [out] */ ULONGLONG *pPktsRecv,
            /* [out] */ ULONGLONG *pUptime,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionSpeed( 
            /* [out] */ DWORD *pdwBps,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionType( 
            /* [out] */ ICS_CONN_TYPE *pConnectionType,
            /* [in] */ BOOL fBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceSharedConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDialState )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionInfo )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ULONGLONG *pBytesSent,
            /* [out] */ ULONGLONG *pBytesRecv,
            /* [out] */ ULONGLONG *pPktsSent,
            /* [out] */ ULONGLONG *pPktsRecv,
            /* [out] */ ULONGLONG *pUptime,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionSpeed )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ DWORD *pdwBps,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionType )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ICS_CONN_TYPE *pConnectionType,
            /* [in] */ BOOL fBlock);
        
        END_INTERFACE
    } IInternetConnectionDeviceSharedConnectionVtbl;

    interface IInternetConnectionDeviceSharedConnection
    {
        CONST_VTBL struct IInternetConnectionDeviceSharedConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDeviceSharedConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDeviceSharedConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDeviceSharedConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDeviceSharedConnection_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#define IInternetConnectionDeviceSharedConnection_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IInternetConnectionDeviceSharedConnection_GetDialState(This,pDialState,fBlock)	\
    (This)->lpVtbl -> GetDialState(This,pDialState,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionInfo(This,pBytesSent,pBytesRecv,pPktsSent,pPktsRecv,pUptime,fBlock)	\
    (This)->lpVtbl -> GetConnectionInfo(This,pBytesSent,pBytesRecv,pPktsSent,pPktsRecv,pUptime,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionSpeed(This,pdwBps,fBlock)	\
    (This)->lpVtbl -> GetConnectionSpeed(This,pdwBps,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionType(This,pConnectionType,fBlock)	\
    (This)->lpVtbl -> GetConnectionType(This,pConnectionType,fBlock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_Connect_Proxy( 
    IInternetConnectionDeviceSharedConnection * This);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_Disconnect_Proxy( 
    IInternetConnectionDeviceSharedConnection * This);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetDialState_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetDialState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionInfo_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ULONGLONG *pBytesSent,
    /* [out] */ ULONGLONG *pBytesRecv,
    /* [out] */ ULONGLONG *pPktsSent,
    /* [out] */ ULONGLONG *pPktsRecv,
    /* [out] */ ULONGLONG *pUptime,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionSpeed_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ DWORD *pdwBps,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionType_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ICS_CONN_TYPE *pConnectionType,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__ */


#ifndef __IInternetConnectionDeviceClient_INTERFACE_DEFINED__
#define __IInternetConnectionDeviceClient_INTERFACE_DEFINED__

/* interface IInternetConnectionDeviceClient */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInternetConnectionDeviceClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6139-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDeviceClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapterGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDeviceClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDeviceClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDeviceClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapterGuid )( 
            IInternetConnectionDeviceClient * This,
            /* [out] */ GUID **ppGuid);
        
        END_INTERFACE
    } IInternetConnectionDeviceClientVtbl;

    interface IInternetConnectionDeviceClient
    {
        CONST_VTBL struct IInternetConnectionDeviceClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDeviceClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDeviceClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDeviceClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDeviceClient_GetAdapterGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetAdapterGuid(This,ppGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceClient_GetAdapterGuid_Proxy( 
    IInternetConnectionDeviceClient * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IInternetConnectionDeviceClient_GetAdapterGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDeviceClient_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ftpd.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpd.h

    This file contains constants & type definitions shared between the
    FTPD Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _FTPD_H_
#define _FTPD_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


//
//  Service name.
//

#define FTPD_SERVICE_NAME_A              "FTPSVC"
#define FTPD_SERVICE_NAME_W             L"FTPSVC"


//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define FTPD_ANNOTATION_FILE_A           "~FTPSVC~.CKM"
#define FTPD_ANNOTATION_FILE_W          L"~FTPSVC~.CKM"


//
//  Name of the log file, used for logging file accesses.
//

#define FTPD_LOG_FILE_A                  "FTPSVC.LOG"
#define FTPD_LOG_FILE_W                 L"FTPSVC.LOG"


//
//  Configuration parameters registry key.
//

#define FTPD_PARAMETERS_KEY_A \
             "System\\CurrentControlSet\\Services\\FtpSvc\\Parameters"

#define FTPD_PARAMETERS_KEY_W \
            L"System\\CurrentControlSet\\Services\\FtpSvc\\Parameters"


//
//  Performance key.
//

#define FTPD_PERFORMANCE_KEY_A \
             "System\\CurrentControlSet\\Services\\FtpSvc\\Performance"

#define FTPD_PERFORMANCE_KEY_W \
            L"System\\CurrentControlSet\\Services\\FtpSvc\\Performance"


//
//  If this registry key exists under the FtpSvc\Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//

#define FTPD_ACCESS_KEY_A                "AccessCheck"
#define FTPD_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define FTPD_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define FTPD_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define FTPD_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define FTPD_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define FTPD_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define FTPD_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define FTPD_LOG_ANONYMOUS_A             "LogAnonymous"
#define FTPD_LOG_ANONYMOUS_W            L"LogAnonymous"

#define FTPD_LOG_NONANONYMOUS_A          "LogNonAnonymous"
#define FTPD_LOG_NONANONYMOUS_W         L"LogNonAnonymous"

#define FTPD_ANONYMOUS_USERNAME_A        "AnonymousUserName"
#define FTPD_ANONYMOUS_USERNAME_W       L"AnonymousUserName"

#define FTPD_HOME_DIRECTORY_A            "HomeDirectory"
#define FTPD_HOME_DIRECTORY_W           L"HomeDirectory"

#define FTPD_MAX_CONNECTIONS_A           "MaxConnections"
#define FTPD_MAX_CONNECTIONS_W          L"MaxConnections"

#define FTPD_READ_ACCESS_MASK_A          "ReadAccessMask"
#define FTPD_READ_ACCESS_MASK_W         L"ReadAccessMask"

#define FTPD_WRITE_ACCESS_MASK_A         "WriteAccessMask"
#define FTPD_WRITE_ACCESS_MASK_W        L"WriteAccessMask"

#define FTPD_CONNECTION_TIMEOUT_A        "ConnectionTimeout"
#define FTPD_CONNECTION_TIMEOUT_W       L"ConnectionTimeout"

#define FTPD_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define FTPD_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define FTPD_GREETING_MESSAGE_A          "GreetingMessage"
#define FTPD_GREETING_MESSAGE_W         L"GreetingMessage"

#define FTPD_EXIT_MESSAGE_A              "ExitMessage"
#define FTPD_EXIT_MESSAGE_W             L"ExitMessage"

#define FTPD_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define FTPD_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define FTPD_DEBUG_FLAGS_A               "DebugFlags"
#define FTPD_DEBUG_FLAGS_W              L"DebugFlags"

#define FTPD_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define FTPD_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define FTPD_LOWERCASE_FILES_A           "LowercaseFiles"
#define FTPD_LOWERCASE_FILES_W          L"LowercaseFiles"

#define FTPD_LOG_FILE_ACCESS_A           "LogFileAccess"
#define FTPD_LOG_FILE_ACCESS_W          L"LogFileAccess"

#define FTPD_LOG_FILE_DIRECTORY_A        "LogFileDirectory"
#define FTPD_LOG_FILE_DIRECTORY_W       L"LogFileDirectory"

#define FTPD_LISTEN_BACKLOG_A            "ListenBacklog"
#define FTPD_LISTEN_BACKLOG_W           L"ListenBacklog"

#define FTPD_ENABLE_LICENSING_A          "EnableLicensing"
#define FTPD_ENABLE_LICENSING_W         L"EnableLicensing"

#define FTPD_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define FTPD_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"

#define FTPD_ENABLE_PORT_ATTACK_A        "EnablePortAttack"
#define FTPD_ENABLE_PORT_ATTACK_W       L"EnablePortAttack"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define FTPD_ANONYMOUS_SECRET_A          "FTPD_ANONYMOUS_DATA"
#define FTPD_ANONYMOUS_SECRET_W         L"FTPD_ANONYMOUS_DATA"

#define FTPD_ROOT_SECRET_A               "FTPD_ROOT_DATA"
#define FTPD_ROOT_SECRET_W              L"FTPD_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define FTPD_SERVICE_NAME               FTPD_SERVICE_NAME_W
#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_W
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_W
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_W
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_W
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_W
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_W
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_W
#define FTPD_LOG_ANONYMOUS              FTPD_LOG_ANONYMOUS_W
#define FTPD_LOG_NONANONYMOUS           FTPD_LOG_NONANONYMOUS_W
#define FTPD_ANONYMOUS_USERNAME         FTPD_ANONYMOUS_USERNAME_W
#define FTPD_HOME_DIRECTORY             FTPD_HOME_DIRECTORY_W
#define FTPD_MAX_CONNECTIONS            FTPD_MAX_CONNECTIONS_W
#define FTPD_READ_ACCESS_MASK           FTPD_READ_ACCESS_MASK_W
#define FTPD_WRITE_ACCESS_MASK          FTPD_WRITE_ACCESS_MASK_W
#define FTPD_CONNECTION_TIMEOUT         FTPD_CONNECTION_TIMEOUT_W
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_W
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_W
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_W
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_W
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_W
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_W
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_W
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_W
#define FTPD_LOG_FILE_ACCESS            FTPD_LOG_FILE_ACCESS_W
#define FTPD_LOG_FILE                   FTPD_LOG_FILE_W
#define FTPD_LOG_FILE_DIRECTORY         FTPD_LOG_FILE_DIRECTORY_W
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_W
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_W
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_W
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_W

#else   // !UNICODE

#define FTPD_SERVICE_NAME               FTPD_SERVICE_NAME_A
#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_A
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_A
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_A
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_A
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_A
#define FTPD_LOG_ANONYMOUS              FTPD_LOG_ANONYMOUS_A
#define FTPD_LOG_NONANONYMOUS           FTPD_LOG_NONANONYMOUS_A
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_A
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_A
#define FTPD_ANONYMOUS_USERNAME         FTPD_ANONYMOUS_USERNAME_A
#define FTPD_HOME_DIRECTORY             FTPD_HOME_DIRECTORY_A
#define FTPD_MAX_CONNECTIONS            FTPD_MAX_CONNECTIONS_A
#define FTPD_READ_ACCESS_MASK           FTPD_READ_ACCESS_MASK_A
#define FTPD_WRITE_ACCESS_MASK          FTPD_WRITE_ACCESS_MASK_A
#define FTPD_CONNECTION_TIMEOUT         FTPD_CONNECTION_TIMEOUT_A
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_A
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_A
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_A
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_A
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_A
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_A
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_A
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_A
#define FTPD_LOG_FILE_ACCESS            FTPD_LOG_FILE_ACCESS_A
#define FTPD_LOG_FILE                   FTPD_LOG_FILE_A
#define FTPD_LOG_FILE_DIRECTORY         FTPD_LOG_FILE_DIRECTORY_A
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_A
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_A
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_A
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_A

#endif  // UNICODE


//
//  Values for LogFileAccess
//

#define FTPD_LOG_DISABLED   0
#define FTPD_LOG_SINGLE     1
#define FTPD_LOG_DAILY      2


//
// Structures for APIs
//

typedef struct _FTP_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} FTP_USER_INFO, * LPFTP_USER_INFO;

typedef struct _FTP_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} FTP_STATISTICS_0, * LPFTP_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    );

NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _FTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\iphlpstk.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    iphlpstk.h

Abstract:

Revision History:

    Amritansh Raghav

--*/

#ifndef _IPHLPSTK_
#define _IPHLPSTK_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <iprtrmib.h>
#include <ntddip.h>
#include <tcpinfo.h>

DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );

DWORD
GetIfTableFromStack(
    OUT PMIB_IFTABLE pIfTable,
    IN  DWORD        dwSize,
    IN  BOOL         bOrder,
    IN  BOOL         bForceUpdate
    );

DWORD
NhpGetInterfaceIndexFromStack(
    IN  PWCHAR      pwszIfName,
    OUT PDWORD      pdwIfIndex
    );

DWORD
GetIfEntryFromStack(
    OUT PMIB_IFROW  pIfEntry,
    IN  DWORD       dwAdapterIndex,
    IN  BOOL        bForceUpdate
    );

DWORD
SetIfEntryToStack(
    IN MIB_IFROW  *pIfEntry,
    IN BOOL       bForceUpdate
    );

DWORD
AllocateAndGetIpAddrTableFromStack(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    );

DWORD
GetIpAddrTableFromStack(
    OUT PMIB_IPADDRTABLE  pIpAddrTable,
    IN  DWORD             dwSize,
    IN  BOOL              bOrder
    );

DWORD
AllocateAndGetTcpTableFromStack(
    OUT MIB_TCPTABLE  **ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    );

DWORD
AllocateAndGetTcpExTableFromStack(
    OUT PVOID         *ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
GetTcpTableFromStack(
    OUT PMIB_TCPTABLE   pTcpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    );

DWORD
SetTcpEntryToStack(
    IN PMIB_TCPROW pTcpRow
    );

DWORD
AllocateAndGetUdpTableFromStack(
    OUT MIB_UDPTABLE  **ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    );
    
DWORD
AllocateAndGetUdpExTableFromStack(
    OUT PVOID         *ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
GetUdpTableFromStack(
    OUT PMIB_UDPTABLE   pUdpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    );

DWORD
AllocateAndGetIpForwardTableFromStack(
    OUT MIB_IPFORWARDTABLE  **ppForwardTable,
    IN  BOOL                bOrder,
    IN  HANDLE              hHeap,
    IN  DWORD               dwFlags
    );

DWORD
GetIpForwardTableFromStack(
    OUT PMIB_IPFORWARDTABLE pForwardTable,
    IN  DWORD               dwSize,
    IN  BOOL                bOrder
    );

DWORD
GetIpStatsFromStack(
    OUT PMIB_IPSTATS pIpStats
    );

DWORD
GetIpStatsFromStackEx(
    OUT PMIB_IPSTATS pIpStats,
    IN  DWORD        dwFamily
    );

DWORD
SetIpStatsToStack(
    IN PMIB_IPSTATS pIpStats
    );

DWORD
GetIcmpStatsFromStack(
    OUT PMIB_ICMP pIcmpStats
    );

DWORD
GetIcmpStatsFromStackEx(
    OUT PVOID         pIcmpStats,
    IN  DWORD         dwFamily
    );

DWORD
GetUdpStatsFromStack(
    OUT PMIB_UDPSTATS pUdpStats
    );

DWORD
GetUdpStatsFromStackEx(
    OUT PMIB_UDPSTATS pUdpStats,
    IN  DWORD         dwFamily
    );

DWORD
GetTcpStatsFromStack(
    OUT PMIB_TCPSTATS pTcpStats
    );

DWORD
GetTcpStatsFromStackEx(
    OUT PMIB_TCPSTATS pTcpStats,
    IN  DWORD         dwFamily
    );

DWORD
AllocateAndGetIpNetTableFromStack(
    OUT MIB_IPNETTABLE **ppNetTable,
    IN  BOOL           bOrder,
    IN  HANDLE         hHeap,
    IN  DWORD          dwFlags,
    IN  BOOL           bForceUpdate
    );

DWORD
GetIpNetTableFromStack(
    OUT PMIB_IPNETTABLE pNetTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder,
    IN  BOOL            bForceUpdate
    );

DWORD
SetIpNetEntryToStack(
    IN MIB_IPNETROW *pNetRow,
    IN BOOL         bForceUpdate
    );

DWORD
FlushIpNetTableFromStack(
    IN DWORD    dwIfIndex
    );

DWORD
SetProxyArpEntryToStack(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwAdapterIndex,
    IN  BOOL    bAddEntry,
    IN  BOOL    bForceUpdate
    );

DWORD
AllocateAndGetArpEntTableFromStack(
    OUT PDWORD    *ppdwArpEntTable,
    OUT PDWORD    pdwNumEntries,
    IN  HANDLE    hHeap,
    IN  DWORD     dwAllocFlags,
    IN  DWORD     dwReAllocFlags
    );

DWORD
SetIpForwardEntryToStack(
    IN PMIB_IPFORWARDROW pForwardRow
    );

DWORD
SetIpRouteEntryToStack(
    IN IPRouteEntry *pRoute
    );

DWORD
SetIpMultihopRouteEntryToStack(
    IN IPMultihopRouteEntry *pRoute
    );    

DWORD
GetBestInterfaceFromStack(
    DWORD   dwDestAddress,
    PDWORD  pdwBestIfIndex
    );

DWORD
GetBestRouteFromStack(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSrcAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );

DWORD
NhpAllocateAndGetInterfaceInfoFromStack(
    OUT IP_INTERFACE_NAME_INFO  **ppTable,
    OUT PDWORD                  pdwCount,
    IN  BOOL                    bOrder,
    IN  HANDLE                  hHeap,
    IN  DWORD                   dwFlags
    );

#ifdef __cplusplus
}
#endif

#endif // _IPHLPSTK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ipfltinf.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    private\inc\ipfltinf.h

Abstract:
    Stuff needed for filtering/firewall/demand dial support in user mode
    Kernel mode only stuff is in ntos\inc\ipfilter.h

Revision History:

--*/

#ifndef __IPFLTINF_H__
#define __IPFLTINF_H__

#if _MSC_VER > 1000
#pragma once
#endif

typedef void *INTERFACE_CONTEXT;    // Context in an inteface

//
// Enum for values that may be returned from filter routine.
//

typedef enum _FORWARD_ACTION
{
    FORWARD = 0,
    DROP = 1,
    ICMP_ON_DROP = 2
} FORWARD_ACTION;


typedef enum _ACTION_E
{
    ICMP_DEST_UNREACHABLE_ON_DROP = 0x1
} ACTION_E, *PACTION_E;

//
// Actions that are returned to IP from IPSEC for a packet.
//

typedef enum  _IPSEC_ACTION
{
    eFORWARD = 0,
    eDROP,
    eABSORB,
    eBACKFILL_NOT_SUPPORTED
} IPSEC_ACTION, *PIPSEC_ACTION;


//
// Structure passed to the IPSetInterfaceContext call.
//

typedef struct _IP_SET_IF_CONTEXT_INFO
{
    unsigned int        Index;      // Inteface index for i/f to be set.
    INTERFACE_CONTEXT   *Context;   // Context for inteface.
    IPAddr              NextHop;
} IP_SET_IF_CONTEXT_INFO, *PIP_SET_IF_CONTEXT_INFO;

#endif //__IPFLTINF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ipfltdrv.h ===
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ipfltdrv.h

Abstract:

    Contains the IOCTLs and related data structures needed to interact with the IP
    Filter Driver

Author:

    Amritansh Raghav

Revision History:

    amritanr         30th Nov 1995     Created

--*/

#ifndef __IPFLTDRV_H__
#define __IPFLTDRV_H__

#if _MSC_VER > 1000
#pragma once
#endif


#define IPHDRLEN 0xf                  // header length mask in iph_verlen
#define IPHDRSFT 2                    // scaling value for the length


//
// Typedefs used in this file
//

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED  1

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED
#include <pfhook.h>

//
// if you don't want these definitions, define the manifest in your sources file
//

#include <packon.h>

//
// Structure of an ICMP header.
//
#ifndef IP_H_INCLUDED
//* IP Header format.
struct IPHeader {
    uchar       iph_verlen;             // Version and length.
    uchar       iph_tos;                // Type of service.
    ushort      iph_length;             // Total length of datagram.
    ushort      iph_id;                 // Identification.
    ushort      iph_offset;             // Flags and fragment offset.
    uchar       iph_ttl;                // Time to live.
    uchar       iph_protocol;           // Protocol.
    ushort      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
}; /* IPHeader */
typedef struct IPHeader IPHeader;
#endif

#ifndef ICMPHEADER_INCLUDED
typedef struct ICMPHeader {
    UCHAR       ich_type;           // Type of ICMP packet.
    UCHAR       ich_code;           // Subcode of type.
    USHORT      ich_xsum;           // Checksum of packet.
    ULONG       ich_param;          // Type-specific parameter field.
} ICMPHeader , *PICMPHeader;
#endif
#include <packoff.h>

#include <rtinfo.h>
#include <ipinfoid.h>
#include <ipfltinf.h>

#define IP_FILTER_DRIVER_VERSION_1    1
#define IP_FILTER_DRIVER_VERSION_2    1
#define IP_FILTER_DRIVER_VERSION    IP_FILTER_DRIVER_VERSION_2

#define MAX_ADDRWORDS            1

//
// common flags
//

#define PF_GLOBAL_FLAGS_LOGON    0x80000000
#define PF_GLOBAL_FLAGS_ABSORB   0x40000000

//
// Log ID
//
typedef UINT_PTR PFLOGGER ;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Service name - this is what the service is called                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IPFLTRDRVR_SERVICE_NAME "IPFilterDriver"

//
// The following definitions come from <pfhook.h> now.
//

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Device Name - this string is the name of the device.  It is the name     //
// that should be passed to NtOpenFile when accessing the device.           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//#define DD_IPFLTRDRVR_DEVICE_NAME   L"\\Device\\IPFILTERDRIVER"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IOCTL code definitions and related structures                            //
// All the IOCTLs are synchronous and need administrator privilege          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//#define FSCTL_IPFLTRDRVR_BASE     FILE_DEVICE_NETWORK

//#define _IPFLTRDRVR_CTL_CODE(function, method, access) \
//                 CTL_CODE(FSCTL_IPFLTRDRVR_BASE, function, method, access)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to to create an interface in the filter driver. It    //
// takes in an index and an opaque context. It creates an interface,        //
// associates the index and context with it and returns a context for this  //
// created interface. All future IOCTLS require this context that is passed //
// out                                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_CREATE_INTERFACE \
            _IPFLTRDRVR_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _FILTER_DRIVER_CREATE_INTERFACE
{
    IN    DWORD   dwIfIndex;
    IN    DWORD   dwAdapterId;
    IN    PVOID   pvRtrMgrContext;
    OUT   PVOID   pvDriverContext;
}FILTER_DRIVER_CREATE_INTERFACE, *PFILTER_DRIVER_CREATE_INTERFACE;

#define INVALID_FILTER_DRIVER_CONTEXT  NULL

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to set filters for an interface.                      //
// The context used to identify the interface is the one that is passed out //
// by the CREATE_INTERFACE IOCTL                                            //
// There can be two TOC entries, one for IP_FILTER_DRIVER_IN_FILTER_INFO    //
// and the other for IP_FILTER_DRIVER_OUT_FILTER_INFO.                      //
// If a (in or out) TOC entry doesnt exist, no change is made to the        //
// (in or out) filters.                                                     //
// If a (in or out) TOC exists and its size is 0, the (in or out) filters   //
// are deleted and the default (in or out) action set to FORWARD.           //
// If a TOC exists and its size is not 0 but the number of filters in the   //
// FILTER_DESCRIPTOR is 0, the old filters are deleted and the default      //
// action set to the one specified in the descriptor.                       //
// The last case is when the Toc exists, its size is not 0, and the         //
// number of filters is also not 0. In this case, the old filters are       //
// deleted, the default action set to the one specified in the descriptor   //
// and the new filters are added.                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_SET_INTERFACE_FILTERS \
            _IPFLTRDRVR_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// NOTE: These two IDs are reused but since they are used in different      //
// namespaces, we can do that safely                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IP_FILTER_DRIVER_IN_FILTER_INFO         IP_GENERAL_INFO_BASE + 1
#define IP_FILTER_DRIVER_OUT_FILTER_INFO        IP_GENERAL_INFO_BASE + 2

typedef struct _FILTER_DRIVER_SET_FILTERS
{
    IN   PVOID                  pvDriverContext;
    IN   RTR_INFO_BLOCK_HEADER  ribhInfoBlock;
}FILTER_DRIVER_SET_FILTERS, *PFILTER_DRIVER_SET_FILTERS;

//
//Definitions for logging and for filter defs.
//


typedef enum _pfEtype
{
    PFE_FILTER = 1,
    PFE_SYNORFRAG,
    PFE_SPOOF,
    PFE_UNUSEDPORT,
    PFE_ALLOWCTL,
    PFE_FULLDENY,
    PFE_NOFRAG,
    PFE_STRONGHOST,
    PFE_FRAGCACHE
} PFETYPE, *PPFETYPE;

typedef struct _FILTER_INFO
{
    DWORD   dwSrcAddr;
    DWORD   dwSrcMask;
    DWORD   dwDstAddr;
    DWORD   dwDstMask;
    DWORD   dwProtocol;
    DWORD   fLateBound;
    WORD    wSrcPort;
    WORD    wDstPort;
}FILTER_INFO, *PFILTER_INFO;

typedef enum _AddrType
{
   IPV4,
   IPV6
}ADDRTYPE, *PADDRTYPE;

typedef struct _FILTER_INFO2
{
    ADDRTYPE addrType;
    DWORD   dwaSrcAddr[MAX_ADDRWORDS];
    DWORD   dwaSrcMask[MAX_ADDRWORDS];
    DWORD   dwaDstAddr[MAX_ADDRWORDS];
    DWORD   dwaDstMask[MAX_ADDRWORDS];
    DWORD   dwProtocol;
    DWORD   fLateBound;
    WORD    wSrcPort;
    WORD    wDstPort;
    WORD    wSrcPortHigh;
    WORD    wDstPortHigh;
}FILTER_INFO2, *PFILTER_INFO2;

typedef struct _FILTER_DESCRIPTOR
{
    DWORD           dwVersion;
    DWORD           dwNumFilters;
    FORWARD_ACTION  faDefaultAction;
    FILTER_INFO     fiFilter[1];
}FILTER_DESCRIPTOR, *PFILTER_DESCRIPTOR;

//
// new filter definition
//

typedef struct _pfFilterInfoEx
{
    PFETYPE  type;
    DWORD dwFlags;
    DWORD  dwFilterRule;
    PVOID   pvFilterHandle;
    FILTER_INFO2 info;
} FILTER_INFOEX, *PFILTER_INFOEX;

#define FLAGS_INFOEX_NOSYN   0x1        // not implemented.
#define FLAGS_INFOEX_LOGALL  0x2
#define FLAGS_INFOEX_ALLOWDUPS 0x4
#define FLAGS_INFOEX_ALLFLAGS 0x7
#define FLAGS_INFOEX_ALLOWANYREMOTEADDRESS 0x8
#define FLAGS_INFOEX_ALLOWANYLOCALADDRESS 0x10

typedef struct _FILTER_DESCRIPTOR2
{
    DWORD           dwVersion;         // must be 2
    DWORD           dwNumFilters;
    FILTER_INFOEX   fiFilter[1];
} FILTER_DESCRIPTOR2, *PFILTER_DESCRIPTOR2;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The constants that should be used to set up the FILTER_INFO_STRUCTURE    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)

#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
//#define FILTER_PROTO_TCP_ESTAB  FILTER_PROTO(0x86)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// For WAN interfaces, the address is unknown at the time the filters are   //
// set. Use these two constants two specify "Local Address". The address    //
// and mask are set with IOCTL_INTERFACE_BOUND                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SRC_ADDR_USE_LOCAL_FLAG     0x00000001
#define SRC_ADDR_USE_REMOTE_FLAG    0x00000002
#define DST_ADDR_USE_LOCAL_FLAG     0x00000004
#define DST_ADDR_USE_REMOTE_FLAG    0x00000008
#define SRC_MASK_LATE_FLAG          0x00000010
#define DST_MASK_LATE_FLAG          0x00000020

#define SetSrcAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_LOCAL_FLAG)

#define SetSrcAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_REMOTE_FLAG)

#define SetDstAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= DST_ADDR_USE_LOCAL_FLAG)

#define SetDstAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= DST_ADDR_USE_REMOTE_FLAG)

#define SetSrcMaskLateFlag(pFilter) ((pFilter)->fLateBound |= SRC_MASK_LATE_FLAG)
#define SetDstMaskLateFlag(pFilter) ((pFilter)->fLateBound |= DST_MASK_LATE_FLAG)

#define AreAllFieldsUnchanged(pFilter)      \
    ((pFilter)->fLateBound == 0x00000000)

#define DoesSrcAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & SRC_ADDR_USE_LOCAL_FLAG)

#define DoesSrcAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & SRC_ADDR_USE_REMOTE_FLAG)

#define DoesDstAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & DST_ADDR_USE_LOCAL_FLAG)

#define DoesDstAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & DST_ADDR_USE_REMOTE_FLAG)

#define IsSrcMaskLateBound(pFilter) ((pFilter)->fLateBound & SRC_MASK_LATE_FLAG)
#define IsDstMaskLateBound(pFilter) ((pFilter)->fLateBound & DST_MASK_LATE_FLAG)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to specify address and mask information for WAN       //
// interfaces at the time they bind. The driver goes through all the        //
// filters for the interface specified by pvDriverContext and if the        //
// fLateBind flag was sepecified for the filter, it changes the             //
// any FILTER_ADDRESS_UNKNOWN fields in the source with dwSrcAddr and       //
// those in the dest with dwDstAddr                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_SET_LATE_BOUND_FILTERS \
            _IPFLTRDRVR_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


typedef struct _FILTER_DRIVER_BINDING_INFO
{
    IN  PVOID   pvDriverContext;
    IN  DWORD   dwLocalAddr;
    IN  DWORD   dwRemoteAddr;
    IN  DWORD   dwMask;
}FILTER_DRIVER_BINDING_INFO, *PFILTER_DRIVER_BINDING_INFO;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL deletes an interface. Once this is called, one may not use    //
// the context of this interface for either any of the IOCTLs or the        //
// MatchFilter() function                                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_DELETE_INTERFACE \
            _IPFLTRDRVR_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DELETE_INTERFACEEX \
            _IPFLTRDRVR_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _FILTER_DRIVER_DELETE_INTERFACE
{
    IN   PVOID   pvDriverContext;
}FILTER_DRIVER_DELETE_INTERFACE, *PFILTER_DRIVER_DELETE_INTERFACE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is exposed so that a user mode test utility can test the      //
// correctness of implementation of the driver                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_TEST_PACKET \
            _IPFLTRDRVR_CTL_CODE(4, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_DRIVER_TEST_PACKET
{
    IN   PVOID            pvInInterfaceContext;
    IN   PVOID            pvOutInterfaceContext;
    OUT  FORWARD_ACTION   eaResult;
    IN   BYTE             bIpPacket[1];
}FILTER_DRIVER_TEST_PACKET, *PFILTER_DRIVER_TEST_PACKET;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL get the information associated with an interface. This        //
// includes the filters set for the interface and statistics related to the //
// filters themselves. If the size of buffer passed to it is less than      //
// sizeof(FILTER_DRIVER_GET_FILTERS), it returns STATUS_INSUFFICIENT_BUFFER.//
// If the size is >= sizeof(FILTER_DRIVER_GET_FILTERS) but less than what is//
// needed to fill in all the FILTER_STATS, then only the number of in and   //
// out filters is written out (so that the user can figure out how much     //
// memory is needed) and it return STATUS_SUCCESS. If the buffer passed is  //
// large enough all the information is written out                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_GET_FILTER_INFO \
            _IPFLTRDRVR_CTL_CODE(5, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_STATS_EX
{
    DWORD       dwNumPacketsFiltered;
    FILTER_INFOEX info;
}FILTER_STATS_EX, *PFILTER_STATS_EX;

typedef struct _FILTER_STATS
{
    DWORD       dwNumPacketsFiltered;
    FILTER_INFO info;
}FILTER_STATS, *PFILTER_STATS;

typedef struct _FILTER_IF
{
    FORWARD_ACTION   eaInAction;
    FORWARD_ACTION   eaOutAction;
    DWORD            dwNumInFilters;
    DWORD            dwNumOutFilters;
    FILTER_STATS     filters[1];
}FILTER_IF, *PFILTER_IF;

typedef struct _FILTER_DRIVER_GET_FILTERS
{
    IN   PVOID     pvDriverContext;
    OUT  DWORD     dwDefaultHitsIn;
    OUT  DWORD     dwDefaultHitsOut;
    OUT  FILTER_IF interfaces;
}FILTER_DRIVER_GET_FILTERS, *PFILTER_DRIVER_GET_FILTERS;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL gets the performance information associated with the filter   //
// driver. This information is only collected if the driver is built with   //
// the DRIVER_PERF flag                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_GET_FILTER_TIMES \
            _IPFLTRDRVR_CTL_CODE(6, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_DRIVER_GET_TIMES
{
    OUT DWORD           dwFragments;
    OUT DWORD           dwNumPackets;
    OUT DWORD           dwCache1;
    OUT DWORD           dwCache2;
    OUT DWORD           dwWalk1;
    OUT DWORD           dwWalk2;
    OUT DWORD           dwForw;
    OUT DWORD           dwWalkCache;
    OUT LARGE_INTEGER   liTotalTime;
}FILTER_DRIVER_GET_TIMES, *PFILTER_DRIVER_GET_TIMES;



typedef struct _MIB_IFFILTERTABLE
{
    DWORD       dwIfIndex;
    DWORD       dwDefaultHitsIn;
    DWORD       dwDefaultHitsOut;
    FILTER_IF   table;
}MIB_IFFILTERTABLE, *PMIB_IFFILTERTABLE;


#define SIZEOF_IFFILTERTABLE(X)     \
    (MAX_MIB_OFFSET + sizeof(MIB_IFFILTERTABLE) - sizeof(FILTER_STATS) + ((X) * sizeof(FILTER_STATS)) + ALIGN_SIZE)

typedef struct _FILTER_DRIVER_GET_TIMES MIB_IFFILTERTIMES, *PMIB_IFFILTERTIMES;


//
// New IOCTLs and definitions for creating interfaces and filters and
// retrieving information
//

#define IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS \
            _IPFLTRDRVR_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_PF_GET_INTERFACE_PARAMETERS \
            _IPFLTRDRVR_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)


typedef enum _PfBindingType
{
    PF_BIND_NONE = 0,
    PF_BIND_IPV4ADDRESS,
    PF_BIND_IPV6ADDRESS,
    PF_BIND_NAME,
    PF_BIND_INTERFACEINDEX
} PFBINDINGTYPE, *PPFBINDINGTYPE;

typedef struct _pfSetInterfaceParameters
{
    PFBINDINGTYPE pfbType;
    DWORD  dwBindingData;
    FORWARD_ACTION eaIn;
    FORWARD_ACTION eaOut;
    FILTER_DRIVER_CREATE_INTERFACE fdInterface;
    DWORD dwInterfaceFlags;
    PFLOGGER pfLogId;
} PFINTERFACEPARAMETERS, *PPFINTERFACEPARAMETERS;

//
// flags for dwInterfaceFlags
//

#define PFSET_FLAGS_UNIQUE          0x1

//
// Structure used to fetch the interface parameters
//

typedef struct _pfGetInterfaceParameters
{
    DWORD   dwReserved;
    PVOID   pvDriverContext;
    DWORD   dwFlags;
    DWORD   dwInDrops;
    DWORD   dwOutDrops;
    FORWARD_ACTION   eaInAction;
    FORWARD_ACTION   eaOutAction;
    DWORD   dwNumInFilters;
    DWORD   dwNumOutFilters;
    DWORD   dwSynOrFrag;
    DWORD   dwSpoof;
    DWORD   dwUnused;
    DWORD   dwTcpCtl;
    LARGE_INTEGER   liSYN;
    LARGE_INTEGER   liTotalLogged;
    DWORD   dwLostLogEntries;
    FILTER_STATS_EX  FilterInfo[1];
} PFGETINTERFACEPARAMETERS, *PPFGETINTERFACEPARAMETERS;

//
// flags for above
//

#define GET_FLAGS_RESET           0x1        // reset all fetched counters
#define GET_FLAGS_FILTERS         0x2        // fetch filters as well
#define GET_BY_INDEX              0x4        // pvDriverContext is an
                                             //  interface index not
                                             //  an interface handle

//
// These IOCTL definitions are used to create, modify and delete
// log interfaces
//

#define IOCTL_PF_CREATE_LOG \
            _IPFLTRDRVR_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_PF_DELETE_LOG \
            _IPFLTRDRVR_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// A logged frame.
//
typedef struct _pfLoggedFrame
{
    LARGE_INTEGER  Timestamp;
    PFETYPE     pfeTypeOfFrame;
    DWORD       dwTotalSizeUsed;
    DWORD       dwFilterRule;
    WORD        wSizeOfAdditionalData;
    WORD        wSizeOfIpHeader;
    DWORD       dwRtrMgrIndex;
    DWORD       dwIPIndex;
    IPHeader    IpHeader;
    BYTE        bData[1];
} PFLOGGEDFRAME, *PPFLOGGEDFRAME;

typedef struct _PfLog
{
    PFLOGGER pfLogId;
    HANDLE hEvent;
    DWORD dwFlags;        // see LOG_ flags below
} PFLOG, *PPFLOG;

typedef struct _PfDeleteLog
{
    PFLOGGER pfLogId;
} PFDELETELOG, *PPFDELETELOG;

//
// set a new log buffer. Note dwSize is an in/out
//
typedef struct _PfSetBuffer
{
    IN      PFLOGGER pfLogId;
    IN OUT  DWORD dwSize;
    OUT     DWORD dwLostEntries;
    OUT     DWORD dwLoggedEntries;
    OUT     PBYTE pbPreviousAddress;
    IN      DWORD dwSizeThreshold;
    IN      DWORD dwEntriesThreshold;
    IN      DWORD dwFlags;
    IN      PBYTE pbBaseOfLog;
} PFSETBUFFER, *PPFSETBUFFER;

typedef struct _InterfaceBinding
{
    PVOID   pvDriverContext;
    PFBINDINGTYPE pfType;
    DWORD   dwAdd;
    DWORD   dwEpoch;
} INTERFACEBINDING, *PINTERFACEBINDING;

typedef struct _InterfaceBinding2
{
    PVOID   pvDriverContext;
    PFBINDINGTYPE pfType;
    DWORD   dwAdd;
    DWORD   dwEpoch;
    DWORD   dwLinkAdd;
} INTERFACEBINDING2, *PINTERFACEBINDING2;


//
// flags for above
//

#define LOG_LOG_ABSORB    0x1        // log is used to absorb frames

typedef struct _FIlterDriverGetSyncCount
{
    LARGE_INTEGER liCount;
} FILTER_DRIVER_GET_SYN_COUNT, *PFILTER_DRIVER_GET_SYN_COUNT;

//
// IOCTL_PF_DELETE_BY_HANDLE input structure
//

typedef struct _PfDeleteByHandle
{
    PVOID   pvDriverContext;
    PVOID   pvHandles[1];
} PFDELETEBYHANDLE, *PPFDELETEBYHANDLE;

//
// IOCTL to do incremental filter setting and deleting. This IOCTL requires
// using the new filter info definitions. No mix and match matey.
//
#define IOCTL_SET_INTERFACE_FILTERS_EX \
            _IPFLTRDRVR_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DELETE_INTERFACE_FILTERS_EX \
            _IPFLTRDRVR_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_LOG_BUFFER \
            _IPFLTRDRVR_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_INTERFACE_BINDING \
            _IPFLTRDRVR_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLEAR_INTERFACE_BINDING \
            _IPFLTRDRVR_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_LATE_BOUND_FILTERSEX \
            _IPFLTRDRVR_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_GET_SYN_COUNTS \
            _IPFLTRDRVR_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_PF_DELETE_BY_HANDLE \
            _IPFLTRDRVR_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_PF_IP_ADDRESS_LOOKUP \
            _IPFLTRDRVR_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_INTERFACE_BINDING2 \
            _IPFLTRDRVR_CTL_CODE(21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif //__IPFLTDRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\isnkrnl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    isnkrnl.h

Abstract:

    This header file contains interface definitions for NT clients
    of the ISN IPX/SPX/Netbios stack.

Author:

    Adam Barr (adamba) 10 November 1993

Revision History:

--*/



#include <packon.h>

//
// Defines a local target. The NicId is assigned by IPX
// for each adapter or WAN line it is bound to. The MacAddress
// is generally the address of the remote machine or the
// router that is used to get to the remote machine.
//
//

//
// [SanjayAn] Changed LocalTarget to include a NicHandle
//

#ifdef	_PNP_POWER

typedef	struct _NIC_HANDLE {
	USHORT	NicId;

#ifdef  _PNP_LATER
	ULONG	Version;
	CSHORT	Signature;
#endif  _PNP_LATER

} NIC_HANDLE, *PNIC_HANDLE;


typedef struct _IPX_LOCAL_TARGET {
    union {
        USHORT      NicId;
    	NIC_HANDLE	NicHandle;
    };
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#else

typedef USHORT  NIC_HANDLE;
typedef PUSHORT PNIC_HANDLE;

typedef struct _IPX_LOCAL_TARGET {
    USHORT NicId;
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#endif	_PNP_POWER

//
// Definition of the options on a TDI datagram. These
// can be passed in as the Options field of a send
// datagram. It is indicated as the Options on a receive
// datagram, and will be copied into the Options field
// of a posted receive datagram if there is room.
//
// The complete structure does not need to be passed.
// Only the packet type can be passed, or nothing.
//

typedef struct _IPX_DATAGRAM_OPTIONS {
    UCHAR PacketType;
    UCHAR Reserved;
    IPX_LOCAL_TARGET LocalTarget;
} IPX_DATAGRAM_OPTIONS, *PIPX_DATAGRAM_OPTIONS;


//
// The extended address that some addresses want. If
// the proper ioctl is set (MIPX_SENDADDROPT) then
// this structure is passed as the remote address on
// send datagrams...
//

typedef struct _IPX_ADDRESS_EXTENDED {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
} IPX_ADDRESS_EXTENDED, *PIPX_ADDRESS_EXTENDED;

//
// ...and this structure is passed on receive indications.
// The values for Flags are defined right after it.
// By using the MIPX_SETRCVFLAGS ioctl you can also
// enable this format for receive addresses without
// changing what is passed on sends.
//

typedef struct _IPX_ADDRESS_EXTENDED_FLAGS {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
} IPX_ADDRESS_EXTENDED_FLAGS, *PIPX_ADDRESS_EXTENDED_FLAGS;

//
// Just appends Nic to the above structure.
//
typedef struct _IPX_ADDRESS_EXTENDED_FLAGS2 {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
    ULONG Nic;
} IPX_ADDRESS_EXTENDED_FLAGS2, *PIPX_ADDRESS_EXTENDED_FLAGS2;

#define IPX_EXTENDED_FLAG_BROADCAST   0x01   // the frame was sent as a broadcast
#define IPX_EXTENDED_FLAG_LOCAL       0x02   // the frame was sent from this machine



//
// The various states of the NICs (LAN/WAN)
//
#define NIC_CREATED         1
#define NIC_DELETED         2
#define NIC_CONNECTED       3
#define NIC_DISCONNECTED    4
#define NIC_LINE_DOWN       5
#define NIC_LINE_UP         6
#define NIC_CONFIGURED      7

//
// The mother of all hacks - tell the forwarder if it should shrink or
// expand all the NICIds...
//
#define NIC_OPCODE_DECREMENT_NICIDS 0x10
#define NIC_OPCODE_INCREMENT_NICIDS 0x20

//
// Move the isnipx.h definitions over here
//
// Frame types.  For now these mirror those in isnipx.h.
//
#define MISN_FRAME_TYPE_ETHERNET_II  0
#define MISN_FRAME_TYPE_802_3        1
#define MISN_FRAME_TYPE_802_2        2
#define MISN_FRAME_TYPE_SNAP         3
#define MISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define MISN_FRAME_TYPE_MAX          4    // of the four standard ones

#define ISN_FRAME_TYPE_AUTO         0xff

#include <packoff.h>

//***NIC  Info ***


//
// For now, we assume that there will not be more than 256 bindings.
// This is a big enough number for most cases that we will encounter now
// or the foreseeable future.  We allocate an array of ULONGS of the above
// dimension. This array stores in its first n elements pointers to the
// bindings created for the various LAN and WAN adapters.
//
#define IPX_MAXIMUM_BINDINGS               256


//
// This is the interface that the Router process in address space uses
// to open an address end point.  Only one point can currently be opened.
// The ea buffer should have the end point information in exactly the same
// format as is used for TdiTransportAddress endpoint.
//
#define ROUTER_INTERFACE  "RouterInterface"
#define ROUTER_INTERFACE_LENGTH  (sizeof("RouterInterface") - 1)

//
// Max. no. of ports that the Router can open
//
#define IPX_RT_MAX_ADDRESSES         16


// Structure for MIPX_CONFIG Ioctl parameters
typedef struct _ISN_ACTION_GET_DETAILS {
    USHORT NicId;          // passed by caller
    BOOLEAN BindingSet;    // returns TRUE if in set
    UCHAR Type;            // 1 = lan, 2 = up wan, 3 = down wan
    ULONG FrameType;       // returns 0 through 3
    ULONG NetworkNumber;   // returns virtual net if NicId is 0
    UCHAR Node[6];         // adapter's MAC address.
    WCHAR AdapterName[64]; // terminated with Unicode NULL
} ISN_ACTION_GET_DETAILS, *PISN_ACTION_GET_DETAILS;


//
// IPX_NIC_INFO.  One or more such structures can be retrieved by a user
//                app through the MIPX_GETNEWNICS ioctl.
//
typedef struct _IPX_NIC_INFO {

    ULONG   InterfaceIndex; // relevant only for demand dial WAN interfaces
    UCHAR   RemoteNodeAddress[6];        //remote nic address (only for WAN)
    ULONG   LinkSpeed;            //speed of link
    ULONG   PacketType;           //packet type 802.3 or whatever
    ULONG   MaxPacketSize;        //Max. pkt size allowed on the link
    ULONG   NdisMediumType;       //Medium type
    ULONG   NdisMediumSubtype;    //
    BOOLEAN Status;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
    ISN_ACTION_GET_DETAILS Details;
    } IPX_NIC_INFO, *PIPX_NIC_INFO;

//
// structure to be passed in the input buffer for the MIPX_GETNEWNICS IOCTL
//
typedef struct _IPX_NICS {
       ULONG NoOfNics;
       ULONG TotalNoOfNics;
       ULONG fAllNicsDesired;   //indicates that the client wants
                                  //ipx to start afresh
       UCHAR Data[1];              //memory holding an array of IPX_NIC_INFO
                                   //structures starts here
       } IPX_NICS, *PIPX_NICS;

//
// Enhanced OPTIONS structure for use with the MIPX_GETNEWNICS ioctl
//
typedef struct _IPX_DATAGRAM_OPTIONS2 {
    IPX_DATAGRAM_OPTIONS DgrmOptions;
    TDI_ADDRESS_IPX  RemoteAddress;
    ULONG            LengthOfExtraOpInfo;  //set it to the size of the extra
                                           //option info.
    char             Data[1];          //for future extensibility
} IPX_DATAGRAM_OPTIONS2, *PIPX_DATAGRAM_OPTIONS2;

//
// Invalid NicId passed down only once so IPX can map the ConnectionId
// to a NicId, which is used later.
//
#define INVALID_NICID   0xffffffff

//
// Structure to be passed with the MIPX_QUERY_WAN_INACTIVITY IOCTL
//
typedef struct _IPX_QUERY_WAN_INACTIVITY {
    ULONG   ConnectionId;
    USHORT  NicId;                  // if equals INVALID_NICID, AdapterIndex is filled in
                                    // adapter index; should change to NicHandle [ZZ]
    ULONG   WanInactivityCounter;   // filled in on return
} IPX_QUERY_WAN_INACTIVITY, *PIPX_QUERY_WAN_INACTIVITY;

//
// Structure to be passed with the MIPX_IPXWAN_CONFIG_DONE IOCTL
//
typedef struct _IPXWAN_CONFIG_DONE {
    USHORT  NicId;           // adapter index; should change to NicHandle [ZZ]
    ULONG   Network;
    UCHAR   LocalNode[6];
    UCHAR   RemoteNode[6];
} IPXWAN_CONFIG_DONE, *PIPXWAN_CONFIG_DONE;

//
// Definitions for TDI_ACTION calls supported by ISN.
// In general the structure defined is passed in the
// OutputBuffer (which becomes the MDL chain when
// the transport receives it) and is used for input
// and output as specified.
//

//
// This is the TransportId to use in the action header
// (it is the string "MISN").
//

#define ISN_ACTION_TRANSPORT_ID   (('N' << 24) | ('S' << 16) | ('I' << 8) | ('M'))


//
// Get local target is used to force a re-RIP and also
// obtain the local target information if desired. The
// IpxAddress is passed on input and the LocalTarget
// is returned on output. The structure defined here
// goes in the Data section of an NWLINK_ACTION
// structure with the Option set to MIPX_LOCALTARGET.
//

typedef struct _ISN_ACTION_GET_LOCAL_TARGET {
    TDI_ADDRESS_IPX IpxAddress;
    IPX_LOCAL_TARGET LocalTarget;
} ISN_ACTION_GET_LOCAL_TARGET, *PISN_ACTION_GET_LOCAL_TARGET;


//
// Get network information is used to return information
// about the path to a network. The information may not
// be accurate since it only reflects what IPX knows
// about the first hop to the remote. Network is an
// input and LinkSpeed (in bytes per second) and
// MaximumPacketSize (not including the IPX header)
// are returned. The structure defined here goes
// in the Data section of an NWLINK_ACTION structure
// with the Options set to MIPX_NETWORKINFO.
//

typedef struct _ISN_ACTION_GET_NETWORK_INFO {
    ULONG Network;
    ULONG LinkSpeed;
    ULONG MaximumPacketSize;
} ISN_ACTION_GET_NETWORK_INFO, *PISN_ACTION_GET_NETWORK_INFO;



//
// This is the structure that the streams IPX transport used
// for its action requests. Because of the way in which nwlink
// was implemented, when passing this structure in a TDI_ACTION
// it should be specified as the InputBuffer, not the output
// buffer.
//
// In the action header, the TransportId is "MIPX" and the
// ActionCode is 0. DatagramOption is TRUE for IPX ioctls
// and FALSE for SPX. The BufferLength includes the length
// of everything after it, which is sizeof(ULONG) for Option
// plus whatever Data is present. Option is one of the
// ioctl codes defined after the structure; in most cases
// Data is not needed.
//

typedef struct _NWLINK_ACTION {
    TDI_ACTION_HEADER Header;
    UCHAR OptionType;
    ULONG BufferLength;
    ULONG Option;
    CHAR Data[1];
} NWLINK_ACTION, *PNWLINK_ACTION;

//
// Defines the values for OptionType (note that for
// NWLINK this is a BOOLEAN DatagramOption, so we
// define these to match, adding the control channel
// one for ISN only).
//

#define NWLINK_OPTION_CONNECTION    0   // action is on a connection
#define NWLINK_OPTION_ADDRESS       1   // action is on an address
#define NWLINK_OPTION_CONTROL       2   // action is on the control channel,
                                        // may also be submitted on an
                                        // open connection or address object



//
// The following IOCTLs are taken from nwlink; the only
// ones added for ISN are the ones in the 200 range.
//


/** Ioctls for IPX - (X) = User callable **/

/**
    ioctls will values 100 - 150 were added for the NT port.
**/

#define I_MIPX          (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SETNODEADDR   (I_MIPX | 0)   /* Set the node address */
#define MIPX_SETNETNUM     (I_MIPX | 1)   /* Set the network number */
#define MIPX_SETPTYPE      (I_MIPX | 2)   /* (X) Set the packet type */
#define MIPX_SENTTYPE      (I_MIPX | 3)   /* (X) Set the xport type */
#define MIPX_SETPKTSIZE    (I_MIPX | 4)   /* Set the packet size */
#define MIPX_SETSAP        (I_MIPX | 5)   /* Set the sap/type field */
#define MIPX_SENDOPTS      (I_MIPX | 6)   /* (X) Send options on recv */
#define MIPX_NOSENDOPTS    (I_MIPX | 7)   /* (X) Don't send options on recv */
#define MIPX_SENDSRC       (I_MIPX | 8)   /* (X) Send source address up */
#define MIPX_NOSENDSRC     (I_MIPX | 9)   /* (X) Don't Send source address up */
#define MIPX_CONVBCAST     (I_MIPX | 10)  /* Convert TKR bcast to func addr */
#define MIPX_NOCONVBCAST   (I_MIPX | 11)  /* Don't cnvrt TKR bcast to funcaddr */
#define MIPX_SETCARDTYPE   (I_MIPX | 12)  /* Set 802.3 or ETH type */
#define MIPX_STARGROUP     (I_MIPX | 13)  /* This is stargroup */
#define MIPX_SWAPLENGTH    (I_MIPX | 14)  /* Set flag for swapping 802.3 length */
#define MIPX_SENDDEST      (I_MIPX | 15)  /* (X) Send dest. address up */
#define MIPX_NOSENDDEST    (I_MIPX | 16)  /* (X) Don't send dest. address up */
#define MIPX_SENDFDEST     (I_MIPX | 17)  /* (X) Send final dest. address up */
#define MIPX_NOSENDFDEST   (I_MIPX | 18)  /* (X) Don't send final dest. up */

/** Added for NT port **/

#define MIPX_SETVERSION    (I_MIPX | 100) /* Set card version */
#define MIPX_GETSTATUS     (I_MIPX | 101)
#define MIPX_SENDADDROPT   (I_MIPX | 102) /* (X) Send ptype w/addr on recv */
#define MIPX_NOSENDADDROPT (I_MIPX | 103) /* (X) Stop sending ptype on recv */
#define MIPX_CHECKSUM      (I_MIPX | 104) /* Enable/Disable checksum      */
#define MIPX_GETPKTSIZE    (I_MIPX | 105) /* Get max packet size          */
#define MIPX_SENDHEADER    (I_MIPX | 106) /* Send header with data        */
#define MIPX_NOSENDHEADER  (I_MIPX | 107) /* Don't send header with data  */
#define MIPX_SETCURCARD    (I_MIPX | 108) /* Set current card for IOCTLs  */
#define MIPX_SETMACTYPE    (I_MIPX | 109) /* Set the Cards MAC type       */
#define MIPX_DOSROUTE      (I_MIPX | 110) /* Do source routing on this card*/
#define MIPX_NOSROUTE      (I_MIPX | 111) /* Don't source routine the card*/
#define MIPX_SETRIPRETRY   (I_MIPX | 112) /* Set RIP retry count          */
#define MIPX_SETRIPTO      (I_MIPX | 113) /* Set RIP timeout              */
#define MIPX_SETTKRSAP     (I_MIPX | 114) /* Set the token ring SAP       */
#define MIPX_SETUSELLC     (I_MIPX | 115) /* Put LLC hdr on packets       */
#define MIPX_SETUSESNAP    (I_MIPX | 116) /* Put SNAP hdr on packets      */
#define MIPX_8023LEN       (I_MIPX | 117) /* 1=make even, 0=dont make even*/
#define MIPX_SENDPTYPE     (I_MIPX | 118) /* Send ptype in options on recv*/
#define MIPX_NOSENDPTYPE   (I_MIPX | 119) /* Don't send ptype in options  */
#define MIPX_FILTERPTYPE   (I_MIPX | 120) /* Filter on recv ptype         */
#define MIPX_NOFILTERPTYPE (I_MIPX | 121) /* Don't Filter on recv ptype   */
#define MIPX_SETSENDPTYPE  (I_MIPX | 122) /* Set pkt type to send with    */
#define MIPX_GETCARDINFO   (I_MIPX | 123) /* Get info on a card           */
#define MIPX_SENDCARDNUM   (I_MIPX | 124) /* Send card num up in options  */
#define MIPX_NOSENDCARDNUM (I_MIPX | 125) /* Dont send card num in options*/
#define MIPX_SETROUTER     (I_MIPX | 126) /* Set router enabled flag      */
#define MIPX_SETRIPAGE     (I_MIPX | 127) /* Set RIP age timeout          */
#define MIPX_SETRIPUSAGE   (I_MIPX | 128) /* Set RIP usage timeout        */
#define MIPX_SETSROUTEUSAGE (I_MIPX| 129) /* Set the SROUTE usage timeout */
#define MIPX_SETINTNET     (I_MIPX | 130) /* Set internal network number  */
#define MIPX_NOVIRTADDR    (I_MIPX | 131) /* Turn off virtual net num     */
#define MIPX_VIRTADDR      (I_MIPX | 132) /* Turn on  virtual net num     */
#define MIPX_GETNETINFO    (I_MIPX | 135) /* Get info on a network num    */
#define MIPX_SETDELAYTIME  (I_MIPX | 136) /* Set cards delay time         */
#define MIPX_SETROUTEADV   (I_MIPX | 137) /* Route advertise timeout      */
#define MIPX_SETSOCKETS    (I_MIPX | 138) /* Set default sockets          */
#define MIPX_SETLINKSPEED  (I_MIPX | 139) /* Set the link speed for a card*/
#define MIPX_SETWANFLAG    (I_MIPX | 140)
#define MIPX_GETCARDCHANGES (I_MIPX | 141) /* Wait for card changes	*/
#define MIPX_GETMAXADAPTERS (I_MIPX | 142)
#define MIPX_REUSEADDRESS   (I_MIPX | 143)
#define MIPX_RERIPNETNUM    (I_MIPX | 144) /* ReRip a network         */
#define MIPX_GETNETINFO_NR  (I_MIPX | 145) /* Get info on a net num - NO RIP */

#define MIPX_SETNIC         (I_MIPX | 146)
#define MIPX_NOSETNIC       (I_MIPX | 147)

/** For Source Routing Support **/

#define MIPX_SRCLEAR       (I_MIPX | 200) /* Clear the source routing table*/
#define MIPX_SRDEF         (I_MIPX | 201) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRBCAST       (I_MIPX | 202) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRMULTI       (I_MIPX | 203) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRREMOVE      (I_MIPX | 204) /* Remove a node from the table */
#define MIPX_SRLIST        (I_MIPX | 205) /* Get the source routing table */
#define MIPX_SRGETPARMS    (I_MIPX | 206) /* Get source routing parms     */

#define MIPX_SETSHOULDPUT  (I_MIPX | 210) /* Turn on should put call      */
#define MIPX_DELSHOULDPUT  (I_MIPX | 211) /* Turn off should put call     */
#define MIPX_GETSHOULDPUT  (I_MIPX | 212) /* Get ptr to mipx_shouldput    */

/** Added for ISN **/

#define MIPX_RCVBCAST      (I_MIPX | 300) /* (X) Enable broadcast reception */
#define MIPX_NORCVBCAST    (I_MIPX | 301) /* (X) Disable broadcast reception */
#define MIPX_ADAPTERNUM    (I_MIPX | 302) /* Get maximum adapter number */
#define MIPX_NOTIFYCARDINFO (I_MIPX | 303) /* Pend until card info changes */
#define MIPX_LOCALTARGET   (I_MIPX | 304) /* Get local target for address */
#define MIPX_NETWORKINFO   (I_MIPX | 305) /* Return info about remote net */
#define MIPX_ZEROSOCKET    (I_MIPX | 306) /* Use 0 as source socket on sends */
#define MIPX_SETRCVFLAGS   (I_MIPX | 307) /* Turn on flags in receive addr   */
#define MIPX_NORCVFLAGS    (I_MIPX | 308) /* Turn off flags in receive addr  */
#define MIPX_CONFIG        (I_MIPX | 309) /* used by IPXROUTE for config info */
#define MIPX_LINECHANGE    (I_MIPX | 310) /* queued until WAN line goes up/down */
#define MIPX_GETCARDINFO2  (I_MIPX | 311) /* Get info, return real send size for token-ring */
#define MIPX_ADAPTERNUM2   (I_MIPX | 312) /* Max. number including duplicates */


//
// Used by a user mode process to get nic info defined by the IPX_NIC_INFO
// structure.
//
// NOTE NOTE NOTE
//
// This is supposed to be used only by the FWRDR process and nobody else.
// If some other app. uses it, the FWRDR will be affected
//
//
#define MIPX_GETNEWNICINFO  (I_MIPX | 313) /*Get any new NIC info that might
                                            *be there*/

//
// IOCTL to be used if the interface is  ROUTER_INTERFACE
//
#define MIPX_SEND_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 314), METHOD_IN_DIRECT) // send dgram
#define MIPX_RCV_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 315), METHOD_OUT_DIRECT) // send dgram

#define MIPX_RT_CREATE      (I_MIPX | 316)
#define MIPX_IPXWAN_CONFIG_DONE   (I_MIPX | 317)
#define MIPX_QUERY_WAN_INACTIVITY (I_MIPX | 318)

/** Ioctls for SPX **/

#define I_MSPX          (('S' << 24) | ('P' << 16) | ('P' << 8))
#define MSPX_SETADDR       (I_MSPX | 0)   /* Set the network address      */
#define MSPX_SETPKTSIZE    (I_MSPX | 1)   /* Set the packet size per card */
#define MSPX_SETDATASTREAM (I_MSPX | 2)   /* Set datastream type          */

/** Added for NT port **/

#define MSPX_SETASLISTEN   (I_MSPX | 100) /* Set as a listen socket       */
#define MSPX_GETSTATUS     (I_MSPX | 101) /* Get running status           */
#define MSPX_GETQUEUEPTR   (I_MSPX | 102) /* Get ptr to the streams queue */
#define MSPX_SETDATAACK    (I_MSPX | 103) /* Set DATA ACK option          */
#define MSPX_NODATAACK     (I_MSPX | 104) /* Turn off DATA ACK option     */
#define MSPX_SETMAXPKTSOCK (I_MSPX | 105) /* Set the packet size per socket */
#define MSPX_SETWINDOWCARD (I_MSPX | 106) /* Set window size for card     */
#define MSPX_SETWINDOWSOCK (I_MSPX | 107) /* Set window size for 1 socket */
#define MSPX_SENDHEADER    (I_MSPX | 108) /* Send header with data        */
#define MSPX_NOSENDHEADER  (I_MSPX | 109) /* Don't send header with data  */
#define MSPX_GETPKTSIZE    (I_MSPX | 110) /* Get the packet size per card */
#define MSPX_SETCONNCNT    (I_MSPX | 111) /* Set the conn req count       */
#define MSPX_SETCONNTO     (I_MSPX | 112) /* Set the conn req timeout     */
#define MSPX_SETALIVECNT   (I_MSPX | 113) /* Set the keepalive count      */
#define MSPX_SETALIVETO    (I_MSPX | 114) /* Set the keepalive timeout    */
#define MSPX_SETALWAYSEOM  (I_MSPX | 115) /* Turn on always EOM flag      */
#define MSPX_NOALWAYSEOM   (I_MSPX | 116) /* Turn off always EOM flag     */
#define MSPX_GETSTATS      (I_MSPX | 119) /* Get connection stats         */
#define MSPX_NOACKWAIT     (I_MSPX | 120) /* Disable piggyback wait       */
#define MSPX_ACKWAIT       (I_MSPX | 121) /* Enable pback wait (default)  */

//
// Taken out of isn\inc\bind.h
//
typedef struct _IPXCP_CONFIGURATION {
    USHORT Version;
    USHORT Length;
    UCHAR Network[4];
    UCHAR LocalNode[6];
    UCHAR RemoteNode[6];
    ULONG ConnectionClient;  // 0 - Server, 1 - Client
    ULONG InterfaceIndex;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
} IPXCP_CONFIGURATION, *PIPXCP_CONFIGURATION;

#define IPXWAN_SOCKET   (USHORT)0x490



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
    ulong       ipsi_forwarding;
    ulong       ipsi_defaultttl;
    ulong       ipsi_inreceives;
    ulong       ipsi_inhdrerrors;
    ulong       ipsi_inaddrerrors;
    ulong       ipsi_forwdatagrams;
    ulong       ipsi_inunknownprotos;
    ulong       ipsi_indiscards;
    ulong       ipsi_indelivers;
    ulong       ipsi_outrequests;
    ulong       ipsi_routingdiscards;
    ulong       ipsi_outdiscards;
    ulong       ipsi_outnoroutes;
    ulong       ipsi_reasmtimeout;
    ulong       ipsi_reasmreqds;
    ulong       ipsi_reasmoks;
    ulong       ipsi_reasmfails;
    ulong       ipsi_fragoks;
    ulong       ipsi_fragfails;
    ulong       ipsi_fragcreates;
    ulong       ipsi_numif;
    ulong       ipsi_numaddr;
    ulong       ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_destunreachs;
    ulong       icmps_timeexcds;
    ulong       icmps_parmprobs;
    ulong       icmps_srcquenchs;
    ulong       icmps_redirects;
    ulong       icmps_echos;
    ulong       icmps_echoreps;
    ulong       icmps_timestamps;
    ulong       icmps_timestampreps;
    ulong       icmps_addrmasks;
    ulong       icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
    ICMPStats   icsi_instats;
    ICMPStats   icsi_outstats;
} ICMPSNMPInfo;

typedef struct ICMPv6Stats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_typecount[256];
} ICMPv6Stats;

typedef struct ICMPv6SNMPInfo {
    ICMPv6Stats   icsi_instats;
    ICMPv6Stats   icsi_outstats;
} ICMPv6SNMPInfo;

#define IP_FORWARDING       1
#define IP_NOT_FORWARDING   2

typedef struct IPAddrEntry {
    ulong       iae_addr;
    ulong       iae_index;
    ulong       iae_mask;
    ulong       iae_bcastaddr;
    ulong       iae_reasmsize;
    ushort      iae_context;
    ushort      iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
#ifdef NT
    ulong       ire_context;
#endif
} IPRouteEntry;

typedef struct IPRouteBlock {
    ulong       numofroutes;
    IPRouteEntry route[1];
} IPRouteBlock;

//
// Route with multiple nexthops and associated defns
//

typedef struct IPRouteNextHopEntry {
    ulong       ine_iretype;
    ulong       ine_nexthop;
    ulong       ine_ifindex;
#ifdef NT
    ulong       ine_context;
#endif
} IPRouteNextHopEntry;


typedef struct IPMultihopRouteEntry {
    ulong               imre_numnexthops;
    ulong               imre_flags;
    IPRouteEntry        imre_routeinfo;
    IPRouteNextHopEntry imre_morenexthops[1];
} IPMultihopRouteEntry;

#define IMRE_FLAG_DELETE_DEST   0x00000001

//
// Input context to pass when querying a route
//

typedef enum {
    IPNotifyNotification = 0,
    IPNotifySynchronization,
    IPNotifyMaximumVersion
} IPNotifyVersion;

typedef struct IPNotifyData {
    ulong       Version;   // See IPNotifyVersion above.
    ulong       Add;
    char        Info[1];
} IPNotifyData, *PIPNotifyData;

typedef struct IPNotifyOutput {
    ulong       ino_addr;
    ulong       ino_mask;
    ulong       ino_info[6];
} IPNotifyOutput, *PIPNotifyOutput;

typedef union IPRouteNotifyOutput {
    IPNotifyOutput irno_info;
    struct {
        ulong   irno_dest;
        ulong   irno_mask;
        ulong   irno_nexthop;
        ulong   irno_proto;
        ulong   irno_ifindex;
        ulong   irno_metric;
        ulong   irno_flags;
    };
} IPRouteNotifyOutput, *PIPRouteNotifyOutput;

#define IRNO_FLAG_ADD       0x00000001
#define IRNO_FLAG_DELETE    0x00000002

//
// Input context to pass when querying a route
//
typedef struct IPRouteLookupData {
    ulong       Version;   //version of this structure
    ulong       DestAdd;
    ulong       SrcAdd;
    char        Info[1];
} IPRouteLookupData, *PIPRouteLookupData;

typedef struct AddrXlatInfo {
    ulong       axi_count;
    ulong       axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14
#define IRE_PROTO_PERSIST_LOCAL 10010

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                 1
#define IP_MIB_RTCHANGE_NOTIFY_ID       2
#define ICMP_MIB_STATS_ID               1

#define AT_MIB_ADDRXLAT_INFO_ID         1
#define AT_MIB_ADDRXLAT_ENTRY_ID        0x101

#define IP_MIB_RTTABLE_ENTRY_ID         0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID       0x102
#define IP_MIB_RTTABLE_ENTRY_ID_EX      0x103

#define IP_INTFC_FLAG_P2P                 1
#define IP_INTFC_FLAG_P2MP                2
#define IP_INTFC_FLAG_UNIDIRECTIONAL      4


typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103
#define IP_MIB_SINGLE_RT_ENTRY_ID       0x104
#define IP_GET_BEST_SOURCE              0x105

#ifndef s6_addr

struct in6_addr {
    union {
        unsigned char Byte[16];
        unsigned short Word[8];
    } u;
};

#define in_addr6 in6_addr

/*
** Defines to match RFC 2553.
*/
#define _S6_un     u
#define _S6_u8     Byte
#define s6_addr    _S6_un._S6_u8

/*
** Defines for our implementation.
*/
#define s6_bytes   u.Byte
#define s6_words   u.Word

#endif

typedef struct IP6RouteEntry {
    ulong           ire_Length;
    struct in6_addr ire_Source;
    ulong           ire_ScopeId;
    ulong           ire_IfIndex;
} IP6RouteEntry;

#define IP6_MIB_STATS_ID       IP_MIB_STATS_ID
#define IP6_GET_BEST_ROUTE_ID  3
#define ICMP6_MIB_STATS_ID     4

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\icanon.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    icanon.h

Abstract:

    Function prototypes and definitions for the internal APIs which
    canonicalize, validate, and compare pathnames, LANMAN object
    names, and lists.

Author:

    Danny Glasser (dannygl) 15 June 1989

Notes:

    The references to the old set of canonicalization routines,
    which live in NETLIB, are being kept around for now.  When
    these routines are expunged the references in here should also
    be removed.

Revision History:

    06-May-1991 rfirth
        32-bit version
    11-Jun-1991 rfirth
        Added WI_Net prototypes
    22-Jan-1992 rfirth
        Changed names to be in line with NT naming convention (I_Net => Netp)
        Removed WI_Net prototypes
        Added mapping for old names. Names should be changed in all sources
    24-Feb-1992 rfirth
        Added LM2X_COMPATIBLE support
    10-May-1993 JohnRo
        RAID 6987: allow spaces in computer names (use comma for API lists).
        Also corrected copyright dates and re-ordered this history.
        Allow multiple includes of this file to be harmless.

--*/


#ifndef _ICANON_
#define _ICANON_


#ifdef __cplusplus
extern "C" {
#endif

//
// keep old names for now
//

#if 0
#define I_NetPathType           NetpPathType
#define I_NetPathCanonicalize   NetpPathCanonicalize
#define I_NetPathCompare        NetpPathCompare
#define I_NetNameValidate       NetpNameValidate
#define I_NetNameCanonicalize   NetpNameCanonicalize
#define I_NetNameCompare        NetpNameCompare
#define I_NetListCanonicalize   NetpListCanonicalize
#define I_NetListTraverse       NetpListTraverse
#else
#define NetpPathType            I_NetPathType
#define NetpPathCanonicalize    I_NetPathCanonicalize
#define NetpPathCompare         I_NetPathCompare
#define NetpNameValidate        I_NetNameValidate
#define NetpNameCanonicalize    I_NetNameCanonicalize
#define NetpNameCompare         I_NetNameCompare
#define NetpListCanonicalize    I_NetListCanonicalize
#define NetpListTraverse        I_NetListTraverse
#endif

//
// canonicalization routine prototypes
//

NET_API_STATUS
NetpIsRemote(
    IN  LPWSTR  ComputerName OPTIONAL,
    OUT LPDWORD LocalOrRemote,
    OUT LPWSTR  CanonicalizedName OPTIONAL,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpPathType(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpPathCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName,
    IN  LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPWSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NET_API_FUNCTION
NetpPathCompare(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName1,
    IN  LPWSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpNameCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NET_API_FUNCTION
NetpNameCompare(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name1,
    IN  LPWSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpListCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  List,
    IN  LPWSTR  Delimiters OPTIONAL,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    );

LPWSTR
NET_API_FUNCTION
NetpListTraverse(
    IN  LPWSTR  Reserved OPTIONAL,
    IN  LPWSTR* pList,
    IN  DWORD   Flags
    );

//
// ** Manifest constants for use with the above functions **
//

//
// Global flags (across all canonicalization functions)
//

#define LM2X_COMPATIBLE                 0x80000000L

#define GLOBAL_CANON_FLAGS              (LM2X_COMPATIBLE)

//
// These are the values which can be returned from NetpIsRemote in LocalOrRemote
//

#define ISREMOTE    (-1)
#define ISLOCAL     0

//
// Flags for NetpIsRemote
//
#define NIRFLAG_MAPLOCAL    0x00000001L
#define NIRFLAG_RESERVED    (~(GLOBAL_CANON_FLAGS|NIRFLAG_MAP_LOCAL))

//
// Flags for I_NetPathType
//
#define INPT_FLAGS_OLDPATHS             0x00000001
#define INPT_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INPT_FLAGS_OLDPATHS))

//
// Flags for I_NetPathCanonicalize
//
#define INPCA_FLAGS_OLDPATHS            0x00000001
#define INPCA_FLAGS_RESERVED            (~(GLOBAL_CANON_FLAGS|INPCA_FLAGS_OLDPATHS))

//
// Flags for I_NetPathCompare
//
#define INPC_FLAGS_PATHS_CANONICALIZED  0x00000001
#define INPC_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INPC_FLAGS_PATHS_CANONICALIZED))

//
// Flags for I_NetNameCanonicalize
//
#define INNCA_FLAGS_FULL_BUFLEN         0x00000001
#define INNCA_FLAGS_RESERVED            (~(GLOBAL_CANON_FLAGS|INNCA_FLAGS_FULL_BUFLEN))

//
// Flags for I_NetNameCompare
//
#define INNC_FLAGS_NAMES_CANONICALIZED  0x00000001
#define INNC_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INNC_FLAGS_NAMES_CANONICALIZED))

//
// Flags for I_NetNameValidate
//
#define INNV_FLAGS_RESERVED             (~GLOBAL_CANON_FLAGS)

//
// Name types for I_NetName* and I_NetListCanonicalize
//
#define NAMETYPE_USER           1
#define NAMETYPE_PASSWORD       2
#define NAMETYPE_GROUP          3
#define NAMETYPE_COMPUTER       4
#define NAMETYPE_EVENT          5
#define NAMETYPE_DOMAIN         6
#define NAMETYPE_SERVICE        7
#define NAMETYPE_NET            8
#define NAMETYPE_SHARE          9
#define NAMETYPE_MESSAGE        10
#define NAMETYPE_MESSAGEDEST    11
#define NAMETYPE_SHAREPASSWORD  12
#define NAMETYPE_WORKGROUP      13


//
// Special name types for I_NetListCanonicalize
//
#define NAMETYPE_COPYONLY       0
#define NAMETYPE_PATH           INLC_FLAGS_MASK_NAMETYPE

//
// Flags for I_NetListCanonicalize
//
#define INLC_FLAGS_MASK_NAMETYPE        0x000000FF
#define INLC_FLAGS_MASK_OUTLIST_TYPE    0x00000300
#define OUTLIST_TYPE_NULL_NULL          0x00000100
#define OUTLIST_TYPE_API                0x00000200
#define OUTLIST_TYPE_SEARCHPATH         0x00000300
#define INLC_FLAGS_CANONICALIZE         0x00000400
#define INLC_FLAGS_MULTIPLE_DELIMITERS  0x00000800
#define INLC_FLAGS_MASK_RESERVED        (~(GLOBAL_CANON_FLAGS| \
                                        INLC_FLAGS_MASK_NAMETYPE |   \
                                        INLC_FLAGS_MASK_OUTLIST_TYPE |  \
                                        INLC_FLAGS_CANONICALIZE |       \
                                        INLC_FLAGS_MULTIPLE_DELIMITERS))

//
// Delimiter strings for the three types of input lists accepted by
// I_NetListCanonicalize.
//
#define LIST_DELIMITER_STR_UI               TEXT(" \t;,")
#define LIST_DELIMITER_STR_API              TEXT(",")
#define LIST_DELIMITER_STR_NULL_NULL        TEXT("")

//
// The API list delimiter character
//
#define LIST_DELIMITER_CHAR_API             TEXT(',')

//
// The Search-path list delimiter character
//
#define LIST_DELIMITER_CHAR_SEARCHPATH      ';'

//
// The list quote character
//
#define LIST_QUOTE_CHAR                     '\"'


/*NOINC*/
/*
 * MAX_API_LIST_SIZE(maxelts, maxsize)
 * MAX_SEARCHPATH_LIST_SIZE(maxelts, maxsize)
 * MAX_NULL_NULL_LIST_SIZE(maxelts, maxsize)
 *
 * These macros specify the maximum size (in bytes) of API, search-path,
 * and null-null  lists, respectively, given the maximum number of elements
 * and the maximum size (in bytes, not including the terminating null) of
 * an element.  They are intended to be used in allocating arrays large
 * enough to hold the output of I_NetListCanonicalize.
 *
 * The size of an API or search-path list entry is three more than the size
 * of the element.  This includes two bytes for leading and trailing quote
 * characters and one byte for a trailing delimiter (or null, for the last
 * element).
 *
 * The size of a null-null list is one more than the size the elements
 * concantenated (allowing for a terminating null after each element).  The
 * extra byte is for the second null which follows the last element.
 */
#define MAX_API_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 3))

#define MAX_SEARCHPATH_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 3))

#define MAX_NULL_NULL_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 1) + 1)

/*INC*/

/***
 *      Constants for type return value.
 *      --> THESE ARE ONLY BUILDING BLOCKS, THEY ARE NOT RETURNED <---
 */

#define ITYPE_WILD              0x1
#define ITYPE_NOWILD            0

#define ITYPE_ABSOLUTE          0x2
#define ITYPE_RELATIVE          0

#define ITYPE_DPATH             0x4
#define ITYPE_NDPATH            0

#define ITYPE_DISK              0
#define ITYPE_LPT               0x10
#define ITYPE_COM               0x20
#define ITYPE_COMPNAME          0x30
#define ITYPE_CON               0x40
#define ITYPE_NUL               0x50

/*
 *      Meta-system names are used in the permission database.  A meta
 *      system name applies to a whole class of objects.  For example,
 *      \MAILSLOT applies to all mailslots.  These are NOT valid
 *      system object names themselves.
 */

#define ITYPE_SYS               0x00000800
#define ITYPE_META              0x00008000          /* See above */
#define ITYPE_SYS_MSLOT         (ITYPE_SYS|0)
#define ITYPE_SYS_SEM           (ITYPE_SYS|0x100)
#define ITYPE_SYS_SHMEM         (ITYPE_SYS|0x200)
#define ITYPE_SYS_PIPE          (ITYPE_SYS|0x300)
#define ITYPE_SYS_COMM          (ITYPE_SYS|0x400)
#define ITYPE_SYS_PRINT         (ITYPE_SYS|0x500)
#define ITYPE_SYS_QUEUE         (ITYPE_SYS|0x600)

#define ITYPE_UNC               0x1000  /* unc paths */
#define ITYPE_PATH              0x2000  /* 'local' non-unc paths */
#define ITYPE_DEVICE            0x4000

#define   ITYPE_PATH_SYS        (ITYPE_PATH_ABSND|ITYPE_SYS)
#define   ITYPE_UNC_SYS         (ITYPE_UNC|ITYPE_SYS)

/* End of building blocks. */


/***
 *      The real things...
 *      WHAT GETS RETURNED
 */

/*        ITYPE_UNC:  \\foo\bar and \\foo\bar\x\y */
#define   ITYPE_UNC_COMPNAME    (ITYPE_UNC|ITYPE_COMPNAME)
#define   ITYPE_UNC_WC          (ITYPE_UNC|ITYPE_COMPNAME|ITYPE_WILD)
#define   ITYPE_UNC_SYS_SEM     (ITYPE_UNC_SYS|ITYPE_SYS_SEM)
#define   ITYPE_UNC_SYS_SHMEM   (ITYPE_UNC_SYS|ITYPE_SYS_SHMEM)
#define   ITYPE_UNC_SYS_MSLOT   (ITYPE_UNC_SYS|ITYPE_SYS_MSLOT)
#define   ITYPE_UNC_SYS_PIPE    (ITYPE_UNC_SYS|ITYPE_SYS_PIPE)
#define   ITYPE_UNC_SYS_QUEUE   (ITYPE_UNC_SYS|ITYPE_SYS_QUEUE)

#define   ITYPE_PATH_ABSND      (ITYPE_PATH|ITYPE_ABSOLUTE|ITYPE_NDPATH)
#define   ITYPE_PATH_ABSD       (ITYPE_PATH|ITYPE_ABSOLUTE|ITYPE_DPATH)
#define   ITYPE_PATH_RELND      (ITYPE_PATH|ITYPE_RELATIVE|ITYPE_NDPATH)
#define   ITYPE_PATH_RELD       (ITYPE_PATH|ITYPE_RELATIVE|ITYPE_DPATH)
#define   ITYPE_PATH_ABSND_WC   (ITYPE_PATH_ABSND|ITYPE_WILD)
#define   ITYPE_PATH_ABSD_WC    (ITYPE_PATH_ABSD|ITYPE_WILD)
#define   ITYPE_PATH_RELND_WC   (ITYPE_PATH_RELND|ITYPE_WILD)
#define   ITYPE_PATH_RELD_WC    (ITYPE_PATH_RELD|ITYPE_WILD)

#define   ITYPE_PATH_SYS_SEM    (ITYPE_PATH_SYS|ITYPE_SYS_SEM)
#define   ITYPE_PATH_SYS_SHMEM  (ITYPE_PATH_SYS|ITYPE_SYS_SHMEM)
#define   ITYPE_PATH_SYS_MSLOT  (ITYPE_PATH_SYS|ITYPE_SYS_MSLOT)
#define   ITYPE_PATH_SYS_PIPE   (ITYPE_PATH_SYS|ITYPE_SYS_PIPE)
#define   ITYPE_PATH_SYS_COMM   (ITYPE_PATH_SYS|ITYPE_SYS_COMM)
#define   ITYPE_PATH_SYS_PRINT  (ITYPE_PATH_SYS|ITYPE_SYS_PRINT)
#define   ITYPE_PATH_SYS_QUEUE  (ITYPE_PATH_SYS|ITYPE_SYS_QUEUE)

#define   ITYPE_PATH_SYS_SEM_M  (ITYPE_PATH_SYS|ITYPE_SYS_SEM|ITYPE_META)
#define   ITYPE_PATH_SYS_SHMEM_M (ITYPE_PATH_SYS|ITYPE_SYS_SHMEM|ITYPE_META)
#define   ITYPE_PATH_SYS_MSLOT_M (ITYPE_PATH_SYS|ITYPE_SYS_MSLOT|ITYPE_META)
#define   ITYPE_PATH_SYS_PIPE_M (ITYPE_PATH_SYS|ITYPE_SYS_PIPE|ITYPE_META)
#define   ITYPE_PATH_SYS_COMM_M (ITYPE_PATH_SYS|ITYPE_SYS_COMM|ITYPE_META)
#define   ITYPE_PATH_SYS_PRINT_M (ITYPE_PATH_SYS|ITYPE_SYS_PRINT|ITYPE_META)
#define   ITYPE_PATH_SYS_QUEUE_M (ITYPE_PATH_SYS|ITYPE_SYS_QUEUE|ITYPE_META)

#define   ITYPE_DEVICE_DISK     (ITYPE_DEVICE|ITYPE_DISK)
#define   ITYPE_DEVICE_LPT      (ITYPE_DEVICE|ITYPE_LPT)
#define   ITYPE_DEVICE_COM      (ITYPE_DEVICE|ITYPE_COM)
#define   ITYPE_DEVICE_CON      (ITYPE_DEVICE|ITYPE_CON)
#define   ITYPE_DEVICE_NUL      (ITYPE_DEVICE|ITYPE_NUL)


#ifdef __cplusplus
}
#endif

#endif // ndef _ICANON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\hostannc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    hostannc.h

Abstract:

    This module defines the data structures related to host announcements.

Author:

    Larry Osterman (LarryO) 22-Oct-1990

Revision History:

    22-Oct-1991  LarryO

        Created

--*/

#ifndef _HOSTANNC_
#define _HOSTANNC_


typedef enum _MailslotType {
    MailslotTransaction = -2,
    OtherTransaction = -1,
    Illegal = 0,
    HostAnnouncement = 1,
    AnnouncementRequest = 2,
    InterrogateInfoRequest = 3,
    RelogonRequest = 4,
    Election = 8,
    GetBackupListReq = 9,
    GetBackupListResp = 10,
    BecomeBackupServer = 11,
    WkGroupAnnouncement = 12,
    MasterAnnouncement = 13,
    ResetBrowserState = 14,
    LocalMasterAnnouncement = 15,
    MaximumMailslotType
} MAILSLOTTYPE, *PMAILSLOTTYPE;

#define WORKSTATION_SIGNATURE       '\0'
#define SERVER_SIGNATURE            ' '
#define PRIMARY_DOMAIN_SIGNATURE    '\0'
#define PRIMARY_CONTROLLER_SIGNATURE '\x1B'
#define DOMAIN_CONTROLLER_SIGNATURE '\x1C'
#define MASTER_BROWSER_SIGNATURE    '\x1D'
#define BROWSER_ELECTION_SIGNATURE  '\x1E'
#define DOMAIN_ANNOUNCEMENT_NAME    "\x01\x02__MSBROWSE__\x02\x01"
//
//  The following values should be the minimum and maximum of the
//  mailslot transaction opcodes defined above.
//

#define MIN_TRANSACT_MS_OPCODE          MailslotTransaction
#define MAX_TRANSACT_MS_OPCODE          RelogonRequest

//
//  Common name for reserved, `internal' transactions
//

#define MAILSLOT_LANMAN_NAME SMB_MAILSLOT_PREFIX "\\LANMAN"
#define MAILSLOT_BROWSER_NAME SMB_MAILSLOT_PREFIX "\\BROWSE"
#define ANNOUNCEMENT_MAILSLOT_NAME     "\\\\*" ITRANS_MS_NAME


#include <packon.h>
//
// Each visible server on the net periodically emits a host announcement.
// This is a SMB TRANSACTION REQUEST on a reserved, "internal" name.
//

//
//  There are two versions of each of these structures defined.  The first,
//  is the actual "meat" of the structure, the second includes the announcement
//  type.
//

//
// Lan Manager announcement message.  This is used for opcodes:
//
//  HostAnnouncement to \MAILSLOT\LANMAN on the LANMAN domain name.
//

typedef struct _HOST_ANNOUNCE_PACKET_1 {
    UCHAR       CompatibilityPad;
    ULONG       Type;
    UCHAR       VersionMajor;   /* version of LM running on host */
    UCHAR       VersionMinor;   /*  "  "   "   "    "    "    "   */
    USHORT      Periodicity;   /* announcement cycle in secs   */
    CHAR        NameComment[LM20_CNLEN+1+LM20_MAXCOMMENTSZ+1];
} HOST_ANNOUNCE_PACKET_1, *PHOST_ANNOUNCE_PACKET_1;

typedef struct _HOST_ANNOUNCE_PACKET {
    UCHAR       AnnounceType;
    HOST_ANNOUNCE_PACKET_1 HostAnnouncement;
} HOST_ANNOUNCE_PACKET, *PHOST_ANNOUNCE_PACKET;

//
// General announcement message.  This is used for opcodes:
//
//  HostAnnouncement, WkGroupAnnouncement, and LocalMasterAnnouncement
//

typedef struct _BROWSE_ANNOUNCE_PACKET_1 {
    UCHAR       UpdateCount;    // Inc'ed when announce data changed.
    ULONG       Periodicity;    // announcement cycle in milliseconds

    UCHAR       ServerName[LM20_CNLEN+1];
    UCHAR       VersionMajor;
    UCHAR       VersionMinor;   /*  "  "   "   "    "    "    "   */
    ULONG       Type;           // Server type.
    CHAR        *CommentPointer;
    CHAR        Comment[LM20_MAXCOMMENTSZ+1];
} BROWSE_ANNOUNCE_PACKET_1, *PBROWSE_ANNOUNCE_PACKET_1;

typedef struct _BROWSE_ANNOUNCE_PACKET {
    UCHAR       BrowseType;
    BROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement;
} BROWSE_ANNOUNCE_PACKET, *PBROWSE_ANNOUNCE_PACKET;
//
//  The request announcement packet is sent by clients to request that
//  remote servers announce themselves.
//

typedef struct _REQUEST_ANNOUNCE_PACKET_1 {      // Contents of request announcement
    UCHAR    Flags;                 // Unused Flags
    CHAR     Reply[LM20_CNLEN+1];
}  REQUEST_ANNOUNCE_PACKET_1, *PREQUEST_ANNOUNCE_PACKET_1;

typedef struct _REQUEST_ANNOUNCE_PACKET {        /* Request announcement struct */
    UCHAR   Type;
    REQUEST_ANNOUNCE_PACKET_1    RequestAnnouncement;
} REQUEST_ANNOUNCE_PACKET, *PREQUEST_ANNOUNCE_PACKET;

#define HOST_ANNC_NAME(xx)     ((xx)->NameComment)
#define HOST_ANNC_COMMENT(xx)  ((xx)->NameComment + (strlen(HOST_ANNC_NAME(xx))+1))

#define BROWSE_ANNC_NAME(xx)     ((xx)->ServerName)
#define BROWSE_ANNC_COMMENT(xx)  ((xx)->Comment)

//
//  Definitions for Windows Browser
//

//
//  Request to retrieve a backup server list.
//

typedef struct _BACKUP_LIST_REQUEST_1 {
    UCHAR       RequestedCount;
    ULONG       Token;
} BACKUP_LIST_REQUEST_1, *PBACKUP_LIST_REQUEST_1;


typedef struct _BACKUP_LIST_REQUEST {
    UCHAR  Type;
    BACKUP_LIST_REQUEST_1 BackupListRequest;
} BACKUP_LIST_REQUEST, *PBACKUP_LIST_REQUEST;

//
//  Response containing a backup server list.
//

typedef struct _BACKUP_LIST_RESPONSE_1 {
    UCHAR       BackupServerCount;
    ULONG       Token;
    UCHAR       BackupServerList[1];
} BACKUP_LIST_RESPONSE_1, *PBACKUP_LIST_RESPONSE_1;

typedef struct _BACKUP_LIST_RESPONSE {
    UCHAR Type;
    BACKUP_LIST_RESPONSE_1 BackupListResponse;
} BACKUP_LIST_RESPONSE, *PBACKUP_LIST_RESPONSE;


//
//  Message indicating that a potential browser server should become a backup
//  server.
//

typedef struct _BECOME_BACKUP_1 {
    UCHAR       BrowserToPromote[1];
} BECOME_BACKUP_1, *PBECOME_BACKUP_1;

typedef struct _BECOME_BACKUP {
    UCHAR Type;
    BECOME_BACKUP_1 BecomeBackup;
} BECOME_BACKUP, *PBECOME_BACKUP;


//
//  Sent during the election process.
//

typedef struct _REQUEST_ELECTION_1 {
    UCHAR       Version;
    ULONG       Criteria;
    ULONG       TimeUp;
    ULONG       MustBeZero;
    UCHAR       ServerName[1];
} REQUEST_ELECTION_1, *PREQUEST_ELECTION_1;

typedef struct _REQUEST_ELECTION {
    UCHAR Type;
    REQUEST_ELECTION_1 ElectionRequest;
} REQUEST_ELECTION, *PREQUEST_ELECTION;

#define ELECTION_CR_OSTYPE      0xFF000000L // Native OS running on server
#define ELECTION_CR_OSWFW       0x01000000L //  Windows for workgroups server
#define ELECTION_CR_WIN_NT      0x10000000L //  Windows/NT Server
#define ELECTION_CR_LM_NT       0x20000000L //  Lan Manager for Windows/NT

#define ELECTION_CR_REVISION    0x00FFFF00L // Browser software revision
#define ELECTION_MAKE_REV(major, minor) (((major)&0xffL)<<16|((minor)&0xFFL)<<8)

#define ELECTION_CR_DESIRE      0x000000FFL // Desirability of becoming master.

//
//  Election desirability within criteria.
//
//  Most important is a running PDC, next is a configured domain master.
//
//  After that come running masters, then configured backups, then existing
//  running backups.
//
// Machines running WINS client are important because they are more capable
// of connecting to a PDC who's address was configured via DHCP.
//

#define ELECTION_DESIRE_AM_BACKUP  0x00000001L // Currently is backup
#define ELECTION_DESIRE_AM_CFG_BKP 0x00000002L // Always want to be
                                               //  master - set if backup &&
                                               //  MaintainServerList==YES
#define ELECTION_DESIRE_AM_MASTER  0x00000004L // Currently is master
#define ELECTION_DESIRE_AM_DOMMSTR 0x00000008L // Configured as domain master

#define ELECTION_DESIRE_WINS_CLIENT 0x00000020L // Transport running WINS client


#ifdef ENABLE_PSEUDO_BROWSER
#define ELECTION_DESIRE_AM_PSEUDO  0x00000040L // Machine is a Pseudo Server
#endif

#define ELECTION_DESIRE_AM_PDC     0x00000080L // Machine is a lanman NT server.

//
//  "Tickle" packet - sent to change state of browser.
//

typedef struct _RESET_STATE_1 {
    UCHAR       Options;
} RESET_STATE_1, *PRESET_STATE_1;

typedef struct _RESET_STATE {
    UCHAR Type;
    RESET_STATE_1 ResetStateRequest;
} RESET_STATE, *PRESET_STATE;

#define RESET_STATE_STOP_MASTER 0x01    // Stop being master
#define RESET_STATE_CLEAR_ALL   0x02    // Clear all browser state.
#define RESET_STATE_STOP        0x04    // Stop the browser service.

//
//  Master Announcement - Send from master to domain master.
//

typedef struct _MASTER_ANNOUNCEMENT_1 {
    UCHAR       MasterName[1];
} MASTER_ANNOUNCEMENT_1, *PMASTER_ANNOUNCEMENT_1;

typedef struct _MASTER_ANNOUNCEMENT {
    UCHAR Type;
    MASTER_ANNOUNCEMENT_1 MasterAnnouncement;
} MASTER_ANNOUNCEMENT, *PMASTER_ANNOUNCEMENT;


//
//  Definitions for Workstation interrogation and revalidation transactions
//

typedef struct _WKSTA_INFO_INTERROGATE_PACKET {
    UCHAR   CompatibilityPad;
    ULONG   Delay ;             // Number of milliseconds to wait before replying
    CHAR    ReturnMailslot[1] ; // Mailslot to reply to.
} WKSTA_INFO_INTERROGATE_PACKET, *PWKSTA_INFO_INTERROGATE_PACKET;

typedef struct _WKSTA_INFO_RESPONSE_PACKET {
    UCHAR   CompatibilityPad;
    UCHAR   VersionMajor;
    UCHAR   VersionMinor;
    USHORT  OsVersion ;
    CHAR    ComputerName[1] ;       // var-length ASCIIZ string */
#if 0
//
//  The following two ASCIIZ strings are not defined in the structure
//  but are concatenated to the end of the structure.
//
    CHAR        UserName[] ;
    CHAR        LogonDomain[] ;
#endif
} WKSTA_INFO_RESPONSE_PACKET, *PWKSTA_INFO_RESPONSE_PACKET;

typedef struct _WKSTA_RELOGON_REQUEST_PACKET {
    UCHAR   CompatibilityPad;
    ULONG   Delay ;
    ULONG   Flags ;
    CHAR    ReturnMailslot[1] ; // var-length ASCIIZ string
#if 0
//
//  The following ASCIIZ string is not defined in the structure
//  but is concatenated to the end of the structure.
//

    CHAR    DC_Name[] ;
#endif
} WKSTA_RELOGON_REQUEST_PACKET, *PWKSTA_RELOGON_REQUEST_PACKET;

//
//  Values for <wkrrq_flags> field */
//

#define WKRRQ_FLAG_LOGON_SERVER      0x1    // I'm your official logon server;
                                            // do a relogon to me.
                                            //

typedef struct _WKSTA_RELOGON_RESPONSE_PACKET {
    UCHAR   CompatibilityPad;
    USHORT  Status ;
    CHAR    ComputerName[1] ;   // var-length ASCIIZ string
} WKSTA_RELOGON_RESPONSE_PACKET, *PWKSTA_RELOGON_RESPONSE_PACKET;


//
//  Values for <wkrrs_status> field
//

#define WKRRS_STATUS_SUCCEEDED      0       // Operation succeeded
#define WKRRS_STATUS_DENIED         1       // Operation denied to caller
#define WKRRS_STATUS_FAILED         2       // Operation tried but failed

#define EXCESS_NAME_LEN (sizeof(ITRANS_MS_NAME) - \
                            FIELD_OFFSET(SMB_TRANSACTION_MAILSLOT, Buffer) )

//
//  This structure defines all of the types of requests that appear in messages
//  to the internal mailslot.
//

typedef struct _INTERNAL_TRANSACTION {
    UCHAR   Type;                               // Type of request.
    union {
        HOST_ANNOUNCE_PACKET_1           Announcement ;
        BROWSE_ANNOUNCE_PACKET_1         BrowseAnnouncement ;
        REQUEST_ANNOUNCE_PACKET_1        RequestAnnounce ;
        BACKUP_LIST_RESPONSE_1           GetBackupListResp ;
        BACKUP_LIST_REQUEST_1            GetBackupListRequest ;
        BECOME_BACKUP_1                  BecomeBackup ;
        REQUEST_ELECTION_1               RequestElection ;
        MASTER_ANNOUNCEMENT_1            MasterAnnouncement ;
        RESET_STATE_1                    ResetState ;

        WKSTA_INFO_INTERROGATE_PACKET    InterrogateRequest ;
        WKSTA_INFO_RESPONSE_PACKET       InterrogateResponse ;
        WKSTA_RELOGON_REQUEST_PACKET     RelogonRequest ;
        WKSTA_RELOGON_RESPONSE_PACKET    RelogonResponse ;
    } Union;
} INTERNAL_TRANSACTION, *PINTERNAL_TRANSACTION ;

#include <packoff.h>

#endif // _HOSTANNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\hnetcfg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for hnetcfg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hnetcfg_h__
#define __hnetcfg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IHNetCfgMgr_FWD_DEFINED__
#define __IHNetCfgMgr_FWD_DEFINED__
typedef interface IHNetCfgMgr IHNetCfgMgr;
#endif 	/* __IHNetCfgMgr_FWD_DEFINED__ */


#ifndef __IHNetBridgeSettings_FWD_DEFINED__
#define __IHNetBridgeSettings_FWD_DEFINED__
typedef interface IHNetBridgeSettings IHNetBridgeSettings;
#endif 	/* __IHNetBridgeSettings_FWD_DEFINED__ */


#ifndef __IHNetFirewallSettings_FWD_DEFINED__
#define __IHNetFirewallSettings_FWD_DEFINED__
typedef interface IHNetFirewallSettings IHNetFirewallSettings;
#endif 	/* __IHNetFirewallSettings_FWD_DEFINED__ */


#ifndef __IHNetIcsSettings_FWD_DEFINED__
#define __IHNetIcsSettings_FWD_DEFINED__
typedef interface IHNetIcsSettings IHNetIcsSettings;
#endif 	/* __IHNetIcsSettings_FWD_DEFINED__ */


#ifndef __IHNetProtocolSettings_FWD_DEFINED__
#define __IHNetProtocolSettings_FWD_DEFINED__
typedef interface IHNetProtocolSettings IHNetProtocolSettings;
#endif 	/* __IHNetProtocolSettings_FWD_DEFINED__ */


#ifndef __IHNetConnection_FWD_DEFINED__
#define __IHNetConnection_FWD_DEFINED__
typedef interface IHNetConnection IHNetConnection;
#endif 	/* __IHNetConnection_FWD_DEFINED__ */


#ifndef __IHNetFirewalledConnection_FWD_DEFINED__
#define __IHNetFirewalledConnection_FWD_DEFINED__
typedef interface IHNetFirewalledConnection IHNetFirewalledConnection;
#endif 	/* __IHNetFirewalledConnection_FWD_DEFINED__ */


#ifndef __IHNetIcsPublicConnection_FWD_DEFINED__
#define __IHNetIcsPublicConnection_FWD_DEFINED__
typedef interface IHNetIcsPublicConnection IHNetIcsPublicConnection;
#endif 	/* __IHNetIcsPublicConnection_FWD_DEFINED__ */


#ifndef __IHNetIcsPrivateConnection_FWD_DEFINED__
#define __IHNetIcsPrivateConnection_FWD_DEFINED__
typedef interface IHNetIcsPrivateConnection IHNetIcsPrivateConnection;
#endif 	/* __IHNetIcsPrivateConnection_FWD_DEFINED__ */


#ifndef __IHNetBridge_FWD_DEFINED__
#define __IHNetBridge_FWD_DEFINED__
typedef interface IHNetBridge IHNetBridge;
#endif 	/* __IHNetBridge_FWD_DEFINED__ */


#ifndef __IHNetBridgedConnection_FWD_DEFINED__
#define __IHNetBridgedConnection_FWD_DEFINED__
typedef interface IHNetBridgedConnection IHNetBridgedConnection;
#endif 	/* __IHNetBridgedConnection_FWD_DEFINED__ */


#ifndef __IHNetPortMappingProtocol_FWD_DEFINED__
#define __IHNetPortMappingProtocol_FWD_DEFINED__
typedef interface IHNetPortMappingProtocol IHNetPortMappingProtocol;
#endif 	/* __IHNetPortMappingProtocol_FWD_DEFINED__ */


#ifndef __IHNetPortMappingBinding_FWD_DEFINED__
#define __IHNetPortMappingBinding_FWD_DEFINED__
typedef interface IHNetPortMappingBinding IHNetPortMappingBinding;
#endif 	/* __IHNetPortMappingBinding_FWD_DEFINED__ */


#ifndef __IHNetApplicationProtocol_FWD_DEFINED__
#define __IHNetApplicationProtocol_FWD_DEFINED__
typedef interface IHNetApplicationProtocol IHNetApplicationProtocol;
#endif 	/* __IHNetApplicationProtocol_FWD_DEFINED__ */


#ifndef __IEnumHNetBridges_FWD_DEFINED__
#define __IEnumHNetBridges_FWD_DEFINED__
typedef interface IEnumHNetBridges IEnumHNetBridges;
#endif 	/* __IEnumHNetBridges_FWD_DEFINED__ */


#ifndef __IEnumHNetFirewalledConnections_FWD_DEFINED__
#define __IEnumHNetFirewalledConnections_FWD_DEFINED__
typedef interface IEnumHNetFirewalledConnections IEnumHNetFirewalledConnections;
#endif 	/* __IEnumHNetFirewalledConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetIcsPublicConnections_FWD_DEFINED__
#define __IEnumHNetIcsPublicConnections_FWD_DEFINED__
typedef interface IEnumHNetIcsPublicConnections IEnumHNetIcsPublicConnections;
#endif 	/* __IEnumHNetIcsPublicConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetIcsPrivateConnections_FWD_DEFINED__
#define __IEnumHNetIcsPrivateConnections_FWD_DEFINED__
typedef interface IEnumHNetIcsPrivateConnections IEnumHNetIcsPrivateConnections;
#endif 	/* __IEnumHNetIcsPrivateConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetApplicationProtocols_FWD_DEFINED__
#define __IEnumHNetApplicationProtocols_FWD_DEFINED__
typedef interface IEnumHNetApplicationProtocols IEnumHNetApplicationProtocols;
#endif 	/* __IEnumHNetApplicationProtocols_FWD_DEFINED__ */


#ifndef __IEnumHNetPortMappingProtocols_FWD_DEFINED__
#define __IEnumHNetPortMappingProtocols_FWD_DEFINED__
typedef interface IEnumHNetPortMappingProtocols IEnumHNetPortMappingProtocols;
#endif 	/* __IEnumHNetPortMappingProtocols_FWD_DEFINED__ */


#ifndef __IEnumHNetPortMappingBindings_FWD_DEFINED__
#define __IEnumHNetPortMappingBindings_FWD_DEFINED__
typedef interface IEnumHNetPortMappingBindings IEnumHNetPortMappingBindings;
#endif 	/* __IEnumHNetPortMappingBindings_FWD_DEFINED__ */


#ifndef __IEnumHNetBridgedConnections_FWD_DEFINED__
#define __IEnumHNetBridgedConnections_FWD_DEFINED__
typedef interface IEnumHNetBridgedConnections IEnumHNetBridgedConnections;
#endif 	/* __IEnumHNetBridgedConnections_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcon.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_hnetcfg_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_HNetCfgMgr;
EXTERN_C const CLSID CLSID_SharingManagerEnumPublicConnection;
EXTERN_C const CLSID CLSID_SharingManagerEnumPrivateConnection;
EXTERN_C const CLSID CLSID_SharingManagerEnumApplicationDefinition;
EXTERN_C const CLSID CLSID_SharingManagerEnumPortMapping;
EXTERN_C const CLSID CLSID_SharingApplicationDefinition;
EXTERN_C const CLSID CLSID_SharingApplicationConfiguration;
EXTERN_C const CLSID CLSID_NetSharingConfiguration;
























extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0000_v0_0_s_ifspec;

#ifndef __IHNetCfgMgr_INTERFACE_DEFINED__
#define __IHNetCfgMgr_INTERFACE_DEFINED__

/* interface IHNetCfgMgr */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetCfgMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6C-3032-11D4-9348-00C04F8EEB71")
    IHNetCfgMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIHNetConnectionForINetConnection( 
            /* [in] */ INetConnection *pNetConnection,
            /* [out] */ IHNetConnection **ppHNetConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIHNetConnectionForGuid( 
            /* [in] */ GUID *pGuid,
            /* [in] */ BOOLEAN fLanConnection,
            /* [in] */ BOOLEAN fCreateEntries,
            /* [out] */ IHNetConnection **ppHNetConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetCfgMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetCfgMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetCfgMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetCfgMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIHNetConnectionForINetConnection )( 
            IHNetCfgMgr * This,
            /* [in] */ INetConnection *pNetConnection,
            /* [out] */ IHNetConnection **ppHNetConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetIHNetConnectionForGuid )( 
            IHNetCfgMgr * This,
            /* [in] */ GUID *pGuid,
            /* [in] */ BOOLEAN fLanConnection,
            /* [in] */ BOOLEAN fCreateEntries,
            /* [out] */ IHNetConnection **ppHNetConnection);
        
        END_INTERFACE
    } IHNetCfgMgrVtbl;

    interface IHNetCfgMgr
    {
        CONST_VTBL struct IHNetCfgMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetCfgMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetCfgMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetCfgMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetCfgMgr_GetIHNetConnectionForINetConnection(This,pNetConnection,ppHNetConnection)	\
    (This)->lpVtbl -> GetIHNetConnectionForINetConnection(This,pNetConnection,ppHNetConnection)

#define IHNetCfgMgr_GetIHNetConnectionForGuid(This,pGuid,fLanConnection,fCreateEntries,ppHNetConnection)	\
    (This)->lpVtbl -> GetIHNetConnectionForGuid(This,pGuid,fLanConnection,fCreateEntries,ppHNetConnection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetCfgMgr_GetIHNetConnectionForINetConnection_Proxy( 
    IHNetCfgMgr * This,
    /* [in] */ INetConnection *pNetConnection,
    /* [out] */ IHNetConnection **ppHNetConnection);


void __RPC_STUB IHNetCfgMgr_GetIHNetConnectionForINetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetCfgMgr_GetIHNetConnectionForGuid_Proxy( 
    IHNetCfgMgr * This,
    /* [in] */ GUID *pGuid,
    /* [in] */ BOOLEAN fLanConnection,
    /* [in] */ BOOLEAN fCreateEntries,
    /* [out] */ IHNetConnection **ppHNetConnection);


void __RPC_STUB IHNetCfgMgr_GetIHNetConnectionForGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetCfgMgr_INTERFACE_DEFINED__ */


#ifndef __IHNetBridgeSettings_INTERFACE_DEFINED__
#define __IHNetBridgeSettings_INTERFACE_DEFINED__

/* interface IHNetBridgeSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridgeSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6D-3032-11D4-9348-00C04F8EEB71")
    IHNetBridgeSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumBridges( 
            /* [out] */ IEnumHNetBridges **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBridge( 
            /* [out] */ IHNetBridge **ppHNetBridge,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllBridges( 
            /* [out] */ ULONG *pcBridges,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgeSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridgeSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridgeSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridgeSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBridges )( 
            IHNetBridgeSettings * This,
            /* [out] */ IEnumHNetBridges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBridge )( 
            IHNetBridgeSettings * This,
            /* [out] */ IHNetBridge **ppHNetBridge,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllBridges )( 
            IHNetBridgeSettings * This,
            /* [out] */ ULONG *pcBridges,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgeSettingsVtbl;

    interface IHNetBridgeSettings
    {
        CONST_VTBL struct IHNetBridgeSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridgeSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridgeSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridgeSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridgeSettings_EnumBridges(This,ppEnum)	\
    (This)->lpVtbl -> EnumBridges(This,ppEnum)

#define IHNetBridgeSettings_CreateBridge(This,ppHNetBridge,pnetcfgExisting)	\
    (This)->lpVtbl -> CreateBridge(This,ppHNetBridge,pnetcfgExisting)

#define IHNetBridgeSettings_DestroyAllBridges(This,pcBridges,pnetcfgExisting)	\
    (This)->lpVtbl -> DestroyAllBridges(This,pcBridges,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_EnumBridges_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ IEnumHNetBridges **ppEnum);


void __RPC_STUB IHNetBridgeSettings_EnumBridges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_CreateBridge_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ IHNetBridge **ppHNetBridge,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgeSettings_CreateBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_DestroyAllBridges_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ ULONG *pcBridges,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgeSettings_DestroyAllBridges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridgeSettings_INTERFACE_DEFINED__ */


#ifndef __IHNetFirewallSettings_INTERFACE_DEFINED__
#define __IHNetFirewallSettings_INTERFACE_DEFINED__

/* interface IHNetFirewallSettings */
/* [unique][uuid][object][local] */ 

typedef struct tagHNET_FW_LOGGING_SETTINGS
    {
    /* [string] */ LPWSTR pszwPath;
    ULONG ulMaxFileSize;
    BOOLEAN fLogDroppedPackets;
    BOOLEAN fLogConnections;
    } 	HNET_FW_LOGGING_SETTINGS;


EXTERN_C const IID IID_IHNetFirewallSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6E-3032-11D4-9348-00C04F8EEB71")
    IHNetFirewallSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFirewalledConnections( 
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirewallLoggingSettings( 
            /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFirewallLoggingSettings( 
            /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAllFirewalling( 
            /* [out] */ ULONG *pcFirewalledConnections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetFirewallSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetFirewallSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetFirewallSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetFirewallSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFirewalledConnections )( 
            IHNetFirewallSettings * This,
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirewallLoggingSettings )( 
            IHNetFirewallSettings * This,
            /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *SetFirewallLoggingSettings )( 
            IHNetFirewallSettings * This,
            /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings);
        
        HRESULT ( STDMETHODCALLTYPE *DisableAllFirewalling )( 
            IHNetFirewallSettings * This,
            /* [out] */ ULONG *pcFirewalledConnections);
        
        END_INTERFACE
    } IHNetFirewallSettingsVtbl;

    interface IHNetFirewallSettings
    {
        CONST_VTBL struct IHNetFirewallSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetFirewallSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetFirewallSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetFirewallSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetFirewallSettings_EnumFirewalledConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumFirewalledConnections(This,ppEnum)

#define IHNetFirewallSettings_GetFirewallLoggingSettings(This,ppSettings)	\
    (This)->lpVtbl -> GetFirewallLoggingSettings(This,ppSettings)

#define IHNetFirewallSettings_SetFirewallLoggingSettings(This,pSettings)	\
    (This)->lpVtbl -> SetFirewallLoggingSettings(This,pSettings)

#define IHNetFirewallSettings_DisableAllFirewalling(This,pcFirewalledConnections)	\
    (This)->lpVtbl -> DisableAllFirewalling(This,pcFirewalledConnections)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_EnumFirewalledConnections_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ IEnumHNetFirewalledConnections **ppEnum);


void __RPC_STUB IHNetFirewallSettings_EnumFirewalledConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_GetFirewallLoggingSettings_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings);


void __RPC_STUB IHNetFirewallSettings_GetFirewallLoggingSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_SetFirewallLoggingSettings_Proxy( 
    IHNetFirewallSettings * This,
    /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings);


void __RPC_STUB IHNetFirewallSettings_SetFirewallLoggingSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_DisableAllFirewalling_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ ULONG *pcFirewalledConnections);


void __RPC_STUB IHNetFirewallSettings_DisableAllFirewalling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetFirewallSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0159 */
/* [local] */ 

VOID
HNetFreeFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    );


extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0159_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0159_v0_0_s_ifspec;

#ifndef __IHNetIcsSettings_INTERFACE_DEFINED__
#define __IHNetIcsSettings_INTERFACE_DEFINED__

/* interface IHNetIcsSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6F-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumIcsPublicConnections( 
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumIcsPrivateConnections( 
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIcs( 
            /* [out] */ ULONG *pcIcsPublicConnections,
            /* [out] */ ULONG *pcIcsPrivateConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPossiblePrivateConnections( 
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ ULONG *pcPrivateConnections,
            /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
            /* [out] */ LONG *pxCurrentPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutodialSettings( 
            /* [out] */ BOOLEAN *pfAutodialEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAutodialSettings( 
            /* [in] */ BOOLEAN fEnableAutodial) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDhcpEnabled( 
            /* [out] */ BOOLEAN *pfDhcpEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDhcpEnabled( 
            /* [in] */ BOOLEAN fEnableDhcp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDhcpScopeSettings( 
            /* [out] */ DWORD *pdwScopeAddress,
            /* [out] */ DWORD *pdwScopeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDhcpScopeSettings( 
            /* [in] */ DWORD dwScopeAddress,
            /* [in] */ DWORD dwScopeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDhcpReservedAddresses( 
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDnsEnabled( 
            /* [out] */ BOOLEAN *pfDnsEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDnsEnabled( 
            /* [in] */ BOOLEAN fEnableDns) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumIcsPublicConnections )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumIcsPrivateConnections )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIcs )( 
            IHNetIcsSettings * This,
            /* [out] */ ULONG *pcIcsPublicConnections,
            /* [out] */ ULONG *pcIcsPrivateConnections);
        
        HRESULT ( STDMETHODCALLTYPE *GetPossiblePrivateConnections )( 
            IHNetIcsSettings * This,
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ ULONG *pcPrivateConnections,
            /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
            /* [out] */ LONG *pxCurrentPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutodialSettings )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfAutodialEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetAutodialSettings )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableAutodial);
        
        HRESULT ( STDMETHODCALLTYPE *GetDhcpEnabled )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfDhcpEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetDhcpEnabled )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableDhcp);
        
        HRESULT ( STDMETHODCALLTYPE *GetDhcpScopeSettings )( 
            IHNetIcsSettings * This,
            /* [out] */ DWORD *pdwScopeAddress,
            /* [out] */ DWORD *pdwScopeMask);
        
        HRESULT ( STDMETHODCALLTYPE *SetDhcpScopeSettings )( 
            IHNetIcsSettings * This,
            /* [in] */ DWORD dwScopeAddress,
            /* [in] */ DWORD dwScopeMask);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDhcpReservedAddresses )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDnsEnabled )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfDnsEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetDnsEnabled )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableDns);
        
        END_INTERFACE
    } IHNetIcsSettingsVtbl;

    interface IHNetIcsSettings
    {
        CONST_VTBL struct IHNetIcsSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsSettings_EnumIcsPublicConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumIcsPublicConnections(This,ppEnum)

#define IHNetIcsSettings_EnumIcsPrivateConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumIcsPrivateConnections(This,ppEnum)

#define IHNetIcsSettings_DisableIcs(This,pcIcsPublicConnections,pcIcsPrivateConnections)	\
    (This)->lpVtbl -> DisableIcs(This,pcIcsPublicConnections,pcIcsPrivateConnections)

#define IHNetIcsSettings_GetPossiblePrivateConnections(This,pConn,pcPrivateConnections,pprgPrivateConnections,pxCurrentPrivate)	\
    (This)->lpVtbl -> GetPossiblePrivateConnections(This,pConn,pcPrivateConnections,pprgPrivateConnections,pxCurrentPrivate)

#define IHNetIcsSettings_GetAutodialSettings(This,pfAutodialEnabled)	\
    (This)->lpVtbl -> GetAutodialSettings(This,pfAutodialEnabled)

#define IHNetIcsSettings_SetAutodialSettings(This,fEnableAutodial)	\
    (This)->lpVtbl -> SetAutodialSettings(This,fEnableAutodial)

#define IHNetIcsSettings_GetDhcpEnabled(This,pfDhcpEnabled)	\
    (This)->lpVtbl -> GetDhcpEnabled(This,pfDhcpEnabled)

#define IHNetIcsSettings_SetDhcpEnabled(This,fEnableDhcp)	\
    (This)->lpVtbl -> SetDhcpEnabled(This,fEnableDhcp)

#define IHNetIcsSettings_GetDhcpScopeSettings(This,pdwScopeAddress,pdwScopeMask)	\
    (This)->lpVtbl -> GetDhcpScopeSettings(This,pdwScopeAddress,pdwScopeMask)

#define IHNetIcsSettings_SetDhcpScopeSettings(This,dwScopeAddress,dwScopeMask)	\
    (This)->lpVtbl -> SetDhcpScopeSettings(This,dwScopeAddress,dwScopeMask)

#define IHNetIcsSettings_EnumDhcpReservedAddresses(This,ppEnum)	\
    (This)->lpVtbl -> EnumDhcpReservedAddresses(This,ppEnum)

#define IHNetIcsSettings_GetDnsEnabled(This,pfDnsEnabled)	\
    (This)->lpVtbl -> GetDnsEnabled(This,pfDnsEnabled)

#define IHNetIcsSettings_SetDnsEnabled(This,fEnableDns)	\
    (This)->lpVtbl -> SetDnsEnabled(This,fEnableDns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumIcsPublicConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumIcsPublicConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumIcsPrivateConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumIcsPrivateConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_DisableIcs_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ ULONG *pcIcsPublicConnections,
    /* [out] */ ULONG *pcIcsPrivateConnections);


void __RPC_STUB IHNetIcsSettings_DisableIcs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetPossiblePrivateConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ IHNetConnection *pConn,
    /* [out] */ ULONG *pcPrivateConnections,
    /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
    /* [out] */ LONG *pxCurrentPrivate);


void __RPC_STUB IHNetIcsSettings_GetPossiblePrivateConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetAutodialSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfAutodialEnabled);


void __RPC_STUB IHNetIcsSettings_GetAutodialSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetAutodialSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableAutodial);


void __RPC_STUB IHNetIcsSettings_SetAutodialSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDhcpEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfDhcpEnabled);


void __RPC_STUB IHNetIcsSettings_GetDhcpEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDhcpEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableDhcp);


void __RPC_STUB IHNetIcsSettings_SetDhcpEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDhcpScopeSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ DWORD *pdwScopeAddress,
    /* [out] */ DWORD *pdwScopeMask);


void __RPC_STUB IHNetIcsSettings_GetDhcpScopeSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDhcpScopeSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ DWORD dwScopeAddress,
    /* [in] */ DWORD dwScopeMask);


void __RPC_STUB IHNetIcsSettings_SetDhcpScopeSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumDhcpReservedAddresses_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumDhcpReservedAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDnsEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfDnsEnabled);


void __RPC_STUB IHNetIcsSettings_GetDnsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDnsEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableDns);


void __RPC_STUB IHNetIcsSettings_SetDnsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0160 */
/* [local] */ 

typedef struct tagHNET_RESPONSE_RANGE
    {
    UCHAR ucIPProtocol;
    USHORT usStartPort;
    USHORT usEndPort;
    } 	HNET_RESPONSE_RANGE;

typedef struct tagHNET_PORT_MAPPING_BINDING
    {
    OLECHAR *pszwTargetMachineName;
    ULONG ulTargetMachineAddress;
    } 	HNET_PORT_MAPPING_BINDING;



extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0160_v0_0_s_ifspec;

#ifndef __IHNetProtocolSettings_INTERFACE_DEFINED__
#define __IHNetProtocolSettings_INTERFACE_DEFINED__

/* interface IHNetProtocolSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetProtocolSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B70-3032-11D4-9348-00C04F8EEB71")
    IHNetProtocolSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumApplicationProtocols( 
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationProtocol( 
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucOutgoingIPProtocol,
            /* [in] */ USHORT usOutgoingPort,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
            /* [out] */ IHNetApplicationProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortMappingProtocols( 
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePortMappingProtocol( 
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usPort,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPortMappingProtocol( 
            /* [in] */ GUID *pGuid,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetProtocolSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetProtocolSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetProtocolSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetProtocolSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplicationProtocols )( 
            IHNetProtocolSettings * This,
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplicationProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucOutgoingIPProtocol,
            /* [in] */ USHORT usOutgoingPort,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
            /* [out] */ IHNetApplicationProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortMappingProtocols )( 
            IHNetProtocolSettings * This,
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePortMappingProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usPort,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *FindPortMappingProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ GUID *pGuid,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        END_INTERFACE
    } IHNetProtocolSettingsVtbl;

    interface IHNetProtocolSettings
    {
        CONST_VTBL struct IHNetProtocolSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetProtocolSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetProtocolSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetProtocolSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetProtocolSettings_EnumApplicationProtocols(This,fEnabledOnly,ppEnum)	\
    (This)->lpVtbl -> EnumApplicationProtocols(This,fEnabledOnly,ppEnum)

#define IHNetProtocolSettings_CreateApplicationProtocol(This,pszwName,ucOutgoingIPProtocol,usOutgoingPort,uscResponses,rgResponses,ppProtocol)	\
    (This)->lpVtbl -> CreateApplicationProtocol(This,pszwName,ucOutgoingIPProtocol,usOutgoingPort,uscResponses,rgResponses,ppProtocol)

#define IHNetProtocolSettings_EnumPortMappingProtocols(This,ppEnum)	\
    (This)->lpVtbl -> EnumPortMappingProtocols(This,ppEnum)

#define IHNetProtocolSettings_CreatePortMappingProtocol(This,pszwName,ucIPProtocol,usPort,ppProtocol)	\
    (This)->lpVtbl -> CreatePortMappingProtocol(This,pszwName,ucIPProtocol,usPort,ppProtocol)

#define IHNetProtocolSettings_FindPortMappingProtocol(This,pGuid,ppProtocol)	\
    (This)->lpVtbl -> FindPortMappingProtocol(This,pGuid,ppProtocol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_EnumApplicationProtocols_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ BOOLEAN fEnabledOnly,
    /* [out] */ IEnumHNetApplicationProtocols **ppEnum);


void __RPC_STUB IHNetProtocolSettings_EnumApplicationProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_CreateApplicationProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ OLECHAR *pszwName,
    /* [in] */ UCHAR ucOutgoingIPProtocol,
    /* [in] */ USHORT usOutgoingPort,
    /* [in] */ USHORT uscResponses,
    /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
    /* [out] */ IHNetApplicationProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_CreateApplicationProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_EnumPortMappingProtocols_Proxy( 
    IHNetProtocolSettings * This,
    /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);


void __RPC_STUB IHNetProtocolSettings_EnumPortMappingProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_CreatePortMappingProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ OLECHAR *pszwName,
    /* [in] */ UCHAR ucIPProtocol,
    /* [in] */ USHORT usPort,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_CreatePortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_FindPortMappingProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ GUID *pGuid,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_FindPortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetProtocolSettings_INTERFACE_DEFINED__ */


#ifndef __IHNetConnection_INTERFACE_DEFINED__
#define __IHNetConnection_INTERFACE_DEFINED__

/* interface IHNetConnection */
/* [unique][uuid][object][local] */ 

typedef struct tagHNET_CONN_PROPERTIES
    {
    BOOLEAN fLanConnection;
    BOOLEAN fFirewalled;
    BOOLEAN fIcsPublic;
    BOOLEAN fIcsPrivate;
    BOOLEAN fBridge;
    BOOLEAN fPartOfBridge;
    BOOLEAN fCanBeBridged;
    BOOLEAN fCanBeFirewalled;
    BOOLEAN fCanBeIcsPublic;
    BOOLEAN fCanBeIcsPrivate;
    } 	HNET_CONN_PROPERTIES;

typedef struct tagHNET_FW_ICMP_SETTINGS
    {
    BOOLEAN fAllowOutboundDestinationUnreachable;
    BOOLEAN fAllowOutboundSourceQuench;
    BOOLEAN fAllowRedirect;
    BOOLEAN fAllowInboundEchoRequest;
    BOOLEAN fAllowInboundRouterRequest;
    BOOLEAN fAllowOutboundTimeExceeded;
    BOOLEAN fAllowOutboundParameterProblem;
    BOOLEAN fAllowInboundTimestampRequest;
    BOOLEAN fAllowInboundMaskRequest;
    } 	HNET_FW_ICMP_SETTINGS;


EXTERN_C const IID IID_IHNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B71-3032-11D4-9348-00C04F8EEB71")
    IHNetConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetINetConnection( 
            /* [out] */ INetConnection **ppNetConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRasPhonebookPath( 
            /* [string][out] */ OLECHAR **ppszwPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ HNET_CONN_PROPERTIES **ppProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlInterface( 
            REFIID iid,
            /* [iid_is] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Firewall( 
            /* [out] */ IHNetFirewalledConnection **ppFirewalledConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePublic( 
            /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePrivate( 
            /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortMappings( 
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindingForPortMappingProtocol( 
            /* [in] */ IHNetPortMappingProtocol *pProtocol,
            /* [out] */ IHNetPortMappingBinding **ppBinding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcmpSettings( 
            /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcmpSettings( 
            /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowAutoconfigBalloon( 
            /* [out] */ BOOLEAN *pfShowBalloon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRasConnectionEntry( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetINetConnection )( 
            IHNetConnection * This,
            /* [out] */ INetConnection **ppNetConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuid )( 
            IHNetConnection * This,
            /* [out] */ GUID **ppGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetConnection * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasPhonebookPath )( 
            IHNetConnection * This,
            /* [string][out] */ OLECHAR **ppszwPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IHNetConnection * This,
            /* [out] */ HNET_CONN_PROPERTIES **ppProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
            IHNetConnection * This,
            REFIID iid,
            /* [iid_is] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Firewall )( 
            IHNetConnection * This,
            /* [out] */ IHNetFirewalledConnection **ppFirewalledConn);
        
        HRESULT ( STDMETHODCALLTYPE *SharePublic )( 
            IHNetConnection * This,
            /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn);
        
        HRESULT ( STDMETHODCALLTYPE *SharePrivate )( 
            IHNetConnection * This,
            /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortMappings )( 
            IHNetConnection * This,
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindingForPortMappingProtocol )( 
            IHNetConnection * This,
            /* [in] */ IHNetPortMappingProtocol *pProtocol,
            /* [out] */ IHNetPortMappingBinding **ppBinding);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcmpSettings )( 
            IHNetConnection * This,
            /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcmpSettings )( 
            IHNetConnection * This,
            /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings);
        
        HRESULT ( STDMETHODCALLTYPE *ShowAutoconfigBalloon )( 
            IHNetConnection * This,
            /* [out] */ BOOLEAN *pfShowBalloon);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRasConnectionEntry )( 
            IHNetConnection * This);
        
        END_INTERFACE
    } IHNetConnectionVtbl;

    interface IHNetConnection
    {
        CONST_VTBL struct IHNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetConnection_GetINetConnection(This,ppNetConnection)	\
    (This)->lpVtbl -> GetINetConnection(This,ppNetConnection)

#define IHNetConnection_GetGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetGuid(This,ppGuid)

#define IHNetConnection_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetConnection_GetRasPhonebookPath(This,ppszwPath)	\
    (This)->lpVtbl -> GetRasPhonebookPath(This,ppszwPath)

#define IHNetConnection_GetProperties(This,ppProperties)	\
    (This)->lpVtbl -> GetProperties(This,ppProperties)

#define IHNetConnection_GetControlInterface(This,iid,ppv)	\
    (This)->lpVtbl -> GetControlInterface(This,iid,ppv)

#define IHNetConnection_Firewall(This,ppFirewalledConn)	\
    (This)->lpVtbl -> Firewall(This,ppFirewalledConn)

#define IHNetConnection_SharePublic(This,ppIcsPublicConn)	\
    (This)->lpVtbl -> SharePublic(This,ppIcsPublicConn)

#define IHNetConnection_SharePrivate(This,ppIcsPrivateConn)	\
    (This)->lpVtbl -> SharePrivate(This,ppIcsPrivateConn)

#define IHNetConnection_EnumPortMappings(This,fEnabledOnly,ppEnum)	\
    (This)->lpVtbl -> EnumPortMappings(This,fEnabledOnly,ppEnum)

#define IHNetConnection_GetBindingForPortMappingProtocol(This,pProtocol,ppBinding)	\
    (This)->lpVtbl -> GetBindingForPortMappingProtocol(This,pProtocol,ppBinding)

#define IHNetConnection_GetIcmpSettings(This,ppSettings)	\
    (This)->lpVtbl -> GetIcmpSettings(This,ppSettings)

#define IHNetConnection_SetIcmpSettings(This,pSettings)	\
    (This)->lpVtbl -> SetIcmpSettings(This,pSettings)

#define IHNetConnection_ShowAutoconfigBalloon(This,pfShowBalloon)	\
    (This)->lpVtbl -> ShowAutoconfigBalloon(This,pfShowBalloon)

#define IHNetConnection_DeleteRasConnectionEntry(This)	\
    (This)->lpVtbl -> DeleteRasConnectionEntry(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetConnection_GetINetConnection_Proxy( 
    IHNetConnection * This,
    /* [out] */ INetConnection **ppNetConnection);


void __RPC_STUB IHNetConnection_GetINetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetGuid_Proxy( 
    IHNetConnection * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IHNetConnection_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetName_Proxy( 
    IHNetConnection * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetConnection_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetRasPhonebookPath_Proxy( 
    IHNetConnection * This,
    /* [string][out] */ OLECHAR **ppszwPath);


void __RPC_STUB IHNetConnection_GetRasPhonebookPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetProperties_Proxy( 
    IHNetConnection * This,
    /* [out] */ HNET_CONN_PROPERTIES **ppProperties);


void __RPC_STUB IHNetConnection_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetControlInterface_Proxy( 
    IHNetConnection * This,
    REFIID iid,
    /* [iid_is] */ void **ppv);


void __RPC_STUB IHNetConnection_GetControlInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_Firewall_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetFirewalledConnection **ppFirewalledConn);


void __RPC_STUB IHNetConnection_Firewall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SharePublic_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn);


void __RPC_STUB IHNetConnection_SharePublic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SharePrivate_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn);


void __RPC_STUB IHNetConnection_SharePrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_EnumPortMappings_Proxy( 
    IHNetConnection * This,
    /* [in] */ BOOLEAN fEnabledOnly,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IHNetConnection_EnumPortMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetBindingForPortMappingProtocol_Proxy( 
    IHNetConnection * This,
    /* [in] */ IHNetPortMappingProtocol *pProtocol,
    /* [out] */ IHNetPortMappingBinding **ppBinding);


void __RPC_STUB IHNetConnection_GetBindingForPortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetIcmpSettings_Proxy( 
    IHNetConnection * This,
    /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings);


void __RPC_STUB IHNetConnection_GetIcmpSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SetIcmpSettings_Proxy( 
    IHNetConnection * This,
    /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings);


void __RPC_STUB IHNetConnection_SetIcmpSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_ShowAutoconfigBalloon_Proxy( 
    IHNetConnection * This,
    /* [out] */ BOOLEAN *pfShowBalloon);


void __RPC_STUB IHNetConnection_ShowAutoconfigBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_DeleteRasConnectionEntry_Proxy( 
    IHNetConnection * This);


void __RPC_STUB IHNetConnection_DeleteRasConnectionEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetFirewalledConnection_INTERFACE_DEFINED__
#define __IHNetFirewalledConnection_INTERFACE_DEFINED__

/* interface IHNetFirewalledConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetFirewalledConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B72-3032-11D4-9348-00C04F8EEB71")
    IHNetFirewalledConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unfirewall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetFirewalledConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetFirewalledConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetFirewalledConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetFirewalledConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unfirewall )( 
            IHNetFirewalledConnection * This);
        
        END_INTERFACE
    } IHNetFirewalledConnectionVtbl;

    interface IHNetFirewalledConnection
    {
        CONST_VTBL struct IHNetFirewalledConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetFirewalledConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetFirewalledConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetFirewalledConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetFirewalledConnection_Unfirewall(This)	\
    (This)->lpVtbl -> Unfirewall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetFirewalledConnection_Unfirewall_Proxy( 
    IHNetFirewalledConnection * This);


void __RPC_STUB IHNetFirewalledConnection_Unfirewall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetFirewalledConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetIcsPublicConnection_INTERFACE_DEFINED__
#define __IHNetIcsPublicConnection_INTERFACE_DEFINED__

/* interface IHNetIcsPublicConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsPublicConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B73-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsPublicConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unshare( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsPublicConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsPublicConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsPublicConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsPublicConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unshare )( 
            IHNetIcsPublicConnection * This);
        
        END_INTERFACE
    } IHNetIcsPublicConnectionVtbl;

    interface IHNetIcsPublicConnection
    {
        CONST_VTBL struct IHNetIcsPublicConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsPublicConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsPublicConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsPublicConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsPublicConnection_Unshare(This)	\
    (This)->lpVtbl -> Unshare(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsPublicConnection_Unshare_Proxy( 
    IHNetIcsPublicConnection * This);


void __RPC_STUB IHNetIcsPublicConnection_Unshare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsPublicConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetIcsPrivateConnection_INTERFACE_DEFINED__
#define __IHNetIcsPrivateConnection_INTERFACE_DEFINED__

/* interface IHNetIcsPrivateConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsPrivateConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B74-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsPrivateConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemoveFromIcs( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsPrivateConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsPrivateConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsPrivateConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsPrivateConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromIcs )( 
            IHNetIcsPrivateConnection * This);
        
        END_INTERFACE
    } IHNetIcsPrivateConnectionVtbl;

    interface IHNetIcsPrivateConnection
    {
        CONST_VTBL struct IHNetIcsPrivateConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsPrivateConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsPrivateConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsPrivateConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsPrivateConnection_RemoveFromIcs(This)	\
    (This)->lpVtbl -> RemoveFromIcs(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsPrivateConnection_RemoveFromIcs_Proxy( 
    IHNetIcsPrivateConnection * This);


void __RPC_STUB IHNetIcsPrivateConnection_RemoveFromIcs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsPrivateConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetBridge_INTERFACE_DEFINED__
#define __IHNetBridge_INTERFACE_DEFINED__

/* interface IHNetBridge */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B75-3032-11D4-9348-00C04F8EEB71")
    IHNetBridge : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [out] */ IEnumHNetBridgedConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMember( 
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ IHNetBridgedConnection **ppBridgedConn,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridge * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMembers )( 
            IHNetBridge * This,
            /* [out] */ IEnumHNetBridgedConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *AddMember )( 
            IHNetBridge * This,
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ IHNetBridgedConnection **ppBridgedConn,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IHNetBridge * This,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgeVtbl;

    interface IHNetBridge
    {
        CONST_VTBL struct IHNetBridgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridge_EnumMembers(This,ppEnum)	\
    (This)->lpVtbl -> EnumMembers(This,ppEnum)

#define IHNetBridge_AddMember(This,pConn,ppBridgedConn,pnetcfgExisting)	\
    (This)->lpVtbl -> AddMember(This,pConn,ppBridgedConn,pnetcfgExisting)

#define IHNetBridge_Destroy(This,pnetcfgExisting)	\
    (This)->lpVtbl -> Destroy(This,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridge_EnumMembers_Proxy( 
    IHNetBridge * This,
    /* [out] */ IEnumHNetBridgedConnections **ppEnum);


void __RPC_STUB IHNetBridge_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridge_AddMember_Proxy( 
    IHNetBridge * This,
    /* [in] */ IHNetConnection *pConn,
    /* [out] */ IHNetBridgedConnection **ppBridgedConn,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridge_AddMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridge_Destroy_Proxy( 
    IHNetBridge * This,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridge_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridge_INTERFACE_DEFINED__ */


#ifndef __IHNetBridgedConnection_INTERFACE_DEFINED__
#define __IHNetBridgedConnection_INTERFACE_DEFINED__

/* interface IHNetBridgedConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridgedConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B76-3032-11D4-9348-00C04F8EEB71")
    IHNetBridgedConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBridge( 
            /* [out] */ IHNetBridge **ppBridge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromBridge( 
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgedConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridgedConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridgedConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridgedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBridge )( 
            IHNetBridgedConnection * This,
            /* [out] */ IHNetBridge **ppBridge);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromBridge )( 
            IHNetBridgedConnection * This,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgedConnectionVtbl;

    interface IHNetBridgedConnection
    {
        CONST_VTBL struct IHNetBridgedConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridgedConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridgedConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridgedConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridgedConnection_GetBridge(This,ppBridge)	\
    (This)->lpVtbl -> GetBridge(This,ppBridge)

#define IHNetBridgedConnection_RemoveFromBridge(This,pnetcfgExisting)	\
    (This)->lpVtbl -> RemoveFromBridge(This,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridgedConnection_GetBridge_Proxy( 
    IHNetBridgedConnection * This,
    /* [out] */ IHNetBridge **ppBridge);


void __RPC_STUB IHNetBridgedConnection_GetBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgedConnection_RemoveFromBridge_Proxy( 
    IHNetBridgedConnection * This,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgedConnection_RemoveFromBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridgedConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetPortMappingProtocol_INTERFACE_DEFINED__
#define __IHNetPortMappingProtocol_INTERFACE_DEFINED__

/* interface IHNetPortMappingProtocol */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetPortMappingProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7E-3032-11D4-9348-00C04F8EEB71")
    IHNetPortMappingProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPProtocol( 
            /* [out] */ UCHAR *pucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPProtocol( 
            /* [in] */ UCHAR ucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ USHORT usPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuiltIn( 
            /* [out] */ BOOLEAN *pfBuiltIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetPortMappingProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetPortMappingProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetPortMappingProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetPortMappingProtocol * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IHNetPortMappingProtocol * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPProtocol )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ UCHAR *pucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPProtocol )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ UCHAR ucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ USHORT usPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuiltIn )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ BOOLEAN *pfBuiltIn);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHNetPortMappingProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuid )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ GUID **ppGuid);
        
        END_INTERFACE
    } IHNetPortMappingProtocolVtbl;

    interface IHNetPortMappingProtocol
    {
        CONST_VTBL struct IHNetPortMappingProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetPortMappingProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetPortMappingProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetPortMappingProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetPortMappingProtocol_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetPortMappingProtocol_SetName(This,pszwName)	\
    (This)->lpVtbl -> SetName(This,pszwName)

#define IHNetPortMappingProtocol_GetIPProtocol(This,pucProtocol)	\
    (This)->lpVtbl -> GetIPProtocol(This,pucProtocol)

#define IHNetPortMappingProtocol_SetIPProtocol(This,ucProtocol)	\
    (This)->lpVtbl -> SetIPProtocol(This,ucProtocol)

#define IHNetPortMappingProtocol_GetPort(This,pusPort)	\
    (This)->lpVtbl -> GetPort(This,pusPort)

#define IHNetPortMappingProtocol_SetPort(This,usPort)	\
    (This)->lpVtbl -> SetPort(This,usPort)

#define IHNetPortMappingProtocol_GetBuiltIn(This,pfBuiltIn)	\
    (This)->lpVtbl -> GetBuiltIn(This,pfBuiltIn)

#define IHNetPortMappingProtocol_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IHNetPortMappingProtocol_GetGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetGuid(This,ppGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetName_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetPortMappingProtocol_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetName_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetPortMappingProtocol_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetIPProtocol_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ UCHAR *pucProtocol);


void __RPC_STUB IHNetPortMappingProtocol_GetIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetIPProtocol_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [in] */ UCHAR ucProtocol);


void __RPC_STUB IHNetPortMappingProtocol_SetIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetPort_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetPortMappingProtocol_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetPort_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetPortMappingProtocol_SetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetBuiltIn_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ BOOLEAN *pfBuiltIn);


void __RPC_STUB IHNetPortMappingProtocol_GetBuiltIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_Delete_Proxy( 
    IHNetPortMappingProtocol * This);


void __RPC_STUB IHNetPortMappingProtocol_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetGuid_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IHNetPortMappingProtocol_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetPortMappingProtocol_INTERFACE_DEFINED__ */


#ifndef __IHNetPortMappingBinding_INTERFACE_DEFINED__
#define __IHNetPortMappingBinding_INTERFACE_DEFINED__

/* interface IHNetPortMappingBinding */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetPortMappingBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B80-3032-11D4-9348-00C04F8EEB71")
    IHNetPortMappingBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [out] */ IHNetConnection **ppConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocol( 
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ BOOLEAN *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ BOOLEAN fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentMethod( 
            /* [out] */ BOOLEAN *pfUseName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetComputerName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetComputerName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetComputerAddress( 
            /* [out] */ ULONG *pulAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetComputerAddress( 
            /* [in] */ ULONG ulAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetPort( 
            /* [in] */ USHORT usPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetPortMappingBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetPortMappingBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetPortMappingBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetPortMappingBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IHNetPortMappingBinding * This,
            /* [out] */ IHNetConnection **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocol )( 
            IHNetPortMappingBinding * This,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IHNetPortMappingBinding * This,
            /* [out] */ BOOLEAN *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IHNetPortMappingBinding * This,
            /* [in] */ BOOLEAN fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentMethod )( 
            IHNetPortMappingBinding * This,
            /* [out] */ BOOLEAN *pfUseName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetComputerName )( 
            IHNetPortMappingBinding * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetComputerName )( 
            IHNetPortMappingBinding * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetComputerAddress )( 
            IHNetPortMappingBinding * This,
            /* [out] */ ULONG *pulAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetComputerAddress )( 
            IHNetPortMappingBinding * This,
            /* [in] */ ULONG ulAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetPort )( 
            IHNetPortMappingBinding * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetPort )( 
            IHNetPortMappingBinding * This,
            /* [in] */ USHORT usPort);
        
        END_INTERFACE
    } IHNetPortMappingBindingVtbl;

    interface IHNetPortMappingBinding
    {
        CONST_VTBL struct IHNetPortMappingBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetPortMappingBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetPortMappingBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetPortMappingBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetPortMappingBinding_GetConnection(This,ppConnection)	\
    (This)->lpVtbl -> GetConnection(This,ppConnection)

#define IHNetPortMappingBinding_GetProtocol(This,ppProtocol)	\
    (This)->lpVtbl -> GetProtocol(This,ppProtocol)

#define IHNetPortMappingBinding_GetEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> GetEnabled(This,pfEnabled)

#define IHNetPortMappingBinding_SetEnabled(This,fEnable)	\
    (This)->lpVtbl -> SetEnabled(This,fEnable)

#define IHNetPortMappingBinding_GetCurrentMethod(This,pfUseName)	\
    (This)->lpVtbl -> GetCurrentMethod(This,pfUseName)

#define IHNetPortMappingBinding_GetTargetComputerName(This,ppszwName)	\
    (This)->lpVtbl -> GetTargetComputerName(This,ppszwName)

#define IHNetPortMappingBinding_SetTargetComputerName(This,pszwName)	\
    (This)->lpVtbl -> SetTargetComputerName(This,pszwName)

#define IHNetPortMappingBinding_GetTargetComputerAddress(This,pulAddress)	\
    (This)->lpVtbl -> GetTargetComputerAddress(This,pulAddress)

#define IHNetPortMappingBinding_SetTargetComputerAddress(This,ulAddress)	\
    (This)->lpVtbl -> SetTargetComputerAddress(This,ulAddress)

#define IHNetPortMappingBinding_GetTargetPort(This,pusPort)	\
    (This)->lpVtbl -> GetTargetPort(This,pusPort)

#define IHNetPortMappingBinding_SetTargetPort(This,usPort)	\
    (This)->lpVtbl -> SetTargetPort(This,usPort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetConnection_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ IHNetConnection **ppConnection);


void __RPC_STUB IHNetPortMappingBinding_GetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetProtocol_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetPortMappingBinding_GetProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetEnabled_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ BOOLEAN *pfEnabled);


void __RPC_STUB IHNetPortMappingBinding_GetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetEnabled_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ BOOLEAN fEnable);


void __RPC_STUB IHNetPortMappingBinding_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetCurrentMethod_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ BOOLEAN *pfUseName);


void __RPC_STUB IHNetPortMappingBinding_GetCurrentMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetComputerName_Proxy( 
    IHNetPortMappingBinding * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetPortMappingBinding_GetTargetComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetComputerName_Proxy( 
    IHNetPortMappingBinding * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetPortMappingBinding_SetTargetComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetComputerAddress_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ ULONG *pulAddress);


void __RPC_STUB IHNetPortMappingBinding_GetTargetComputerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetComputerAddress_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ ULONG ulAddress);


void __RPC_STUB IHNetPortMappingBinding_SetTargetComputerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetPort_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetPortMappingBinding_GetTargetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetPort_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetPortMappingBinding_SetTargetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetPortMappingBinding_INTERFACE_DEFINED__ */


#ifndef __IHNetApplicationProtocol_INTERFACE_DEFINED__
#define __IHNetApplicationProtocol_INTERFACE_DEFINED__

/* interface IHNetApplicationProtocol */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetApplicationProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7F-3032-11D4-9348-00C04F8EEB71")
    IHNetApplicationProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutgoingIPProtocol( 
            /* [out] */ UCHAR *pucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutgoingIPProtocol( 
            /* [in] */ UCHAR ucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutgoingPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutgoingPort( 
            /* [in] */ USHORT usPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResponseRanges( 
            /* [out] */ USHORT *puscResponses,
            /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResponseRanges( 
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuiltIn( 
            /* [out] */ BOOLEAN *pfBuiltIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ BOOLEAN *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ BOOLEAN fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetApplicationProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetApplicationProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetApplicationProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetApplicationProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetApplicationProtocol * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IHNetApplicationProtocol * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutgoingIPProtocol )( 
            IHNetApplicationProtocol * This,
            /* [out] */ UCHAR *pucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutgoingIPProtocol )( 
            IHNetApplicationProtocol * This,
            /* [in] */ UCHAR ucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutgoingPort )( 
            IHNetApplicationProtocol * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutgoingPort )( 
            IHNetApplicationProtocol * This,
            /* [in] */ USHORT usPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponseRanges )( 
            IHNetApplicationProtocol * This,
            /* [out] */ USHORT *puscResponses,
            /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetResponseRanges )( 
            IHNetApplicationProtocol * This,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuiltIn )( 
            IHNetApplicationProtocol * This,
            /* [out] */ BOOLEAN *pfBuiltIn);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IHNetApplicationProtocol * This,
            /* [out] */ BOOLEAN *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IHNetApplicationProtocol * This,
            /* [in] */ BOOLEAN fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHNetApplicationProtocol * This);
        
        END_INTERFACE
    } IHNetApplicationProtocolVtbl;

    interface IHNetApplicationProtocol
    {
        CONST_VTBL struct IHNetApplicationProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetApplicationProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetApplicationProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetApplicationProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetApplicationProtocol_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetApplicationProtocol_SetName(This,pszwName)	\
    (This)->lpVtbl -> SetName(This,pszwName)

#define IHNetApplicationProtocol_GetOutgoingIPProtocol(This,pucProtocol)	\
    (This)->lpVtbl -> GetOutgoingIPProtocol(This,pucProtocol)

#define IHNetApplicationProtocol_SetOutgoingIPProtocol(This,ucProtocol)	\
    (This)->lpVtbl -> SetOutgoingIPProtocol(This,ucProtocol)

#define IHNetApplicationProtocol_GetOutgoingPort(This,pusPort)	\
    (This)->lpVtbl -> GetOutgoingPort(This,pusPort)

#define IHNetApplicationProtocol_SetOutgoingPort(This,usPort)	\
    (This)->lpVtbl -> SetOutgoingPort(This,usPort)

#define IHNetApplicationProtocol_GetResponseRanges(This,puscResponses,prgResponseRange)	\
    (This)->lpVtbl -> GetResponseRanges(This,puscResponses,prgResponseRange)

#define IHNetApplicationProtocol_SetResponseRanges(This,uscResponses,rgResponseRange)	\
    (This)->lpVtbl -> SetResponseRanges(This,uscResponses,rgResponseRange)

#define IHNetApplicationProtocol_GetBuiltIn(This,pfBuiltIn)	\
    (This)->lpVtbl -> GetBuiltIn(This,pfBuiltIn)

#define IHNetApplicationProtocol_GetEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> GetEnabled(This,pfEnabled)

#define IHNetApplicationProtocol_SetEnabled(This,fEnable)	\
    (This)->lpVtbl -> SetEnabled(This,fEnable)

#define IHNetApplicationProtocol_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetName_Proxy( 
    IHNetApplicationProtocol * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetApplicationProtocol_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetName_Proxy( 
    IHNetApplicationProtocol * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetApplicationProtocol_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetOutgoingIPProtocol_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ UCHAR *pucProtocol);


void __RPC_STUB IHNetApplicationProtocol_GetOutgoingIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetOutgoingIPProtocol_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ UCHAR ucProtocol);


void __RPC_STUB IHNetApplicationProtocol_SetOutgoingIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetOutgoingPort_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetApplicationProtocol_GetOutgoingPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetOutgoingPort_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetApplicationProtocol_SetOutgoingPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetResponseRanges_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ USHORT *puscResponses,
    /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]);


void __RPC_STUB IHNetApplicationProtocol_GetResponseRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetResponseRanges_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ USHORT uscResponses,
    /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]);


void __RPC_STUB IHNetApplicationProtocol_SetResponseRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetBuiltIn_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ BOOLEAN *pfBuiltIn);


void __RPC_STUB IHNetApplicationProtocol_GetBuiltIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetEnabled_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ BOOLEAN *pfEnabled);


void __RPC_STUB IHNetApplicationProtocol_GetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetEnabled_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ BOOLEAN fEnable);


void __RPC_STUB IHNetApplicationProtocol_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_Delete_Proxy( 
    IHNetApplicationProtocol * This);


void __RPC_STUB IHNetApplicationProtocol_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetApplicationProtocol_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetBridges_INTERFACE_DEFINED__
#define __IEnumHNetBridges_INTERFACE_DEFINED__

/* interface IEnumHNetBridges */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetBridges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B77-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetBridges : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridge **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetBridges **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetBridgesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetBridges * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetBridges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetBridges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetBridges * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridge **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetBridges * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetBridges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetBridges * This,
            /* [out] */ IEnumHNetBridges **ppEnum);
        
        END_INTERFACE
    } IEnumHNetBridgesVtbl;

    interface IEnumHNetBridges
    {
        CONST_VTBL struct IEnumHNetBridgesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetBridges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetBridges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetBridges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetBridges_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetBridges_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetBridges_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetBridges_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Next_Proxy( 
    IEnumHNetBridges * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetBridge **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetBridges_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Skip_Proxy( 
    IEnumHNetBridges * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetBridges_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Reset_Proxy( 
    IEnumHNetBridges * This);


void __RPC_STUB IEnumHNetBridges_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Clone_Proxy( 
    IEnumHNetBridges * This,
    /* [out] */ IEnumHNetBridges **ppEnum);


void __RPC_STUB IEnumHNetBridges_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetBridges_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__
#define __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__

/* interface IEnumHNetFirewalledConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetFirewalledConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B78-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetFirewalledConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetFirewalledConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetFirewalledConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetFirewalledConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetFirewalledConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetFirewalledConnections * This,
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetFirewalledConnectionsVtbl;

    interface IEnumHNetFirewalledConnections
    {
        CONST_VTBL struct IEnumHNetFirewalledConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetFirewalledConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetFirewalledConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetFirewalledConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetFirewalledConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetFirewalledConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetFirewalledConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetFirewalledConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Next_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetFirewalledConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Skip_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetFirewalledConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Reset_Proxy( 
    IEnumHNetFirewalledConnections * This);


void __RPC_STUB IEnumHNetFirewalledConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Clone_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [out] */ IEnumHNetFirewalledConnections **ppEnum);


void __RPC_STUB IEnumHNetFirewalledConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__
#define __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__

/* interface IEnumHNetIcsPublicConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetIcsPublicConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B79-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetIcsPublicConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetIcsPublicConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetIcsPublicConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetIcsPublicConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetIcsPublicConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetIcsPublicConnections * This,
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetIcsPublicConnectionsVtbl;

    interface IEnumHNetIcsPublicConnections
    {
        CONST_VTBL struct IEnumHNetIcsPublicConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetIcsPublicConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetIcsPublicConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetIcsPublicConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetIcsPublicConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetIcsPublicConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetIcsPublicConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetIcsPublicConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Next_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetIcsPublicConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Skip_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetIcsPublicConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Reset_Proxy( 
    IEnumHNetIcsPublicConnections * This);


void __RPC_STUB IEnumHNetIcsPublicConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Clone_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);


void __RPC_STUB IEnumHNetIcsPublicConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__
#define __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__

/* interface IEnumHNetIcsPrivateConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetIcsPrivateConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7A-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetIcsPrivateConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetIcsPrivateConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetIcsPrivateConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetIcsPrivateConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetIcsPrivateConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetIcsPrivateConnectionsVtbl;

    interface IEnumHNetIcsPrivateConnections
    {
        CONST_VTBL struct IEnumHNetIcsPrivateConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetIcsPrivateConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetIcsPrivateConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetIcsPrivateConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetIcsPrivateConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetIcsPrivateConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetIcsPrivateConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetIcsPrivateConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Next_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Skip_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Reset_Proxy( 
    IEnumHNetIcsPrivateConnections * This);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Clone_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__
#define __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__

/* interface IEnumHNetApplicationProtocols */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetApplicationProtocols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7B-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetApplicationProtocols : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetApplicationProtocolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetApplicationProtocols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetApplicationProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetApplicationProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetApplicationProtocols * This,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum);
        
        END_INTERFACE
    } IEnumHNetApplicationProtocolsVtbl;

    interface IEnumHNetApplicationProtocols
    {
        CONST_VTBL struct IEnumHNetApplicationProtocolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetApplicationProtocols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetApplicationProtocols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetApplicationProtocols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetApplicationProtocols_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetApplicationProtocols_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetApplicationProtocols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetApplicationProtocols_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Next_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetApplicationProtocols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Skip_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetApplicationProtocols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Reset_Proxy( 
    IEnumHNetApplicationProtocols * This);


void __RPC_STUB IEnumHNetApplicationProtocols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Clone_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [out] */ IEnumHNetApplicationProtocols **ppEnum);


void __RPC_STUB IEnumHNetApplicationProtocols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__
#define __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__

/* interface IEnumHNetPortMappingProtocols */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetPortMappingProtocols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7C-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetPortMappingProtocols : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetPortMappingProtocolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetPortMappingProtocols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetPortMappingProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetPortMappingProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetPortMappingProtocols * This,
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);
        
        END_INTERFACE
    } IEnumHNetPortMappingProtocolsVtbl;

    interface IEnumHNetPortMappingProtocols
    {
        CONST_VTBL struct IEnumHNetPortMappingProtocolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetPortMappingProtocols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetPortMappingProtocols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetPortMappingProtocols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetPortMappingProtocols_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetPortMappingProtocols_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetPortMappingProtocols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetPortMappingProtocols_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Next_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetPortMappingProtocols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Skip_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetPortMappingProtocols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Reset_Proxy( 
    IEnumHNetPortMappingProtocols * This);


void __RPC_STUB IEnumHNetPortMappingProtocols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Clone_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);


void __RPC_STUB IEnumHNetPortMappingProtocols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__
#define __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__

/* interface IEnumHNetPortMappingBindings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetPortMappingBindings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B81-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetPortMappingBindings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetPortMappingBindingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetPortMappingBindings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetPortMappingBindings * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetPortMappingBindings * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetPortMappingBindings * This,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        END_INTERFACE
    } IEnumHNetPortMappingBindingsVtbl;

    interface IEnumHNetPortMappingBindings
    {
        CONST_VTBL struct IEnumHNetPortMappingBindingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetPortMappingBindings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetPortMappingBindings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetPortMappingBindings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetPortMappingBindings_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetPortMappingBindings_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetPortMappingBindings_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetPortMappingBindings_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Next_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetPortMappingBindings_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Skip_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetPortMappingBindings_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Reset_Proxy( 
    IEnumHNetPortMappingBindings * This);


void __RPC_STUB IEnumHNetPortMappingBindings_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Clone_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IEnumHNetPortMappingBindings_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetBridgedConnections_INTERFACE_DEFINED__
#define __IEnumHNetBridgedConnections_INTERFACE_DEFINED__

/* interface IEnumHNetBridgedConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetBridgedConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7D-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetBridgedConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetBridgedConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetBridgedConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetBridgedConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetBridgedConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetBridgedConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetBridgedConnections * This,
            /* [out] */ IEnumHNetBridgedConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetBridgedConnectionsVtbl;

    interface IEnumHNetBridgedConnections
    {
        CONST_VTBL struct IEnumHNetBridgedConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetBridgedConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetBridgedConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetBridgedConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetBridgedConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetBridgedConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetBridgedConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetBridgedConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Next_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetBridgedConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Skip_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetBridgedConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Reset_Proxy( 
    IEnumHNetBridgedConnections * This);


void __RPC_STUB IEnumHNetBridgedConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Clone_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [out] */ IEnumHNetBridgedConnections **ppEnum);


void __RPC_STUB IEnumHNetBridgedConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetBridgedConnections_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0178 */
/* [local] */ 

#ifndef NOTIFYFORMATBUFFERSIZE
#define NOTIFYFORMATBUFFERSIZE 1024
#endif
#ifndef HNWCALLBACKBUFFERSIZE
#define HNWCALLBACKBUFFERSIZE 1024
#endif
typedef VOID (STDMETHODCALLTYPE HNWCALLBACK)(LPCWSTR pszLogEntry, LPARAM lParam);
typedef HNWCALLBACK *LPHNWCALLBACK;
HRESULT APIENTRY
HNetGetShareAndBridgeSettings(
    OUT INetConnection  **ppNetPublicConnection,
    OUT INetConnection ***ppNetPrivateConnection,
    OUT BOOLEAN          *pbSharePublicConnection,
    OUT BOOLEAN          *pbFirewallPublicConnection
    );
HRESULT APIENTRY
HNetSetShareAndBridgeSettings(
    IN  INetConnection  *pNetPublicConnection,
    IN  INetConnection  *pNetPrivateConnection[],
    IN  BOOLEAN          bSharePublicConnection,
    IN  BOOLEAN          bFirewallPublicConnection,
    IN  LPHNWCALLBACK    lpHnwCallback,
    IN  LPARAM           lpContext,
    OUT INetConnection **pNetPrivateInterface
    );
typedef HRESULT (APIENTRY *LPFNHNETSETSHAREANDBRIDGESETTINGS)(
    INetConnection  *pNetPublicConnection,
    INetConnection  *pNetPrivateConnection[],
    BOOLEAN          bSharePublicConnection,
    BOOLEAN          bFirewallPublicConnection,
    LPHNWCALLBACK    lpHnwCallback,
    LPARAM           lpContext,
    INetConnection **pNetPrivateInterface );
HRESULT APIENTRY
ObtainIcsErrorConditions(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext );
BOOL APIENTRY
HNetSharedAccessSettingsDlg(
    IN  BOOL fSharedAccessMode,
    IN  HWND hwndOwner );
BOOL APIENTRY
HNetSharingAndFirewallSettingsDlg(
    IN HWND             hwndOwner,
    IN IHNetCfgMgr      *pHNetCfgMgr,
    IN BOOL             fShowFwOnlySettings,
    IN OPTIONAL IHNetConnection  *pHNetConn);


extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0178_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0178_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\msgrutil.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgrutil.h

Abstract:

    Header file for the following helper routines found in the msgrutil.c
    module of netlib.

        NetpNetBiosAddName
        NetpNetBiosDelName
        NetpNetBiosGetAdapterNumbers
        NetpNetBiosCall
        NetpNetBiosHangup
        NetpNetBiosReceive
        NetpNetBiosSend
        NetpStringToNetBiosName
        NetpNetBiosStatusToApiStatus

Authors:

    Rita Wong (ritaw) 26-July-1991

Revision History:

--*/

#define MESSAGE_ALIAS_TYPE             0x03
#define WKSTA_TO_MESSAGE_ALIAS_TYPE    0x01

typedef struct _NB30_ADAPTER_STATUS {
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER Names[16];
} NB30_ADAPTER_STATUS, *PNB30_ADAPTER_STATUS;

NET_API_STATUS
NetpNetBiosReset(
    IN  UCHAR LanAdapterNumber
    );

NET_API_STATUS
NetpNetBiosAddName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber,
    OUT PUCHAR NetBiosNameNumber OPTIONAL
    );

NET_API_STATUS
NetpNetBiosDelName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber
    );

NET_API_STATUS
NetpNetBiosGetAdapterNumbers(
    OUT PLANA_ENUM LanAdapterBuffer,
    IN  WORD LanAdapterBufferSize
    );

NET_API_STATUS
NetpNetBiosCall(
    IN  UCHAR LanAdapterNumber,
    IN  LPTSTR NameToCall,
    IN  LPTSTR Sender,
    OUT UCHAR *SessionNumber
    );

NET_API_STATUS
NetpNetBiosHangup(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber
    );

NET_API_STATUS
NetpNetBiosSend(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  PCHAR SendBuffer,
    IN  WORD SendBufferSize
    );

NET_API_STATUS
NetpNetBiosReceive(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    OUT PUCHAR ReceiveBuffer,
    IN  WORD ReceiveBufferSize,
    IN  HANDLE EventHandle,
    OUT WORD *NumberOfBytesReceived
    );

NET_API_STATUS
NetpStringToNetBiosName(
    OUT PCHAR NetBiosName,
    IN  LPTSTR String,
    IN  DWORD CanonicalizeType,
    IN  WORD Type
    );

NET_API_STATUS
NetpNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    );

int
NetpSmbCheck(
    IN LPBYTE  buffer,     // Buffer containing SMB
    IN USHORT  size,       // size of SMB buffer (in bytes)
    IN UCHAR   func,       // Function code
    IN int     parms,      // Parameter count
    IN LPSTR   fields      // Buffer fields dope vector
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef LLINFO_INCLUDED
#define LLINFO_INCLUDED

#include <ipifcons.h>

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define IF_MIB_STATS_ID     1
#define IF_FRIENDLY_NAME_ID 2

#define MAX_PHYSADDR_SIZE   8

typedef struct IPNetToMediaEntry {
    ulong           inme_index;
    ulong           inme_physaddrlen;
    uchar           inme_physaddr[MAX_PHYSADDR_SIZE];
    ulong           inme_addr;
    ulong           inme_type;
} IPNetToMediaEntry;

#define INME_TYPE_OTHER         1
#define INME_TYPE_INVALID       2
#define INME_TYPE_DYNAMIC       3
#define INME_TYPE_STATIC        4

#define MAX_IFDESCR_LEN         256

#define IFE_FIXED_SIZE  offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
    ulong           if_index;
    ulong           if_type;
    ulong           if_mtu;
    ulong           if_speed;
    ulong           if_physaddrlen;
    uchar           if_physaddr[MAX_PHYSADDR_SIZE];
    ulong           if_adminstatus;
    ulong           if_operstatus;
    ulong           if_lastchange;
    ulong           if_inoctets;
    ulong           if_inucastpkts;
    ulong           if_innucastpkts;
    ulong           if_indiscards;
    ulong           if_inerrors;
    ulong           if_inunknownprotos;
    ulong           if_outoctets;
    ulong           if_outucastpkts;
    ulong           if_outnucastpkts;
    ulong           if_outdiscards;
    ulong           if_outerrors;
    ulong           if_outqlen;
    ulong           if_descrlen;
    uchar           if_descr[1];
} IFEntry;

//
// MIB-II interface status values.  The latest definition of these values 
// is in RFC 2863.  ifOperStatus can use all values.  ifAdminStatus only
// uses the first three values.
//
typedef enum {
    IF_STATUS_UP               = 1,
    IF_STATUS_DOWN             = 2,
    IF_STATUS_TESTING          = 3,
    IF_STATUS_UNKNOWN          = 4,
    IF_STATUS_DORMANT          = 5,
    IF_STATUS_NOT_PRESENT      = 6,
    IF_STATUS_LOWER_LAYER_DOWN = 7
} IF_STATUS_ENUM;


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\logonp.h ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    logonp.h

Abstract:

    Private Netlogon service routines useful by both the Netlogon service
    and others that pass mailslot messages to/from the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 7-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef _LOGONP_H_
#define _LOGONP_H_
#include <dsgetdc.h>    // PDS_DOMAIN_TRUSTSW

//
// Message versions returned from NetpLogonGetMessageVersion
//

#define LMUNKNOWN_MESSAGE   0  // No version tokens on end of message
#define LM20_MESSAGE        1  // Just LM 2.0 token on end of message
#define LMNT_MESSAGE        2  // LM 2.0 and LM NT token on end of message
#define LMUNKNOWNNT_MESSAGE 3  // LM 2.0 and LM NT token on end of
                                    // message, but the version is not
                                    // supported.
#define LMWFW_MESSAGE       4  // LM WFW token on end of message

//
// Define the token placed in the last two bytes of a LanMan 2.0 message
//

#define LM20_TOKENBYTE    0xFF

//
// Define the token placed in the last four bytes of a NT LanMan message
//  Notice that such a message is by definition a LanMan 2.0 message
//

#define LMNT_TOKENBYTE    0xFF

//
// Define the token placed in the next to last byte of the PRIMARY_QUERY
// message from newer (8/8/94) WFW and Chicago clients.  This byte (followed
// by a LM20_TOKENBYTE) indicates the client is WAN-aware and sends the
// PRIMARY_QUERY to the DOMAIN<1B> name.  As such, BDC on the same subnet need
// not respond to this query.
//

#define LMWFW_TOKENBYTE   0xFE

//
//  Put the LANMAN NT token onto the end of a message.
//
//  The token is always followed by a LM 2.0 token so LM 2.0 systems will
//  think this message is from a LM 2.0 system.
//
//  Also append a version flag before the NT TOKEN so that the future
//  versions of software can handle the newer messages effectively.
//
//Arguments:
//
//  Where - Indirectly points to the current location in the buffer.  The
//      'String' is copied to the current location.  This current location is
//      updated to point to the byte following the token.
//
//  NtVersion - Additional version information to be or'ed into the NtVersion
//      field of the message.

#define NetpLogonPutNtToken( _Where, _NtVersion ) \
{ \
    SmbPutUlong( (*_Where), NETLOGON_NT_VERSION_1 | (_NtVersion) ); \
    (*_Where) += sizeof(ULONG); \
    *((PUCHAR)((*_Where)++)) = LMNT_TOKENBYTE; \
    *((PUCHAR)((*_Where)++)) = LMNT_TOKENBYTE; \
    NetpLogonPutLM20Token( _Where ); \
}

//
//  Put the LANMAN 2.0 token onto the end of a message.
//
//Arguments:
//
//  Where - Indirectly points to the current location in the buffer.  The
//      'String' is copied to the current location.  This current location is
//      updated to point to the byte following the token.

#define NetpLogonPutLM20Token( _Where ) \
{ \
    *((PUCHAR)((*_Where)++)) = LM20_TOKENBYTE; \
    *((PUCHAR)((*_Where)++)) = LM20_TOKENBYTE; \
}

#define NetpLogonPutGuid( _Guid, _Where ) \
            NetpLogonPutBytes( (_Guid), sizeof(GUID), _Where )

#define NetpLogonGetGuid( _Message, _MessageSize, _Where, _Guid ) \
            NetpLogonGetBytes( \
                (_Message),    \
                (_MessageSize),\
                (_Where),      \
                sizeof(GUID),  \
                (_Guid) )



//
// Name of binary Forest Trust List file
//
#define NL_FOREST_BINARY_LOG_FILE L"\\system32\\config\\netlogon.ftl"
#define NL_FOREST_BINARY_LOG_FILE_JOIN L"\\system32\\config\\netlogon.ftj"

//
// Header for binary Forest Trust List file.
//

typedef struct _DS_DISK_TRUSTED_DOMAIN_HEADER {

    ULONG Version;

} DS_DISK_TRUSTED_DOMAIN_HEADER, *PDS_DISK_TRUSTED_DOMAIN_HEADER;

#define DS_DISK_TRUSTED_DOMAIN_VERSION   1

//
// Entry for binary Forest Trust List file.
//
typedef struct _PDS_DISK_TRUSTED_DOMAIN {

    //
    // Size of entire entry
    //

    ULONG EntrySize;

    //
    // Name of the trusted domain.
    //
    ULONG NetbiosDomainNameSize;
    ULONG DnsDomainNameSize;


    //
    // Flags defining attributes of the trust.
    //
    ULONG Flags;

    //
    // Index to the domain that is the parent of this domain.
    //  Only defined if NETLOGON_DOMAIN_IN_FOREST is set and
    //      NETLOGON_DOMAIN_TREE_ROOT is not set.
    //
    ULONG ParentIndex;

    //
    // The trust type and attributes of this trust.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  these value are infered.
    //
    ULONG TrustType;
    ULONG TrustAttributes;

    //
    // The SID of the trusted domain.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  this value will be NULL.
    //
    ULONG DomainSidSize;

    //
    // The GUID of the trusted domain.
    //

    GUID DomainGuid;

} DS_DISK_TRUSTED_DOMAINS, *PDS_DISK_TRUSTED_DOMAINS;

//
// Procedure forwards from logonp.c
//

VOID
NetpLogonPutOemString(
    IN LPSTR String,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    );

VOID
NetpLogonPutUnicodeString(
    IN LPWSTR String,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    );

VOID
NetpLogonPutBytes(
    IN LPVOID Data,
    IN DWORD Size,
    IN OUT PCHAR * Where
    );

DWORD
NetpLogonGetMessageVersion(
    IN PVOID Message,
    IN PDWORD MessageSize,
    OUT PULONG Version
    );

BOOL
NetpLogonGetOemString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringLength,
    OUT LPSTR *String
    );

BOOL
NetpLogonGetUnicodeString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringSize,
    OUT LPWSTR *String
    );

BOOL
NetpLogonGetBytes(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD DataSize,
    OUT LPVOID Data
    );

BOOL
NetpLogonGetDBInfo(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    OUT PDB_CHANGE_INFO Data
);

LPWSTR
NetpLogonOemToUnicode(
    IN LPSTR Ansi
    );

LPSTR
NetpLogonUnicodeToOem(
    IN LPWSTR Unicode
    );

NET_API_STATUS
NetpLogonWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );

//
// Define the largest message returned by a mailslot created by
// NetpLogonCreateRandomMailslot().  The 64 byte value allows expansion
// of the messages in the future.
//
#define MAX_RANDOM_MAILSLOT_RESPONSE (max(sizeof(NETLOGON_LOGON_RESPONSE), sizeof(NETLOGON_PRIMARY)) + 64 )

NET_API_STATUS
NetpLogonCreateRandomMailslot(
    IN LPSTR path,
    OUT PHANDLE MsHandle
    );

VOID
NetpLogonPutDomainSID(
    IN PCHAR Sid,
    IN DWORD SidLength,
    IN OUT PCHAR * Where
    );

BOOL
NetpLogonGetDomainSID(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD SIDSize,
    OUT PCHAR *Sid
    );

BOOLEAN
NetpLogonTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN DWORD Timeout
    );

NET_API_STATUS
NlWriteBinaryLog(
    IN LPWSTR FileSuffix,
    IN LPBYTE Buffer,
    IN ULONG BufferSize
    );

NET_API_STATUS
NlWriteFileForestTrustList (
    IN LPWSTR FileSuffix,
    IN PDS_DOMAIN_TRUSTSW ForestTrustList,
    IN ULONG ForestTrustListCount
    );

#endif // _LOGONP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\mpr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mpr.h

Abstract:

    Standard MPR Header File for NT-WIN32

Author:

    John Ludeman (Johnl)    10-Dec-1991

Environment:

    User Mode -Win32

Notes:

    This is a private header file specific to the multiple provider and
    the windows shell.

Revision History:

    10-Dec-1991     Johnl
    Created

    13-Jan-1992     Johnl
    Moved return codes specific to WNetRestoreConnection from winnet32.h
        to here.

    24-Jan-1992     Johnl
    Added additional APIs for support of Filemanager's toolbar

    19-Mar-1992     JohnL
    Added WNetNukeConnections

    12-May-1992     Johnl
    Removed "I_" from I_WNetConnect/DisconnectDialog,
    Added WNNC_DLG_Disconnect and WNNC_DLG_Connect manifests

    05-Aug-1992     AlbertT
        Added extra BOOL bFlushCache to WNetGetDirectoryType{A,W}

    26-Aug-1992     Johnl
    Renamed WNetNukeConnections to WNetClearConnections

    Nov-5-1992      CongpaY
        Add structures _CONNECT_INFO, PARAMETERS, ERRORDLGPARAMETERS
        and functions DoPassordDialog, DoProfileErrorDialog
        and ShowReconnectDialog. They are used by restoring connection.

    07-Nov-1992     ChuckC
        Added WNetDisconnectDialog2 and WNetConnectionDialog2 for help
        support.

    12-Nov-1992     Yi-HsinS
        Added WNetBrowsePrinterDialog, WNetBrowseDialog

    20-Dec-1992     Yi-HsinS
        Added WNetGetFormatNameProc

    29-Dec-1992     Johnl
        Added WNetGetConnection2

    07-Jan-1993     Danl
        Added Credential Management API

    29-Jun-1994     JonN
        Added parameter to DoProfileErrorDialog

    23-Mar-1995     AnirudhS
        Added WNFMT_* manifests

    12-Jul-1995     Anirudhs
        Removed things defined in winnetwk.h and winnetp.h

    21-Feb-1997     AnirudhS
        Added I_MprSaveConn for use by setup (Win95->NT upgrade)

--*/
#include <lmcons.h>
#include <wincred.h>
#ifndef _MPR_H_INCLUDED
#define _MPR_H_INCLUDED

//For restoring connection stuff. Add by congpay.
// const used by connect.c
#define SHOW_CONNECTION     (WM_USER+200)
#define DO_PASSWORD_DIALOG  (WM_USER + 201)
#define DO_ERROR_DIALOG     (WM_USER + 202)

// Used by I_MprSaveConn
#define DEFER_EXPLICIT_PASSWORD         0x00000001
#define DEFER_UNKNOWN                   0x00000002
#define DEFER_DEFAULT_CRED              0x00000004

// Errors that can be repaired by popping up a
// username/password dialog

#define IS_USERNAME_PASSWORD_ERROR(x)     \
        CREDUI_IS_AUTHENTICATION_ERROR(x)

// types used by connect.c

typedef struct _CONNECTION_INFO *LPCONNECTION_INFO;

// The following two structures are used by two threads in mpr.dll and
// mprui.dll to share data.

typedef struct _PARAMETERS
{
    HWND       hDlg;
    HANDLE     hDlgCreated;                // Initialized in WNetRestoreConnection
    HANDLE     hDlgFailed;                 // Initialized in WNetRestoreConnection
    HANDLE     hDonePassword;              // Initialized in WNetRestoreConnection
    TCHAR *    pchResource;                // ShowReconnectDialog, DoRestoreConnection
    TCHAR *    pchUserName;                // For DoPasswordDialog
    TCHAR      passwordBuffer[UNLEN+1];    // Used by WNetRestoreThisConnection
    BOOL       fSuccess;                   // For the DoPasswordDialog
    BOOL       fDidCancel;                 // For the DoPasswordDialog
    DWORD      dwError;                    // Error from the connection attempt
    LONG       fDoCleanup;                 // TRUE if the current thread should clean up
    HINSTANCE  hDll;                       // Handle to mpr.dll to prevent unload
    DWORD      status;                     // return value from DoRestoreConnection
    DWORD      numSubKeys;                 // Initialized in WNetRestoreConnection
    DWORD      RegMaxWait;
    LPCONNECTION_INFO ConnectArray;        // Initialized in WNetRestoreConnection
    DWORD      dwRestoreFlags;             // WNRC_ flags - modify the behavior of WNetRestoreConnection
    BOOL       fReconnectFailed;           // set to TRUE if any reconnect fails
}
PARAMETERS;

#ifdef __cplusplus
extern "C" {
#endif

//function load from mprui.dll.

DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    DWORD         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    );

DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel, // ask whether to stop reconnecting devices
                                //  this time?
    BOOL *        pfDidCancel,  // stop reconnecting devices this time?
                                //  active iff fAllowCancel
    BOOL *        pfDisconnect, // do not reconnect this device in future?
    BOOL *        pfHideErrors  // stop displaying error dialogs this time?
                                //  active iff fAllowCancel
    );

DWORD
MPRUI_ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS *  Params
    );

//
// Return codes from WNetRestoreConnection
//
#define WN_CONTINUE     0x00000BB9

DWORD APIENTRY
RestoreConnectionA0(
    HWND    hWnd,
    LPSTR  lpDevice
    );

DWORD APIENTRY
MPRUI_WNetClearConnections(
     HWND    hWnd
     );

DWORD
MPRUI_WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD
MPRUI_WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );

DWORD
MPRUI_WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD
MPRUI_WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    );


//
// Authentication Provider (Credential Management) Functions
//

DWORD APIENTRY
WNetLogonNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    );

typedef DWORD
(APIENTRY *PF_WNetLogonNotify) (
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    );

DWORD APIENTRY
WNetPasswordChangeNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    );

//
// Directory functions
//
DWORD
WNetGetDirectoryTypeA (
    LPSTR   lpName,
    LPINT   lpType,
    BOOL    bFlushCache
    );

DWORD
WNetGetDirectoryTypeW (
    LPTSTR  lpName,
    LPINT   lpType,
    BOOL    bFlushCache
    );

#ifdef UNICODE
#define WNetGetDirectoryType   WNetGetDirectoryTypeW
#else
#define WNetGetDirectoryType   WNetGetDirectoryTypeA
#endif  // UNICODE


DWORD
WNetDirectoryNotifyA (
    HWND    hwnd,
    LPSTR   lpDir,
    DWORD   dwOper
    );

DWORD
WNetDirectoryNotifyW (
    HWND    hwnd,
    LPTSTR  lpDir,
    DWORD   dwOper
    );

#ifdef UNICODE
#define WNetDirectoryNotify   WNetDirectoryNotifyW
#else
#define WNetDirectoryNotify   WNetDirectoryNotifyA
#endif  // UNICODE


DWORD
WNetPropertyDialogA (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    DWORD nType
    );

DWORD
WNetPropertyDialogW (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPTSTR lpszName,
    DWORD nType
    );

#ifdef UNICODE
#define WNetPropertyDialog    WNetPropertyDialogW
#else
#define WNetPropertyDialog    WNetPropertyDialogA
#endif  // UNICODE


DWORD
WNetGetPropertyTextA (
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    LPSTR lpszButtonName,
    DWORD nButtonNameLength,
    DWORD nType
    );

DWORD
WNetGetPropertyTextW (
    DWORD  iButton,
    DWORD  nPropSel,
    LPTSTR lpszName,
    LPTSTR lpszButtonName,
    DWORD  nButtonNameLength,
    DWORD  nType
    );

#ifdef UNICODE
#define WNetGetPropertyText   WNetGetPropertyTextW
#else
#define WNetGetPropertyText   WNetGetPropertyTextA
#endif  // UNICODE

typedef struct _WNET_CONNECTINFOA
{
    LPSTR lpRemoteName ;
    LPSTR lpProvider ;
} WNET_CONNECTIONINFOA, *LPWNET_CONNECTIONINFOA ;

typedef struct _WNET_CONNECTINFOW
{
    LPWSTR lpRemoteName ;
    LPWSTR lpProvider ;
} WNET_CONNECTIONINFOW, *LPWNET_CONNECTIONINFOW ;

#ifdef UNICODE
#define WNET_CONNECTIONINFO   WNET_CONNECTIONINFOW
#define LPWNET_CONNECTIONINFO LPWNET_CONNECTIONINFOW
#else
#define WNET_CONNECTIONINFO WNET_CONNECTIONINFOA
#define LPWNET_CONNECTIONINFO LPWNET_CONNECTIONINFOA
#endif  // UNICODE

//
//  Used in conjunction with WNET_CONNECTIONINFO, gets the net provider name
//  in addition to the remote name for this connection.
//
DWORD
WNetGetConnection2A(
    LPSTR   lpLocalName,
    LPVOID  lpBuffer,       // Contains WNET_CONNECTIONINFOA struct
    LPDWORD lpBufferSize    // In bytes!
    ) ;

DWORD
WNetGetConnection2W(
    LPWSTR  lpLocalName,
    LPVOID  lpBuffer,       // Contains WNET_CONNECTIONINFOW struct
    LPDWORD lpBufferSize    // In bytes!
    ) ;

#ifdef UNICODE
#define WNetGetConnection2 WNetGetConnection2W
#else
#define WNetGetConnection2 WNetGetConnection2A
#endif  // UNICODE

//
// Used by winlogon to close all net connections at logoff
//
DWORD APIENTRY WNetClearConnections(HWND hWnd);

//
// This entry point is used by setup when converting a Win9x user hive to NT
//
DWORD
I_MprSaveConn(
    IN HKEY             HiveRoot,
    IN LPCWSTR          ProviderName,
    IN DWORD            ProviderType,
    IN LPCWSTR          UserName,
    IN LPCWSTR          LocalName,
    IN LPCWSTR          RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    );


//
// Browse dialog
//

// Type of the callback routine used by the browse dialog to validate
// the path input by the user
typedef BOOL (*PFUNC_VALIDATION_CALLBACK)( LPWSTR pszName );

//  WNetBrowseDialog and WNetBrowsePrinterDialog
//  NOTE: WNetBrowsePrintDialog =
//        WNetBrowseDialog with dwType RESOURCETYPE_PRINT
//
/*******************************************************************

    NAME:       WNetBrowseDialog, WNetBrowsePrinterDialog

    SYNOPSIS:   Presents a dialog to the user from which the user can
                browse the network for disk or print shares.

    ENTRY:      hwndParent  -  Parent window handle
                dwType      -  ( Only in WNetBrowseDialog )
                   RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpszName    -  The path name typed by the user. It will be
                               undefined if the user hits the CANCEL button.
                cchBufSize  -  The buffer size of the lpszName in characters
                lpszHelpFile-  The helpfile to use when the user hits F1.
                nHelpContext-  The helpcontext to use for the helpfile above
                pfuncValidation - Callback method to validate the path typed
                   by the user. If NULL, no validation will
                               be done.

    RETURNS:    WN_CANCEL when the user cancels the dialog. NO_ERROR
                on success, standard ERROR_* error code otherwise

    NOTES:      This is a UNICODE only API.

    HISTORY:
        Yi-HsinS    22-Nov-1992    Created

********************************************************************/

DWORD WNetBrowseDialog(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation );

DWORD WNetBrowsePrinterDialog(
    HWND    hwndParent,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation );

//
// stuff in user, not driver, for shell apps
//
DWORD APIENTRY WNetErrorText(DWORD,LPTSTR,DWORD);

//
// used by MPRUI.DLL to determine if a provider supports
// NpSearchDialog() and obtain to a pointer to it.
//
FARPROC WNetGetSearchDialog(LPWSTR lpProvider) ;

//
// used by MPRUI.DLL to determine if a provider supports
// NPFormatNetworkName() and obtain a pointer to it.
//
FARPROC WNetGetFormatNameProc(LPWSTR lpProvider) ;

//
// used by MPRUI.DLL to determine if a provider supports
// WNNC_ENUM_GLOBAL
//
BOOL WNetSupportGlobalEnum(LPWSTR lpProvider) ;

//
// used by ACLEDIT.DLL to get provider-specific permission editor
//

DWORD WNetFMXGetPermCaps( LPWSTR lpDriveName ) ;
DWORD WNetFMXEditPerm( LPWSTR lpDriveName, HWND hwndFMX, DWORD nDialogType );
DWORD WNetFMXGetPermHelp( LPWSTR  lpDriveName,
                          DWORD   nDialogType,
                          BOOL    fDirectory,
                          LPVOID  lpFileNameBuffer,
                          LPDWORD lpBufferSize,
                          LPDWORD lpnHelpContext );

//
// sections and keys used for persistent connections
//

#define WNNC_DLG_DISCONNECT     0x0008
#define WNNC_DLG_CONNECT        0x0004

#ifdef UNICODE

#define MPR_MRU_FILE_SECTION        L"NET_Files"
#define MPR_MRU_PRINT_SECTION       L"NET_Printers"
#define MPR_MRU_ORDER_KEY       L"Order"

#define MPR_NETWORK_SECTION     L"Network"
#define MPR_SAVECONNECTION_KEY      L"SaveConnections"
#define MPR_RESTORECONNECTION_KEY   L"RestoreConnections"
#define MPR_EXPANDLOGONDOMAIN_KEY       L"ExpandLogonDomain"

#define MPR_YES_VALUE           L"yes"
#define MPR_NO_VALUE            L"no"

#else

#define MPR_MRU_FILE_SECTION        "NET_Files"
#define MPR_MRU_PRINT_SECTION       "NET_Printers"
#define MPR_MRU_ORDER_KEY       "Order"

#define MPR_NETWORK_SECTION     "Network"
#define MPR_SAVECONNECTION_KEY      "SaveConnections"
#define MPR_RESTORECONNECTION_KEY   "RestoreConnections"
#define MPR_EXPANDLOGONDOMAIN_KEY       "ExpandLogonDomain"

#define MPR_YES_VALUE           "yes"
#define MPR_NO_VALUE            "no"

#endif  // UNICODE


//
// Internal NP interface used to help the NTLM provider remember
// whether a persistent connection is a DFS connection or not
//

DWORD APIENTRY
NPGetReconnectFlags (
       IN  LPWSTR   lpLocalName,
       OUT LPBYTE   lpPersistFlags
    );
typedef DWORD (*PF_NPGetReconnectFlags) (
       LPWSTR   lpLocalName,
       LPBYTE   lpPersistFlags
    );

// This macro operates on the dwFlags parameter of NPAddConnection3
#define CONNECT_PROVIDER_FLAGS(dwFlags)   ((BYTE) (((dwFlags) & 0xFF000000) >> 24))

#ifdef __cplusplus
}
#endif

#endif // _MPR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\nameser.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *	 /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *	@(#)nameser.h	5.3
 *
 *	Last delta created	14:06:04 3/4/91
 *	This file extracted	11:19:28 3/8/91
 *
 *	Modifications:
 *
 *		GSS	20 Jul 90	New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)nameser.h	5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ	512		/* maximum packet size */
#define MAXDNAME	256		/* maximum domain name */
#define MAXCDNAME	255		/* maximum compressed domain name */
#define MAXLABEL	63		/* maximum length of domain label */
	/* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ	4
	/* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ	10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT	53

/*
 * Currently defined opcodes
 */
#define QUERY		0x0		/* standard query */
#define IQUERY		0x1		/* inverse query */
#define STATUS		0x2		/* nameserver status query */
/*#define xxx		0x3		/* 0x3 reserved */
	/* non standard */
#define UPDATEA		0x9		/* add resource record */
#define UPDATED		0xa		/* delete a specific resource record */
#define UPDATEDA	0xb		/* delete all nemed resource record */
#define UPDATEM		0xc		/* modify a specific resource record */
#define UPDATEMA	0xd		/* modify all named resource record */

#define ZONEINIT	0xe		/* initial zone transfer */
#define ZONEREF		0xf		/* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR		0		/* no error */
#endif
#define FORMERR		1		/* format error */
#define SERVFAIL	2		/* server failure */
#define NXDOMAIN	3		/* non existent domain */
#define NOTIMP		4		/* not implemented */
#define REFUSED		5		/* query refused */
	/* non standard */
#define NOCHANGE	0xf		/* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A	        1		/* host address */
#define T_NS		2		/* authoritative server */
#define T_MD		3		/* mail destination */
#define T_MF		4		/* mail forwarder */
#define T_CNAME		5		/* connonical name */
#define T_SOA		6		/* start of authority zone */
#define T_MB		7		/* mailbox domain name */
#define T_MG		8		/* mail group member */
#define T_MR		9		/* mail rename name */
#define T_NULL		10		/* null resource record */
#define T_WKS		11		/* well known service */
#define T_PTR		12		/* domain name pointer */
#define T_HINFO		13		/* host information */
#define T_MINFO		14		/* mailbox information */
#define T_MX		15		/* mail routing information */
#define T_TXT		16		/* text strings */
#define T_AFSDB		18		/* AFS database servers */
#define T_ATMA 		34		/* ATM endpoint address */
	/* non standard */
#define T_UINFO		100		/* user (finger) information */
#define T_UID		101		/* user ID */
#define T_GID		102		/* group ID */
#define T_UNSPEC	103		/* Unspecified format (binary data) */
	/* Query type values which do not appear in resource records */
#define T_AXFR		252		/* transfer zone of authority */
#define T_MAILB		253		/* transfer mailbox records */
#define T_MAILA		254		/* transfer mail agent records */
#define T_ANY		255		/* wildcard match */

/*
 * Values for class field
 */

#define C_IN		1		/* the arpa internet */
#define C_CHAOS		3		/* for chaos net at MIT */
#define C_HS		4		/* for Hesiod name server at MIT */
	/* Query class values which do not appear in resource records */
#define C_ANY		255		/* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax) */
#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER	LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#ifndef BYTE_ORDER		/* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_AMD64_) || defined(_IA64_)
#define BYTE_ORDER	LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
	/* you must determine what the correct bit order is for your compiler */
	UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
	unsigned short	id;		/* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
			/* fields in third byte */
	unsigned char	qr:1;		/* response flag */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	rd:1;		/* recursion desired */
			/* fields in fourth byte */
	unsigned char	ra:1;		/* recursion available */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	rcode:4;	/* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
			/* fields in third byte */
	unsigned char	rd:1;		/* recursion desired */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	qr:1;		/* response flag */
			/* fields in fourth byte */
	unsigned char	rcode:4;	/* response code */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	ra:1;		/* recursion available */
#endif
			/* remaining bytes */
	unsigned short	qdcount;	/* number of question entries */
	unsigned short	ancount;	/* number of answer entries */
	unsigned short	nscount;	/* number of authority entries */
	unsigned short	arcount;	/* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK	0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
	short	        r_zone;			/* zone number */
	short	        r_class;		/* class number */
	short	        r_type;			/* type number */
	unsigned long	r_ttl;			/* time to live */
	int	        r_size;			/* size of data area */
	char	       *r_data;		        /* pointer to data */
};

extern	unsigned short	_getshort();
extern	unsigned long	_getlong();

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
	(s) = *(cp)++ << 8; \
	(s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
	(l) = *(cp)++ << 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
	*(cp)++ = (s) >> 8; \
	*(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
	(cp)[3] = l; \
	(cp)[2] = (l >>= 8); \
	(cp)[1] = (l >>= 8); \
	(cp)[0] = l >> 8; \
	(cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\nb30p.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nb30p.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 09-Dec-1991

Revision History:

--*/


#ifndef _NB30P_
#define _NB30P_

#define NB_DEVICE_NAME      L"\\Device\\Netbios" // name of our driver.
#define	NB_REGISTRY_STRING	L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Netbios"
//
//  private IOCTLs used by the Netbios routine in the dll to communicate with
//  \Device\Netbios
//

#define IOCTL_NB_BASE FILE_DEVICE_TRANSPORT

#define _NB_CONTROL_CODE(request, method) \
    CTL_CODE(IOCTL_NB_BASE, request, method, FILE_ANY_ACCESS)

#define IOCTL_NB_NCB            _NB_CONTROL_CODE(20, METHOD_NEITHER)
#define IOCTL_NB_REGISTER_STOP  _NB_CONTROL_CODE(21, METHOD_NEITHER)
#define IOCTL_NB_STOP           _NB_CONTROL_CODE(22, METHOD_NEITHER)
#define IOCTL_NB_REGISTER_RESET _NB_CONTROL_CODE(23, METHOD_BUFFERED)

//
// MessageId: STATUS_HANGUP_REQUIRED
//
// MessageText:
//
//  Warning error for the Netbios driver to the Netbios dll. When receiving this
//  status on an NCB completion, the dll will hangup the connection causing the
//  connection block to be deleted. This status will never be returned to a user
//  application.
//
#define STATUS_HANGUP_REQUIRED           ((NTSTATUS)0x80010001L)

//
//  Private extension for XNS to support vtp.exe
//

#define NCALLNIU            0x74    /* UB special */

//
//  Private extension to support AsyBEUI
//

#define NCBQUICKADDNAME     0x75
#define NCBQUICKADDGRNAME   0x76

//  Values for transport_id in ACTION_HEADER

#define MS_ABF          "MABF"
#define MS_XNS          "MXNS"

#endif // _NB30P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\msgtext.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    apperr.h

Abstract:

    This file contains the number and text of miscellaneous error
    messages.

Author:

    Cliff Van Dyke (CliffV) 4-Nov-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/


#define MTXT_BASE 3300


/**INTERNAL_ONLY**/

/*** WARNING *** WARNING *** WARNING ****
 *                                      *
 * The redirector has hardcoded in its  *
 * makefile some message numbers used   *
 * at startup.  If you change MTXT_BASE *
 * or any of the redirs message numbers *
 * you must also fix the redir makefile *
 * where it generates netwksta.pro      *
 *                                      *
 ****************************************/

/************* WARNING ***************
 * See the comment in netcons.h for  *
 * info on the allocation of errors  *
 *************************************/

/**END_INTERNAL**/

/*  Share remarks, must be <= MAXCOMMENTSZ bytes.
 */

#define MTXT_IPC_SHARE_REMARK       MTXT_BASE+1   /* @I Remote IPC %0 */
#define MTXT_ADMIN_SHARE_REMARK     MTXT_BASE+2   /* @I Remote Admin %0 */
#define MTXT_LOGON_SRV_SHARE_REMARK MTXT_BASE+3   /* @I Logon server share %0 */


#define MTXT_WKSTA_ERR_POPUP_HDR MTXT_BASE+4    /* @I A network error occurred. %0 */

/* NetWksta installation messages.
 */

#define MTXT_MemAllocMsg        (MTXT_BASE+100) /* There is not enough memory to start the Workstation service. */
#define MTXT_IniFilRdErr        (MTXT_BASE+101) /* An error occurred when reading the NETWORKS entry in the LANMAN.INI file. */
#define MTXT_BadArgMsg          (MTXT_BASE+102) /* This is an invalid argument: %1. */
#define MTXT_BadNetEntHdr    (MTXT_BASE+103) /* @W The %1 NETWORKS entry in the LANMAN.INI file has a
     * syntax error and will be ignored.
     */
#define MTXT_MultNetsMsg        (MTXT_BASE+104) /* There are too many NETWORKS entries in the LANMAN.INI file. */
/* UNUSED            (MTXT_BASE+105) */
#define MTXT_BadBiosMsg        (MTXT_BASE+106) /* @W An error occurred when opening network
     * device driver %1 = %2.
     */
#define MTXT_BadLinkMsg         (MTXT_BASE+107) /* @W Device driver %1 sent a bad BiosLinkage response.*/
#define MTXT_BadVerMsg          (MTXT_BASE+108) /* The program cannot be used with this operating system. */
#define MTXT_RdrInstMsg         (MTXT_BASE+109) /* The redirector is already installed. */
#define MTXT_Version        (MTXT_BASE+110) /* @I Installing NETWKSTA.SYS Version %1.%2.%3  (%4)
     *
     */
#define MTXT_RdrInstlErr    (MTXT_BASE+111) /* There was an error installing NETWKSTA.SYS.
     *
     * Press ENTER to continue.
     */
#define MTXT_BadResolver    (MTXT_BASE+112) /* Resolver linkage problem. */

/*
 *    Forced Logoff error messages
 */

#define MTXT_Expiration_Warning (MTXT_BASE + 113) /* @I
     * Your logon time at %1 ends at %2.
     * Please clean up and log off.
     */

#define MTXT_Logoff_Warning (MTXT_BASE + 114) /* @I
     *
     * You will be automatically disconnected at %1.
     */

#define MTXT_Expiration_Message (MTXT_BASE + 115) /* @I
     * Your logon time at %1 has ended.
     */

#define MTXT_Past_Expiration_Message (MTXT_BASE + 116) /* @I
     * Your logon time at %1 ended at %2.
     */

#define MTXT_Immediate_Kickoff_Warning (MTXT_BASE + 117) /* @I
     * WARNING: You have until %1 to logoff. If you
     * have not logged off at this time, your session will be
     * disconnected, and any open files or devices you
     * have open may lose data.
     */

#define MTXT_Kickoff_Warning (MTXT_BASE + 118) /* @I
     * WARNING: You must log off at %1 now.  You have
     * two minutes to log off, or you will be disconnected.
     */

#define MTXT_Kickoff_File_Warning (MTXT_BASE + 119) /* @I
     *
     * You have open files or devices, and a forced
     * disconnection may cause you to lose data.
     */

/*  Servers default share remark */

#define MTXT_Svr_Default_Share_Remark (MTXT_BASE + 120) /* @I
     *Default Share for Internal Use %0*/

/* Messenger Service Message Box Title */
#define MTXT_MsgsvcTitle (MTXT_BASE + 121) /* @I
     *Messenger Service %0*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\mdhcsapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mdhcpapi.h

Abstract:

    This file contains the MDHCP APIs proto-type and description. Also
    contains the data structures used by the MDHCP APIs.

Author:

    Munil Shah  (munils)  01-Oct-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _MDHCSAPI_H_
#define _MDHCSAPI_H_

#if defined(MIDL_PASS)
#define LPWSTR [string] wchar_t *
#endif

typedef struct _DHCP_MSCOPE_INFO {
    LPWSTR MScopeName;
    LPWSTR MScopeComment;
    DWORD  MScopeId;
    DWORD  MScopeAddressPolicy;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE MScopeState;
    DWORD  MScopeFlags;
    DATE_TIME   ExpiryTime;
    LPWSTR  LangTag;
    BYTE    TTL;
} DHCP_MSCOPE_INFO, *LPDHCP_MSCOPE_INFO;

typedef struct _DHCP_MSCOPE_TABLE {
    DWORD NumElements;
#if defined( MIDL_PASS )
    [ size_is( NumElements ) ]
#endif;
    LPWSTR *pMScopeNames;         // scope name
} DHCP_MSCOPE_TABLE, *LPDHCP_MSCOPE_TABLE;

typedef struct _DHCP_MCLIENT_INFO {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DWORD   MScopeId;
    DHCP_CLIENT_UID ClientId;
    LPWSTR ClientName;                  // optional.
    DATE_TIME ClientLeaseStarts;       // UTC time in FILE_TIME format.
    DATE_TIME ClientLeaseEnds;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    DWORD   AddressFlags;
    BYTE    AddressState;
} DHCP_MCLIENT_INFO, *LPDHCP_MCLIENT_INFO;

typedef struct _DHCP_MCLIENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_MCLIENT_INFO *Clients; // array of pointers
} DHCP_MCLIENT_INFO_ARRAY, *LPDHCP_MCLIENT_INFO_ARRAY;

typedef struct _MSCOPE_MIB_INFO {
    DWORD MScopeId;
    LPWSTR MScopeName;
    DWORD NumAddressesInuse;
    DWORD NumAddressesFree;
    DWORD NumPendingOffers;
} MSCOPE_MIB_INFO, *LPMSCOPE_MIB_INFO;

typedef struct _DHCP_MCAST_MIB_INFO {
    DWORD Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Renews;
    DWORD Acks;
    DWORD Naks;
    DWORD Releases;
    DWORD Informs;
    DATE_TIME ServerStartTime;
    DWORD Scopes;
#if defined(MIDL_PASS)
    [size_is(Scopes)]
#endif // MIDL_PASS
    LPMSCOPE_MIB_INFO ScopeInfo; // array.
} DHCP_MCAST_MIB_INFO, *LPDHCP_MCAST_MIB_INFO;

// The APIs

#ifndef     DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpSetMScopeInfo(
    DHCP_CONST WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_MSCOPE_INFO MScopeInfo,
    BOOL NewScope
    );

DWORD DHCP_API_FUNCTION
DhcpGetMScopeInfo(
    DHCP_CONST WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_MSCOPE_INFO *MScopeInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopes(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpAddMScopeElement(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopeElements(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveMScopeElement(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteMScope(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpGetMClientInfo(
    WCHAR * ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_MCLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteMClientInfo(
    WCHAR * ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopeClients(
    WCHAR * ServerIpAddress,
    WCHAR * MScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpScanMDatabase(
    DHCP_CONST WCHAR *ServerIpAddress,
    WCHAR * MScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    );

DWORD DHCP_API_FUNCTION
DhcpGetMCastMibInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MibInfo
    );

#endif DHCPAPI_NO_PROTOTYPES
#endif _MDHCSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netbios.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netbios.h

Abstract:

    This is the include file for the component of netbios that allows
    the netbios initialization routine to be called during dll
    initialization and destruction.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

VOID
NetbiosInitialize(
    HMODULE hModule
    );

VOID
NetbiosDelete(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netcfgp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netcfgp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcfgp_h__
#define __netcfgp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IIpxAdapterInfo_FWD_DEFINED__
#define __IIpxAdapterInfo_FWD_DEFINED__
typedef interface IIpxAdapterInfo IIpxAdapterInfo;
#endif 	/* __IIpxAdapterInfo_FWD_DEFINED__ */


#ifndef __ITcpipProperties_FWD_DEFINED__
#define __ITcpipProperties_FWD_DEFINED__
typedef interface ITcpipProperties ITcpipProperties;
#endif 	/* __ITcpipProperties_FWD_DEFINED__ */


#ifndef __INetCfgInternalSetup_FWD_DEFINED__
#define __INetCfgInternalSetup_FWD_DEFINED__
typedef interface INetCfgInternalSetup INetCfgInternalSetup;
#endif 	/* __INetCfgInternalSetup_FWD_DEFINED__ */


#ifndef __INetCfgComponentPrivate_FWD_DEFINED__
#define __INetCfgComponentPrivate_FWD_DEFINED__
typedef interface INetCfgComponentPrivate INetCfgComponentPrivate;
#endif 	/* __INetCfgComponentPrivate_FWD_DEFINED__ */


#ifndef __INetInstallQueue_FWD_DEFINED__
#define __INetInstallQueue_FWD_DEFINED__
typedef interface INetInstallQueue INetInstallQueue;
#endif 	/* __INetInstallQueue_FWD_DEFINED__ */


#ifndef __INetCfgSpecialCase_FWD_DEFINED__
#define __INetCfgSpecialCase_FWD_DEFINED__
typedef interface INetCfgSpecialCase INetCfgSpecialCase;
#endif 	/* __INetCfgSpecialCase_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netcfgp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif
STDAPI
SvchostChangeSvchostGroup (
    LPCWSTR pszService,
    LPCWSTR pszNewGroup
    );








extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_s_ifspec;

#ifndef __IIpxAdapterInfo_INTERFACE_DEFINED__
#define __IIpxAdapterInfo_INTERFACE_DEFINED__

/* interface IIpxAdapterInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIpxAdapterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133270-4B20-11D1-AB01-00805FC1270E")
    IIpxAdapterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameTypesForAdapter( 
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD *anFrameTypes,
            /* [ref][out] */ DWORD *pcFrameTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualNetworkNumber( 
            /* [out] */ DWORD *pdwVNetworkNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualNetworkNumber( 
            /* [in] */ DWORD dwVNetworkNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIpxAdapterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIpxAdapterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIpxAdapterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIpxAdapterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameTypesForAdapter )( 
            IIpxAdapterInfo * This,
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD *anFrameTypes,
            /* [ref][out] */ DWORD *pcFrameTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualNetworkNumber )( 
            IIpxAdapterInfo * This,
            /* [out] */ DWORD *pdwVNetworkNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetVirtualNetworkNumber )( 
            IIpxAdapterInfo * This,
            /* [in] */ DWORD dwVNetworkNumber);
        
        END_INTERFACE
    } IIpxAdapterInfoVtbl;

    interface IIpxAdapterInfo
    {
        CONST_VTBL struct IIpxAdapterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIpxAdapterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIpxAdapterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIpxAdapterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIpxAdapterInfo_GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)	\
    (This)->lpVtbl -> GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)

#define IIpxAdapterInfo_GetVirtualNetworkNumber(This,pdwVNetworkNumber)	\
    (This)->lpVtbl -> GetVirtualNetworkNumber(This,pdwVNetworkNumber)

#define IIpxAdapterInfo_SetVirtualNetworkNumber(This,dwVNetworkNumber)	\
    (This)->lpVtbl -> SetVirtualNetworkNumber(This,dwVNetworkNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetFrameTypesForAdapter_Proxy( 
    IIpxAdapterInfo * This,
    /* [string][in] */ LPCWSTR pszwAdapterBindName,
    /* [in] */ DWORD cFrameTypesMax,
    /* [length_is][size_is][out] */ DWORD *anFrameTypes,
    /* [ref][out] */ DWORD *pcFrameTypes);


void __RPC_STUB IIpxAdapterInfo_GetFrameTypesForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo * This,
    /* [out] */ DWORD *pdwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_GetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_SetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo * This,
    /* [in] */ DWORD dwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_SetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIpxAdapterInfo_INTERFACE_DEFINED__ */


#ifndef __ITcpipProperties_INTERFACE_DEFINED__
#define __ITcpipProperties_INTERFACE_DEFINED__

/* interface ITcpipProperties */
/* [unique][uuid][object][local] */ 

typedef struct tagREMOTE_IPINFO
    {
    DWORD dwEnableDhcp;
    WCHAR *pszwIpAddrList;
    WCHAR *pszwSubnetMaskList;
    WCHAR *pszwOptionList;
    } 	REMOTE_IPINFO;


EXTERN_C const IID IID_ITcpipProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133271-4B20-11D1-AB01-00805FC1270E")
    ITcpipProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIpInfoForAdapter( 
            /* [in] */ const GUID *pguidAdapter,
            /* [out] */ REMOTE_IPINFO **ppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIpInfoForAdapter( 
            /* [in] */ const GUID *pguidAdapter,
            /* [in] */ REMOTE_IPINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITcpipPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITcpipProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITcpipProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITcpipProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIpInfoForAdapter )( 
            ITcpipProperties * This,
            /* [in] */ const GUID *pguidAdapter,
            /* [out] */ REMOTE_IPINFO **ppInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetIpInfoForAdapter )( 
            ITcpipProperties * This,
            /* [in] */ const GUID *pguidAdapter,
            /* [in] */ REMOTE_IPINFO *pInfo);
        
        END_INTERFACE
    } ITcpipPropertiesVtbl;

    interface ITcpipProperties
    {
        CONST_VTBL struct ITcpipPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITcpipProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITcpipProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITcpipProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITcpipProperties_GetIpInfoForAdapter(This,pguidAdapter,ppInfo)	\
    (This)->lpVtbl -> GetIpInfoForAdapter(This,pguidAdapter,ppInfo)

#define ITcpipProperties_SetIpInfoForAdapter(This,pguidAdapter,pInfo)	\
    (This)->lpVtbl -> SetIpInfoForAdapter(This,pguidAdapter,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITcpipProperties_GetIpInfoForAdapter_Proxy( 
    ITcpipProperties * This,
    /* [in] */ const GUID *pguidAdapter,
    /* [out] */ REMOTE_IPINFO **ppInfo);


void __RPC_STUB ITcpipProperties_GetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITcpipProperties_SetIpInfoForAdapter_Proxy( 
    ITcpipProperties * This,
    /* [in] */ const GUID *pguidAdapter,
    /* [in] */ REMOTE_IPINFO *pInfo);


void __RPC_STUB ITcpipProperties_SetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITcpipProperties_INTERFACE_DEFINED__ */


#ifndef __INetCfgInternalSetup_INTERFACE_DEFINED__
#define __INetCfgInternalSetup_INTERFACE_DEFINED__

/* interface INetCfgInternalSetup */
/* [unique][uuid][object][local] */ 

typedef 
enum tagCI_FILTER_COMPONENT
    {	FC_LAN	= 0,
	FC_RASSRV	= FC_LAN + 1,
	FC_RASCLI	= FC_RASSRV + 1,
	FC_ATM	= FC_RASCLI + 1
    } 	CI_FILTER_COMPONENT;

typedef struct tagCI_FILTER_INFO
    {
    CI_FILTER_COMPONENT eFilter;
    INetCfgComponent *pIComp;
    void *pvReserved;
    } 	CI_FILTER_INFO;


EXTERN_C const IID IID_INetCfgInternalSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133276-4B20-11D1-AB01-00805FC1270E")
    INetCfgInternalSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectWithFilterAndInstall( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID *pClassGuid,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ const CI_FILTER_INFO *pcfi,
            /* [out] */ INetCfgComponent **ppIComp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentInstalled( 
            /* [in] */ PVOID pComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentUpdated( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateNonEnumeratedComponent( 
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentRemoved( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgInternalSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgInternalSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgInternalSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginBatchOperation )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CommitBatchOperation )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectWithFilterAndInstall )( 
            INetCfgInternalSetup * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID *pClassGuid,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ const CI_FILTER_INFO *pcfi,
            /* [out] */ INetCfgComponent **ppIComp);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentInstalled )( 
            INetCfgInternalSetup * This,
            /* [in] */ PVOID pComponent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentUpdated )( 
            INetCfgInternalSetup * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateNonEnumeratedComponent )( 
            INetCfgInternalSetup * This,
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentRemoved )( 
            INetCfgInternalSetup * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        END_INTERFACE
    } INetCfgInternalSetupVtbl;

    interface INetCfgInternalSetup
    {
        CONST_VTBL struct INetCfgInternalSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgInternalSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgInternalSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgInternalSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgInternalSetup_BeginBatchOperation(This)	\
    (This)->lpVtbl -> BeginBatchOperation(This)

#define INetCfgInternalSetup_CommitBatchOperation(This)	\
    (This)->lpVtbl -> CommitBatchOperation(This)

#define INetCfgInternalSetup_SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)	\
    (This)->lpVtbl -> SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)

#define INetCfgInternalSetup_EnumeratedComponentInstalled(This,pComponent)	\
    (This)->lpVtbl -> EnumeratedComponentInstalled(This,pComponent)

#define INetCfgInternalSetup_EnumeratedComponentUpdated(This,pszPnpId)	\
    (This)->lpVtbl -> EnumeratedComponentUpdated(This,pszPnpId)

#define INetCfgInternalSetup_UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)	\
    (This)->lpVtbl -> UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)

#define INetCfgInternalSetup_EnumeratedComponentRemoved(This,pszPnpId)	\
    (This)->lpVtbl -> EnumeratedComponentRemoved(This,pszPnpId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_BeginBatchOperation_Proxy( 
    INetCfgInternalSetup * This);


void __RPC_STUB INetCfgInternalSetup_BeginBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_CommitBatchOperation_Proxy( 
    INetCfgInternalSetup * This);


void __RPC_STUB INetCfgInternalSetup_CommitBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_SelectWithFilterAndInstall_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const GUID *pClassGuid,
    /* [in] */ OBO_TOKEN *pOboToken,
    /* [in] */ const CI_FILTER_INFO *pcfi,
    /* [out] */ INetCfgComponent **ppIComp);


void __RPC_STUB INetCfgInternalSetup_SelectWithFilterAndInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentInstalled_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ PVOID pComponent);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentUpdated_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_UpdateNonEnumeratedComponent_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ INetCfgComponent *pIComp,
    /* [in] */ DWORD dwSetupFlags,
    /* [in] */ DWORD dwUpgradeFromBuildNo);


void __RPC_STUB INetCfgInternalSetup_UpdateNonEnumeratedComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentRemoved_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgInternalSetup_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentPrivate_INTERFACE_DEFINED__
#define __INetCfgComponentPrivate_INTERFACE_DEFINED__

/* interface INetCfgComponentPrivate */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133273-4B20-11D1-AB01-00805FC1270E")
    INetCfgComponentPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNotifyObject( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyUpperEdgeConfigChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNotifyObject )( 
            INetCfgComponentPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirty )( 
            INetCfgComponentPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyUpperEdgeConfigChange )( 
            INetCfgComponentPrivate * This);
        
        END_INTERFACE
    } INetCfgComponentPrivateVtbl;

    interface INetCfgComponentPrivate
    {
        CONST_VTBL struct INetCfgComponentPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentPrivate_QueryNotifyObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryNotifyObject(This,riid,ppvObject)

#define INetCfgComponentPrivate_SetDirty(This)	\
    (This)->lpVtbl -> SetDirty(This)

#define INetCfgComponentPrivate_NotifyUpperEdgeConfigChange(This)	\
    (This)->lpVtbl -> NotifyUpperEdgeConfigChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_QueryNotifyObject_Proxy( 
    INetCfgComponentPrivate * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB INetCfgComponentPrivate_QueryNotifyObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_SetDirty_Proxy( 
    INetCfgComponentPrivate * This);


void __RPC_STUB INetCfgComponentPrivate_SetDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Proxy( 
    INetCfgComponentPrivate * This);


void __RPC_STUB INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentPrivate_INTERFACE_DEFINED__ */


#ifndef __INetInstallQueue_INTERFACE_DEFINED__
#define __INetInstallQueue_INTERFACE_DEFINED__

/* interface INetInstallQueue */
/* [unique][uuid][object] */ 

typedef 
enum tagNC_INSTALL_TYPE
    {	NCI_INSTALL	= 0,
	NCI_UPDATE	= NCI_INSTALL + 1,
	NCI_REMOVE	= NCI_UPDATE + 1
    } 	NC_INSTALL_TYPE;

typedef struct NIQ_INFO
    {
    NC_INSTALL_TYPE eType;
    GUID ClassGuid;
    GUID InstanceGuid;
    DWORD dwCharacter;
    LPCWSTR pszPnpId;
    LPCWSTR pszInfId;
    DWORD dwDeipFlags;
    } 	NIQ_INFO;


EXTERN_C const IID IID_INetInstallQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133274-4B20-11D1-AB01-00805FC1270E")
    INetInstallQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ const NIQ_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessItems( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetInstallQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetInstallQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetInstallQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetInstallQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            INetInstallQueue * This,
            /* [in] */ const NIQ_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessItems )( 
            INetInstallQueue * This);
        
        END_INTERFACE
    } INetInstallQueueVtbl;

    interface INetInstallQueue
    {
        CONST_VTBL struct INetInstallQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetInstallQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetInstallQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetInstallQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetInstallQueue_AddItem(This,pInfo)	\
    (This)->lpVtbl -> AddItem(This,pInfo)

#define INetInstallQueue_ProcessItems(This)	\
    (This)->lpVtbl -> ProcessItems(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetInstallQueue_AddItem_Proxy( 
    INetInstallQueue * This,
    /* [in] */ const NIQ_INFO *pInfo);


void __RPC_STUB INetInstallQueue_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetInstallQueue_ProcessItems_Proxy( 
    INetInstallQueue * This);


void __RPC_STUB INetInstallQueue_ProcessItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetInstallQueue_INTERFACE_DEFINED__ */


#ifndef __INetCfgSpecialCase_INTERFACE_DEFINED__
#define __INetCfgSpecialCase_INTERFACE_DEFINED__

/* interface INetCfgSpecialCase */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgSpecialCase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE95-306E-11D1-AACF-00805FC1270E")
    INetCfgSpecialCase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapterOrder( 
            /* [out] */ DWORD *pcAdapters,
            /* [out] */ INetCfgComponent ***papAdapters,
            /* [out] */ BOOL *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdapterOrder( 
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent **apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWanAdaptersFirst( 
            /* [out] */ BOOL *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWanAdaptersFirst( 
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgSpecialCaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgSpecialCase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgSpecialCase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgSpecialCase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapterOrder )( 
            INetCfgSpecialCase * This,
            /* [out] */ DWORD *pcAdapters,
            /* [out] */ INetCfgComponent ***papAdapters,
            /* [out] */ BOOL *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdapterOrder )( 
            INetCfgSpecialCase * This,
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent **apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *GetWanAdaptersFirst )( 
            INetCfgSpecialCase * This,
            /* [out] */ BOOL *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *SetWanAdaptersFirst )( 
            INetCfgSpecialCase * This,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        END_INTERFACE
    } INetCfgSpecialCaseVtbl;

    interface INetCfgSpecialCase
    {
        CONST_VTBL struct INetCfgSpecialCaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgSpecialCase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgSpecialCase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgSpecialCase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgSpecialCase_GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)	\
    (This)->lpVtbl -> GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)	\
    (This)->lpVtbl -> SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)

#define INetCfgSpecialCase_GetWanAdaptersFirst(This,pfWanAdaptersFirst)	\
    (This)->lpVtbl -> GetWanAdaptersFirst(This,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetWanAdaptersFirst(This,fWanAdaptersFirst)	\
    (This)->lpVtbl -> SetWanAdaptersFirst(This,fWanAdaptersFirst)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetAdapterOrder_Proxy( 
    INetCfgSpecialCase * This,
    /* [out] */ DWORD *pcAdapters,
    /* [out] */ INetCfgComponent ***papAdapters,
    /* [out] */ BOOL *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetAdapterOrder_Proxy( 
    INetCfgSpecialCase * This,
    /* [in] */ DWORD cAdapters,
    /* [in] */ INetCfgComponent **apAdapters,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase * This,
    /* [out] */ BOOL *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase * This,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgSpecialCase_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netcan.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netcan.h

Abstract:

    Prototypes for internal (private) local canonicalization routines (Netpw)
    and client-side RPC functions (Netps)

Author:

    Richard L Firth (rfirth) 22-Jan-1992

Revision History:

--*/

//
// worker (Netpw) functions in NETLIB.LIB
//

NET_API_STATUS
NetpwPathType(
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwPathCanonicalize(
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NetpwPathCompare(
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwNameValidate(
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwNameCanonicalize(
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NetpwNameCompare(
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwListCanonicalize(
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    );

LPTSTR
NetpwListTraverse(
    IN  LPTSTR  Reserved,
    IN  LPTSTR* pList,
    IN  DWORD   Flags
    );

//
// stub (Netps) functions in SRVSVC.DLL
//

NET_API_STATUS
NetpsPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NetpsPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NetpsNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netlib.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    NetLib.h

Abstract:

    This header file declares various common routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 14-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windows.h> and <lmcons.h> before this file.

Revision History:

    14-Mar-1991 JohnRo
        Created.
    20-Mar-1991 JohnRo
        Moved NetpPackString here (was NetapipPackString).  Removed tabs.
    21-Mar-1991 RitaW
        Added NetpCopyStringToBuffer.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.
    03-Apr-1991 JohnRo
        Fixed types for NetpCopyStringToBuffer.
    08-Apr-1991 CliffV
        Added NetpCopyDataToBuffer
    10-Apr-1991 JohnRo
        Added NetpSetParmError (descended from CliffV's SetParmError).
    10-Apr-1991 Danl
        Added NetpGetComputerName
    24-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
        Added NetpAdjustPreferedMaximum().
        NetpCopyStringToBuffer's input string ptr is optional.
    26-Apr-1991 CliffV
        Added NetpAllocateEnumBuffer.
        Added typedefs PTRDIFF_T and BUFFER_DESCRIPTOR.
    16-Apr-1991 JohnRo
        Clarify UNICODE handling of pack and copy routines.
    24-Jul-1991 JohnRo
        Provide NetpIsServiceStarted() for use by <netrpc.h> macros.
    29-Oct-1991 JohnRo
        Added NetpChangeNullCharToNullPtr() macro.
    29-Oct-1991 Danhi
        Add function prototypes for DosxxxMessage Api's
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    09-Jan-1992 JohnRo
        Added NetpGetDomainName().
    23-Jan-1992 JohnRo
        Added IN_RANGE() macro based on MadanA's RANGECHECK().
    25-Mar-1992 RitaW
        Added SET_SERVICE_EXITCODE() macro for setting Win32 vs
        service specific exitcode.
    06-May-1992 JohnRo
        Added NetpGetLocalDomainId() for PortUAS.
        Added NetpTranslateServiceName() for service controller APIs.
    27-Jul-1992 Madana
        Added NetpWriteEventlog function proto type.
    05-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.
    09-Sep-1992 JohnRo
        RAID 1090: net start/stop "" causes assertion.
    14-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
    02-Nov-1992 JohnRo
        Added NetpIsRemoteServiceStarted().
    15-Feb-1993 JohnRo
        RAID 10685: user name not in repl event log.
    24-Mar-1993 JohnRo
        Repl svc shuold use DBFlag in registry.
    05-Aug-1993 JohnRo
        RAID 17010: Implement per-first-level-directory change notify.
    19-Aug-1993 JohnRo
        RAID 2822: PortUAS maps chars funny.  (Workaround FormatMessageA bug.)
        RAID 3094: PortUAS displays chars incorrectly.

--*/

#ifndef _NETLIB_
#define _NETLIB_

// These may be included in any order:

#include <string.h>             // memcpy().

// Don't complain about "unneeded" includes of this file:
/*lint -efile(764,wchar.h) */
/*lint -efile(766,wchar.h) */
#include <wchar.h>      // iswdigit().

#ifdef CDEBUG                   // Debug in ANSI C environment?

#include <netdebug.h>           // NetpAssert().

#endif // ndef CDEBUG


#ifdef __cplusplus
extern "C" {
#endif

//
// IN_RANGE(): Make sure SomeValue is between SomeMin and SomeMax.
// Beware side-effects (SomeValue is evaluated twice).
// Created by JohnRo from MadanA's RANGECHECK().
//
// BOOL
// IN_RANGE(
//     IN DWORD SomeValue,
//     IN DWORD SomeMin,
//     IN DWORD SomeMax
//     );
//
#define IN_RANGE(SomeValue, SomeMin, SomeMax) \
    ( ((SomeValue) >= (SomeMin)) && ((SomeValue) <= (SomeMax)) )


//
// SET_SERVICE_EXITCODE() sets the SomeApiStatus to NetCodeVariable
// if it is within the NERR_BASE and NERR_MAX range.  Otherwise,
// Win32CodeVariable is set.  This original code came from JohnRo.
//
#define SET_SERVICE_EXITCODE(SomeApiStatus, Win32CodeVariable, NetCodeVariable) \
    {                                                                  \
        if ((SomeApiStatus) == NERR_Success) {                         \
            (Win32CodeVariable) = NO_ERROR;                            \
            (NetCodeVariable) = NERR_Success;                          \
        } else if (! IN_RANGE((SomeApiStatus), MIN_LANMAN_MESSAGE_ID, MAX_LANMAN_MESSAGE_ID)) { \
            (Win32CodeVariable) = (DWORD) (SomeApiStatus);             \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        } else {                                                       \
            (Win32CodeVariable) = ERROR_SERVICE_SPECIFIC_ERROR;        \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        }                                                              \
    }


VOID
NetpAdjustPreferedMaximum (
    IN DWORD PreferedMaximum,
    IN DWORD EntrySize,
    IN DWORD Overhead,
    OUT LPDWORD BytesToAllocate OPTIONAL,
    OUT LPDWORD EntriesToAllocate OPTIONAL
    );

// Portable memory move/copy routine:  This is intended to have exactly
// the semantics of ANSI C's memcpy() routine, except that the byte count
// is 32 bits long.
//
// VOID
// NetpMoveMemory(
//     OUT LPBYTE Dest,         // Destination (must not be NULL).
//     IN LPBYTE Src,           // Source
//     IN DWORD Size            // Byte count
//     );

#ifdef CDEBUG

// Note that C6 version doesn't allow 32-bit Size, hence the
// assertion.  Replace this macro with another if this is a problem.

#define NetpMoveMemory(Dest,Src,Size)                                   \
                {                                                       \
                    NetpAssert( (Size) == (DWORD) (size_t) (Size));     \
                    (void) memcpy( (Dest), (Src), (size_t) (Size) );    \
                }

#else // ndef CDEBUG

#define NetpMoveMemory(Dest,Src,Size)                                   \
                (void) memcpy( (Dest), (Src), (size_t) (Size) )

#endif // ndef CDEBUG

DWORD
NetpPackString(
    IN OUT LPWSTR * string,     // pointer by reference: string to be copied.
    IN LPBYTE dataend,          // pointer to end of fixed size data.
    IN OUT LPWSTR * laststring  // pointer by reference: top of string data.
    );

//
// This routine is like NetpPackString, except that it does not expect the
// caller to assign the pointer of the source string to the variable in the
// fixed size structure before the call.  It also takes a string character
// count parameter instead of calling strlen on String.
//

BOOL
NetpCopyStringToBuffer (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

//
// This routine is like NetpCopyStringToBuffer except it copies any data
// (not just strings), it does not put a zero byte at the end of the
// data, and it allows the alignment of the resultant copied data to be
// specified.
//

BOOL
NetpCopyDataToBuffer (
    IN LPBYTE Data,
    IN DWORD ByteCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPBYTE *EndOfVariableData,
    OUT LPBYTE *VariableDataPointer,
    IN DWORD Alignment
    );

//
// Declare a type for the difference between two pointers.
//
// This must be at least as long as a ptrdiff_t but we don't want to
// add a dependency on <stddef.h> here.
//

typedef DWORD_PTR PTRDIFF_T;


//
// Declare a description of an enumeration buffer.
//

typedef struct _BUFFER_DESCRIPTOR {
    LPBYTE Buffer;        // Pointer to the allocated buffer.
    DWORD AllocSize;      // Current size of the allocated buffer.
    DWORD AllocIncrement; // Amount to increment size by on each reallocate.

    LPBYTE EndOfVariableData;// Pointer past last avaliable byte of string space
    LPBYTE FixedDataEnd;  // Pointer past last used byte of fixed data space

} BUFFER_DESCRIPTOR, *PBUFFER_DESCRIPTOR;

//
// This routine handles all the details of allocating and growing a
// buffer returned from an enumeration function.  It takes the users
// prefered maximum size into consideration.
//

#define NETP_ENUM_GUESS 16384 // Initial guess for enumeration buffer size

NET_API_STATUS
NetpAllocateEnumBuffer(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
        // Caller must deallocate BD->Buffer using MIDL_user_free.

    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter
    );

NET_API_STATUS
NetpAllocateEnumBufferEx(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter,
    IN DWORD IncrementalSize
    );

BOOL
NetpIsServiceStarted(
    IN LPWSTR ServiceName
    );

//
// Portable memory allocation routines.  Memory is per-process only.
//

// Allocate memory, or return NULL if not available.

LPVOID
NetpMemoryAllocate(
    IN DWORD Size
    );

// Free memory at Address (must have been gotten from NetpMemoryAllocate or
// NetpMemoryReallocate).  (Address may be NULL.)

VOID
NetpMemoryFree(
    IN LPVOID Address OPTIONAL
    );

// Reallocate block (now at OldAddress) to NewSize.  OldAddress may be NULL.
// Contents of block are copied if necessary.  Returns NULL if unable to
// allocate additional storage.

LPVOID
NetpMemoryReallocate(
    IN LPVOID OldAddress OPTIONAL,
    IN DWORD NewSize
    );

//
// Random handy macros:
//
#define NetpPointerPlusSomeBytes(p,n)                                   \
                (LPBYTE)  ( ( (LPBYTE) (p)) + (n) )

#define NetpSetOptionalArg(arg, value) \
    {                         \
        if ((arg) != NULL) {  \
            *(arg) = (value); \
        }                     \
    }

//
// Set the optional ParmError parameter
//

#define NetpSetParmError( _ParmNumValue ) \
    if ( ParmError != NULL ) { \
        *ParmError = (_ParmNumValue); \
    }

#if defined(lint) || defined(_lint)
#define UNUSED(x)               { (x) = (x); }
#else
#define UNUSED(x)               { (void) (x); }
#endif

//
// NetpGetComputerName retrieves the local computername from the local
// configuration database.
//

NET_API_STATUS
NetpGetComputerName (
    IN  LPWSTR   *ComputerNamePtr);

NET_API_STATUS
NetpGetComputerNameEx (
    IN  LPWSTR   *ComputerNamePtr,
    IN  BOOL PhysicalNetbiosName
    );

// Note: calls to NetpGetDomainId should eventually be replaced by calls
// to NetpGetLocalDomainId.  --JR
NET_API_STATUS
NetpGetDomainId (
    OUT PSID *RetDomainId     // alloc and set ptr (free with LocalFree)
    );

NET_API_STATUS
NetpGetDomainName (
    OUT LPWSTR *DomainNamePtr  // alloc and set ptr (free with NetApiBufferFree)
    );

NET_API_STATUS
NetpGetDomainNameEx (
    OUT LPWSTR *DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOLEAN IsWorkgroupName
    );

NET_API_STATUS
NetpGetDomainNameExEx (
    OUT LPWSTR *DomainNamePtr,
    OUT LPWSTR *DnsDomainNamePtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    } GUID;

#endif // !GUID_DEFINED

NET_API_STATUS
NetpGetDomainNameExExEx (
    OUT LPTSTR *DomainNamePtr,
    OUT LPTSTR *DnsDomainNamePtr OPTIONAL,
    OUT LPTSTR *DnsForestNamePtr OPTIONAL,
    OUT GUID **DomainGuidPtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

typedef enum _LOCAL_DOMAIN_TYPE {
    LOCAL_DOMAIN_TYPE_ACCOUNTS,
    LOCAL_DOMAIN_TYPE_BUILTIN,
    LOCAL_DOMAIN_TYPE_PRIMARY
} LOCAL_DOMAIN_TYPE, *PLOCAL_DOMAIN_TYPE, *LPLOCAL_DOMAIN_TYPE;

NET_API_STATUS
NetpGetLocalDomainId (
    IN LOCAL_DOMAIN_TYPE TypeWanted,
    OUT PSID *RetDomainId     // alloc and set ptr (free with LocalFree)
    );

//
// NetService API helpers
//

// BOOL
// NetpIsServiceLevelValid(
//     IN DWORD Level
//     );
//
#define NetpIsServiceLevelValid( Level ) \
     ( ((Level)==0) || ((Level)==1) || ((Level)==2) )

NET_API_STATUS
NetpTranslateNamesInServiceArray(
    IN DWORD Level,
    IN LPVOID ArrayBase,
    IN DWORD EntryCount,
    IN BOOL PreferNewStyle,
    OUT LPVOID * NewArrayBase
    );

NET_API_STATUS
NetpTranslateServiceName(
    IN LPWSTR GivenServiceName,
    IN BOOL PreferNewStyle,
    OUT LPWSTR * TranslatedName
    );

//
// Mapping routines to map DosxxxMessage API's to FormatMessage
//


WORD
DosGetMessage(
    IN LPSTR * InsertionStrings,
    IN WORD NumberofStrings,
    OUT LPBYTE Buffer,
    IN WORD BufferLength,
    IN WORD MessageId,
    IN LPWSTR FileName,
    OUT PWORD pMessageLength
    );

DWORD
NetpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

DWORD
NetpReleasePrivilege(
    VOID
    );

DWORD
NetpWriteEventlog(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    LPWSTR *Strings,
    DWORD DataLength,
    LPVOID Data
    );

DWORD
NetpRaiseAlert(
    IN LPWSTR ServiceName,
    IN DWORD alert_no,
    IN LPWSTR *string_array
    );

//
// Special flags to NetpEventlogWrite
//

#define NETP_LAST_MESSAGE_IS_NTSTATUS  0x80000000
#define NETP_LAST_MESSAGE_IS_NETSTATUS 0x40000000
#define NETP_ALLOW_DUPLICATE_EVENTS    0x20000000
#define NETP_RAISE_ALERT_TOO           0x10000000
#define NETP_STRING_COUNT_MASK         0x000FFFFF

HANDLE
NetpEventlogOpen (
    IN LPWSTR Source,
    IN ULONG DuplicateEventlogTimeout
    );

DWORD
NetpEventlogWrite (
    IN HANDLE NetpEventHandle,
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    );

//
// extended version with re-arranged parameters + category, to be more
// compatible with ReportEvent().
//

DWORD
NetpEventlogWriteEx (
    IN HANDLE NetpEventHandle,
    IN DWORD EventType,
    IN DWORD EventCategory,
    IN DWORD EventId,
    IN DWORD StringCount,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN LPVOID RawDataBuffer OPTIONAL
    );

VOID
NetpEventlogClearList (
    IN HANDLE NetpEventHandle
    );

VOID
NetpEventlogSetTimeout (
    IN HANDLE NetpEventHandle,
    IN ULONG DuplicateEventlogTimeout
    );

VOID
NetpEventlogClose (
    IN HANDLE NetpEventHandle
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ndispnp.h ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  Module Name:
 *      ndispnp.h
 *
 *  Abstract:
 *      Include file for PnP message apis to NDIS.
 *
 *  Environment:
 *      These routines are statically linked in the caller's executable and are callable in user mode.
 */

#ifndef _NDISPNP_
#define _NDISPNP_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4514)
#endif
#if (_MSC_VER >= 1020)
#pragma once
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Definitions for Layer
//
#define NDIS            0x01
#define TDI             0x02

//
// Definitions for Operation
//
#define BIND                0x01
#define UNBIND              0x02
#define RECONFIGURE         0x03
#define UNBIND_FORCE        0x04
#define UNLOAD              0x05
#define REMOVE_DEVICE       0x06    // This is a notification that a device is about to be removed.
#define ADD_IGNORE_BINDING  0x07
#define DEL_IGNORE_BINDING  0x08
#define BIND_LIST           0x09    // this is a notification that a protocol's bind list has changed

//
// Return code from this api is to be treated as a BOOL. Link with ndispnp.lib for this.
//
extern
UINT
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent,
    IN  PUNICODE_STRING UpperComponent,
    IN  PUNICODE_STRING BindList,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    );

#define MEDIA_STATE_CONNECTED       1
#define MEDIA_STATE_DISCONNECTED    0
#define MEDIA_STATE_UNKNOWN         -1

#define DEVICE_STATE_CONNECTED      1
#define DEVICE_STATE_DISCONNECTED   0

typedef struct
{
    ULONG               Size;               // Of this structure
    ULONG               DeviceState;        // DEVICE_STATE_XXX above
    ULONG               MediaType;          // NdisMediumXXX
    ULONG               MediaState;      // MEDIA_STATE_XXX above
    ULONG               PhysicalMediaType;
    ULONG               LinkSpeed;          // In 100bits/s. 10Mb/s = 100000
    ULONGLONG           PacketsSent;
    ULONGLONG           PacketsReceived;
    ULONG               InitTime;           // In milliseconds
    ULONG               ConnectTime;        // In seconds
    ULONGLONG           BytesSent;          // 0 - Unknown (or not supported)
    ULONGLONG           BytesReceived;      // 0 - Unknown (or not supported)
    ULONGLONG           DirectedBytesReceived;
    ULONGLONG           DirectedPacketsReceived;
    ULONG               PacketsReceiveErrors;
    ULONG               PacketsSendErrors;
    ULONG               ResetCount;
    ULONG               MediaSenseConnectCount;
    ULONG               MediaSenseDisconnectCount;

} NIC_STATISTICS, *PNIC_STATISTICS;

extern
UINT
NdisQueryHwAddress(
    IN  PUNICODE_STRING DeviceGUID,         // Device name of the form "\Device\{GUID}
    OUT PUCHAR          CurrentAddress,     // Has space for HW address
    OUT PUCHAR          PermanentAddress,   // Has space for HW address
    OUT PUCHAR          VendorId            // Has space for Vendor Id
    );

extern
UINT
NdisQueryStatistics(
    IN  PUNICODE_STRING   DeviceGUID,      // Device name of the form "\Device\{GUID}
    OUT PNIC_STATISTICS   Statistics
    );

typedef struct _NDIS_INTERFACE
{
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      DeviceDescription;
} NDIS_INTERFACE, *PNDIS_INTERFACE;

typedef struct _NDIS_ENUM_INTF
{
    UINT                TotalInterfaces;        // in Interface array below
    UINT                AvailableInterfaces;    // >= TotalInterfaces
    UINT                BytesNeeded;            // for all available interfaces
    UINT                Reserved;
    NDIS_INTERFACE      Interface[1];
} NDIS_ENUM_INTF, *PNDIS_ENUM_INTF;

extern
UINT
NdisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF Interfaces,
    IN  UINT            Size
    );

typedef enum
{
    BundlePrimary,
    BundleSecondary
} BUNDLE_TYPE;

typedef struct _DEVICE_BUNDLE_ENRTY
{
    UNICODE_STRING Name;
    BUNDLE_TYPE    Type;
} DEVICE_BUNDLE_ENRTY, *PDEVICE_BUNDLE_ENRTY;

typedef struct _DEVICE_BUNDLE
{
    UINT                TotalEntries;
    UINT                AvailableEntries;
    DEVICE_BUNDLE_ENRTY Entries[1];
} DEVICE_BUNDLE, *PDEVICE_BUNDLE;

extern
UINT
NdisQueryDeviceBundle(
    IN  PUNICODE_STRING DeviceGUID,      // Device name of the form "\Device\{GUID}
    OUT PDEVICE_BUNDLE  BundleBuffer,
    IN  UINT            BufferSize
    );

#define POINTER_TO_OFFSET(val, start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) - (ULONG_PTR)(start) )

#define OFFSET_TO_POINTER(val, start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) + (ULONG_PTR)(start) )

#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#pragma warning(default:4514)
#endif

#endif  // _NDISPNP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netlibnt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    NetLibNT.h

Abstract:

    This header file declares various common routines for use in the
    NT networking code.

Author:

    John Rogers (JohnRo) 02-Apr-1991

Environment:

    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <nt.h> and <lmcons.h> before this file.

Revision History:

    02-Apr-1991 JohnRo
        Created.
    16-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
    06-May-1991 JohnRo
        Implement UNICODE.  Avoid NET_API_FUNCTION for non-APIs.
    06-Sep-1991 CliffV
        Added NetpApiStatusToNtStatus.
    27-Nov-1991 JohnRo
        Added NetpAllocTStrFromString() for local NetConfig APIs.
    03-Jan-1992 JohnRo
        Added NetpCopyStringToTStr() for FAKE_PER_PROCESS_RW_CONFIG handling.
    13-Mar-1992 JohnRo
        Added NetpAllocStringFromTStr() for NetpGetDomainId().
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.  (Added
        NetpGetProductType and NetpIsProductTypeValid.)
    13-Feb-1995 FloydR
        Deleted NetpAllocStringFromTStr() - unused

--*/

#ifndef _NETLIBNT_
#define _NETLIBNT_

#ifdef __cplusplus
extern "C" {
#endif

NET_API_STATUS
NetpNtStatusToApiStatus(
    IN NTSTATUS NtStatus
    );

NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    );

NET_API_STATUS
NetpRdrFsControlTree(
    IN LPTSTR TreeName,
    IN LPTSTR TransportName OPTIONAL,
    IN ULONG ConnectionType,
    IN DWORD FsControlCode,
    IN LPVOID SecurityDescriptor OPTIONAL,
    IN LPVOID InputBuffer OPTIONAL,
    IN DWORD InputBufferSize,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOL NoPermissionRequired
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIBNT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\nbtioctl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nbtioctl.h

Abstract:

    This header file defines constants for issuing IOCTLS to Netbt


Author:

    JSTEW     November 16, 1993

Revision History:

--*/

#include <tdi.h>

#ifndef _NBTIOCTL_
#define _NBTIOCTL_

#define NETBIOS_NAMESIZE 16
#define MAX_IPADDRS_PER_HOST 26

//
// The following definitions are from Dns.c
//
#define DNS_NAME_BUFFER_LENGTH      (256)
#define DNS_MAX_NAME_LENGTH         (255)

//
// Netbt supports this number of adapters
//
#if defined(VXD) || defined(CHICAGO_PRODUCT)
#define NBT_MAXIMUM_BINDINGS    32  // we allow up to 32 net cards in CHICAGO
#else
#define NBT_MAXIMUM_BINDINGS    64  // we allow up to 64 net cards in NT
#endif  // VXD || CHICAGO_PRODUCT

//
// This structure is passed down to netbt on a IOCTL_NETBT_ADAPTER_STATUS
// call.  If the Ipaddress is set to anything other than zero netbt will
// assume it is an ip address and use it rather than try a name resolution
// on the netbios name passed in.
//
typedef struct
{
    ULONG                IpAddress;
    TA_NETBIOS_ADDRESS   NetbiosAddress;

} tIPANDNAMEINFO;

//
// Adapter Status response buffer format for a query of the remote hash
// table.  It is the same as the adapter status format except it includes
// the ip address of each name too. This is used in NBtQueryAdapterStatus
// when responding to nbtstat queries.
//
typedef struct
{
    UCHAR   name[NETBIOS_NAMESIZE];
    UCHAR   name_num;
    UCHAR   name_flags;
    UCHAR   padding;
#ifndef CHICAGO_PRODUCT
    ULONG   IpAddress;      // ip address of remote host
    ULONG   Ttl;            // remaining time in cache
#else
    UCHAR   IpAddress[4];
    UCHAR   Ttl[4];
#endif  // !CHICAGO_PRODUCT
} tREMOTE_CACHE;

// We log the how names are registered and queried
//
#define NAME_QUERY_SUCCESS         0
#define NAME_REGISTRATION_SUCCESS  1
#define NAME_QUERY_FAILURE         2
#define SIZE_RESOLVD_BY_BCAST_CACHE 8

typedef struct
{
    UCHAR   Name[NETBIOS_NAMESIZE];
} tNAME;
typedef struct
{
    ULONG   Stats[4];
    ULONG   Index;
    tNAME   NamesReslvdByBcast[SIZE_RESOLVD_BY_BCAST_CACHE];

} tNAMESTATS_INFO;


typedef struct
{
    USHORT  LanaNumber;
    ULONG   IpAddress;
    ULONG   NameServerAddress;     // primary WINS server
    ULONG   BackupServer;          // backup WINS server
    ULONG   lDnsServerAddress;     // primary DNS server
    ULONG   lDnsBackupServer;      // backup DNS server
} tIPCONFIG_PER_LANA;

//
// structure returned when ipconfig queries vnbt for parameters being used
//
typedef struct
{
    USHORT              NumLanas;
    tIPCONFIG_PER_LANA  LanaInfo[8];
    USHORT              NodeType;
    USHORT              ScopeLength;
    CHAR                szScope[1];
} tIPCONFIG_INFO;

//
// These two structures are used to return the connection list to
// NbtStat
//
typedef struct
{
#ifdef  CHICAGO_PRODUCT
    UCHAR           State[4];
    UCHAR           SrcIpAddr[4];
    CHAR            LocalName[NETBIOS_NAMESIZE];
    CHAR            RemoteName[NETBIOS_NAMESIZE];
    UCHAR           BytesRcvd[4];
    UCHAR           BytesSent[4];
#else
    ULONG           State;
    ULONG           SrcIpAddr;
    CHAR            LocalName[NETBIOS_NAMESIZE];
    CHAR            RemoteName[NETBIOS_NAMESIZE];
    LARGE_INTEGER   BytesRcvd;
    LARGE_INTEGER   BytesSent;
#endif  // CHICAGO_PRODUCT
    UCHAR           Originator; // True if originated on this node
} tCONNECTIONS;

typedef struct
{
    ULONG           ConnectionCount;
    tCONNECTIONS    ConnList[1];
} tCONNECTION_LIST;


typedef struct
{
    ULONG   IpAddress;
    ULONG   Resolved;
    UCHAR   Name[16];

} tIPADDR_BUFFER;

// this is the format of the buffer passed to Netbt when it either posts
// a buffer for subsequent DNS name resolutions, or it replies to a name
// resolution request. For a posted buffer, Name starts with a null, otherwise
// name is the name that was resolved. Resolved is set to true if the name
// resolved.
//
typedef struct
{
    union {
        WCHAR   pwName[DNS_NAME_BUFFER_LENGTH];     // Support for UNICODE
        CHAR    pName[DNS_NAME_BUFFER_LENGTH];     // Support for UNICODE
    };
    ULONG   NameLen;                            // how big is the name
    ULONG   bUnicode;
    ULONG   Resolved;
    ULONG   IpAddrsList[MAX_IPADDRS_PER_HOST+1];
} tIPADDR_BUFFER_DNS;

//
// this is the format of the buffer passed to Nbt by DHCP when DHCP
// changes the Ip Address
//
typedef struct
{
    ULONG   IpAddress;
    ULONG   SubnetMask;

} tNEW_IP_ADDRESS;

//
// this is the format of the buffer passed to Nbt by the RDR when
// it wants to know the Wins IP addresses for a given network adapter
// card.
//
typedef struct
{
    ULONG   PrimaryWinsServer;
    ULONG   BackupWinsServer;
} tWINS_ADDRESSES;

typedef ULONG   tIPADDRESS;
#define MAX_NUM_OTHER_NAME_SERVERS   10 // # of Backup Name Server entries to keep in cache

typedef struct
{
    union
    {
        tIPADDRESS      AllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  NameServerAddress;
            tIPADDRESS  BackupServer;
            tIPADDRESS  Others[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };
    USHORT  NumOtherServers;
    USHORT  LastResponsive;
    ULONG   NodeType;
    BOOLEAN NetbiosEnabled;
}tWINS_NODE_INFO;


//
// This structure is returned by Nbt when a TdiQueryInformation()
// call asks for TDI_QUERY_ADDRESS_INFO on a connection.  This is
// the same as a TRANSPORT_ADDRESS struct from "tdi.h" containing
// two address, a NetBIOS address followed by an IP address.
//

typedef struct _NBT_ADDRESS_PAIR {
    LONG TAAddressCount;                   // this will always == 2

    struct {
        USHORT AddressLength;              // length in bytes of this address == 18
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_NETBIOS
        TDI_ADDRESS_NETBIOS Address;
    } AddressNetBIOS;

    struct {
        USHORT AddressLength;              // length in bytes of this address == 14
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_IP
        TDI_ADDRESS_IP Address;
    } AddressIP;

} NBT_ADDRESS_PAIR, *PNBT_ADDRESS_PAIR;

typedef struct _NBT_ADDRESS_PAIR_INFO {
    ULONG ActivityCount;                   // outstanding open file objects/this address.
    NBT_ADDRESS_PAIR AddressPair;          // the actual address & its components.
} NBT_ADDRESS_PAIR_INFO, *PNBT_ADDRESS_PAIR_INFO;


#define WINS_INTERFACE_NAME "WinsInterface"
//
// This is the format of the remote address structure on the front of
// datagram rcvs passed up to WINS
//
typedef struct
{
    SHORT       Family;
    USHORT      Port;
    ULONG       IpAddress;
    ULONG       LengthOfBuffer;

} tREM_ADDRESS;


#define     MAX_NAME    650        // arbitrary!

typedef struct _NETBT_ADAPTER_INDEX_MAP
{
    ULONG   Index;
#if defined(VXD) || defined(CHICAGO_PRODUCT)
    ULONG   LanaNumber;
#else
    WCHAR   Name[MAX_NAME];
#endif
}NETBT_ADAPTER_INDEX_MAP, *PNETBT_ADAPTER_INDEX_MAP;

typedef struct _NETBT_INTERFACE_INFO
{
     LONG                       NumAdapters;
     NETBT_ADAPTER_INDEX_MAP    Adapter[1];
} NETBT_INTERFACE_INFO,*PNETBT_INTERFACE_INFO;


//
// Bind request type as requested by Rdr/Srv
//
enum eNbtBindRequestor
{
    SMB_SERVER,
    SMB_CLIENT
};

#if !defined(VXD) && !defined(CHICAGO_PRODUCT)
typedef struct _NETBT_SMB_BIND_REQUEST
{
    ULONG           RequestType;            // Set as SMB_SERVER_BINDING_.... from above
    ULONG           PnPOpCode;
    PUNICODE_STRING pDeviceName;
    PWSTR           MultiSZBindList;
}NETBT_SMB_BIND_REQUEST, *PNETBT_SMB_BIND_REQUEST;
#endif  // !VXD && !CHICAGO_PRODUCT


//
// Wins and Netbt share the transaction id space, where WINS uses the lower
// half
//
#define WINS_MAXIMUM_TRANSACTION_ID 0x7FFF

// this is equivalent to AF_INET - WINS depends on this to determine kind of
// address the source node has.
//
#define NBT_UNIX    1
#define NBT_INET    2
#define WINS_EXPORT       TEXT("Export")
#define NETBT_LINKAGE_KEY TEXT("system\\currentcontrolset\\services\\netbt\\linkage")

typedef struct _tWINS_SET_INFO
{
    ULONG           IpAddress;
}tWINS_SET_INFO;

// defines for CHICAGO_PRODUCT
#if defined(VXD) || defined(CHICAGO_PRODUCT)

#define NBT_VERIFY_VXD_IOCTL    0x33333333
typedef struct {
    ULONG   Signature;
    ULONG   LanaNumber;

    CHAR    UserData[1];
} tNBT_IOCTL_HEADER;


#define IOCTL_NETBT_PURGE_CACHE                 101
#define IOCTL_NETBT_GET_BCAST_NAMES             102
#define IOCTL_NETBT_GET_CONNECTIONS             103
#define IOCTL_NETBT_GET_LOCAL_NAMES             104
#define IOCTL_NETBT_GET_REMOTE_NAMES            105
#define IOCTL_NETBT_REREAD_REGISTRY             106
#define IOCTL_NETBT_NEW_IPADDRESS               107
#define IOCTL_NETBT_DNS_NAME_RESOLVE            108
#define IOCTL_NETBT_FIND_NAME                   109
#define IOCTL_NETBT_GET_WINS_ADDR               110
#define IOCTL_NETBT_WINS_SEND                   111
#define IOCTL_NETBT_WINS_RCV                    112
#define IOCTL_NETBT_GET_IP_ADDRS                113
#define IOCTL_NETBT_GET_IP_SUBNET               114
#define IOCTL_NETBT_ADAPTER_STATUS              115
#define IOCTL_NETBT_IPCONFIG_INFO               116
#define IOCTL_NETBT_NAME_RELEASE_REFRESH        117
#define IOCTL_NETBT_ADD_TO_REMOTE_TABLE         118
#define IOCTL_NETBT_GET_INTERFACE_INFO          119
#define IOCTL_NETBT_SET_TCP_CONNECTION_INFO     120
#define IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE    121
#define IOCTL_NETBT_LAST_IOCTL                  200

#else

// defines for NT

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
#define _NETBT_CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_TRANSPORT, function, method, access)


#define IOCTL_NETBT_PURGE_CACHE     _NETBT_CTRL_CODE( 30, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_BCAST_NAMES _NETBT_CTRL_CODE( 31, METHOD_OUT_DIRECT,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_CONNECTIONS _NETBT_CTRL_CODE( 32, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_REMOTE_NAMES _NETBT_CTRL_CODE( 33, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_REREAD_REGISTRY  _NETBT_CTRL_CODE( 34, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_NEW_IPADDRESS    _NETBT_CTRL_CODE( 35, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_DNS_NAME_RESOLVE _NETBT_CTRL_CODE( 36, METHOD_OUT_DIRECT,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_FIND_NAME        _NETBT_CTRL_CODE( 37, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_WINS_ADDR    _NETBT_CTRL_CODE( 38, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_WINS_SEND        _NETBT_CTRL_CODE( 39, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_WINS_RCV         _NETBT_CTRL_CODE( 40, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_GET_IP_ADDRS     _NETBT_CTRL_CODE( 41, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_IP_SUBNET     _NETBT_CTRL_CODE( 42, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_ADAPTER_STATUS    _NETBT_CTRL_CODE( 43, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_CHECK_IP_ADDR    _NETBT_CTRL_CODE( 44, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_ADD_INTERFACE   _NETBT_CTRL_CODE( 45, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_DELETE_INTERFACE _NETBT_CTRL_CODE( 46, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_QUERY_INTERFACE_INSTANCE _NETBT_CTRL_CODE( 47, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_SET_WINS_ADDRESS _NETBT_CTRL_CODE( 48, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_ENABLE_EXTENDED_ADDR _NETBT_CTRL_CODE( 49, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_DISABLE_EXTENDED_ADDR _NETBT_CTRL_CODE( 50, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_NAME_RELEASE_REFRESH _NETBT_CTRL_CODE( 51, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_ADD_TO_REMOTE_TABLE _NETBT_CTRL_CODE( 52, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_INTERFACE_INFO _NETBT_CTRL_CODE( 53, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_SET_TCP_CONNECTION_INFO _NETBT_CTRL_CODE( 54, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO _NETBT_CTRL_CODE( 55, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE _NETBT_CTRL_CODE( 56, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_WINS_SET_INFO _NETBT_CTRL_CODE( 57, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)


//
// This ioctl should be last since Driver.c uses this to decide the range of
// ioctls to pass to DispatchIoctls
//
#define IOCTL_NETBT_LAST_IOCTL       _NETBT_CTRL_CODE( 58, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Used in IOCTL_NETBT_ADD_INTERFACE and IOCTL_NETBT_DELETE_INTERFACE
//
typedef struct  _netbt_add_del_if {
    NTSTATUS   Status;
    ULONG   InstanceNumber; // instance number of this device
    ULONG   Length; // length of the buffer
    WCHAR   IfName[1]; // actual data
} NETBT_ADD_DEL_IF, *PNETBT_ADD_DEL_IF;

//
// Used in IOCTL_NETBT_SET_WINS_ADDRESS
//
typedef struct  _netbt_set_wins_addr {
    ULONG   PrimaryWinsAddr;
    ULONG   SecondaryWinsAddr;
    NTSTATUS   Status;
} NETBT_SET_WINS_ADDR, *PNETBT_SET_WINS_ADDR;

#endif  // VXD || CHICAGO_PRODUCT

#endif  // ifndef _NBTIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netconp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netconp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netconp_h__
#define __netconp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetConnectionUiLock_FWD_DEFINED__
#define __INetConnectionUiLock_FWD_DEFINED__
typedef interface INetConnectionUiLock INetConnectionUiLock;
#endif 	/* __INetConnectionUiLock_FWD_DEFINED__ */


#ifndef __INetConnectionWizardUi_FWD_DEFINED__
#define __INetConnectionWizardUi_FWD_DEFINED__
typedef interface INetConnectionWizardUi INetConnectionWizardUi;
#endif 	/* __INetConnectionWizardUi_FWD_DEFINED__ */


#ifndef __INetConnectionWizardUiContext_FWD_DEFINED__
#define __INetConnectionWizardUiContext_FWD_DEFINED__
typedef interface INetConnectionWizardUiContext INetConnectionWizardUiContext;
#endif 	/* __INetConnectionWizardUiContext_FWD_DEFINED__ */


#ifndef __INetInboundConnection_FWD_DEFINED__
#define __INetInboundConnection_FWD_DEFINED__
typedef interface INetInboundConnection INetInboundConnection;
#endif 	/* __INetInboundConnection_FWD_DEFINED__ */


#ifndef __INetLanConnection_FWD_DEFINED__
#define __INetLanConnection_FWD_DEFINED__
typedef interface INetLanConnection INetLanConnection;
#endif 	/* __INetLanConnection_FWD_DEFINED__ */


#ifndef __INetSharedAccessConnection_FWD_DEFINED__
#define __INetSharedAccessConnection_FWD_DEFINED__
typedef interface INetSharedAccessConnection INetSharedAccessConnection;
#endif 	/* __INetSharedAccessConnection_FWD_DEFINED__ */


#ifndef __INetLanConnectionWizardUi_FWD_DEFINED__
#define __INetLanConnectionWizardUi_FWD_DEFINED__
typedef interface INetLanConnectionWizardUi INetLanConnectionWizardUi;
#endif 	/* __INetLanConnectionWizardUi_FWD_DEFINED__ */


#ifndef __INetRasConnection_FWD_DEFINED__
#define __INetRasConnection_FWD_DEFINED__
typedef interface INetRasConnection INetRasConnection;
#endif 	/* __INetRasConnection_FWD_DEFINED__ */


#ifndef __INetDefaultConnection_FWD_DEFINED__
#define __INetDefaultConnection_FWD_DEFINED__
typedef interface INetDefaultConnection INetDefaultConnection;
#endif 	/* __INetDefaultConnection_FWD_DEFINED__ */


#ifndef __INetRasConnectionIpUiInfo_FWD_DEFINED__
#define __INetRasConnectionIpUiInfo_FWD_DEFINED__
typedef interface INetRasConnectionIpUiInfo INetRasConnectionIpUiInfo;
#endif 	/* __INetRasConnectionIpUiInfo_FWD_DEFINED__ */


#ifndef __IPersistNetConnection_FWD_DEFINED__
#define __IPersistNetConnection_FWD_DEFINED__
typedef interface IPersistNetConnection IPersistNetConnection;
#endif 	/* __IPersistNetConnection_FWD_DEFINED__ */


#ifndef __INetConnectionBrandingInfo_FWD_DEFINED__
#define __INetConnectionBrandingInfo_FWD_DEFINED__
typedef interface INetConnectionBrandingInfo INetConnectionBrandingInfo;
#endif 	/* __INetConnectionBrandingInfo_FWD_DEFINED__ */


#ifndef __INetConnectionManager2_FWD_DEFINED__
#define __INetConnectionManager2_FWD_DEFINED__
typedef interface INetConnectionManager2 INetConnectionManager2;
#endif 	/* __INetConnectionManager2_FWD_DEFINED__ */


#ifndef __INetConnection2_FWD_DEFINED__
#define __INetConnection2_FWD_DEFINED__
typedef interface INetConnection2 INetConnection2;
#endif 	/* __INetConnection2_FWD_DEFINED__ */


#ifndef __INetConnectionNotifySink_FWD_DEFINED__
#define __INetConnectionNotifySink_FWD_DEFINED__
typedef interface INetConnectionNotifySink INetConnectionNotifySink;
#endif 	/* __INetConnectionNotifySink_FWD_DEFINED__ */


#ifndef __INetConnectionUiUtilities_FWD_DEFINED__
#define __INetConnectionUiUtilities_FWD_DEFINED__
typedef interface INetConnectionUiUtilities INetConnectionUiUtilities;
#endif 	/* __INetConnectionUiUtilities_FWD_DEFINED__ */


#ifndef __INetConnectionRefresh_FWD_DEFINED__
#define __INetConnectionRefresh_FWD_DEFINED__
typedef interface INetConnectionRefresh INetConnectionRefresh;
#endif 	/* __INetConnectionRefresh_FWD_DEFINED__ */


#ifndef __INetConnectionCMUtil_FWD_DEFINED__
#define __INetConnectionCMUtil_FWD_DEFINED__
typedef interface INetConnectionCMUtil INetConnectionCMUtil;
#endif 	/* __INetConnectionCMUtil_FWD_DEFINED__ */


#ifndef __INetConnectionHNetUtil_FWD_DEFINED__
#define __INetConnectionHNetUtil_FWD_DEFINED__
typedef interface INetConnectionHNetUtil INetConnectionHNetUtil;
#endif 	/* __INetConnectionHNetUtil_FWD_DEFINED__ */


#ifndef __INetConnectionSysTray_FWD_DEFINED__
#define __INetConnectionSysTray_FWD_DEFINED__
typedef interface INetConnectionSysTray INetConnectionSysTray;
#endif 	/* __INetConnectionSysTray_FWD_DEFINED__ */


#ifndef __INetMachinePolicies_FWD_DEFINED__
#define __INetMachinePolicies_FWD_DEFINED__
typedef interface INetMachinePolicies INetMachinePolicies;
#endif 	/* __INetMachinePolicies_FWD_DEFINED__ */


#ifndef __INetConnectionManagerDebug_FWD_DEFINED__
#define __INetConnectionManagerDebug_FWD_DEFINED__
typedef interface INetConnectionManagerDebug INetConnectionManagerDebug;
#endif 	/* __INetConnectionManagerDebug_FWD_DEFINED__ */


#ifndef __ISharedAccessBeacon_FWD_DEFINED__
#define __ISharedAccessBeacon_FWD_DEFINED__
typedef interface ISharedAccessBeacon ISharedAccessBeacon;
#endif 	/* __ISharedAccessBeacon_FWD_DEFINED__ */


#ifndef __ISharedAccessBeaconFinder_FWD_DEFINED__
#define __ISharedAccessBeaconFinder_FWD_DEFINED__
typedef interface ISharedAccessBeaconFinder ISharedAccessBeaconFinder;
#endif 	/* __ISharedAccessBeaconFinder_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "netcon.h"
#include "netcfgx.h"
#include "netcfgp.h"
#include "upnp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netconp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_NetConnectionUiUtilities;
EXTERN_C const CLSID CLSID_NetConnectionHNetUtil;
EXTERN_C const CLSID GUID_NETSHELL_PROPS;
EXTERN_C const CLSID CLSID_ConnectionManager2;


























extern RPC_IF_HANDLE __MIDL_itf_netconp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0000_v0_0_s_ifspec;

#ifndef __INetConnectionUiLock_INTERFACE_DEFINED__
#define __INetConnectionUiLock_INTERFACE_DEFINED__

/* interface INetConnectionUiLock */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetConnectionUiLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF50-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionUiLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryLock( 
            /* [string][out] */ LPWSTR *ppszwLockHolder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionUiLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionUiLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionUiLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionUiLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLock )( 
            INetConnectionUiLock * This,
            /* [string][out] */ LPWSTR *ppszwLockHolder);
        
        END_INTERFACE
    } INetConnectionUiLockVtbl;

    interface INetConnectionUiLock
    {
        CONST_VTBL struct INetConnectionUiLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionUiLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionUiLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionUiLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionUiLock_QueryLock(This,ppszwLockHolder)	\
    (This)->lpVtbl -> QueryLock(This,ppszwLockHolder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionUiLock_QueryLock_Proxy( 
    INetConnectionUiLock * This,
    /* [string][out] */ LPWSTR *ppszwLockHolder);


void __RPC_STUB INetConnectionUiLock_QueryLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionUiLock_INTERFACE_DEFINED__ */


#ifndef __INetConnectionWizardUi_INTERFACE_DEFINED__
#define __INetConnectionWizardUi_INTERFACE_DEFINED__

/* interface INetConnectionWizardUi */
/* [unique][uuid][object][local] */ 

typedef 
enum tagNETCON_WIZARD_FLAGS
    {	NCWF_RENAME_DISABLE	= 0x1,
	NCWF_SHORTCUT_ENABLE	= 0x2,
	NCWF_ALLUSER_CONNECTION	= 0x4,
	NCWF_GLOBAL_CREDENTIALS	= 0x8,
	NCWF_FIREWALLED	= 0x10,
	NCWF_DEFAULT	= 0x20,
	NCWF_SHARED	= 0x40,
	NCWF_INCOMINGCONNECTION	= 0x80
    } 	NETCON_WIZARD_FLAGS;


EXTERN_C const IID IID_INetConnectionWizardUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF51-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionWizardUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryMaxPageCount( 
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [out] */ DWORD *pcMaxPages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNewConnectionInfo( 
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ NETCON_MEDIATYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuggestedConnectionName( 
            /* [string][out] */ LPWSTR *pszwSuggestedName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [string][in] */ LPCWSTR pszwConnectionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNewConnection( 
            /* [out] */ INetConnection **ppCon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionWizardUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionWizardUi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionWizardUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionWizardUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryMaxPageCount )( 
            INetConnectionWizardUi * This,
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [out] */ DWORD *pcMaxPages);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            INetConnectionWizardUi * This,
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewConnectionInfo )( 
            INetConnectionWizardUi * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ NETCON_MEDIATYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSuggestedConnectionName )( 
            INetConnectionWizardUi * This,
            /* [string][out] */ LPWSTR *pszwSuggestedName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionName )( 
            INetConnectionWizardUi * This,
            /* [string][in] */ LPCWSTR pszwConnectionName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewConnection )( 
            INetConnectionWizardUi * This,
            /* [out] */ INetConnection **ppCon);
        
        END_INTERFACE
    } INetConnectionWizardUiVtbl;

    interface INetConnectionWizardUi
    {
        CONST_VTBL struct INetConnectionWizardUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionWizardUi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionWizardUi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionWizardUi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionWizardUi_QueryMaxPageCount(This,pContext,pcMaxPages)	\
    (This)->lpVtbl -> QueryMaxPageCount(This,pContext,pcMaxPages)

#define INetConnectionWizardUi_AddPages(This,pContext,pfnAddPage,lParam)	\
    (This)->lpVtbl -> AddPages(This,pContext,pfnAddPage,lParam)

#define INetConnectionWizardUi_GetNewConnectionInfo(This,pdwFlags,pMediaType)	\
    (This)->lpVtbl -> GetNewConnectionInfo(This,pdwFlags,pMediaType)

#define INetConnectionWizardUi_GetSuggestedConnectionName(This,pszwSuggestedName)	\
    (This)->lpVtbl -> GetSuggestedConnectionName(This,pszwSuggestedName)

#define INetConnectionWizardUi_SetConnectionName(This,pszwConnectionName)	\
    (This)->lpVtbl -> SetConnectionName(This,pszwConnectionName)

#define INetConnectionWizardUi_GetNewConnection(This,ppCon)	\
    (This)->lpVtbl -> GetNewConnection(This,ppCon)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_QueryMaxPageCount_Proxy( 
    INetConnectionWizardUi * This,
    /* [in] */ INetConnectionWizardUiContext *pContext,
    /* [out] */ DWORD *pcMaxPages);


void __RPC_STUB INetConnectionWizardUi_QueryMaxPageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_AddPages_Proxy( 
    INetConnectionWizardUi * This,
    /* [in] */ INetConnectionWizardUiContext *pContext,
    /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
    /* [in] */ LPARAM lParam);


void __RPC_STUB INetConnectionWizardUi_AddPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetNewConnectionInfo_Proxy( 
    INetConnectionWizardUi * This,
    /* [out] */ DWORD *pdwFlags,
    /* [out] */ NETCON_MEDIATYPE *pMediaType);


void __RPC_STUB INetConnectionWizardUi_GetNewConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetSuggestedConnectionName_Proxy( 
    INetConnectionWizardUi * This,
    /* [string][out] */ LPWSTR *pszwSuggestedName);


void __RPC_STUB INetConnectionWizardUi_GetSuggestedConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_SetConnectionName_Proxy( 
    INetConnectionWizardUi * This,
    /* [string][in] */ LPCWSTR pszwConnectionName);


void __RPC_STUB INetConnectionWizardUi_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetNewConnection_Proxy( 
    INetConnectionWizardUi * This,
    /* [out] */ INetConnection **ppCon);


void __RPC_STUB INetConnectionWizardUi_GetNewConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionWizardUi_INTERFACE_DEFINED__ */


#ifndef __INetConnectionWizardUiContext_INTERFACE_DEFINED__
#define __INetConnectionWizardUiContext_INTERFACE_DEFINED__

/* interface INetConnectionWizardUiContext */
/* [unique][uuid][object][local] */ 

typedef 
enum tagSETUP_MODE_FLAGS
    {	NCWUC_SETUPMODE_MINIMAL	= 0,
	NCWUC_SETUPMODE_TYPICAL	= 0x1,
	NCWUC_SETUPMODE_LAPTOP	= 0x2,
	NCWUC_SETUPMODE_CUSTOM	= 0x3
    } 	SETUP_MODE_FLAGS;

typedef 
enum tagUNATTENDED_MODE_FLAGS
    {	UM_DEFAULTHIDE	= 0x1,
	UM_GUIATTENDED	= 0x2,
	UM_PROVIDEDEFAULT	= 0x3,
	UM_READONLY	= 0x4,
	UM_FULLUNATTENDED	= 0x5
    } 	UM_MODE;

typedef 
enum tagPRODUCT_TYPE_FLAGS
    {	NCWUC_PRODUCT_WORKSTATION	= 0,
	NCWUC_PRODUCT_SERVER_DC	= 0x1,
	NCWUC_PRODUCT_SERVER_STANDALONE	= 0x2
    } 	PRODUCT_TYPE_FLAGS;

typedef 
enum tagOPERATION_FLAGS
    {	NCWUC_SETUPOPER_UPGRADE	= 0x4,
	NCWUC_SETUPOPER_UNATTENDED	= 0x8,
	NCWUC_SETUPOPER_POSTINSTALL	= 0x10
    } 	OPERATION_FLAGS;


EXTERN_C const IID IID_INetConnectionWizardUiContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF52-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionWizardUiContext : public IUnknown
    {
    public:
        virtual DWORD STDMETHODCALLTYPE GetSetupMode( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetProductType( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetOperationFlags( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetUnattendedModeFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetINetCfg( 
            /* [out] */ INetCfg **ppINetCfg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionWizardUiContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionWizardUiContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionWizardUiContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetSetupMode )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetProductType )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetOperationFlags )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetUnattendedModeFlags )( 
            INetConnectionWizardUiContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetINetCfg )( 
            INetConnectionWizardUiContext * This,
            /* [out] */ INetCfg **ppINetCfg);
        
        END_INTERFACE
    } INetConnectionWizardUiContextVtbl;

    interface INetConnectionWizardUiContext
    {
        CONST_VTBL struct INetConnectionWizardUiContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionWizardUiContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionWizardUiContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionWizardUiContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionWizardUiContext_GetSetupMode(This)	\
    (This)->lpVtbl -> GetSetupMode(This)

#define INetConnectionWizardUiContext_GetProductType(This)	\
    (This)->lpVtbl -> GetProductType(This)

#define INetConnectionWizardUiContext_GetOperationFlags(This)	\
    (This)->lpVtbl -> GetOperationFlags(This)

#define INetConnectionWizardUiContext_GetUnattendedModeFlags(This)	\
    (This)->lpVtbl -> GetUnattendedModeFlags(This)

#define INetConnectionWizardUiContext_GetINetCfg(This,ppINetCfg)	\
    (This)->lpVtbl -> GetINetCfg(This,ppINetCfg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetSetupMode_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetSetupMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetProductType_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetProductType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetOperationFlags_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetOperationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetUnattendedModeFlags_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetUnattendedModeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUiContext_GetINetCfg_Proxy( 
    INetConnectionWizardUiContext * This,
    /* [out] */ INetCfg **ppINetCfg);


void __RPC_STUB INetConnectionWizardUiContext_GetINetCfg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionWizardUiContext_INTERFACE_DEFINED__ */


#ifndef __INetInboundConnection_INTERFACE_DEFINED__
#define __INetInboundConnection_INTERFACE_DEFINED__

/* interface INetInboundConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetInboundConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF53-31FE-11D1-AAD2-00805FC1270E")
    INetInboundConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServerConnectionHandle( 
            /* [out] */ ULONG_PTR *phRasSrvCon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeAsConfigConnection( 
            /* [in] */ BOOL fStartRemoteAccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetInboundConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetInboundConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetInboundConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetInboundConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerConnectionHandle )( 
            INetInboundConnection * This,
            /* [out] */ ULONG_PTR *phRasSrvCon);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeAsConfigConnection )( 
            INetInboundConnection * This,
            /* [in] */ BOOL fStartRemoteAccess);
        
        END_INTERFACE
    } INetInboundConnectionVtbl;

    interface INetInboundConnection
    {
        CONST_VTBL struct INetInboundConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetInboundConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetInboundConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetInboundConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetInboundConnection_GetServerConnectionHandle(This,phRasSrvCon)	\
    (This)->lpVtbl -> GetServerConnectionHandle(This,phRasSrvCon)

#define INetInboundConnection_InitializeAsConfigConnection(This,fStartRemoteAccess)	\
    (This)->lpVtbl -> InitializeAsConfigConnection(This,fStartRemoteAccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetInboundConnection_GetServerConnectionHandle_Proxy( 
    INetInboundConnection * This,
    /* [out] */ ULONG_PTR *phRasSrvCon);


void __RPC_STUB INetInboundConnection_GetServerConnectionHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetInboundConnection_InitializeAsConfigConnection_Proxy( 
    INetInboundConnection * This,
    /* [in] */ BOOL fStartRemoteAccess);


void __RPC_STUB INetInboundConnection_InitializeAsConfigConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetInboundConnection_INTERFACE_DEFINED__ */


#ifndef __INetLanConnection_INTERFACE_DEFINED__
#define __INetLanConnection_INTERFACE_DEFINED__

/* interface INetLanConnection */
/* [unique][uuid][object] */ 

typedef 
enum tagLANCON_INFO_FLAGS
    {	LCIF_NAME	= 0x1,
	LCIF_ICON	= 0x2,
	LCIF_COMP	= 0x8,
	LCIF_ALL	= 0xff
    } 	LANCON_INFO_FLAGS;

typedef struct tagLANCON_INFO
    {
    /* [string] */ LPWSTR szwConnName;
    BOOL fShowIcon;
    GUID guid;
    } 	LANCON_INFO;


EXTERN_C const IID IID_INetLanConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF54-31FE-11D1-AAD2-00805FC1270E")
    INetLanConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ DWORD dwMask,
            /* [out] */ LANCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInfo( 
            /* [in] */ DWORD dwMask,
            /* [in] */ const LANCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceGuid( 
            /* [ref][out] */ GUID *pguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetLanConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetLanConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetLanConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetLanConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            INetLanConnection * This,
            /* [in] */ DWORD dwMask,
            /* [out] */ LANCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            INetLanConnection * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ const LANCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceGuid )( 
            INetLanConnection * This,
            /* [ref][out] */ GUID *pguid);
        
        END_INTERFACE
    } INetLanConnectionVtbl;

    interface INetLanConnection
    {
        CONST_VTBL struct INetLanConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetLanConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetLanConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetLanConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetLanConnection_GetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwMask,pLanConInfo)

#define INetLanConnection_SetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> SetInfo(This,dwMask,pLanConInfo)

#define INetLanConnection_GetDeviceGuid(This,pguid)	\
    (This)->lpVtbl -> GetDeviceGuid(This,pguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetLanConnection_GetInfo_Proxy( 
    INetLanConnection * This,
    /* [in] */ DWORD dwMask,
    /* [out] */ LANCON_INFO *pLanConInfo);


void __RPC_STUB INetLanConnection_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetLanConnection_SetInfo_Proxy( 
    INetLanConnection * This,
    /* [in] */ DWORD dwMask,
    /* [in] */ const LANCON_INFO *pLanConInfo);


void __RPC_STUB INetLanConnection_SetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetLanConnection_GetDeviceGuid_Proxy( 
    INetLanConnection * This,
    /* [ref][out] */ GUID *pguid);


void __RPC_STUB INetLanConnection_GetDeviceGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetLanConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netconp_0324 */
/* [local] */ 


EXTERN_C HRESULT WINAPI HrLanConnectionNameFromGuidOrPath (
  /* [in]    */  const GUID* pguid,
  /* [in]    */  LPCWSTR pszwPath,
  /* [out]   */  LPWSTR  pszwName,
  /* [inout] */  LPDWORD pcchMax);


typedef HRESULT
(WINAPI* PHRLANCONNECTIONNAMEFROMGUIDORPATH)(
    const GUID*,
    LPCWSTR,
    LPWSTR,
    LPDWORD
    );


EXTERN_C HRESULT WINAPI HrPnpInstanceIdFromGuid (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  LPWSTR szwInstance,
  /* [in]    */  UINT cchInstance);


typedef HRESULT
(WINAPI* PHRPNPINSTANCEIDFROMGUID)(
    const GUID*,
    LPWSTR,
    UINT
    );


EXTERN_C HRESULT WINAPI HrGetPnpDeviceStatus (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  NETCON_STATUS *pStatus);


typedef HRESULT
(WINAPI* PHRGETPNPDEVICESTATUS)(
    const GUID*,
    NETCON_STATUS*
    );


EXTERN_C HRESULT WINAPI HrQueryLanMediaState (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  BOOL *pfEnabled);


typedef HRESULT
(WINAPI* PHRQUERYLANMEDIASTATE)(
    const GUID*,
    BOOL*
    );



extern RPC_IF_HANDLE __MIDL_itf_netconp_0324_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0324_v0_0_s_ifspec;

#ifndef __INetSharedAccessConnection_INTERFACE_DEFINED__
#define __INetSharedAccessConnection_INTERFACE_DEFINED__

/* interface INetSharedAccessConnection */
/* [unique][uuid][object] */ 

typedef 
enum tagSHAREDACCESSCON_INFO_FLAGS
    {	SACIF_ICON	= 0x1,
	SACIF_ALL	= 0xff
    } 	SHAREDACCESSCON_INFO_FLAGS;

typedef struct tagSHAREDACCESSCON_INFO
    {
    BOOL fShowIcon;
    } 	SHAREDACCESSCON_INFO;

typedef 
enum tagSAHOST_SERVICES
    {	SAHOST_SERVICE_OSINFO	= 0,
	SAHOST_SERVICE_WANCOMMONINTERFACECONFIG	= SAHOST_SERVICE_OSINFO + 1,
	SAHOST_SERVICE_WANIPCONNECTION	= SAHOST_SERVICE_WANCOMMONINTERFACECONFIG + 1,
	SAHOST_SERVICE_WANPPPCONNECTION	= SAHOST_SERVICE_WANIPCONNECTION + 1,
	SAHOST_SERVICE_NATSTATICPORTMAPPING	= SAHOST_SERVICE_WANPPPCONNECTION + 1,
	SAHOST_SERVICE_MAX	= SAHOST_SERVICE_NATSTATICPORTMAPPING + 1
    } 	SAHOST_SERVICES;


EXTERN_C const IID IID_INetSharedAccessConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF55-31FE-11D1-AAD2-00805FC1270E")
    INetSharedAccessConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ DWORD dwMask,
            /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInfo( 
            /* [in] */ DWORD dwMask,
            /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalAdapterGUID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharedAccessConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetSharedAccessConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetSharedAccessConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetSharedAccessConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            INetSharedAccessConnection * This,
            /* [in] */ DWORD dwMask,
            /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            INetSharedAccessConnection * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAdapterGUID )( 
            INetSharedAccessConnection * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            INetSharedAccessConnection * This,
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **ppService);
        
        END_INTERFACE
    } INetSharedAccessConnectionVtbl;

    interface INetSharedAccessConnection
    {
        CONST_VTBL struct INetSharedAccessConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharedAccessConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetSharedAccessConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetSharedAccessConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetSharedAccessConnection_GetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwMask,pLanConInfo)

#define INetSharedAccessConnection_SetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> SetInfo(This,dwMask,pLanConInfo)

#define INetSharedAccessConnection_GetLocalAdapterGUID(This,pGuid)	\
    (This)->lpVtbl -> GetLocalAdapterGUID(This,pGuid)

#define INetSharedAccessConnection_GetService(This,ulService,ppService)	\
    (This)->lpVtbl -> GetService(This,ulService,ppService)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetInfo_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ DWORD dwMask,
    /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo);


void __RPC_STUB INetSharedAccessConnection_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_SetInfo_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ DWORD dwMask,
    /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo);


void __RPC_STUB INetSharedAccessConnection_SetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetLocalAdapterGUID_Proxy( 
    INetSharedAccessConnection * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB INetSharedAccessConnection_GetLocalAdapterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetService_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ SAHOST_SERVICES ulService,
    /* [out] */ IUPnPService **ppService);


void __RPC_STUB INetSharedAccessConnection_GetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetSharedAccessConnection_INTERFACE_DEFINED__ */


#ifndef __INetLanConnectionWizardUi_INTERFACE_DEFINED__
#define __INetLanConnectionWizardUi_INTERFACE_DEFINED__

/* interface INetLanConnectionWizardUi */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetLanConnectionWizardUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF56-31FE-11D1-AAD2-00805FC1270E")
    INetLanConnectionWizardUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDeviceComponent( 
            /* [in] */ const GUID *pguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetLanConnectionWizardUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetLanConnectionWizardUi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetLanConnectionWizardUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetLanConnectionWizardUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceComponent )( 
            INetLanConnectionWizardUi * This,
            /* [in] */ const GUID *pguid);
        
        END_INTERFACE
    } INetLanConnectionWizardUiVtbl;

    interface INetLanConnectionWizardUi
    {
        CONST_VTBL struct INetLanConnectionWizardUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetLanConnectionWizardUi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetLanConnectionWizardUi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetLanConnectionWizardUi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetLanConnectionWizardUi_SetDeviceComponent(This,pguid)	\
    (This)->lpVtbl -> SetDeviceComponent(This,pguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetLanConnectionWizardUi_SetDeviceComponent_Proxy( 
    INetLanConnectionWizardUi * This,
    /* [in] */ const GUID *pguid);


void __RPC_STUB INetLanConnectionWizardUi_SetDeviceComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetLanConnectionWizardUi_INTERFACE_DEFINED__ */


#ifndef __INetRasConnection_INTERFACE_DEFINED__
#define __INetRasConnection_INTERFACE_DEFINED__

/* interface INetRasConnection */
/* [unique][uuid][object] */ 

typedef struct tagRASCON_INFO
    {
    /* [string] */ LPWSTR pszwPbkFile;
    /* [string] */ LPWSTR pszwEntryName;
    GUID guidId;
    } 	RASCON_INFO;


EXTERN_C const IID IID_INetRasConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF57-31FE-11D1-AAD2-00805FC1270E")
    INetRasConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRasConnectionInfo( 
            /* [out] */ RASCON_INFO *pRasConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRasConnectionInfo( 
            /* [in] */ const RASCON_INFO *pRasConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRasConnectionHandle( 
            /* [out] */ ULONG_PTR *phRasConn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetRasConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetRasConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetRasConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetRasConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasConnectionInfo )( 
            INetRasConnection * This,
            /* [out] */ RASCON_INFO *pRasConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRasConnectionInfo )( 
            INetRasConnection * This,
            /* [in] */ const RASCON_INFO *pRasConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasConnectionHandle )( 
            INetRasConnection * This,
            /* [out] */ ULONG_PTR *phRasConn);
        
        END_INTERFACE
    } INetRasConnectionVtbl;

    interface INetRasConnection
    {
        CONST_VTBL struct INetRasConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetRasConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetRasConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetRasConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetRasConnection_GetRasConnectionInfo(This,pRasConInfo)	\
    (This)->lpVtbl -> GetRasConnectionInfo(This,pRasConInfo)

#define INetRasConnection_SetRasConnectionInfo(This,pRasConInfo)	\
    (This)->lpVtbl -> SetRasConnectionInfo(This,pRasConInfo)

#define INetRasConnection_GetRasConnectionHandle(This,phRasConn)	\
    (This)->lpVtbl -> GetRasConnectionHandle(This,phRasConn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetRasConnection_GetRasConnectionInfo_Proxy( 
    INetRasConnection * This,
    /* [out] */ RASCON_INFO *pRasConInfo);


void __RPC_STUB INetRasConnection_GetRasConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetRasConnection_SetRasConnectionInfo_Proxy( 
    INetRasConnection * This,
    /* [in] */ const RASCON_INFO *pRasConInfo);


void __RPC_STUB INetRasConnection_SetRasConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetRasConnection_GetRasConnectionHandle_Proxy( 
    INetRasConnection * This,
    /* [out] */ ULONG_PTR *phRasConn);


void __RPC_STUB INetRasConnection_GetRasConnectionHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetRasConnection_INTERFACE_DEFINED__ */


#ifndef __INetDefaultConnection_INTERFACE_DEFINED__
#define __INetDefaultConnection_INTERFACE_DEFINED__

/* interface INetDefaultConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetDefaultConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF66-31FE-11D1-AAD2-00805FC1270E")
    INetDefaultConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefault( 
            /* [in] */ BOOL bDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefault( 
            /* [out] */ BOOL *pbDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDefaultConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetDefaultConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetDefaultConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetDefaultConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefault )( 
            INetDefaultConnection * This,
            /* [in] */ BOOL bDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefault )( 
            INetDefaultConnection * This,
            /* [out] */ BOOL *pbDefault);
        
        END_INTERFACE
    } INetDefaultConnectionVtbl;

    interface INetDefaultConnection
    {
        CONST_VTBL struct INetDefaultConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDefaultConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetDefaultConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetDefaultConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetDefaultConnection_SetDefault(This,bDefault)	\
    (This)->lpVtbl -> SetDefault(This,bDefault)

#define INetDefaultConnection_GetDefault(This,pbDefault)	\
    (This)->lpVtbl -> GetDefault(This,pbDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetDefaultConnection_SetDefault_Proxy( 
    INetDefaultConnection * This,
    /* [in] */ BOOL bDefault);


void __RPC_STUB INetDefaultConnection_SetDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetDefaultConnection_GetDefault_Proxy( 
    INetDefaultConnection * This,
    /* [out] */ BOOL *pbDefault);


void __RPC_STUB INetDefaultConnection_GetDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetDefaultConnection_INTERFACE_DEFINED__ */


#ifndef __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__
#define __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__

/* interface INetRasConnectionIpUiInfo */
/* [unique][uuid][object] */ 

typedef 
enum tagRASCON_IPUI_FLAGS
    {	RCUIF_PPP	= 0x1,
	RCUIF_SLIP	= 0x2,
	RCUIF_USE_IP_ADDR	= 0x4,
	RCUIF_USE_NAME_SERVERS	= 0x8,
	RCUIF_USE_REMOTE_GATEWAY	= 0x10,
	RCUIF_USE_HEADER_COMPRESSION	= 0x20,
	RCUIF_VPN	= 0x40,
	RCUIF_DEMAND_DIAL	= 0x80,
	RCUIF_USE_DISABLE_REGISTER_DNS	= 0x100,
	RCUIF_USE_PRIVATE_DNS_SUFFIX	= 0x200,
	RCUIF_NOT_ADMIN	= 0x400,
	RCUIF_ENABLE_NBT	= 0x800
    } 	RASCON_UIINFO_FLAGS;

typedef struct tagRASCON_IPUI
    {
    GUID guidConnection;
    DWORD dwFlags;
    WCHAR pszwIpAddr[ 16 ];
    WCHAR pszwDnsAddr[ 16 ];
    WCHAR pszwDns2Addr[ 16 ];
    WCHAR pszwWinsAddr[ 16 ];
    WCHAR pszwWins2Addr[ 16 ];
    DWORD dwFrameSize;
    WCHAR pszwDnsSuffix[ 256 ];
    } 	RASCON_IPUI;


EXTERN_C const IID IID_INetRasConnectionIpUiInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF58-31FE-11D1-AAD2-00805FC1270E")
    INetRasConnectionIpUiInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUiInfo( 
            /* [out] */ RASCON_IPUI *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetRasConnectionIpUiInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetRasConnectionIpUiInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetRasConnectionIpUiInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetRasConnectionIpUiInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUiInfo )( 
            INetRasConnectionIpUiInfo * This,
            /* [out] */ RASCON_IPUI *pInfo);
        
        END_INTERFACE
    } INetRasConnectionIpUiInfoVtbl;

    interface INetRasConnectionIpUiInfo
    {
        CONST_VTBL struct INetRasConnectionIpUiInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetRasConnectionIpUiInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetRasConnectionIpUiInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetRasConnectionIpUiInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetRasConnectionIpUiInfo_GetUiInfo(This,pInfo)	\
    (This)->lpVtbl -> GetUiInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetRasConnectionIpUiInfo_GetUiInfo_Proxy( 
    INetRasConnectionIpUiInfo * This,
    /* [out] */ RASCON_IPUI *pInfo);


void __RPC_STUB INetRasConnectionIpUiInfo_GetUiInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__ */


#ifndef __IPersistNetConnection_INTERFACE_DEFINED__
#define __IPersistNetConnection_INTERFACE_DEFINED__

/* interface IPersistNetConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF59-31FE-11D1-AAD2-00805FC1270E")
    IPersistNetConnection : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
            /* [out] */ ULONG *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [size_is][in] */ const BYTE *pbBuf,
            /* [in] */ ULONG cbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [size_is][out] */ BYTE *pbBuf,
            /* [in] */ ULONG cbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistNetConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistNetConnection * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
            IPersistNetConnection * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistNetConnection * This,
            /* [size_is][in] */ const BYTE *pbBuf,
            /* [in] */ ULONG cbSize);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistNetConnection * This,
            /* [size_is][out] */ BYTE *pbBuf,
            /* [in] */ ULONG cbSize);
        
        END_INTERFACE
    } IPersistNetConnectionVtbl;

    interface IPersistNetConnection
    {
        CONST_VTBL struct IPersistNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistNetConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistNetConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistNetConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistNetConnection_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistNetConnection_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)

#define IPersistNetConnection_Load(This,pbBuf,cbSize)	\
    (This)->lpVtbl -> Load(This,pbBuf,cbSize)

#define IPersistNetConnection_Save(This,pbBuf,cbSize)	\
    (This)->lpVtbl -> Save(This,pbBuf,cbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistNetConnection_GetSizeMax_Proxy( 
    IPersistNetConnection * This,
    /* [out] */ ULONG *pcbSize);


void __RPC_STUB IPersistNetConnection_GetSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistNetConnection_Load_Proxy( 
    IPersistNetConnection * This,
    /* [size_is][in] */ const BYTE *pbBuf,
    /* [in] */ ULONG cbSize);


void __RPC_STUB IPersistNetConnection_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistNetConnection_Save_Proxy( 
    IPersistNetConnection * This,
    /* [size_is][out] */ BYTE *pbBuf,
    /* [in] */ ULONG cbSize);


void __RPC_STUB IPersistNetConnection_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistNetConnection_INTERFACE_DEFINED__ */


#ifndef __INetConnectionBrandingInfo_INTERFACE_DEFINED__
#define __INetConnectionBrandingInfo_INTERFACE_DEFINED__

/* interface INetConnectionBrandingInfo */
/* [unique][uuid][object] */ 

typedef struct tagCON_BRANDING_INFO
    {
    /* [string] */ LPWSTR szwLargeIconPath;
    /* [string] */ LPWSTR szwSmallIconPath;
    /* [string] */ LPWSTR szwTrayIconPath;
    } 	CON_BRANDING_INFO;

typedef struct tagCON_TRAY_MENU_ENTRY
    {
    /* [string] */ LPWSTR szwMenuText;
    /* [string] */ LPWSTR szwMenuCmdLine;
    /* [string] */ LPWSTR szwMenuParams;
    } 	CON_TRAY_MENU_ENTRY;

typedef struct tagCON_TRAY_MENU_DATA
    {
    DWORD dwCount;
    /* [size_is] */ CON_TRAY_MENU_ENTRY *pctme;
    } 	CON_TRAY_MENU_DATA;


EXTERN_C const IID IID_INetConnectionBrandingInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5B-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionBrandingInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBrandingIconPaths( 
            /* [out] */ CON_BRANDING_INFO **ppConBrandInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrayMenuEntries( 
            /* [out] */ CON_TRAY_MENU_DATA **ppMenuData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionBrandingInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionBrandingInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionBrandingInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionBrandingInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrandingIconPaths )( 
            INetConnectionBrandingInfo * This,
            /* [out] */ CON_BRANDING_INFO **ppConBrandInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTrayMenuEntries )( 
            INetConnectionBrandingInfo * This,
            /* [out] */ CON_TRAY_MENU_DATA **ppMenuData);
        
        END_INTERFACE
    } INetConnectionBrandingInfoVtbl;

    interface INetConnectionBrandingInfo
    {
        CONST_VTBL struct INetConnectionBrandingInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionBrandingInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionBrandingInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionBrandingInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionBrandingInfo_GetBrandingIconPaths(This,ppConBrandInfo)	\
    (This)->lpVtbl -> GetBrandingIconPaths(This,ppConBrandInfo)

#define INetConnectionBrandingInfo_GetTrayMenuEntries(This,ppMenuData)	\
    (This)->lpVtbl -> GetTrayMenuEntries(This,ppMenuData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionBrandingInfo_GetBrandingIconPaths_Proxy( 
    INetConnectionBrandingInfo * This,
    /* [out] */ CON_BRANDING_INFO **ppConBrandInfo);


void __RPC_STUB INetConnectionBrandingInfo_GetBrandingIconPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionBrandingInfo_GetTrayMenuEntries_Proxy( 
    INetConnectionBrandingInfo * This,
    /* [out] */ CON_TRAY_MENU_DATA **ppMenuData);


void __RPC_STUB INetConnectionBrandingInfo_GetTrayMenuEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionBrandingInfo_INTERFACE_DEFINED__ */


#ifndef __INetConnectionManager2_INTERFACE_DEFINED__
#define __INetConnectionManager2_INTERFACE_DEFINED__

/* interface INetConnectionManager2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF69-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionManager2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumConnectionProperties( 
            /* [out] */ LPSAFEARRAY *ppsaConnectionProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumConnectionProperties )( 
            INetConnectionManager2 * This,
            /* [out] */ LPSAFEARRAY *ppsaConnectionProperties);
        
        END_INTERFACE
    } INetConnectionManager2Vtbl;

    interface INetConnectionManager2
    {
        CONST_VTBL struct INetConnectionManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionManager2_EnumConnectionProperties(This,ppsaConnectionProperties)	\
    (This)->lpVtbl -> EnumConnectionProperties(This,ppsaConnectionProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionManager2_EnumConnectionProperties_Proxy( 
    INetConnectionManager2 * This,
    /* [out] */ LPSAFEARRAY *ppsaConnectionProperties);


void __RPC_STUB INetConnectionManager2_EnumConnectionProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionManager2_INTERFACE_DEFINED__ */


#ifndef __INetConnection2_INTERFACE_DEFINED__
#define __INetConnection2_INTERFACE_DEFINED__

/* interface INetConnection2 */
/* [unique][uuid][object] */ 

typedef 
enum tagNETCON_SUBMEDIATYPE
    {	NCSM_NONE	= 0,
	NCSM_LAN	= NCSM_NONE + 1,
	NCSM_WIRELESS	= NCSM_LAN + 1,
	NCSM_ATM	= NCSM_WIRELESS + 1,
	NCSM_ELAN	= NCSM_ATM + 1,
	NCSM_1394	= NCSM_ELAN + 1,
	NCSM_DIRECT	= NCSM_1394 + 1,
	NCSM_IRDA	= NCSM_DIRECT + 1,
	NCSM_CM	= NCSM_IRDA + 1
    } 	NETCON_SUBMEDIATYPE;

typedef struct tagNETCON_PROPERTIES_EX
    {
    DWORD dwSize;
    GUID guidId;
    BSTR bstrName;
    BSTR bstrDeviceName;
    NETCON_STATUS ncStatus;
    NETCON_MEDIATYPE ncMediaType;
    NETCON_SUBMEDIATYPE ncSubMediaType;
    DWORD dwCharacter;
    CLSID clsidThisObject;
    CLSID clsidUiObject;
    BSTR bstrPhoneOrHostAddress;
    BSTR bstrPersistData;
    } 	NETCON_PROPERTIES_EX;


EXTERN_C const IID IID_INetConnection2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF6A-31FE-11D1-AAD2-00805FC1270E")
    INetConnection2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertiesEx( 
            /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnection2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnection2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnection2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertiesEx )( 
            INetConnection2 * This,
            /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx);
        
        END_INTERFACE
    } INetConnection2Vtbl;

    interface INetConnection2
    {
        CONST_VTBL struct INetConnection2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnection2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnection2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnection2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnection2_GetPropertiesEx(This,ppConnectionPropertiesEx)	\
    (This)->lpVtbl -> GetPropertiesEx(This,ppConnectionPropertiesEx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnection2_GetPropertiesEx_Proxy( 
    INetConnection2 * This,
    /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx);


void __RPC_STUB INetConnection2_GetPropertiesEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnection2_INTERFACE_DEFINED__ */


#ifndef __INetConnectionNotifySink_INTERFACE_DEFINED__
#define __INetConnectionNotifySink_INTERFACE_DEFINED__

/* interface INetConnectionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5C-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectionAdded( 
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionBandWidthChange( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionDeleted( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionModified( 
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionRenamed( 
            /* [in] */ const GUID *pguidId,
            /* [string][in] */ LPCWSTR pszwNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionStatusChange( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ NETCON_STATUS Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionAddressChange( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowBalloon( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableEvents( 
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAdded )( 
            INetConnectionNotifySink * This,
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionBandWidthChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionDeleted )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionModified )( 
            INetConnectionNotifySink * This,
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionRenamed )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [string][in] */ LPCWSTR pszwNewName);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionStatusChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ NETCON_STATUS Status);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshAll )( 
            INetConnectionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAddressChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ShowBalloon )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText);
        
        HRESULT ( STDMETHODCALLTYPE *DisableEvents )( 
            INetConnectionNotifySink * This,
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout);
        
        END_INTERFACE
    } INetConnectionNotifySinkVtbl;

    interface INetConnectionNotifySink
    {
        CONST_VTBL struct INetConnectionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionNotifySink_ConnectionAdded(This,pPropsEx)	\
    (This)->lpVtbl -> ConnectionAdded(This,pPropsEx)

#define INetConnectionNotifySink_ConnectionBandWidthChange(This,pguidId)	\
    (This)->lpVtbl -> ConnectionBandWidthChange(This,pguidId)

#define INetConnectionNotifySink_ConnectionDeleted(This,pguidId)	\
    (This)->lpVtbl -> ConnectionDeleted(This,pguidId)

#define INetConnectionNotifySink_ConnectionModified(This,pPropsEx)	\
    (This)->lpVtbl -> ConnectionModified(This,pPropsEx)

#define INetConnectionNotifySink_ConnectionRenamed(This,pguidId,pszwNewName)	\
    (This)->lpVtbl -> ConnectionRenamed(This,pguidId,pszwNewName)

#define INetConnectionNotifySink_ConnectionStatusChange(This,pguidId,Status)	\
    (This)->lpVtbl -> ConnectionStatusChange(This,pguidId,Status)

#define INetConnectionNotifySink_RefreshAll(This)	\
    (This)->lpVtbl -> RefreshAll(This)

#define INetConnectionNotifySink_ConnectionAddressChange(This,pguidId)	\
    (This)->lpVtbl -> ConnectionAddressChange(This,pguidId)

#define INetConnectionNotifySink_ShowBalloon(This,pguidId,szCookie,szBalloonText)	\
    (This)->lpVtbl -> ShowBalloon(This,pguidId,szCookie,szBalloonText)

#define INetConnectionNotifySink_DisableEvents(This,fDisable,ulDisableTimeout)	\
    (This)->lpVtbl -> DisableEvents(This,fDisable,ulDisableTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionAdded_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);


void __RPC_STUB INetConnectionNotifySink_ConnectionAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionBandWidthChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionBandWidthChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionDeleted_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionModified_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);


void __RPC_STUB INetConnectionNotifySink_ConnectionModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionRenamed_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [string][in] */ LPCWSTR pszwNewName);


void __RPC_STUB INetConnectionNotifySink_ConnectionRenamed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionStatusChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ NETCON_STATUS Status);


void __RPC_STUB INetConnectionNotifySink_ConnectionStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_RefreshAll_Proxy( 
    INetConnectionNotifySink * This);


void __RPC_STUB INetConnectionNotifySink_RefreshAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionAddressChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionAddressChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ShowBalloon_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const BSTR szCookie,
    /* [in] */ const BSTR szBalloonText);


void __RPC_STUB INetConnectionNotifySink_ShowBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_DisableEvents_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const BOOL fDisable,
    /* [in] */ const ULONG ulDisableTimeout);


void __RPC_STUB INetConnectionNotifySink_DisableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionNotifySink_INTERFACE_DEFINED__ */


#ifndef __INetConnectionUiUtilities_INTERFACE_DEFINED__
#define __INetConnectionUiUtilities_INTERFACE_DEFINED__

/* interface INetConnectionUiUtilities */
/* [unique][uuid][object][local] */ 

typedef 
enum tagQUERY_USER_FOR_REBOOT_FLAGS
    {	QUFR_PROMPT	= 0x1,
	QUFR_REBOOT	= 0x2
    } 	QUERY_USER_FOR_REBOOT_FLAGS;

typedef 
enum tagNCPERM_FLAGS
    {	NCPERM_NewConnectionWizard	= 0,
	NCPERM_Statistics	= 1,
	NCPERM_AddRemoveComponents	= 2,
	NCPERM_RasConnect	= 3,
	NCPERM_LanConnect	= 4,
	NCPERM_DeleteConnection	= 5,
	NCPERM_DeleteAllUserConnection	= 6,
	NCPERM_RenameConnection	= 7,
	NCPERM_RenameMyRasConnection	= 8,
	NCPERM_ChangeBindState	= 9,
	NCPERM_AdvancedSettings	= 10,
	NCPERM_DialupPrefs	= 11,
	NCPERM_LanChangeProperties	= 12,
	NCPERM_RasChangeProperties	= 13,
	NCPERM_LanProperties	= 14,
	NCPERM_RasMyProperties	= 15,
	NCPERM_RasAllUserProperties	= 16,
	NCPERM_ShowSharedAccessUi	= 17,
	NCPERM_AllowAdvancedTCPIPConfig	= 18,
	NCPERM_OpenConnectionsFolder	= 19,
	NCPERM_PersonalFirewallConfig	= 20,
	NCPERM_AllowNetBridge_NLA	= 21,
	NCPERM_ICSClientApp	= 22,
	NCPERM_EnDisComponentsAllUserRas	= 23,
	NCPERM_EnDisComponentsMyRas	= 24,
	NCPERM_ChangeMyRasProperties	= 25,
	NCPERM_ChangeAllUserRasProperties	= 26,
	NCPERM_RenameLanConnection	= 27,
	NCPERM_RenameAllUserRasConnection	= 28,
	NCPERM_IpcfgOperation	= 29,
	NCPERM_Repair	= 30
    } 	NCPERM_FLAGS;


EXTERN_C const IID IID_INetConnectionUiUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5E-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionUiUtilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryUserAndRemoveComponent( 
            HWND hwndParent,
            INetCfg *pnc,
            INetCfgComponent *pncc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryUserForReboot( 
            HWND hwndParent,
            LPCTSTR pszCaption,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayAddComponentDialog( 
            HWND hwndParent,
            INetCfg *pnc,
            CI_FILTER_INFO *pcfi) = 0;
        
        virtual BOOL STDMETHODCALLTYPE UserHasPermission( 
            DWORD dwPerm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionUiUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionUiUtilities * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionUiUtilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionUiUtilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUserAndRemoveComponent )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            INetCfg *pnc,
            INetCfgComponent *pncc);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUserForReboot )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            LPCTSTR pszCaption,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayAddComponentDialog )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            INetCfg *pnc,
            CI_FILTER_INFO *pcfi);
        
        BOOL ( STDMETHODCALLTYPE *UserHasPermission )( 
            INetConnectionUiUtilities * This,
            DWORD dwPerm);
        
        END_INTERFACE
    } INetConnectionUiUtilitiesVtbl;

    interface INetConnectionUiUtilities
    {
        CONST_VTBL struct INetConnectionUiUtilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionUiUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionUiUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionUiUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionUiUtilities_QueryUserAndRemoveComponent(This,hwndParent,pnc,pncc)	\
    (This)->lpVtbl -> QueryUserAndRemoveComponent(This,hwndParent,pnc,pncc)

#define INetConnectionUiUtilities_QueryUserForReboot(This,hwndParent,pszCaption,dwFlags)	\
    (This)->lpVtbl -> QueryUserForReboot(This,hwndParent,pszCaption,dwFlags)

#define INetConnectionUiUtilities_DisplayAddComponentDialog(This,hwndParent,pnc,pcfi)	\
    (This)->lpVtbl -> DisplayAddComponentDialog(This,hwndParent,pnc,pcfi)

#define INetConnectionUiUtilities_UserHasPermission(This,dwPerm)	\
    (This)->lpVtbl -> UserHasPermission(This,dwPerm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_QueryUserAndRemoveComponent_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    INetCfg *pnc,
    INetCfgComponent *pncc);


void __RPC_STUB INetConnectionUiUtilities_QueryUserAndRemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_QueryUserForReboot_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    LPCTSTR pszCaption,
    DWORD dwFlags);


void __RPC_STUB INetConnectionUiUtilities_QueryUserForReboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_DisplayAddComponentDialog_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    INetCfg *pnc,
    CI_FILTER_INFO *pcfi);


void __RPC_STUB INetConnectionUiUtilities_DisplayAddComponentDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE INetConnectionUiUtilities_UserHasPermission_Proxy( 
    INetConnectionUiUtilities * This,
    DWORD dwPerm);


void __RPC_STUB INetConnectionUiUtilities_UserHasPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionUiUtilities_INTERFACE_DEFINED__ */


#ifndef __INetConnectionRefresh_INTERFACE_DEFINED__
#define __INetConnectionRefresh_INTERFACE_DEFINED__

/* interface INetConnectionRefresh */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionRefresh;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5F-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionRefresh : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionAdded( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionDeleted( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionModified( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionRenamed( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionStatusChanged( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const NETCON_STATUS ncs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowBalloon( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableEvents( 
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionRefreshVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionRefresh * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionRefresh * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionRefresh * This);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshAll )( 
            INetConnectionRefresh * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAdded )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionDeleted )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionModified )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionRenamed )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionStatusChanged )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const NETCON_STATUS ncs);
        
        HRESULT ( STDMETHODCALLTYPE *ShowBalloon )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText);
        
        HRESULT ( STDMETHODCALLTYPE *DisableEvents )( 
            INetConnectionRefresh * This,
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout);
        
        END_INTERFACE
    } INetConnectionRefreshVtbl;

    interface INetConnectionRefresh
    {
        CONST_VTBL struct INetConnectionRefreshVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionRefresh_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionRefresh_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionRefresh_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionRefresh_RefreshAll(This)	\
    (This)->lpVtbl -> RefreshAll(This)

#define INetConnectionRefresh_ConnectionAdded(This,pConnection)	\
    (This)->lpVtbl -> ConnectionAdded(This,pConnection)

#define INetConnectionRefresh_ConnectionDeleted(This,pguidId)	\
    (This)->lpVtbl -> ConnectionDeleted(This,pguidId)

#define INetConnectionRefresh_ConnectionModified(This,pConnection)	\
    (This)->lpVtbl -> ConnectionModified(This,pConnection)

#define INetConnectionRefresh_ConnectionRenamed(This,pConnection)	\
    (This)->lpVtbl -> ConnectionRenamed(This,pConnection)

#define INetConnectionRefresh_ConnectionStatusChanged(This,pguidId,ncs)	\
    (This)->lpVtbl -> ConnectionStatusChanged(This,pguidId,ncs)

#define INetConnectionRefresh_ShowBalloon(This,pguidId,szCookie,szBalloonText)	\
    (This)->lpVtbl -> ShowBalloon(This,pguidId,szCookie,szBalloonText)

#define INetConnectionRefresh_DisableEvents(This,fDisable,ulDisableTimeout)	\
    (This)->lpVtbl -> DisableEvents(This,fDisable,ulDisableTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionRefresh_RefreshAll_Proxy( 
    INetConnectionRefresh * This);


void __RPC_STUB INetConnectionRefresh_RefreshAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionAdded_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionDeleted_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionRefresh_ConnectionDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionModified_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionRenamed_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionRenamed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionStatusChanged_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const NETCON_STATUS ncs);


void __RPC_STUB INetConnectionRefresh_ConnectionStatusChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ShowBalloon_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const BSTR szCookie,
    /* [in] */ const BSTR szBalloonText);


void __RPC_STUB INetConnectionRefresh_ShowBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_DisableEvents_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const BOOL fDisable,
    /* [in] */ const ULONG ulDisableTimeout);


void __RPC_STUB INetConnectionRefresh_DisableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionRefresh_INTERFACE_DEFINED__ */


#ifndef __INetConnectionCMUtil_INTERFACE_DEFINED__
#define __INetConnectionCMUtil_INTERFACE_DEFINED__

/* interface INetConnectionCMUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionCMUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF60-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionCMUtil : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapCMHiddenConnectionToOwner( 
            /* [in] */ REFGUID guidHidden,
            /* [out] */ GUID *pguidOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionCMUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionCMUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionCMUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionCMUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapCMHiddenConnectionToOwner )( 
            INetConnectionCMUtil * This,
            /* [in] */ REFGUID guidHidden,
            /* [out] */ GUID *pguidOwner);
        
        END_INTERFACE
    } INetConnectionCMUtilVtbl;

    interface INetConnectionCMUtil
    {
        CONST_VTBL struct INetConnectionCMUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionCMUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionCMUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionCMUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionCMUtil_MapCMHiddenConnectionToOwner(This,guidHidden,pguidOwner)	\
    (This)->lpVtbl -> MapCMHiddenConnectionToOwner(This,guidHidden,pguidOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionCMUtil_MapCMHiddenConnectionToOwner_Proxy( 
    INetConnectionCMUtil * This,
    /* [in] */ REFGUID guidHidden,
    /* [out] */ GUID *pguidOwner);


void __RPC_STUB INetConnectionCMUtil_MapCMHiddenConnectionToOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionCMUtil_INTERFACE_DEFINED__ */


#ifndef __INetConnectionHNetUtil_INTERFACE_DEFINED__
#define __INetConnectionHNetUtil_INTERFACE_DEFINED__

/* interface INetConnectionHNetUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionHNetUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF64-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionHNetUtil : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyUpdate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionHNetUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionHNetUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionHNetUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionHNetUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyUpdate )( 
            INetConnectionHNetUtil * This);
        
        END_INTERFACE
    } INetConnectionHNetUtilVtbl;

    interface INetConnectionHNetUtil
    {
        CONST_VTBL struct INetConnectionHNetUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionHNetUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionHNetUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionHNetUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionHNetUtil_NotifyUpdate(This)	\
    (This)->lpVtbl -> NotifyUpdate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionHNetUtil_NotifyUpdate_Proxy( 
    INetConnectionHNetUtil * This);


void __RPC_STUB INetConnectionHNetUtil_NotifyUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionHNetUtil_INTERFACE_DEFINED__ */


#ifndef __INetConnectionSysTray_INTERFACE_DEFINED__
#define __INetConnectionSysTray_INTERFACE_DEFINED__

/* interface INetConnectionSysTray */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionSysTray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF65-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionSysTray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowIcon( 
            /* [in] */ const BOOL bShowIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IconStateChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionSysTrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionSysTray * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionSysTray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionSysTray * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowIcon )( 
            INetConnectionSysTray * This,
            /* [in] */ const BOOL bShowIcon);
        
        HRESULT ( STDMETHODCALLTYPE *IconStateChanged )( 
            INetConnectionSysTray * This);
        
        END_INTERFACE
    } INetConnectionSysTrayVtbl;

    interface INetConnectionSysTray
    {
        CONST_VTBL struct INetConnectionSysTrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionSysTray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionSysTray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionSysTray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionSysTray_ShowIcon(This,bShowIcon)	\
    (This)->lpVtbl -> ShowIcon(This,bShowIcon)

#define INetConnectionSysTray_IconStateChanged(This)	\
    (This)->lpVtbl -> IconStateChanged(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionSysTray_ShowIcon_Proxy( 
    INetConnectionSysTray * This,
    /* [in] */ const BOOL bShowIcon);


void __RPC_STUB INetConnectionSysTray_ShowIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionSysTray_IconStateChanged_Proxy( 
    INetConnectionSysTray * This);


void __RPC_STUB INetConnectionSysTray_IconStateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionSysTray_INTERFACE_DEFINED__ */


#ifndef __INetMachinePolicies_INTERFACE_DEFINED__
#define __INetMachinePolicies_INTERFACE_DEFINED__

/* interface INetMachinePolicies */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetMachinePolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF68-31FE-11D1-AAD2-00805FC1270E")
    INetMachinePolicies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VerifyPermission( 
            /* [in] */ const DWORD ulPerm,
            /* [out] */ BOOL *pPermission) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetMachinePoliciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetMachinePolicies * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetMachinePolicies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetMachinePolicies * This);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermission )( 
            INetMachinePolicies * This,
            /* [in] */ const DWORD ulPerm,
            /* [out] */ BOOL *pPermission);
        
        END_INTERFACE
    } INetMachinePoliciesVtbl;

    interface INetMachinePolicies
    {
        CONST_VTBL struct INetMachinePoliciesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetMachinePolicies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetMachinePolicies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetMachinePolicies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetMachinePolicies_VerifyPermission(This,ulPerm,pPermission)	\
    (This)->lpVtbl -> VerifyPermission(This,ulPerm,pPermission)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetMachinePolicies_VerifyPermission_Proxy( 
    INetMachinePolicies * This,
    /* [in] */ const DWORD ulPerm,
    /* [out] */ BOOL *pPermission);


void __RPC_STUB INetMachinePolicies_VerifyPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetMachinePolicies_INTERFACE_DEFINED__ */


#ifndef __INetConnectionManagerDebug_INTERFACE_DEFINED__
#define __INetConnectionManagerDebug_INTERFACE_DEFINED__

/* interface INetConnectionManagerDebug */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionManagerDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5D-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionManagerDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyTestStart( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyTestStop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionManagerDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionManagerDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionManagerDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionManagerDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyTestStart )( 
            INetConnectionManagerDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyTestStop )( 
            INetConnectionManagerDebug * This);
        
        END_INTERFACE
    } INetConnectionManagerDebugVtbl;

    interface INetConnectionManagerDebug
    {
        CONST_VTBL struct INetConnectionManagerDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionManagerDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionManagerDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionManagerDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionManagerDebug_NotifyTestStart(This)	\
    (This)->lpVtbl -> NotifyTestStart(This)

#define INetConnectionManagerDebug_NotifyTestStop(This)	\
    (This)->lpVtbl -> NotifyTestStop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionManagerDebug_NotifyTestStart_Proxy( 
    INetConnectionManagerDebug * This);


void __RPC_STUB INetConnectionManagerDebug_NotifyTestStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionManagerDebug_NotifyTestStop_Proxy( 
    INetConnectionManagerDebug * This);


void __RPC_STUB INetConnectionManagerDebug_NotifyTestStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionManagerDebug_INTERFACE_DEFINED__ */


#ifndef __ISharedAccessBeacon_INTERFACE_DEFINED__
#define __ISharedAccessBeacon_INTERFACE_DEFINED__

/* interface ISharedAccessBeacon */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISharedAccessBeacon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF6B-31FE-11D1-AAD2-00805FC1270E")
    ISharedAccessBeacon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ NETCON_MEDIATYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalAdapterGUID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **__MIDL_0018) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueDeviceName( 
            /* [out] */ BSTR *pUDN) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedAccessBeaconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedAccessBeacon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedAccessBeacon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedAccessBeacon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            ISharedAccessBeacon * This,
            /* [out] */ NETCON_MEDIATYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAdapterGUID )( 
            ISharedAccessBeacon * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            ISharedAccessBeacon * This,
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **__MIDL_0018);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueDeviceName )( 
            ISharedAccessBeacon * This,
            /* [out] */ BSTR *pUDN);
        
        END_INTERFACE
    } ISharedAccessBeaconVtbl;

    interface ISharedAccessBeacon
    {
        CONST_VTBL struct ISharedAccessBeaconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedAccessBeacon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedAccessBeacon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedAccessBeacon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedAccessBeacon_GetMediaType(This,pMediaType)	\
    (This)->lpVtbl -> GetMediaType(This,pMediaType)

#define ISharedAccessBeacon_GetLocalAdapterGUID(This,pGuid)	\
    (This)->lpVtbl -> GetLocalAdapterGUID(This,pGuid)

#define ISharedAccessBeacon_GetService(This,ulService,__MIDL_0018)	\
    (This)->lpVtbl -> GetService(This,ulService,__MIDL_0018)

#define ISharedAccessBeacon_GetUniqueDeviceName(This,pUDN)	\
    (This)->lpVtbl -> GetUniqueDeviceName(This,pUDN)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetMediaType_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ NETCON_MEDIATYPE *pMediaType);


void __RPC_STUB ISharedAccessBeacon_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetLocalAdapterGUID_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB ISharedAccessBeacon_GetLocalAdapterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetService_Proxy( 
    ISharedAccessBeacon * This,
    /* [in] */ SAHOST_SERVICES ulService,
    /* [out] */ IUPnPService **__MIDL_0018);


void __RPC_STUB ISharedAccessBeacon_GetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetUniqueDeviceName_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ BSTR *pUDN);


void __RPC_STUB ISharedAccessBeacon_GetUniqueDeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedAccessBeacon_INTERFACE_DEFINED__ */


#ifndef __ISharedAccessBeaconFinder_INTERFACE_DEFINED__
#define __ISharedAccessBeaconFinder_INTERFACE_DEFINED__

/* interface ISharedAccessBeaconFinder */
/* [object][unique][uuid] */ 

typedef struct tagSHAREDACCESS_HOST_INFO
    {
    BSTR WANAccessType;
    IUPnPService *pOSInfo;
    IUPnPService *pWANCommonInterfaceConfig;
    IUPnPService *pWANConnection;
    GUID LocalAdapterGuid;
    } 	SHAREDACCESS_HOST_INFO;


EXTERN_C const IID IID_ISharedAccessBeaconFinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF67-31FE-11D1-AAD2-00805FC1270E")
    ISharedAccessBeaconFinder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSharedAccessBeacon( 
            /* [in] */ BSTR DeviceId,
            /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedAccessBeaconFinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedAccessBeaconFinder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedAccessBeaconFinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedAccessBeaconFinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharedAccessBeacon )( 
            ISharedAccessBeaconFinder * This,
            /* [in] */ BSTR DeviceId,
            /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon);
        
        END_INTERFACE
    } ISharedAccessBeaconFinderVtbl;

    interface ISharedAccessBeaconFinder
    {
        CONST_VTBL struct ISharedAccessBeaconFinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedAccessBeaconFinder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedAccessBeaconFinder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedAccessBeaconFinder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedAccessBeaconFinder_GetSharedAccessBeacon(This,DeviceId,ppSharedAccessBeacon)	\
    (This)->lpVtbl -> GetSharedAccessBeacon(This,DeviceId,ppSharedAccessBeacon)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISharedAccessBeaconFinder_GetSharedAccessBeacon_Proxy( 
    ISharedAccessBeaconFinder * This,
    /* [in] */ BSTR DeviceId,
    /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon);


void __RPC_STUB ISharedAccessBeaconFinder_GetSharedAccessBeacon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedAccessBeaconFinder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netconp_0343 */
/* [local] */ 


EXTERN_C HRESULT WINAPI HrGetIconFromMediaType (
  /* [in]    */  DWORD dwIconSize,
  /* [in]    */  NETCON_MEDIATYPE ncm,
  /* [in]    */  NETCON_SUBMEDIATYPE ncsm,
  /* [in]    */  DWORD dwConnectionIcon,
  /* [in]    */  DWORD dwCharacteristics,
  /* [out]   */  HICON *phIcon);



extern RPC_IF_HANDLE __MIDL_itf_netconp_0343_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0343_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netlogon.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netlogon.h

Abstract:

    Definition of mailslot messages and Internal APIs to the Netlogon service.

    This file is shared by the Netlogon service, the Workstation service,
    the XACT server, and the MSV1_0 authentication package.

Author:

    Cliff Van Dyke (cliffv) 16-May-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    16-May-1991 (cliffv)
        Ported from LanMan 2.1.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

#ifndef _NETLOGON_H_
#define _NETLOGON_H_

#include <smbtypes.h>    // need by smbgtpt.h
#include <smbgtpt.h>    // SmbPutUlong

//
// define version bit
//
// All netlogon messages that are compatible to NT VERSION 1 will
// have the following bit set in the version field of the message
// otherwise the message will not be processed by this version
// of software. In addition to this the message should carry NT
// token in it.
//

#define NETLOGON_NT_VERSION_1   0x00000001

//
// Starting in NT 5.0, some messages became more DS/DNS aware.  Those
//  messages additionally have the following bits set to indicate the
//  presence of the additional fields.

#define NETLOGON_NT_VERSION_5   0x00000002

//
// Starting in NT 5.0, some client can handle the _EX version of
// logon responses.

#define NETLOGON_NT_VERSION_5EX 0x00000004

//
// 5EX responses in mailslot messages will also include the IP address of
//  the responding DC.
//

#define NETLOGON_NT_VERSION_5EX_WITH_IP 0x00000008

//
// Set on Logon requests to indicate caller is querying for a PDC.
#define NETLOGON_NT_VERSION_PDC     0x10000000

//
// Set on Logon requests to indicate caller is querying for a DC running IP
#define NETLOGON_NT_VERSION_IP      0x20000000

//
// Set on Logon requests to indicate caller is local machine
#define NETLOGON_NT_VERSION_LOCAL   0x40000000

//
// Set on Logon requests to indicate caller is querying for a GC.
#define NETLOGON_NT_VERSION_GC      0x80000000

//
// Set on Logon requests to indicate caller wants to avoid NT4.0 emulation.
#define NETLOGON_NT_VERSION_AVOID_NT4EMUL  0x01000000

//
//

//
// Name of the mailslot the Netlogon service listens to.
//

#define NETLOGON_LM_MAILSLOT_W      L"\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_A      "\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_LEN    22  // Length in characters (w/o NULL)

#define NETLOGON_NT_MAILSLOT_W      L"\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_A      "\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_LEN    21 // Length in characters (w/o NULL)

//
// Opcodes for netlogon mailslot data
//

#define LOGON_REQUEST               0   // LM1.0/2.0 LOGON Request from client
#define LOGON_RESPONSE              1   // LM1.0 Response to LOGON_REQUEST
#define LOGON_CENTRAL_QUERY         2   // LM1.0 QUERY for centralized init
#define LOGON_DISTRIB_QUERY         3   // LM1.0 QUERY for non-centralized init
#define LOGON_CENTRAL_RESPONSE      4   // LM1.0 response to LOGON_CENTRAL_QUERY
#define LOGON_DISTRIB_RESPONSE      5   // LM1.0 resp to LOGON_DISTRIB_QUERY
#define LOGON_RESPONSE2             6   // LM2.0 Response to LOGON_REQUEST
#define LOGON_PRIMARY_QUERY         7   // QUERY for Primary DC
#define LOGON_START_PRIMARY         8   // announce startup of Primary DC
#define LOGON_FAIL_PRIMARY          9   // announce failed  Primary DC
#define LOGON_UAS_CHANGE            10  // announce change to UAS or SAM
#define LOGON_NO_USER               11  // announce no user on machine
#define LOGON_PRIMARY_RESPONSE      12  // response to LOGON_PRIMARY_QUERY
#define LOGON_RELOGON_RESPONSE      13  // LM1.0/2.0 resp to relogn request
#define LOGON_WKSTINFO_RESPONSE     14  // LM1.0/2.0 resp to interrogate request
#define LOGON_PAUSE_RESPONSE        15  // LM2.0 resp when NETLOGON is paused
#define LOGON_USER_UNKNOWN          16  // LM2.0 response when user is unknown
#define LOGON_UPDATE_ACCOUNT        17  // LM2.1 announce account updates

#define LOGON_SAM_LOGON_REQUEST     18  // SAM LOGON request from client
#define LOGON_SAM_LOGON_RESPONSE    19  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE    20  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN      21  // SAM response when user is unknown

#define LOGON_SAM_LOGON_RESPONSE_EX 23  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE_EX 24  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN_EX   25  // SAM response when user is unknown


//
// These structures are defined for their maximum case.  In many instances,
// the strings are packed immediately following one another.  In that case
// the comments below indicate that the offset of certain fields should
// not be used.
//

//
// NETLOGON_LOGON_QUERY:
//
// This structure is used for the following Opcodes:
//      LOGON_PRIMARY_QUERY,    (all LanMan versions)
//      LOGON_CENTRAL_QUERY,        (LM 1.0 only)
//      LOGON_CENTRAL_RESPONSE,     (LM 1.0 only)
//      LOGON_DISTRIB_QUERY,        (LM 1.0 only)
//      LOGON_DISTRIB_RESPONSE.     (LM 1.0 only)
//
//

typedef struct _NETLOGON_LOGON_QUERY {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];        // This field is always ASCII.

    CHAR MailslotName[LM20_PATHLEN];        // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodeComputerName[CNLEN+1];     // Do not use offset of this field

                                            //
                                            // This field is only present if
                                            // this is a LOGON_PRIMARY_QUERY
                                            // from an NT system.
                                            //


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_QUERY, * PNETLOGON_LOGON_QUERY;



//
// NETLOGON_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_REQUEST    (LM 1.0 and LM 2.0 Only)
//

typedef struct _NETLOGON_LOGON_REQUEST {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];
    CHAR UserName[LM20_UNLEN+1];            // Do not use offset of this field

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    _USHORT (RequestCount);                 // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_REQUEST, * PNETLOGON_LOGON_REQUEST;



//
// NETLOGON_LOGON_RESPONSE:
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE (To LM 1.0 clients only).
//

typedef struct _NETLOGON_LOGON_RESPONSE {
    USHORT Opcode;
    CHAR UseName[2 + LM20_CNLEN + 1 + LM20_NNLEN +1];
    CHAR ScriptName[(2*LM20_PATHLEN) + LM20_UNLEN + LM20_CNLEN + LM20_NNLEN + 8];       // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE, *PNETLOGON_LOGON_RESPONSE;


//
// NETLOGON_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_START_PRIMARY
//      LOGON_PRIMARY_RESPONSE
//

typedef struct _NETLOGON_PRIMARY {
    USHORT Opcode;
    CHAR PrimaryDCName[LM20_CNLEN + 1];     // This field is always ASCII.

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodePrimaryDCName[CNLEN+1];    // Do not use offset of this field
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_PRIMARY, * PNETLOGON_PRIMARY;


//
// NETLOGON_FAIL_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_FAIL_PRIMARY       (All LanMan versions)
//

typedef struct _NETLOGON_FAIL_PRIMARY {
    USHORT  Opcode;

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_FAIL_PRIMARY, *PNETLOGON_FAIL_PRIMARY;


//
// NETLOGON_LOGON_RESPONSE2
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE2         (LM 2.0 only)
//      LOGON_USER_UNKNOWN      (LM 2.0 only)
//      LOGON_PAUSE_RESPONSE    (LM 2.0 only)
//

typedef struct _NETLOGON_LOGON_RESPONSE2 {
    USHORT Opcode;
    CHAR LogonServer[LM20_UNCLEN+1];
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE2, *PNETLOGON_LOGON_RESPONSE2;


//
// The following structures are densely packed to be compatible with LM2.0.
//  Poorly aligned fields should only be accessed using the SmbPut and SmbGet
//  family of macros.
//

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// NETLOGON_UAS_CHANGE
//
// This structure is used for the following Opcodes:
//      LOGON_UAS_CHANGE
//

//
// DB_CHANGE_INFO structure contains per database change info.
//

typedef struct _DB_CHANGE_INFO {
    DWORD           DBIndex;
    LARGE_INTEGER   LargeSerialNumber;
    LARGE_INTEGER   NtDateAndTime;
} DB_CHANGE_INFO, *PDB_CHANGE_INFO;


//
// NETLOGON_DB_STRUCTURE contains common change info for all databases and
//  array of per database change info. First half of this structure is
//  identical to downlevel NETLOGON_UAS_CHANGE message and contains SAM
//  database change info.
//

typedef struct _NETLOGON_DB_CHANGE {
    USHORT  Opcode;
    _ULONG  (LowSerialNumber);
    _ULONG  (DateAndTime);
    _ULONG  (Pulse);
    _ULONG  (Random);
    CHAR    PrimaryDCName[LM20_CNLEN + 1];
    CHAR    DomainName[LM20_DNLEN + 1];     // Do not use offset of this field

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR   UnicodePrimaryDCName[CNLEN+1];  // Do not use offset of this field
    WCHAR   UnicodeDomainName[DNLEN+1];     // Do not use offset of this field
    DWORD   DBCount;                        // Do not use offset of this field
    DB_CHANGE_INFO DBChangeInfo[1];         // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR    DomainSid[1];                   // Do not use offset of this field
    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_DB_CHANGE, *PNETLOGON_DB_CHANGE;



//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING



//
// NETLOGON_SAM_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_REQUEST  (SAM Only)
//
// This message exceeds the maximum size for broadcast mailslot messages.  In
// practice, this will only be a problem if the UnicodeUserName is over 100
// characters long.
//

typedef struct _NETLOGON_SAM_LOGON_REQUEST {
    USHORT Opcode;
    USHORT RequestCount;

    WCHAR UnicodeComputerName[CNLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1]; // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field
                                            // This field is always ASCII.
    _ULONG (AllowableAccountControlBits);   // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR DomainSid[1];                      // Do not use offset of this field


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field

    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_REQUEST, * PNETLOGON_SAM_LOGON_REQUEST;



//
// NETLOGON_SAM_LOGON_RESPONSE
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE    (SAM only)
//      LOGON_SAM_USER_UNKNOWN      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE    (SAM only)
//

typedef struct _NETLOGON_SAM_LOGON_RESPONSE {
    USHORT Opcode;
    WCHAR UnicodeLogonServer[UNCLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1];         // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    // The following fields are only present for NETLOGON_NT_VERSION_5
    GUID DomainGuid;                        // Do not use offset of this field
    GUID SiteGuid;                          // Do not use offset of this field

    CHAR DnsForestName[256];                  // Do not use offset of this field
                                            // This field counted UTF-8

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    _ULONG (DcIpAddress);                   // Do not use offset of this field
                                            // Host byte order
    _ULONG (Flags);                         // Do not use offset of this field
    // The previous fields are only present for NETLOGON_NT_VERSION_5

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_RESPONSE, *PNETLOGON_SAM_LOGON_RESPONSE;



//
// NETLOGON_SAM_LOGON_RESPONSE_EX
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE_EX    (SAM only)
//      LOGON_SAM_USER_UNKNOWN_EX      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE_EX    (SAM only)
//
// All character fields are UTF-8 and are compressed ala RFC 1035

typedef struct _NETLOGON_SAM_LOGON_RESPONSE_EX {
    USHORT Opcode;
    USHORT Sbz;
    ULONG Flags;
    GUID DomainGuid;

    CHAR DnsForestName[256];                  // Do not use offset of this field

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field

    CHAR NetbiosDomainName[DNLEN+1];        // Do not use offset of this field

    CHAR NetbiosComputerName[UNCLEN+1];     // Do not use offset of this field

    CHAR UserName[64];                      // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR DcSiteName[64];                    // Do not use offset of this field

    CHAR ClientSiteName[64];                // Do not use offset of this field

    // The DcSockAddrSize field is only present for NETLOGON_NT_VERSION_5EX_WITH_IP
    CHAR(DcSockAddrSize);                   // Do not use offset of this field
                                            // The next DcSockAddrSize byte are a
                                            // SOCKADDR structure representing the
                                            // IP address of the DC

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field

} NETLOGON_SAM_LOGON_RESPONSE_EX, *PNETLOGON_SAM_LOGON_RESPONSE_EX;

#endif // _NETLOGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rap.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Rap.h

Abstract:

    This header file contains procedure prototypes for Remote Admin Protocol
    (RAP) routines.  These routines are shared between XactSrv and RpcXlate.

Author:

    David Treadwell (davidtr) 08-Jan-1991
    Shanku Niyogi (w-shanku)
    John Rogers (JohnRo)

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Mar-1991 JohnRo
        Extracted Rap routines from XactSrv (Xs) code.
    26-Mar-1991 JohnRo
        Added FORMAT_LPDESC (for debugging).  Include <ctype.h>.
    21-Apr-1991 JohnRo
        Added RapIsValidDescriptorSmb().  Reduced recompiles.
        Make it clear that RapAsciiToDecimal updates the pointer it is given.
        RapConvertSingleEntry's BytesRequired is not OPTIONAL.
        Clarify that OutStructure is OUT, not IN.
    06-May-1991 JohnRo
        Added DESC_CHAR typedef.
    14-May-1991 JohnRo
        Added DESCLEN() and FORMAT_DESC_CHAR macros.
    15-May-1991 JohnRo
        Added conversion mode handling.  Added native vs. RAP handling.
    05-Jun-1991 JohnRo
        Added RapTotalSize().  Make output structure OPTIONAL for convert
        single entry; this will be used by RapTotalSize().
    10-Jul-1991 JohnRo
        Added RapStructureAlignment() for use by RxpConvertDataStructures().
    22-Jul-1991 RFirth
        Added MAX_DESC_SUBSTRING
    19-Aug-1991 JohnRo
        Added DESC_CHAR_IS_DIGIT() macro (to improve UNICODE conversion).
    10-Sep-1991 JohnRo
        Added DESC_DIGIT_TO_NUM(), to support changes suggested by PC-LINT.
    07-Oct-1991 JohnRo
        Correct MAX_DESC_SUBSTRING.
        Use DESC_CHAR_IS_DIGIT() in t-JamesW's new macros.
    07-Feb-1992 JohnRo
        Added RapCharSize() macro.
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for DEC and others.

--*/

#ifndef _RAP_
#define _RAP_


// These must be included first:

#include <windef.h>             // BOOL, CHAR, DWORD, IN, LPBYTE, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <lmremutl.h>   // DESC_CHAR and LPDESC_CHAR typedefs.


#ifndef DESC_CHAR_UNICODE

#include <ctype.h>      // isdigit().
#include <string.h>     // strlen() (only needed for DESCLEN()).

//
// The descriptor strings are really ASCIIZ strings, and are not expected to
// be translated into Unicode.  So, let's define a type for them just to
// make this clearer.  (That'll also make it easier to change to Unicode later
// if I'm wrong.  --JR)
//

//typedef CHAR DESC_CHAR;

//
// Net buffers contain 32-bit pointers.
//

#define NETPTR DWORD

// DESCLEN(desc): return number of characters (not including null) in desc:
#define DESCLEN(desc)                   strlen(desc)

// DESC_CHAR_IS_DIGIT(descchar): return nonzero iff descchar is a digit.
#define DESC_CHAR_IS_DIGIT(descchar)    isdigit(descchar)

// DESC_DIGIT_TO_NUM(descchar): return integer value of descchar.
#define DESC_DIGIT_TO_NUM(descchar) \
    ( (DWORD) ( ((int)(descchar)) - ((int) '0') ) )

//
// Format strings for NetpDbgPrint use (see NetDebug.h).  Note that
// FORMAT_LPDESC_CHAR will go away one of these days.
//
#define FORMAT_DESC_CHAR        "%c"
#define FORMAT_LPDESC           "%s"
#define FORMAT_LPDESC_CHAR      "%c"

#else // DESC_CHAR_UNICODE is defined

//
// The descriptor strings are really ASCIIZ strings, and are not expected to
// be translated into Unicode.  So, let's define a type for them just to
// make this clearer.  (That'll also make it easier to change to Unicode later
// if I'm wrong.  --JR)
//

#include <wchar.h>      // iswdigit(), wcslen().

//typedef WCHAR DESC_CHAR;

// DESCLEN(desc): return number of characters (not including null) in desc:
#define DESCLEN(desc)                   wcslen(desc)

// DESC_CHAR_IS_DIGIT(descchar): return nonzero iff descchar is a digit.
#define DESC_CHAR_IS_DIGIT(descchar)    iswdigit(descchar)

// DESC_DIGIT_TO_NUM(descchar): return integer value of descchar.
#define DESC_DIGIT_TO_NUM(descchar) \
    ( (DWORD) ( ((int)(descchar)) - ((int) L'0') ) )

//
// Format strings for NetpDbgPrint use (see NetDebug.h).  Note that
// FORMAT_LPDESC_CHAR will go away one of these days.
//
#define FORMAT_DESC_CHAR        "%wc"
#define FORMAT_LPDESC           "%ws"
#define FORMAT_LPDESC_CHAR      "%wc"

#endif // DESC_CHAR_UNICODE is defined

//typedef DESC_CHAR * LPDESC;

//
// MAX_DESC_SUBSTRING - the maximum number of consecutive characters in a
// descriptor string which can describe a single field in a structure - for
// example "B21" in "B21BWWWzWB9B".  So far, largest is "B120".
//

#define MAX_DESC_SUBSTRING  4

//
// Some routines need to know whether a given item is part of a request,
// a response, or both:
//

typedef enum _RAP_TRANSMISSION_MODE {
    Request,                    // only part of request (in)
    Response,                   // only part of response (out)
    Both                        // both (in out).
} RAP_TRANSMISSION_MODE, *LPRAP_TRANSMISSION_MODE;

typedef enum _RAP_CONVERSION_MODE {
    NativeToRap,                // native format to RAP
    RapToNative,                // RAP format to native
    NativeToNative,             // native to native
    RapToRap                    // RAP to RAP
} RAP_CONVERSION_MODE, *LPRAP_CONVERSION_MODE;

//
// The value returned by RapLastPointerOffset for a descriptor string
// which indicates that the structure has no pointers. A very high
// value is returned instead of 0, in order to distinguish between
// a structure with no pointers, such as share_info_0, and a structure
// with only one pointer, at offset 0.
//

#define NO_POINTER_IN_STRUCTURE 0xFFFFFFFF

//
// The value returned by RapAuxDataCount when there is no
// auxiliary data. This will be indicated by the lack of an auxiliary
// data count character in the descriptor string.
//

#define NO_AUX_DATA 0xFFFFFFFF

//
// Helper subroutines and macros.
//

DWORD
RapArrayLength(
    IN LPDESC Descriptor,
    IN OUT LPDESC * UpdatedDescriptorPtr,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    );

DWORD
RapAsciiToDecimal (
   IN OUT LPDESC *Number
   );

DWORD
RapAuxDataCountOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapAuxDataCount (
    IN LPBYTE Buffer,
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

// RapCharSize(native): return character size (in bytes) for characters of a
// given format.
// 
// DWORD
// RapCharSize(Native)
//     IN BOOL Native
//     );
//
#define RapCharSize(Native) \
    ( (DWORD) ( (Native) ? sizeof(TCHAR) : sizeof(CHAR) ) )

NET_API_STATUS
RapConvertSingleEntry (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    );

NET_API_STATUS
RapConvertSingleEntryEx (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode,
    IN UINT_PTR Bias
    );

//
//
// RapDescArrayLength(Descriptor) - return the array length if the descriptor
// data has numeric characters, or return default length of 1.
//
// DWORD
// RapDescArrayLength(
//     IN OUT LPDESC Descriptor
//     );
//

#define RapDescArrayLength( Descriptor ) \
   ( ( DESC_CHAR_IS_DIGIT( *(Descriptor) )) ? RapAsciiToDecimal( &(Descriptor) ) : 1 )

//
// RapDescStringLength(Descriptor) - return the array length if the descriptor
// data has numeric characters, or return default length of 0, which indicates
// that there is no limit.
//
// DWORD
// RapDescStringLength(
//     IN OUT LPDESC Descriptor
//     );

#define RapDescStringLength( Descriptor ) \
   ( ( DESC_CHAR_IS_DIGIT( *(Descriptor) )) ? RapAsciiToDecimal( &(Descriptor) ) : 0 )

VOID
RapExamineDescriptor (
    IN LPDESC DescriptorString,
    IN LPDWORD ParmNum OPTIONAL,
    OUT LPDWORD StructureSize OPTIONAL,
    OUT LPDWORD LastPointerOffset OPTIONAL,
    OUT LPDWORD AuxDataCountOffset OPTIONAL,
    OUT LPDESC * ParmNumDescriptor OPTIONAL,
    OUT LPDWORD StructureAlignment OPTIONAL,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapGetFieldSize(
    IN LPDESC TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    );

//
// BOOL
// RapIsPointer(
//     IN CHAR DescChar
//     );
//

#define RapIsPointer(c)         ( ((c) > 'Z') ? TRUE : FALSE )

BOOL
RapIsValidDescriptorSmb (
    IN LPDESC Desc
    );

DWORD
RapLastPointerOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

LPDESC
RapParmNumDescriptor(
    IN LPDESC Descriptor,
    IN DWORD ParmNum,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

// LPVOID
// RapPossiblyAlignCount(
//     IN DWORD Count,
//     IN DWORD Pow2,
//     IN BOOL Native
//     );
#define RapPossiblyAlignCount(count,pow2,native) \
        ( (!(native)) ? (count) : (ROUND_UP_COUNT( (count), (pow2) )) )

// LPVOID
// RapPossiblyAlignPointer(
//     IN LPVOID Ptr,
//     IN DWORD Pow2,
//     IN BOOL Native
//     );
#define RapPossiblyAlignPointer(ptr,pow2,native) \
        ( (!(native)) ? (ptr) : (ROUND_UP_POINTER( (ptr), (pow2) )) )

DWORD
RapStructureAlignment (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapStructureSize (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapTotalSize (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    );

//
// RapValueWouldBeTruncated(n): return TRUE if n would lose bits when we try
// to store it in 16 bits.
//
// BOOL
// RapValueWouldBeTruncated(
//     IN DWORD Value
//     );
//

#define RapValueWouldBeTruncated(n)             \
    ( ( (n) != (DWORD) (WORD) (n)) ? TRUE : FALSE )

#endif // ndef _RAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\netshp.h ===
// Defines

#define ERROR_CONTEXT_SWITCH            0x55aa
#define ERROR_CONNECT_REMOTE_CONFIG     (ERROR_CONTEXT_SWITCH + 1)


// Flags
enum NS_CMD_FLAGS_PRIV
{
    CMD_FLAG_IMMEDIATE   = 0x04, // not valid from ancestor contexts
};

// Callbacks
typedef
DWORD
    (WINAPI NS_CONTEXT_ENTRY_FN)(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    );

typedef NS_CONTEXT_ENTRY_FN *PNS_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_SUBENTRY_FN)(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      LPCVOID                      pvData,
    OUT     LPWSTR                       pwcNewContext
    );

typedef NS_CONTEXT_SUBENTRY_FN *PNS_CONTEXT_SUBENTRY_FN;

typedef
BOOL
(WINAPI *PNS_EVENT_FILTER)(
    IN  EVENTLOGRECORD  *pRecord,
    IN  LPCWSTR         pwszLogName,
    IN  LPCWSTR         pwszComponent,
    IN  LPCWSTR         pwszSubComponent,
    IN  LPCVOID         pvFilterContext
    );

typedef
DWORD
(WINAPI *PNS_GET_EVENT_IDS_FN)(
    IN  LPCWSTR  pwszComponent,
    IN  LPCWSTR  pwszSubComponent,
    OUT PDWORD   pdwEventIds,
    OUT PULONG   pulEventCount
    );

// Macros
#define NUM_VALUES_IN_TABLE(TokenArray) sizeof(TokenArray)/sizeof(VALUE_STRING)

// Structures
typedef struct _NS_PRIV_CONTEXT_ATTRIBUTES
{
    PNS_CONTEXT_ENTRY_FN     pfnEntryFn;
    PNS_CONTEXT_SUBENTRY_FN  pfnSubEntryFn;
    PVOID                    pfnHelpFn;
} NS_PRIV_CONTEXT_ATTRIBUTES, *PNS_PRIV_CONTEXT_ATTRIBUTES;

typedef struct _NS_DLL_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ullAlign;
    };

    PNS_DLL_STOP_FN     pfnStopFn;

} NS_DLL_ATTRIBUTES, *PNS_DLL_ATTRIBUTES;


typedef struct _VALUE_TOKEN
{
    DWORD    dwValue;
    LPCWSTR  pwszToken;
} VALUE_TOKEN, *PVALUE_TOKEN;

typedef struct _VALUE_STRING
{
    DWORD   dwValue;
    DWORD   dwStringId;
} VALUE_STRING, *PVALUE_STRING;


// Exports
VOID WINAPI ConvertGuidToString(
    IN    CONST GUID *pGuid,
    OUT   LPWSTR      pwszBuffer
    );

DWORD WINAPI ConvertStringToGuid(
    IN  LPCWSTR pwszGuid,
    IN  USHORT  usStringLen,
    OUT GUID    *pGuid
    );

DWORD DisplayMessageToConsole(
    IN  HANDLE  hModule,
    IN  HANDLE  hConsole,
    IN  DWORD   dwMsgId,
    ...
    );

DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

VOID WINAPI FreeQuotedString(
    IN  LPWSTR  pwszMadeString
    );

VOID WINAPI FreeString(
    IN  LPWSTR  pwszMadeString
    );

DWORD WINAPI GenericMonitor(
    IN     PCNS_CONTEXT_ATTRIBUTES  pContext,
    IN     LPCWSTR                  pwszMachine,
    IN OUT LPWSTR                  *ppwcArguments,
    IN     DWORD                    dwArgCount,
    IN     DWORD                    dwFlags,
    IN     LPCVOID                  pvData,
    OUT    LPWSTR                   pwcNewContext
    );

LPWSTR WINAPI GetEnumString(
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  DWORD           dwNumVal,
    IN  PTOKEN_VALUE    pEnumTable
    );

BOOL WINAPI InitializeConsole(
    IN    OUT    PDWORD    pdwRR,
    OUT          HANDLE    *phMib,
    OUT          HANDLE    *phConsole
    );

LPWSTR WINAPI MakeQuotedString(
    IN  LPCWSTR  pwszString
    );

LPWSTR WINAPI MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

BOOL WINAPI MatchCmdLine(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD    dwArgCount,
    IN      LPCWSTR  pwszCmdToken,
    OUT     PDWORD   pdwNumMatched
    );

DWORD WINAPI MatchTagsInCmdLine(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN OUT  PTAG_TYPE   pEnumTable,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    );

DWORD WINAPI NsGetFriendlyNameFromIfName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI NsGetIfNameFromFriendlyName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );


DWORD WINAPI PrintEventLog(
    IN  LPCWSTR             pwszLogName,
    IN  LPCWSTR             pwszComponent,
    IN  LPCWSTR             pwszSubComponent, OPTIONAL
    IN  DWORD               fFlags,
    IN  LPCVOID             pvHistoryInfo,
    IN  PNS_EVENT_FILTER    pfnEventFilter, OPTIONAL
    IN  LPCVOID             pvFilterContext
    );

DWORD WINAPI RefreshConsole(
    IN    HANDLE    hMib,
    IN    HANDLE    hConsole,
    IN    DWORD     dwRR
    );

#define DisplayError     PrintError
#define DisplayMessageT  PrintMessage
#define DisplayMessage   PrintMessageFromModule
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ntddip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddip.h

Abstract:

    This header file defines constants and types for accessing the NT
    IP driver.

Author:

    Mike Massa (mikemas) 13-Aug-1993

Revision History:

--*/

#ifndef _NTDDIP_
#define _NTDDIP_
#pragma once

#include <ipexport.h>

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
#define DD_IP_DEVICE_NAME           L"\\Device\\Ip"
#define DD_IP_SYMBOLIC_DEVICE_NAME  L"\\DosDevices\\Ip"

#define IP_ADDRTYPE_TRANSIENT 0x01


//
// Structures used in IOCTLs.
//
typedef struct set_ip_address_request {
    USHORT          Context;        // Context value for the target NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
} IP_SET_ADDRESS_REQUEST, *PIP_SET_ADDRESS_REQUEST;

//
// Structures used in IOCTLs.
//
typedef struct set_ip_address_request_ex {
    USHORT          Context;        // Context value for the target NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    USHORT          Type;           // Type of address being added
} IP_SET_ADDRESS_REQUEST_EX, *PIP_SET_ADDRESS_REQUEST_EX;


typedef struct set_dhcp_interface_request {
    ULONG           Context;        // Context value identifying the NTE
                                    // Valid contexts are 16 bit quantities.
} IP_SET_DHCP_INTERFACE_REQUEST, *PIP_SET_DHCP_INTERFACE_REQUEST;

typedef struct add_ip_nte_request {
    ULONG           InterfaceContext; // Context value for the IP interface
                                    // to which to add the NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    UNICODE_STRING  InterfaceName;  // Interface name when interface context
                                    // is 0xffff
    CHAR            InterfaceNameBuffer[1]; // Buffer to hold interface name
                                    // from above

} IP_ADD_NTE_REQUEST, *PIP_ADD_NTE_REQUEST;

#if defined(_WIN64)

typedef struct add_ip_nte_request32 {
    ULONG           InterfaceContext; // Context value for the IP interface
                                    // to which to add the NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    UNICODE_STRING32 InterfaceName; // Interface name when interface context
                                    // is 0xffff
    CHAR            InterfaceNameBuffer[1]; // Buffer to hold interface name
                                    // from above

} IP_ADD_NTE_REQUEST32, *PIP_ADD_NTE_REQUEST32;

#endif // _WIN64

typedef struct _ip_rtchange_notify {
    IPAddr          Addr;
    IPMask          Mask;
} IP_RTCHANGE_NOTIFY, *PIP_RTCHANGE_NOTIFY;

typedef struct _ip_addchange_notify {
    IPAddr          Addr;
    IPMask          Mask;
    PVOID           pContext;
    USHORT          IPContext;
    ULONG           AddrAdded;
    ULONG           UniAddr;
    UNICODE_STRING  ConfigName;
    CHAR            NameData[1];
} IP_ADDCHANGE_NOTIFY, *PIP_ADDCHANGE_NOTIFY;

typedef struct _ip_ifchange_notify
{
    USHORT          Context;
    UCHAR           Pad[2];
    ULONG           IfAdded;
} IP_IFCHANGE_NOTIFY, *PIP_IFCHANGE_NOTIFY;

typedef struct add_ip_nte_request_old {
    USHORT          InterfaceContext; // Context value for the IP interface
                                // to which to add the NTE
    IPAddr          Address;    // IP address to set, or zero to clear
    IPMask          SubnetMask; // Subnet mask to set
} IP_ADD_NTE_REQUEST_OLD, *PIP_ADD_NTE_REQUEST_OLD;

typedef struct add_ip_nte_response {
    USHORT          Context;    // Context value for the new NTE
    ULONG           Instance;   // Instance ID for the new NTE
} IP_ADD_NTE_RESPONSE, *PIP_ADD_NTE_RESPONSE;

typedef struct delete_ip_nte_request {
    USHORT          Context;    // Context value for the NTE
} IP_DELETE_NTE_REQUEST, *PIP_DELETE_NTE_REQUEST;

typedef struct get_ip_nte_info_request {
    USHORT          Context;    // Context value for the NTE
} IP_GET_NTE_INFO_REQUEST, *PIP_GET_NTE_INFO_REQUEST;

typedef struct get_ip_nte_info_response {
    ULONG           Instance;   // Instance ID for the NTE
    IPAddr          Address;
    IPMask          SubnetMask;
    ULONG           Flags;
} IP_GET_NTE_INFO_RESPONSE, *PIP_GET_NTE_INFO_RESPONSE;

typedef struct  _net_pm_wakeup_pattern_desc {
    struct  _net_pm_wakeup_pattern_desc *Next; // points to the next descriptor
                                // on the list.
    UCHAR           *Ptrn;      // the wakeup pattern
    UCHAR           *Mask;      // bit mask for matching wakeup pattern,
                                // 1 -match, 0 - ignore
    USHORT          PtrnLen;    // length of the Pattern. len of mask
                                // is retrieved via GetWakeupPatternMaskLength
} NET_PM_WAKEUP_PATTERN_DESC, *PNET_PM_WAKEUP_PATTERN_DESC;

typedef struct wakeup_pattern_request {
    ULONG           InterfaceContext; // Context value
    PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc; // higher level protocol pattern
                                // descriptor
    BOOLEAN         AddPattern; // TRUE - Add, FALSE - Delete
} IP_WAKEUP_PATTERN_REQUEST, *PIP_WAKEUP_PATTERN_REQUEST;

typedef struct ip_get_ip_event_response {
    ULONG           SequenceNo; // SequenceNo of the this event
    USHORT          ContextStart; // Context value for the first NTE of the
                                // adapter.
    USHORT          ContextEnd; // Context value for the last NTE of the adapter
    IP_STATUS       MediaStatus; // Status of the media.
    UNICODE_STRING  AdapterName;
} IP_GET_IP_EVENT_RESPONSE, *PIP_GET_IP_EVENT_RESPONSE;

typedef struct ip_get_ip_event_request {
    ULONG           SequenceNo; // SequenceNo of the last event notified.
} IP_GET_IP_EVENT_REQUEST, *PIP_GET_IP_EVENT_REQUEST;

#define IP_PNP_RECONFIG_VERSION 2
typedef struct ip_pnp_reconfig_request {
    USHORT          version;
    USHORT          arpConfigOffset; // If 0, this is an IP layer request;
                                // else this is the offset from the start
                                // of this structure at which the ARP layer
                                // reconfig request is located.
    BOOLEAN         gatewayListUpdate; // is gateway list changed?
    BOOLEAN         IPEnableRouter; // is ip forwarding on?
    UCHAR           PerformRouterDiscovery : 4; // is PerformRouterDiscovery on?
    BOOLEAN         DhcpPerformRouterDiscovery : 4; // has DHCP server specified
                                // IRDP?
    BOOLEAN         EnableSecurityFilter; // Enable/disable security filter
    BOOLEAN         InterfaceMetricUpdate; // re-read interface metric

    UCHAR           Flags;      // mask of valid fields
    USHORT          NextEntryOffset; // the offset from the start of this
                                // structure at which the next
                                // reconfig entry for the IP layer
                                // (if any) is located.

} IP_PNP_RECONFIG_REQUEST, *PIP_PNP_RECONFIG_REQUEST;

#define IP_IRDP_DISABLED            0
#define IP_IRDP_ENABLED             1
#define IP_IRDP_DISABLED_USE_DHCP   2

#define IP_PNP_FLAG_IP_ENABLE_ROUTER                0x01
#define IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY        0x02
#define IP_PNP_FLAG_ENABLE_SECURITY_FILTER          0x04
#define IP_PNP_FLAG_GATEWAY_LIST_UPDATE             0x08
#define IP_PNP_FLAG_INTERFACE_METRIC_UPDATE         0x10
#define IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY   0x20
#define IP_PNP_FLAG_INTERFACE_TCP_PARAMETER_UPDATE  0x40
#define IP_PNP_FLAG_ALL                             0x6f

typedef enum {
    IPPnPInitCompleteEntryType = 1,
    IPPnPMaximumEntryType
} IP_PNP_RECONFIG_ENTRY_TYPE;

typedef struct ip_pnp_reconfig_header {
    USHORT          NextEntryOffset;
    UCHAR           EntryType;
} IP_PNP_RECONFIG_HEADER, *PIP_PNP_RECONFIG_HEADER;

typedef struct ip_pnp_init_complete {
    IP_PNP_RECONFIG_HEADER Header;
} IP_PNP_INIT_COMPLETE, *PIP_PNP_INIT_COMPLETE;

//
// Enumerated data type for Query procedure in NetBT
//
enum DnsOption {
    WinsOnly =0,
    WinsThenDns,
    DnsOnly
};

typedef struct netbt_pnp_reconfig_request {
    USHORT          version;            // always 1
    enum DnsOption  enumDnsOption;      // Enable Dns box. 3 states: WinsOnly,
                                        // WinsThenDns, DnsOnly
    BOOLEAN         fLmhostsEnabled;    // EnableLmhosts box is checked.
                                        // Checked: TRUE, unchecked: FALSE
    BOOLEAN         fLmhostsFileSet;    // TRUE <==> user has successfully
                                        // chosen a file & filecopy succeeded
    BOOLEAN         fScopeIdUpdated;    // True if the new value for ScopeId
                                        // is different from the old
} NETBT_PNP_RECONFIG_REQUEST, *PNETBT_PNP_RECONFIG_REQUEST;


typedef struct _ip_set_if_promiscuous_info {
    ULONG           Index;  // IP's interface index
    UCHAR           Type;   // PROMISCUOUS_MCAST or PROMISCUOUS_BCAST
    UCHAR           Add;    // 1 to add, 0 to delete
} IP_SET_IF_PROMISCUOUS_INFO, *PIP_SET_IF_PROMISCUOUS_INFO;

#define PROMISCUOUS_MCAST   0
#define PROMISCUOUS_BCAST   1

typedef struct _ip_get_if_index_info {
    ULONG           Index;
    WCHAR           Name[1];
} IP_GET_IF_INDEX_INFO, *PIP_GET_IF_INDEX_INFO;

typedef struct ip_interface_name_info {
    ULONG           Index;      // Interface Index
    ULONG           MediaType;  // Interface Types - see ipifcons.h
    UCHAR           ConnectionType;
    UCHAR           AccessType;
    GUID            DeviceGuid; // Device GUID is the guid of the device
                                // that IP exposes
    GUID            InterfaceGuid; // Interface GUID, if not GUID_NULL is the
                                // GUID for the interface mapped to the device.
} IP_INTERFACE_NAME_INFO, *PIP_INTERFACE_NAME_INFO;


typedef struct _ip_get_if_name_info {
    ULONG           Context;    // Set this to 0 to start enumeration
                                // To resume enumeration, copy the value
                                // returned by the last enum
    ULONG           Count;
    IP_INTERFACE_NAME_INFO  Info[1];
} IP_GET_IF_NAME_INFO, *PIP_GET_IF_NAME_INFO;

//
// NTE Flags
//

#define IP_NTE_DYNAMIC  0x00000010

//
// IP IOCTL code definitions
//

#define FSCTL_IP_BASE     FILE_DEVICE_NETWORK

#define _IP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IP_BASE, function, method, access)

//
// This IOCTL is used to send an ICMP Echo request. It is synchronous and
// returns any replies received.
//
#define IOCTL_ICMP_ECHO_REQUEST \
            _IP_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL is used to set the IP address for an interface. It is meant to
// be issued by a DHCP client. Setting the address to 0 deletes the current
// address and disables the interface. It may only be issued by a process
// with Administrator privilege.
//
#define IOCTL_IP_SET_ADDRESS  \
            _IP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL is used to specify on which uninitialized interface a DHCP
// client intends to send its requests. The Interface Context parameter is
// a 16-bit quantity. The IOCTL takes a 32-bit Context as its argument. This
// IOCTL with a Context value of 0xFFFFFFFF must be issued to disable special
// processing in IP when a DHCP client is finished initializing interfaces.
// This IOCTL may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_DHCP_INTERFACE  \
            _IP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_IF_CONTEXT  \
            _IP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_FILTER_POINTER  \
            _IP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_MAP_ROUTE_POINTER  \
            _IP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_GET_PNP_ARP_POINTERS  \
            _IP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl creates a new, dynamic NTE. It may only be issued by a process
// with Administrator privilege.
//
#define IOCTL_IP_ADD_NTE  \
            _IP_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl deletes a dynamic NTE. It may only be issued by a process with
// Administrator privilege.
//
#define IOCTL_IP_DELETE_NTE  \
            _IP_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl gathers information about an NTE. It requires no special
// privilege.
//
#define IOCTL_IP_GET_NTE_INFO  \
            _IP_CTL_CODE(9, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This ioctl adds or removes wakeup patterns
//
#define IOCTL_IP_WAKEUP_PATTERN  \
            _IP_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl allows DHCP to get media sense notifications.
//
#define IOCTL_IP_GET_IP_EVENT  \
            _IP_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This ioctl may only be issued by a process with Administrator privilege.
//

#define IOCTL_IP_SET_FIREWALL_HOOK  \
            _IP_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST  \
            _IP_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST  \
            _IP_CTL_CODE(14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ARP_SEND_REQUEST  \
            _IP_CTL_CODE(15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_INTERFACE_INFO  \
            _IP_CTL_CODE(16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_BEST_INTERFACE  \
            _IP_CTL_CODE(17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_SET_IF_PROMISCUOUS \
            _IP_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_FLUSH_ARP_TABLE \
            _IP_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_IGMPLIST  \
            _IP_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_SET_BLOCKOFROUTES  \
            _IP_CTL_CODE(23, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_ROUTEWITHREF  \
            _IP_CTL_CODE(24, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_ADDRESS_DUP  \
            _IP_CTL_CODE(25, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_IF_INDEX       \
            _IP_CTL_CODE(26, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_IF_NAME        \
            _IP_CTL_CODE(27, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_BESTINTFC_FUNC_ADDR        \
            _IP_CTL_CODE(28, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_MULTIHOPROUTE  \
            _IP_CTL_CODE(29, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_WOL_CAPABILITY  \
            _IP_CTL_CODE(30, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX  \
            _IP_CTL_CODE(31, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ENABLE_ROUTER_REQUEST \
            _IP_CTL_CODE(32, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_UNENABLE_ROUTER_REQUEST \
            _IP_CTL_CODE(33, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_OFFLOAD_CAPABILITY \
            _IP_CTL_CODE(34, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_IFCHANGE_NOTIFY_REQUEST \
            _IP_CTL_CODE(35, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS \
            _IP_CTL_CODE(36, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_MCAST_COUNTERS \
            _IP_CTL_CODE(37, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ENABLE_MEDIA_SENSE_REQUEST \
            _IP_CTL_CODE(38, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST \
            _IP_CTL_CODE(39, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_ADDRESS_EX  \
            _IP_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif // _NTDDIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rasuip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       R A S U I P . H
//
//  Contents:   Private RAS APIs used by the NT5 Connections UI.  These
//              APIs are exported by rasdlg.dll.
//
//  Notes:
//
//  Author:     shaunco   10 Nov 1997
//
//----------------------------------------------------------------------------

#ifndef _RASUIP_
#define _RASUIP_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 1200 )
#pragma warning(push)
#endif
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4514)
#endif
#if (_MSC_VER >= 1020)
#pragma once
#endif
#endif

#include <prsht.h>
#include <ras.h>
#include <hnetcfg.h>


#ifdef __cplusplus
extern "C" {
#endif

//+---------------------------------------------------------------------------
// RASENTRYDLG.reserved2 argument block valid when RASENTRYDLG.dwFlags
// RASEDFLAG_ShellOwned is set.
//

typedef struct
_RASEDSHELLOWNEDR2
{
    // Add page routine to be called by RasEntryDlg before returning.
    // Callback returns context 'lparam'.
    //
    LPFNADDPROPSHEETPAGE    pfnAddPage;
    LPARAM                  lparam;

    // When RASEDFLAG_NewEntry and RASEDFLAG_ShellOwned are set,
    // pvWizardCtx is filled in by RasEntryDlg so that the shell has
    // context information with which to pass to the NccXXX APIs below.
    //
    LPVOID                  pvWizardCtx;
}
RASEDSHELLOWNEDR2;


//+---------------------------------------------------------------------------
// RAS Connection wizard APIs
//

// Flags returned from RasWizCreateNewEntry
//
#define NCC_FLAG_ALL_USERS          0x1     // Create connection for all users
#define NCC_FLAG_CREATE_INCOMING    0x2     // Create incoming connection instead
#define NCC_FLAG_SHARED             0x4
#define NCC_FLAG_FIREWALL           0x8     // If turn on Firewall
#define NCC_FLAG_GLOBALCREDS        0x10    // If the credentials is for all users
#define NCC_FLAG_DEFAULT_INTERNET   0x20    // If this is a default internet connection

// Types of connections to be used in calls to RasWizXXX
#define RASWIZ_TYPE_DIALUP    0x1
#define RASWIZ_TYPE_DIRECT    0x2
#define RASWIZ_TYPE_INCOMING  0x3
#define RASWIZ_TYPE_BROADBAND 0x4

DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags);

DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags);

DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName);

DWORD
APIENTRY
RasWizGetSuggestedEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName);

DWORD
APIENTRY
RasWizQueryMaxPageCount(
    IN  DWORD    dwRasWizType);

DWORD
APIENTRY
RasWizSetEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName);

DWORD
APIENTRY
RasWizIsEntryRenamable(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable);


//+---------------------------------------------------------------------------
// Inbound connection APIs
//

typedef HANDLE HRASSRVCONN;

#define RASSRV_MaxName              256

// Types of ras server connections (RASSRVCONN.dwType values)
//
#define RASSRVUI_MODEM              0
#define RASSRVUI_VPN                1
#define RASSRVUI_DCC                2

// Defines a structure that identifies a client connection
//
typedef struct _RASSRVCONN
{
    DWORD       dwSize;                 // Size of the structure (used for versioning)
    HRASSRVCONN hRasSrvConn;            // Handle of the connection
    DWORD       dwType;
    WCHAR       szEntryName  [RASSRV_MaxName + 1];
    WCHAR       szDeviceName [RASSRV_MaxName + 1];
    GUID        Guid;
} RASSRVCONN, *LPRASSRVCONN;

// Starts the remote access service and marks it as autostart.
// If the remoteaccess service is not installed, this function
// returns an error.
DWORD
APIENTRY
RasSrvInitializeService (
    VOID);

// Stops the remote access service and marks it as disabled.
DWORD
APIENTRY
RasSrvCleanupService (
    VOID);

DWORD
APIENTRY
RasSrvIsServiceRunning (
    OUT BOOL* pfIsRunning);

//
// Returns whether is it ok to display the "Incoming Connections"
// connection.
//
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow);

DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);

DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);    // context should be passed in as pvData
                                            // subsequent calls to RasWizXXX

// Function behaves anagolously to the WIN32 function RasEnumConnections but
// for client connections instead of dialout connections.
DWORD
APIENTRY
RasSrvEnumConnections (
    IN OUT  LPRASSRVCONN    pRasSrvConn,    // Buffer of array of connections.
    IN      LPDWORD         pcb,            // size in bytes of buffer
    OUT     LPDWORD         pcConnections); // number of connections written to buffer

// Gets the status of a Ras Server Connection
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,            // The connection in question
    OUT BOOL*       pfConnected);           // Buffer to hold the type

// Hang up the given connection
DWORD
APIENTRY
RasSrvHangupConnection (
    IN  HRASSRVCONN hRasSrvConn);           // The connection in question


// Has "show icons in taskbar" been checked?
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon);

// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent);

// Enables or disables having the user manually dial
// his/her remote access server.
DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN BOOL  bEnable );     // whether to enable or not

DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled );   // whether to enable or not

//+---------------------------------------------------------------------------
// Connection sharing API routines
//

// Defines the structure used to store information about the shared connection.
// This structure is stored as binary data in the registry, and any changes
// to it must be made with this in mind.
//
#include <packon.h>
typedef struct _RASSHARECONN
{
    DWORD               dwSize;
    BOOL                fIsLanConnection;
    union {
        GUID            guid;
        RASENTRYNAMEW   name;
    };
} RASSHARECONN, *LPRASSHARECONN;
#include <packoff.h>

// Flag set by 'RasQueryLanConnTable' for private LAN connections
//
#define NCCF_PRIVATE_LAN        0x1000

// Name of secure event object shared with rasauto service.
//
#define RAS_AUTO_DIAL_SHARED_CONNECTION_EVENT \
    "RasAutoDialSharedConnectionEvent"

// VOID
// RasEntryToSharedConnection(
//      IN LPCWSTR          pszPhonebookPath,
//      IN LPCWSTR          pszEntryName,
//      OUT LPRASSHARECONN  pConn );
//
// Macro for conversion of phonebook/entry to 'RASSHARECONN'.
//
#define RasEntryToSharedConnection( _pszPhonebookPath, _pszEntryName, _pConn ) \
( \
    ZeroMemory((_pConn), sizeof(RASSHARECONN)), \
    (_pConn)->dwSize = sizeof(RASSHARECONN), \
    (_pConn)->fIsLanConnection = FALSE, \
    (_pConn)->name.dwSize = sizeof((_pConn)->name), \
    (_pConn)->name.dwFlags = REN_AllUsers, \
    lstrcpynW((_pConn)->name.szPhonebookPath, _pszPhonebookPath, MAX_PATH), \
    lstrcpynW((_pConn)->name.szEntryName, _pszEntryName, RAS_MaxEntryName) \
)

// VOID
// RasGuidToSharedConnection(
//      IN REFGUID          guid,
//      OUT LPRASSHARECONN  pConn );
//
// Macro for conversion of LAN GUID to 'RASSHARECONN'
//
#define RasGuidToSharedConnection( _guid, _pConn ) \
( \
    ZeroMemory((_pConn), sizeof(RASSHARECONN)), \
    (_pConn)->dwSize = sizeof(RASSHARECONN), \
    (_pConn)->fIsLanConnection = TRUE, \
    CopyMemory(&(_pConn)->guid, (_guid), sizeof(GUID)) \
)

// VOID
// RasIsEqualSharedConnection(
//      IN LPRASSHARECONN   pConn1,
//      IN LPRASSHARECONN   pConn2 );
//
// Macro for comparison of 'RASSHARECONN' values
//
#define RasIsEqualSharedConnection( _pConn1, _pConn2 ) \
( \
    ((_pConn1)->fIsLanConnection == (_pConn2)->fIsLanConnection) && \
    ((_pConn1)->fIsLanConnection \
        ? !memcmp(&(_pConn1)->guid, &(_pConn2)->guid, sizeof(GUID)) \
        : (!lstrcmpiW( \
                (_pConn1)->name.szPhonebookPath, \
                (_pConn2)->name.szPhonebookPath) && \
           !lstrcmpiW( \
                (_pConn1)->name.szEntryName, \
                (_pConn2)->name.szEntryName))) \
)

DWORD
APIENTRY
RasAutoDialSharedConnection( VOID );

DWORD
APIENTRY
RasIsSharedConnection(
    IN LPRASSHARECONN   pConn,
    OUT PBOOL           pfShared );

DWORD
APIENTRY
RasQuerySharedAutoDial(
    IN PBOOL            pfEnabled );

DWORD
APIENTRY
RasQuerySharedConnection(
    OUT LPRASSHARECONN  pConn );

DWORD
APIENTRY
RasSetSharedAutoDial(
    IN BOOL             fEnable );

//+---------------------------------------------------------------------------
// Internal RAS APIs
//

DWORD
APIENTRY
DwRasUninitialize();

#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 1200 )
#pragma warning(pop)
#elif ( _MSC_VER >= 800 )
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#pragma warning(default:4514)
#endif
#endif

#endif  // _RASUIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ntddtcp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas) 13-Aug-1993

Revision History:

--*/

#pragma once
#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"

#define DD_TCP_SYMBOLIC_DEVICE_NAME L"\\DosDevices\\Tcp"

//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

typedef struct tcp_blockports_request {
    unsigned long  ReservePorts;   // TRUE if reserve; FALSE otherwise
    union
    {
        unsigned long  NumberofPorts;   // numberofports to reserve
        unsigned long  StartHandle;     // handle to be used to unreserve
    };
} TCP_BLOCKPORTS_REQUEST, *PTCP_BLOCKPORTS_REQUEST;

typedef struct tcp_findtcb_request {
    unsigned long  Src;
    unsigned long  Dest;
    unsigned short DestPort;
    unsigned short SrcPort;
} TCP_FINDTCB_REQUEST, *PTCP_FINDTCB_REQUEST;

typedef struct tcp_findtcb_response {
  ULONG_PTR         tcb_addr;
  unsigned long     tcb_senduna;
  unsigned long     tcb_sendnext;
  unsigned long     tcb_sendmax;
  unsigned long     tcb_sendwin;
  unsigned long     tcb_unacked;
  unsigned long     tcb_maxwin;
  unsigned long     tcb_cwin;
  unsigned short    tcb_mss;
  unsigned long     tcb_rtt;
  unsigned short    tcb_smrtt;
  unsigned short    tcb_rexmitcnt;
  unsigned short    tcb_rexmittimer;
  unsigned short    tcb_rexmit;
  unsigned long     tcb_retrans;
  unsigned short    tcb_state;
  unsigned long     tcb_copied;
} TCP_FINDTCB_RESPONSE, *PTCP_FINDTCB_RESPONSE;


//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_RESERVE_PORT_RANGE  \
            _TCP_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_UNRESERVE_PORT_RANGE  \
            _TCP_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_BLOCK_PORTS  \
            _TCP_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_WSH_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TCP_FINDTCB \
            _IP_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TCP_RCVWND \
            _IP_CTL_CODE(22, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif // _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ntddtc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddtc.h

Abstract:

    This module contains type definitions for the interface between the 
    traffic dll and kernel mode components.
    Definitions here should not be exposed to the external user.
    'traffic.h' and 'qos.h' should be used as public include files instead.

Author:

    Ofer Bar ( oferbar )    Oct 8, 1997

Revision History:

    Ofer Bar ( oferbar )    Dec 1, 1997

        Add error codes

--*/

//---------------------------------------------------------------------------
// 
//      QoS supported guid
// 
//---------------------------------------------------------------------------

DEFINE_GUID( GUID_QOS_TC_SUPPORTED, 0xe40056dcL, 
             0x40c8, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x59, 0x15);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_UP_INDICATION, 
             0x0ca13af0L, 0x46c4, 0x11d1, 0x78, 0xac, 0x00, 0x80, 0x5f, 0x68, 0x35, 0x1e);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_DOWN_INDICATION, 
             0xaf5315e4L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_CHANGE_INDICATION, 
             0xda76a254L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);

DEFINE_GUID( GUID_QOS_SCHEDULING_PROFILES_SUPPORTED, 0x1ff890f0L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_CURRENT_SCHEDULING_PROFILE, 0x2966ed30L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_DISABLE_DRR, 0x1fa6dc7aL, 0x6120, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD_REACHED, 0x357b74d2L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_BUFFER_SIZE, 0x357b74d3L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD, 0x357b74d0L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_DATA, 0x357b74d1L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_LEVEL,0x9dd7f3ae,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);

DEFINE_GUID( GUID_QOS_LOG_MASK,0x9e696320,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);



#ifndef __NTDDTC_H
#define __NTDDTC_H

//
// Kernel NT private error codes
// these should be only returned to the GPC but not
// to NDIS, since WMI will not map them to winerror
//

#define QOS_STATUS_INVALID_SERVICE_TYPE        0xC0020080L
#define QOS_STATUS_INVALID_TOKEN_RATE          0xC0020081L
#define QOS_STATUS_INVALID_PEAK_RATE           0xC0020082L
#define QOS_STATUS_INVALID_SD_MODE             0xC0020083L
#define QOS_STATUS_INVALID_QOS_PRIORITY        0xC0020084L
#define QOS_STATUS_INVALID_TRAFFIC_CLASS       0xC0020085L
#define QOS_STATUS_TC_OBJECT_LENGTH_INVALID    0xC0020086L
#define QOS_STATUS_INVALID_FLOW_MODE           0xC0020087L
#define QOS_STATUS_INVALID_DIFFSERV_FLOW       0xC0020088L
#define QOS_STATUS_DS_MAPPING_EXISTS           0xC0020089L
#define QOS_STATUS_INVALID_SHAPE_RATE          0xC0020090L
#define QOS_STATUS_INVALID_DS_CLASS            0xC0020091L

//
// These are the public QOS error codes
//

#define QOS_STATUS_INCOMPATABLE_QOS                     NDIS_STATUS_INCOMPATABLE_QOS

// The CF_INFO structure for the QoS classification family.
// Note that this is not interpreted by the GPC, but it is shared by 
// all clients of the GPC which are of the QoS classification family.

#define MAX_INSTANCE_NAME_LENGTH        256


typedef struct _CF_INFO_QOS {

    USHORT                      InstanceNameLength;     // name length
    WCHAR                       InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name
    ULONG           ToSValue;
    ULONG                       Flags;
    TC_GEN_FLOW         GenFlow;

} CF_INFO_QOS, *PCF_INFO_QOS;


//
// This is the buffer that the data provider sends up 
// on Interface Up notification
//
typedef struct _TC_INDICATION_BUFFER {

    ULONG                                               SubCode;                // reason for notification
    TC_SUPPORTED_INFO_BUFFER    InfoBuffer;

} TC_INDICATION_BUFFER, *PTC_INDICATION_BUFFER;

//
// Definitions for the Class Map (including CBQ)
//

typedef struct _TC_CLASS_MAP_FLOW {

    ULONG             DefaultClass;                   // Default Class Id
    ULONG             ObjectsLength;                  // Length of Objects
    QOS_OBJECT_HDR    Objects;                                // Offset to Objects

} TC_CLASS_MAP_FLOW, *PTC_CLASS_MAP_FLOW;

typedef struct _CF_INFO_CLASS_MAP {

    USHORT                              InstanceNameLength;     // name length
    WCHAR                               InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name
    
    ULONG                               Flags;
    TC_CLASS_MAP_FLOW   ClassMapInfo;
    
} CF_INFO_CLASS_MAP, *PCF_INFO_CLASS_MAP;

//
// Internal QoS Objects start at this offset from the base
//

#define QOS_PRIVATE_GENERAL_ID_BASE 3000

#define QOS_OBJECT_WAN_MEDIA                   (0x00000001 + QOS_PRIVATE_GENERAL_ID_BASE)
        /* QOS_WAN_MEDIA structure passed */
#define QOS_OBJECT_SHAPER_QUEUE_DROP_MODE	   (0x00000002 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueDropMode structure */
#define QOS_OBJECT_SHAPER_QUEUE_LIMIT          (0x00000003 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueLimit structure */
#define QOS_OBJECT_PRIORITY                    (0x00000004 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_PRIORITY structure passed */

//
// This structure defines the media specific information needed by ndiswan to 
// create a flow.
//
typedef struct _QOS_WAN_MEDIA {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           LinkId[6];
    ULONG           ISSLOW;

} QOS_WAN_MEDIA, *LPQOS_WAN_MEDIA;


//
// This structure allows overriding of the default schema used to drop 
// packets when a flow's shaper queue limit is reached.
//
// DropMethod - 
// 	QOS_SHAPER_DROP_FROM_HEAD - Drop packets from
// 		the head of the queue until the new packet can be
// 		accepted into the shaper under the current limit.  This
// 		behavior is the default.
// 	QOS_SHAPER_DROP_INCOMING - Drop the incoming, 
// 		limit-offending packet.
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT_DROP_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            DropMode;

} QOS_SHAPER_QUEUE_LIMIT_DROP_MODE, *LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE;

#define QOS_SHAPER_DROP_INCOMING	0
#define QOS_SHAPER_DROP_FROM_HEAD	1

//
// This structure allows the default per-flow limit on the shaper queue
// size to be overridden.
//
// QueueSizeLimit - Limit, in bytes, of the size of the shaper queue
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            QueueSizeLimit;

} QOS_SHAPER_QUEUE_LIMIT, *LPQOS_SHAPER_QUEUE_LIMIT;


//
// This structure defines the absolute priorty of the flow.  Priorities in the 
// range of 0-7 are currently defined. Receive Priority is not currently used, 
// but may at some point in the future.
//
typedef struct _QOS_PRIORITY {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           SendPriority;     /* this gets mapped to layer 2 priority.*/
    UCHAR           SendFlags;        /* there are none currently defined.*/
    UCHAR           ReceivePriority;  /* this could be used to decide who 
                                       * gets forwarded up the stack first 
                                       * - not used now */
    UCHAR           Unused;

} QOS_PRIORITY, *LPQOS_PRIORITY;


#define PARAM_TYPE_GQOS_INFO        0xABC0DEF0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\ntddip6.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This header file defines constants and types for accessing
// the MSR IPv6 driver via ioctls.
//


#ifndef _NTDDIP6_
#define _NTDDIP6_

#include <ipexport.h>

//
// We need a definition of CTL_CODE for use below.
// When compiling kernel components in the DDK environment,
// ntddk.h supplies this definition. Otherwise get it
// from devioctl.h in the SDK environment.
//
#ifndef CTL_CODE
#include <devioctl.h>
#endif

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

//
// We also need a definition of TDI_ADDRESS_IP6.
// In the DDK environment, tdi.h supplies this.
// We provide a definition here for the SDK environment.
//
#ifndef TDI_ADDRESS_LENGTH_IP6
#include <packon.h>
typedef struct _TDI_ADDRESS_IP6 {
    USHORT sin6_port;
    ULONG  sin6_flowinfo;
    USHORT sin6_addr[8];
    ULONG  sin6_scope_id;
} TDI_ADDRESS_IP6, *PTDI_ADDRESS_IP6;
#include <packoff.h>

#define TDI_ADDRESS_LENGTH_IP6 sizeof (TDI_ADDRESS_IP6)
#endif

//
// This is the key name of the TCP/IPv6 protocol stack in the registry.
// The protocol driver and the winsock helper both use it.
//
#define TCPIPV6_NAME L"Tcpip6"

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCPV6_DEVICE_NAME      L"\\Device\\Tcp6"
#define DD_UDPV6_DEVICE_NAME      L"\\Device\\Udp6"
#define DD_RAW_IPV6_DEVICE_NAME   L"\\Device\\RawIp6"
#define DD_IPV6_DEVICE_NAME       L"\\Device\\Ip6"

//
// The Windows-accessible device name.  It is the name that
// (prepended with "\\\\.\\") should be passed to CreateFile.
//
#define WIN_IPV6_BASE_DEVICE_NAME L"Ip6"
#define WIN_IPV6_DEVICE_NAME      L"\\\\.\\" WIN_IPV6_BASE_DEVICE_NAME


//
// When an interface is bound, we are passed a name beginning with
// IPV6_BIND_STRING_PREFIX.  However, we register our interfaces with
// TDI using names beginning with IPV6_EXPORT_STRING_PREFIX.
//
#define IPV6_BIND_STRING_PREFIX   L"\\DEVICE\\"
#define IPV6_EXPORT_STRING_PREFIX L"\\DEVICE\\TCPIP6_"

//
// For buffer sizing convenience, bound the link-layer address size.
//
#define MAX_LINK_LAYER_ADDRESS_LENGTH   64

//
// IPv6 IOCTL code definitions.
//
// The codes that use FILE_ANY_ACCESS are open to all users.
// The codes that use FILE_WRITE_ACCESS require local Administrator privs.
//

#define FSCTL_IPV6_BASE FILE_DEVICE_NETWORK

#define _IPV6_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IPV6_BASE, function, method, access)


//
// This IOCTL is used to send an ICMPv6 Echo request.
// It returns the reply (unless there was a timeout or TTL expired).
//
#define IOCTL_ICMPV6_ECHO_REQUEST \
            _IPV6_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct icmpv6_echo_request {
    TDI_ADDRESS_IP6 DstAddress; // Destination address.
    TDI_ADDRESS_IP6 SrcAddress; // Source address.
    unsigned int Timeout;       // Request timeout in milliseconds.
    unsigned char TTL;          // TTL or Hop Count.
    unsigned int Flags;
    // Request data follows this structure in memory.
} ICMPV6_ECHO_REQUEST, *PICMPV6_ECHO_REQUEST;

#define ICMPV6_ECHO_REQUEST_FLAG_REVERSE        0x1     // Use routing header.

typedef struct icmpv6_echo_reply {
    TDI_ADDRESS_IP6 Address;    // Replying address.
    IP_STATUS Status;           // Reply IP_STATUS.
    unsigned int RoundTripTime; // RTT in milliseconds.
    // Reply data follows this structure in memory.
} ICMPV6_ECHO_REPLY, *PICMPV6_ECHO_REPLY;


//
// This IOCTL retrieves information about an interface,
// given an interface index or guid.
// It takes as input an IPV6_QUERY_INTERFACE structure
// and returns as output an IPV6_INFO_INTERFACE structure.
// To perform an iteration, start with Index set to -1, in which case
// only an IPV6_QUERY_INTERFACE is returned, for the first interface.
// If there are no more interfaces, then the Index in the returned
// IPV6_QUERY_INTERFACE will be -1.
//
#define IOCTL_IPV6_QUERY_INTERFACE \
            _IPV6_CTL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_interface {
    unsigned int Index;         // -1 means start/finish iteration,
                                // 0 means use the Guid.
    GUID Guid;
} IPV6_QUERY_INTERFACE;

//
// This IOCTL retrieves persisted information about an interface,
// given a registry index or guid.
// It takes as input an IPV6_PERSISTENT_QUERY_INTERFACE structure
// and returns as output an IPV6_INFO_INTERFACE structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE \
            _IPV6_CTL_CODE(48, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_interface {
    unsigned int RegistryIndex; // -1 means use the Guid.
    GUID Guid;
} IPV6_PERSISTENT_QUERY_INTERFACE;

typedef struct ipv6_info_interface {
    IPV6_QUERY_INTERFACE Next;      // For non-persistent queries only.
    IPV6_QUERY_INTERFACE This;

    //
    // Length of this structure in bytes, not including
    // any link-layer addresses following in memory.
    //
    unsigned int Length;

    //
    // These fields are ignored for updates.
    //
    unsigned int LinkLayerAddressLength;
    unsigned int LocalLinkLayerAddress;  // Offset, zero indicates absence.
    unsigned int RemoteLinkLayerAddress; // Offset, zero indicates absence.

    unsigned int Type;                   // Ignored for updates.
    int RouterDiscovers;                 // Ignored for updates.
    int NeighborDiscovers;               // Ignored for updates.
    int PeriodicMLD;                     // Ignored for updates.
    int Advertises;                      // -1 means no change, else boolean.
    int Forwards;                        // -1 means no change, else boolean.
    unsigned int MediaStatus;            // Ignored for updates.
    int OtherStatefulConfig;             // Ignored for updates.

    unsigned int ZoneIndices[16];        // 0 means no change.

    unsigned int TrueLinkMTU;            // Ignored for updates.
    unsigned int LinkMTU;                // 0 means no change.
    unsigned int CurHopLimit;            // -1 means no change.
    unsigned int BaseReachableTime;      // Milliseconds, 0 means no change.
    unsigned int ReachableTime;          // Milliseconds, ignored for updates.
    unsigned int RetransTimer;           // Milliseconds, 0 means no change.
    unsigned int DupAddrDetectTransmits; // -1 means no change.
    unsigned int Preference;             // -1 means no change.

    // Link-layer addresses may follow.
} IPV6_INFO_INTERFACE;

//
// These values should agree with definitions also
// found in llip6if.h and ip6def.h.
//

#define IPV6_IF_TYPE_LOOPBACK           0
#define IPV6_IF_TYPE_ETHERNET           1
#define IPV6_IF_TYPE_FDDI               2
#define IPV6_IF_TYPE_TUNNEL_AUTO        3
#define IPV6_IF_TYPE_TUNNEL_6OVER4      4
#define IPV6_IF_TYPE_TUNNEL_V6V4        5
#define IPV6_IF_TYPE_TUNNEL_6TO4        6
#define IPV6_IF_TYPE_TUNNEL_TEREDO      7

#define IPV6_IF_MEDIA_STATUS_DISCONNECTED       0
#define IPV6_IF_MEDIA_STATUS_RECONNECTED        1
#define IPV6_IF_MEDIA_STATUS_CONNECTED          2

//
// Initialize the fields of the IPV6_INFO_INTERFACE structure
// to values that indicate no change.
//
__inline void
IPV6_INIT_INFO_INTERFACE(IPV6_INFO_INTERFACE *Info)
{
    memset(Info, 0, sizeof *Info);
    Info->Length = sizeof *Info;

    Info->Type = (unsigned int)-1;
    Info->RouterDiscovers = -1;
    Info->NeighborDiscovers = -1;
    Info->PeriodicMLD = -1;
    Info->Advertises = -1;
    Info->Forwards = -1;
    Info->MediaStatus = (unsigned int)-1;

    Info->CurHopLimit = (unsigned int)-1;
    Info->DupAddrDetectTransmits = (unsigned int)-1;
    Info->Preference = (unsigned int)-1;
}


//
// This IOCTL retrieves information about an address
// on an interface.
//
#define IOCTL_IPV6_QUERY_ADDRESS \
            _IPV6_CTL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_address {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_ADDRESS;

typedef struct ipv6_info_address {
    IPV6_QUERY_ADDRESS Next;
    IPV6_QUERY_ADDRESS This;

    unsigned int Type;
    unsigned int Scope;
    unsigned int ScopeId;

    union {
        struct {  // If it's a unicast address.
            unsigned int DADState;
            unsigned int PrefixConf;
            unsigned int InterfaceIdConf;
            unsigned int ValidLifetime;            // Seconds.
            unsigned int PreferredLifetime;        // Seconds.
        };
        struct {  // If it's a multicast address.
            unsigned int MCastRefCount;
            unsigned int MCastFlags;
            unsigned int MCastTimer;               // Seconds.
        };
    };
} IPV6_INFO_ADDRESS;

//
// Values for address Type.
//
#define ADE_UNICAST   0x00
#define ADE_ANYCAST   0x01
#define ADE_MULTICAST 0x02

//
// Values for address Scope.
//
#define ADE_SMALLEST_SCOPE      0x00
#define ADE_INTERFACE_LOCAL     0x01
#define ADE_LINK_LOCAL          0x02
#define ADE_SUBNET_LOCAL        0x03
#define ADE_ADMIN_LOCAL         0x04
#define ADE_SITE_LOCAL          0x05
#define ADE_ORG_LOCAL           0x08
#define ADE_GLOBAL              0x0e
#define ADE_LARGEST_SCOPE       0x0f

#define ADE_NUM_SCOPES          (ADE_LARGEST_SCOPE - ADE_SMALLEST_SCOPE + 1)

//
// Bit values for MCastFlags.
//
#define MAE_REPORTABLE          0x01
#define MAE_LAST_REPORTER       0x02

//
// Values for PrefixConf.
// These must match the IP_PREFIX_ORIGIN values in iptypes.h.
//
#define PREFIX_CONF_OTHER       0       // None of the ones below.
#define PREFIX_CONF_MANUAL      1       // From a user or administrator.
#define PREFIX_CONF_WELLKNOWN   2       // IANA-assigned.
#define PREFIX_CONF_DHCP        3       // Configured via DHCP.
#define PREFIX_CONF_RA          4       // From a Router Advertisement.

//
// Values for InterfaceIdConf.
// These must match the IP_SUFFIX_ORIGIN values in iptypes.h.
//
#define IID_CONF_OTHER          0       // None of the ones below.
#define IID_CONF_MANUAL         1       // From a user or administrator.
#define IID_CONF_WELLKNOWN      2       // IANA-assigned.
#define IID_CONF_DHCP           3       // Configured via DHCP.
#define IID_CONF_LL_ADDRESS     4       // Derived from the link-layer address.
#define IID_CONF_RANDOM         5       // Random, e.g. anonymous address.

//
// Values for DADState.
//
// The low bit set indicates whether the state is valid.
// Among valid states, bigger is better
// for source address selection.
//
#define DAD_STATE_INVALID    0
#define DAD_STATE_TENTATIVE  1
#define DAD_STATE_DUPLICATE  2
#define DAD_STATE_DEPRECATED 3
#define DAD_STATE_PREFERRED  4

//
// We use this infinite lifetime value for prefix lifetimes,
// router lifetimes, address lifetimes, etc.
//
#define INFINITE_LIFETIME 0xffffffff


//
// This IOCTL retrieves information about an address
// that has been assigned persistently to an interface.
// It takes the IPV6_PERSISTENT_QUERY_ADDRESS structure
// and returns the IPV6_UPDATE_ADDRESS structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS \
            _IPV6_CTL_CODE(47, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_address {
    IPV6_PERSISTENT_QUERY_INTERFACE IF;
    unsigned int RegistryIndex; // -1 means use the Address.
    IPv6Addr Address;
} IPV6_PERSISTENT_QUERY_ADDRESS;


//
// This IOCTL retrieves information from the neighbor cache.
//
#define IOCTL_IPV6_QUERY_NEIGHBOR_CACHE \
            _IPV6_CTL_CODE(3, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_neighbor_cache {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_NEIGHBOR_CACHE;

typedef struct ipv6_info_neighbor_cache {
    IPV6_QUERY_NEIGHBOR_CACHE Query;

    unsigned int IsRouter;                // Whether neighbor is a router.
    unsigned int IsUnreachable;           // Whether neighbor is unreachable.
    unsigned int NDState;                 // Current state of entry.
    unsigned int ReachableTimer;          // Reachable time remaining (in ms).

    unsigned int LinkLayerAddressLength;
    // Link-layer address follows.
} IPV6_INFO_NEIGHBOR_CACHE;

#define ND_STATE_INCOMPLETE 0
#define ND_STATE_PROBE      1
#define ND_STATE_DELAY      2
#define ND_STATE_STALE      3
#define ND_STATE_REACHABLE  4
#define ND_STATE_PERMANENT  5

//
// This IOCTL retrieves information from the route cache.
//
#define IOCTL_IPV6_QUERY_ROUTE_CACHE \
            _IPV6_CTL_CODE(4, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_route_cache {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_ROUTE_CACHE;

typedef struct ipv6_info_route_cache {
    IPV6_QUERY_ROUTE_CACHE Query;

    unsigned int Type;
    unsigned int Flags;
    int Valid;                      // Boolean - FALSE means it is stale.
    IPv6Addr SourceAddress;
    IPv6Addr NextHopAddress;
    unsigned int NextHopInterface;
    unsigned int PathMTU;
    unsigned int PMTUProbeTimer;    // Time until next PMTU probe (in ms).
    unsigned int ICMPLastError;     // Time since last ICMP error sent (in ms).
    unsigned int BindingSeqNumber;
    unsigned int BindingLifetime;   // Seconds.
    IPv6Addr CareOfAddress;
} IPV6_INFO_ROUTE_CACHE;

#define RCE_FLAG_CONSTRAINED_IF         0x1
#define RCE_FLAG_CONSTRAINED_SCOPEID    0x2
#define RCE_FLAG_CONSTRAINED            0x3

#define RCE_TYPE_COMPUTED 1
#define RCE_TYPE_REDIRECT 2


#if 0 // obsolete
//
// This IOCTL retrieves information from the prefix list.
//
#define IOCTL_IPV6_QUERY_PREFIX_LIST \
            _IPV6_CTL_CODE(5, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL retrieves information from the default router list.
//
#define IOCTL_IPV6_QUERY_ROUTER_LIST \
            _IPV6_CTL_CODE(6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL adds a multicast group to the desired interface.
//
#define IOCTL_IPV6_ADD_MEMBERSHIP \
            _IPV6_CTL_CODE(7, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL drops a multicast group.
//
#define IOCTL_IPV6_DROP_MEMBERSHIP \
            _IPV6_CTL_CODE(8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

//
// This IOCTL adds an SP to the SP list.
//
#define IOCTL_IPV6_CREATE_SECURITY_POLICY \
            _IPV6_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_create_security_policy {
    unsigned long SPIndex;                // Index of policy to create.

    unsigned int RemoteAddrField;
    unsigned int RemoteAddrSelector;
    IPv6Addr RemoteAddr;                  // Remote IP Address.
    IPv6Addr RemoteAddrData;

    unsigned int LocalAddrField;          // Single, range, or wildcard.
    unsigned int LocalAddrSelector;       // Packet or policy.
    IPv6Addr LocalAddr;                   // Start of range or single value.
    IPv6Addr LocalAddrData;               // End of range.

    unsigned int TransportProtoSelector;  // Packet or policy.
    unsigned short TransportProto;

    unsigned int RemotePortField;         // Single, range, or wildcard.
    unsigned int RemotePortSelector;      // Packet or policy.
    unsigned short RemotePort;            // Start of range or single value.
    unsigned short RemotePortData;        // End of range.

    unsigned int LocalPortField;          // Single, range, or wildcard.
    unsigned int LocalPortSelector;       // Packet or policy.
    unsigned short LocalPort;             // Start of range or single value.
    unsigned short LocalPortData;         // End of range.

    unsigned int IPSecProtocol;
    unsigned int IPSecMode;
    IPv6Addr RemoteSecurityGWAddr;
    unsigned int Direction;
    unsigned int IPSecAction;
    unsigned long SABundleIndex;
    unsigned int SPInterface;
} IPV6_CREATE_SECURITY_POLICY;


//
// This IOCTL adds an SA to the SA list.
//
#define IOCTL_IPV6_CREATE_SECURITY_ASSOCIATION \
            _IPV6_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_create_security_association {
    unsigned long SAIndex;
    unsigned long SPI;              // Security Parameter Index.
    IPv6Addr SADestAddr;
    IPv6Addr DestAddr;
    IPv6Addr SrcAddr;
    unsigned short TransportProto;
    unsigned short DestPort;
    unsigned short SrcPort;
    unsigned int Direction;
    unsigned long SecPolicyIndex;
    unsigned int AlgorithmId;
    unsigned int RawKeySize;
} IPV6_CREATE_SECURITY_ASSOCIATION;


//
// This IOCTL gets all the SPs from the SP list.
//
#define IOCTL_IPV6_QUERY_SECURITY_POLICY_LIST \
            _IPV6_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_security_policy_list {
    unsigned int SPInterface;
    unsigned long Index;
} IPV6_QUERY_SECURITY_POLICY_LIST;

typedef struct ipv6_info_security_policy_list {
    IPV6_QUERY_SECURITY_POLICY_LIST Query;
    unsigned long SPIndex;
    unsigned long NextSPIndex;

    unsigned int RemoteAddrField;
    unsigned int RemoteAddrSelector;
    IPv6Addr RemoteAddr;                  // Remote IP Address.
    IPv6Addr RemoteAddrData;

    unsigned int LocalAddrField;          // Single, range, or wildcard.
    unsigned int LocalAddrSelector;       // Packet or policy.
    IPv6Addr LocalAddr;                   // Start of range or single value.
    IPv6Addr LocalAddrData;               // End of range.

    unsigned int TransportProtoSelector;  // Packet or policy.
    unsigned short TransportProto;

    unsigned int RemotePortField;         // Single, range, or wildcard.
    unsigned int RemotePortSelector;      // Packet or policy.
    unsigned short RemotePort;            // Start of range or single value.
    unsigned short RemotePortData;        // End of range.

    unsigned int LocalPortField;          // Single, range, or wildcard.
    unsigned int LocalPortSelector;       // Packet or policy.
    unsigned short LocalPort;             // Start of range or single value.
    unsigned short LocalPortData;         // End of range.

    unsigned int IPSecProtocol;
    unsigned int IPSecMode;
    IPv6Addr RemoteSecurityGWAddr;
    unsigned int Direction;
    unsigned int IPSecAction;
    unsigned long SABundleIndex;
    unsigned int SPInterface;
} IPV6_INFO_SECURITY_POLICY_LIST;


//
// This IOCTL gets all the SAs from the SA list.
//
#define IOCTL_IPV6_QUERY_SECURITY_ASSOCIATION_LIST \
            _IPV6_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_security_association_list {
    unsigned long Index;
} IPV6_QUERY_SECURITY_ASSOCIATION_LIST;

typedef struct ipv6_info_security_association_list {
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST Query;
    unsigned long SAIndex;
    unsigned long NextSAIndex;
    unsigned long SPI;              // Security Parameter Index.
    IPv6Addr SADestAddr;  
    IPv6Addr DestAddr;
    IPv6Addr SrcAddr;
    unsigned short TransportProto;
    unsigned short DestPort;
    unsigned short SrcPort;    
    unsigned int Direction;   
    unsigned long SecPolicyIndex;
    unsigned int AlgorithmId;
} IPV6_INFO_SECURITY_ASSOCIATION_LIST;


//
// This IOCTL retrieves information from the route table.
// It takes the IPV6_QUERY_ROUTE_TABLE structure
// and returns the IPV6_INFO_ROUTE_TABLE structure.
//
//
#define IOCTL_IPV6_QUERY_ROUTE_TABLE \
            _IPV6_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_route_table {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
    IPV6_QUERY_NEIGHBOR_CACHE Neighbor;
} IPV6_QUERY_ROUTE_TABLE;

typedef struct ipv6_info_route_table {
    union {
        IPV6_QUERY_ROUTE_TABLE Next;    // Non-persistent query results.
        IPV6_QUERY_ROUTE_TABLE This;    // All other uses.
    };

    unsigned int SitePrefixLength;
    unsigned int ValidLifetime;         // Seconds.
    unsigned int PreferredLifetime;     // Seconds.
    unsigned int Preference;            // Smaller is better. See below.
    unsigned int Type;                  // See values below.
    int Publish;                        // Boolean.
    int Immortal;                       // Boolean.
} IPV6_INFO_ROUTE_TABLE;

//
// The Type field indicates where the route came from.
// These are RFC 2465 ipv6RouteProtocol values.
// Routing protocols are free to define new values.
//
#define RTE_TYPE_SYSTEM         2
#define RTE_TYPE_MANUAL         3
#define RTE_TYPE_AUTOCONF       4
#define RTE_TYPE_RIP            5
#define RTE_TYPE_OSPF           6
#define RTE_TYPE_BGP            7
#define RTE_TYPE_IDRP           8
#define RTE_TYPE_IGRP           9

//
// Standard route preference values.
// The value zero is reserved for administrative configuration.
//
#define ROUTE_PREF_LOW          (16*16*16)
#define ROUTE_PREF_MEDIUM       (16*16)
#define ROUTE_PREF_HIGH         16
#define ROUTE_PREF_ON_LINK      8
#define ROUTE_PREF_LOOPBACK     4
#define ROUTE_PREF_HIGHEST      0


//
// This IOCTL retrieves information about a persistent route.
// It takes the IPV6_PERSISTENT_QUERY_ROUTE_TABLE structure
// and returns the IPV6_INFO_ROUTE_TABLE structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE \
            _IPV6_CTL_CODE(46, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_route_table {
    IPV6_PERSISTENT_QUERY_INTERFACE IF;
    unsigned int RegistryIndex; // -1 means use the parameters below.
    IPv6Addr Neighbor;
    IPv6Addr Prefix;
    unsigned int PrefixLength;
} IPV6_PERSISTENT_QUERY_ROUTE_TABLE;


//
// This IOCTL adds/removes a route in the route table.
// It uses the IPV6_INFO_ROUTE_TABLE structure.
//
#define IOCTL_IPV6_UPDATE_ROUTE_TABLE \
            _IPV6_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_ROUTE_TABLE \
            _IPV6_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL adds/removes an address on an interface.
// It uses the IPV6_UPDATE_ADDRESS structure.
//
#define IOCTL_IPV6_UPDATE_ADDRESS \
            _IPV6_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_ADDRESS \
            _IPV6_CTL_CODE(38, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_update_address {
    IPV6_QUERY_ADDRESS This;
    unsigned int Type;               // Unicast or anycast.
    unsigned int PrefixConf;
    unsigned int InterfaceIdConf;
    unsigned int PreferredLifetime;  // Seconds.
    unsigned int ValidLifetime;      // Seconds.
} IPV6_UPDATE_ADDRESS;


//
// This IOCTL retrieves information from the binding cache.
//
#define IOCTL_IPV6_QUERY_BINDING_CACHE \
            _IPV6_CTL_CODE(16, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_binding_cache {
    IPv6Addr HomeAddress;
} IPV6_QUERY_BINDING_CACHE;

typedef struct ipv6_info_binding_cache {
    IPV6_QUERY_BINDING_CACHE Query;

    IPv6Addr HomeAddress;
    IPv6Addr CareOfAddress;
    unsigned int BindingSeqNumber;
    unsigned int BindingLifetime;   // Seconds.
} IPV6_INFO_BINDING_CACHE;


//
// This IOCTL controls some attributes of an interface.
// It uses the IPV6_INFO_INTERFACE structure.
//
#define IOCTL_IPV6_UPDATE_INTERFACE \
            _IPV6_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_INTERFACE \
            _IPV6_CTL_CODE(36, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL flushes entries from the neighbor cache.
// It uses the IPV6_QUERY_NEIGHBOR_CACHE structure.
//
#define IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE \
            _IPV6_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL flushes entries from the route cache.
// It uses the IPV6_QUERY_ROUTE_CACHE structure.
//
#define IOCTL_IPV6_FLUSH_ROUTE_CACHE \
            _IPV6_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes SA entries from the SA list.
// It uses the IPV6_QUERY_SECURITY_ASSOCIATION_LIST structure.
//
#define IOCTL_IPV6_DELETE_SECURITY_ASSOCIATION \
             _IPV6_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes SP entries from the SP list.
// It uses the IPV6_QUERY_SECURITY_POLICY_LIST structure.
//
#define IOCTL_IPV6_DELETE_SECURITY_POLICY \
             _IPV6_CTL_CODE(21, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes an interface.
// It uses the IPV6_QUERY_INTERFACE structure.
//
// The persistent variant, in addition to deleting the runtime interface,
// also keeps the interface from being (re)created persistently.
// However, it does NOT reset or delete any persistent attributes
// of the interface. For example, suppose you have a persisent tunnel
// interface with a persistent attribute, the interface metric.
// If you delete the tunnel interface and reboot, the tunnel interface
// will be recreated with the non-default interface metric.
// If you persistently delete the tunnel interface and reboot,
// the tunnel interface will not be created. But if you then create
// the tunnel interface, it will get the non-default interface metric.
// This is analogous to persistent attributes on removable ethernet interfaces.
//
#define IOCTL_IPV6_DELETE_INTERFACE \
            _IPV6_CTL_CODE(22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_DELETE_INTERFACE \
            _IPV6_CTL_CODE(44, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#if 0 // obsolete
//
// This IOCTL sets the mobility security to either on or off.
// When mobility security is turned on, Binding Cache Updates
// must be protected via IPsec.
//
#define IOCTL_IPV6_SET_MOBILITY_SECURITY \
            _IPV6_CTL_CODE(23, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_set_mobility_security {
    unsigned int MobilitySecurity;  // See MOBILITY_SECURITY values in ipsec.h.
} IPV6_SET_MOBILITY_SECURITY;
#endif


//
// This IOCTL sorts a list of destination addresses.
// The returned list may contain fewer addresses.
// It uses an array of TDI_ADDRESS_IP6 in/out.
//
#define IOCTL_IPV6_SORT_DEST_ADDRS \
            _IPV6_CTL_CODE(24, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// This IOCTL retrieves information from the site prefix table.
//
#define IOCTL_IPV6_QUERY_SITE_PREFIX \
            _IPV6_CTL_CODE(25, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_site_prefix {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
    IPV6_QUERY_INTERFACE IF;
} IPV6_QUERY_SITE_PREFIX;

typedef struct ipv6_info_site_prefix {
    IPV6_QUERY_SITE_PREFIX Query;

    unsigned int ValidLifetime;  // Seconds.
} IPV6_INFO_SITE_PREFIX;


//
// This IOCTL adds/removes a prefix in the site prefix table.
// It uses the IPV6_INFO_SITE_PREFIX structure.
//
// This ioctl is provided for testing purposes.
// Administrative configuration of site prefixes should never
// be required, because site prefixes are configured from
// Router Advertisements on hosts and from the routing table
// on routers. Hence there is no persistent version of this ioctl.
//
#define IOCTL_IPV6_UPDATE_SITE_PREFIX \
            _IPV6_CTL_CODE(26, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL create a new interface.
// It uses the IPV6_INFO_INTERFACE structure,
// with many fields ignored.
//
#define IOCTL_IPV6_CREATE_INTERFACE \
            _IPV6_CTL_CODE(27, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_CREATE_INTERFACE \
            _IPV6_CTL_CODE(43, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL requests a routing change notification.
// It uses the IPV6_RTCHANGE_NOTIFY_REQUEST (input) and
// IPV6_INFO_ROUTE_TABLE (output) structures.
//
// A notification request completes when a route
// that matches is added or deleted.
// A route matches the requested prefix if the route
// prefix and the request prefix intersect.
// So the ::/0 request prefix matches all route updates.
//
#define IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST \
            _IPV6_CTL_CODE(28, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_rtchange_notify_request {
    unsigned int Flags;
    unsigned int PrefixLength;
    unsigned long ScopeId;
    IPv6Addr Prefix;
} IPV6_RTCHANGE_NOTIFY_REQUEST;

#define IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SYNCHRONIZE   0x1
                // Only one wakeup per requestor per change.
#define IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SUPPRESS_MINE 0x2
                // Ignore route changes from this requestor.


#if 0
//
// This IOCTL retrieves an interface index, given a device name.
// It takes a PWSTR for input, and uses the IPV6_QUERY_INTERFACE structure 
// for output.
//
#define IOCTL_IPV6_QUERY_INTERFACE_INDEX \
            _IPV6_CTL_CODE(29, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif


//
// This IOCTL queries global IPv6 parameters.
// It uses the IPV6_GLOBAL_PARAMETERS structure.
//
// Note that changing these parameters typically does not affect
// existing uses of them. For example changing DefaultCurHopLimit
// will not affect the CurHopLimit of existing interfaces,
// but it will affect the CurHopLimit of new interfaces.
//
#define IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(30, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(49, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_global_parameters {
    unsigned int DefaultCurHopLimit;       // -1 means no change.
    unsigned int UseAnonymousAddresses;    // -1 means no change.
    unsigned int MaxAnonDADAttempts;       // -1 means no change.
    unsigned int MaxAnonValidLifetime;     // -1 means no change.
    unsigned int MaxAnonPreferredLifetime; // -1 means no change.
    unsigned int AnonRegenerateTime;       // -1 means no change.
    unsigned int MaxAnonRandomTime;        // -1 means no change.
    unsigned int AnonRandomTime;           // -1 means no change.
    unsigned int NeighborCacheLimit;       // -1 means no change.
    unsigned int RouteCacheLimit;          // -1 means no change.
    unsigned int BindingCacheLimit;        // -1 means no change.
    unsigned int ReassemblyLimit;          // -1 means no change.
    int MobilitySecurity;                  // Boolean, -1 means no change.
} IPV6_GLOBAL_PARAMETERS;

#define USE_ANON_NO             0       // Don't use anonymous addresses.
#define USE_ANON_YES            1       // Use them.
#define USE_ANON_ALWAYS         2       // Always generating random numbers.
#define USE_ANON_COUNTER        3       // Use them with per-interface counter.

//
// Initialize the fields of the IPV6_GLOBAL_PARAMETERS structure
// to values that indicate no change.
//
__inline void
IPV6_INIT_GLOBAL_PARAMETERS(IPV6_GLOBAL_PARAMETERS *Params)
{
    Params->DefaultCurHopLimit = (unsigned int) -1;
    Params->UseAnonymousAddresses = (unsigned int) -1;
    Params->MaxAnonDADAttempts = (unsigned int) -1;
    Params->MaxAnonValidLifetime = (unsigned int) -1;
    Params->MaxAnonPreferredLifetime = (unsigned int) -1;
    Params->AnonRegenerateTime = (unsigned int) -1;
    Params->MaxAnonRandomTime = (unsigned int) -1;
    Params->AnonRandomTime = (unsigned int) -1;
    Params->NeighborCacheLimit = (unsigned int) -1;
    Params->RouteCacheLimit = (unsigned int) -1;
    Params->BindingCacheLimit = (unsigned int) -1;
    Params->ReassemblyLimit = (unsigned int) -1;
    Params->MobilitySecurity = -1;
}


//
// This IOCTL sets global IPv6 parameters.
// It uses the IPV6_GLOBAL_PARAMETERS structure.
//
// Note that changing these parameters typically does not affect
// existing uses of them. For example changing DefaultCurHopLimit
// will not affect the CurHopLimit of existing interfaces,
// but it will affect the CurHopLimit of new interfaces.
//
#define IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(31, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(37, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL retrieves information from the prefix policy table.
// It takes as input an IPV6_QUERY_PREFIX_POLICY structure
// and returns as output an IPV6_INFO_PREFIX_POLICY structure.
// To perform an iteration, start with PrefixLength set to -1, in which case
// only an IPV6_QUERY_PREFIX_POLICY is returned, for the first policy.
// If there are no more policies, then the PrefixLength in the returned
// IPV6_QUERY_PREFIX_POLICY will be -1.
//
#define IOCTL_IPV6_QUERY_PREFIX_POLICY \
            _IPV6_CTL_CODE(32, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_prefix_policy {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
} IPV6_QUERY_PREFIX_POLICY;

typedef struct ipv6_info_prefix_policy {
    IPV6_QUERY_PREFIX_POLICY Next;      // For non-persistent queries only.
    IPV6_QUERY_PREFIX_POLICY This;

    unsigned int Precedence;
    unsigned int SrcLabel;
    unsigned int DstLabel;
} IPV6_INFO_PREFIX_POLICY;


//
// This IOCTL retrieves information about persisted prefix policies.
// It takes as input an IPV6_PERSISTENT_QUERY_PREFIX_POLICY structure
// and returns as output an IPV6_INFO_PREFIX_POLICY structure.
// (The Next field is not returned.)
// To perform an iteration, start with index 0 and increment
// until getting STATUS_NO_MORE_ENTRIES / ERROR_NO_MORE_ITEMS.
//
// An IOCTL to retrieve persisted prefix policies via prefix
// (like IPV6_QUERY_PREFIX_POLICY) is conceivable but not supported.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY \
            _IPV6_CTL_CODE(50, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_prefix_policy {
    unsigned int RegistryIndex;
} IPV6_PERSISTENT_QUERY_PREFIX_POLICY;


//
// This IOCTL adds a prefix to the prefix policy table,
// or updates an existing prefix policy.
// It uses the IPV6_INFO_PREFIX_POLICY structure.
// (The Next field is ignored.)
//
#define IOCTL_IPV6_UPDATE_PREFIX_POLICY \
            _IPV6_CTL_CODE(33, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_PREFIX_POLICY \
            _IPV6_CTL_CODE(41, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL removes a prefix from the prefix policy table.
// It uses the IPV6_QUERY_PREFIX_POLICY structure.
//
#define IOCTL_IPV6_DELETE_PREFIX_POLICY \
            _IPV6_CTL_CODE(34, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_DELETE_PREFIX_POLICY \
            _IPV6_CTL_CODE(42, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes all manual configuration.
//
#define IOCTL_IPV6_RESET \
            _IPV6_CTL_CODE(39, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_RESET \
            _IPV6_CTL_CODE(45, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL sets the link-layer address of a default router
// on a non-broadcast multi-access (NBMA) link, such as the ISATAP
// link, where Router Solicitations, Router Advertistments, and
// Redirects are desired.
//
// There is no persistent version of this ioctl because
// 6to4svc always configures this information dynamically.
//
#define IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS \
            _IPV6_CTL_CODE(35, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_update_router_ll_address {
    IPV6_QUERY_INTERFACE IF;
    // Following this structure in memory are:
    //   Own link-layer address to use for EUI-64 creation.
    //   Link-layer address of router.
} IPV6_UPDATE_ROUTER_LL_ADDRESS;


//
// This IOCTL renews an interface, meaning that all
// auto-configured state is thrown away and regenerated.
// Same behavior as reconnecting the interface to a link.
// It uses the IPV6_QUERY_INTERFACE structure.
//
#define IOCTL_IPV6_RENEW_INTERFACE \
            _IPV6_CTL_CODE(51, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#pragma warning(pop)
#endif  // ifndef _NTDDIP6_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\sockreg.h ===
FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    );


NTSTATUS
SockOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    );

NTSTATUS
SockOpenKeyEx(
    PHANDLE HandlePtr,
    PUCHAR  KeyName1,
    PUCHAR  KeyName2,
    PUCHAR  KeyName3
    );

NTSTATUS
SockGetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    PULONG ValueType,
    ULONG  ValueLength
    );

NTSTATUS
SockSetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    ULONG ValueType,
    ULONG  ValueLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\remtypes.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    RemTypes.h

Abstract:

    This header file defines character values used in descriptor strings in
    Remote Admin Protocol.

    NOTES   - All pointer types are lower case, except for buffer pointers,
              and the null pointer.

            - REM_BYTE should not be used for parameters, since data is
              never placed on the stack as individual bytes.

            - REM_NULL_PTR is never specified in the call, but may be
              used to replace a pointer type if the pointer itself is NULL.

            - In some cases as indicated below, a descriptor character
              can indicate an array of data items, if followed by an
              ASCII representation of the number of items. For pointer
              types, this is a count of the data items themselves, not
              the pointers. For example, 'b12' describes a pointer
              to 12 bytes of data, not 12 pointers to byte values.

Author:

    LanMan 2.x people.

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Mar-1991 Shanku Niyogi (w-shanku)
        Ported to NT format, and added special 32-bit descriptor characters.

    21-Aug-1991 Jim Waters (t-jamesw)
        Added REM_ASCIZ_COMMENT.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
--*/

#ifndef _REMTYPES_
#define _REMTYPES_

//
// Data types.
//

#define REM_BYTE                'B'     // Byte (s)
#define REM_WORD                'W'     // Word (s)
#define REM_DWORD               'D'     // DWord (s)
#define REM_DATE_TIME           'C'     // Date time field
#define REM_FILL_BYTES          'F'     // Pad field

//
// Pointer types.
//

//
// For internal use, the count following a REM_ASCIZ may specify the maximum
// string length.  On the network no count may be present.
//
// In RapConvertSingleEntry, attempting to copy a REM_ASCIZ into a buffer too
// small to hold it will result in an error.  Use REM_ASCIZ_TRUNCATABLE
// for strings which can be truncated.
//
#define REM_ASCIZ               'z'     // Far pointer to asciz string

#define REM_BYTE_PTR            'b'     // Far pointer to byte(s)
#define REM_WORD_PTR            'w'     // Far pointer to word(s)
#define REM_DWORD_PTR           'd'     // Far pointer to dword(s)

#define REM_RCV_BYTE_PTR        'g'     // Far pointer to rcv byte(s)
#define REM_RCV_WORD_PTR        'h'     // Far pointer to rcv word(s)
#define REM_RCV_DWORD_PTR       'i'     // Far pointer to rcv dword(s)

#define REM_NULL_PTR            'O'     // NULL pointer

//
// Buffer pointer and length types.
//

#define REM_RCV_BUF_PTR         'r'     // Far pointer to receive data buffer
#define REM_RCV_BUF_LEN         'L'     // Word length of receive buffer

#define REM_SEND_BUF_PTR        's'     // Far pointer to send data buffer
#define REM_SEND_BUF_LEN        'T'     // Word length of send buffer

//
// Other special types.
//

#define REM_AUX_NUM             'N'     // !!! Temporary - for compatibility

#define REM_PARMNUM             'P'     // parameter number word

#define REM_ENTRIES_READ        'e'     // Far pointer to entries read word

#define REM_DATA_BLOCK          'K'     // Unstructured data block

#define REM_SEND_LENBUF         'l'     // Far pointer to send data buffer,
                                        // where first word in buffer is the
                                        // length of the buffer.


//
// Items from here on are "internal use only", and should never actually
// appear on the network.
//

//
// The following is used in the MVDM driver to get various API support
//

#define REM_WORD_LINEAR         'a'     // Far linear pointer to word(s)

//
// The following is used while processing 32-bit APIs and 16-bit APIs with
// different padding requirements or info levels with ignored fields.
//

#define REM_IGNORE              'Q'     // Ignore this field (16->32 or
                                        // 32->16 conversions).

//
// A dword version of the auxiliary structure count (for 32-bit data).
//

#define REM_AUX_NUM_DWORD       'A'     // 32-bit dword count of aux structures

//
// Sign extended dword - for 16->32 bit conversion where the 16-bit
//      quantity may represent signed negative quantities which need
//      to be extended over 32 bits.
//

#define REM_SIGNED_DWORD        'X'     // 32-bit signed dword(s)

#define REM_SIGNED_DWORD_PTR    'x'     // Far pointer to signed dword(s)

//
// Truncatable asciz string - If a count is specified, the field only
//     accepts strings up to the specified length.  In
//     RapConvertSingleEntry, if a REM_ASCIZ_TRUNCATABLE is too long to
//     fit in the destination field, the string will be truncated to fit.
//     Use REM_ASCIZ for fields which cannot accept truncated strings.
//

#define REM_ASCIZ_TRUNCATABLE   'c'     // Far pointer to asciz comment
                                        // Count signifies maximum length.

// Time and date in seconds since 1970 (GMT).  In POSIX, this is usually
// called "seconds since the epoch".

#define REM_EPOCH_TIME_GMT      'G'     // 32-bit unsigned num of seconds.

// Time and date in seconds since 1970 (local time zone).

#define REM_EPOCH_TIME_LOCAL    'J'     // 32-bit unsigned num of seconds.

//
// Unsupported fields - for set info calls. A 'U' indicates that a parameter
//     cannot be changed.
//

#define REM_UNSUPPORTED_FIELD   'U'     // Unsupported field

#endif // ndef _REMTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\remdef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RemDef.h

Abstract:

    Definition of descriptor strings for Net API remote calls.
    Names defined in this file follow the format:

                RemPrefix_RemDescriptor

    where RemPrefix is either REM16, REM32, or REMSmb, indicating whether
          the descriptor is for 16-bit or 32-bit data for conversion,
          or for an actual XACT SMB.

          RemDescriptor follows one of the following formats:

             StructureName_level         -  info structures
             StructureName_level_suffix  -  special info structures
             ApiName_P                   -  parameter descriptors

    This file also contains some field index equates.  These are similar
    to parmnum equates, except that the field index equates are guaranteed
    to reflect the field's position in the descriptor.  (See the
    RapParmNumDescriptor routine for more information on how this is used.)
    If the parmnum value (in the LM*.H header files) is identical to the
    field index value, then no field index equate is given.  Where the numbers
    are different, then for each parmnum of the form:

                ParmNumPrefix_PARMNUM

    this file will have an equate of the form:

                ParmNumPrefix_FIELDINDEX

    where ParmNumPrefix is, for instance, PRJ_PRIORITY (for print job priority).

Notes:

    1. While the above formats should be followed, the equate names
       cannot exceed 32 characters, and abbreviated forms should be used.

    2. The remote API mechanism requires that the return parameter length
       is less than or equal to the send parameter length. This assumption
       is made in order to reduce the overhead in the buffer management
       required for the API call. This restriction is not unreasonable
       as the APIs were designed to return data in the data buffer and just
       use return parameters for data lengths & file handles etc.
       HOWEVER, if it has been spec'ed to return a large parameter field, it
       is possible to pad the size of the send parameter using a REM_FILL_BYTES
       field to meet the above restriction.

    3. Some of the descriptors have different size byte arrays in the 16 and
       32-bit versions.  This allows the 32-bit version to be UNICODE where
       the 16-bit version is an 8-bit (codepage) string.  RapConvertSingleEntry
       automatically makes this conversion if it detects one byte count being
       twice the other's.

Author:

    John Rogers (JohnRo)
    Shanku Niyogi (w-shanku)

Environment:

    Portable to just about anything.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Ported from Lanman 2.0 code.

    17-Jan-1992 rfirth
        Changed REM32_share_info_2 from "zQDzDDDzzQ" to "zQDzDXDzzQ" to allow
        shi2_max_uses field to go from -1 (0xffff) to -1L (0xffffffff), not
        65535L

    17-Aug-1992 JohnRo
        RAID 3607: REPLLOCK.RP$ is being created during tree copy.
        Re-ordered revision history.
    01-Sep-1992 JohnRo
        RAID 5088: NetGetDCName to downlevel doesn't UNICODE translate.
    09-Sep-1992 JohnRo
        RAID 1100: last string in access type truncated in NetAuditRead.
--*/

#ifndef _REMDEF_
#define _REMDEF_

//====================================================================
//
// Conversion descriptors. The 16 and 32 bit versions must have the
// same number of fields. Fields not present in one version can be
// indicated with the REM_IGNORE ('Q') character.
//
// These strings should NOT be passed over the network.
//
//====================================================================

#define REM16_share_info_0              "B13"
#define REM32_share_info_0              "z"
#define REM16_share_info_1              "B13BWz"
#define REM32_share_info_1              "zQDz"
#define REM16_share_info_2              "B13BWzWWWzB9B"
#define REM32_share_info_2              "zQDzDXDzzQ"

#define SHI_REMARK_FIELDINDEX           4
#define SHI_PERMISSIONS_FIELDINDEX      5
#define SHI_MAX_USES_FIELDINDEX         6
#define SHI_PASSWD_FIELDINDEX           9

#define REM16_share_info_90             "B13BWz"
#define REM16_share_info_92             "zzz"
#define REM16_share_info_93             "zzz"

#define REM16_share_info_0_setinfo      "U"
#define REM32_share_info_0_setinfo      "z"
#define REM16_share_info_1_setinfo      "UUUz"
#define REM32_share_info_1_setinfo      "zQDz"
#define REM16_share_info_2_setinfo      "UUUzWWUUB9U"
#define REM32_share_info_2_setinfo      "zQDzQDDzQQ"

#define REM16_share_info_90_setinfo     "B13BWz"
#define REM16_share_info_91_setinfo     "B13BWzWWWOB9BB9BWzWWzWW"

#define REM16_NetShareEnum_P            "WrLeh"
#define REM16_NetShareGetInfo_P         "zWrLh"
#define REM16_NetShareSetInfo_P         "zWsTP"
#define REM16_NetShareAdd_P             "WsT"
#define REM16_NetShareDel_P             "zW"
#define REM16_NetShareCheck_P           "zh"

#define REM16_session_info_0            "z"
#define REM32_session_info_0            "z"
#define REM16_session_info_1            "zzWWWDDD"
#define REM32_session_info_1            "zzQDQDDD"
#define REM16_session_info_2            "zzWWWDDDz"
#define REM32_session_info_2            "zzQDQDDDz"
#define REM16_session_info_10           "zzDD"
#define REM32_session_info_10           "zzDD"

#define REM16_NetSessionEnum_P          "WrLeh"
#define REM16_NetSessionGetInfo_P       "zWrLh"
#define REM16_NetSessionDel_P           "zW"

#define REM16_connection_info_0         "W"
#define REM32_connection_info_0         "D"
#define REM16_connection_info_1         "WWWWDzz"
#define REM32_connection_info_1         "DDDDDzz"

#define REM16_NetConnectionEnum_P       "zWrLeh"

#define REM16_file_info_0               "W"
#define REM32_file_info_0               "D"
#define REM16_file_info_1               "WWWzz"
#define REM32_file_info_1               "DDDzz"
#define REM16_file_info_2               "D"
#define REM32_file_info_2               "D"
#define REM16_file_info_3               "DWWzz"
#define REM32_file_info_3               "DDDzz"
#define REM16_file_info_50              "QB16BBDZ??ZZZ"

#define REM16_NetFileEnum_P             "zWrLeh"
#define REM16_NetFileEnum2_P            "zzWrLehb8g8"
#define REM16_NetFileGetInfo_P          "WWrLh"
#define REM16_NetFileGetInfo2_P         "DWrLh"
#define REM16_NetFileClose_P            "W"
#define REM16_NetFileClose2_P           "D"

#define REM16_server_info_0             "QB16"
#define REM32_server_info_0             "Dz"
#define REM16_server_info_1             "QB16BBDz"
#define REM32_server_info_1             "DzDDDz"
#define REM16_server_info_2             "QB16BBDzJJJWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWz"
#define REM32_server_info_2             "DzDDDzQQQDXQQQQQDDDQDzQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM16_server_info_3             "QB16BBDzJJJWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWzDWz"
#define REM32_server_info_3             "DzDDDzQQQDXQQQQQDDDQDzQQQQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM32_server_info_50            "QB16BBDzWWzzz"

#define REM32_server_info_100           "Dz"
#define REM32_server_info_101           "DzDDDz"
#define REM32_server_info_102           "DzDDDzDDWDDDz"
#define REM32_server_info_402           "DDDzDDDzDDDDDDDDDDDDDDDDDDDDDDz"
#define REM32_server_info_403           "DDDzDDDzDDDDDDDDDDDDDDDDDDDDDDzDDz"

#define REM16_server_info_1_setinfo     "B16BBDz"
#define REM32_server_info_1_setinfo     "zDDDz"
#define REM16_server_info_2_setinfo     "B16BBDzDDDWWzWWWWWWWB21BOWWWWWWWWWWWWWWWWWWWWWWz"
#define REM32_server_info_2_setinfo     "zDDDzQQQDDQQQQQWDDQQOQQQQQQQQQQQQQQQQQQQQQQQ"

#define REM16_server_admin_command      "B"

#define REM16_server_diskenum_0         "B3"
#define REM32_server_diskenum_0         "B3"

#define REM16_authenticator_info_0      "B8D"

#define REM16_server_diskft_100         "B"
#define REM16_server_diskft_101         "BBWWWWDW"
#define REM16_server_diskft_102         "BBWWWWDN"
#define REM16_server_diskfterr_0        "DWWDDW"
#define REM16_ft_info_0                 "WWW"
#define REM16_ft_drivestats_0           "BBWDDDDDDD"
#define REM16_ft_error_info_1           "DWWDDWBBDD"

#define REM16_I_NetServerDiskEnum_P     "WrLeh"
#define REM16_I_NetServerDiskGetInfo_P  "WWrLh"
#define REM16_I_FTVerifyMirror_P        "Wz"
#define REM16_I_FTAbortVerify_P         "W"
#define REM16_I_FTGetInfo_P             "WrLh"
#define REM16_I_FTSetInfo_P             "WsTP"
#define REM16_I_FTLockDisk_P            "WWh"
#define REM16_I_FTFixError_P            "Dzhh2"
#define REM16_I_FTAbortFix_P            "D"
#define REM16_I_FTDiagnoseError_P       "Dhhhh"
#define REM16_I_FTGetDriveStats_P       "WWrLh"
#define REM16_I_FTErrorGetInfo_P        "DWrLh"

#define REM16_NetServerEnum_P           "WrLeh"
#define REM16_I_NetServerEnum_P         "WrLeh"
#define REM16_NetServerEnum2_P          "WrLehDz"
#define REM16_I_NetServerEnum2_P        "WrLehDz"
#define REM16_NetServerGetInfo_P        "WrLh"
#define REM16_NetServerSetInfo_P        "WsTP"
#define REM16_NetServerDiskEnum_P       "WrLeh"
#define REM16_NetServerAdminCommand_P   "zhrLeh"
#define REM16_NetServerReqChalleng_P    "zb8g8"
#define REM16_NetServerAuthenticat_P    "zb8g8"
#define REM16_NetServerPasswordSet_P    "zb12g12b16"

#define REM16_NetAuditOpen_P            "h"
#define REM16_NetAuditClear_P           "zz"
#define REM16_NetAuditRead_P            "zb16g16DhDDrLeh"

#define REM16_audit_entry_fixed         "WWJWW"
#define REM32_audit_entry_fixed         "DDGDD"
#define REM16_audit_entry_srvstatus     "W"
#define REM32_audit_entry_srvstatus     "D"
#define REM16_audit_entry_sesslogon     "WWW"
#define REM32_audit_entry_sesslogon     "DDD"
#define REM16_audit_entry_sesslogoff    "WWW"
#define REM32_audit_entry_sesslogoff    "DDD"
#define REM16_audit_entry_sesspwerr     "WW"
#define REM32_audit_entry_sesspwerr     "DD"
#define REM16_audit_entry_connstart     "WWWW"
#define REM32_audit_entry_connstart     "DDDD"
#define REM16_audit_entry_connstop      "WWWWW"
#define REM32_audit_entry_connstop      "DDDDD"
#define REM16_audit_entry_connrej       "WWWW"
#define REM32_audit_entry_connrej       "DDDD"
#define REM16_audit_entry_resaccess     "WWWWWWW"
#define REM32_audit_entry_resaccess     "DDDDDDD"
#define REM16_audit_entry_resaccess2    "WWWWWWD"
// Note: 16-bit ae_resaccess and ae_resaccess2 both get converted to
// 32-bit ae_resaccess.
#define REM16_audit_entry_resaccessrej  "WWWW"
#define REM32_audit_entry_resaccessrej  "DDDD"
#define REM16_audit_entry_closefile     "WWWWDW"
#define REM32_audit_entry_closefile     "DDDDDD"
#define REM16_audit_entry_servicestat   "WWWWDWW"
#define REM32_audit_entry_servicestat   "DDDDDDD"
#define REM16_audit_entry_aclmod        "WWWWW"
#define REM32_audit_entry_aclmod        "DDDDD"
#define REM16_audit_entry_uasmod        "WWWWWW"
#define REM32_audit_entry_uasmod        "DDDDDD"
#define REM16_audit_entry_netlogon      "WWWW"
#define REM32_audit_entry_netlogon      "DDDD"
#define REM16_audit_entry_netlogoff     "WWWW"
#define REM32_audit_entry_netlogoff     "DDDD"
#define REM16_audit_entry_acclim        "WWWW"
#define REM32_audit_entry_acclim        "DDDD"
#define REM16_audit_entry_lockout       "WWWW"
#define REM32_audit_entry_lockout       "DDDD"

#define REM16_AuditLogReturnBuf         "K"

#define REM16_NetErrorLogOpen_P         "h"
#define REM16_NetErrorLogClear_P        "zz"
#define REM16_NetErrorLogRead_P         "zb16g16DhDDrLeh"

#define REM16_ErrorLogReturnBuf         "K"

#define REM16_chardev_info_0            "B9"
#define REM32_chardev_info_0            "z"
#define REM16_chardev_info_1            "B10WB22D"
#define REM32_chardev_info_1            "zDzD"
#define REM16_chardevQ_info_0           "B13"
#define REM32_chardevQ_info_0           "z"
#define REM16_chardevQ_info_1           "B14WzWW"
#define REM32_chardevQ_info_1           "zDzDD"

#define REM16_chardevQ_info_1_setinfo   "UWzUU"
#define REM32_chardevQ_info_1_setinfo   "QWzQQ"

#define REM16_NetCharDevEnum_P          "WrLeh"
#define REM16_NetCharDevGetInfo_P       "zWrLh"
#define REM16_NetCharDevControl_P       "zW"
#define REM16_NetCharDevQEnum_P         "zWrLeh"
#define REM16_NetCharDevQGetInfo_P      "zzWrLh"
#define REM16_NetCharDevQSetInfo_P      "zWsTP"
#define REM16_NetCharDevQPurge_P        "z"
#define REM16_NetCharDevQPurgeSelf_P    "zz"

#define REM16_msg_info_0                "B16"
#define REM32_msg_info_0                "z"
#define REM16_msg_info_1                "B16BBB16"
#define REM32_msg_info_1                "zQDz"
#define REM16_send_struct               "K"

#define REM16_NetMessageNameEnum_P      "WrLeh"
#define REM16_NetMessageNameGetInfo_P   "zWrLh"
#define REM16_NetMessageNameAdd_P       "zW"
#define REM16_NetMessageNameDel_P       "zW"
#define REM16_NetMessageNameFwd_P       "zzW"
#define REM16_NetMessageNameUnFwd_P     "z"
#define REM16_NetMessageBufferSend_P    "zsT"
#define REM16_NetMessageFileSend_P      "zz"
#define REM16_NetMessageLogFileSet_P    "zW"
#define REM16_NetMessageLogFileGet_P    "rLh"

#define REM16_service_info_0            "B16"
#define REM32_service_info_0            "z"
#define REM16_service_info_1            "B16WDW"
#define REM32_service_info_1            "zDDD"
#define REM16_service_info_2            "B16WDWB64QQ"
#define REM32_service_info_2            "zDDDzDz"
#define REM16_service_cmd_args          "K"

#define REM16_NetServiceEnum_P          "WrLeh"
#define REM16_NetServiceControl_P       "zWWrL"
#define REM16_NetServiceInstall_P       "zF88sg88T"     // See NOTE 2
#define REM16_NetServiceGetInfo_P       "zWrLh"

#define REM16_access_info_0             "z"
#define REM32_access_info_0             "z"
#define REM16_access_info_0_setinfo     "z"
#define REM32_access_info_0_setinfo     "z"
#define REM16_access_info_1             "zWN"
#define REM32_access_info_1             "zDA"
#define REM16_access_info_1_setinfo     "OWN"
#define REM32_access_info_1_setinfo     "ODA"
#define REM16_access_list               "B21BW"
#define REM16_access_list_filler        "QQQ"
#define REM32_access_list               "zQD"

#define ACCESS_ATTR_FIELDINDEX          2

#define REM16_NetAccessEnum_P           "zWWrLeh"
#define REM16_NetAccessGetInfo_P        "zWrLh"
#define REM16_NetAccessSetInfo_P        "zWsTP"
#define REM16_NetAccessAdd_P            "WsT"
#define REM16_NetAccessDel_P            "z"
#define REM16_NetAccessGetUserPerms_P   "zzh"

#define REM16_group_info_0              "B21"
#define REM32_group_info_0              "z"
#define REM16_group_info_1              "B21Bz"
#define REM32_group_info_1              "zQz"
#define REM16_group_users_info_0        "B21"
#define REM32_group_users_info_0        "z"
#define REM16_group_users_info_1        "B21BN"
#define REM16_group_users_info_0_set    "B21BN"
#define REM32_group_users_info_0_set    "zQA"

#define REM16_group_info_1_setinfo      "UUz"
#define REM32_group_info_1_setinfo      "QQz"

#define GRPI_COMMENT_FIELDINDEX         3

#define REM16_NetGroupEnum_P            "WrLeh"
#define REM16_NetGroupAdd_P             "WsT"
#define REM16_NetGroupDel_P             "z"
#define REM16_NetGroupAddUser_P         "zz"
#define REM16_NetGroupDelUser_P         "zz"
#define REM16_NetGroupGetUsers_P        "zWrLeh"
#define REM16_NetGroupSetUsers_P        "zWsTW"
#define REM16_NetGroupGetInfo_P         "zWrLh"
#define REM16_NetGroupSetInfo_P         "zWsTP"

#define REM16_user_info_0               "B21"
#define REM32_user_info_0               "z"
#define REM16_user_info_1               "B21BB16DWzzWz"
#define REM32_user_info_1               "zQb16DDzzDz"
#define REM32_user_info_1_NOCRYPT       "zQzDDzzDz"
#define REM32_user_info_1_OWF           "zQB16DDzzDz"
#define REM16_user_info_2               "B21BB16DWzzWzDzzzzJJJDWb21WWzWW"
#define REM32_user_info_2               "zQb16DDzzDzDzzzzGGGDDb21DDzDD"
#define REM32_user_info_2_NOCRYPT       "zQzDDzzDzDzzzzGGGDDb21DDzDD"
#define REM32_user_info_22              "zQB16DDzzDzDzzzzGGGDDb21DDzDD"
#define REM16_user_info_10              "B21Bzzz"
#define REM32_user_info_10              "zQzzz"
#define REM16_user_info_11              "B21BzzzWDDzzJJWWzWzDWb21W"
#define REM32_user_info_11              "zQzzzDDDzzGGDDzDzDDb21D"

#define REM16_user_info_1_setinfo       "UUB16UWzzWz"
#define REM32_user_info_1_setinfo       "zQB16DDzzDz"
#define REM32_user_info_1_setinfo_NOCRYPT "zQzDDzzDz"
#define REM16_user_info_2_setinfo       "UUB16UWzzWzDzzzzUUJDWB21WWzWW"
#define REM32_user_info_2_setinfo       "QQzQDzzDzDzzzzQQGDDB21DDzDD"
#define REM32_user_info_2_setinfo_NOCRYPT "QQzQDzzDzDzzzzQQGDDB21DDzDD"

#define REM32_user_info_3               "zQb16DDzzDzDzzzzGGGDDb21DDzDDDDzzD"
#define REM32_user_info_3_NOCRYPT       "zQzDDzzDzDzzzzGGGDDb21DDzDDDDzzD"

#define REM32_user_info_3_setinfo         "QQzQDzzDzDzzzzQQGDDB21DDzDDDDzzD"
#define REM32_user_info_3_setinfo_NOCRYPT "QQzQDzzDzDzzzzQQGDDB21DDzDDDDzzD"


#define USER_PASSWD_FIELDINDEX          3
#define USER_PRIV_FIELDINDEX            5
#define USER_DIR_FIELDINDEX             6
#define USER_COMMENT_FIELDINDEX         7
#define USER_USER_FLAGS_FIELDINDEX      8
#define USER_SCRIPT_PATH_FIELDINDEX     9
#define USER_AUTH_FLAGS_FIELDINDEX      10
#define USER_FULL_NAME_FIELDINDEX       11
#define USER_USR_COMMENT_FIELDINDEX     12
#define USER_PARMS_FIELDINDEX           13
#define USER_WORKSTATION_FIELDINDEX     14
#define USER_ACCT_EXPIRES_FIELDINDEX    17
#define USER_MAX_STORAGE_FIELDINDEX     18
#define USER_LOGON_HOURS_FIELDINDEX     20
#define USER_LOGON_SERVER_FIELDINDEX    23
#define USER_COUNTRY_CODE_FIELDINDEX    24
#define USER_CODE_PAGE_FIELDINDEX       25

#define REM16_user_info_100             "DWW"
#define REM16_user_info_101             "B60"
#define REM16_user_modals_info_0        "WDDDWW"
#define REM32_user_modals_info_0        "DDDDDQ"


#define MODAL0_MIN_LEN_FIELDINDEX       1
#define MODAL0_MAX_AGE_FIELDINDEX       2
#define MODAL0_MIN_AGE_FIELDINDEX       3
#define MODAL0_FORCEOFF_FIELDINDEX      4
#define MODAL0_HISTLEN_FIELDINDEX       5

#define REM16_user_modals_info_1        "Wz"
#define REM32_user_modals_info_1        "Dz"

#define REM16_user_modals_info_0_setinfo "WDDDWU"
#define REM32_user_modals_info_0_setinfo "DDDDDQ"
#define REM16_user_modals_info_1_setinfo "Wz"
#define REM32_user_modals_info_1_setinfo "Dz"

#define MODAL1_ROLE_FIELDINDEX          1
#define MODAL1_PRIMARY_FIELDINDEX       2

#define REM16_user_modals_info_100      "B50"
#define REM16_user_modals_info_101      "zDDzDD"
#define REM16_user_logon_info_0         "B21B"
#define REM32_user_logon_info_0         "zQ"
#define REM16_user_logon_info_1         "WB21BWDWWJJJJDJJzzzD"
#define REM32_user_logon_info_1         "QzQDDDDGGGGDGGzzzD"
#define REM16_user_logon_info_2         "B21BzzzJ"
#define REM32_user_logon_info_2         "zQzzzG"
#define REM16_user_logoff_info_1        "WDW"
#define REM32_user_logoff_info_1        "QDW"

#define REM16_NetUserEnum_P             "WrLeh"
#define REM16_NetUserAdd_P              "WsTW"
#define REM16_NetUserAdd2_P             "WsTWW"
#define REM16_NetUserDel_P              "z"
#define REM16_NetUserGetInfo_P          "zWrLh"
#define REM16_NetUserSetInfo_P          "zWsTPW"
#define REM16_NetUserSetInfo2_P         "zWsTPWW"
#define REM16_NetUserPasswordSet_P      "zb16b16W"
#define REM16_NetUserPasswordSet2_P     "zb16b16WW"
#define REM16_NetUserGetGroups_P        "zWrLeh"
#define REM16_NetUserSetGroups_P        "zWsTW"
#define REM16_NetUserModalsGet_P        "WrLh"
#define REM16_NetUserModalsSet_P        "WsTP"
#define REM16_NetUserEnum2_P            "WrLDieh"
#define REM16_NetUserValidate2_P        "Wb62WWrLhWW"

#define REM16_wksta_info_0              "QWDzzzzQBBQQDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REM32_wksta_info_0              "DQQQzQzzDDDzQQQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM16_wksta_info_1              "QWDzzzzQBBQQDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REM16_wksta_info_10             "QzzzQBBzz"
#define REM32_wksta_info_100            "DzzDD"
#define REM32_wksta_info_101            "DzzDDz"
#define REM32_wksta_info_102            "DzzDDzD"
#define REM32_wksta_info_302            "DDDDDDDDDDDDDDDDDzDzD"
#define REM32_wksta_info_402            "DDDDDDDDDDDDDDDDDzDDD"
#define REM32_wksta_info_502            "DDDDDDDDDDDDDDDDDBBBBBBBBBBBBBB"

#define REM16_use_info_0                "B9Bz"
#define REM32_use_info_0                "zQz"
#define REM16_use_info_1                "B9BzzWWWW"
#define REM32_use_info_1                "zQzzDDDD"

#define REM16_printQ_0                  "B13"
#ifndef UNICODE
#define REM32_printQ_0                  REM16_printQ_0
#else
#define REM32_printQ_0                  "B26"
#endif
// Can't do set info of level 0.

#define REM16_printQ_1                  "B13BWWWzzzzzWW"
#ifndef UNICODE
#define REM32_printQ_1                  REM16_printQ_1
#else
#define REM32_printQ_1                  "B26WWWWzzzzzWW"
#endif
#define PRQ_PRIORITY_LVL1_FIELDINDEX         3
#define PRQ_STARTTIME_LVL1_FIELDINDEX         4
#define PRQ_UNTILTIME_LVL1_FIELDINDEX          5
#define PRQ_SEPARATOR_LVL1_FIELDINDEX           6
#define PRQ_PROCESSOR_LVL1_FIELDINDEX            7
#define PRQ_DESTINATIONS_LVL1_FIELDINDEX          8
#define PRQ_PARMS_LVL1_FIELDINDEX                  9
#define PRQ_COMMENT_LVL1_FIELDINDEX                 10

#define REM16_printQ_1_setinfo          "UUWWWzzzzzUU"
#define REM32_printQ_1_setinfo          REM32_printQ_1

#define REM16_printQ_2                  "B13BWWWzzzzzWN"
#ifndef UNICODE
#define REM32_printQ_2                  REM16_printQ_2
#else
#define REM32_printQ_2                  "B26WWWWzzzzzWN"
#endif
// Can't do set info of level 2.

#define REM16_printQ_3                  "zWWWWzzzzWWzzl"
#define REM32_printQ_3                  REM16_printQ_3
#define PRQ_PRIORITY_LVL3_FIELDINDEX      2
#define PRQ_STARTTIME_LVL3_FIELDINDEX      3
#define PRQ_UNTILTIME_LVL3_FIELDINDEX       4
#define PRQ_SEPARATOR_LVL3_FIELDINDEX         6
#define PRQ_PROCESSOR_LVL3_FIELDINDEX          7
#define PRQ_PARMS_LVL3_FIELDINDEX               8
#define PRQ_COMMENT_LVL3_FIELDINDEX              9
#define PRQ_PRINTERS_LVL3_FIELDINDEX                12
#define PRQ_DRIVERNAME_LVL3_FIELDINDEX               13
#define PRQ_DRIVERDATA_LVL3_FIELDINDEX                14

#define REM16_printQ_3_setinfo          "UWWWUzzzzUUzzl"
#define REM32_printQ_3_setinfo          REM32_printQ_3

#define REM16_printQ_4                  "zWWWWzzzzWNzzl"
#define REM32_printQ_4                  REM16_printQ_4
// Can't do set info of level 4.

#define REM16_printQ_5                  "z"
#define REM32_printQ_5                  REM16_printQ_5
// Can't do set info of level 5.

#define REM16_printQ_52                 "WzzzzzzzzWzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
#define REM32_printQ_52                 REM16_printQ_52

#define REM16_DosPrintQEnum_P           "WrLeh"
#define REM16_DosPrintQGetInfo_P        "zWrLh"
#define REM16_DosPrintQSetInfo_P        "zWsTP"
#define REM16_DosPrintQAdd_P            "WsT"
#define REM16_DosPrintQDel_P            "z"
#define REM16_DosPrintQPause_P          "z"
#define REM16_DosPrintQPurge_P          "z"
#define REM16_DosPrintQContinue_P       "z"

#define REM16_print_job_0               "W"
#define REM32_print_job_0               REM16_print_job_0
// print_job_0 cannot be used with setinfo.

#define REM16_print_job_1               "WB21BB16B10zWWzJDz"
#ifndef UNICODE
#define REM32_print_job_1               "WB21BB16B10zWWzGDz"
#else
#define REM32_print_job_1               "WB42WB32B20zWWzGDz"
#endif
#define PRJ_NOTIFYNAME_LVL1_FIELDINDEX        4
#define PRJ_DATATYPE_LVL1_FIELDINDEX             5
#define PRJ_PARMS_LVL1_FIELDINDEX                   6
#define PRJ_POSITION_LVL1_FIELDINDEX                 7
#define PRJ_COMMENT_LVL1_FIELDINDEX                       12

#define REM16_print_job_1_setinfo       "UUUB16B10zWUUUUz"
#define REM32_print_job_1_setinfo       REM32_print_job_1

#define REM16_print_job_2               "WWzWWJDzz"
#define REM32_print_job_2               "WWzWWGDzz"
// print_job_2 cannot be used with setinfo.

#define REM16_print_job_3               "WWzWWJDzzzzzzzzzzlz"
#define REM32_print_job_3               "WWzWWGDzzzzzzzzzzlz"
#define PRJ_PRIORITY_LVL3_FIELDINDEX      2
#define PRJ_POSITION_LVL3_FIELDINDEX        4
#define PRJ_COMMENT_LVL3_FIELDINDEX             8
#define PRJ_DOCUMENT_LVL3_FIELDINDEX             9
#define PRJ_NOTIFYNAME_LVL3_FIELDINDEX            10
#define PRJ_DATATYPE_LVL3_FIELDINDEX               11
#define PRJ_PARMS_LVL3_FIELDINDEX                   12
#define PRJ_PROCPARMS_LVL3_FIELDINDEX                   16
#define PRJ_DRIVERDATA_LVL3_FIELDINDEX                    18

#define REM16_print_job_3_setinfo       "UWUWUUUzzzzzUUUzUlU"
#define REM32_print_job_3_setinfo       REM32_print_job_3

#define REM16_print_job_info_1_setinfo  "WB21BB16B10zWWODDz"
#define REM16_print_job_info_3_setinfo  "WWzWWDDzzzzzOzzzzlO"

#define REM16_DosPrintJobEnum_P         "zWrLeh"
#define REM16_DosPrintJobGetInfo_P      "WWrLh"
#define REM16_DosPrintJobSetInfo_P      "WWsTP"
#define REM16_DosPrintJobAdd_P          "zsTF129g129h"  // See note 2
#define REM16_DosPrintJobSchedule_P     "W"
#define REM16_DosPrintJobDel_P          "W"
#define REM16_DosPrintJobPause_P        "W"
#define REM16_DosPrintJobContinue_P     "W"

#define REM16_print_dest_0              "B9"
#ifndef UNICODE
#define REM32_print_dest_0              REM16_print_dest_0
#else
#define REM32_print_dest_0              "B18"
#endif
// Can't do set info of level 0.

#define REM16_print_dest_1              "B9B21WWzW"
#ifndef UNICODE
#define REM32_print_dest_1              REM16_print_dest_1
#else
#define REM32_print_dest_1              "B18B42WWzW"
#endif
// Can't do set info of level 1.

#define REM16_print_dest_2              "z"
#define REM32_print_dest_2              REM16_print_dest_2
// Can't do set info of level 2.

#define REM16_print_dest_3              "zzzWWzzzWW"
#define REM32_print_dest_3              REM16_print_dest_3
#define REM16_print_dest_info_3_setinfo "zOzWWOzzWW"
// Level 3 parmnums and field indexes are identical, so no equates here.

#define REM16_print_dest_3_setinfo      "UUzUUUzzUU"
#define REM32_print_dest_3_setinfo      REM32_print_dest_3

#define REM16_DosPrintDestEnum_P        "WrLeh"
#define REM16_DosPrintDestGetInfo_P     "zWrLh"
#define REM16_DosPrintDestControl_P     "zW"
#define REM16_DosPrintDestAdd_P         "WsT"
#define REM16_DosPrintDestSetInfo_P     "zWsTP"
#define REM16_DosPrintDestDel_P         "z"

#define REM16_NetProfileSave_P          "zDW"
#define REM16_NetProfileLoad_P          "zDrLD"

#define REM16_profile_load_info         "WDzD"

#define REM16_statistics_info           "B"

#define REM16_statistics2_info_W        "B120"
#define REM16_stat_workstation_0        "JDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REM32_stat_workstation_0        "GDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REM16_statistics2_info_S        "B68"
#define REM16_stat_server_0             "JDDDDDDDDDDDDDDDD"
#define REM32_stat_server_0             "GDDDDDDDDDDDDDDDD"

#define REM16_NetStatisticsGet_P        "rLeh"
#define REM16_NetStatisticsClear_P      ""

#define REM16_NetStatisticsGet2_P       "zDWDrLh"

#define REM16_NetRemoteTOD_P            "rL"

#define REM16_time_of_day_info          "JDBBBBWWBBWB"
#define REM32_time_of_day_info          "GDDDDDXDDDDD"

#define REM16_netbios_info_0            "B17"
#define REM16_netbios_info_1            "B17B9BBWWDWWW"

#define REM16_NetBiosEnum_P             "WrLeh"
#define REM16_NetBiosGetInfo_P          "zWrLh"

#define REM16_Spl_open_data             "zzlzzzzzz"
#define REM16_plain_data                "K"

#define REM16_NetSplQmAbort_P           "Di"
#define REM16_NetSplQmClose_P           "Di"
#define REM16_NetSplQmEndDoc_P          "Dhi"
#define REM16_NetSplQmOpen_P            "zTsWii"
#define REM16_NetSplQmStartDoc_P        "Dzi"
#define REM16_NetSplQmWrite_P           "DTsi"

#define REM16_configgetall_info         "B"
#define REM32_configgetall_info         REM16_configgetall_info
#define REM16_configget_info            "B"
#define REM32_configget_info            REM16_configget_info
#define REM16_configset_info_0          "zz"
#define REM32_configset_info_0          REM16_configset_info_0

#define REM16_NetConfigGetAll_P         "zzrLeh"
#define REM16_NetConfigGet_P            "zzzrLe"
#define REM16_NetConfigSet_P            "zzWWsTD"

#define REM16_NetBuildGetInfo_P         "DWrLh"
#define REM16_build_info_0              "WD"

#define REM16_NetGetDCName_P            "zrL"

#define REM16_dc_name                   "B18"
#ifndef UNICODE
#define REM32_dc_name                   REM16_dc_name
#else
#define REM32_dc_name                   "B36"
#endif

#define REM16_challenge_info_0          "B8"
#define REM16_account_delta_info_0      "K"
#define REM16_account_sync_info_0       "K"

#define REM16_NetAccountDeltas_P        "zb12g12b24WWrLehg24"
#define REM16_NetAccountSync_P          "zb12g12DWrLehig24"

#define REM16_NetLogonEnum_P            "WrLeh"

#define REM16_I_NetPathType_P           "ziD"
#define REM16_I_NetPathCanonicalize_P   "zrLziDD"
#define REM16_I_NetPathCompare_P        "zzDD"
#define REM16_I_NetNameValidate_P       "zWD"
#define REM16_I_NetNameCanonicalize_P   "zrLWD"
#define REM16_I_NetNameCompare_P        "zzWD"

#define REM16_LocalOnlyCall             ""
#define REM32_LocalOnlyCall             ""

//
// The following definitions exist for DOS LANMAN--Windows 3.0
// Normally, there is a const char far * servername
// as the first parameter, but this will be ignored (sort of)
//

#define REM16_DosPrintJobGetId_P        "WrL"
#define REM16_GetPrintId                "WB16B13B"
#define REM16_NetRemoteCopy_P           "zzzzWWrL"
#define REM16_copy_info                 "WB1"
#define REM16_NetRemoteMove_P           "zzzzWWrL"
#define REM16_move_info                 "WB1"
#define REM16_NetHandleGetInfo_P        "WWrLh"
#define REM16_NetHandleSetInfo_P        "WWsTP"
#define REM16_handle_info_1             "DW"
#define REM16_handle_info_2             "z"
#define REM16_WWkstaGetInfo_P           "WrLhOW"

// The following strings are defined for RIPL APIs

#define REM16_RplWksta_info_0           "z"
#define REM16_RplWksta_info_1           "zz"
#define REM16_RplWksta_info_2           "b13b16b15b15zN"
#define REM16_RplWksta_info_3           "b16b49"

#define REM16_RplWkstaEnum_P            "WzWrLehb4g4"
#define REM16_RplWkstaGetInfo_P         "zWrLh"
#define REM16_RplWkstaSetInfo_P         "zWsTPW"
#define REM16_RplWkstaAdd_P             "WsTW"
#define REM16_RplWkstaDel_P             "zW"

#define REM16_RplProfile_info_0         "z"
#define REM16_RplProfile_info_1         "zz"
#define REM16_RplProfile_info_2         "b16b47"
#define REM16_RplProfile_info_3         "b16b47b16"

#define REM16_RplProfileEnum_P          "WzWrLehb4g4"
#define REM16_RplProfileGetInfo_P       "zWrLh"
#define REM16_RplProfileSetInfo_P       "zWsTP"
#define REM16_RplProfileAdd_P           "WzsTW"
#define REM16_RplProfileDel_P           "zW"
#define REM16_RplProfileClone_P         "WzsTW"
#define REM16_RplBaseProfileEnum_P      "WrLehb4g4"


// LAN Manager 3.0 API strings go here

#define REM16_I_GuidGetAgent_P          "g6i"
#define REM16_I_GuidSetAgent_P          "b6D"


// update support

#define REM16_NetAccountUpdate_P        "b12g12WWrLh"
#define REM16_NetAccountConfirmUpd_P    "b12g12D"
#define REM16_update_info_0             "K"

//
// SamrOemChangePasswordUser2 api support
//
#define REM32_SamOEMChgPasswordUser2_P  "zsT"        // Parameters to the call
#define REMSmb_SamOEMChgPasswordUser2   "B516B16"    // data that is passed

//====================================================================
//
// SMB XACT message descriptors. These are the only descriptors that
// can be passed over the network, and must not have any internal-
// use-only characters as defined in RemTypes.h
//
//====================================================================

#define REMSmb_share_info_0              "B13"
#define REMSmb_share_info_1              "B13BWz"
#define REMSmb_share_info_2              "B13BWzWWWzB9B"

#define REMSmb_share_info_90             "B13BWz"
#define REMSmb_share_info_92             "zzz"
#define REMSmb_share_info_93             "zzz"

#define REMSmb_share_info_0_setinfo      "B13"
#define REMSmb_share_info_1_setinfo      "B13BWz"
#define REMSmb_share_info_2_setinfo      "B13BWzWWOB9B"

#define REMSmb_share_info_90_setinfo     "B13BWz"
#define REMSmb_share_info_91_setinfo     "B13BWzWWWOB9BB9BWzWWzWW"

#define REMSmb_NetShareEnum_P            "WrLeh"
#define REMSmb_NetShareGetInfo_P         "zWrLh"
#define REMSmb_NetShareSetInfo_P         "zWsTP"
#define REMSmb_NetShareAdd_P             "WsT"
#define REMSmb_NetShareDel_P             "zW"
#define REMSmb_NetShareCheck_P           "zh"

#define REMSmb_session_info_0            "z"
#define REMSmb_session_info_1            "zzWWWDDD"
#define REMSmb_session_info_2            "zzWWWDDDz"
#define REMSmb_session_info_10           "zzDD"

#define REMSmb_NetSessionEnum_P          "WrLeh"
#define REMSmb_NetSessionGetInfo_P       "zWrLh"
#define REMSmb_NetSessionDel_P           "zW"

#define REMSmb_connection_info_0         "W"
#define REMSmb_connection_info_1         "WWWWDzz"

#define REMSmb_NetConnectionEnum_P       "zWrLeh"

#define REMSmb_file_info_0               "W"
#define REMSmb_file_info_1               "WWWzz"
#define REMSmb_file_info_2               "D"
#define REMSmb_file_info_3               "DWWzz"

#define REMSmb_NetFileEnum_P             "zWrLeh"
#define REMSmb_NetFileEnum2_P            "zzWrLehb8g8"
#define REMSmb_NetFileGetInfo_P          "WWrLh"
#define REMSmb_NetFileGetInfo2_P         "DWrLh"
#define REMSmb_NetFileClose_P            "W"
#define REMSmb_NetFileClose2_P           "D"

#define REMSmb_server_info_0             "B16"
#define REMSmb_server_info_1             "B16BBDz"
#define REMSmb_server_info_2             "B16BBDzDDDWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWz"
#define REMSmb_server_info_3             "B16BBDzDDDWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWzDWz"

#define REMSmb_server_info_1_setinfo     "B16BBDz"
#define REMSmb_server_info_2_setinfo     "B16BBDzDDDWWzWWWWWWWB21BOWWWWWWWWWWWWWWWWWWWWWWz"

#define REMSmb_server_admin_command      "B"

#define REMSmb_server_diskenum_0         "B3"

#define REMSmb_authenticator_info_0      "B8D"

#define REMSmb_server_diskft_100         "B"
#define REMSmb_server_diskft_101         "BBWWWWDW"
#define REMSmb_server_diskft_102         "BBWWWWDN"
#define REMSmb_server_diskfterr_0        "DWWDDW"
#define REMSmb_ft_info_0                 "WWW"
#define REMSmb_ft_drivestats_0           "BBWDDDDDDD"
#define REMSmb_ft_error_info_1           "DWWDDWBBDD"

#define REMSmb_I_NetServerDiskEnum_P     "WrLeh"
#define REMSmb_I_NetServerDiskGetInfo_P  "WWrLh"
#define REMSmb_I_FTVerifyMirror_P        "Wz"
#define REMSmb_I_FTAbortVerify_P         "W"
#define REMSmb_I_FTGetInfo_P             "WrLh"
#define REMSmb_I_FTSetInfo_P             "WsTP"
#define REMSmb_I_FTLockDisk_P            "WWh"
#define REMSmb_I_FTFixError_P            "Dzhh2"
#define REMSmb_I_FTAbortFix_P            "D"
#define REMSmb_I_FTDiagnoseError_P       "Dhhhh"
#define REMSmb_I_FTGetDriveStats_P       "WWrLh"
#define REMSmb_I_FTErrorGetInfo_P        "DWrLh"

#define REMSmb_NetServerEnum_P           "WrLeh"
#define REMSmb_I_NetServerEnum_P         "WrLeh"
#define REMSmb_NetServerEnum2_P          "WrLehDz"
#define REMSmb_I_NetServerEnum2_P        "WrLehDz"
#define REMSmb_NetServerEnum3_P          "WrLehDzz"
#define REMSmb_NetServerGetInfo_P        "WrLh"
#define REMSmb_NetServerSetInfo_P        "WsTP"
#define REMSmb_NetServerDiskEnum_P       "WrLeh"
#define REMSmb_NetServerAdminCommand_P   "zhrLeh"
#define REMSmb_NetServerReqChalleng_P    "zb8g8"
#define REMSmb_NetServerAuthenticat_P    "zb8g8"
#define REMSmb_NetServerPasswordSet_P    "zb12g12b16"

#define REMSmb_NetAuditOpen_P            "h"
#define REMSmb_NetAuditClear_P           "zz"
#define REMSmb_NetAuditRead_P            "zb16g16DhDDrLeh"

#define REMSmb_AuditLogReturnBuf         "K"

#define REMSmb_NetErrorLogOpen_P         "h"
#define REMSmb_NetErrorLogClear_P        "zz"
#define REMSmb_NetErrorLogRead_P         "zb16g16DhDDrLeh"

#define REMSmb_ErrorLogReturnBuf         "K"

#define REMSmb_chardev_info_0            "B9"
#define REMSmb_chardev_info_1            "B10WB22D"
#define REMSmb_chardevQ_info_0           "B13"
#define REMSmb_chardevQ_info_1           "B14WzWW"

#define REMSmb_NetCharDevEnum_P          "WrLeh"
#define REMSmb_NetCharDevGetInfo_P       "zWrLh"
#define REMSmb_NetCharDevControl_P       "zW"
#define REMSmb_NetCharDevQEnum_P         "zWrLeh"
#define REMSmb_NetCharDevQGetInfo_P      "zzWrLh"
#define REMSmb_NetCharDevQSetInfo_P      "zWsTP"
#define REMSmb_NetCharDevQPurge_P        "z"
#define REMSmb_NetCharDevQPurgeSelf_P    "zz"

#define REMSmb_msg_info_0                "B16"
#define REMSmb_msg_info_1                "B16BBB16"
#define REMSmb_send_struct               "K"

#define REMSmb_NetMessageNameEnum_P      "WrLeh"
#define REMSmb_NetMessageNameGetInfo_P   "zWrLh"
#define REMSmb_NetMessageNameAdd_P       "zW"
#define REMSmb_NetMessageNameDel_P       "zW"
#define REMSmb_NetMessageNameFwd_P       "zzW"
#define REMSmb_NetMessageNameUnFwd_P     "z"
#define REMSmb_NetMessageBufferSend_P    "zsT"
#define REMSmb_NetMessageFileSend_P      "zz"
#define REMSmb_NetMessageLogFileSet_P    "zW"
#define REMSmb_NetMessageLogFileGet_P    "rLh"

#define REMSmb_service_info_0            "B16"
#define REMSmb_service_info_1            "B16WDW"
#define REMSmb_service_info_2            "B16WDWB64"
#define REMSmb_service_cmd_args          "K"

#define REMSmb_NetServiceEnum_P          "WrLeh"
#define REMSmb_NetServiceControl_P       "zWWrL"
#define REMSmb_NetServiceInstall_P       "zF88sg88T"     // See NOTE 2
#define REMSmb_NetServiceGetInfo_P       "zWrLh"

#define REMSmb_access_info_0             "z"
#define REMSmb_access_info_0_setinfo     "z"
#define REMSmb_access_info_1             "zWN"
#define REMSmb_access_info_1_setinfo     "OWN"
#define REMSmb_access_list               "B21BW"

#define REMSmb_NetAccessEnum_P           "zWWrLeh"
#define REMSmb_NetAccessGetInfo_P        "zWrLh"
#define REMSmb_NetAccessSetInfo_P        "zWsTP"
#define REMSmb_NetAccessAdd_P            "WsT"
#define REMSmb_NetAccessDel_P            "z"
#define REMSmb_NetAccessGetUserPerms_P   "zzh"

#define REMSmb_group_info_0              "B21"
#define REMSmb_group_info_1              "B21Bz"
#define REMSmb_group_users_info_0        "B21"
#define REMSmb_group_users_info_1        "B21BN"

#define REMSmb_NetGroupEnum_P            "WrLeh"
#define REMSmb_NetGroupAdd_P             "WsT"
#define REMSmb_NetGroupDel_P             "z"
#define REMSmb_NetGroupAddUser_P         "zz"
#define REMSmb_NetGroupDelUser_P         "zz"
#define REMSmb_NetGroupGetUsers_P        "zWrLeh"
#define REMSmb_NetGroupSetUsers_P        "zWsTW"
#define REMSmb_NetGroupGetInfo_P         "zWrLh"
#define REMSmb_NetGroupSetInfo_P         "zWsTP"

#define REMSmb_user_info_0               "B21"
#define REMSmb_user_info_1               "B21BB16DWzzWz"
#define REMSmb_user_info_2               "B21BB16DWzzWzDzzzzDDDDWb21WWzWW"
#define REMSmb_user_info_10              "B21Bzzz"
#define REMSmb_user_info_11              "B21BzzzWDDzzDDWWzWzDWb21W"

#define REMSmb_user_info_100             "DWW"
#define REMSmb_user_info_101             "B60"
#define REMSmb_user_modals_info_0        "WDDDWW"
#define REMSmb_user_modals_info_1        "Wz"
#define REMSmb_user_modals_info_100      "B50"
#define REMSmb_user_modals_info_101      "zDDzDD"
#define REMSmb_user_logon_info_0         "B21B"
#define REMSmb_user_logon_info_1         "WB21BWDWWDDDDDDDzzzD"
#define REMSmb_user_logon_info_2         "B21BzzzD"
#define REMSmb_user_logoff_info_1        "WDW"

#define REMSmb_NetUserEnum_P             "WrLeh"
#define REMSmb_NetUserAdd_P              "WsTW"
#define REMSmb_NetUserAdd2_P             "WsTWW"
#define REMSmb_NetUserDel_P              "z"
#define REMSmb_NetUserGetInfo_P          "zWrLh"
#define REMSmb_NetUserSetInfo_P          "zWsTPW"
#define REMSmb_NetUserSetInfo2_P         "zWsTPWW"
#define REMSmb_NetUserPasswordSet_P      "zb16b16W"
#define REMSmb_NetUserPasswordSet2_P     "zb16b16WW"
#define REMSmb_NetUserGetGroups_P        "zWrLeh"
#define REMSmb_NetUserSetGroups_P        "zWsTW"
#define REMSmb_NetUserModalsGet_P        "WrLh"
#define REMSmb_NetUserModalsSet_P        "WsTP"
#define REMSmb_NetUserEnum2_P            "WrLDieh"
#define REMSmb_NetUserValidate2_P        "Wb62WWrLhWW"

#define REMSmb_wksta_info_0              "WDzzzzBBDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REMSmb_wksta_info_0_setinfo      "WDOOOOBBDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REMSmb_wksta_info_1              "WDzzzzBBDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REMSmb_wksta_info_1_setinfo      "WDOOOOBBDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REMSmb_wksta_info_10             "zzzBBzz"
#define REMSmb_wksta_annc_info           "K"

#define REMSmb_NetWkstaLogon_P           "zzirL"
#define REMSmb_NetWkstaLogoff_P          "zD"
#define REMSmb_NetWkstaSetUID_P          "zzzW"
#define REMSmb_NetWkstaGetInfo_P         "WrLh"
#define REMSmb_NetWkstaSetInfo_P         "WsTP"
#define REMSmb_NetWkstaUserLogon_P       "zzWb54WrLh"
#define REMSmb_NetWkstaUserLogoff_P      "zzWb38WrLh"

#define REMSmb_use_info_0                "B9Bz"
#define REMSmb_use_info_1                "B9BzzWWWW"

#define REMSmb_use_info_2                "B9BzzWWWWWWWzB16"

#define REMSmb_NetUseEnum_P              "WrLeh"
#define REMSmb_NetUseAdd_P               "WsT"
#define REMSmb_NetUseDel_P               "zW"
#define REMSmb_NetUseGetInfo_P           "zWrLh"

#define REMSmb_printQ_0                  "B13"
#define REMSmb_printQ_1                  "B13BWWWzzzzzWW"
#define REMSmb_printQ_2                  "B13BWWWzzzzzWN"
#define REMSmb_printQ_3                  "zWWWWzzzzWWzzl"
#define REMSmb_printQ_4                  "zWWWWzzzzWNzzl"
#define REMSmb_printQ_5                  "z"

#define REMSmb_DosPrintQEnum_P           "WrLeh"
#define REMSmb_DosPrintQGetInfo_P        "zWrLh"
#define REMSmb_DosPrintQSetInfo_P        "zWsTP"
#define REMSmb_DosPrintQAdd_P            "WsT"
#define REMSmb_DosPrintQDel_P            "z"
#define REMSmb_DosPrintQPause_P          "z"
#define REMSmb_DosPrintQPurge_P          "z"
#define REMSmb_DosPrintQContinue_P       "z"

#define REMSmb_print_job_0               "W"
#define REMSmb_print_job_1               "WB21BB16B10zWWzDDz"
#define REMSmb_print_job_2               "WWzWWDDzz"
#define REMSmb_print_job_3               "WWzWWDDzzzzzzzzzzlz"

#define REMSmb_print_job_info_1_setinfo  "WB21BB16B10zWWODDz"
#define REMSmb_print_job_info_3_setinfo  "WWzWWDDzzzzzOzzzzlO"

#define REMSmb_DosPrintJobEnum_P         "zWrLeh"
#define REMSmb_DosPrintJobGetInfo_P      "WWrLh"
#define REMSmb_DosPrintJobSetInfo_P      "WWsTP"
#define REMSmb_DosPrintJobAdd_P          "zsTF129g129h"  // See note 2
#define REMSmb_DosPrintJobSchedule_P     "W"
#define REMSmb_DosPrintJobDel_P          "W"
#define REMSmb_DosPrintJobPause_P        "W"
#define REMSmb_DosPrintJobContinue_P     "W"

#define REMSmb_print_dest_0              "B9"
#define REMSmb_print_dest_1              "B9B21WWzW"
#define REMSmb_print_dest_2              "z"
#define REMSmb_print_dest_3              "zzzWWzzzWW"
#define REMSmb_print_dest_info_3_setinfo "zOzWWOzzWW"

#define REMSmb_DosPrintDestEnum_P        "WrLeh"
#define REMSmb_DosPrintDestGetInfo_P     "zWrLh"
#define REMSmb_DosPrintDestControl_P     "zW"
#define REMSmb_DosPrintDestAdd_P         "WsT"
#define REMSmb_DosPrintDestSetInfo_P     "zWsTP"
#define REMSmb_DosPrintDestDel_P         "z"

#define REMSmb_NetProfileSave_P          "zDW"
#define REMSmb_NetProfileLoad_P          "zDrLD"

#define REMSmb_profile_load_info         "WDzD"

#define REMSmb_statistics_info           "B"

#define REMSmb_statistics2_info_W        "B120"
#define REMSmb_stat_workstation_0        "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REMSmb_statistics2_info_S        "B68"
#define REMSmb_stat_server_0             "DDDDDDDDDDDDDDDDD"

#define REMSmb_NetStatisticsGet_P        "rLeh"
#define REMSmb_NetStatisticsClear_P      ""

#define REMSmb_NetStatisticsGet2_P       "zDWDrLh"

#define REMSmb_NetRemoteTOD_P            "rL"

#define REMSmb_time_of_day_info          "DDBBBBWWBBWB"

#define REMSmb_netbios_info_0            "B17"
#define REMSmb_netbios_info_1            "B17B9BBWWDWWW"

#define REMSmb_NetBiosEnum_P             "WrLeh"
#define REMSmb_NetBiosGetInfo_P          "zWrLh"

#define REMSmb_Spl_open_data             "zzlzzzzzz"
#define REMSmb_plain_data                "K"

#define REMSmb_NetSplQmAbort_P           "Di"
#define REMSmb_NetSplQmClose_P           "Di"
#define REMSmb_NetSplQmEndDoc_P          "Dhi"
#define REMSmb_NetSplQmOpen_P            "zTsWii"
#define REMSmb_NetSplQmStartDoc_P        "Dzi"
#define REMSmb_NetSplQmWrite_P           "DTsi"

#define REMSmb_configgetall_info         "B"
#define REMSmb_configget_info            "B"
#define REMSmb_configset_info_0          "zz"

#define REMSmb_NetConfigGetAll_P         "zzrLeh"
#define REMSmb_NetConfigGet_P            "zzzrLe"
#define REMSmb_NetConfigSet_P            "zzWWsTD"

#define REMSmb_NetBuildGetInfo_P         "DWrLh"
#define REMSmb_build_info_0              "WD"

#define REMSmb_NetGetDCName_P            "zrL"
#define REMSmb_dc_name                   "B18"

#define REMSmb_challenge_info_0          "B8"
#define REMSmb_account_delta_info_0      "K"
#define REMSmb_account_sync_info_0       "K"

#define REMSmb_NetAccountDeltas_P        "zb12g12b24WWrLehg24"
#define REMSmb_NetAccountSync_P          "zb12g12DWrLehig24"

#define REMSmb_NetLogonEnum_P            "WrLeh"

#define REMSmb_I_NetPathType_P           "ziD"
#define REMSmb_I_NetPathCanonicalize_P   "zrLziDD"
#define REMSmb_I_NetPathCompare_P        "zzDD"
#define REMSmb_I_NetNameValidate_P       "zWD"
#define REMSmb_I_NetNameCanonicalize_P   "zrLWD"
#define REMSmb_I_NetNameCompare_P        "zzWD"

#define REMSmb_LocalOnlyCall             ""

//
// The following definitions exist for DOS LANMAN--Windows 3.0
// Normally, there is a const char far * servername
// as the first parameter, but this will be ignored (sort of)
//

#define REMSmb_DosPrintJobGetId_P        "WrL"
#define REMSmb_GetPrintId                "WB16B13B"
#define REMSmb_NetRemoteCopy_P           "zzzzWWrL"
#define REMSmb_copy_info                 "WB1"
#define REMSmb_NetRemoteMove_P           "zzzzWWrL"
#define REMSmb_move_info                 "WB1"
#define REMSmb_NetHandleGetInfo_P        "WWrLh"
#define REMSmb_NetHandleSetInfo_P        "WWsTP"
#define REMSmb_handle_info_1             "DW"
#define REMSmb_handle_info_2             "z"
#define REMSmb_WWkstaGetInfo_P           "WrLhOW"

// The following strings are defined for RIPL APIs

#define REMSmb_RplWksta_info_0           "z"
#define REMSmb_RplWksta_info_1           "zz"
#define REMSmb_RplWksta_info_2           "b13b16b15b15zN"
#define REMSmb_RplWksta_info_3           "b16b49"

#define REMSmb_RplWkstaEnum_P            "WzWrLehb4g4"
#define REMSmb_RplWkstaGetInfo_P         "zWrLh"
#define REMSmb_RplWkstaSetInfo_P         "zWsTPW"
#define REMSmb_RplWkstaAdd_P             "WsTW"
#define REMSmb_RplWkstaDel_P             "zW"

#define REMSmb_RplProfile_info_0         "z"
#define REMSmb_RplProfile_info_1         "zz"
#define REMSmb_RplProfile_info_2         "b16b47"
#define REMSmb_RplProfile_info_3         "b16b47b16"

#define REMSmb_RplProfileEnum_P          "WzWrLehb4g4"
#define REMSmb_RplProfileGetInfo_P       "zWrLh"
#define REMSmb_RplProfileSetInfo_P       "zWsTP"
#define REMSmb_RplProfileAdd_P           "WzsTW"
#define REMSmb_RplProfileDel_P           "zW"
#define REMSmb_RplProfileClone_P         "WzsTW"
#define REMSmb_RplBaseProfileEnum_P      "WrLehb4g4"


// LAN Manager 3.0 API strings go here

#define REMSmb_I_GuidGetAgent_P          "g6i"
#define REMSmb_I_GuidSetAgent_P          "b6D"


// update support

#define REMSmb_NetAccountUpdate_P        "b12g12WWrLh"
#define REMSmb_NetAccountConfirmUpd_P    "b12g12D"
#define REMSmb_update_info_0             "K"

#endif // ndef _REMDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rmcommon.h ===
/*	
**	RmCommon.h - Driver/Winsock common for PGM Reliable Transport
**
**	This file contains PGM specific information for use by WinSock2 compatible
**  applications that need Reliable Multicast Transport.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**	Created: Mar 12, 2000
**
*/

#ifndef _RMCOMMON_H_
#define _RMCOMMON_H_

#include "wsrm.h"

#define SOCK_PGM    SOCK_RDM

typedef ULONG   tIPADDRESS;

#define PGM_COMMON_SERVICE_FLAGS    XP1_GUARANTEED_ORDER           \
                                  | XP1_GUARANTEED_DELIVERY        \
                                  | XP1_SUPPORT_MULTIPOINT         \
                                  | XP1_GRACEFUL_CLOSE              \
                                  | XP1_IFS_HANDLES


#define PGM_RDM_SERVICE_FLAGS       PGM_COMMON_SERVICE_FLAGS | XP1_MESSAGE_ORIENTED
#define PGM_STREAM_SERVICE_FLAGS    PGM_COMMON_SERVICE_FLAGS | XP1_PSEUDO_STREAM


//
// Argument structure for passing requests from WHSPgm.dll to Pgm.dll
//
//
// Ioctl Definitions:
//

//
// Structure for passing MCast info to Ip
//
typedef struct {
    tIPADDRESS  MCastIpAddr;    // struct in_addr imr_multiaddr -- IP multicast address of group
    tIPADDRESS  MCastInIf;     // struct in_addr imr_interface -- local IP address of incoming interface
} tMCAST_INFO;

//
// Structure to be used for passing down Ioctl info:
//
typedef struct {
    union
    {
        struct
        {
            tMCAST_INFO     MCastInfo;
            USHORT          MCastPort;
        };
        RM_SENDER_STATS     SenderStats;
        RM_RECEIVER_STATS   ReceiverStats;
        ULONG               RcvBufferLength;            // To set the RcvBufferLength in Pgm
        tIPADDRESS          MCastOutIf;                 // local IP address of outgoing interface
        RM_SEND_WINDOW      TransmitWindowInfo;
        ULONG               WindowAdvancePercentage;    // Sender's transmit window advance rate
        ULONG               LateJoinerPercentage;       // Sender's transmit window advance rate
        ULONG               NextMessageBoundary;
        ULONG               MCastTtl;
        ULONG               WindowAdvanceMethod;
        RM_FEC_INFO         FECInfo;
    };
} tPGM_MCAST_REQUEST;

#define FSCTL_PGM_BASE     FILE_DEVICE_NETWORK

#define _PGM_CTRL_CODE(function, method, access) \
            CTL_CODE(FSCTL_PGM_BASE, function, method, access)

// Ioctls:
#define IOCTL_PGM_WSH_SET_SEND_IF           \
            _PGM_CTRL_CODE( 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_ADD_RECEIVE_IF        \
            _PGM_CTRL_CODE( 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_DEL_RECEIVE_IF        \
            _PGM_CTRL_CODE( 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_JOIN_MCAST_LEAF       \
            _PGM_CTRL_CODE( 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_RCV_BUFF_LEN      \
            _PGM_CTRL_CODE( 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_WINDOW_SIZE_RATE      \
            _PGM_CTRL_CODE( 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_WINDOW_SIZE_RATE      \
            _PGM_CTRL_CODE( 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_ADVANCE_WINDOW_RATE      \
            _PGM_CTRL_CODE( 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_ADVANCE_WINDOW_RATE      \
            _PGM_CTRL_CODE( 8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_LATE_JOINER_PERCENTAGE      \
            _PGM_CTRL_CODE( 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_LATE_JOINER_PERCENTAGE      \
            _PGM_CTRL_CODE( 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_NEXT_MESSAGE_BOUNDARY      \
            _PGM_CTRL_CODE( 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_SENDER_STATS    \
            _PGM_CTRL_CODE( 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_USE_FEC               \
            _PGM_CTRL_CODE( 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_MCAST_TTL      \
            _PGM_CTRL_CODE( 14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_FEC_INFO      \
            _PGM_CTRL_CODE( 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_RECEIVER_STATS      \
            _PGM_CTRL_CODE( 16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_WINDOW_ADVANCE_METHOD      \
            _PGM_CTRL_CODE( 17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_WINDOW_ADVANCE_METHOD      \
            _PGM_CTRL_CODE( 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  /* _RMCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rxp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RxP.h

Abstract:

    This is the private header file for the NT version of RpcXlate.

Author:

    John Rogers (JohnRo) 25-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    25-Mar-1991 JohnRo
        Created.
    03-May-1991 JohnRo
        RxpStartBuildingTransaction's data descriptor is SMB version (no Q's
        or U's).  RxpConvertBlock needs 2 versions of data descriptor.
        RcvDataPtrPtr and RcvDataPresent are redundant for RxpConvertArguments
        and RxpConvertBlock.  RxpTransactSmb now gets UNC server name.
        Fixed receive buffer size problem.  Use LPTSTR.
        Added stuff to allow runtime debug on/off changes.
        Clarify that RxpStartBuildingTransaction uses buffer as OUT.
        Reduced recompile hits from header files.
    06-May-1991 JohnRo
        Added RxpComputeRequestBufferSize().
    13-May-1991 JohnRo
        Added print Q and print job APIs support.
    14-May-1991 JohnRo
        Pass 2 aux descriptors to RxpConvertBlock.  Clarify other types of
        aux descriptors.
    18-May-1991 JohnRo
        Handle array of aux structs.
    19-May-1991 JohnRo
        Added DBGSTATIC definition.  Pass ResourceName to RxpSetField().
        Fixed RxpAddAscii().
    20-May-1991 JohnRo
        Make data descriptors OPTIONAL for RxpConvertBlock.
    29-May-1991 JohnRo
        RxpConvertArgs must return SendDataPtr16 and SendDataSize16.
    05-Jun-1991 JohnRo
        Added setfield debug output.
    11-Jun-1991 rfirth
        Added SmbRcvByteLen parameter to RxpConvertBlock
        Changed RetDataSize parameter to RxpTransactSmb to IN OUT LPDWORD
    12-Jun-1991 JohnRo
        Moved DBGSTATIC to <NetDebug.h>.
    13-Jun-1991 JohnRo
        RxpPackSendBuffer and RxpConvertArgs both need DataDesc16.
    15-Jul-1991 JohnRo
        Added FieldIndex parameter to RxpSetField.
        Changed RxpConvertDataStructures to allow ERROR_MORE_DATA, e.g. for
        print APIs.  Added debug flag for the same routine.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    19-Aug-1991 rfirth
        Added Flags parameter to RxpConvert{Args|Block}
    04-Oct-1991 JohnRo
        Handle ERROR_BAD_NET_NAME (e.g. IPC$ not shared) to fix NetShareEnum.
        More work toward UNICODE.  (Added RxpAddTStr().)
    07-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.
    24-Oct-1991 JohnRo
        Added RxpCopyStrArrayToTStrArray for remote config and disk enum.
    29-Oct-1991 JohnRo
        RxpFatalErrorCode() should be paranoid.
    13-Nov-1991 JohnRo
        OK, RxpFatalErrorCode() was too paranoid.  It should allow
        ERROR_MORE_DATA or all the enum APIs break.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.
    26-Jun-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.
    04-May-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.
        Made changes suggested by PC-LINT 5.0
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.

--*/

#ifndef _RXP_
#define _RXP_

// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <rap.h>                // LPDESC, RapStructureSize(), etc.
// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,rxp.h,smbgtpt.h,stdarg.h,tstr.h,tstring.h) */
/*lint -efile(766,rxp.h,smbgtpt.h,stdarg.h,tstr.h,tstring.h) */
#include <smbgtpt.h>            // SmbPutUshort() (needed by macros below).
#include <stdarg.h>             // va_list, etc.
#include <tstring.h>            // NetpCopyTStrToStr().


// Maximum sizes (in bytes) supported by the transact SMB.
#define MAX_TRANSACT_RET_DATA_SIZE      ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_RET_PARM_SIZE      ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_SEND_DATA_SIZE     ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_SEND_PARM_SIZE     ((DWORD) 0x0000FFFF)


// Note: IF_DEBUG() and so on are now in Net/Inc/RxpDebug.h.

DWORD
RxpComputeRequestBufferSize(
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    IN DWORD DataSize
    );

NET_API_STATUS
RxpConvertArgs(
    IN LPDESC ParmDescriptorString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD MaximumInputBlockSize,
    IN DWORD MaximumOutputBlockSize,
    IN OUT LPDWORD CurrentInputBlockSizePtr,
    IN OUT LPDWORD CurrentOutputBlockSizePtr,
    IN OUT LPBYTE * CurrentOutputBlockPtrPtr,
    IN va_list * FirstArgumentPtr,      // rest of API's arguments (after
                                        // server name)
    OUT LPDWORD SendDataSizePtr16,
    OUT LPBYTE * SendDataPtrPtr16,
    OUT LPDWORD RcvDataSizePtr,
    OUT LPBYTE * RcvDataPtrPtr,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxpConvertBlock(
    IN  DWORD   ApiNumber,
    IN  LPBYTE  ResponseBlockPtr,
    IN  LPDESC  ParmDescriptorString,
    IN  LPDESC  DataDescriptor16 OPTIONAL,
    IN  LPDESC  DataDescriptor32 OPTIONAL,
    IN  LPDESC  AuxDesc16 OPTIONAL,
    IN  LPDESC  AuxDesc32 OPTIONAL,
    IN  va_list* FirstArgumentPtr,      // rest of API's arguments
    IN  LPBYTE  SmbRcvBuffer OPTIONAL,
    IN  DWORD   SmbRcvByteLen,
    OUT LPBYTE  RcvDataPtr OPTIONAL,
    IN  DWORD   RcvDataSize,
    IN  DWORD   Flags
    );

// DWORD
// RxpEstimateBytesNeeded(
//     IN DWORD BytesNeeded16
//     );
//
// Worst case: BOOL or CHAR might be padded to DWORD.
#define RxpEstimateBytesNeeded(Size16) \
    ( (Size16) * 4 )

//
// Estimate bytes needed for an audit log or error log array.
//
NET_API_STATUS
RxpEstimateLogSize(
    IN DWORD DownlevelFixedEntrySize,
    IN DWORD InputArraySize,
    IN BOOL DoingErrorLog,    // TRUE for error log, FALSE for audit log
    OUT LPDWORD OutputArraySize
    );

// BOOL
// RxpFatalErrorCode(
//     IN NET_API_STATUS Status
//     );
//
#define RxpFatalErrorCode( Status )             \
    ( ( ((Status) != NERR_Success)              \
     && ((Status) != ERROR_MORE_DATA) )         \
    ? TRUE : FALSE )

NET_API_STATUS
RxpPackSendBuffer(
    IN OUT LPVOID * SendBufferPtrPtr,
    IN OUT LPDWORD SendBufferSizePtr,
    OUT LPBOOL AllocFlagPtr,
    IN LPDESC DataDesc16,
    IN LPDESC AuxDesc16,
    IN DWORD FixedSize16,
    IN DWORD AuxOffset,
    IN DWORD AuxSize,
    IN BOOL SetInfo
    );

NET_API_STATUS
RxpReceiveBufferConvert(
    IN OUT LPVOID RcvDataPtr,
    IN DWORD      RcvDataSize,
    IN DWORD      Converter,
    IN DWORD      NumberOfStructures,
    IN LPDESC     DataDescriptorString,
    IN LPDESC     AuxDescriptorString,
    OUT LPDWORD   NumAuxStructs
    );

NET_API_STATUS
RxpSetField (
    IN DWORD ApiNumber,
    IN LPTSTR UncServerName,
    IN LPDESC ObjectDesc OPTIONAL,
    IN LPVOID ObjectToSet OPTIONAL,
    IN LPDESC ParmDesc,
    IN LPDESC DataDesc16,
    IN LPDESC DataDesc32,
    IN LPDESC DataDescSmb,
    IN LPVOID NativeInfoBuffer,
    IN DWORD ParmNumToSend,
    IN DWORD FieldIndex,
    IN DWORD Level
    );

NET_API_STATUS
RxpStartBuildingTransaction(
    OUT LPVOID Buffer,
    IN DWORD BufferSize,
    IN DWORD ApiNumber,
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    OUT LPVOID * RovingOutputPtr,
    OUT LPDWORD SizeSoFarPtr,
    OUT LPVOID * LastStringPtr OPTIONAL,
    OUT LPDESC * ParmDescCopyPtr OPTIONAL
    );

NET_API_STATUS
RxpTransactSmb(
    IN LPTSTR UncServerName,
    IN LPTSTR TransportName,
    IN LPVOID SendParmPtr,
    IN DWORD SendParmSize,
    IN LPVOID SendDataPtr OPTIONAL,
    IN DWORD SendDataSize,
    OUT LPVOID RetParmPtr OPTIONAL,
    IN DWORD RetParmSize,
    OUT LPVOID RetDataPtr OPTIONAL,
    IN OUT LPDWORD RetDataSize,
    IN BOOL NoPermissionRequired
    );

NET_API_STATUS
RxpConvertDataStructures(
    IN  LPDESC  InputDescriptor,
    IN  LPDESC  OutputDescriptor,
    IN  LPDESC  InputAuxDescriptor OPTIONAL,
    IN  LPDESC  OutputAuxDescriptor OPTIONAL,
    IN  LPBYTE  InputBuffer,
    OUT LPBYTE  OutputBuffer,
    IN  DWORD   OutputBufferSize,
    IN  DWORD   PrimaryCount,
    OUT LPDWORD EntriesConverted OPTIONAL,
    IN  RAP_TRANSMISSION_MODE TransmissionMode,
    IN  RAP_CONVERSION_MODE ConversionMode
    );



// VOID
// RxpAddPointer(
//     IN LPVOID Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#if defined(_WIN64)

#define RxpAddPointer(Input,CurPtrPtr,CurSizePtr)                       \
            {                                                           \
                *((PVOID UNALIGNED *)(*(CurPtrPtr))) = (Input);         \
                *(CurPtrPtr) += sizeof(LPBYTE);                         \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(LPBYTE);       \
            }

#else

#define RxpAddPointer(Input,CurPtrPtr,CurSizePtr)                       \
            {                                                           \
                SmbPutUlong( (LPDWORD) *(CurPtrPtr), (DWORD) (Input));  \
                *(CurPtrPtr) += sizeof(LPBYTE);                         \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(LPBYTE);       \
            }

#endif


// RxpAddVariableSize: Add a variable length item to string space at end of
// buffer.  Store pointer to it in buffer; update current buffer pointer and
// Size; update string space pointer.
//
// VOID
// RxpAddVariableSize(
//     IN LPBYTE Input,
//     IN DWORD InputSize,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddVariableSize(Input,InputSize,CurPtrPtr,StrPtrPtr,CurSizePtr) \
            {                                                            \
                *(StrPtrPtr) -= (InputSize);                             \
                RxpAddPointer( *(StrPtrPtr), (CurPtrPtr), (CurSizePtr)); \
                NetpMoveMemory( *((StrPtrPtr)), (Input), (InputSize));   \
            }

// RxpAddAscii: Add an ASCII string to string space at end of buffer;
// store pointer to it in buffer; update current buffer pointer and Size;
// update string space pointer.
//
// VOID
// RxpAddAscii(
//     IN LPTSTR Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddAscii(Input,CurPtrPtr,StrPtrPtr,CurSizePtr)               \
            {                                                           \
                DWORD len = strlen((Input))+1;                          \
                RxpAddVariableSize(                                     \
                    (Input), len,                                       \
                    (CurPtrPtr), (StrPtrPtr), (CurSizePtr));            \
            }

// RxpAddTStr: Add a LPTSTR string to string space at end of buffer;
// store pointer to it in buffer; update current buffer pointer and Size;
// update string space pointer.
//
// VOID
// RxpAddTStr(
//     IN LPTSTR Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddTStr(Input,CurPtrPtr,StrPtrPtr,CurSizePtr)                 \
            {                                                            \
                DWORD size = STRLEN((Input))+1;                          \
                *(StrPtrPtr) -= size;                                    \
                RxpAddPointer( *(StrPtrPtr), (CurPtrPtr), (CurSizePtr)); \
                NetpCopyWStrToStrDBCS( *((StrPtrPtr)), (Input) );        \
            }

// VOID
// RxpAddWord(
//     IN WORD Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddWord(Input,CurPtrPtr,CurSizePtr)                          \
            {                                                           \
                SmbPutUshort( (LPWORD) (*(CurPtrPtr)), (WORD) (Input)); \
                *(CurPtrPtr) += sizeof(WORD);                           \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(WORD);         \
            }

//
// MAKE_PARMNUM_PAIR() - packs a parmnum and a field index into a DWORD. We
// have to do this because there are (many) cases where we cannot assume
// correspondence between a parmnum and a field index
//

#define MAKE_PARMNUM_PAIR(parmnum, field_index) ((DWORD)((((DWORD)(field_index)) << 16) | (DWORD)(parmnum)))

//
// FIELD_INDEX_FROM_PARMNUM_PAIR() - retrieve the field index from the pair
// conjoined by MAKE_PARMNUM_PAIR()
//

#define FIELD_INDEX_FROM_PARMNUM_PAIR(pair) ((DWORD)((pair) >> 16))

//
// PARMNUM_FROM_PARMNUM_PAIR() - retrieve the parmnum from the pair conjoined
// by MAKE_PARMNUM_PAIR()
//

#define PARMNUM_FROM_PARMNUM_PAIR(pair) ((DWORD)((pair) & 0x0000ffff))

#endif // ndef _RXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rpcutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcutil.h

Abstract:

    This file contains prototypes for the bind and unbind functions that
    all net api stub functions will call.  It also includes the allocate
    and free routines used by the MIDL generated RPC stubs.

    Other function prototypes defined here are RPC helper routines to
    start and stop the RPC server, and the RPC status to Net API status
    mapping function.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    23-Oct-1991 Danl
        Added NetpInitRpcServer().

    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)

    20-Jul-1992 JohnRo
        RAID 2252: repl should prevent export on Windows/NT.
        Reordered this change history.
    01-Dec-1992 JohnRo
        Fix MIDL_user_ func signatures.

--*/
#ifndef _RPCUTIL_
#define _RPCUTIL_

#include <lmcons.h>

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>        // __RPC_FAR, etc.

//
// DEFINES
//

//
// The following typedefs are created for use in the net api Enum entry point
// routines.  These structures are meant to mirror the level specific
// info containers that are specified in the .idl file for the Enum API
// function.  Using these structures to set up for the API call allows
// the entry point routine to avoid using any bulky level-specific logic
// to set-up or return from the RPC stub call.
//

typedef struct _GENERIC_INFO_CONTAINER {
    DWORD       EntriesRead;
    LPBYTE      Buffer;
} GENERIC_INFO_CONTAINER, *PGENERIC_INFO_CONTAINER, *LPGENERIC_INFO_CONTAINER ;

typedef struct _GENERIC_ENUM_STRUCT {
    DWORD                   Level;
    PGENERIC_INFO_CONTAINER Container;
} GENERIC_ENUM_STRUCT, *PGENERIC_ENUM_STRUCT, *LPGENERIC_ENUM_STRUCT ;


#define     NT_PIPE_PREFIX      TEXT("\\PIPE\\")

//
// Function Prototypes - routines called by MIDL-generated code:
//

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t NumBytes
    );

void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

//
// Function Prototypes - private network routines.
//

RPC_STATUS
NetpBindRpc(
    IN  LPTSTR              servername,
    IN  LPTSTR              servicename,
    IN  LPTSTR              networkoptions,
    OUT RPC_BINDING_HANDLE  * pBindingHandle
    );

//  We do not need any longer NetpRpcStatusToApiStatus() mapping
//  But for now, rather than eliminating a few references to it in
//  the net tree, we just stub it out.

//  NET_API_STATUS
//  NetpRpcStatusToApiStatus(
//      IN  RPC_STATUS RpcStatus
//      );

#define NetpRpcStatusToApiStatus(RpcStatus)  ((NET_API_STATUS)(RpcStatus))

RPC_STATUS
NetpUnbindRpc(
    IN  RPC_BINDING_HANDLE BindingHandle
    );



#endif // _RPCUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\sock_err.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

  sock_err.h

Abstract:

   This module contains error codes for sockets and STREAMS sources.

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version  (in posix\sys\errno.h)
  9-19-91    mikemas  extracted these codes from posix\sys\errno.h

Notes:

--*/
/*
 *      Copyright (c) 1984 AT&T
 *      Copyright (c) 1987 Fairchild Semiconductor Corporation
 *      Copyright 1987 Lachman Associates, Incorporated (LAI)
 *        All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T,
 *      FAIRCHILD SEMICONDUCTOR CORPORATION,
 *      (AND LACHMAN ASSOCIATES)
 *      AND SPIDER SYSTEMS.
 *
 *      stcp copyright above and this notice must be preserved in all
 *      copies of this source code.  The copyright above does not
 *      evidence any actual or intended publication of this source
 *      code
 */

#ifndef SOCK_ERR_INCLUDED
#define SOCK_ERR_INCLUDED


// in CRT #define ENOTBLK 54      /* Block device required                */
// in CRT #define ETXTBSY 55      /* Text file busy                       */
#define ENOMSG  56      /* No message of desired type           */
#define EIDRM   57      /* Identifier removed                   */
#define ECHRNG  58      /* Channel number out of range          */
#define EL2NSYNC 59     /* Level 2 not synchronized             */
#define EL3HLT  60      /* Level 3 halted                       */
#define EL3RST  61      /* Level 3 reset                        */
#define ELNRNG  62      /* Link number out of range             */
#define EUNATCH 63      /* Protocol driver not attached         */
#define ENOCSI  64      /* No CSI structure available           */
#define EL2HLT  65      /* Level 2 halted                       */

/* Convergent Error Returns */
#define EBADE   66      /* invalid exchange                     */
#define EBADR   67      /* invalid request descriptor           */
#define EXFULL  68      /* exchange full                        */
#define ENOANO  69      /* no anode                             */
#define EBADRQC 70      /* invalid request code                 */
#define EBADSLT 71      /* invalid slot                         */
// in CRT #define EDEADLOCK 72    /* file locking deadlock error          */

#define EBFONT  73      /* bad font file fmt                    */

/* stream problems */
#define ENOSTR  74      /* Device not a stream                  */
#define ENODATA 75      /* no data (for no delay io)            */
#define ETIME   76      /* timer expired                        */
#define ENOSR   77      /* out of streams resources             */

#define ENONET  78      /* Machine is not on the network        */
#define ENOPKG  79      /* Package not installed                */
#define EREMOTE 80      /* The object is remote                 */
#define ENOLINK 81      /* the link has been severed */
#define EADV    82      /* advertise error */
#define ESRMNT  83      /* srmount error */

#define ECOMM   84      /* Communication error on send          */
#define EPROTO  85      /* Protocol error                       */
#define EMULTIHOP 86    /* multihop attempted */
#define ELBIN   87      /* Inode is remote (not really error)*/
#define EDOTDOT 88      /* Cross mount point (not really error)*/
#define EBADMSG 89      /* trying to read unreadable message    */

#define ENOTUNIQ 90     /* given log. name not unique */
#define EREMCHG  91     /* Remote address changed */

/* shared library problems */
#define ELIBACC 92      /* Can't access a needed shared lib.    */
#define ELIBBAD 93      /* Accessing a corrupted shared lib.    */
#define ELIBSCN 94      /* .lib section in a.out corrupted.     */
#define ELIBMAX 95      /* Attempting to link in too many libs. */
#define ELIBEXEC        96      /* Attempting to exec a shared library. */


/*
 * Additional error codes for the socket library
 */

#define EWOULDBLOCK     EAGAIN          /* Operation would block */

#define ENOTSOCK        100             /* Socket operation on non-socket */
#define EADDRNOTAVAIL   101             /* Can't assign requested address */
#define EADDRINUSE      102             /* Address already in use */
#define EAFNOSUPPORT    103
                        /* Address family not supported by protocol family */
#define ESOCKTNOSUPPORT 104             /* Socket type not supported */
#define EPROTONOSUPPORT 105             /* Protocol not supported */
#define ENOBUFS         106             /* No buffer space available */
#define ETIMEDOUT       107             /* Connection timed out */
#define EISCONN         108             /* Socket is already connected */
#define ENOTCONN        109             /* Socket is not connected */
#define ENOPROTOOPT     110             /* Bad protocol option */
#define ECONNRESET      111             /* Connection reset by peer */
#define ECONNABORT      112             /* Software caused connection abort */
#define ENETDOWN        113             /* Network is down */
#define ECONNREFUSED    114             /* Connection refused */
#define EHOSTUNREACH    115             /* Host is unreachable */
#define EPROTOTYPE      116             /* Protocol wrong type for socket */
#define EOPNOTSUPP      117             /* Operation not supported on socket */

#define ETIMEOUT        ETIMEDOUT

/*
 * these originate from the Internet Module
 */
#define ESUBNET         118             /* IP subnet table full */
#define ENETNOLNK       119             /* Subnet module not linked */
#define EBADIOCTL       120             /* Unknown ioctl call */
#define ERESOURCE       121             /* Failure in Streams buffer allocn */

#define EPROTUNR        122             /* ICMP Protocol unreachable    */
#define EPORTUNR        123             /* ICMP Port unreachable        */
#define ENETUNR         124             /* ICMP Network unreachable     */

#define ENETUNREACH     ENETUNR         /* ICMP Network unreachable     */

/*
 * Ethernet Driver Errors
 */

#define EPACKET         150             /* Invalid Ethernet Packet */
#define ETYPEREG        151             /* Type registration error */

/*
 * Socket library call
 */

#define ENOTINIT        152             /* Sockets library not initialized */


#endif  //SOCK_ERR_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\rxuser.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxuser.h

Abstract:

    Prototypes for down-level remoted RxNetUser... routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created

--*/

NET_API_STATUS
RxNetUserAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetUserDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName
    );

NET_API_STATUS
RxNetUserEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetUserGetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    );

NET_API_STATUS
RxNetUserGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetUserModalsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetUserModalsSet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetUserPasswordSet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  LPTSTR  OldPassword,
    IN  LPTSTR  NewPassword
    );

NET_API_STATUS
RxNetUserSetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    IN  DWORD   Entries
    );

NET_API_STATUS
RxNetUserSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );


//NET_API_STATUS
//RxNetUserValidate2
//    /** CANNOT BE REMOTED **/
//{
//
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\uio.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    uio.h

Abstract:

    I/O structure definitions for compatibility with BSD.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  Spider BSD Compatibility
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  UIO.H
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/include/bsd/sys/0/s.uio.h
 *      @(#)uio.h       5.3
 *
 *      Last delta created      14:41:47 3/4/91
 *      This file extracted     11:24:29 3/8/91
 *
 *      Modifications:
 *
 *              GSS     19 Jun 90       New File
 */

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)uio.h       7.1 (Berkeley) 6/4/86
 */

#ifndef _UIO_
#define _UIO_

typedef long                   daddr_t;
typedef char FAR *             caddr_t;

struct iovec {
        caddr_t iov_base;
        int     iov_len;
};

struct uio {
        struct  iovec *uio_iov;
        int     uio_iovcnt;
        int     uio_offset;
        int     uio_segflg;
        int     uio_resid;
};

enum    uio_rw { UIO_READ, UIO_WRITE };

/*
 * Segment flag values (should be enum).
 */
#define UIO_USERSPACE   0               /* from user data space */
#define UIO_SYSSPACE    1               /* from system space */
#define UIO_USERISPACE  2               /* from user I space */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\winnetp.h ===
#ifndef _WINNETP_
#define _WINNETP_
#ifdef __cplusplus
extern "C" {
#endif
//
// DON'T use 0x00280000 since some people may be
// accidentally trying to use it for RDR2SAMPLE
//
//
// Do NOT add new WNNC_NET_ constants without co-ordinating with PSS
// (HeatherH/ToddC) and jschwart (NT bug #2396)
//
#if(WINVER >= 0x0500)
#define RESOURCE_SHAREABLE      0x00000006
#endif /* WINVER >= 0x0500 */

//
// Structures and infolevels for WNetGetConnection3
//

#define WNGC_INFOLEVEL_DISCONNECTED      1

typedef struct  _WNGC_CONNECTION_STATE {
    DWORD    dwState;
} WNGC_CONNECTION_STATE, *LPWNGC_CONNECTION_STATE;

// Values of the dwState field of WNGC_CONNECTION_STATE
// for info level WNGC_INFOLEVEL_DISCONNECTED
#define WNGC_CONNECTED      0x00000000
#define WNGC_DISCONNECTED   0x00000001


DWORD APIENTRY
WNetGetConnection3A(
     IN LPCSTR lpLocalName,
     IN LPCSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    );
DWORD APIENTRY
WNetGetConnection3W(
     IN LPCWSTR lpLocalName,
     IN LPCWSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    );
#ifdef UNICODE
#define WNetGetConnection3  WNetGetConnection3W
#else
#define WNetGetConnection3  WNetGetConnection3A
#endif // !UNICODE

DWORD APIENTRY
WNetRestoreConnectionA(
    IN HWND     hwndParent,
    IN LPCSTR lpDevice
    );
DWORD APIENTRY
WNetRestoreConnectionW(
    IN HWND     hwndParent,
    IN LPCWSTR lpDevice
    );
#ifdef UNICODE
#define WNetRestoreConnection  WNetRestoreConnectionW
#else
#define WNetRestoreConnection  WNetRestoreConnectionA
#endif // !UNICODE

// WNetRestoreConnection2 flags
#define WNRC_NOUI                           0x00000001

DWORD APIENTRY
WNetRestoreConnection2A(
    IN  HWND     hwndParent,
    IN  LPCSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    );
DWORD APIENTRY
WNetRestoreConnection2W(
    IN  HWND     hwndParent,
    IN  LPCWSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    );
#ifdef UNICODE
#define WNetRestoreConnection2  WNetRestoreConnection2W
#else
#define WNetRestoreConnection2  WNetRestoreConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetSetConnectionA(
    IN LPCSTR    lpName,
    IN DWORD       dwProperties,
    IN LPVOID      pvValues
    );
DWORD APIENTRY
WNetSetConnectionW(
    IN LPCWSTR    lpName,
    IN DWORD       dwProperties,
    IN LPVOID      pvValues
    );
#ifdef UNICODE
#define WNetSetConnection  WNetSetConnectionW
#else
#define WNetSetConnection  WNetSetConnectionA
#endif // !UNICODE
#if defined(_WIN32_WINDOWS)
DWORD APIENTRY
WNetLogonA(
    IN LPCSTR lpProvider,
    IN HWND hwndOwner
    );
DWORD APIENTRY
WNetLogonW(
    IN LPCWSTR lpProvider,
    IN HWND hwndOwner
    );
#ifdef UNICODE
#define WNetLogon  WNetLogonW
#else
#define WNetLogon  WNetLogonA
#endif // !UNICODE

DWORD APIENTRY
WNetLogoffA(
    IN LPCSTR lpProvider,
    IN HWND hwndOwner
    );
DWORD APIENTRY
WNetLogoffW(
    IN LPCWSTR lpProvider,
    IN HWND hwndOwner
    );
#ifdef UNICODE
#define WNetLogoff  WNetLogoffW
#else
#define WNetLogoff  WNetLogoffA
#endif // !UNICODE

DWORD APIENTRY
WNetVerifyPasswordA(
    IN LPCSTR  lpszPassword,
    OUT BOOL FAR *pfMatch
    );
DWORD APIENTRY
WNetVerifyPasswordW(
    IN LPCWSTR  lpszPassword,
    OUT BOOL FAR *pfMatch
    );
#ifdef UNICODE
#define WNetVerifyPassword  WNetVerifyPasswordW
#else
#define WNetVerifyPassword  WNetVerifyPasswordA
#endif // !UNICODE

#endif  // _WIN32_WINDOWS

DWORD APIENTRY
WNetGetHomeDirectoryA(
    IN LPCSTR  lpProviderName,
    OUT LPSTR   lpDirectory,
    IN OUT LPDWORD   lpBufferSize
    );
DWORD APIENTRY
WNetGetHomeDirectoryW(
    IN LPCWSTR  lpProviderName,
    OUT LPWSTR   lpDirectory,
    IN OUT LPDWORD   lpBufferSize
    );
#ifdef UNICODE
#define WNetGetHomeDirectory  WNetGetHomeDirectoryW
#else
#define WNetGetHomeDirectory  WNetGetHomeDirectoryA
#endif // !UNICODE
DWORD APIENTRY
WNetFormatNetworkNameA(
    IN LPCSTR  lpProvider,
    IN LPCSTR  lpRemoteName,
    OUT LPSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    );
DWORD APIENTRY
WNetFormatNetworkNameW(
    IN LPCWSTR  lpProvider,
    IN LPCWSTR  lpRemoteName,
    OUT LPWSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    );
#ifdef UNICODE
#define WNetFormatNetworkName  WNetFormatNetworkNameW
#else
#define WNetFormatNetworkName  WNetFormatNetworkNameA
#endif // !UNICODE

DWORD APIENTRY
WNetGetProviderTypeA(
    IN  LPCSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    );
DWORD APIENTRY
WNetGetProviderTypeW(
    IN  LPCWSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    );
#ifdef UNICODE
#define WNetGetProviderType  WNetGetProviderTypeW
#else
#define WNetGetProviderType  WNetGetProviderTypeA
#endif // !UNICODE
DWORD APIENTRY
WNetInitialize(
    void
    );


DWORD APIENTRY
MultinetGetErrorTextA(
    OUT LPSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    );
DWORD APIENTRY
MultinetGetErrorTextW(
    OUT LPWSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPWSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    );
#ifdef UNICODE
#define MultinetGetErrorText  MultinetGetErrorTextW
#else
#define MultinetGetErrorText  MultinetGetErrorTextA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif
#endif  // _WINNETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\tcpinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** TCPINFO.H - TDI Query/SetInfo and Action definitons.
//
//  This file contains definitions for information returned from TCP/UDP.
//

#pragma once
#ifndef TCP_INFO_INCLUDED
#define TCP_INFO_INCLUDED

#include "ipinfo.h"

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;
#endif // CTE_TYPEDEFS_DEFINED

typedef struct TCPStats {
    ulong       ts_rtoalgorithm;
    ulong       ts_rtomin;
    ulong       ts_rtomax;
    ulong       ts_maxconn;
    ulong       ts_activeopens;
    ulong       ts_passiveopens;
    ulong       ts_attemptfails;
    ulong       ts_estabresets;
    ulong       ts_currestab;
    ulong       ts_insegs;
    ulong       ts_outsegs;
    ulong       ts_retranssegs;
    ulong       ts_inerrs;
    ulong       ts_outrsts;
    ulong       ts_numconns;
} TCPStats;

#define TCP_RTO_OTHER       1
#define TCP_RTO_CONSTANT    2
#define TCP_RTO_RSRE        3
#define TCP_RTO_VANJ        4

#define TCP_MAXCONN_DYNAMIC -1

typedef struct UDPStats {
    ulong       us_indatagrams;
    ulong       us_noports;
    ulong       us_inerrors;
    ulong       us_outdatagrams;
    ulong       us_numaddrs;
} UDPStats;

typedef struct TCPConnTableEntry {
    ulong       tct_state;
    ulong       tct_localaddr;
    ulong       tct_localport;
    ulong       tct_remoteaddr;
    ulong       tct_remoteport;
} TCPConnTableEntry;

typedef struct TCP6ConnTableEntry {
    struct in6_addr tct_localaddr;
    ulong           tct_localscopeid;
    ulong           tct_localport;
    struct in6_addr tct_remoteaddr;
    ulong           tct_remotescopeid;
    ulong           tct_remoteport;
    ulong           tct_state;
    ulong           tct_owningpid;
} TCP6ConnTableEntry, *PTCP6ConnTableEntry;

//* Definitions for the tct_state variable.
#define TCP_CONN_CLOSED     1                   // Closed.
#define TCP_CONN_LISTEN     2                   // Listening.
#define TCP_CONN_SYN_SENT   3                   // SYN Sent.
#define TCP_CONN_SYN_RCVD   4                   // SYN received.
#define TCP_CONN_ESTAB      5                   // Established.
#define TCP_CONN_FIN_WAIT1  6                   // FIN-WAIT-1
#define TCP_CONN_FIN_WAIT2  7                   // FIN-WAIT-2
#define TCP_CONN_CLOSE_WAIT 8                   // Close waiting.
#define TCP_CONN_CLOSING    9                   // Closing state.
#define TCP_CONN_LAST_ACK   10                  // Last ack state.
#define TCP_CONN_TIME_WAIT  11                  // Time wait state.
#define TCP_DELETE_TCB      12                  // Set to delete this TCB.


typedef struct TCPConnTableEntryEx {
    TCPConnTableEntry   tcte_basic;
    ulong               tcte_owningpid;
} TCPConnTableEntryEx;

typedef struct _TCP_EX_TABLE
{
    ulong               dwNumEntries;
    TCPConnTableEntryEx table[1];
} TCP_EX_TABLE;

typedef struct _TCP6_EX_TABLE
{
    ulong              dwNumEntries;
    TCP6ConnTableEntry table[1];
} TCP6_EX_TABLE, *PTCP6_EX_TABLE;


typedef struct UDPEntry {
    ulong       ue_localaddr;
    ulong       ue_localport;
} UDPEntry;

typedef struct UDPEntryEx {
    UDPEntry    uee_basic;
    ulong       uee_owningpid;
} UDPEntryEx;

typedef struct _UDP_EX_TABLE
{
    ulong               dwNumEntries;
    UDPEntryEx          table[1];
} UDP_EX_TABLE;

typedef struct UDP6ListenerEntry {
    struct in6_addr ule_localaddr;
    ulong           ule_localscopeid;
    ulong           ule_localport;
    ulong           ule_owningpid;
} UDP6ListenerEntry, *PUDP6ListenerEntry;

typedef struct _UDP6_LISTENER_TABLE
{
    ulong               dwNumEntries;
    UDP6ListenerEntry   table[1];
} UDP6_LISTENER_TABLE, *PUDP6_LISTENER_TABLE;


#define TCP_MIB_STAT_ID         1
#define UDP_MIB_STAT_ID         1
#define TCP_MIB_TABLE_ID        0x101
#define UDP_MIB_TABLE_ID        0x101
#define TCP_EX_TABLE_ID         0x102
#define UDP_EX_TABLE_ID         0x102

// Sockets based identifiers for connections.

typedef struct TCPSocketOption {
    ulong       tso_value;
} TCPSocketOption;

typedef struct TCPKeepalive {
    ulong   onoff;
    ulong   keepalivetime;
    ulong   keepaliveinterval;
} TCPKeepalive;

//* Structure passed in/returned from the SOCKET_ATMARK call. The tsa_offset
//  field indicate how far back or forward in the data stream urgent data
//  was or will be returned. A negative value means inline urgent data has
//  already been given to the client, -tsa_offset bytes ago. A positive value
//  means that inline urgent data is available tsa_offset bytes down the
//  data stream. The tsa_size field is the size in bytes of the urgent data.
//  This call when always return a 0 size and offset if the connection is not
//  in the urgent inline mode.

typedef struct TCPSocketAMInfo {
    ulong       tsa_size;               // Size of urgent data returned.
    long        tsa_offset;             // Offset of urgent data returned.
} TCPSocketAMInfo;

#define TCP_SOCKET_NODELAY      1
#define TCP_SOCKET_KEEPALIVE    2
#define TCP_SOCKET_OOBINLINE    3
#define TCP_SOCKET_BSDURGENT    4
#define TCP_SOCKET_ATMARK       5
#define TCP_SOCKET_WINDOW       6
#define TCP_SOCKET_KEEPALIVE_VALS 7
#define TCP_SOCKET_TOS          8
#define TCP_SOCKET_SCALE_CWIN   9


//  Address object identifies. All but AO_OPTION_MCASTIF take single boolean
//  character value. That one expects a pointer to an IP address.

#define AO_OPTION_TTL                1
#define AO_OPTION_MCASTTTL           2
#define AO_OPTION_MCASTIF            3
#define AO_OPTION_XSUM               4
#define AO_OPTION_IPOPTIONS          5
#define AO_OPTION_ADD_MCAST          6
#define AO_OPTION_DEL_MCAST          7
#define AO_OPTION_TOS                8
#define AO_OPTION_IP_DONTFRAGMENT    9
#define AO_OPTION_MCASTLOOP         10
#define AO_OPTION_BROADCAST         11
#define AO_OPTION_IP_HDRINCL        12
#define AO_OPTION_RCVALL            13
#define AO_OPTION_RCVALL_MCAST      14
#define AO_OPTION_RCVALL_IGMPMCAST  15
#define AO_OPTION_UNNUMBEREDIF      16
#define AO_OPTION_IP_UCASTIF        17
#define AO_OPTION_ABSORB_RTRALERT   18
#define AO_OPTION_LIMIT_BCASTS      19
#define AO_OPTION_INDEX_BIND        20
#define AO_OPTION_INDEX_MCASTIF     21
#define AO_OPTION_INDEX_ADD_MCAST   22
#define AO_OPTION_INDEX_DEL_MCAST   23
#define AO_OPTION_IFLIST            24
#define AO_OPTION_ADD_IFLIST        25
#define AO_OPTION_DEL_IFLIST        26
#define AO_OPTION_IP_PKTINFO        27
#define AO_OPTION_ADD_MCAST_SRC     28
#define AO_OPTION_DEL_MCAST_SRC     29
#define AO_OPTION_MCAST_FILTER      30
#define AO_OPTION_BLOCK_MCAST_SRC   31
#define AO_OPTION_UNBLOCK_MCAST_SRC 32
#define AO_OPTION_UDP_CKSUM_COVER   33
#define AO_OPTION_WINDOW            34
#define AO_OPTION_SCALE_CWIN        35
#define AO_OPTION_RCV_HOPLIMIT      36

// Values used with AO_OPTION_RCVALL*
// These must match the values defined in mstcpip.h
#define RCVALL_OFF             0
#define RCVALL_ON              1
#define RCVALL_SOCKETLEVELONLY 2

//* Information relating to setting/deleting IP multicast addresses.
typedef struct UDPMCastReq {
    ulong       umr_addr;               // MCast address to add/delete.
    ulong       umr_if;                 // I/F on which to join.
} UDPMCastReq;

//* Information relating to setting/deleting IP multicast source/group
//  addresses.  This must match ip_mreq_source.
typedef struct UDPMCastSrcReq {
    ulong       umr_addr;               // MCast address to add/delete.
    ulong       umr_src;                // Source address to add/delete.
    ulong       umr_if;                 // I/F on which to join.
} UDPMCastSrcReq;

//* Information relating to setting/deleting IP multicast source filters.
//  This must match ip_msfilter.
typedef struct UDPMCastFilter {
    ulong       umf_addr;               // MCast address to apply source to.
    ulong       umf_if;                 // I/F on which to join.
    ulong       umf_fmode;              // Filter mode (TRUE=exclude)
    ulong       umf_numsrc;             // Number of sources.
    ulong       umf_srclist[1];           // Source array.
} UDPMCastFilter;

#define UDPMCAST_FILTER_SIZE(numsrc) \
    ((ulong)FIELD_OFFSET (UDPMCastFilter, umf_srclist[numsrc]))

//* Structure defining what is passed in to AO_OPTION_MCASTIF request.
typedef struct UDPMCastIFReq {
    IPAddr      umi_addr;
} UDPMCastIFReq;


//
// Structures used in security filter enumeration.
//
// All values are in HOST byte order!!!
//
typedef struct TCPSecurityFilterEntry {
    ulong   tsf_address;        // IP interface address
    ulong   tsf_protocol;       // Transport protocol number
    ulong   tsf_value;          // Transport filter value (e.g. TCP port)
} TCPSecurityFilterEntry;

typedef struct TCPSecurityFilterEnum {
    ULONG tfe_entries_returned;  // The number of TCPSecurityFilterEntry structs
                                 // returned in the subsequent array.

    ULONG tfe_entries_available; // The number of TCPSecurityFilterEntry structs
                                 // currently available from the transport.
} TCPSecurityFilterEnum;

//
// Structures used in connection list enumeration.
//
// All values are in HOST byte order!!!
//

typedef struct TCPConnectionListEntry {
    IPAddr  tcf_address;        // IP address
    uint    tcf_ticks;          // Tick Count remaining
} TCPConnectionListEntry;

typedef struct TCPConnectionListEnum {
    ULONG tce_entries_returned;  // The number of TCPConnectionListEntry structs
                                 // returned in the subsequent array.

    ULONG tce_entries_available; // The number of TCPConnectionListEntry structs
                                 // currently available from the transport.
} TCPConnectionListEnum;

#endif // TCP_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\tstring.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tstring.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    13-Jan-1992 JohnRo
        Oops, I missed from NetpAlloc{type}From{type} macros
        Also added STRNCMPI as an alias for STRNICMP.
    16-Jan-1992 Danl
        Moved the macros to \private\inc\tstr.h
    23-Mar-1992 JohnRo
        Added NetpCopy{Str,TStr,WStr}ToUnalignedWStr().
    27-Apr-1992 JohnRo
        Changed NetpNCopy{type}From{type} to return NET_API_STATUS.
    03-Aug-1992 JohnRo
        RAID 1895: Net APIs and svcs should use OEM char set.
    14-Apr-1993 JohnRo
        RAID 6113 ("PortUAS: dangerous handling of Unicode").
        Made changes suggested by PC-LINT 5.0

--*/

#ifndef _TSTRING_H_INCLUDED
#define _TSTRING_H_INCLUDED


#include <lmcons.h>     // NET_API_STATUS.
// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,tstr.h,winerror.h) */
/*lint -efile(766,tstr.h,winerror.h) */
#include <tstr.h>       // tstring stuff, used in macros below.
#include <winerror.h>   // NO_ERROR.


//
// Eventually, most uses of non-UNICODE strings should refer to the default
// codepage for the LAN.  The NetpCopy functions support the default codepage.
// The other STR macros may not.
//
VOID
NetpCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src              // string in default LAN codepage
    );

NET_API_STATUS
NetpNCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src,             // string in default LAN codepage
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

NET_API_STATUS
NetpNCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStrDBCS(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

VOID
NetpCopyWStrToStrDBCSN(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD MaxStringSize
    );


ULONG
NetpUnicodeToDBCSLen(
    IN  LPWSTR Src
    );


#ifdef UNICODE

#define NetpCopyStrToTStr(Dest,Src)  NetpCopyStrToWStr((Dest),(Src))
#define NetpCopyTStrToStr(Dest,Src)  NetpCopyWStrToStr((LPSTR)(Dest),(LPWSTR)(Src))
#define NetpCopyTStrToWStr(Dest,Src) (void) wcscpy((Dest),(Src))

#define NetpNCopyTStrToWStr(Dest,Src,Len) \
                        (wcsncpy((Dest),(Src),(Len)), NO_ERROR)

#endif // UNICODE


//
// Define a set of allocate and copy functions.  These all return NULL if
// unable to allocate memory.  The memory must be freed with NetApiBufferFree.
//

LPSTR
NetpAllocStrFromStr (
    IN LPSTR Src
    );

LPSTR
NetpAllocStrFromWStr (
    IN LPWSTR Src
    );

LPWSTR
NetpAllocWStrFromStr (
    IN LPSTR Src
    );

LPWSTR
NetpAllocWStrFromWStr (
    IN LPWSTR Src
    );

//
// As of 03-Aug-1992, people are still arguing over whether there should
// be an RtlInitOemString.  So I'm inventing NetpInitOemString in the
// meantime.  --JR
//

#ifdef _NTDEF_   // POEM_STRING typedef visible?

VOID
NetpInitOemString(
    OUT POEM_STRING DestinationString,
    IN  PCSZ        SourceString
    );

#endif // _NTDEF_


//
//
// ANSI versions of the API.
//

LPWSTR
NetpAllocWStrFromAStr (
    IN LPCSTR Src
    );

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Src
    );

#endif  // _TSTRING_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\uiexport.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    uiexport.h

    Prototypes for Net UI exported APIs



    FILE HISTORY:
	Johnl	17-Apr-1992	Created

*/

#ifndef _UIEXPORT_H_
#define _UIEXPORT_H_

#ifdef __cplusplus
extern "C" {
#endif


/* Selections the user can make in the System focus dialog
 */

/* Low word of the selection type
 */
#define FOCUSDLG_DOMAINS_ONLY		(1)
#define FOCUSDLG_SERVERS_ONLY		(2)
#define FOCUSDLG_SERVERS_AND_DOMAINS	(3)

/* High word of the selection type contains a bitmask indicating
 * which domains to display in the dialog.
 * WARNING: This bitmask are shifted up 16 bits from the bitmask in
 *          \nt\private\net\ui\common\h\domenum.h. If you want to
 *          modify the values of the bitmask, you will need to
 *          make corresponding changes to domenum.h.
 *
 */

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

/* Some handy combinations of flags.
*/

/* FOCUSDLG_BROWSE_LM2X_DOMAINS will return only the domains available
   from a LanMan 2.x workstation.  This returns just the logon,
   workstation, and other domains. This is the default value.
*/

#define FOCUSDLG_BROWSE_LM2X_DOMAINS  ( FOCUSDLG_BROWSE_LOGON_DOMAIN       | \
                                        FOCUSDLG_BROWSE_WKSTA_DOMAIN       | \
                                        FOCUSDLG_BROWSE_OTHER_DOMAINS )

/*
   FOCUSDLG_BROWSE_LOCAL_DOMAINS will return only the domains available
   to the local machine.  This returns the logon, workstation,
   and other, plus the domains that trust "us".
*/

#define FOCUSDLG_BROWSE_LOCAL_DOMAINS ( FOCUSDLG_BROWSE_LM2X_DOMAINS       | \
                                        FOCUSDLG_BROWSE_TRUSTING_DOMAINS )

/*
  FOCUSDLG_BROWSE_ALL_DOMAINS is a conglomeration of all potential domain
  sources available to the domain enumerator.
*/

#define FOCUSDLG_BROWSE_ALL_DOMAINS   ( FOCUSDLG_BROWSE_LOCAL_DOMAINS      | \
                                        FOCUSDLG_BROWSE_WORKGROUP_DOMAINS )

/*******************************************************************

    NAME:	I_SystemFocusDialog

    SYNOPSIS:	Presents a dialog to the user from which a server or domain
		maybe selected.

    ENTRY:	hwndOwner -       Parent window handle
		nSelectionType -  The type of selection the user is allowed
			          to make
		pszName -         The server or domain name. It will be
			          undefined if the user hits the CANCEL
                                  button ( pfOK = FALSE )
		cchBufSize -      The buffer size of the lptstrName.
		pfUserQuit -      If the user hits the OKAY button, it will
                                  return TRUE. Otherwise, it will return FALSE.
                pszHelpFile -     The helpfile to use when the user hits F1.
                                  If NULL, the default helpfile is used.
                nHelpContext -    The helpcontext to use for the helpfile above.
 				  If the above is NULL, this must be 0 (& vice
                                  versa).

    EXIT:	if *pfOKPressed is TRUE (and an error didn't occur), then
		lptstrName will be filled with the user selected name.

    RETURNS:	NO_ERROR on success, standard ERROR_* error code otherwise

    NOTES:	This will be a UNICODE only API when the net group goes UNICODE

    HISTORY:
	JohnL	22-Apr-1992	Added selection option, exported to private\inc
	ChuckC	03-Nov-1992	Added helpfile & help context

********************************************************************/

UINT FAR PASCAL I_SystemFocusDialog(
    HWND    hwndOwner,
    UINT    nSelectionType,
    LPWSTR  pszName,
    UINT    cchBufSize,
    BOOL   *pfOKPressed,
    LPWSTR  pszHelpFile,
    DWORD   nHelpContext
    );

typedef UINT (FAR PASCAL *LPFNI_SYSTEMFOCUSDIALOG)(
    HWND    hwndOwner,
    UINT    nSelectionType,
    LPWSTR  pszName,
    UINT    cchBufSize,
    BOOL   *pfOKPressed,
    LPWSTR  pszHelpFile,
    DWORD   nHelpContext
    );

#ifdef __cplusplus
}
#endif

#endif //_UIEXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\wlrsop.h ===
//
// For stuff that's passed from Winlogon/Group Policy
// to polstore (see RSOP_PolicySetting in MSDN)
//

#define WIRELESS_RSOP_CLASSNAME L"RSOP_IEEE80211PolicySetting"

typedef struct _GPO_INFO {
  BSTR     bsCreationtime;
  UINT32   uiPrecedence;
  BSTR     bsGPOID;
  BSTR     bsSOMID;
  UINT32   uiTotalGPOs;
}  GPO_INFO, *PGPO_INFO;



HRESULT
WirelessWriteDirectoryPolicyToWMI(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    PGPO_INFO pGPOInfo,
    IWbemServices *pWbemServices
    );

HRESULT
WirelessClearWMIStore(
    IWbemServices *pWbemServices
    );

typedef struct _RSOP_INFO {
  LPWSTR   pszCreationtime;
  LPWSTR   pszID;
  LPWSTR   pszName;
  UINT32   uiPrecedence;
  LPWSTR   pszGPOID;
  LPWSTR   pszSOMID;
} RSOP_INFO, * PRSOP_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\winsintf.h ===
#ifndef WINSINTF_H
#define WINSINTF_H
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	winsintf.h	

Abstract:
	
	This is the header file to be included in a client of the WINS

Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	April-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include <winbase.h>

#if !defined(MIDL_PASS)
#include <rpc.h>
#include <rpcasync.h>
#include <winerror.h>
#endif

#ifdef  WINS_CLIENT_APIS
#define DECLARE_WINS_HANDLE( _hdl ) WINSIF2_HANDLE    _hdl,
#define DECLARE_WINS_HANDLE0( _hdl ) WINSIF2_HANDLE    _hdl
#else
#define DECLARE_WINS_HANDLE( _hdl )
#define DECLARE_WINS_HANDLE0( _hdl )
#endif  WINS_CLIENT_APIS

/*
  defines
*/
#define WINSINTF_MAX_NAME_SIZE			255
//#define WINSINTF_MAX_COMPUTERNAME_LENGTH			(MAX_COMPUTERNAME_LENGTH + 1)


#define WINSINTF_MAX_NO_RPL_PNRS	25
#define WINSINTF_SUCCESS 		ERROR_SUCCESS
#define WINSINTF_FAILURE 		 ERROR_WINS_INTERNAL
#define WINSINTF_CAN_NOT_DEL_LOCAL_WINS ERROR_CAN_NOT_DEL_LOCAL_WINS
#define WINSINTF_STATIC_INIT_FAILED  ERROR_STATIC_INIT
#define WINSINTF_INC_BACKUP_FAILED   ERROR_INC_BACKUP
#define WINSINTF_FULL_BACKUP_FAILED  ERROR_FULL_BACKUP
#define WINSINTF_REC_NOT_FOUND       ERROR_REC_NON_EXISTENT
#define WINSINTF_RPL_NOT_ALLOWED     ERROR_RPL_NOT_ALLOWED

#define WINSINTF_TOO_MANY_STATIC_INITS  ERROR_TOO_MANY_OPEN_FILES
#define WINSINTF_LAST_FAILURE_CODE	WINSINTF_TOO_MANY_STATIC_INITS

#define WINS_BACKUP_DIR_ASCII   "\\wins_bak"
#define WINS_BACKUP_DIR          TEXT(WINS_BACKUP_DIR_ASCII)

//
// Flags that can be set in WINS
//
#define WINSINTF_BS                     0x01
#define WINSINTF_MEMORY_INFO_DUMP       0x02
#define WINSINTF_HEAP_INFO_DUMP         0x04
#define WINSINTF_QUE_ITEMS_DUMP         0x08

#define  WINS_NO_ACCESS	        0x0
#define  WINS_CONTROL_ACCESS	0x0001
#define  WINS_QUERY_ACCESS	    0x0002

#define  WINS_ALL_ACCESS	(STANDARD_RIGHTS_REQUIRED | \
				  WINS_CONTROL_ACCESS |WINS_QUERY_ACCESS)

//
// Type of address families
//
#define WINSINTF_TCP_IP			0x0

//
// Type Of Recs to retrieve (WinsGetDbRecsByName)
//
//  Note: There should be no ovelap of bit patterns
//
#define WINSINTF_STATIC  1
#define WINSINTF_DYNAMIC 2
#define WINSINTF_BOTH    4

//
// Max. members returned for a special group or a multihomed entry
//
#define WINSINTF_MAX_MEM		25	
#define WINSINTF_MAX_ADD		(WINSINTF_MAX_MEM * 2)	

//
//  used as argument of WinsGetDbRecsByName
//
#define  WINSINTF_BEGINNING       0
#define  WINSINTF_END             1

/*
  macros
*/

//
// Pass the value of the field NameLen (WINSINTF_RECORD_ACTION_T) to get
// the actual length of the name
//
#define  WINSINTF_NAME_LEN_M(NameLen)   ((NameLen) - 1)


/*
 externs
*/
struct _WINSINTF_STAT_T;		//forward declaration

#if !defined(MIDL_PASS)
extern  struct _WINSINTF_STAT_T   WinsIntfStat;
extern CRITICAL_SECTION 	WinsIntfCrtSec;
extern CRITICAL_SECTION 	WinsIntfPotentiallyLongCrtSec;
#endif

extern DWORD	WinsIntfNoOfNbtThds;
extern DWORD	WinsIntfNoCncrntStaticInits;
//extern DWORD    WinsIntfNoOfRpcThds;


#ifndef UNICODE
#define WinsBind  WinsABind
#else
#define WinsBind  WinsUBind
#endif

/*
* typedefs
*/
typedef LARGE_INTEGER	WINSINTF_VERS_NO_T;
typedef handle_t        WINSIF2_HANDLE;

//
// NOTE NOTE NOTE
//
// When UNICODE is defined, the client should put a unicode string in
// the pServerAdd and pPipeName fields.
//
typedef struct _WINSINTF_BIND_DATA_T {
		DWORD	fTcpIp;
		LPSTR   pServerAdd; //IP address
		LPSTR	pPipeName;  //unc name
	} WINSINTF_BIND_DATA_T, *PWINSINTF_BIND_DATA_T;


typedef struct _WINSINTF_ADD_T {
		BYTE	Type;
		DWORD	Len;
		DWORD	IPAdd;
	} WINSINTF_ADD_T, *PWINSINTF_ADD_T;
	

	
/*
 enum  definitions.  Have the enum types be of the same value as given
 in nmsdb.h for the various types (otherwise modify winsintf.c code)
*/

//
// Wins Priority Class
//
typedef enum _WINSINTF_PRIORITY_CLASS_E {
		WINSINTF_E_NORMAL = 0,
		WINSINTF_E_HIGH
	} WINSINTF_PRIORITY_CLASS_E, *PWINSINTF_PRIORITY_CLASS_E;

//
// same values as those defined in nmsdb.h
//

//
//NOTE NOTE NOTE
//
// For the enum below,  WINSINTF_E_MULTIHOMED should be the last entry. If
// it is not, you should change WinsRecordAction (under MODIFY) in winsintf.c
//
// Do not disturb the order without changing wins.mib correspondingly
//
typedef enum _WINSINTF_RECTYPE_E {
		WINSINTF_E_UNIQUE 	= 0,
		WINSINTF_E_NORM_GROUP,
		WINSINTF_E_SPEC_GROUP,
		WINSINTF_E_MULTIHOMED
	} WINSINTF_RECTYPE_E, *PWINSINTF_RECTYPE_E;

//
// Same values as those in NMSDB_STATE_E
//

//
//NOTE NOTE NOTE
//
// For the enum below,  WINSINTF_E_DELETED should be the last entry. If
// it is not, you should change WinsRecordAction (under MODIFY) in winsintf.c
//
//  NOTE NOTE NOTE
//
// Do not disturb the order without changing wins.mib correspondingly
//
typedef enum _WINSINTF_STATE_E {
		WINSINTF_E_ACTIVE = 0,
		WINSINTF_E_RELEASED,
		WINSINTF_E_TOMBSTONE,
		WINSINTF_E_DELETED
		} WINSINTF_STATE_E, *PWINSINTF_STATE_E;

typedef enum _WINSINTF_NODE_TYPE_E {
		WINSINTF_E_BNODE = 0,
		WINSINTF_E_PNODE,
		WINSINTF_E_HNODE = 3,
		} WINSINTF_NODE_TYPE_E, *PWINSINTF_NODE_TYPE_E;
//
// Type of action to take on a record.  This is passed as the "command" to
// WinsRecordAction.
//
typedef enum  _WINSINTF_ACT_E {
	WINSINTF_E_INSERT = 0,
	WINSINTF_E_DELETE,
	WINSINTF_E_RELEASE,
	WINSINTF_E_MODIFY,
	WINSINTF_E_QUERY
	} WINSINTF_ACT_E, *PWINSINTF_ACT_E;


//
// Passed as argument to WinsIntfSetTime
//
typedef enum _WINSINTF_TIME_TYPE_E {
	WINSINTF_E_PLANNED_PULL = 0,
	WINSINTF_E_ADDCHG_TRIG_PULL,
	WINSINTF_E_UPDCNT_TRIG_PULL,
	WINSINTF_E_ADMIN_TRIG_PULL,
	WINSINTF_E_NTWRK_TRIG_PULL,
	WINSINTF_E_PLANNED_SCV,
	WINSINTF_E_ADMIN_TRIG_SCV,
	WINSINTF_E_TOMBSTONES_SCV,
	WINSINTF_E_VERIFY_SCV,
	WINSINTF_E_INIT_DB,
	WINSINTF_E_WINS_START,
	WINSINTF_E_COUNTER_RESET
	} WINSINTF_TIME_TYPE_E, *PWINSINTF_TIME_TYPE_E;

//
// Type of trigger to send to a WINS
//
typedef enum _WINSINTF_TRIG_TYPE_E {	
		WINSINTF_E_PULL = 0,
		WINSINTF_E_PUSH,
		WINSINTF_E_PUSH_PROP
	} WINSINTF_TRIG_TYPE_E, *PWINSINTF_TRIG_TYPE_E;


typedef struct _WINSINTF_RECORD_ACTION_T {

	WINSINTF_ACT_E	Cmd_e;
#if defined(MIDL_PASS)
	[size_is(NameLen + 1)] LPBYTE	pName;  //ansi form
#else
        LPBYTE          pName;
#endif

	DWORD		NameLen;
	DWORD		TypOfRec_e;
	DWORD		NoOfAdds;
#if defined(MIDL_PASS)
        [unique, size_is(NoOfAdds)] PWINSINTF_ADD_T pAdd;
#else
        PWINSINTF_ADD_T pAdd;
#endif

	WINSINTF_ADD_T	Add;
	LARGE_INTEGER	VersNo;
	BYTE		NodeTyp;
	DWORD		OwnerId;
	DWORD		State_e;
	DWORD		fStatic;
	DWORD_PTR       TimeStamp;
	} WINSINTF_RECORD_ACTION_T, *PWINSINTF_RECORD_ACTION_T;


typedef struct _WINSINTF_RPL_COUNTERS_T {
		WINSINTF_ADD_T	Add;
		DWORD	NoOfRpls;
		DWORD	NoOfCommFails;
		} WINSINTF_RPL_COUNTERS_T, *PWINSINTF_RPL_COUNTERS_T;
//
// Structure holds the various statistics collected by WINS
//
typedef struct _WINSINTF_STAT_T {
		struct {
		DWORD  NoOfUniqueReg;
		DWORD  NoOfGroupReg;
		DWORD  NoOfQueries;
		DWORD  NoOfSuccQueries;
		DWORD  NoOfFailQueries;
		DWORD  NoOfUniqueRef;
		DWORD  NoOfGroupRef;
		DWORD  NoOfRel;
		DWORD  NoOfSuccRel;
		DWORD  NoOfFailRel;
		DWORD  NoOfUniqueCnf;
		DWORD  NoOfGroupCnf;
		      } Counters;
		struct {
		SYSTEMTIME WinsStartTime;
		SYSTEMTIME LastPScvTime;
		SYSTEMTIME LastATScvTime;	//admin triggered
		SYSTEMTIME LastTombScvTime;	
		SYSTEMTIME LastVerifyScvTime;
		SYSTEMTIME LastPRplTime;
		SYSTEMTIME LastATRplTime;	//admin triggered
		SYSTEMTIME LastNTRplTime;	//network triggered
		SYSTEMTIME LastACTRplTime;	//address change triggered
		SYSTEMTIME LastInitDbTime;	//db initialization
		SYSTEMTIME CounterResetTime;    //counter reset time
		    } TimeStamps;
		DWORD			NoOfPnrs;

#if defined(MIDL_PASS)
		[unique, size_is(NoOfPnrs)] PWINSINTF_RPL_COUNTERS_T   pRplPnrs;
#else
		PWINSINTF_RPL_COUNTERS_T	pRplPnrs;
#endif
		} WINSINTF_STAT_T, *PWINSINTF_STAT_T;

typedef struct _WINSINTF_ADD_VERS_MAP_T {
		WINSINTF_ADD_T	Add;
		LARGE_INTEGER	VersNo;
		} WINSINTF_ADD_VERS_MAP_T, *PWINSINTF_ADD_VERS_MAP_T;
		
typedef struct _WINSINTF_RESULTS_T {
		DWORD			NoOfOwners;
		WINSINTF_ADD_VERS_MAP_T	AddVersMaps[WINSINTF_MAX_NO_RPL_PNRS];
		LARGE_INTEGER		MyMaxVersNo;
		DWORD			RefreshInterval;
		DWORD			TombstoneInterval;
		DWORD			TombstoneTimeout;
		DWORD			VerifyInterval;
		DWORD			WinsPriorityClass;
		DWORD			NoOfWorkerThds;
		WINSINTF_STAT_T		WinsStat;
		} WINSINTF_RESULTS_T, *PWINSINTF_RESULTS_T;	

typedef struct _WINSINTF_RESULTS_NEW_T {
		DWORD			NoOfOwners;
#if defined(MIDL_PASS)
		[unique, size_is(NoOfOwners)] PWINSINTF_ADD_VERS_MAP_T	pAddVersMaps;
#else
		PWINSINTF_ADD_VERS_MAP_T	pAddVersMaps;
#endif
		LARGE_INTEGER		MyMaxVersNo;
		DWORD			RefreshInterval;
		DWORD			TombstoneInterval;
		DWORD			TombstoneTimeout;
		DWORD			VerifyInterval;
		DWORD			WinsPriorityClass;
		DWORD			NoOfWorkerThds;
		WINSINTF_STAT_T		WinsStat;
		} WINSINTF_RESULTS_NEW_T, *PWINSINTF_RESULTS_NEW_T;	

typedef enum _WINSINTF_CMD_E {
		WINSINTF_E_ADDVERSMAP = 0,
		WINSINTF_E_CONFIG,
		WINSINTF_E_STAT,		//get statistics
		WINSINTF_E_CONFIG_ALL_MAPS
		} WINSINTF_CMD_E, *PWINSINTF_CMD_E;


#if 0
typedef struct _WINSINTF_RECS_T {
		PWINSINTF_RECORD_ACTION_T  pRow;
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;

typedef struct _WINSINTF_RECS_T {
		DWORD	BuffSize;
#if defined(MIDL_PASS)
		[unique,size_is(BuffSize)] LPBYTE  pRow;  //will store a pointer to
						   //an array of
						   //WINSINTF_RECORD_ACTION_T
						   //recs
#else
		LPBYTE pRow;
#endif
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;
#endif

typedef struct _WINSINTF_RECS_T {
		DWORD	BuffSize;
#if defined(MIDL_PASS)
		[unique,size_is(NoOfRecs)] PWINSINTF_RECORD_ACTION_T  pRow;  //will store a pointer to
						   //an array of
						   //WINSINTF_RECORD_ACTION_T
						   //recs
#else
		PWINSINTF_RECORD_ACTION_T pRow;
#endif
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;

//
// Provides information to the Pull thread for pulling the specfied range
// of records from a WINS server.  This structure is passed with the
// QUE_E_CMD_PULL_RANGE cmd.
//
typedef struct _WINSINTF_PULL_RANGE_INFO_T {
	LPVOID			pPnr;          //info of pnr to pull from
	WINSINTF_ADD_T		OwnAdd;
	WINSINTF_VERS_NO_T	MinVersNo;
	WINSINTF_VERS_NO_T	MaxVersNo;
	} WINSINTF_PULL_RANGE_INFO_T, *PWINSINTF_PULL_RANGE_INFO_T;

//
// NOTE NOTE NOTE:
//
// This structure is exactly the same as SERVER_INFO_100_CONTAINER.
// IT SHOULD STAY THE SAME.
//
typedef struct _WINSINTF_BROWSER_INFO_T {
	DWORD	dwNameLen;
#if defined(MIDL_PASS)
	[string] LPBYTE	pName;
#else
	LPBYTE	pName;
#endif
	} WINSINTF_BROWSER_INFO_T, *PWINSINTF_BROWSER_INFO_T;

typedef struct _WINSINTF_BROWSER_NAMES_T {
	DWORD			EntriesRead;		//no use
#if defined(MIDL_PASS)
	[unique, size_is(EntriesRead)]  PWINSINTF_BROWSER_INFO_T pInfo;
#else
	PWINSINTF_BROWSER_INFO_T	pInfo;
#endif
	} WINSINTF_BROWSER_NAMES_T, *PWINSINTF_BROWSER_NAMES_T;

typedef enum _WINSINTF_SCV_OPC_E {
          WINSINTF_E_SCV_GENERAL,
          WINSINTF_E_SCV_VERIFY
  } WINSINTF_SCV_OPC_E, *PWINSINTF_SCV_OPC_E;

//
// To send a scavenge request
//
typedef struct _WINSINTF_SCV_REQ_T {
          WINSINTF_SCV_OPC_E  Opcode_e;
          DWORD               Age;
          DWORD               fForce;
   } WINSINTF_SCV_REQ_T, *PWINSINTF_SCV_REQ_T;
	
typedef enum _DbVersion{
    DbVersionMin,
    DbVersion351 = 1,
    DbVersion4,
    DbVersion5,
    DbVersionMax
} DbVersion;

/*
* function declarations
*/
extern
handle_t
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsBind(
	PWINSINTF_BIND_DATA_T	pBindData
	);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsUnbind(
	PWINSINTF_BIND_DATA_T	pBindData,
	handle_t		BindHdl
	);

extern
DWORD
R_WinsRecordAction(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_RECORD_ACTION_T *ppRecAction
		 );

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsRecordAction(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_RECORD_ACTION_T	*ppRecAction
	);

extern
DWORD
R_WinsStatus(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_T pResults
		 );


extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatus(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	LPVOID              pResults
		 );
extern
DWORD
R_WinsStatusNew(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
		 );
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatusNew(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
		 );
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatusWHdl(
    PWINSINTF_BIND_DATA_T    pWinsHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	);

extern
DWORD
R_WinsTrigger (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTrigger (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	);

extern
DWORD
R_WinsDoStaticInit (
    DECLARE_WINS_HANDLE( ServerHdl )
	LPWSTR pDataFilePath,
    DWORD  fDel
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoStaticInit (
    DECLARE_WINS_HANDLE( ServerHdl )
	LPWSTR pDataFilePath,
    DWORD  fDel
	);

extern
DWORD
R_WinsGetDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T	pRecs	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsGetDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T	pRecs	
	);

extern
DWORD
R_WinsGetDbRecsByName (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
    DWORD               Location,
    LPBYTE              pName,
    DWORD               NameLen,
    DWORD               NoOfRecsDesired,
    DWORD               TypeOfRecs,
	PWINSINTF_RECS_T        pRecs	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetDbRecsByName (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
    DWORD               Location,
    LPBYTE              pName,
    DWORD               NameLen,
    DWORD               NoOfRecsDesired,
    DWORD               TypeOfRecs,
	PWINSINTF_RECS_T    pRecs	
	);

extern
DWORD
R_WinsDoScavenging (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoScavenging (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);
extern
DWORD
R_WinsDoScavengingNew (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_SCV_REQ_T pScvReq
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoScavengingNew (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_SCV_REQ_T pScvReq
	);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsIntfSetTime(
    DECLARE_WINS_HANDLE( ServerHdl )
	IN OUT PSYSTEMTIME     		pTime,
	IN     WINSINTF_TIME_TYPE_E	TimeType_e
	);
extern
DWORD
R_WinsTerm (
    handle_t ServerHdl,
	IN short		fAbruptTerm
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTerm (
    handle_t ServerHdl,
	IN short	fAbruptTerm
	);
extern
DWORD
R_WinsBackup (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN      LPBYTE			pBackupPath,
	IN	short			fIncremental	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsBackup (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN      LPBYTE			pBackupPath,
	IN	short			fIncremental	
	);
extern
DWORD
R_WinsDelDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDelDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
R_WinsPullRange (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	PWINSINTF_ADD_T   	pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsPullRange (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	PWINSINTF_ADD_T   	pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);

extern
DWORD
R_WinsSetPriorityClass (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN WINSINTF_PRIORITY_CLASS_E 	PrCls_e
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSetPriorityClass (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN WINSINTF_PRIORITY_CLASS_E 	PrCls_e
	);

extern
DWORD
R_WinsResetCounters (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsResetCounters (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
R_WinsWorkerThdUpd (
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD NewNoOfNbtThds
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsWorkerThdUpd (
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD NewNoOfNbtThds
	);
extern
DWORD
WinsRestore (
	LPBYTE BackupPath
	);


extern
DWORD
WinsRestoreEx (
	LPBYTE BackupPath ,
    DbVersion Version
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSyncUp (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T pWinsAdd,
	PWINSINTF_ADD_T pOwnAdd
	);


extern
DWORD
R_WinsGetNameAndAdd(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetNameAndAdd(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetBrowserNames(
    PWINSINTF_BIND_DATA_T       pWinsHdl,
	PWINSINTF_BROWSER_NAMES_T	pNames
	);


extern
VOID
R_WinsGetBrowserNames_notify(
    DECLARE_WINS_HANDLE0( ServerHdl )
);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetBrowserNames_Old(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_BROWSER_NAMES_T	pNames
	);

extern
DWORD
R_WinsDeleteWins(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd
	);

extern
DWORD
R_WinsSetFlags(
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD	fFlags
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSetFlags(
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD  fFlags	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDeleteWins(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd
	);

extern
void
#if !defined(MIDL_PASS)
__RPC_FAR * __RPC_API
//void  * __RPC_API
//void	*
#endif // MIDL_PASS
midl_user_allocate(size_t cBytes);

extern
//void __RPC_FAR * __RPC_API
void
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
//void
//midl_user_free(void __RPC_FAR *pMem);
midl_user_free(void *pMem);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsFreeMem(LPVOID pMem);

extern
LPVOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsAllocMem(size_t cBytes);

typedef struct _TREE_T  {
#if defined(MIDL_PASS)
		[unique] struct _TREE_T *fPtr;
		[ignore, unique] struct _TREE_T *bPtr;
		[unique, size_is(NameLen)] LPBYTE pName;
#else
		struct _TREE_T *fPtr;
		struct _TREE_T *bPtr;
		LPBYTE pName;
#endif
		unsigned short  NameLen;
		DWORD	x;
	} TREE_T, *PTREE_T;


extern
DWORD
R_WinsTombstoneDbRecs (
    WINSIF2_HANDLE      ServerHdl,
    PWINSINTF_ADD_T	    pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTombstoneDbRecs (
    DECLARE_WINS_HANDLE (ServerHdl)
    PWINSINTF_ADD_T	    pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);

extern
DWORD
R_WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    );

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\wsahelp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WsaHelp.h

Abstract:

    This header file contains prototypes required for Windows Sockets
    Helper DLLs.  The helper DLLs allow the Windows Sockets DLL to be
    transport independent by suppling the necessary option get/set and
    address conversion routines for an individual transport or transport
    family.

Author:

    David Treadwell (davidtr)    15-Jul-1992

Revision History:

    Keith Moore (keithmo)        08-Jan-1996
        Added WinSock 2 entrypoints.

--*/

#ifndef _WSAHELP_H_
#define _WSAHELP_H_

//
// Notification event definitions.  A helper DLL returns a mask of the
// events for which it wishes to be notified, and the Windows Sockets
// DLL calls the helper DLL in WSHNotify for each requested event.
//

#define WSH_NOTIFY_BIND                 0x01
#define WSH_NOTIFY_LISTEN               0x02
#define WSH_NOTIFY_CONNECT              0x04
#define WSH_NOTIFY_ACCEPT               0x08
#define WSH_NOTIFY_SHUTDOWN_RECEIVE     0x10
#define WSH_NOTIFY_SHUTDOWN_SEND        0x20
#define WSH_NOTIFY_SHUTDOWN_ALL         0x40
#define WSH_NOTIFY_CLOSE                0x80
#define WSH_NOTIFY_CONNECT_ERROR        0x100

//
// Definitions for various internal socket options.  These are used
// by the Windows Sockets DLL to communicate information to the helper
// DLL via get and set socket information calls.
//

#define SOL_INTERNAL 0xFFFE
#define SO_CONTEXT 1

//
// Open, Notify, and Socket Option routine prototypes.
//

typedef
INT
(WINAPI * PWSH_OPEN_SOCKET) (
    IN PINT AddressFamily,
    IN PINT SocketType,
    IN PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

INT
WINAPI
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

typedef
INT
(WINAPI * PWSH_NOTIFY) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    );

INT
WINAPI
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    );

typedef
INT
(WINAPI * PWSH_GET_SOCKET_INFORMATION) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    );

INT
WINAPI
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    );

typedef
INT
(WINAPI * PWSH_SET_SOCKET_INFORMATION) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    );

INT
WINAPI
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    );

//
// Structure and routine for determining the address family/socket
// type/protocol triples supported by an individual Windows Sockets
// Helper DLL.  The Rows field of WINSOCK_MAPPING determines the
// number of entries in the Mapping[] array; the Columns field is
// always 3 for Windows/NT product 1.
//

typedef struct _WINSOCK_MAPPING {
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[1];
} WINSOCK_MAPPING, *PWINSOCK_MAPPING;

typedef
DWORD
(WINAPI * PWSH_GET_WINSOCK_MAPPING) (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

DWORD
WINAPI
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

//
// Address manipulation routine.
//

typedef enum _SOCKADDR_ADDRESS_INFO {
    SockaddrAddressInfoNormal,
    SockaddrAddressInfoWildcard,
    SockaddrAddressInfoBroadcast,
    SockaddrAddressInfoLoopback
} SOCKADDR_ADDRESS_INFO, *PSOCKADDR_ADDRESS_INFO;

typedef enum _SOCKADDR_ENDPOINT_INFO {
    SockaddrEndpointInfoNormal,
    SockaddrEndpointInfoWildcard,
    SockaddrEndpointInfoReserved
} SOCKADDR_ENDPOINT_INFO, *PSOCKADDR_ENDPOINT_INFO;

typedef struct _SOCKADDR_INFO {
    SOCKADDR_ADDRESS_INFO AddressInfo;
    SOCKADDR_ENDPOINT_INFO EndpointInfo;
} SOCKADDR_INFO, *PSOCKADDR_INFO;

typedef
INT
(WINAPI * PWSH_GET_SOCKADDR_TYPE) (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    );

INT
WINAPI
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    );

typedef
INT
(WINAPI * PWSH_GET_WILDCARD_SOCKADDR) (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

INT
WINAPI
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

typedef
INT
(WINAPI * PWSH_ENUM_PROTOCOLS) (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

INT
WINAPI
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

#ifdef _WINSOCK2API_

//
// New WinSock 2 Entrypoints.
//

typedef
INT
(WINAPI * PWSH_OPEN_SOCKET2) (
    IN PINT AddressFamily,
    IN PINT SocketType,
    IN PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

INT
WINAPI
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

typedef
INT
(WINAPI * PWSH_JOIN_LEAF) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    );

INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    );

INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    );

typedef
INT
(WINAPI * PWSH_ADDRESS_TO_STRING) (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    );

INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    );

typedef
INT
(WINAPI * PWSH_STRING_TO_ADDRESS) (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    );

typedef
INT
(WINAPI * PWSH_GET_BROADCAST_SOCKADDR) (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

typedef
INT
(WINAPI * PWSH_GET_PROVIDER_GUID) (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    );

INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    );

typedef
INT
(WINAPI * PWSH_GET_WSAPROTOCOL_INFO) (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    );

INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    );

typedef
INT
(WINAPI * PWSH_IOCTL) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    );

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    );

#endif  // _WINSOCK2API_

#endif  // _WSAHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\wzcsvc.h ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzcsvc.h

Abstract:

    Header file for wzcdlg

Author:

    Deonb   27-March-2001

Environment:

    User Level: Win32

Revision History:

--*/

# ifdef     __cplusplus
extern "C" {
# endif

HRESULT
WZCQueryGUIDNCSState (
    IN      GUID            * pGuidConn,
    OUT     NETCON_STATUS   * pncs
    );

VOID
WZCTrayIconReady (
    IN      const WCHAR    * pszUserName
    );


# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\wzcdlg.h ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzcdlg.h

Abstract:

    Header file for wzcdlg

Author:

    Deonb   21-March-2001

Environment:

    User Level: Win32

Revision History:

--*/

# ifdef     __cplusplus
extern "C" {
# endif

BOOL
WZCDlgMain (
        IN HINSTANCE hInstance,
        IN DWORD    dwReason,
        IN LPVOID   lpReserved OPTIONAL);

HRESULT 
WZCCanShowBalloon ( 
        IN const GUID * pGUIDConn, 
        IN const PCWSTR pszConnectionName,
        IN OUT   BSTR * pszBalloonText, 
        IN OUT   BSTR * pszCookie
        );

HRESULT 
WZCOnBalloonClick ( 
        IN const GUID * pGUIDConn, 
        IN const BSTR pszConnectionName,
        IN const BSTR szCookie
        );

# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\lmon.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation
All rights reserved

Module Name:

    lmon.h

--*/


typedef struct _PORT_INFO_FFA {
    LPSTR   pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFA, *PPORT_INFO_FFA, *LPPORT_INFO_FFA;

typedef struct _PORT_INFO_FFW {
    LPWSTR  pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFW, *PPORT_INFO_FFW, *LPPORT_INFO_FFW;

#ifdef UNICODE
#define PORT_INFO_FF PORT_INFO_FFW
#define PPORT_INFO_FF PPORT_INFO_FFW
#define LPPORT_INFO_FF LPPORT_INFO_FFW
#else
#define PORT_INFO_FF PORT_INFO_FFA
#define PPORT_INFO_FF PPORT_INFO_FFA
#define LPPORT_INFO_FF LPPORT_INFO_FFA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\wsasetup.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wsasetup.h

Abstract:

    This header file contains the type definitions and function prototypes
    for the private interface between NT Setup and WSOCK32.DLL.

Author:

    Keith Moore (keithmo)        27-Oct-1995

Revision History:

--*/


#ifndef _WSASETUP_
#define _WSASETUP_


//
// Setup disposition, used to tell Setup what actions were taken (if any).
//

typedef enum _WSA_SETUP_DISPOSITION {

    WsaSetupNoChangesMade,
    WsaSetupChangesMadeRebootNotNecessary,
    WsaSetupChangesMadeRebootRequired

} WSA_SETUP_DISPOSITION, *LPWSA_SETUP_DISPOSITION;


//
// Opcodes for the migration callback (see below).
//

typedef enum _WSA_SETUP_OPCODE {

    WsaSetupInstallingProvider,
    WsaSetupRemovingProvider,
    WsaSetupValidatingProvider,
    WsaSetupUpdatingProvider

} WSA_SETUP_OPCODE, *LPWSA_SETUP_OPCODE;


//
// Callback function invoked by MigrationWinsockConfiguration() at
// strategic points in the migration process.
//

typedef
BOOL
(CALLBACK LPFN_WSA_SETUP_CALLBACK)(
    WSA_SETUP_OPCODE Opcode,
    LPVOID Parameter,
    DWORD Context
    );


//
// Private function exported by WSOCK32.DLL for use by NT Setup only.  This
// function updates the WinSock 2.0 configuration information to reflect any
// changes made to the WinSock 1.1 configuration.
//

DWORD
WINAPI
MigrateWinsockConfiguration(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    );

typedef
DWORD
(WINAPI * LPFN_MIGRATE_WINSOCK_CONFIGURATION)(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    );


#endif  // _WSASETUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\xsprocs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsProcs.h

Abstract:

    This header file contains procedure prototypes for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSPROCS_
#define _XSPROCS_

//
// API handling routines.
//

NTSTATUS
XsNetShareEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareCheck (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConnectionEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileClose (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerDiskEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerAdminCommand (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetAuditOpen (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogOpen (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQPurge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQPurgeSelf (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameFwd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameUnFwd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageBufferSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageFileSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageLogFileSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageLogFileGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceInstall (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupAddUser (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupDelUser (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupGetUsers (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserPasswordSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserGetGroups (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaSetUID (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQPause (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQContinue (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobSetInfo_OLD (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobPause (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobContinue (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetProfileSave (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetProfileLoad (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetRemoteTOD (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBiosEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBiosGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQPurge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessGetUserPerms (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupSetUsers (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetGroups (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserModalsGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserModalsSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserAdd2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetInfo2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserPasswordSet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConfigGet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConfigGetAll2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGetDCName (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetHandleGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetHandleSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsGet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBuildGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileGetInfo2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileClose2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerReqChallenge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerAuthenticate (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerPasswordSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccountDeltas (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccountSync (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaUserLogon (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaUserLogoff (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetLogonEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogRead (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathType (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathCanonicalize (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathCompare (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameValidate (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameCanonicalize (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameCompare (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditRead (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserValidate2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_NetServerDiskEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_NetServerDiskGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTVerifyMirror (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTAbortVerify (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTLockDisk (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTFixError (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTAbortFix (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTDiagnoseError (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTGetDriveStats (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTErrorGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessCheck (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertRaise (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertStart (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertStop (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditWrite (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetIRemoteAPI (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceStatus (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerRegister (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerDeregister (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsAltSrvMessageBufferSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsAltSrvMessageFileSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsSamOEMChangePasswordUser2_P (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum3 (
    API_HANDLER_PARAMETERS
    );

#endif // ndef _XSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\annotlib.h ===
#ifndef _ANNOT_H_
#define _ANNOT_H_

#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include <shimgdata.h>
// This file defines classes used to render and edit TIFF 6.0 annotations.
// These annotations are stored in tag #32932. The specification for these annotations
// is defined by Eastman Software, the spec version is 1.00.06.

#define ANNOTATION_IMAGE_TAG 32932

// These structures define the in-file layout of the annotations.
// Note that most of the structs are variable-sized.
// The annotation parser reads the annotations into these structures, wraps them in a descriptor
// and passes the descriptor to the annotation factory object to construct
// CAnnotationMark-derived classes that implement
// the rendering, editing, and saving of the different types of marks.

// MT_* used in ANNOTATIONMARK::uType
#define MT_IMAGEEMBED         1
#define MT_IMAGEREF           2
#define MT_STRAIGHTLINE       3
#define MT_FREEHANDLINE       4
#define MT_HOLLOWRECT         5
#define MT_FILLRECT           6
#define MT_TYPEDTEXT          7
#define MT_FILETEXT           8
#define MT_STAMP              9
#define MT_ATTACHANOTE       10
#define MT_FORM              11
#define MT_OCR               12 // unsupported

// ANNOTATIONMARK is fixed size and exists for every mark in the file
// We only support files with 4 byte integers
// this struct is not declared as UNALIGNED because we never typecast a variable
// as this type.
struct ANNOTATIONMARK
{
    UINT uType;                 /* The type of the mark (or operation).
                                    This will be ignored for sets.*/
    RECT lrBounds;             /* Rect in FULLSIZE units.
                                    This could be a rect or 2 points.*/
    RGBQUAD rgbColor1;          /* This is the main color. (Example: This is the
                                    color of all lines, rects, and stand alone
                                    text.*/
    RGBQUAD rgbColor2;          /* This is the secondary color. (Example: This
                                    is the color of the text of an ATTACH_A_NOTE.)*/
    BOOL bHighlighting;         /* TRUE = The mark will be drawn highlighted.
                                    This attribute is currently only valid
                                    for lines, rectangles, and freehand.*/
    BOOL bTransparent;          /* TRUE = The mark will be drawn transparent.
                                    If the mark is drawn transparent, then white
                                    pixels are not drawn (ie. there is nothing
                                    drawn for this mark where it contains white
                                    pixels. This attribute is currently only
                                    available for images. This attribute being
                                    set to TRUE will cause significant
                                    performance reduction.*/
    UINT uLineSize;             /* The size of the line etc. This is passed
                                    onto Windows and is currently in logical
                                    pixels for lines and rectangles.*/
    UINT uStartingPoint;        /* The shape put on the starting of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    UINT uEndPoint;             /* The shape put on the end of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    LOGFONTA lfFont;             /* The font information for the text. */
    BOOL bMinimizable;          /* TRUE = This mark can be minimized
                                    by the user. This flag is only used for
                                    marks that have a minimizable
                                    characteristic such as ATTACH_A_NOTE.*/
    UINT  Time;                /* The time that the mark was first saved.
                                    in seconds from 00:00:00 1-1-1970 (GMT).*/
    BOOL bVisible;              /* TRUE means that the layer is currently set
                                    to be visible.*/
    DWORD dwPermissions;        /* Reserved. Must be set to 0x0ff83f */
    UINT lReserved[10];         /* Reserved for future expansion.
                                    For this release these must be set to 0.*/
};


// ANNOTATIONHEADER is the first 4 bytes of data in the annotation property.
struct _ANNOTATIONHEADER
{
    BYTE reserved[4];
    UINT IntIs32Bit;
};

typedef UNALIGNED struct _ANNOTATIONHEADER ANNOTATIONHEADER;
//
// for OiAnoDat
//
struct _ANPOINTS
{
    int nMaxPoints;
    int nPoints;
    POINT ptPoint[1];
};

typedef UNALIGNED struct _ANPOINTS ANPOINTS;

struct _ANROTATE
{
    int rotation;
    int scale;
    int nHRes;
    int nVRes;
    int nOrigHRes;
    int nOrigVRes;
    BOOL bReserved1;
    BOOL bReserved2;
    int nReserved[6];
};

typedef UNALIGNED struct _ANROTATE ANROTATE;
// for OiFilNam
struct _ANNAME
{
    char szName[1];
};

typedef UNALIGNED struct _ANNAME ANNAME;
// for OiDIB
struct _ANIMAGE
{
    BYTE dibInfo[1]; // standard memory DIB
};

typedef UNALIGNED struct _ANIMAGE ANIMAGE;
// for OiAnText
struct _ANTEXTPRIVDATA
{
    int nCurrentOrientation;
    UINT uReserved1; // always 1000 when writing, ignore when reading
    UINT uCreationScale; // always 72000 divided by the vertical resolution of the base image when writing.
                         // Used to modify the Attributes.lfFont.lfHeight variable for display
    UINT uAnoTextLength; // 64k byte limit, except 255 byte limit for text stamp
    char szAnoText[1];
};

typedef UNALIGNED struct _ANTEXTPRIVDATA ANTEXTPRIVDATA;

// These structures provide descriptors for the data read from the annotation property blob.
// The extra data includes the size of each annotation structure
// _NAMEDBLOCK is our in-memory representation
struct _NAMEDBLOCK
{
    UINT cbSize;
    char szType[9];
    BYTE data[1];
};

typedef UNALIGNED struct _NAMEDBLOCK NAMEDBLOCK;

// _FILENAMEDBLOCK is what the namedblock looks like in the file
struct _FILENAMEDBLOCK
{
    char szType[8];
    UINT cbSize;
    BYTE data[1];
};

typedef UNALIGNED struct _FILENAMEDBLOCK FILENAMEDBLOCK;

struct ANNOTATIONDESCRIPTOR
{
    UINT cbSize;
    ANNOTATIONMARK mark;
    BYTE blocks[1];
};

// Define a base class for the various annotation types
class CAnnotation
{
public:
    static CAnnotation* CreateAnnotation(UINT type, ULONG uCreationScale);
    static CAnnotation* CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual ~CAnnotation();

    // render to the given rectangle in window client coordinates.
    virtual void Render(HDC hdc) { return; }
    // return the in-file representation of this annotation, as well as its total size
    HRESULT GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex);
    // return our image coordinates
    virtual void GetRect(RECT &rect) {rect = _mark.lrBounds;}
    // return the type of Annotation Mark used to change the selection handles for straight lines
    virtual UINT GetType() { return _mark.uType; }
    // moves the annotation on the page by the specified offset
    virtual void Move(SIZE sizeOffset) { OffsetRect(&_mark.lrBounds, sizeOffset.cx, sizeOffset.cy); }
    // return true if the object can be resized (true for every thing but freehand lines and images)
    virtual BOOL CanResize() { return true; }
    // resizes the annotation on the page to the new rect specified
    virtual void Resize(RECT rectNewSize);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasWidth() { return true; }
    virtual UINT GetWidth() { return _mark.uLineSize; }
    virtual void SetWidth(UINT nWidth) { _mark.uLineSize = nWidth; }

    virtual BOOL HasTransparent() { return true; }
    virtual BOOL GetTransparent() { return _mark.bHighlighting; }
    virtual void SetTransparent(BOOL bTransparent) { _mark.bHighlighting = bTransparent; }

    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

    virtual BOOL HasFont() { return true; }
    virtual void GetFont(LOGFONTA& lfFont) { CopyMemory (&lfFont, &_mark.lfFont, sizeof(lfFont)); }
    virtual void GetFont(LOGFONTW& lfFont);
    virtual void SetFont(LOGFONTA& lfFont) { CopyMemory (&_mark.lfFont, &lfFont, sizeof(lfFont)); }
    virtual void SetFont(LOGFONTW& lfFont);
    virtual LONG GetFontHeight(HDC hdc) { return _mark.lfFont.lfHeight; }

    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

protected:
    CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor);
    NAMEDBLOCK *_FindNamedBlock (LPCSTR szName, ANNOTATIONDESCRIPTOR *pDesc);
    virtual HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer) {return E_NOTIMPL;};
    // define helper functions for writing the different named block types
    SIZE_T _WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len);
    SIZE_T _WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints);
    SIZE_T _WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate);
    SIZE_T _WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen);
    SIZE_T _WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib);

    ANNOTATIONMARK _mark;
    LPSTR          _szGroup;
    FILENAMEDBLOCK *   _pUGroup;
};

class CRectMark : public CAnnotation
{
public:
    CRectMark (ANNOTATIONDESCRIPTOR *pDescriptor);
    void Render (HDC hdc);

    virtual BOOL HasWidth() { return (_mark.uType == MT_HOLLOWRECT); }
    virtual BOOL HasFont() { return false; }
};

class CImageMark : public CAnnotation
{
public:
    CImageMark (ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded);
    ~CImageMark();
    void Render (HDC hdc);
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);
    virtual BOOL CanResize() { return false; };
    virtual void Resize(RECT rectNewSize) { return; };

private:
    HANDLE _hDibSection; // cached image for quicker render
    LPBYTE _pDib;        // the DIB data from the annotation. If NULL, this is a reference mark
    ANROTATE _rotation;  // rotation info
    LPSTR    _szFilename;  // image file name from the annotation
    bool     _bRotate; //REVIEW_SDK: Shouldn't there just be a known blank rotation value? If I rotate something 0 degrees shouldn't just not write the rotation record?
    SIZE_T   _cbDib;
};

class CLineMark : public CAnnotation
{
public:
    CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand);
    ~CLineMark();
    void Render(HDC hdc);
    void GetRect(RECT &rect);
    void SetPoints(POINT* pPoints, int cPoints);
    void GetPointsRect(RECT &rect);
    virtual void Move(SIZE sizeOffset);
    virtual BOOL CanResize() { return (_nPoints == 2); };
    virtual void Resize(RECT rectNewSize);
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasFont() { return false; }

    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

private:
    int    _iMaxPts;
    int    _nPoints;
    POINT *_points; // 2 points for a straight line, more for a freehand line
};

// all text annotations render and initialize the same way so use a common base class
class CTextAnnotation : public CAnnotation
{
public:
    CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxText=65536, bool _bUseColor2=false);
    void Render(HDC hdc);
    virtual ~CTextAnnotation();
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

    virtual BOOL HasWidth() { return false; }
    virtual BOOL HasTransparent() { return false; }
    virtual BOOL HasColor() { return false; }
    virtual LONG GetFontHeight(HDC hdc);
    virtual int GetOrientation() { return _nCurrentOrientation; }

    BSTR GetText();
    void SetText(BSTR bstrText);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

private:
    int _nCurrentOrientation;
    UINT _uCreationScale;
    UINT _uAnoTextLength;
    UINT _nMaxText;
    LPSTR _szText;
    bool _bUseColor2;
};

class CTypedTextMark : public CTextAnnotation
{
public:
    CTypedTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CFileTextMark : public CTextAnnotation
{
public:
    CFileTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CTextStampMark : public CTextAnnotation
{
public:
    CTextStampMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CAttachNoteMark : public CTextAnnotation
{
public:
    CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor2.rgbRed, _mark.rgbColor2.rgbGreen, _mark.rgbColor2.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor2.rgbRed = GetRValue(crColor); _mark.rgbColor2.rgbGreen = GetGValue(crColor); _mark.rgbColor2.rgbBlue = GetBValue(crColor); }
};

class CAnnotationSet
{
public:
    CAnnotationSet ();
    ~CAnnotationSet ();

    // Draw all the marks
    void RenderAllMarks (HDC hdc);
    // construct annotation set from raw data
    HRESULT BuildAllMarksFromData( LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI );
    // Return the annotation at this point in image coordinates
    CAnnotation* GetAnnotation (INT_PTR nIndex);
    // Add a new annotation to the list. Should only be called from a CAnnotation
    BOOL AddAnnotation(CAnnotation *pMark);
    // Remove an annotation from the list. Should only be called from a CAnnotation
    BOOL RemoveAnnotation (CAnnotation *pMark);
    // Save the current set of annotations to the image
    HRESULT CommitAnnotations (IShellImageData *pimg);
    // Forget our old annotations and load new ones
    void SetImageData (IShellImageData *pimg);
    INT_PTR GetCount ()
    {
        if (_dpaMarks)
            return DPA_GetPtrCount(_dpaMarks);
        return 0;
    };

    UINT GetCreationScale();
    void ClearAllMarks();


private:
    HDPA    _dpaMarks;
    LPBYTE  _pDefaultData;
    SIZE_T  _cbDefaultData;
    ULONG   _xDPI;
    ULONG   _yDPI;

    static int CALLBACK _FreeMarks(LPVOID pMark, LPVOID pUnused);
    void   _ClearMarkList ();
    void   _BuildMarkList (IShellImageData *pimg);
    void   _BuildListFromData (LPVOID pData, UINT cbSize);
    INT    _NamedBlockDataSize (UINT uType, LPBYTE pData, LPBYTE pEOD);
    LPBYTE _MakeAnnotationBlob ();
    HRESULT _SaveAnnotationProperty(IShellImageData *pimg, LPBYTE pData, SIZE_T cbBuffer);
    ANNOTATIONDESCRIPTOR *_ReadMark (LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\faxreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This file contains all fax registry strings and general constants.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/


#ifndef _FAXREG_H_
#define _FAXREG_H_

#define FAX_PATH_SEPARATOR_STR  TEXT("\\")
#define FAX_PATH_SEPARATOR_CHR  TEXT('\\')
#define CP_SHORTCUT_EXT     _T(".lnk")

/*****************************************************************************
**                                                                          **
**               Global project definitions and constants                   **
**                                                                          **
*****************************************************************************/

#define FAX_API_MODULE_NAME                 TEXT("FXSAPI.DLL")                          // Used by the print monitor and setup
#define FAX_SERVICE_IMAGE_NAME              TEXT("%systemroot%\\system32\\FXSSVC.EXE")  // Used by the service
#define FAX_WZRD_MODULE_NAME                TEXT("FXSWZRD.DLL")                         // Used by setup
#define FAX_TIFF_MODULE_NAME                TEXT("FXSTIFF.DLL")                         // Used by setup
#define FAX_DRV_MODULE_NAME                 TEXT("FXSDRV.DLL")                          // Used by setup
#define FAX_DRV_WIN9X_32_MODULE_NAME        TEXT("FXSDRV32.DLL")
#define FAX_DRV_WIN9X_16_MODULE_NAME        TEXT("FXSDRV16.DRV")
#define FAX_DRV_UNIDRV_MODULE_NAME          TEXT("UNIDRV.DLL")
#define FAX_DRV_UNIDRV_HELP                 TEXT("UNIDRV.HLP")
#define FAX_DRV_DEPEND_FILE                 TEXT("FXSWZRD.DLL")
#define FAX_TIFF_FILE                       TEXT("FXSTIFF.DLL")
#define FAX_RES_FILE                        TEXT("FXSRES.DLL")
#define FAX_DRV_ICONLIB                     TEXT("ICONLIB.DLL")
#define FAX_UI_MODULE_NAME                  TEXT("FXSUI.DLL")                           // Used by setup
#define FAX_MONITOR_FILE                    TEXT("FXSMON.DLL")                          // Used by setup
#define FAX_EVENT_MSG_FILE                  TEXT("%systemroot%\\system32\\fxsevent.dll")// Used by service\regsitry\faxreg.c: CreateFaxEventSource()
#define FAX_MAIL_TRANSPORT_MODULE_NAME      TEXT("FXSXP32.DLL")                         // Used by exchange\xport\faxxp.h
#define FAX_POINT_PRINT_SETUP_DLL           TEXT("FXSOCM.DLL")                          // Used by print\faxprint\faxui\prnevent.c
#define FAX_SEND_IMAGE_NAME                 TEXT("fxssend.exe")                         // Used by the client console
#define FAX_COVER_IMAGE_NAME                TEXT("fxscover.exe")                        // Used by MMC and ClientConsole
#define FAX_COVER_PAGE_EXT_LETTERS          TEXT("cov")                                 // Used by MMC, CoverPage editor, and ClientConsole
#define FAX_COVER_PAGE_FILENAME_EXT         TEXT(".") FAX_COVER_PAGE_EXT_LETTERS        // Used by many
#define FAX_COVER_PAGE_MASK                 TEXT("*") FAX_COVER_PAGE_FILENAME_EXT       // Used by MMC, Outlook ext, and ClientConsole
#define FAX_LNK_FILE_EXT                    TEXT("lnk")                                 // Used by MAPI transport
#define FAX_LNK_FILE_DOT_EXT                TEXT(".") FAX_LNK_FILE_EXT                  // Used by MAPI transport
#define FAX_LNK_FILE_MASK                   TEXT("*") FAX_LNK_FILE_DOT_EXT              // Used by MAPI transport and Outlook ext.
#define FAX_TIF_FILE_EXT                    TEXT("tif")                                 // Used by the service
#define FAX_TIF_FILE_DOT_EXT                TEXT(".") FAX_TIF_FILE_EXT                  // Used by the service
#define FAX_TIF_FILE_MASK                   TEXT("*") FAX_TIF_FILE_DOT_EXT              // Used by the service
#define FAX_TIFF_FILE_EXT                   TEXT("tiff")                                // Used by print monitor
#define FAX_TIFF_FILE_DOT_EXT               TEXT(".") FAX_TIFF_FILE_EXT                 // Used by print monitor
#define FAX_TIFF_FILE_MASK                  TEXT("*") FAX_TIFF_FILE_DOT_EXT             // Used by print monitor
#define FAX_HTML_HELP_EXT                   TEXT("chm")                                 // Used by the client console
#define FAX_ADMIN_CONSOLE_IMAGE_NAME        TEXT("fxsadmin.msc")                        // Used by configuration wizard and ClientConsole
#define FAX_SERVICE_NAME                    TEXT("Fax")                                 // Used by the service
#define FAX_SERVICE_DISPLAY_NAME            TEXT("Microsoft Fax Server Service")        // Used by the service
#define FAX_SERVICE_DISPLAY_NAME_W          L"Microsoft Fax Server Service"             // Used by the service
#define FAX_PRINTER_NAME                    TEXT("Fax")                                 // Used everywhere
#define FAX_MONITOR_PORT_NAME               TEXT("SHRFAX:")                             // Used by print monitor and setup
#define FAX_PORT_NAME                       FAX_MONITOR_PORT_NAME                       // Used by print monitor and setup
#define FAX_DRIVER_NAME                     TEXT("Microsoft Shared Fax Driver")         // Used by print monitor and setup
#define FAX_DRIVER_NAME_A                   "Microsoft Shared Fax Driver"               // Used by print driver
#define FAX_WIN2K_DRIVER_NAME               TEXT("Windows NT Fax Driver")       // Legacy - for routing extension snap-in
#define FAX_MONITOR_NAME                    TEXT("Microsoft Shared Fax Monitor")        // Used by print monitor and setup
#define FAX_ADDRESS_TYPE_A                  "FAX"                                       // Used by MAPI transport
#define TRANSPORT_DISPLAY_NAME_STRING       "Microsoft Fax Mail Transport"              // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W2K        "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W9X        "AWFAX"                                     // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME            "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_T          TEXT(FAX_MESSAGE_SERVICE_NAME)
#define FAX_MESSAGE_PROVIDER_NAME           "MSFAX XPP"                                 // Used by MAPI transport
#define FAX_MESSAGE_PROVIDER_NAME_T         TEXT(FAX_MESSAGE_PROVIDER_NAME)
#define FAX_MESSAGE_SERVICE_NAME_SBS50      "SHAREDFAX XP"
#define FAX_MESSAGE_SERVICE_NAME_SBS50_T    TEXT(FAX_MESSAGE_SERVICE_NAME_SBS50)
#define FAX_MESSAGE_PROVIDER_NAME_SBS50     "SHAREDFAX XPP"
#define FAX_MESSAGE_PROVIDER_NAME_SBS50_T   TEXT(FAX_MESSAGE_PROVIDER_NAME_SBS50)


#define FAX_ROUTE_MODULE_NAME               TEXT("FXSROUTE")
#define FAX_T30_MODULE_NAME                 TEXT("FXST30")

#define FAX_MESSAGE_SERVICE_PROVIDER_NAME   "Microsoft Fax XPP"                         // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_PROVIDER_NAME_T TEXT(FAX_MESSAGE_SERVICE_PROVIDER_NAME)     // Used by MAPI transport
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME    "FXSXP.DLL"                                 // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T  TEXT(FAX_MESSAGE_TRANSPORT_IMAGE_NAME)      // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_RPC_ENDPOINTW                   L"SHAREDFAX"                                // Used by RPC - Same EndPoint as for BOS
#define FAX_RPC_ENDPOINT                    TEXT("SHAREDFAX")                           // Used by RPC - Same EndPoint as for BOS
#define FAX_CLIENT_CONSOLE_IMAGE_NAME       TEXT("FXSCLNT.exe")                         // Used by MMC
#define FAX_CONTEXT_HELP_FILE               TEXT("FXSCLNT.hlp")                         // Used by ClientConsole
#define FAX_CLIENT_HELP_FILE                TEXT("FXSCLNT.chm")                         // Used by ClientConsole
#define FAX_COVERPAGE_HELP_FILE             TEXT("FXSCOVER.chm")                        // Used by the cover page editor
#define FAX_ADMIN_HELP_FILE                 TEXT("FXSADMIN.chm")                        // Used by MMC
#define FAX_CLIENTS_SHARE_NAME              TEXT("FxsClients$")                         // Used by FxsUI.dll
#define FAX_COVER_PAGES_SHARE_NAME          TEXT("FxsSrvCp$")                           // Used by send wizard
#define ADAPTIVE_ANSWER_SECTION             TEXT("Adaptive Answer Modems")              // Used by the service
#define REGKEY_CLIENT_EXT                   TEXT("Software\\Microsoft\\Exchange\\Client\\Extensions")   // Used by setup
#define EXCHANGE_CLIENT_EXT_FILE            "%windir%\\system32\\fxsext32.dll"          // Used by setup
#define FAX_FILENAME_FAXPERF_INI            TEXT("FXSPERF.INI")                         // Used by setup
#define USE_SERVER_DEVICE                   MAXDWORD                                    // Used by the service - this line id value is reserved for internal use.
#define SHARED_FAX_SERVICE_SETUP_LOG_FILE   TEXT("XPFaxServiceSetupLog.txt")
#define SERVICE_ALWAYS_RUNS                 TEXT("/AlwaysRun")                          // Command line parameter to service to disable idle-activity suicide
#define SERVICE_DELAY_SUICIDE               TEXT("/DelaySuicide")                       // Command line parameter to service to delay idle-activity suicide
#define FAX_SERVER_EVENT_NAME               TEXT("Global\\FaxSvcRPCStarted-1ed23866-f90b-4ec5-b77e-36e8709422b6")   // Name of event that notifies service RPC is on.
                                                                                                                    // This event should be "Global" (see terminal services and named kernel objects)

#define FAX_MODEM_PROVIDER_NAME             TEXT("Windows Telephony Service Provider for Universal Modem Driver")

//
// Install types
//
#define FAX_INSTALL_NETWORK_CLIENT          0x00000001                                  // Used by the coverpage editor
#define FAX_INSTALL_SERVER                  0x00000002                                  // Used by the coverpage editor
#define FAX_INSTALL_WORKSTATION             0x00000004                                  // Used by the coverpage editor
#define FAX_INSTALL_REMOTE_ADMIN            0x00000008                                  // Used by the coverpage editor
//
// Product types
//
#define PRODUCT_TYPE_WINNT                  1                                           // Used by the utility library
#define PRODUCT_TYPE_SERVER                 2                                           // Used by the utility library
//
// Shared memory region name for faxui & faxxp32
//
#define FAX_ENVVAR_PRINT_FILE               TEXT("MS_FAX_PRINTFILE")
#define FAXXP_ATTACH_MUTEX_NAME             TEXT("MS_FAXXP_ATTACHMENT_MUTEX")
#define FAXXP_MEM_NAME                      TEXT("MS_FAXXP_ATTACHMENT_REGION")
#define FAXXP_MEM_MUTEX_NAME                TEXT("MS_FAXXP_ATTACHMENTREGION_MUTEX")
#define FAXXP_ATTACH_END_DOC_EVENT          TEXT("_END_DOC_EVENT")                      // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_ABORT_EVENT            TEXT("_ABORT_EVENT")                        // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_EVENT_NAME_LEN         (MAX_PATH+20)
//
// Fax dirs. These are hardcoded relative paths. We call into the shell to get the base path.
//
#define FAX_SHARE_DIR                       TEXT("Microsoft\\Windows NT\\MSFax")
#define FAX_RECEIVE_DIR                     FAX_SHARE_DIR TEXT("\\FaxReceive")          // Used by MS routing extension
#define FAX_QUEUE_DIR                       FAX_SHARE_DIR TEXT("\\Queue")               // Used by service

#define FAX_PREVIEW_TMP_DIR                 TEXT("FxsTmp")    // Created under %windir%\system32 with full access to everyone.
                                                              // Used for mapping of preview file in W2K and NT4 if
                                                              // Access to %windir%\system32 is denied for guest users.


/*****************************************************************************
**                                                                          **
**                     Registry keys, values, paths etc.                    **
**                                                                          **
*****************************************************************************/

//
// Fax Server Registry Root (relative to LOCAL_MACHINE or CURRENT_USER)
//
#define REGKEY_FAXSERVER_A              "Software\\Microsoft\\Fax"
#define REGKEY_FAXSERVER                TEXT(REGKEY_FAXSERVER_A)

#define REGKEY_CLIENT                   TEXT("Microsoft\\Fax")
#define CLIENT_ARCHIVE_KEY              TEXT("Archive")
#define CLIENT_ARCHIVE_MSGS_PER_CALL    TEXT("MessagesPerCall")
#define CLIENT_INBOX_VIEW               TEXT("InboxView")
#define CLIENT_SENT_ITEMS_VIEW          TEXT("SentItemsView")
#define CLIENT_INCOMING_VIEW            TEXT("IncomingView")
#define CLIENT_OUTBOX_VIEW              TEXT("OutboxView")
#define CLIENT_COVER_PAGES_VIEW         TEXT("CoverPagesView")
#define CLIENT_VIEW_COLUMNS             TEXT("Columns")
#define CLIENT_VIEW_COL_WIDTH           TEXT("Width")
#define CLIENT_VIEW_COL_SHOW            TEXT("Show")
#define CLIENT_VIEW_COL_ORDER           TEXT("Order")
#define CLIENT_VIEW_SORT_ASCENDING      TEXT("SortAscending")
#define CLIENT_VIEW_SORT_COLUMN         TEXT("SortColumn")
#define CLIENT_MAIN_FRAME               TEXT("MainFrame")
#define CLIENT_MAXIMIZED                TEXT("Maximized")
#define CLIENT_NORMAL_POS_TOP           TEXT("NormalPosTop")
#define CLIENT_NORMAL_POS_RIGHT         TEXT("NormalPosRight")
#define CLIENT_NORMAL_POS_BOTTOM        TEXT("NormalPosBottom")
#define CLIENT_NORMAL_POS_LEFT          TEXT("NormalPosLeft")
#define CLIENT_SPLITTER_POS             TEXT("SplitterPos")
#define CLIENT_CONFIRM_SEC              TEXT("Confirm")
#define CLIENT_CONFIRM_ITEM_DEL         TEXT("ItemDeletion")
#define CLIENT_CONFIRM_PRN_REMOVE       TEXT("FaxPrinterRemoval")
//
// Registry values stored under HKEY_CURRENT_USER
//
//
// User information is stored under Fax\UserInfo subkey
//
#define   REGVAL_FULLNAME                       TEXT("FullName")
#define   REGVAL_FAX_NUMBER                     TEXT("FaxNumber")
#define   REGVAL_MAILBOX                        TEXT("Mailbox")
#define   REGVAL_COMPANY                        TEXT("Company")
#define   REGVAL_TITLE                          TEXT("Title")
#define   REGVAL_ADDRESS                        TEXT("Address")
#define   REGVAL_CITY                           TEXT("City")
#define   REGVAL_STATE                          TEXT("State")
#define   REGVAL_ZIP                            TEXT("ZIP")
#define   REGVAL_COUNTRY                        TEXT("Country")
#define   REGVAL_DEPT                           TEXT("Department")
#define   REGVAL_OFFICE                         TEXT("Office")
#define   REGVAL_HOME_PHONE                     TEXT("HomePhone")
#define   REGVAL_OFFICE_PHONE                   TEXT("OfficePhone")
#define   REGVAL_BILLING_CODE                   TEXT("BillingCode")

#define   REGVAL_SEND_COVERPG                   TEXT("SendCoverPage")
#define   REGVAL_COVERPG                        TEXT("CoverPageFile")
#define   REGVAL_FAX_PRINTER                    TEXT("LastSelectedPrinter")
#define   REGVAL_LAST_COUNTRYID                 TEXT("LastCountryID")
#define   REGVAL_LAST_RECNAME                   TEXT("LastRecipientName")
#define   REGVAL_LAST_RECAREACODE               TEXT("LastRecipientAreaCode")
#define   REGVAL_LAST_RECNUMBER                 TEXT("LastRecipientNumber")
#define   REGVAL_USE_DIALING_RULES              TEXT("LastUseDialingRules")
#define   REGVAL_USE_OUTBOUND_ROUTING           TEXT("LastUseOutboundRouting")
#define   REGVAL_STRESS_INDEX                   TEXT("LastStressPrinterIndex")

#define   REGVAL_RECEIPT_NO_RECEIPT             TEXT("ReceiptNoRecipt")
#define   REGVAL_RECEIPT_GRP_PARENT             TEXT("ReceiptGroupParent")
#define   REGVAL_RECEIPT_MSGBOX                 TEXT("ReceiptMessageBox")
#define   REGVAL_RECEIPT_EMAIL                  TEXT("ReceiptEMail")
#define   REGVAL_RECEIPT_ADDRESS                TEXT("ReceiptAddress")
#define   REGVAL_RECEIPT_ATTACH_FAX             TEXT("ReceiptAttachFax")
//
// Status UI configuration values
//
#define   REGVAL_DEVICE_TO_MONITOR              TEXT("DeviceToMonitor") // device ID for monitoring
#define   REGVAL_MONITOR_ON_SEND                TEXT("MonitorOnSend")
#define   REGVAL_MONITOR_ON_RECEIVE             TEXT("MonitorOnReceive")
#define   REGVAL_NOTIFY_PROGRESS                TEXT("NotifyProgress")
#define   REGVAL_NOTIFY_IN_COMPLETE             TEXT("NotifyIncomingCompletion")
#define   REGVAL_NOTIFY_OUT_COMPLETE            TEXT("NotifyOutgoingCompletion")

#define   REGVAL_SOUND_ON_RING                  TEXT("SoundOnRing")
#define   REGVAL_SOUND_ON_RECEIVE               TEXT("SoundOnReceive")
#define   REGVAL_SOUND_ON_SENT                  TEXT("SoundOnSent")
#define   REGVAL_SOUND_ON_ERROR                 TEXT("SoundOnError")

#define   REGVAL_ALWAYS_ON_TOP                  TEXT("AlwaysOnTop")
#define   REGVAL_TASKBAR                        TEXT("OnTaskBar")
#define   REGVAL_VISUAL_NOTIFICATION            TEXT("VisualNotification")
#define   REGVAL_SOUND_NOTIFICATION             TEXT("SoundNotification")
#define   REGVAL_ANSWER_NEXTCALL                TEXT("AnswerNextCall")
#define   REGVAL_ENABLE_MANUAL_ANSWER           TEXT("EnableManualAnswer")

#define   REGVAL_BALLOON_RECEIVE                TEXT("ReceiveNotification")
#define   REGVAL_BALLOON_SENDERROR              TEXT("SendErrorNotification")
#define   REGVAL_BALLOON_RINGING                TEXT("RingingNotification")
#define   REGVAL_BALLOON_TIMEOUT                TEXT("BalloonTimeOut")

//
// Fax status monitor and fax notification bar icon contants:
//
#define FAXSTAT_WINCLASS                        TEXT("FaxMonWinClass{3FD224BA-8556-47fb-B260-3E451BAE2793}")    // Window class for fax notification bar messages
#define FAX_SYS_TRAY_DLL                        TEXT("fxsst.dll")   // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                         "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                             // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC               "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();                       // FaxMonitorShutdown type
#define WM_FAXSTAT_CONTROLPANEL                 (WM_USER + 201)     // Fax notification bar configuration has changed
#define WM_FAXSTAT_OPEN_MONITOR                 (WM_USER + 211)     // User explicitly asks for fax status monitor
#define WM_FAXSTAT_INBOX_VIEWED                 (WM_USER + 212)     // Message viewed or deleted in the fax client console's inbox folder
#define WM_FAXSTAT_OUTBOX_VIEWED                (WM_USER + 213)     // Message in error was restarted or deleted in the fax client console's outbox folder
#define WM_FAXSTAT_RECEIVE_NOW                  (WM_USER + 214)     // Start receiving now
#define WM_FAXSTAT_PRINTER_PROPERTY             (WM_USER + 215)     // Open Fax Printer Property Sheet. WPARAM is an initiall page number

//
// Setup information is stored under Fax\Setup subkey
//
#define REGKEY_FAX_SETUP                        REGKEY_FAXSERVER TEXT("\\Setup")
#define REGKEY_FAX_SETUP_SUBKEY                 TEXT("Setup")

#define   REGVAL_CP_EDITOR                      TEXT("CoverPageEditor")
#define   REGVAL_CP_LOCATION                    TEXT("CoverPageDir")
#define   REGVAL_FAX_PROFILE                    TEXT("FaxProfileName")
#define   REGVAL_FAXINSTALLED                   TEXT("Installed")
#define   REGVAL_DONT_UNATTEND_INSTALL          TEXT("DenyUnattendInstall")
#define   REGVAL_FAXINSTALL_TYPE                TEXT("InstallType")
#define   REGVAL_FAXINSTALLED_PLATFORMS         TEXT("InstalledPlatforms")
#define   REGVAL_CFGWZRD_USER_INFO              TEXT("CfgWzdrUserInfo")
#define   REGVAL_CPE_CONVERT                    TEXT("WereCpesConverted")
#define   REGVAL_CFGWZRD_DEVICE                 TEXT("CfgWzdrDevice")
#define   REGVAL_SERVER_CP_LOCATION             TEXT("ServerCoverPageDir")
#define   REGVAL_IMPORT_INFO                    TEXT("ImportInfoDisplayed")
#define   REGVAL_INSTALLED_COMPONENTS           TEXT("InstalledComponents")

#define   REGVAL_W2K_SENT_ITEMS                 TEXT("W2K_SentItems")
#define   REGVAL_W2K_INBOX                      TEXT("W2K_Inbox")

#define DEFAULT_COVERPAGE_EDITOR                FAX_COVER_IMAGE_NAME    // Used by print\faxprint\lib\registry.c
#define DEFAULT_COVERPAGE_DIR                   TEXT("%systemroot%\\Fax\\CoverPg")

#define REGKEY_INSTALLLOCATION                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_SOURCEPATH                       TEXT("SourcePath")
#define REGVAL_DEFAULT_TSID                     TEXT("Fax")
#define REGVAL_DEFAULT_CSID                     TEXT("Fax")

//
// Per-user devmode information is stored under Fax\Devmode subkey
//
#define REGKEY_FAX_DEVMODE                      REGKEY_FAXSERVER TEXT("\\Devmode")
//
// Registry values stored under HKEY_LOCAL_MACHINE
//

//
// Server registry values
// stored under REGKEY_FAXSERVER
//
#define REGVAL_DBGLEVEL                         TEXT("DebugLevel")
#define REGVAL_DBGLEVEL_EX                      TEXT("DebugLevelEx")
#define REGVAL_DBGFORMAT_EX                     TEXT("DebugFormatEx")
#define REGVAL_DBGCONTEXT_EX                    TEXT("DebugContextEx")
#define REGVAL_DBG_SKU                          TEXT("DebugSKU")
#define FAX_SVC_EVENT                           TEXT("Microsoft Fax")
#define REGKEY_EVENTLOG                         TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\") FAX_SVC_EVENT

#define   REGVAL_EVENTMSGFILE                   TEXT("EventMessageFile")
#define   REGVAL_CATEGORYMSGFILE                TEXT("CategoryMessageFile")
#define   REGVAL_CATEGORYCOUNT                  TEXT("CategoryCount")
#define   REGVAL_TYPESSUPPORTED                 TEXT("TypesSupported")

#define REGKEY_SOFTWARE                         REGKEY_FAXSERVER

#define   REGVAL_RETRIES                        TEXT("Retries")
#define   REGVAL_RETRYDELAY                     TEXT("Retry Delay")
#define   REGVAL_MANUAL_ANSWER_DEVICE           TEXT("ManualAnswerDevice")
#define   REGVAL_DIRTYDAYS                      TEXT("Dirty Days")
#define   REGVAL_BRANDING                       TEXT("Branding")
#define   REGVAL_USE_DEVICE_TSID                TEXT("UseDeviceTsid")
#define   REGVAL_SERVERCP                       TEXT("ServerCoverPageOnly")
#define   REGVAL_STARTCHEAP                     TEXT("StartCheapTime")
#define   REGVAL_STOPCHEAP                      TEXT("StopCheapTime")
#define   REGVAL_QUEUE_STATE                    TEXT("QueueState")
#define   REGVAL_JOB_NUMBER                     TEXT("NextJobNumber")
#define   REGVAL_SCANNER_SUPPORT                TEXT("ScannerSupport")
#define   REGVAL_MISSING_DEVICE_LIFETIME        TEXT("MissingDeviceLifetime")
#define   REGVAL_MAX_LINE_CLOSE_TIME            TEXT("MaxLineCloseTime")
//
// 31 days * 24 hours * 60 minutes * 60 seconds * 1000000 microseconds * 10 (100 ns is one unit)
//
#define   DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME 26784000000000

#define   DEFAULT_REGVAL_RETRIES                3
#define   DEFAULT_REGVAL_RETRYDELAY             10
#define   DEFAULT_REGVAL_DIRTYDAYS              30
#define   DEFAULT_REGVAL_BRANDING               1
#define   DEFAULT_REGVAL_USEDEVICETSID          1
#define   DEFAULT_REGVAL_SERVERCP               0
#define   DEFAULT_REGVAL_STARTCHEAP             MAKELONG(20,0)
#define   DEFAULT_REGVAL_STOPCHEAP              MAKELONG(7,0)
#define   DEFAULT_REGVAL_QUEUE_STATE            0
#define   DEFAULT_REGVAL_JOB_NUMBER             1

#define   REGKEY_DEVICE_PROVIDERS               TEXT("Device Providers")
#define     REGVAL_FRIENDLY_NAME                TEXT("FriendlyName")
#define     REGVAL_IMAGE_NAME                   TEXT("ImageName")
#define     REGVAL_PROVIDER_NAME                TEXT("ProviderName")
#define     REGVAL_PROVIDER_CAPABILITIES        TEXT("Capabilities")
#define     REGVAL_PROVIDER_GUID                TEXT("GUID")
#define     REGVAL_PROVIDER_API_VERSION         TEXT("APIVersion")
//
// The following value is an incremental prefix for device ids assigned to FSPs
//
#define     REGVAL_PROVIDER_DEVICE_ID_PREFIX    TEXT("DeviceIdPerfix")
//
// The following value is the base device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE   DWORD(0x20000)
//
// The following value is the base for our internal unique fax ids
//
#define     DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE        DWORD(0x10000)
//
// The following value is the increase step of device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_STEP   DWORD(0x10000)
//
// How device ids are allocated:
// -----------------------------
// Fax unique devices (allocated by the server), VFSP devices, and EVFSP devices all share
// the same device id space (32-bit = 4GB of ids).
//
// Notice: TAPI permanent line ids (used by FSPs / EFSPs) are not in this space.
//
// Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
//     Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
//     and leave segments allocation to a PM effort here.
//
// Range [DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE ... DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE-1] :
//     Used by the fax server for the unique device ids of TAPI devices discovered by the server.
//
// Range [DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE ... MAXDWORD] : Used for VEFSPs.
//     Luckily, we can tell VEFSPs the base of the ids they give their devices.
//     It is the server's responsibility to segment this range for each VEFSP.
//     The size of each segment is DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_STEP.
//
#define   REGKEY_RECEIPTS_CONFIG                TEXT("Receipts")    // Key of receipts configuration
#define     REGVAL_RECEIPTS_TYPE                TEXT("Type")        // Receipts supported
#define     REGVAL_RECEIPTS_SERVER              TEXT("Server")      // SMTP Server's name
#define     REGVAL_RECEIPTS_PORT                TEXT("Port")        // SMTP Server's port
#define     REGVAL_RECEIPTS_FROM                TEXT("From")        // SMTP sender address
#define     REGVAL_RECEIPTS_USER                TEXT("User")        // SMTP user name
#define     REGVAL_RECEIPTS_PASSWORD            TEXT("Password")    // SMTP password
#define     REGVAL_RECEIPTS_SMTP_AUTH_TYPE      TEXT("SMTPAuth")    // SMTP authentication type
#define     REGVAL_ISFOR_MSROUTE                TEXT("UseForMsRoute")  // TRUE if to use for MS route through e-mail method

#define     DEFAULT_REGVAL_SMTP_PORT            25                  // Default SMTP port number

#define   REGKEY_ARCHIVE_SENTITEMS_CONFIG       TEXT("SentItems")// Key of SentItems archive configuration
#define   REGKEY_ARCHIVE_INBOX_CONFIG           TEXT("Inbox")    // Key of Inbox archive configuration
#define     REGVAL_ARCHIVE_USE                  TEXT("Use")      // Archive?
#define     REGVAL_ARCHIVE_FOLDER               TEXT("Folder")   // Archive location
#define     REGVAL_ARCHIVE_SIZE_QUOTA_WARNING   TEXT("SizeQuotaWarn") // Warn on size excess?
#define     REGVAL_ARCHIVE_HIGH_WATERMARK       TEXT("HighWatermark") // Warning high watermark
#define     REGVAL_ARCHIVE_LOW_WATERMARK        TEXT("LowWatermark")  // Warning low watermark
#define     REGVAL_ARCHIVE_AGE_LIMIT            TEXT("AgeLimit") // Archive age limit

#define     DEFAULT_REGVAL_ARCHIVE_USE          0        // Don't use archive by default
#define     DEFAULT_REGVAL_ARCHIVE_FOLDER       TEXT("") // Default location of archive
#define     DEFAULT_REGVAL_SIZE_QUOTA_WARNING   1        // Warn on size by default
#define     DEFAULT_REGVAL_HIGH_WATERMARK       100      // High watermark default
#define     DEFAULT_REGVAL_LOW_WATERMARK        95       // Low watermark default
#define     DEFAULT_REGVAL_AGE_LIMIT            60       // Default archive age limit

#define   REGKEY_ACTIVITY_LOG_CONFIG            TEXT("ActivityLogging")    // Key of Activity Logging configuration
#define     REGVAL_ACTIVITY_LOG_DB              TEXT("DBFile")             // Database file
#define     REGVAL_ACTIVITY_LOG_IN              TEXT("LogIncoming")        // Log incoming faxes?
#define     REGVAL_ACTIVITY_LOG_OUT             TEXT("LogOutgoing")        // Log outgoing faxes?

#define   REGKEY_OUTBOUND_ROUTING                   TEXT("Outbound Routing")   // Outbound routing key
#define     REGKEY_OUTBOUND_ROUTING_GROUPS          TEXT("Groups")             // Outbound routing groups key
#define         REGVAL_ROUTING_GROUP_DEVICES        TEXT("Devices")            // List of all group's devices
#define     REGKEY_OUTBOUND_ROUTING_RULES           TEXT("Rules")              // Outbound routing rules key
#define         REGVAL_ROUTING_RULE_COUNTRY_CODE    TEXT("CountryCode")        // Outbound routing rule country code
#define         REGVAL_ROUTING_RULE_AREA_CODE       TEXT("AreaCode")           // Outbound routing rule area code
#define         REGVAL_ROUTING_RULE_GROUP_NAME      TEXT("GroupName")          // Outbound routing rule dest group name
#define         REGVAL_ROUTING_RULE_DEVICE_ID       TEXT("DeviceID")           // Outbound routing rule dest device ID
#define         REGVAL_ROUTING_RULE_USE_GROUP       TEXT("UseGroup")           // Flag inidicating to use group destination

#define   REGKEY_ROUTING_EXTENSIONS             TEXT("Routing Extensions")
#define     REGKEY_ROUTING_METHODS              TEXT("Routing Methods")
#define         REGVAL_FUNCTION_NAME            TEXT("Function Name")
#define         REGVAL_GUID                     TEXT("Guid")
#define         REGVAL_ROUTING_PRIORITY         TEXT("Priority")

#define   REGKEY_UNASSOC_EXTENSION_DATA         TEXT("UnassociatedExtensionData")
#define   REGKEY_DEVICES                        TEXT("Devices")
#define     REGKEY_FAXSVC_DEVICE_GUID           TEXT("{F10A5326-0261-4715-B367-2970427BBD99}")
#define       REGVAL_DEVICE_NAME                TEXT("Device Name")
#define       REGVAL_PROVIDER                   TEXT("Provider Name")
#define       REGVAL_PERMANENT_LINEID           TEXT("Permanent Lineid")
#define       REGVAL_TAPI_PERMANENT_LINEID      TEXT("TAPI Permanent Lineid")

#define       REGVAL_FLAGS                      TEXT("Flags")
#define       REGVAL_RINGS                      TEXT("Rings")
#define       REGVAL_ROUTING_CSID               TEXT("CSID")
#define       REGVAL_ROUTING_TSID               TEXT("TSID")
#define       REGVAL_DEVICE_DESCRIPTION         TEXT("Description")
#define       REGVAL_LAST_DETECTED_TIME         TEXT("LastDetected")
#define       REGVAL_MANUAL_ANSWER              TEXT("ManualAnswer")

#define       REGVAL_LAST_UNIQUE_LINE_ID        TEXT("LastUniqueLineId")

#define   REGKEY_LOGGING                        TEXT("Logging")
#define     REGVAL_CATEGORY_NAME                TEXT("Name")
#define     REGVAL_CATEGORY_LEVEL               TEXT("Level")
#define     REGVAL_CATEGORY_NUMBER              TEXT("Number")

#define   REGKEY_DEVICES_CACHE                  TEXT("Devices Cache")
#define     REGKEY_TAPI_DATA                    TEXT("TAPI Data")

#define REGKEY_FAX_LOGGING                      REGKEY_FAXSERVER TEXT("\\Logging")
#define REGKEY_FAX_INBOX                        REGKEY_FAXSERVER TEXT("\\Inbox")
#define REGKEY_FAX_SENTITEMS                    REGKEY_FAXSERVER TEXT("\\SentItems")
#define REGKEY_FAX_DEVICES                      REGKEY_FAXSERVER TEXT("\\Devices")
#define REGKEY_FAX_DEVICES_CACHE                REGKEY_FAXSERVER TEXT("\\Devices Cache")
#define REGKEY_TAPIDEVICES                      REGKEY_FAXSERVER TEXT("\\TAPIDevices")
#define REGKEY_DEVICE_PROVIDER_KEY              REGKEY_FAXSERVER TEXT("\\Device Providers")
#define REGKEY_ROUTING_EXTENSION_KEY            REGKEY_FAXSERVER TEXT("\\Routing Extensions")
#define REGKEY_USERINFO                         REGKEY_FAXSERVER TEXT("\\UserInfo")
#define REGKEY_FAX_USERINFO                     REGKEY_USERINFO
#define REGKEY_FAX_OUTBOUND_ROUTING             REGKEY_FAXSERVER TEXT("\\Outbound Routing")
#define REGKEY_FAX_OUTBOUND_ROUTING_GROUPS      REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\Groups")
#define REGKEY_FAX_OUTBOUND_ROUTING_RULES       REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\Rules")

#define REGKEY_FAX_SETUP_ORIG                   REGKEY_FAXSERVER TEXT("\\Setup\\Original Setup Data")
//
// device provider reg values
//
#define REGKEY_MODEM_PROVIDER                   TEXT("Microsoft Modem Device Provider")
#define   REGVAL_T30_PROVIDER_GUID_STRING       TEXT("{2172FD8F-11F6-11d3-90BF-006094EB630B}")
//
// MSFT standard routing methods
//
#define REGKEY_ROUTING_METHOD_EMAIL             TEXT("Email")
#define   REGVAL_RM_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_FOLDER            TEXT("Folder")
#define   REGVAL_RM_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_PRINTING          TEXT("Printing")
#define   REGVAL_RM_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
//
// GUID of routing methods usage flags - used by the Microsoft Fax Routing Extension DLL:
//
#define   REGVAL_RM_FLAGS_GUID                  TEXT("{aacc65ec-0091-40d6-a6f3-a2ed6057e1fa}")
//
// Routing mask bits
//
#define LR_PRINT                                0x00000001
#define LR_STORE                                0x00000002
#define LR_INBOX                                0x00000004
#define LR_EMAIL                                0x00000008
//
// Routing extension reg values
//
#define REGKEY_ROUTING_EXTENSION                TEXT("Microsoft Routing Extension")
//
// Performance key/values
//
#define REGKEY_FAXPERF                          TEXT("SYSTEM\\CurrentControlSet\\Services\\") FAX_SERVICE_NAME TEXT("\\Performance")
#define   REGVAL_OPEN                           TEXT("Open")
#define     REGVAL_OPEN_DATA                    TEXT("OpenFaxPerformanceData")
#define   REGVAL_CLOSE                          TEXT("Close")
#define     REGVAL_CLOSE_DATA                   TEXT("CloseFaxPerformanceData")
#define   REGVAL_COLLECT                        TEXT("Collect")
#define     REGVAL_COLLECT_DATA                 TEXT("CollectFaxPerformanceData")
#define   REGVAL_LIBRARY                        TEXT("Library")
#define     REGVAL_LIBRARY_DATA                 TEXT("%systemroot%\\system32\\fxsperf.dll")
//
// Security descriptors
//
#define REGKEY_FAX_SECURITY                     REGKEY_FAXSERVER TEXT("\\Security")
#define   REGVAL_DESCRIPTOR                     TEXT("Descriptor")
//
// AppEvents
//
#define REGKEY_FAXSTAT                          TEXT("AppEvents\\Schemes\\Apps\\systray")
#define REGKEY_EVENT_LABEL_IN                   TEXT("AppEvents\\EventLabels\\Incoming-Fax")
#define REGKEY_SCHEMES_DEFAULT_IN               TEXT("AppEvents\\Schemes\\Apps\\systray\\Incoming-Fax\\.Default")
#define REGKEY_SCHEMES_CURRENT_IN               TEXT("AppEvents\\Schemes\\Apps\\systray\\Incoming-Fax\\.Current")
#define REGKEY_EVENT_LABEL_OUT                  TEXT("AppEvents\\EventLabels\\Outgoing-Fax")
#define REGKEY_SCHEMES_DEFAULT_OUT              TEXT("AppEvents\\Schemes\\Apps\\systray\\Outgoing-Fax\\.Default")
#define REGKEY_SCHEMES_CURRENT_OUT              TEXT("AppEvents\\Schemes\\Apps\\systray\\Outgoing-Fax\\.Current")

//
// default mail client
//
#define  REGKEY_MAIL_CLIENT     TEXT("SOFTWARE\\Clients\\Mail")
#define  REGVAL_MS_OUTLOOK      TEXT("Microsoft Outlook")

//
// Combined translated strings from the wizard to the service
// Format is "{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED<dialable string>{11d0ecca-4072-4c7b-9af1-541d9778375f}<displayable string>"
//
#define COMBINED_PREFIX                         TEXT("{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED")
#define COMBINED_SUFFIX                         TEXT("{11d0ecca-4072-4c7b-9af1-541d9778375f}")
#define COMBINED_TRANSLATED_STRING_FORMAT       COMBINED_PREFIX TEXT("%s") COMBINED_SUFFIX TEXT("%s")
#define COMBINED_TRANSLATED_STRING_EXTRA_LEN    (_tcslen(COMBINED_TRANSLATED_STRING_FORMAT) - 4)

//
// These prefixes are used by all temp preview TIFF files (generated by the client console and the fax send wizard)
//
#define CONSOLE_PREVIEW_TIFF_PREFIX                     TEXT("MSFaxConsoleTempPreview-#")
#define WIZARD_PREVIEW_TIFF_PREFIX                      TEXT("MSFaxWizardTempPreview-#")

#define FAX_ADDERSS_VALID_CHARACTERS                    TEXT("0123456789 -|^!#$*,?@ABCbcdDPTWdptw")

//
// Client console command line parameters.
// All parameters are case insensitive.
//
#define CONSOLE_CMD_FLAG_STR_FOLDER                     TEXT("folder")          // Sets initial startup folder. Usage: "fxsclnt.exe /folder <folder>"
#define CONSOLE_CMD_PRM_STR_OUTBOX                          TEXT("outbox")          // Outbox startup folder. Usage: "fxsclnt.exe /folder outbox"
#define CONSOLE_CMD_PRM_STR_INCOMING                        TEXT("incoming")        // Incoming startup folder. Usage: "fxsclnt.exe /folder incoming"
#define CONSOLE_CMD_PRM_STR_INBOX                           TEXT("inbox")           // Inbox startup folder. Usage: "fxsclnt.exe /folder inbox". This is the default
#define CONSOLE_CMD_PRM_STR_SENT_ITEMS                      TEXT("sent_items")      // sent items startup folder. Usage: "fxsclnt.exe /folder sent_items"

#define CONSOLE_CMD_FLAG_STR_MESSAGE_ID                 TEXT("MessageId")       // Select a message in the startup folder. Usage: "fxsclnt.exe /MessageId 0x0201c0d62f36ec0b"
#define CONSOLE_CMD_FLAG_STR_NEW                        TEXT("New")             // Force a new instance. Usage: "fxsclnt.exe /new"

#endif  // !_FAXREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\wiadevdp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADEVDP.H
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/15/1999
 *
 *  DESCRIPTION: Private Device Dialog Declarations
 *
 *******************************************************************************/
#ifndef _WIADEVDP_H_INCLUDED
#define _WIADEVDP_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

//
// Private flags for WIA enumeration
//
//      DEV_MAN_ENUM_TYPE_REMOTE    Will enumerate local AND remote
//      DEV_MAN_ENUM_TYPE_VOL       Will enumerate our volume devices
//      DEV_MAN_ENUM_TYPE_INACTIVE  Will enumerate inactive devices (e.g. USB 
//                                  device thaat is unplugged)
//      DEV_MAN_ENUM_TYPE_STI       Will enumerate STI only devices too
//      DEV_MAN_ENUM_TYPE_ALL       Will enumerate all devices
//
#define DEV_MAN_ENUM_TYPE_REMOTE    0x00000001
#define DEV_MAN_ENUM_TYPE_VOL       0x00000002
#define DEV_MAN_ENUM_TYPE_INACTIVE  0x00000004
#define DEV_MAN_ENUM_TYPE_STI       0x00000008
#define DEV_MAN_ENUM_TYPE_ALL       0x0000000F

DEFINE_GUID( CLSID_WiaDefaultUi, 0xD1621129, 0x45C4, 0x41AD, 0xA1, 0xD1, 0xAF, 0x7E, 0xAF, 0xAB, 0xEE, 0xDC );

//
// {F1ABE2B5-C073-4dba-B6EB-FD7A5111DD8F}
//
DEFINE_GUID( CLSID_WiaAutoPlayDropTarget, 0xf1abe2b5, 0xc073, 0x4dba, 0xb6, 0xeb, 0xfd, 0x7a, 0x51, 0x11, 0xdd, 0x8f );

//
// Private interface used to call system ui
//
#undef  INTERFACE
#define INTERFACE IWiaGetImageDlg
DECLARE_INTERFACE_(IWiaGetImageDlg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaGetImageDlg methods ***
    STDMETHOD(SelectDeviceDlg) (THIS_
        HWND         hwndParent,
        BSTR         bstrInitialDeviceId,
        LONG         lDeviceType,
        LONG         lFlags,
        BSTR        *pbstrDeviceID,
        IWiaItem   **ppWiaItemRoot );

    STDMETHOD(GetImageDlg)( THIS_
        IWiaDevMgr  *pWiaDevMgr,
        HWND         hwndParent,
        LONG         lDeviceType,
        LONG         lFlags,
        LONG         lIntent,
        IWiaItem    *pItemRoot,
        BSTR         bstrFilename,
        GUID        *pguidFormat );
};

DEFINE_GUID( IID_IWiaGetImageDlg, 0x4F67AD3C, 0x19EA, 0x4CE9, 0x80, 0xE2, 0x3A, 0xDE, 0x50, 0xD5, 0x02, 0xA2 );

//
// Hide various controls
//
#define WIA_PROGRESSDLG_NO_PROGRESS              0x00000001
#define WIA_PROGRESSDLG_NO_CANCEL                0x00000002
#define WIA_PROGRESSDLG_NO_ANIM                  0x00000004
#define WIA_PROGRESSDLG_NO_TITLE                 0x00000008

//
// Animation flags
//
#define WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE 0x00010000
#define WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE  0x00020000
#define WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE   0x00040000
#define WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE     0x00080000
#define WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE      0x00100000
#define WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE       0x00200000
#define WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE 0x00400000

#undef  INTERFACE
#define INTERFACE IWiaProgressDialog
DECLARE_INTERFACE_(IWiaProgressDialog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IWiaProgressDialog methods ***
    STDMETHOD(Create)(THIS_ HWND hwndParent, LONG lFlags );
    STDMETHOD(Show)(THIS);
    STDMETHOD(Hide)(THIS);
    STDMETHOD(Cancelled)( THIS_ BOOL *pbCancelled );
    STDMETHOD(SetTitle)( THIS_ LPCWSTR pszMessage );
    STDMETHOD(SetMessage)( THIS_ LPCWSTR pszTitle );
    STDMETHOD(SetPercentComplete)( THIS_ UINT nPercent );
    STDMETHOD(Destroy)(THIS);
};

// {F740718A-E460-4b05-83E8-C5D221C772E5}
DEFINE_GUID( IID_IWiaProgressDialog, 0xF740718A, 0xE460, 0x4B05, 0x83, 0xE8, 0xC5, 0xD2, 0x21, 0xC7, 0x72, 0xE5 );


// {8144B6F5-20A8-444a-B8EE-19DF0BB84BDB}
DEFINE_GUID( CLSID_StiEventHandler, 0x8144b6f5, 0x20a8, 0x444a, 0xb8, 0xee, 0x19, 0xdf, 0xb, 0xb8, 0x4b, 0xdb );


#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVDP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\prwiziid.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       prwiziid.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        12/15/00
 *
 *  DESCRIPTION: Define clsid/iids for this project
 *
 *****************************************************************************/

#ifndef _PHOTO_PRINT_WIZARD_IIDS_H_
#define _PHOTO_PRINT_WIZARD_IIDS_H_


//CLSID_PrintPhotoshDropTarget  {60fd46de-f830-4894-a628-6fa81bc0190d}
DEFINE_GUID(CLSID_PrintPhotosDropTarget, 0x60fd46de, 0xf830, 0x4894, 0xa6, 0x28, 0x6f, 0xa8, 0x1b, 0xc0, 0x19, 0x0d);


#undef INTERFACE
#define INTERFACE IPrintPhotosWizardSetInfo
//
// IPrintPhotosWizardSetInfo is meant as a way to get information
// to the wizard from outside objects/classes.  Primarily, we use
// this as a way to transfer a dataobject to the wizard that holds
// all of the items we want to print.
//
DECLARE_INTERFACE_(IPrintPhotosWizardSetInfo, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IPrintPhotosWizardSetInfo methods
    STDMETHOD(SetFileListDataObject) (THIS_ IN IDataObject * pdo);
    STDMETHOD(SetFileListArray) (THIS_ IN LPITEMIDLIST *aidl, IN int cItems, IN int iSelectedItem);
    STDMETHOD(RunWizard) (THIS_ VOID);
};

typedef HRESULT (*LPFNPPWPRINTTO)(LPCMINVOKECOMMANDINFO pCMI,IDataObject * pdtobj);
#define PHOTO_PRINT_WIZARD_PRINTTO_ENTRY "UsePPWForPrintTo"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\net\inc\xstypes.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    XsTypes.h

Abstract:

    Structure and type declarations for XACTSRV.

Author:

    David Treadwell (davidtr) 09-Jan-1991

Revision History:

--*/

#ifndef _XSTYPES_
#define _XSTYPES_

//
// This structure is the same as in the server file srvblock.h.  The server
// passes it to XACTSRV via shared memory, and XACTSRV uses it to make the
// necessary API call(s) and receive any response data.  XACTSRV should
// not modify any fields in this structure except the count fields;
// changing other fields could cause an access violation in the server.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE EXCEPT TO MIRROR THE CORRESPONDING *
// * STRUCTURE IN ntos\srv\srvblock.h!                               *
// *                                                                 *
// *******************************************************************
//

typedef struct _TRANSACTION {

    DWORD BlockHeader[2];

#if SRVDBG2
    DWORD ReferenceHistory[4];
#endif

    LPVOID NonpagedHeader;

    LPVOID Connection;
    LPVOID Session;
    LPVOID TreeConnect;

    LIST_ENTRY ConnectionListEntry;

    UNICODE_STRING TransactionName;

    DWORD StartTime;
    DWORD Timeout;
    DWORD cMaxBufferSize;

    LPWORD InSetup;
    LPWORD OutSetup;
    LPBYTE InParameters;
    LPBYTE OutParameters;
    LPBYTE InData;
    LPBYTE OutData;

    DWORD SetupCount;
    DWORD MaxSetupCount;
    DWORD ParameterCount;
    DWORD TotalParameterCount;
    DWORD MaxParameterCount;
    DWORD DataCount;
    DWORD TotalDataCount;
    DWORD MaxDataCount;

    WORD Category;
    WORD Function;

    BOOLEAN InputBufferCopied;
    BOOLEAN OutputBufferCopied;

    WORD Flags;

    WORD Tid;
    WORD Pid;
    WORD Uid;
    WORD OtherInfo;

    HANDLE FileHandle;
    PVOID FileObject;

    DWORD ParameterDisplacement;
    DWORD DataDisplacement;

    BOOLEAN PipeRequest;
    BOOLEAN RemoteApiRequest;

    BOOLEAN Inserted;
    BOOLEAN MultipieceIpxSend;

} TRANSACTION, *PTRANSACTION, *LPTRANSACTION;

//
// The header included in all parameter structures passed to API handlers.
// The actual parameter structure follows.
//

typedef struct _XS_PARAMETER_HEADER {

    WORD Status;
    WORD Converter;
    LPWSTR ClientMachineName;
    LPWSTR ClientTransportName;
    PUCHAR ServerName;              // points to NETBIOS_NAME_LEN array
    PUCHAR EncryptionKey;
    DWORD Flags;
} XS_PARAMETER_HEADER, *PXS_PARAMETER_HEADER, *LPXS_PARAMETER_HEADER;

//
// The input parameters taken by all API handler routines.
//

#define API_HANDLER_PARAMETERS      \
    IN PXS_PARAMETER_HEADER Header, \
    IN PVOID Parameters,            \
    IN LPDESC StructureDesc,         \
    IN LPDESC AuxStructureDesc OPTIONAL
//
// Routine declaration for API processing routines.
//

typedef
NTSTATUS
(*PXACTSRV_API_HANDLER) (
    API_HANDLER_PARAMETERS
    );

typedef
NET_API_STATUS
(*PXACTSRV_ENUM_VERIFY_FUNCTION) (
    NET_API_STATUS ConvertStatus,
    LPBYTE ConvertedEntry,
    LPBYTE BaseAddress
    );

#define API_HANDLER_PARAMETERS_REFERENCE       \
    UNREFERENCED_PARAMETER( Header );          \
    UNREFERENCED_PARAMETER( Parameters );      \
    UNREFERENCED_PARAMETER( StructureDesc );   \
    UNREFERENCED_PARAMETER( AuxStructureDesc )

#endif // ndef _XSTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\splapip.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    SplApiP.h

Abstract:

    Header file for Private Print APIs
    For use in stress

Author:

    Matthew Felton (MattFe) 4-Mar-1994

Revision History:

--*/
#ifndef SPLAPIP_H_
#define SPLAPIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "lmon.h"

// Internal Used to report Stress test results

#define STRESSINFOLEVEL 0

//  W A R N I N G
//
//  Do not alter the size of this structure it will break NT interop with older releases if you do.

typedef struct _PRINTER_INFO_STRESSA {
    LPSTR   pPrinterName;           // Printer Name locally "Printername" remotely "\\servername\printername"
    LPSTR   pServerName;            // Server Name
    DWORD   cJobs;                  // Number of Jobs currently in Print Queue
    DWORD   cTotalJobs;             // Total Number of Jobs spooled
    DWORD   cTotalBytes;            // Total Bytes Printed (LOW DWORD)
    SYSTEMTIME stUpTime;            // Time printed data structure crated UTC
    DWORD   MaxcRef;                // Maximum number of cRef
    DWORD   cTotalPagesPrinted;     // Total number of pages printed
    DWORD   dwGetVersion;           // OS version
    DWORD   fFreeBuild;             // TRUE for free build
    DWORD   cSpooling;              // Number of jobs actively spooling
    DWORD   cMaxSpooling;           // Maximum number of cSpooling
    DWORD   cRef;                   // Printer object reference count (opened)
    DWORD   cErrorOutOfPaper;       // Total Number of Out Of Paper Errors
    DWORD   cErrorNotReady;         // Total Number of Error Not Ready
    DWORD   cJobError;              // Total number of Job Errors
    DWORD   dwNumberOfProcessors;   // Number of Processors on computer
    DWORD   dwProcessorType;        // Processor Type of computer
    DWORD   dwHighPartTotalBytes;   // Total Bytes Printed (HIGH DWORD)
    DWORD   cChangeID;              // Count of Changes to Printer Config
    DWORD   dwLastError;            // Last Error
    DWORD   Status;                 // Current Printer Status
    DWORD   cEnumerateNetworkPrinters; // Count How Many Times Browse List Requested
    DWORD   cAddNetPrinters;        // Count of NetPrinters Added ( Browser )
    WORD    wProcessorArchitecture; // Processor Architecture of computer
    WORD    wProcessorLevel;        // Processor Level of computer
    DWORD   cRefIC;                 // Count of open IC handles
    DWORD   dwReserved2;            // Reserved for Future Use
    DWORD   dwReserved3;

} PRINTER_INFO_STRESSA, *PPRINTER_INFO_STRESSA, *LPPRINTER_INFO_STRESSA;

typedef struct _PRINTER_INFO_STRESSW {
    LPWSTR  pPrinterName;           // Printer Name locally "Printername" remotely "\\servername\printername"
    LPWSTR  pServerName;            // Server Name
    DWORD   cJobs;                  // Number of Jobs currently in Print Queue
    DWORD   cTotalJobs;             // Total Number of Jobs spooled
    DWORD   cTotalBytes;            // Total Bytes Printed (LOW DWORD)
    SYSTEMTIME stUpTime;            // Time printed data structure crated UTC
    DWORD   MaxcRef;                // Maximum number of cRef
    DWORD   cTotalPagesPrinted;     // Total number of pages printed
    DWORD   dwGetVersion;           // OS version
    DWORD   fFreeBuild;             // TRUE for free build
    DWORD   cSpooling;              // Number of jobs actively spooling
    DWORD   cMaxSpooling;           // Maximum number of cSpooling
    DWORD   cRef;                   // Printer object reference count (opened)
    DWORD   cErrorOutOfPaper;       // Total Number of Out Of Paper Errors
    DWORD   cErrorNotReady;         // Total Number of Error Not Ready
    DWORD   cJobError;              // Total number of Job Errors
    DWORD   dwNumberOfProcessors;   // Number of Processors on computer
    DWORD   dwProcessorType;        // Processor Type of computer
    DWORD   dwHighPartTotalBytes;   // Total Bytes Printed (HIGH DWORD)
    DWORD   cChangeID;              // Count of Changes to Printer Config
    DWORD   dwLastError;            // Last Error
    DWORD   Status;                 // Current Printer Status
    DWORD   cEnumerateNetworkPrinters; // Count How Many Times Browse List Requested
    DWORD   cAddNetPrinters;        // Count of NetPrinters Added ( Browser )
    WORD    wProcessorArchitecture; // Processor Architecture of computer
    WORD    wProcessorLevel;        // Processor Level of computer
    DWORD   cRefIC;                 // Count of open IC handles
    DWORD   dwReserved2;            // Reserved for Future Use
    DWORD   dwReserved3;

} PRINTER_INFO_STRESSW, *PPRINTER_INFO_STRESSW, *LPPRINTER_INFO_STRESSW;


typedef struct _DRIVER_UPGRADE_INFO_1W {
    LPWSTR   pPrinterName;           // Printer Name being upgraded
    LPWSTR   pOldDriverDirectory;    // fully qualified path to old printer driver

} DRIVER_UPGRADE_INFO_1W, *PDRIVER_UPGRADE_INFO_1W, *LPDRIVER_UPGRADE_INFO_1W;


#ifdef UNICODE
#define PRINTER_INFO_STRESS PRINTER_INFO_STRESSW
#define PPRINTER_INFO_STRESS PPRINTER_INFO_STRESSW
#define LPPRINTER_INFO_STRESS LPPRINTER_INFO_STRESSW
#else
#define PRINTER_INFO_STRESS PRINTER_INFO_STRESSA
#define PPRINTER_INFO_STRESS PPRINTER_INFO_STRESSA
#define LPPRINTER_INFO_STRESS LPPRINTER_INFO_STRESSA
#endif // UNICODE


BOOL
AddPortExW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
);

BOOL
AddPortExA(
    LPSTR pName,
    DWORD Level,
    LPBYTE lpBuffer,
    LPSTR  lpMonitorName
);

BOOL
SetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
);


#ifdef UNICODE
#define AddPortEx AddPortExW
#else
#define AddPortEx AddPortExA
#endif // !UNICODE

//
//  Interfaces to Spooler APIs
//

HANDLE
SplAddPrinter(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pPrinter,
    HANDLE      pIniSpooler,
    LPBYTE      pExtraData,
    LPBYTE      pSplClientInfo,
    DWORD       dwLevel
);

BOOL
SplDeletePrinter(
    HANDLE  hPrinter
);

BOOL
SplEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

DWORD
SplOpenPrinter(
   LPWSTR               pPrinterName,
   LPHANDLE             phPrinter,
   LPPRINTER_DEFAULTS   pDefault,
   HANDLE               pIniSpooler,
   LPBYTE               pSplClientInfo,
   DWORD                dwLevel
);


BOOL
SplDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    HANDLE   pIniSpooler
);

BOOL
SplDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    HANDLE   pIniSpooler,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
);

BOOL
SplGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    HANDLE   pIniSpooler
);


BOOL
SplGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    HANDLE   pIniSpooler
);

BOOL
SplAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPVOID   pBuffer,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    HANDLE  pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

BOOL
SplAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    HANDLE  pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

BOOL
SplAddDriverCatalog(
    HANDLE hPrinter,
    DWORD  dwLevel,
    VOID   *pvDriverInfCatInfo,
    DWORD  dwCatalogCopyFlags
);

BOOL
SplDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);

BOOL
SplDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName,
    HANDLE   pIniSpooler
);

BOOL
SplAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    HANDLE   pIniSpooler
);

BOOL
SplMonitorIsInstalled(
    LPWSTR  pMonitorName
);

BOOL
SplDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    HANDLE   pIniSpooler
);

BOOL
SplEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

BOOL
SplConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName,
    HANDLE   pIniSpooler
);


BOOL
SplXcvData(
    HANDLE      hXcv,
    LPCWSTR     pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    HANDLE      pIniSpooler
);


BOOL
SplEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


BOOL
SplEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


BOOL
SplEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

BOOL
SplEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


VOID
SplBroadcastChange(
    HANDLE  hPrinter,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
);


typedef struct _SPOOLER_INFO_1 {
    LPWSTR pDir;
    LPWSTR pDefaultSpoolDir;
    LPWSTR pszRegistryRoot;
    LPWSTR pszRegistryPrinters;
    LPWSTR pszRegistryMonitors;
    LPWSTR pszRegistryEnvironments;
    LPWSTR pszRegistryEventLog;
    LPWSTR pszRegistryProviders;
    LPWSTR pszEventLogMsgFile;
    LPWSTR pszDriversShare;
    LPWSTR pszRegistryForms;
    DWORD   SpoolerFlags;
    FARPROC pfnReadRegistryExtra;
    FARPROC pfnWriteRegistryExtra;
    FARPROC pfnFreePrinterExtra;
} SPOOLER_INFO_1, *PSPOOLER_INFO_1, *LPSPOOLER_INFO_1;

typedef struct _SPOOLER_INFO_2 {
    LPWSTR pDir;
    LPWSTR pDefaultSpoolDir;
    LPWSTR pszRegistryRoot;
    LPWSTR pszRegistryPrinters;
    LPWSTR pszRegistryMonitors;
    LPWSTR pszRegistryEnvironments;
    LPWSTR pszRegistryEventLog;
    LPWSTR pszRegistryProviders;
    LPWSTR pszEventLogMsgFile;
    LPWSTR pszDriversShare;
    LPWSTR pszRegistryForms;
    DWORD   SpoolerFlags;
    FARPROC pfnReadRegistryExtra;
    FARPROC pfnWriteRegistryExtra;
    FARPROC pfnFreePrinterExtra;
    LPWSTR pszResource;
    LPWSTR pszName;
    LPWSTR pszAddress;
} SPOOLER_INFO_2, *PSPOOLER_INFO_2, *LPSPOOLER_INFO_2;

#define SPL_UPDATE_WININI_DEVICES                   0x00000001
#define SPL_PRINTER_CHANGES                         0x00000002
#define SPL_LOG_EVENTS                              0x00000004
#define SPL_FORMS_CHANGE                            0x00000008
#define SPL_BROADCAST_CHANGE                        0x00000010
#define SPL_SECURITY_CHECK                          0x00000020
#define SPL_OPEN_CREATE_PORTS                       0x00000040
#define SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION     0x00000080
#define SPL_REMOTE_HANDLE_CHECK                     0x00000100
#define SPL_PRINTER_DRIVER_EVENT                    0x00000200

#define SPL_ALWAYS_CREATE_DRIVER_SHARE              0x00000400
#define SPL_NO_UPDATE_PRINTERINI                    0x00000800
#define SPL_NO_UPDATE_JOBSHD                        0x00001000
#define SPL_CLUSTER_REG                             0x00002000
#define SPL_OFFLINE                                 0x00004000
#define SPL_PENDING_DELETION                        0x00008000
#define SPL_SERVER_THREAD                           0x00010000
#define SPL_PRINT                                   0x00020000
#define SPL_NON_RAW_TO_MASQ_PRINTERS                0x00040000
#define SPL_OPEN_EXISTING_ONLY                      0x00080000

#define SPL_TYPE                                    0xff000000
#define SPL_TYPE_LOCAL                              0x01000000
#define SPL_TYPE_CLUSTER                            0x02000000
#define SPL_TYPE_CACHE                              0x04000000


HANDLE
SplCreateSpooler(
    LPWSTR  pMachineName,
    DWORD   Level,
    PBYTE   pSpooler,
    LPBYTE  pReserved
);

BOOL
SplDeleteSpooler(
    HANDLE  hSpooler
);

BOOL
SplCloseSpooler(
    HANDLE  hSpooler
);


BOOL
SplEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
SplAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);

BOOL
SplDeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
);

BOOL
SplGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplSetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);

BOOL
SplClosePrinter(
    HANDLE hPrinter
);

DWORD
SplGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

DWORD
SplGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);


DWORD
SplEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
);

DWORD
SplEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
SplEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey       // address for size of value buffer
);


DWORD
SplDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
);


DWORD
SplDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
);

DWORD
SplDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
);


DWORD
SplSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

DWORD
SplSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
SplGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplGetPrinterDriverEx(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
);


BOOL
SplResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);


BOOL
SplGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    DWORD   Command
);

BOOL
SplSetPrinterExtra(
    HANDLE  hPrinter,
    LPBYTE  pExtraData
);

BOOL
SplGetPrinterExtra(
    HANDLE  hPrinter,
    PBYTE   *ppExtraData
);

BOOL
SplSetPrinterExtraEx(
    HANDLE  hPrinter,
    DWORD   dwPrivateFlag
);

BOOL
SplGetPrinterExtraEx(
    HANDLE  hPrinter,
    LPDWORD pdwPrivateFlag
);

BOOL
SplDriverEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    LPARAM  lParam
);

BOOL
SplCopyNumberOfFiles(
    LPWSTR  pszPrinterName,
    LPWSTR  *ppszSourceFileNames,
    DWORD   dwCount,
    LPWSTR  pszTargetDir,
    LPBOOL  pbFilesAddedOrUpdated
    );

BOOL
SplGetDriverDir(
    HANDLE  hIniSpooler,
    LPWSTR  pszDir,
    LPDWORD pcchDir
    );

HMODULE
SplLoadLibraryTheCopyFileModule(
    HANDLE  hPrinter,
    LPWSTR  pszModule
    );

BOOL
SplCopyFileEvent(
    HANDLE  hPrinter,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    );

VOID
SplDriverUnloadComplete(
    LPWSTR   pDriverFile
    );

BOOL
SplGetSpoolFileInfo(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL
SplCommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL
SplCloseSpoolFileHandle(
    HANDLE  hPrinter
    );

BOOL
bGetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    );

BOOL
bSetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE pDevMode
    );

DWORD 
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCWSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\fxsapip.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/



#ifndef _FAXAPIP_
#define _FAXAPIP_


#ifndef MIDL_PASS
#include <tapi.h>
#endif

#if !defined(_WINFAX_)
#define WINFAXAPI DECLSPEC_IMPORT
#else
#define WINFAXAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif

//
// FAX ERROR CODES
//

#define FAX_ERR_START                                   7001L   // First fax specific error code

#define FAX_ERR_SRV_OUTOFMEMORY                         7001L
#define FAX_ERR_GROUP_NOT_FOUND                         7002L
#define FAX_ERR_BAD_GROUP_CONFIGURATION                 7003L
#define FAX_ERR_GROUP_IN_USE                            7004L
#define FAX_ERR_RULE_NOT_FOUND                          7005L
#define FAX_ERR_NOT_NTFS                                7006L
#define FAX_ERR_DIRECTORY_IN_USE                        7007L
#define FAX_ERR_FILE_ACCESS_DENIED                      7008L
#define FAX_ERR_MESSAGE_NOT_FOUND                       7009L
#define FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED               7010L
#define FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU               7011L
#define FAX_ERR_VERSION_MISMATCH                        7012L   // Fax client/server versions mismtach

#define FAX_ERR_END                                     7012L   // Last fax specific error code


//
// MessageId: FAX_E_SRV_OUTOFMEMORY
//
// MessageText:
//
//  The fax server failed to allocate memory.
//
#define FAX_E_SRV_OUTOFMEMORY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_SRV_OUTOFMEMORY)

//
// MessageId: FAX_E_GROUP_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing group by name.
//
#define FAX_E_GROUP_NOT_FOUND                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_NOT_FOUND)

//
// MessageId: FAX_E_BAD_GROUP_CONFIGURATION
//
// MessageText:
//
//  The fax server encountered an outbound routing group with bad configuration.
//
#define FAX_E_BAD_GROUP_CONFIGURATION        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_BAD_GROUP_CONFIGURATION)

//
// MessageId: FAX_E_GROUP_IN_USE
//
// MessageText:
//
//  The fax server cannot remove an outbound routing group because it is in use by one or more outbound routing rules.
//
#define FAX_E_GROUP_IN_USE                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_IN_USE)

//
// MessageId: FAX_E_RULE_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing rule by country code and area code.
//
#define FAX_E_RULE_NOT_FOUND                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_RULE_NOT_FOUND)

//
// MessageId: FAX_E_NOT_NTFS
//
// MessageText:
//
//  The fax server cannot set an archive folder to a non-NTFS partition.
//
#define FAX_E_NOT_NTFS                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_NTFS)

//
// MessageId: FAX_E_DIRECTORY_IN_USE
//
// MessageText:
//
//  The fax server cannot use the same folder for both the inbox and the sent-items archives.
//
#define FAX_E_DIRECTORY_IN_USE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DIRECTORY_IN_USE)

//
// MessageId: FAX_E_FILE_ACCESS_DENIED
//
// MessageText:
//
//  The fax server cannot access the specified file or folder.
//
#define FAX_E_FILE_ACCESS_DENIED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_FILE_ACCESS_DENIED)

//
// MessageId: FAX_E_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  The fax server cannot find the job or message by its ID.
//
#define FAX_E_MESSAGE_NOT_FOUND              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_MESSAGE_NOT_FOUND)

//
// MessageId: FAX_E_DEVICE_NUM_LIMIT_EXCEEDED
//
// MessageText:
//
//  The fax server cannot complete the operation because the number of active fax devices allowed for this version of Windows was exceeded.
//
#define FAX_E_DEVICE_NUM_LIMIT_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED)

//
// MessageId: FAX_E_NOT_SUPPORTED_ON_THIS_SKU
//
// MessageText:
//
//  The fax server cannot complete the operation because it is not supported for this version of Windows.
//
#define FAX_E_NOT_SUPPORTED_ON_THIS_SKU      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU)

//
// MessageId: FAX_E_VERSION_MISMATCH
//
// MessageText:
//
//  The fax server API version does not support the requested operation.
//
#define FAX_E_VERSION_MISMATCH               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_VERSION_MISMATCH)

typedef enum
{
    FAXLOG_LEVEL_NONE            = 0,
    FAXLOG_LEVEL_MIN,
    FAXLOG_LEVEL_MED,
    FAXLOG_LEVEL_MAX
} FAX_ENUM_LOG_LEVELS;

typedef enum
{
    FAXLOG_CATEGORY_INIT        = 1,        // Initialization / shutdown
    FAXLOG_CATEGORY_OUTBOUND,               // Outbound messages
    FAXLOG_CATEGORY_INBOUND,                // Inbound messages
    FAXLOG_CATEGORY_UNKNOWN                 // Unknown category (all others)
} FAX_ENUM_LOG_CATEGORIES;

typedef struct _FAX_LOG_CATEGORYA
{
    LPCSTR              Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYA, *PFAX_LOG_CATEGORYA;
typedef struct _FAX_LOG_CATEGORYW
{
    LPCWSTR             Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYW, *PFAX_LOG_CATEGORYW;
#ifdef UNICODE
typedef FAX_LOG_CATEGORYW FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYW PFAX_LOG_CATEGORY;
#else
typedef FAX_LOG_CATEGORYA FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYA PFAX_LOG_CATEGORY;
#endif // UNICODE

typedef struct _FAX_TIME
{
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;

typedef struct _FAX_CONFIGURATIONA
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCSTR              ArchiveDirectory;               // archive directory for outgoing faxes
    LPCSTR              Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONA, *PFAX_CONFIGURATIONA;
typedef struct _FAX_CONFIGURATIONW
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCWSTR             ArchiveDirectory;               // archive directory for outgoing faxes
    LPCWSTR             Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONW, *PFAX_CONFIGURATIONW;
#ifdef UNICODE
typedef FAX_CONFIGURATIONW FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONW PFAX_CONFIGURATION;
#else
typedef FAX_CONFIGURATIONA FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONA PFAX_CONFIGURATION;
#endif // UNICODE


//
// FaxSetJob() command codes
//

typedef enum
{
    JC_UNKNOWN      = 0,
    JC_DELETE,
    JC_PAUSE,
    JC_RESUME
} FAX_ENUM_JOB_COMMANDS;

#define JC_RESTART   JC_RESUME


//
// job type defines
//

//
// NOTICE: JT_* and JS_* are different from the Win2K public constants.
//         If you use WinFax.h and/or the Win2K COM interfaces, you get the Win2K constants.
//         If you use fxsapip.h, you get the Whistler constants.
//
//         NEVER MIX THEM !!!
//
typedef enum
{
    JT_UNKNOWN                  = 0x0001,       // Fax type is not determined yet
    JT_SEND                     = 0x0002,       // Outgoing fax message
    JT_RECEIVE                  = 0x0004,       // Incoming fax message
    JT_ROUTING                  = 0x0008,       // Incoming message - being routed
    JT_FAIL_RECEIVE             = 0x0010,       // Fail receive job (legacy support only)
    JT_BROADCAST                = 0x0020        // Outgoing broadcast message
} FAX_ENUM_JOB_TYPES;

//
// job status defines
//

#define JS_PENDING                  0x00000001
#define JS_INPROGRESS               0x00000002
#define JS_DELETING                 0x00000004
#define JS_FAILED                   0x00000008
#define JS_PAUSED                   0x00000010
#define JS_NOLINE                   0x00000020
#define JS_RETRYING                 0x00000040
#define JS_RETRIES_EXCEEDED         0x00000080


typedef struct _FAX_DEVICE_STATUSA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              CallerId;                   // caller id string
    LPCSTR              Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCSTR              DeviceName;                 // device name
    LPCSTR              DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCSTR              PhoneNumber;                // sending phone number
    LPCSTR              RoutingString;              // routing information
    LPCSTR              SenderName;                 // sender name
    LPCSTR              RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCSTR              StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCSTR              Tsid;                       // transmitting station identifier
    LPCSTR              UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSA, *PFAX_DEVICE_STATUSA;
typedef struct _FAX_DEVICE_STATUSW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             CallerId;                   // caller id string
    LPCWSTR             Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCWSTR             PhoneNumber;                // sending phone number
    LPCWSTR             RoutingString;              // routing information
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCWSTR             StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCWSTR             Tsid;                       // transmitting station identifier
    LPCWSTR             UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSW, *PFAX_DEVICE_STATUSW;
#ifdef UNICODE
typedef FAX_DEVICE_STATUSW FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSW PFAX_DEVICE_STATUS;
#else
typedef FAX_DEVICE_STATUSA FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSA PFAX_DEVICE_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRYA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCSTR              UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name
} FAX_JOB_ENTRYA, *PFAX_JOB_ENTRYA;
typedef struct _FAX_JOB_ENTRYW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCWSTR             UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name
} FAX_JOB_ENTRYW, *PFAX_JOB_ENTRYW;
#ifdef UNICODE
typedef FAX_JOB_ENTRYW FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYW PFAX_JOB_ENTRY;
#else
typedef FAX_JOB_ENTRYA FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYA PFAX_JOB_ENTRY;
#endif // UNICODE

//
// fax port state masks
//
// if you change these defines the be sure to
// change the resources in the fax service.
//

#define FPS_DIALING              0x20000001
#define FPS_SENDING              0x20000002
#define FPS_RECEIVING            0x20000004
#define FPS_COMPLETED            0x20000008
#define FPS_HANDLED              0x20000010
#define FPS_UNAVAILABLE          0x20000020
#define FPS_BUSY                 0x20000040
#define FPS_NO_ANSWER            0x20000080
#define FPS_BAD_ADDRESS          0x20000100
#define FPS_NO_DIAL_TONE         0x20000200
#define FPS_DISCONNECTED         0x20000400
#define FPS_FATAL_ERROR          0x20000800
#define FPS_NOT_FAX_CALL         0x20001000
#define FPS_CALL_DELAYED         0x20002000
#define FPS_CALL_BLACKLISTED     0x20004000
#define FPS_INITIALIZING         0x20008000
#define FPS_OFFLINE              0x20010000
#define FPS_RINGING              0x20020000

#define FPS_AVAILABLE            0x20100000
#define FPS_ABORTING             0x20200000
#define FPS_ROUTING              0x20400000
#define FPS_ANSWERED             0x20800000

//
// fax port capability mask
//

#define FPF_RECEIVE       0x00000001        // Automatically receive faxes
#define FPF_SEND          0x00000002
#define FPF_VIRTUAL       0x00000004

typedef struct _FAX_PORT_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCSTR              DeviceName;                 // Device name
    LPCSTR              Tsid;                       // Device Tsid
    LPCSTR              Csid;                       // Device Csid
} FAX_PORT_INFOA, *PFAX_PORT_INFOA;
typedef struct _FAX_PORT_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCWSTR             DeviceName;                 // Device name
    LPCWSTR             Tsid;                       // Device Tsid
    LPCWSTR             Csid;                       // Device Csid
} FAX_PORT_INFOW, *PFAX_PORT_INFOW;
#ifdef UNICODE
typedef FAX_PORT_INFOW FAX_PORT_INFO;
typedef PFAX_PORT_INFOW PFAX_PORT_INFO;
#else
typedef FAX_PORT_INFOA FAX_PORT_INFO;
typedef PFAX_PORT_INFOA PFAX_PORT_INFO;
#endif // UNICODE


typedef struct _FAX_ROUTING_METHODA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCSTR              DeviceName;                 // device name
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODA, *PFAX_ROUTING_METHODA;
typedef struct _FAX_ROUTING_METHODW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODW, *PFAX_ROUTING_METHODW;
#ifdef UNICODE
typedef FAX_ROUTING_METHODW FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODW PFAX_ROUTING_METHOD;
#else
typedef FAX_ROUTING_METHODA FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODA PFAX_ROUTING_METHOD;
#endif // UNICODE


typedef struct _FAX_GLOBAL_ROUTING_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOA, *PFAX_GLOBAL_ROUTING_INFOA;
typedef struct _FAX_GLOBAL_ROUTING_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOW, *PFAX_GLOBAL_ROUTING_INFOW;
#ifdef UNICODE
typedef FAX_GLOBAL_ROUTING_INFOW FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOW PFAX_GLOBAL_ROUTING_INFO;
#else
typedef FAX_GLOBAL_ROUTING_INFOA FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOA PFAX_GLOBAL_ROUTING_INFO;
#endif // UNICODE


typedef struct _FAX_COVERPAGE_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCSTR              CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCSTR              RecName;                    //
    LPCSTR              RecFaxNumber;               //
    LPCSTR              RecCompany;                 //
    LPCSTR              RecStreetAddress;           //
    LPCSTR              RecCity;                    //
    LPCSTR              RecState;                   //
    LPCSTR              RecZip;                     //
    LPCSTR              RecCountry;                 //
    LPCSTR              RecTitle;                   //
    LPCSTR              RecDepartment;              //
    LPCSTR              RecOfficeLocation;          //
    LPCSTR              RecHomePhone;               //
    LPCSTR              RecOfficePhone;             //
    //
    // Sender information
    //
    LPCSTR              SdrName;                    //
    LPCSTR              SdrFaxNumber;               //
    LPCSTR              SdrCompany;                 //
    LPCSTR              SdrAddress;                 //
    LPCSTR              SdrTitle;                   //
    LPCSTR              SdrDepartment;              //
    LPCSTR              SdrOfficeLocation;          //
    LPCSTR              SdrHomePhone;               //
    LPCSTR              SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCSTR              Note;                       //
    LPCSTR              Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOA, *PFAX_COVERPAGE_INFOA;
typedef struct _FAX_COVERPAGE_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW, *PFAX_COVERPAGE_INFOW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFOW FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOW PFAX_COVERPAGE_INFO;
#else
typedef FAX_COVERPAGE_INFOA FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOA PFAX_COVERPAGE_INFO;
#endif // UNICODE

typedef enum
{
    JSA_NOW                  = 0,   // Send now
    JSA_SPECIFIC_TIME,              // Send at specific time
    JSA_DISCOUNT_PERIOD             // Send at server configured discount period
} FAX_ENUM_JOB_SEND_ATTRIBUTES;
typedef enum
{
    DRT_NONE                = 0x0000,       // Do not send receipt
    DRT_EMAIL               = 0x0001,       // Send receipt by email (SMTP)
    DRT_UNUSED              = 0x0002,       // Reserved
    DRT_MSGBOX              = 0x0004,       // Send receipt by a message box
    DRT_GRP_PARENT          = 0x0008,       // Send a single receipt for a broadcast job
    DRT_ATTACH_FAX          = 0x0010        // Attach the fax tiff file to the receipt
} FAX_ENUM_DELIVERY_REPORT_TYPES;


#define DRT_ALL         (DRT_EMAIL | DRT_MSGBOX)            // All possible delivery report types
#define DRT_MODIFIERS   (DRT_GRP_PARENT | DRT_ATTACH_FAX)   // All state modifiers


//
// the reserved fields are private data used
// by the fax monitor and winfax.
//
//
// Reserved[0] == 0xffffffff
// Reserved[1] == Print job id
//
// Reserved[0] == 0xfffffffe   start of a broadcast job
//

typedef struct _FAX_JOB_PARAMA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMA, *PFAX_JOB_PARAMA;
typedef struct _FAX_JOB_PARAMW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMW, *PFAX_JOB_PARAMW;
#ifdef UNICODE
typedef FAX_JOB_PARAMW FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMW PFAX_JOB_PARAM;
#else
typedef FAX_JOB_PARAMA FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMA PFAX_JOB_PARAM;
#endif // UNICODE

//
// Event Ids
//
// FEI_NEVENTS is the number of events
//

#define FEI_DIALING                 0x00000001
#define FEI_SENDING                 0x00000002
#define FEI_RECEIVING               0x00000003
#define FEI_COMPLETED               0x00000004
#define FEI_BUSY                    0x00000005
#define FEI_NO_ANSWER               0x00000006
#define FEI_BAD_ADDRESS             0x00000007
#define FEI_NO_DIAL_TONE            0x00000008
#define FEI_DISCONNECTED            0x00000009
#define FEI_FATAL_ERROR             0x0000000a
#define FEI_NOT_FAX_CALL            0x0000000b
#define FEI_CALL_DELAYED            0x0000000c
#define FEI_CALL_BLACKLISTED        0x0000000d
#define FEI_RINGING                 0x0000000e
#define FEI_ABORTING                0x0000000f
#define FEI_ROUTING                 0x00000010
#define FEI_MODEM_POWERED_ON        0x00000011
#define FEI_MODEM_POWERED_OFF       0x00000012
#define FEI_IDLE                    0x00000013
#define FEI_FAXSVC_ENDED            0x00000014
#define FEI_ANSWERED                0x00000015
#define FEI_JOB_QUEUED              0x00000016
#define FEI_DELETED                 0x00000017
#define FEI_INITIALIZING            0x00000018
#define FEI_LINE_UNAVAILABLE        0x00000019
#define FEI_HANDLED                 0x0000001a
#define FEI_FAXSVC_STARTED          0x0000001b

#define FEI_NEVENTS                 FEI_FAXSVC_STARTED

typedef struct _FAX_EVENTA
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTA, *PFAX_EVENTA;
typedef struct _FAX_EVENTW
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTW, *PFAX_EVENTW;
#ifdef UNICODE
typedef FAX_EVENTW FAX_EVENT;
typedef PFAX_EVENTW PFAX_EVENT;
#else
typedef FAX_EVENTA FAX_EVENT;
typedef PFAX_EVENTA PFAX_EVENT;
#endif // UNICODE


typedef struct _FAX_PRINT_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCSTR              DocName;                    // Document name that appears in the spooler
    LPCSTR              RecipientName;              // Recipient name
    LPCSTR              RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCSTR              SenderName;                 // Sender name
    LPCSTR              SenderCompany;              // Sender company (optional)
    LPCSTR              SenderDept;                 // Sender department
    LPCSTR              SenderBillingCode;          // Billing code
    LPCSTR              Reserved;                   // Reserved; must be NULL
    LPCSTR              DrEmailAddress;             // E.Mail address for delivery report
    LPCSTR              OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOA, *PFAX_PRINT_INFOA;
typedef struct _FAX_PRINT_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCWSTR             DocName;                    // Document name that appears in the spooler
    LPCWSTR             RecipientName;              // Recipient name
    LPCWSTR             RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCWSTR             SenderName;                 // Sender name
    LPCWSTR             SenderCompany;              // Sender company (optional)
    LPCWSTR             SenderDept;                 // Sender department
    LPCWSTR             SenderBillingCode;          // Billing code
    LPCWSTR             Reserved;                   // Reserved; must be NULL
    LPCWSTR             DrEmailAddress;             // E.Mail address for delivery report
    LPCWSTR             OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOW, *PFAX_PRINT_INFOW;
#ifdef UNICODE
typedef FAX_PRINT_INFOW FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOW PFAX_PRINT_INFO;
#else
typedef FAX_PRINT_INFOA FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOA PFAX_PRINT_INFO;
#endif // UNICODE


typedef struct _FAX_CONTEXT_INFOA
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    CHAR                ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOA, *PFAX_CONTEXT_INFOA;
typedef struct _FAX_CONTEXT_INFOW
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    WCHAR               ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOW, *PFAX_CONTEXT_INFOW;
#ifdef UNICODE
typedef FAX_CONTEXT_INFOW FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOW PFAX_CONTEXT_INFO;
#else
typedef FAX_CONTEXT_INFOA FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOA PFAX_CONTEXT_INFO;
#endif // UNICODE


//
// prototypes
//

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define FaxConnectFaxServer  FaxConnectFaxServerW
#else
#define FaxConnectFaxServer  FaxConnectFaxServerA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERA)(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERW)(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERW
#else
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXCLOSE)(
    IN HANDLE FaxHandle
    );

typedef enum
{
    PORT_OPEN_QUERY     = 1,
    PORT_OPEN_MODIFY
} FAX_ENUM_PORT_OPEN_TYPE;

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

typedef BOOL
(WINAPI *PFAXOPENPORT)(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define FaxCompleteJobParams  FaxCompleteJobParamsW
#else
#define FaxCompleteJobParams  FaxCompleteJobParamsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSA)(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSW)(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSW
#else
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSA
#endif // !UNICODE



WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define FaxSendDocument  FaxSendDocumentW
#else
#define FaxSendDocument  FaxSendDocumentA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTA)(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTW)(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTW
#else
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTA
#endif // !UNICODE

typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKA)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMA JobParams,
    IN OUT PFAX_COVERPAGE_INFOA CoverpageInfo OPTIONAL
    );
typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMW JobParams,
    IN OUT PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
    );
#ifdef UNICODE
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKW
#else
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    );
#ifdef UNICODE
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastW
#else
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTA)(
    IN  HANDLE FaxHandle,
    IN  LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN  LPVOID Context
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTW)(
    IN  HANDLE FaxHandle,
    IN  LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN  LPVOID Context
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTW
#else
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxSetJob  FaxSetJobW
#else
#define FaxSetJob  FaxSetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETJOBA)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXSETJOBW)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXSETJOB  PFAXSETJOBW
#else
#define PFAXSETJOB  PFAXSETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

typedef BOOL
(WINAPI *PFAXGETPAGEDATA)(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define FaxGetDeviceStatus  FaxGetDeviceStatusW
#else
#define FaxGetDeviceStatus  FaxGetDeviceStatusA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSW
#else
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

typedef BOOL
(WINAPI *PFAXABORT)(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxGetConfiguration  FaxGetConfigurationW
#else
#define FaxGetConfiguration  FaxGetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONW
#else
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxSetConfiguration  FaxSetConfigurationW
#else
#define FaxSetConfiguration  FaxSetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONW
#else
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesW
#else
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESW
#else
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesW
#else
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESW
#else
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define FaxEnumPorts  FaxEnumPortsW
#else
#define FaxEnumPorts  FaxEnumPortsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMPORTSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMPORTSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define PFAXENUMPORTS  PFAXENUMPORTSW
#else
#define PFAXENUMPORTS  PFAXENUMPORTSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxGetPort  FaxGetPortW
#else
#define FaxGetPort  FaxGetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETPORTA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXGETPORTW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXGETPORT  PFAXGETPORTW
#else
#define PFAXGETPORT  PFAXGETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxSetPort  FaxSetPortW
#else
#define FaxSetPort  FaxSetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETPORTA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXSETPORTW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXSETPORT  PFAXSETPORTW
#else
#define PFAXSETPORT  PFAXSETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsW
#else
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSW
#else
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodW
#else
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODW
#else
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoW
#else
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOW
#else
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoW
#else
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOW
#else
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxGetRoutingInfo  FaxGetRoutingInfoW
#else
#define FaxGetRoutingInfo  FaxGetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXGETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOW
#else
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxSetRoutingInfo  FaxSetRoutingInfoW
#else
#define FaxSetRoutingInfo  FaxSetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXSETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOW
#else
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRelease(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXRELEASE)(
    IN HANDLE FaxHandle
    );

BOOL
FXSAPIInitialize(
    VOID
    );

VOID
FXSAPIFree(
    VOID
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2A
(
    IN  LPCSTR                 PrinterName,
    IN  const FAX_PRINT_INFOA    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOA       FaxContextInfo
);
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2W
(
    IN  LPCWSTR                 PrinterName,
    IN  const FAX_PRINT_INFOW    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOW       FaxContextInfo
);
#ifdef UNICODE
#define FaxStartPrintJob2  FaxStartPrintJob2W
#else
#define FaxStartPrintJob2  FaxStartPrintJob2A
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

typedef BOOL
(WINAPI *PFAXINITIALIZEEVENTQUEUE)(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    );

typedef VOID
(WINAPI *PFAXFREEBUFFER)(
    LPVOID Buffer
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define FaxStartPrintJob  FaxStartPrintJobW
#else
#define FaxStartPrintJob  FaxStartPrintJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBA)(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBW)(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBW
#else
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define FaxPrintCoverPage  FaxPrintCoverPageW
#else
#define FaxPrintCoverPage  FaxPrintCoverPageA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEA)(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEW)(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEW
#else
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define FaxRegisterServiceProvider  FaxRegisterServiceProviderW

typedef BOOL
(WINAPI *PFAXREGISTERSERVICEPROVIDERW)(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define PFAXREGISTERSERVICEPROVIDER PFAXREGISTERSERVICEPROVIDERW

typedef BOOL
(CALLBACK *PFAX_ROUTING_INSTALLATION_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );

#define PFAX_ROUTING_INSTALLATION_CALLBACK PFAX_ROUTING_INSTALLATION_CALLBACKW


WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define FaxRegisterRoutingExtension FaxRegisterRoutingExtensionW


typedef BOOL
(WINAPI *PFAXREGISTERROUTINGEXTENSIONW)(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define PFAXREGISTERROUTINGEXTENSION PFAXREGISTERROUTINGEXTENSIONW

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
);
#ifdef UNICODE
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionW
#else
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetInstallType(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );

typedef BOOL
(WINAPI *PFAXGETINSTALLTYPE)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );



WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

typedef BOOL
(WINAPI *PFAXACCESSCHECK)(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

//
// Fax Specific Access Rights
//

#define FAX_JOB_SUBMIT          (0x0001)
#define FAX_JOB_QUERY           (0x0002)
#define FAX_CONFIG_QUERY        (0x0004)
#define FAX_CONFIG_SET          (0x0008)
#define FAX_PORT_QUERY          (0x0010)
#define FAX_PORT_SET            (0x0020)
#define FAX_JOB_MANAGE          (0x0040)

#define FAX_READ                (STANDARD_RIGHTS_READ        |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_PORT_QUERY)

#define FAX_WRITE               (STANDARD_RIGHTS_WRITE       |\
                                 FAX_JOB_SUBMIT )

#define FAX_ALL_ACCESS          (STANDARD_RIGHTS_ALL         |\
                                 FAX_JOB_SUBMIT              |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_CONFIG_SET              |\
                                 FAX_PORT_QUERY              |\
                                 FAX_PORT_SET                |\
                                 FAX_JOB_MANAGE)


//************************************
//* Extended API Functions
//************************************

#define MAX_FAX_STRING_LEN              MAX_PATH - 2
#define MAX_DIR_PATH                    248

//
// Outbound routing defines
//
#define ROUTING_RULE_COUNTRY_CODE_ANY   0       // Outbound routing rule - Any country dialing code
#define ROUTING_RULE_AREA_CODE_ANY      0       // Outbound routing rule - Any area dialing code

#define MAX_ROUTING_GROUP_NAME          128
#define ROUTING_GROUP_ALL_DEVICESW      L"<All devices>"
#define ROUTING_GROUP_ALL_DEVICESA      "<All devices>"

#ifdef UNICODE
#define ROUTING_GROUP_ALL_DEVICES       ROUTING_GROUP_ALL_DEVICESW
#else
#define ROUTING_GROUP_ALL_DEVICES       ROUTING_GROUP_ALL_DEVICESA;
#endif // UNICODE


//
// Activity logging defines
//
#define ACTIVITY_LOG_INBOX_FILE       TEXT("InboxLOG.txt")
#define ACTIVITY_LOG_OUTBOX_FILE      TEXT("OutboxLOG.txt")

//
// Archive defines
//
#define FAX_ARCHIVE_FOLDER_INVALID_SIZE         MAKELONGLONG(0xffffffff, 0xffffffff)
#define MAX_ARCHIVE_FOLDER_PATH                 180

//
// New job status codes
//
#define JS_COMPLETED                0x00000100
#define JS_CANCELED                 0x00000200
#define JS_CANCELING                0x00000400
#define JS_ROUTING                  0x00000800


//
// Extended job status defines
//

#define JS_EX_DISCONNECTED              0x00000001
#define JS_EX_INITIALIZING              0x00000002
#define JS_EX_DIALING                   0x00000003
#define JS_EX_TRANSMITTING              0x00000004
#define JS_EX_ANSWERED                  0x00000005
#define JS_EX_RECEIVING                 0x00000006
#define JS_EX_LINE_UNAVAILABLE          0x00000007
#define JS_EX_BUSY                      0x00000008
#define JS_EX_NO_ANSWER                 0x00000009
#define JS_EX_BAD_ADDRESS               0x0000000A
#define JS_EX_NO_DIAL_TONE              0x0000000B
#define JS_EX_FATAL_ERROR               0x0000000C
#define JS_EX_CALL_DELAYED              0x0000000D
#define JS_EX_CALL_BLACKLISTED          0x0000000E
#define JS_EX_NOT_FAX_CALL              0x0000000F
#define JS_EX_PARTIALLY_RECEIVED        0x00000010
#define JS_EX_HANDLED                   0x00000011

#define FAX_API_VER_0_MAX_JS_EX         JS_EX_HANDLED    // API version 0 was only aware of extended status codes up to JS_EX_HANDLED

#define JS_EX_CALL_COMPLETED            0x00000012
#define JS_EX_CALL_ABORTED              0x00000013

#define FAX_API_VER_1_MAX_JS_EX         JS_EX_CALL_ABORTED    // API version 0 was only aware of extended status codes up to JS_EX_CALL_ABORTED

#define JS_EX_PROPRIETARY               0x01000000

//
// Available job operations
//
typedef enum
{
    FAX_JOB_OP_VIEW                             = 0x0001,
    FAX_JOB_OP_PAUSE                            = 0x0002,
    FAX_JOB_OP_RESUME                           = 0x0004,
    FAX_JOB_OP_RESTART                          = 0x0008,
    FAX_JOB_OP_DELETE                           = 0x0010,
    FAX_JOB_OP_RECIPIENT_INFO                   = 0x0020,
    FAX_JOB_OP_SENDER_INFO                      = 0x0040
} FAX_ENUM_JOB_OP;

//************************************
//* Getting / Settings the queue state
//************************************

typedef enum
{
    FAX_INCOMING_BLOCKED = 0x0001,
    FAX_OUTBOX_BLOCKED   = 0x0002,
    FAX_OUTBOX_PAUSED    = 0x0004
} FAX_ENUM_QUEUE_STATE;

WINFAXAPI
BOOL
WINAPI
FaxGetQueueStates (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwQueueStates
);

WINFAXAPI
BOOL
WINAPI
FaxSetQueue (
    IN HANDLE       hFaxHandle,
    IN CONST DWORD  dwQueueStates
);

//************************************************
//* Getting / Setting the receipts configuration
//************************************************

typedef enum
{
    FAX_SMTP_AUTH_ANONYMOUS,
    FAX_SMTP_AUTH_BASIC,
    FAX_SMTP_AUTH_NTLM
} FAX_ENUM_SMTP_AUTH_OPTIONS;

typedef struct _FAX_RECEIPTS_CONFIGA
{
    DWORD                           dwSizeOfStruct;         // For version checks
    DWORD                           dwAllowedReceipts;      // Any combination of DRT_EMAIL and DRT_MSGBOX
    FAX_ENUM_SMTP_AUTH_OPTIONS      SMTPAuthOption;         // SMTP server authentication type
    LPSTR                           lptstrReserved;         // Reserved; must be NULL
    LPSTR                           lptstrSMTPServer;       // SMTP server name
    DWORD                           dwSMTPPort;             // SMTP port number
    LPSTR                           lptstrSMTPFrom;         // SMTP sender address
    LPSTR                           lptstrSMTPUserName;     // SMTP user name (for authenticated connections)
    LPSTR                           lptstrSMTPPassword;     // SMTP password (for authenticated connections)
                                                            // This value is always NULL on get and may be NULL
                                                            // on set (won't be written in the server).
    BOOL                            bIsToUseForMSRouteThroughEmailMethod;
} FAX_RECEIPTS_CONFIGA, *PFAX_RECEIPTS_CONFIGA;
typedef struct _FAX_RECEIPTS_CONFIGW
{
    DWORD                           dwSizeOfStruct;         // For version checks
    DWORD                           dwAllowedReceipts;      // Any combination of DRT_EMAIL and DRT_MSGBOX
    FAX_ENUM_SMTP_AUTH_OPTIONS      SMTPAuthOption;         // SMTP server authentication type
    LPWSTR                          lptstrReserved;         // Reserved; must be NULL
    LPWSTR                          lptstrSMTPServer;       // SMTP server name
    DWORD                           dwSMTPPort;             // SMTP port number
    LPWSTR                          lptstrSMTPFrom;         // SMTP sender address
    LPWSTR                          lptstrSMTPUserName;     // SMTP user name (for authenticated connections)
    LPWSTR                          lptstrSMTPPassword;     // SMTP password (for authenticated connections)
                                                            // This value is always NULL on get and may be NULL
                                                            // on set (won't be written in the server).
    BOOL                            bIsToUseForMSRouteThroughEmailMethod;
} FAX_RECEIPTS_CONFIGW, *PFAX_RECEIPTS_CONFIGW;
#ifdef UNICODE
typedef FAX_RECEIPTS_CONFIGW FAX_RECEIPTS_CONFIG;
typedef PFAX_RECEIPTS_CONFIGW PFAX_RECEIPTS_CONFIG;
#else
typedef FAX_RECEIPTS_CONFIGA FAX_RECEIPTS_CONFIG;
typedef PFAX_RECEIPTS_CONFIGA PFAX_RECEIPTS_CONFIG;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationA (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGA  *ppReceipts
);
WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationW (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGW  *ppReceipts
);
#ifdef UNICODE
#define FaxGetReceiptsConfiguration  FaxGetReceiptsConfigurationW
#else
#define FaxGetReceiptsConfiguration  FaxGetReceiptsConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGA  pReceipts
);
WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGW  pReceipts
);
#ifdef UNICODE
#define FaxSetReceiptsConfiguration  FaxSetReceiptsConfigurationW
#else
#define FaxSetReceiptsConfiguration  FaxSetReceiptsConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsOptions (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwReceiptsOptions  // Combination of DRT_EMAIL and DRT_MSGBOX
);

//********************************************
//*             Server version
//********************************************

typedef struct _FAX_VERSION
{
    DWORD dwSizeOfStruct;       // Size of this structure
    BOOL  bValid;               // Is version valid?
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    WORD  wMajorBuildNumber;
    WORD  wMinorBuildNumber;
    DWORD dwFlags;              // Combination of FAX_VER_FLAG_*
} FAX_VERSION, *PFAX_VERSION;


typedef enum
{
    FAX_VER_FLAG_CHECKED        = 0x00000001,       // File was built in debug mode
    FAX_VER_FLAG_EVALUATION     = 0x00000002        // Evaluation build
} FAX_VERSION_FLAGS;

WINFAXAPI
BOOL
WINAPI
FaxGetVersion (
    IN  HANDLE          hFaxHandle,
    OUT PFAX_VERSION    pVersion
);

#define FAX_API_VERSION_0           0x00000000      // BOS/SBS 2000 Fax Server API (0.0)
#define FAX_API_VERSION_1           0x00010000      // Windows XP Fax Server API   (1.0)

//
// NOTICE: Change this value whenever a new API version is introduced.
//
#define CURRENT_FAX_API_VERSION     FAX_API_VERSION_1

WINFAXAPI
BOOL
WINAPI
FaxGetReportedServerAPIVersion (
    IN  HANDLE          hFaxHandle,
    OUT LPDWORD         lpdwReportedServerAPIVersion
);

//********************************************
//*            Activity logging
//********************************************

typedef struct _FAX_ACTIVITY_LOGGING_CONFIGA
{
    DWORD   dwSizeOfStruct;
    BOOL    bLogIncoming;
    BOOL    bLogOutgoing;
    LPSTR   lptstrDBPath;
} FAX_ACTIVITY_LOGGING_CONFIGA, *PFAX_ACTIVITY_LOGGING_CONFIGA;
typedef struct _FAX_ACTIVITY_LOGGING_CONFIGW
{
    DWORD   dwSizeOfStruct;
    BOOL    bLogIncoming;
    BOOL    bLogOutgoing;
    LPWSTR  lptstrDBPath;
} FAX_ACTIVITY_LOGGING_CONFIGW, *PFAX_ACTIVITY_LOGGING_CONFIGW;
#ifdef UNICODE
typedef FAX_ACTIVITY_LOGGING_CONFIGW FAX_ACTIVITY_LOGGING_CONFIG;
typedef PFAX_ACTIVITY_LOGGING_CONFIGW PFAX_ACTIVITY_LOGGING_CONFIG;
#else
typedef FAX_ACTIVITY_LOGGING_CONFIGA FAX_ACTIVITY_LOGGING_CONFIG;
typedef PFAX_ACTIVITY_LOGGING_CONFIGA PFAX_ACTIVITY_LOGGING_CONFIG;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationA (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGA *ppActivLogCfg
);
WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationW (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGW *ppActivLogCfg
);
#ifdef UNICODE
#define FaxGetActivityLoggingConfiguration  FaxGetActivityLoggingConfigurationW
#else
#define FaxGetActivityLoggingConfiguration  FaxGetActivityLoggingConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationA (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGA  pActivLogCfg
);
WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationW (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGW  pActivLogCfg
);
#ifdef UNICODE
#define FaxSetActivityLoggingConfiguration  FaxSetActivityLoggingConfigurationW
#else
#define FaxSetActivityLoggingConfiguration  FaxSetActivityLoggingConfigurationA
#endif // !UNICODE

//********************************************
//*            Outbox configuration
//********************************************

typedef struct _FAX_OUTBOX_CONFIG
{
    DWORD       dwSizeOfStruct;
    BOOL        bAllowPersonalCP;
    BOOL        bUseDeviceTSID;
    DWORD       dwRetries;
    DWORD       dwRetryDelay;
    FAX_TIME    dtDiscountStart;
    FAX_TIME    dtDiscountEnd;
    DWORD       dwAgeLimit;
    BOOL        bBranding;
} FAX_OUTBOX_CONFIG, *PFAX_OUTBOX_CONFIG;

WINFAXAPI
BOOL
WINAPI
FaxGetOutboxConfiguration (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_OUTBOX_CONFIG *ppOutboxCfg
);

WINFAXAPI
BOOL
WINAPI
FaxSetOutboxConfiguration (
    IN HANDLE                    hFaxHandle,
    IN CONST PFAX_OUTBOX_CONFIG  pOutboxCfg
);

WINFAXAPI
BOOL
WINAPI
FaxGetPersonalCoverPagesOption (
    IN  HANDLE  hFaxHandle,
    OUT LPBOOL  lpbPersonalCPAllowed
);

//********************************************
//*            Archive configuration
//********************************************

typedef enum
{
    FAX_MESSAGE_FOLDER_INBOX,
    FAX_MESSAGE_FOLDER_SENTITEMS,
    FAX_MESSAGE_FOLDER_QUEUE
} FAX_ENUM_MESSAGE_FOLDER;

typedef struct _FAX_ARCHIVE_CONFIGA
{
    DWORD   dwSizeOfStruct;
    BOOL    bUseArchive;
    LPSTR   lpcstrFolder;
    BOOL    bSizeQuotaWarning;
    DWORD   dwSizeQuotaHighWatermark;
    DWORD   dwSizeQuotaLowWatermark;
    DWORD   dwAgeLimit;
    DWORDLONG dwlArchiveSize;
} FAX_ARCHIVE_CONFIGA, *PFAX_ARCHIVE_CONFIGA;
typedef struct _FAX_ARCHIVE_CONFIGW
{
    DWORD   dwSizeOfStruct;
    BOOL    bUseArchive;
    LPWSTR  lpcstrFolder;
    BOOL    bSizeQuotaWarning;
    DWORD   dwSizeQuotaHighWatermark;
    DWORD   dwSizeQuotaLowWatermark;
    DWORD   dwAgeLimit;
    DWORDLONG dwlArchiveSize;
} FAX_ARCHIVE_CONFIGW, *PFAX_ARCHIVE_CONFIGW;
#ifdef UNICODE
typedef FAX_ARCHIVE_CONFIGW FAX_ARCHIVE_CONFIG;
typedef PFAX_ARCHIVE_CONFIGW PFAX_ARCHIVE_CONFIG;
#else
typedef FAX_ARCHIVE_CONFIGA FAX_ARCHIVE_CONFIG;
typedef PFAX_ARCHIVE_CONFIGA PFAX_ARCHIVE_CONFIG;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationA (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGA    *ppArchiveCfg
);
WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationW (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
);
#ifdef UNICODE
#define FaxGetArchiveConfiguration  FaxGetArchiveConfigurationW
#else
#define FaxGetArchiveConfiguration  FaxGetArchiveConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGA   pArchiveCfg
);
WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
);
#ifdef UNICODE
#define FaxSetArchiveConfiguration  FaxSetArchiveConfigurationW
#else
#define FaxSetArchiveConfiguration  FaxSetArchiveConfigurationA
#endif // !UNICODE

//********************************************
//*         Server activity
//********************************************

typedef struct _FAX_SERVER_ACTIVITY
{
    DWORD   dwSizeOfStruct;
    DWORD   dwIncomingMessages;
    DWORD   dwRoutingMessages;
    DWORD   dwOutgoingMessages;
    DWORD   dwDelegatedOutgoingMessages;
    DWORD   dwQueuedMessages;
    DWORD   dwErrorEvents;
    DWORD   dwWarningEvents;
    DWORD   dwInformationEvents;
} FAX_SERVER_ACTIVITY, *PFAX_SERVER_ACTIVITY;

WINFAXAPI
BOOL
WINAPI
FaxGetServerActivity (
    IN  HANDLE               hFaxHandle,
    OUT PFAX_SERVER_ACTIVITY pServerActivity
);

//********************************************
//*                 Queue jobs
//********************************************

typedef enum
{
    FAX_PRIORITY_TYPE_LOW,
    FAX_PRIORITY_TYPE_NORMAL,
    FAX_PRIORITY_TYPE_HIGH
} FAX_ENUM_PRIORITY_TYPE;

#define FAX_PRIORITY_TYPE_DEFAULT    FAX_PRIORITY_TYPE_LOW

typedef enum
{
    FAX_JOB_FIELD_JOB_ID                    = 0x00000001,
    FAX_JOB_FIELD_TYPE                      = 0x00000002,
    FAX_JOB_FIELD_QUEUE_STATUS              = 0x00000004,
    FAX_JOB_FIELD_STATUS_EX                 = 0x00000008,
    FAX_JOB_FIELD_SIZE                      = 0x00000010,
    FAX_JOB_FIELD_PAGE_COUNT                = 0x00000020,
    FAX_JOB_FIELD_CURRENT_PAGE              = 0x00000040,
    FAX_JOB_FIELD_RECIPIENT_PROFILE         = 0x00000080,
    FAX_JOB_FIELD_SCHEDULE_TIME             = 0x00000100,
    FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME    = 0x00000200,
    FAX_JOB_FIELD_SUBMISSION_TIME           = 0x00000400,
    FAX_JOB_FIELD_TRANSMISSION_START_TIME   = 0x00000800,
    FAX_JOB_FIELD_TRANSMISSION_END_TIME     = 0x00001000,
    FAX_JOB_FIELD_PRIORITY                  = 0x00002000,
    FAX_JOB_FIELD_RETRIES                   = 0x00004000,
    FAX_JOB_FIELD_DELIVERY_REPORT_TYPE      = 0x00008000,
    FAX_JOB_FIELD_SENDER_PROFILE            = 0x00010000,
    FAX_JOB_FIELD_STATUS_SUB_STRUCT         = 0x00020000,
    FAX_JOB_FIELD_DEVICE_ID                 = 0x00040000,
    FAX_JOB_FIELD_MESSAGE_ID                = 0x00080000,
    FAX_JOB_FIELD_BROADCAST_ID              = 0x00010000
} FAX_ENUM_JOB_FIELDS;

typedef struct _FAX_JOB_STATUSA
{
    DWORD           dwSizeOfStruct;
    DWORD           dwValidityMask;
    DWORD           dwJobID;
    DWORD           dwJobType;
    DWORD           dwQueueStatus;
    DWORD           dwExtendedStatus;
    LPCSTR          lpctstrExtendedStatus;
    DWORD           dwSize;
    DWORD           dwPageCount;
    DWORD           dwCurrentPage;
    LPCSTR          lpctstrTsid;
    LPCSTR          lpctstrCsid;
    SYSTEMTIME      tmScheduleTime;
    SYSTEMTIME      tmTransmissionStartTime;
    SYSTEMTIME      tmTransmissionEndTime;
    DWORD           dwDeviceID;
    LPCSTR          lpctstrDeviceName;
    DWORD           dwRetries;
    LPCSTR          lpctstrCallerID;
    LPCSTR          lpctstrRoutingInfo;
    DWORD           dwAvailableJobOperations;
} FAX_JOB_STATUSA, *PFAX_JOB_STATUSA;
typedef struct _FAX_JOB_STATUSW
{
    DWORD           dwSizeOfStruct;
    DWORD           dwValidityMask;
    DWORD           dwJobID;
    DWORD           dwJobType;
    DWORD           dwQueueStatus;
    DWORD           dwExtendedStatus;
    LPCWSTR         lpctstrExtendedStatus;
    DWORD           dwSize;
    DWORD           dwPageCount;
    DWORD           dwCurrentPage;
    LPCWSTR         lpctstrTsid;
    LPCWSTR         lpctstrCsid;
    SYSTEMTIME      tmScheduleTime;
    SYSTEMTIME      tmTransmissionStartTime;
    SYSTEMTIME      tmTransmissionEndTime;
    DWORD           dwDeviceID;
    LPCWSTR         lpctstrDeviceName;
    DWORD           dwRetries;
    LPCWSTR         lpctstrCallerID;
    LPCWSTR         lpctstrRoutingInfo;
    DWORD           dwAvailableJobOperations;
} FAX_JOB_STATUSW, *PFAX_JOB_STATUSW;
#ifdef UNICODE
typedef FAX_JOB_STATUSW FAX_JOB_STATUS;
typedef PFAX_JOB_STATUSW PFAX_JOB_STATUS;
#else
typedef FAX_JOB_STATUSA FAX_JOB_STATUS;
typedef PFAX_JOB_STATUSA PFAX_JOB_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRY_EXA
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwValidityMask;
    DWORDLONG               dwlMessageId;
    DWORDLONG               dwlBroadcastId;
    LPCSTR                  lpctstrRecipientNumber;
    LPCSTR                  lpctstrRecipientName;
    LPCSTR                  lpctstrSenderUserName;
    LPCSTR                  lpctstrBillingCode;
    SYSTEMTIME              tmOriginalScheduleTime;
    SYSTEMTIME              tmSubmissionTime;
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwDeliveryReportType;
    LPCSTR                  lpctstrDocumentName;
    LPCSTR                  lpctstrSubject;
    PFAX_JOB_STATUSA        pStatus;
} FAX_JOB_ENTRY_EXA, *PFAX_JOB_ENTRY_EXA;
typedef struct _FAX_JOB_ENTRY_EXW
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwValidityMask;
    DWORDLONG               dwlMessageId;
    DWORDLONG               dwlBroadcastId;
    LPCWSTR                 lpctstrRecipientNumber;
    LPCWSTR                 lpctstrRecipientName;
    LPCWSTR                 lpctstrSenderUserName;
    LPCWSTR                 lpctstrBillingCode;
    SYSTEMTIME              tmOriginalScheduleTime;
    SYSTEMTIME              tmSubmissionTime;
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwDeliveryReportType;
    LPCWSTR                 lpctstrDocumentName;
    LPCWSTR                 lpctstrSubject;
    PFAX_JOB_STATUSW        pStatus;
} FAX_JOB_ENTRY_EXW, *PFAX_JOB_ENTRY_EXW;
#ifdef UNICODE
typedef FAX_JOB_ENTRY_EXW FAX_JOB_ENTRY_EX;
typedef PFAX_JOB_ENTRY_EXW PFAX_JOB_ENTRY_EX;
#else
typedef FAX_JOB_ENTRY_EXA FAX_JOB_ENTRY_EX;
typedef PFAX_JOB_ENTRY_EXA PFAX_JOB_ENTRY_EX;
#endif // UNICODE


typedef struct _FAX_JOB_PARAM_EXA
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwScheduleAction;
        SYSTEMTIME              tmSchedule;
        DWORD                   dwReceiptDeliveryType;
        LPSTR                   lptstrReceiptDeliveryAddress;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        HCALL                   hCall;
        DWORD_PTR               dwReserved[4];
        LPSTR                   lptstrDocumentName;
        DWORD                   dwPageCount;
} FAX_JOB_PARAM_EXA, *PFAX_JOB_PARAM_EXA;
typedef struct _FAX_JOB_PARAM_EXW
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwScheduleAction;
        SYSTEMTIME              tmSchedule;
        DWORD                   dwReceiptDeliveryType;
        LPWSTR                  lptstrReceiptDeliveryAddress;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        HCALL                   hCall;
        DWORD_PTR               dwReserved[4];
        LPWSTR                  lptstrDocumentName;
        DWORD                   dwPageCount;
} FAX_JOB_PARAM_EXW, *PFAX_JOB_PARAM_EXW;
#ifdef UNICODE
typedef FAX_JOB_PARAM_EXW FAX_JOB_PARAM_EX;
typedef PFAX_JOB_PARAM_EXW PFAX_JOB_PARAM_EX;
#else
typedef FAX_JOB_PARAM_EXA FAX_JOB_PARAM_EX;
typedef PFAX_JOB_PARAM_EXA PFAX_JOB_PARAM_EX;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI FaxEnumJobsExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
);
WINFAXAPI
BOOL
WINAPI FaxEnumJobsExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntries,
    OUT LPDWORD             lpdwJobs
);
#ifdef UNICODE
#define FaxEnumJobsEx  FaxEnumJobsExW
#else
#define FaxEnumJobsEx  FaxEnumJobsExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetJobExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
);
WINFAXAPI
BOOL
WINAPI
FaxGetJobExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntry
);
#ifdef UNICODE
#define FaxGetJobEx  FaxGetJobExW
#else
#define FaxGetJobEx  FaxGetJobExA
#endif // !UNICODE


typedef const FAX_JOB_PARAM_EXW * LPCFAX_JOB_PARAM_EXW;
typedef const FAX_JOB_PARAM_EXA * LPCFAX_JOB_PARAM_EXA;

#ifdef UNICODE
        typedef LPCFAX_JOB_PARAM_EXW LPCFAX_JOB_PARAM_EX;
#else
        typedef LPCFAX_JOB_PARAM_EXA LPCFAX_JOB_PARAM_EX;
#endif


typedef enum
{
    FAX_COVERPAGE_FMT_COV = 1,
    FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY
} FAX_ENUM_COVERPAGE_FORMATS;


typedef struct _FAX_COVERPAGE_INFO_EXA
{
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPSTR   lptstrCoverPageFileName;
    BOOL    bServerBased;
    LPSTR   lptstrNote;
    LPSTR   lptstrSubject;
} FAX_COVERPAGE_INFO_EXA, *PFAX_COVERPAGE_INFO_EXA;
typedef struct _FAX_COVERPAGE_INFO_EXW
{
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPWSTR  lptstrCoverPageFileName;
    BOOL    bServerBased;
    LPWSTR  lptstrNote;
    LPWSTR  lptstrSubject;
} FAX_COVERPAGE_INFO_EXW, *PFAX_COVERPAGE_INFO_EXW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFO_EXW FAX_COVERPAGE_INFO_EX;
typedef PFAX_COVERPAGE_INFO_EXW PFAX_COVERPAGE_INFO_EX;
#else
typedef FAX_COVERPAGE_INFO_EXA FAX_COVERPAGE_INFO_EX;
typedef PFAX_COVERPAGE_INFO_EXA PFAX_COVERPAGE_INFO_EX;
#endif // UNICODE

typedef const FAX_COVERPAGE_INFO_EXW * LPCFAX_COVERPAGE_INFO_EXW;
typedef const FAX_COVERPAGE_INFO_EXA * LPCFAX_COVERPAGE_INFO_EXA;

#ifdef UNICODE
        typedef LPCFAX_COVERPAGE_INFO_EXW LPCFAX_COVERPAGE_INFO_EX;
#else
        typedef LPCFAX_COVERPAGE_INFO_EXA LPCFAX_COVERPAGE_INFO_EX;
#endif


typedef struct _FAX_PERSONAL_PROFILEA
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPSTR      lptstrName;                  // Name of person
    LPSTR      lptstrFaxNumber;             // Fax number
    LPSTR      lptstrCompany;               // Company name
    LPSTR      lptstrStreetAddress;         // Street address
    LPSTR      lptstrCity;                  // City
    LPSTR      lptstrState;                 // State
    LPSTR      lptstrZip;                   // Zip code
    LPSTR      lptstrCountry;               // Country
    LPSTR      lptstrTitle;                 // Title
    LPSTR      lptstrDepartment;            // Department
    LPSTR      lptstrOfficeLocation;        // Office location
    LPSTR      lptstrHomePhone;             // Phone number at home
    LPSTR      lptstrOfficePhone;           // Phone number at office
    LPSTR      lptstrEmail;                 // Personal e-mail address
    LPSTR      lptstrBillingCode;           // Billing code
    LPSTR      lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEA, *PFAX_PERSONAL_PROFILEA;
typedef struct _FAX_PERSONAL_PROFILEW
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPWSTR     lptstrName;                  // Name of person
    LPWSTR     lptstrFaxNumber;             // Fax number
    LPWSTR     lptstrCompany;               // Company name
    LPWSTR     lptstrStreetAddress;         // Street address
    LPWSTR     lptstrCity;                  // City
    LPWSTR     lptstrState;                 // State
    LPWSTR     lptstrZip;                   // Zip code
    LPWSTR     lptstrCountry;               // Country
    LPWSTR     lptstrTitle;                 // Title
    LPWSTR     lptstrDepartment;            // Department
    LPWSTR     lptstrOfficeLocation;        // Office location
    LPWSTR     lptstrHomePhone;             // Phone number at home
    LPWSTR     lptstrOfficePhone;           // Phone number at office
    LPWSTR     lptstrEmail;                 // Personal e-mail address
    LPWSTR     lptstrBillingCode;           // Billing code
    LPWSTR     lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEW, *PFAX_PERSONAL_PROFILEW;
#ifdef UNICODE
typedef FAX_PERSONAL_PROFILEW FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEW PFAX_PERSONAL_PROFILE;
#else
typedef FAX_PERSONAL_PROFILEA FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEA PFAX_PERSONAL_PROFILE;
#endif // UNICODE

typedef const FAX_PERSONAL_PROFILEW * LPCFAX_PERSONAL_PROFILEW;
typedef const FAX_PERSONAL_PROFILEA * LPCFAX_PERSONAL_PROFILEA;

#ifdef UNICODE
        typedef LPCFAX_PERSONAL_PROFILEW LPCFAX_PERSONAL_PROFILE;
#else
        typedef LPCFAX_PERSONAL_PROFILEA LPCFAX_PERSONAL_PROFILE;
#endif


BOOL WINAPI FaxSendDocumentExA
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
BOOL WINAPI FaxSendDocumentExW
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
#ifdef UNICODE
#define FaxSendDocumentEx  FaxSendDocumentExW
#else
#define FaxSendDocumentEx  FaxSendDocumentExA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTEXA)(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpcJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTEXW)(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpcJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
#ifdef UNICODE
#define PFAXSENDDOCUMENTEX  PFAXSENDDOCUMENTEXW
#else
#define PFAXSENDDOCUMENTEX  PFAXSENDDOCUMENTEXA
#endif // !UNICODE


//********************************************
//*               Archive jobs
//********************************************

typedef struct _FAX_MESSAGEA
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwValidityMask;
        DWORDLONG               dwlMessageId;
        DWORDLONG               dwlBroadcastId;
        DWORD                   dwJobType;
        DWORD                   dwQueueStatus;
        DWORD                   dwExtendedStatus;
        LPCSTR                  lpctstrExtendedStatus;
        DWORD                   dwSize;
        DWORD                   dwPageCount;
        LPCSTR                  lpctstrRecipientNumber;
        LPCSTR                  lpctstrRecipientName;
        LPCSTR                  lpctstrSenderNumber;
        LPCSTR                  lpctstrSenderName;
        LPCSTR                  lpctstrTsid;
        LPCSTR                  lpctstrCsid;
        LPCSTR                  lpctstrSenderUserName;
        LPCSTR                  lpctstrBillingCode;
        SYSTEMTIME              tmOriginalScheduleTime;
        SYSTEMTIME              tmSubmissionTime;
        SYSTEMTIME              tmTransmissionStartTime;
        SYSTEMTIME              tmTransmissionEndTime;
        LPCSTR                  lpctstrDeviceName;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        DWORD                   dwRetries;
        LPCSTR                  lpctstrDocumentName;
        LPCSTR                  lpctstrSubject;
        LPCSTR                  lpctstrCallerID;
        LPCSTR                  lpctstrRoutingInfo;
} FAX_MESSAGEA, *PFAX_MESSAGEA;
typedef struct _FAX_MESSAGEW
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwValidityMask;
        DWORDLONG               dwlMessageId;
        DWORDLONG               dwlBroadcastId;
        DWORD                   dwJobType;
        DWORD                   dwQueueStatus;
        DWORD                   dwExtendedStatus;
        LPCWSTR                 lpctstrExtendedStatus;
        DWORD                   dwSize;
        DWORD                   dwPageCount;
        LPCWSTR                 lpctstrRecipientNumber;
        LPCWSTR                 lpctstrRecipientName;
        LPCWSTR                 lpctstrSenderNumber;
        LPCWSTR                 lpctstrSenderName;
        LPCWSTR                 lpctstrTsid;
        LPCWSTR                 lpctstrCsid;
        LPCWSTR                 lpctstrSenderUserName;
        LPCWSTR                 lpctstrBillingCode;
        SYSTEMTIME              tmOriginalScheduleTime;
        SYSTEMTIME              tmSubmissionTime;
        SYSTEMTIME              tmTransmissionStartTime;
        SYSTEMTIME              tmTransmissionEndTime;
        LPCWSTR                 lpctstrDeviceName;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        DWORD                   dwRetries;
        LPCWSTR                 lpctstrDocumentName;
        LPCWSTR                 lpctstrSubject;
        LPCWSTR                 lpctstrCallerID;
        LPCWSTR                 lpctstrRoutingInfo;
} FAX_MESSAGEW, *PFAX_MESSAGEW;
#ifdef UNICODE
typedef FAX_MESSAGEW FAX_MESSAGE;
typedef PFAX_MESSAGEW PFAX_MESSAGE;
#else
typedef FAX_MESSAGEA FAX_MESSAGE;
typedef PFAX_MESSAGEA PFAX_MESSAGE;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxStartMessagesEnum (
    IN  HANDLE                  hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PHANDLE                 phEnum
);

WINFAXAPI
BOOL
WINAPI
FaxEndMessagesEnum (
    IN  HANDLE  hEnum
);

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesA (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEA  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
);
WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesW (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEW  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
);
#ifdef UNICODE
#define FaxEnumMessages  FaxEnumMessagesW
#else
#define FaxEnumMessages  FaxEnumMessagesA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetMessageA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEA          *ppMsg
);
WINFAXAPI
BOOL
WINAPI
FaxGetMessageW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEW          *ppMsg
);
#ifdef UNICODE
#define FaxGetMessage  FaxGetMessageW
#else
#define FaxGetMessage  FaxGetMessageA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveMessage (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder
);

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCSTR                lpctstrFilePath
);
WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCWSTR                lpctstrFilePath
);
#ifdef UNICODE
#define FaxGetMessageTiff  FaxGetMessageTiffW
#else
#define FaxGetMessageTiff  FaxGetMessageTiffA
#endif // !UNICODE

//************************************
//*     Non-RPC extended interfaces
//************************************

HRESULT WINAPI
FaxFreeSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );

HRESULT WINAPI
FaxSetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );

HRESULT WINAPI
FaxGetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );


//********************************************
//*                 Security
//********************************************
//
//  Specific access rights
//
typedef enum
{
    FAX_ACCESS_SUBMIT                   = 0x0001,
    FAX_ACCESS_SUBMIT_NORMAL            = 0x0002,
    FAX_ACCESS_SUBMIT_HIGH              = 0x0004,
    FAX_ACCESS_QUERY_JOBS               = 0x0008,
    FAX_ACCESS_MANAGE_JOBS              = 0x0010,
    FAX_ACCESS_QUERY_CONFIG             = 0x0020,
    FAX_ACCESS_MANAGE_CONFIG            = 0x0040,
    FAX_ACCESS_QUERY_IN_ARCHIVE         = 0x0080,
    FAX_ACCESS_MANAGE_IN_ARCHIVE        = 0x0100,
    FAX_ACCESS_QUERY_OUT_ARCHIVE        = 0x0200,
    FAX_ACCESS_MANAGE_OUT_ARCHIVE       = 0x0400
} FAX_SPECIFIC_ACCESS_RIGHTS;

#define FAX_GENERIC_READ    (FAX_ACCESS_QUERY_JOBS | FAX_ACCESS_QUERY_CONFIG | FAX_ACCESS_QUERY_IN_ARCHIVE | FAX_ACCESS_QUERY_OUT_ARCHIVE)
#define FAX_GENERIC_WRITE   (FAX_ACCESS_MANAGE_JOBS | FAX_ACCESS_MANAGE_CONFIG | FAX_ACCESS_MANAGE_IN_ARCHIVE | FAX_ACCESS_MANAGE_OUT_ARCHIVE)
#define FAX_GENERIC_EXECUTE (FAX_ACCESS_SUBMIT)
#define FAX_GENERIC_ALL     (FAX_ACCESS_SUBMIT                  |       \
                             FAX_ACCESS_SUBMIT_NORMAL           |       \
                             FAX_ACCESS_SUBMIT_HIGH             |       \
                             FAX_ACCESS_QUERY_JOBS              |       \
                             FAX_ACCESS_MANAGE_JOBS             |       \
                             FAX_ACCESS_QUERY_CONFIG            |       \
                             FAX_ACCESS_MANAGE_CONFIG           |       \
                             FAX_ACCESS_QUERY_IN_ARCHIVE        |       \
                             FAX_ACCESS_MANAGE_IN_ARCHIVE       |       \
                             FAX_ACCESS_QUERY_OUT_ARCHIVE       |       \
                             FAX_ACCESS_MANAGE_OUT_ARCHIVE)



//
//  Functions
//


//********************************************
//*              Security
//********************************************
WINFAXAPI
BOOL
WINAPI
FaxGetSecurity (
    IN  HANDLE                  hFaxHandle,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
);

WINFAXAPI
BOOL
WINAPI
FaxGetSecurityEx (
    IN  HANDLE                  hFaxHandle,
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
);

WINFAXAPI
BOOL
WINAPI
FaxSetSecurity (
    IN HANDLE                       hFaxHandle,
    IN SECURITY_INFORMATION         SecurityInformation,
    IN CONST PSECURITY_DESCRIPTOR   pSecDesc
);




WINFAXAPI
BOOL
WINAPI
FaxAccessCheckEx (
    IN  HANDLE          FaxHandle,
    IN  DWORD           AccessMask,
    OUT LPDWORD         lpdwRights
    );


//********************************************
//*              Extension data
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataA (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
);
WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataW (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCWSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
);
#ifdef UNICODE
#define FaxGetExtensionData  FaxGetExtensionDataW
#else
#define FaxGetExtensionData  FaxGetExtensionDataA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataA (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
);
WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataW (
    IN HANDLE    